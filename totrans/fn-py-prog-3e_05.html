<html><head></head><body>
<section id="chapter-5-higher-order-functions" class="level2 chapterHead" data-number="0.9">&#13;
<h2 class="chapterHead" data-number="0.9"><span class="titlemark"> 5</span><br/>&#13;
<span id="x1-1000005"/>Higher-Order Functions</h2>&#13;
<p>A very important feature of the functional programming paradigm is higher-order functions. We’ll look at these three varieties<span id="dx1-100001"/> of higher-order functions:</p>&#13;
<ul>&#13;
<li><p>Functions that accept functions as one (or more) of their arguments</p></li>&#13;
<li><p>Functions that return a function</p></li>&#13;
<li><p>Functions that accept a function and return a function, a combination of the preceding two features</p></li>&#13;
</ul>&#13;
<p>We’ll look at the built-in higher-order functions in this chapter. Separate from these functions, we’ll look at a few of the library modules that offer higher-order functions in later chapters after introducing the concepts here.</p>&#13;
<p>Functions that accept functions and create functions include complex callable classes as well as function decorators. We’ll defer consideration of decorators until <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 12</span></a>, <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Decorator Design Techniques</span></a>.</p>&#13;
<p>In this chapter, we’ll look at the following functions:</p>&#13;
<ul>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span></p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span></p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span></p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span></p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">sorted()</code></span></span></p></li>&#13;
</ul>&#13;
<p>Additionally, we’ll look at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itemgetter()</code></span></span> function in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator</code></span></span> module. This function is useful for extracting an item from a sequence.</p>&#13;
<p>We’ll also look at lambda forms that we can use to simplify using higher-order functions.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span> functions are reductions; they create a single value from a collection. The other functions<span id="dx1-100002"/> are mappings.<span id="dx1-100003"/> They don’t reduce the input to a single value.</p>&#13;
<div id="tcolobox-90" class="packt_tip">&#13;
&#13;
&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">sorted()</code></span></span> functions have both a default behavior as well as a higher-order function behavior. If needed, a function can be provided via the <span class="obeylines-h"><span class="verb"><code class="inlineCode">key=</code></span></span> argument. There is a meaningful default behavior for these functions.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> functions take the function as the first positional argument. Here, the function is required because there is no default behavior.</p>&#13;
&#13;
</div>&#13;
<p>There are a number of higher-order functions in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module. We’ll look at this module in <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 8</span></a>, <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">The Itertools Module</span></a>, and <a href="Chapter_09.xhtml#x1-1990009"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 9</span></a>, <a href="Chapter_09.xhtml#x1-1990009"><span class="cmti-10x-x-109">Itertools</span> <span class="cmti-10x-x-109">for Combinatorics – Permutations and Combinations</span></a>.</p>&#13;
<p>Additionally, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools</code></span></span> module provides a general-purpose <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function. We’ll look at this in <a href="Chapter_10.xhtml#x1-21700010"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 10</span></a>, <a href="Chapter_10.xhtml#x1-21700010"><span class="cmti-10x-x-109">The Functools Module</span></a>, because it requires a bit more care to use. We need to avoid transforming an inefficient algorithm into a nightmare of excessive processing. <span id="x1-100004r100"/></p>&#13;
<section id="using-max-and-min-to-find-extrema" class="level3 sectionHead" data-number="0.9.1">&#13;
<h3 class="sectionHead" data-number="0.9.1"><span class="titlemark">5.1 </span> <span id="x1-1010001"/>Using max() and min() to find extrema</h3>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span> functions<span id="dx1-101001"/> each have a dual life. They are simple functions<span id="dx1-101002"/> that apply to collections. They are also higher-order functions. We can see their default behavior as follows:</p>&#13;
<div id="tcolobox-91" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; max(1, 2, 3) &#13;
3 &#13;
&gt;&gt;&gt; max((1,2,3,4)) &#13;
4</code></pre>&#13;
&#13;
</div>&#13;
<p>Both functions will accept an indefinite number of arguments. The functions are designed to also accept a sequence or an iterable as the only argument and locate the max (or min) of that iterable. When applied to a mapping<span id="dx1-101008"/> collection, they will locate the maximum (or minimum) key value.</p>&#13;
<p>They also do something more sophisticated. Let’s say we have our trip data from the examples in <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>. We have a function that will generate a sequence of tuples that looks as follows:</p>&#13;
<div id="tcolobox-92" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>[ &#13;
 ((37.54901619777347, -76.33029518659048), (37.840832, -76.273834), 17.7246), &#13;
 ((37.840832, -76.273834), (38.331501, -76.459503), 30.7382), &#13;
 ((38.331501, -76.459503), (38.845501, -76.537331), 31.0756), &#13;
 ((36.843334, -76.298668), (37.549, -76.331169), 42.3962), &#13;
 ((37.549, -76.331169), (38.330166, -76.458504), 47.2866), &#13;
 ((38.330166, -76.458504), (38.976334, -76.473503), 38.8019) &#13;
]</code></pre>&#13;
&#13;
</div>&#13;
<p>Each tuple in this collection<span id="dx1-101018"/> has three values: a starting location, an ending location, and a distance. The locations are given in latitude and longitude pairs. The east latitude is positive; these are points along the US East Coast, about 76<span class="tcrm-1095">° </span>west. The distances between points are in nautical miles.</p>&#13;
<p>We have three ways of getting the maximum and minimum distances from this sequence of values. They are as follows:</p>&#13;
<ul>&#13;
<li><p>Extract the distance with a generator function. This will give us only the distances, as we’ve discarded the other two attributes of each leg. This won’t work out well if we have any additional processing requirements based on the latitude or longitude.</p></li>&#13;
<li><p>Use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">unwrap(process(wrap()))</code></span></span> pattern. This will give us the legs with the longest and shortest distances. From these, we can extract the distance or the point as needed.</p></li>&#13;
<li><p>Use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span> functions as higher-order functions, inserting a function<span id="dx1-101019"/> that does the extraction of the important distance values. This will also preserve the original objects with all of their attributes.</p></li>&#13;
</ul>&#13;
<p>To provide context, the following<span id="dx1-101020"/> script builds the overall trip:</p>&#13;
<div id="tcolobox-93" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from Chapter04.ch04_ex1 import ( &#13;
...    floats_from_pair, float_lat_lon, row_iter_kml, haversine, legs &#13;
... ) &#13;
&gt;&gt;&gt; import urllib.request &#13;
&gt;&gt;&gt; data = "file:./Winter%202012-2013.kml" &#13;
 &#13;
&gt;&gt;&gt; with urllib.request.urlopen(data) as source: &#13;
...     path = floats_from_pair(float_lat_lon(row_iter_kml(source))) &#13;
...     trip = list( &#13;
...         (start, end, round(haversine(start, end), 4)) &#13;
...         for start, end in legs(path) &#13;
...     )</code></pre>&#13;
&#13;
</div>&#13;
<p>The resulting <span class="obeylines-h"><span class="verb"><code class="inlineCode">trip</code></span></span> object is a list object, containing the individual legs. Each leg is a three-tuple with the starting point, the ending point, and the distance, computed with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">haversine()</code></span></span> function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">leg()</code></span></span> function creates start-end pairs from the overall path of points in the original KML file. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">list()</code></span></span> function consumes values from the lazy generator to materialize the list of legs.</p>&#13;
<p>Once we have the <span class="obeylines-h"><span class="verb"><code class="inlineCode">trip</code></span></span> object, we can extract distances and compute the maximum and minimum of those distances. The code to do this with a generator function looks as follows:</p>&#13;
<div id="tcolobox-94" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; longest = max(dist for start, end, dist in trip) &#13;
&gt;&gt;&gt; shortest = min(dist for start, end, dist in trip)</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve used a generator function to extract the relevant item from each leg of the trip tuple. We’ve had to repeat the generator expression because the expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">dist</code><code class="inlineCode"> for</code><code class="inlineCode"> start,</code><code class="inlineCode"> end,</code><code class="inlineCode"> dist</code><code class="inlineCode"> in</code><code class="inlineCode"> trip</code></span></span> can be consumed only once.</p>&#13;
<p>Here are the results<span id="dx1-101037"/> based on a larger set of data than was shown previously:</p>&#13;
<div id="tcolobox-95" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; longest &#13;
129.7748 &#13;
&gt;&gt;&gt; shortest &#13;
0.1731</code></pre>&#13;
&#13;
</div>&#13;
<p>It may help to refer to <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 2</span></a>, <a href="Chapter_02.xhtml#x1-340002"><span class="cmti-10x-x-109">Introducing Essential Functional Concepts</span></a>, for examples of the wrap-process-unwrap design pattern.</p>&#13;
<p>The following is a version of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">unwrap(process(wrap()))</code></span></span> pattern applied to this data:</p>&#13;
<pre id="listing-85" class="lstlisting"><code>from collections.abc import Iterator, Iterable &#13;
from typing import Any &#13;
 &#13;
def wrap(leg_iter: Iterable[Any]) -&gt; Iterable[tuple[Any, Any]]: &#13;
    return ((leg[2], leg) for leg in leg_iter) &#13;
 &#13;
def unwrap(dist_leg: tuple[Any, Any]) -&gt; Any: &#13;
    distance, leg = dist_leg &#13;
    return leg</code></pre>&#13;
<p>We can use these functions<span id="dx1-101052"/> as follows:</p>&#13;
<div id="tcolobox-96" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; longest = unwrap(max(wrap(trip))) &#13;
&gt;&gt;&gt; longest &#13;
((27.154167, -80.195663), (29.195168, -81.002998), 129.7748) &#13;
 &#13;
&gt;&gt;&gt; short = unwrap(min(wrap(trip))) &#13;
&gt;&gt;&gt; short &#13;
((35.505665, -76.653664), (35.508335, -76.654999), 0.1731)</code></pre>&#13;
&#13;
</div>&#13;
<p>The final and most important form uses the higher-order function feature of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span> functions. We’ll define a helper function first and then use it to reduce the collection of legs to the desired summaries by executing the following code snippet:</p>&#13;
<pre id="listing-86" class="lstlisting"><code>def by_dist(leg: tuple[Any, Any, Any]) -&gt; Any: &#13;
    lat, lon, dist = leg &#13;
    return dist</code></pre>&#13;
<p>We can use this function<span id="dx1-101064"/> as the <span class="obeylines-h"><span class="verb"><code class="inlineCode">key=</code></span></span> argument value to the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function. It looks like the following:</p>&#13;
<div id="tcolobox-97" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; longest = max(trip, key=by_dist) &#13;
&gt;&gt;&gt; longest &#13;
((27.154167, -80.195663), (29.195168, -81.002998), 129.7748) &#13;
 &#13;
&gt;&gt;&gt; short = min(trip, key=by_dist) &#13;
&gt;&gt;&gt; short &#13;
((35.505665, -76.653664), (35.508335, -76.654999), 0.1731)</code></pre>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">by_dist()</code></span></span> function<span id="dx1-101073"/> picks apart the three items in each leg tuple and returns the distance item. We’ll use this with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span> functions.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span> functions both accept an iteratable and a function as arguments. The keyword parameter <span class="obeylines-h"><span class="verb"><code class="inlineCode">key=</code></span></span> is used by many of Python’s higher-order functions to provide a function that will be used to extract the necessary key value. <span id="x1-101074r105"/></p>&#13;
<section id="using-python-lambda-forms" class="level4 subsectionHead" data-number="0.9.1.1">&#13;
<h4 class="subsectionHead" data-number="0.9.1.1"><span class="titlemark">5.1.1 </span> <span id="x1-1020001"/>Using Python lambda forms</h4>&#13;
<p>In many cases, the definition<span id="dx1-102001"/> of a helper function seems to require too much code. Often, we can digest the <span class="obeylines-h"><span class="verb"><code class="inlineCode">key=</code></span></span> function to a single expression. It can seem wasteful to have to write both <span class="obeylines-h"><span class="verb"><code class="inlineCode">def</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">return</code></span></span> statements to wrap a single expression.</p>&#13;
<p>Python offers the lambda form as a way to simplify using higher-order functions. A lambda form allows us to define a small, anonymous function. The function’s body is limited to a single expression.</p>&#13;
<p>The following is an example of using a simple lambda expression as the <span class="obeylines-h"><span class="verb"><code class="inlineCode">key=</code></span></span> function:</p>&#13;
<div id="tcolobox-98" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; longest = max(trip, key=lambda leg: leg[2]) &#13;
&gt;&gt;&gt; shortest = min(trip, key=lambda leg: leg[2])</code></pre>&#13;
&#13;
</div>&#13;
<p>The lambda we’ve used will be given an item from the sequence; in this case, each leg three-tuple will be given to the lambda. The lambda argument variable, <span class="obeylines-h"><span class="verb"><code class="inlineCode">leg</code></span></span>, is assigned and the expression, <span class="obeylines-h"><span class="verb"><code class="inlineCode">leg[2]</code></span></span>, is evaluated, plucking the distance from the three-tuple.</p>&#13;
<p>In cases where a lambda<span id="dx1-102005"/> is used exactly once, this form is ideal. When reusing a lambda, it’s important to avoid copy and paste. In the above example, the lambda is repeated, a potential software maintenance nightmare. What’s the alternative?</p>&#13;
<p>We can assign lambdas to variables, by doing something like this:</p>&#13;
<pre id="listing-87" class="lstlisting"><code>start = lambda x: x[0] &#13;
end = lambda x: x[1] &#13;
dist = lambda x: x[2]</code></pre>&#13;
<p>Each of these lambda forms is a callable object, similar to a defined function. They can be used like a function.</p>&#13;
<p>The following is an example at the interactive prompt:</p>&#13;
<div id="tcolobox-99" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; longest = ((27.154167, -80.195663), (29.195168, -81.002998), 129.7748) &#13;
&gt;&gt;&gt; dist(longest) &#13;
129.7748</code></pre>&#13;
&#13;
</div>&#13;
<p>Here are two reasons for avoiding this technique:</p>&#13;
<ul>&#13;
<li><p>PEP 8, the style guide for Python code, advises against assigning lambda objects to variables. See <a href="https://peps.python.org/pep-0008/" class="url">https://peps.python.org/pep-0008/</a> for more information.</p></li>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator</code></span></span> module provides a generic item getter, <span class="obeylines-h"><span class="verb"><code class="inlineCode">itemgetter()</code></span></span>. This is a higher-order function that returns a function we can use instead of a lambda object.</p></li>&#13;
</ul>&#13;
<p>To extend this example, we’ll look at how we get the latitude or longitude value of the starting or ending point.</p>&#13;
<p>The following is a continuation of the interactive session:</p>&#13;
<div id="tcolobox-100" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from operator import itemgetter &#13;
&gt;&gt;&gt; start = itemgetter(0) &#13;
&gt;&gt;&gt; start(longest) &#13;
(27.154167, -80.195663) &#13;
 &#13;
&gt;&gt;&gt; lat = itemgetter(0) &#13;
&gt;&gt;&gt; lon = itemgetter(1) &#13;
&gt;&gt;&gt; lat(start(longest)) &#13;
27.154167</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve imported the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itemgetter()</code></span></span> function from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator</code></span></span> module. The value returned by this function is a function<span id="dx1-102023"/> that will grab the requested item from a sequence. In the first part of the example, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">start()</code></span></span> function will extract item <span class="obeylines-h"><span class="verb"><code class="inlineCode">0</code></span></span> from a sequence.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">lat()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">lon()</code></span></span> functions, similarly, are created by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itemgetter()</code></span></span> function. Note that the complexity of the nested tuples in the data structure must be carefully paralleled with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itemgetter()</code></span></span> functions.</p>&#13;
<p>There’s no clear advantage to using lambda objects or <span class="obeylines-h"><span class="verb"><code class="inlineCode">itemgetter()</code></span></span> functions as a way to extract fields over defining a <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing.NamedTuple</code></span></span> class or a dataclass. Using lambdas (or better, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itemgetter()</code></span></span> function) does allow the code to rely on prefix function notation, which might be easier to read in a functional programming context. We can gain a similar advantage by using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.attrgetter</code></span></span> function to extract a specific attribute from a <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing.NamedTuple</code></span></span> class or dataclass. Using <span class="obeylines-h"><span class="verb"><code class="inlineCode">attrgetter</code></span></span> duplicates a name. For example, a <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing.NamedTuple</code></span></span> class with an attribute of <span class="obeylines-h"><span class="verb"><code class="inlineCode">lat</code></span></span> may also use <span class="obeylines-h"><span class="verb"><code class="inlineCode">attrgetter(’lat’)</code></span></span>; this can make it slightly harder to locate all references to an attribute when refactoring. <span id="x1-102024r109"/></p>&#13;
</section>&#13;
<section id="lambdas-and-the-lambda-calculus" class="level4 subsectionHead" data-number="0.9.1.2">&#13;
<h4 class="subsectionHead" data-number="0.9.1.2"><span class="titlemark">5.1.2 </span> <span id="x1-1030002"/>Lambdas and the lambda calculus</h4>&#13;
<p>If Python were a purely functional programming language, it would be necessary to explain Church’s lambda<span id="dx1-103001"/> calculus, and the technique<span id="dx1-103002"/> invented by Haskell Curry that we call <span class="keyWord">currying</span>. Python, however, doesn’t stick closely to the lambda calculus. Functions are not curried to reduce them to single-argument lambda forms.</p>&#13;
<p>Python lambda forms are not restricted to single-argument functions. They can have any number of arguments. They are restricted to a single expression, however.</p>&#13;
<p>We can, using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools.partial</code></span></span> function, implement currying. We’ll save this for <a href="Chapter_10.xhtml#x1-21700010"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 10</span></a>, <a href="Chapter_10.xhtml#x1-21700010"><span class="cmti-10x-x-109">The Functools Module</span></a>. <span id="x1-103003r108"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="using-the-map-function-to-apply-a-function-to-a-collection" class="level3 sectionHead" data-number="0.9.2">&#13;
<h3 class="sectionHead" data-number="0.9.2"><span class="titlemark">5.2 </span> <span id="x1-1040002"/>Using the map() function to apply a function to a collection</h3>&#13;
<p>A scalar function<span id="dx1-104001"/> maps values from a domain<span id="dx1-104002"/> to a range. When we look at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">math.sqrt()</code></span></span> function, as an example, we’re looking at a mapping from a float value, <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code></span></span>, to another float value, <span class="obeylines-h"><span class="verb"><code class="inlineCode">y</code><code class="inlineCode"> =</code><code class="inlineCode"> sqrt(x)</code></span></span>, such that <span class="italic">y</span><sup><span class="cmr-8">2</span></sup> = <span class="italic">x</span>. The domain is limited to non-negative values for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">math</code></span></span> module. When using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">cmath</code></span></span> module, any number can be used, and the results can be complex numbers.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function expresses a similar concept; it maps values from one collection to create another collection. It assures that the given function is used to map each individual item from the domain collection to the range collection—this is the ideal way to apply a built-in function to a collection of data.</p>&#13;
<p>Our first example involves parsing a block of text to get a sequence of numbers. Let’s say we have the following chunk of text:</p>&#13;
<div id="tcolobox-101" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; text= """\ &#13;
... 2 3 5 7 11 13 17 19 23 29 &#13;
... 31 37 41 43 47 53 59 61 67 71 &#13;
... 73 79 83 89 97 101 103 107 109 113 &#13;
... 127 131 137 139 149 151 157 163 167 173 &#13;
... 179 181 191 193 197 199 211 223 227 229 &#13;
... """</code></pre>&#13;
&#13;
</div>&#13;
<p>We can restructure this text using the following generator<span id="dx1-104011"/> function:</p>&#13;
<div id="tcolobox-102" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; data = list( &#13;
...     v &#13;
...     for line in text.splitlines() &#13;
...         for v in line.split() &#13;
... )</code></pre>&#13;
&#13;
</div>&#13;
<p>This will split the text into lines. For each line, it will split the line into space-delimited words and iterate through each of the resulting strings. The results look as follows:</p>&#13;
<div id="tcolobox-103" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>[’2’, ’3’, ’5’, ’7’, ’11’, ’13’, ’17’, ’19’, ’23’, ’29’, &#13;
’31’, ’37’, ’41’, ’43’, ’47’, ’53’, ’59’, ’61’, ’67’, ’71’, &#13;
’73’, ’79’, ’83’, ’89’, ’97’, ’101’, ’103’, ’107’, ’109’, ’113’, &#13;
’127’, ’131’, ’137’, ’139’, ’149’, ’151’, ’157’, ’163’, ’167’, &#13;
’173’, ’179’, ’181’, ’191’, ’193’, ’197’, ’199’, ’211’, ’223’, &#13;
’227’, ’229’]</code></pre>&#13;
&#13;
</div>&#13;
<p>We still need to apply the <span class="obeylines-h"><span class="verb"><code class="inlineCode">int()</code></span></span> function to each of the string values. This is where the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function excels. Take a look at the following code snippet:</p>&#13;
<div id="tcolobox-104" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; list(map(int, data)) &#13;
[2, 3, 5, 7, 11, 13, 17, 19, ..., 229]</code></pre>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function applied the <span class="obeylines-h"><span class="verb"><code class="inlineCode">int()</code></span></span> function to each value in the collection. The result is a sequence of numbers instead of a sequence of strings.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function’s results are iterable. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function can process any type of iterable.</p>&#13;
<p>The idea here is that any Python function can be applied to the items of a collection using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function. There are a lot of built-in functions that can be used in this map-processing context. <span id="x1-104028r110"/></p>&#13;
<section id="working-with-lambda-forms-and-map" class="level4 subsectionHead" data-number="0.9.2.1">&#13;
<h4 class="subsectionHead" data-number="0.9.2.1"><span class="titlemark">5.2.1 </span> <span id="x1-1050001"/>Working with lambda forms and map()</h4>&#13;
<p>Let’s say we want to convert<span id="dx1-105001"/> our trip distances from nautical miles to statute miles. We want to multiply<span id="dx1-105002"/> each leg’s distance by <span class="obeylines-h"><span class="verb"><code class="inlineCode">6076.12/5280</code></span></span>, which is <span class="obeylines-h"><span class="verb"><code class="inlineCode">1.150780</code></span></span>.</p>&#13;
<p>We’ll rely on a number of <span class="obeylines-h"><span class="verb"><code class="inlineCode">itemgetter</code></span></span> functions to extract data from the data structure. We can combine extractions with computation of new values. We can do this calculation with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function as follows:</p>&#13;
<div id="tcolobox-105" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from operator import itemgetter &#13;
&gt;&gt;&gt; start = itemgetter(0) &#13;
&gt;&gt;&gt; end = itemgetter(1) &#13;
&gt;&gt;&gt; dist = itemgetter(2) &#13;
&gt;&gt;&gt; sm_trip = map( &#13;
...     lambda x: (start(x), end(x), dist(x) * 6076.12 / 5280), &#13;
...     trip &#13;
... )</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve defined a lambda that will be applied to each leg in the trip by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function. The lambda will use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itemgetter</code></span></span> function to separate the start, end, and distance values from each leg’s tuple. It will compute a revised distance and assemble a new leg tuple from the start, end, and statute mile distances.</p>&#13;
<p>This is precisely like the following generator expression:</p>&#13;
<div id="tcolobox-106" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; sm_trip = ( &#13;
...     (start(x), end(x), dist(x) * 6076.12 / 5280) &#13;
...     for x in trip &#13;
... )</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve done the same processing on each item in the generator expression.</p>&#13;
<p>Using the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function or a generator expression will produce identical results and have nearly identical performance. The choice of using lambdas, named tuples, defined functions, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.itemgetter()</code></span></span> function, or generator<span id="dx1-105017"/> expressions is entirely a matter of how to make the resulting application program succinct and expressive. <span id="x1-105018r112"/></p>&#13;
</section>&#13;
<section id="using-map-with-multiple-sequences" class="level4 subsectionHead" data-number="0.9.2.2">&#13;
<h4 class="subsectionHead" data-number="0.9.2.2"><span class="titlemark">5.2.2 </span> <span id="x1-1060002"/>Using map() with multiple sequences</h4>&#13;
<p>Sometimes, we’ll have two collections<span id="dx1-106001"/> of data that need to be parallel to each other. In <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, we saw how the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function can interleave two sequences to create a sequence of pairs. In many cases, we’re really trying to do something like the following:</p>&#13;
<pre id="listing-88" class="lstlisting"><code>map(function, zip(one_iterable, another_iterable))</code></pre>&#13;
<p>We’re creating argument tuples from two (or more) parallel iterables and applying a function to the argument tuple. This can be awkward because the parameters to the given function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">function()</code></span></span>, will be a single two-tuple; the argument values will not be applied to each parameter.</p>&#13;
<p>As a consequence, we can think about using the following technique to decompose the tuple into two individual parameters:</p>&#13;
<pre id="listing-89" class="lstlisting"><code>( &#13;
    function(x, y) &#13;
    for x, y in zip(one_iterable, another_iterable) &#13;
)</code></pre>&#13;
<p>Here, we’ve replaced the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function with an equivalent generator expression. <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code><code class="inlineCode"> x,</code><code class="inlineCode"> y</code></span></span> decomposes the two-tuples so we can apply them to each parameter of the function.</p>&#13;
<p>There is a better approach that is already available to us. Let’s look at a concrete example of the alternate approach.</p>&#13;
<p>In <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, we looked at trip data that we extracted from an XML file as a series of waypoints. We needed to create legs from this list of waypoints that show the start and end of each leg.</p>&#13;
<p>The following is a simplified<span id="dx1-106007"/> version that uses the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function applied to two slices of a sequence:</p>&#13;
&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&#13;
&gt;&gt;&gt; waypoints = range(4)&#13;
&gt;&gt;&gt; zip(waypoints, waypoints[1:])&#13;
&lt;zip object at ...&gt;&#13;
&#13;
&gt;&gt;&gt; list(zip(waypoints, waypoints[1:]))&#13;
[(0, 1), (1, 2), (2, 3)]&#13;
</code></pre>&#13;
&#13;
&#13;
<p>We’ve created a sequence of pairs drawn from a single flat list. Each pair will have two adjacent values. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function stops when the shorter list is exhausted. This <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip(x,</code><code class="inlineCode"> x[1:])</code></span></span> pattern only works for materialized sequences and the iterable created by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">range()</code></span></span> function. It won’t work for iterable objects because the slicing operation isn’t implemented.</p>&#13;
<p>We created pairs so that we can apply the <span class="obeylines-h"><span class="verb"><code class="inlineCode">haversine()</code></span></span> function to each pair to compute the distance between the two points on the path. The following is how it looks in one sequence of steps:</p>&#13;
<div id="tcolobox-107" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from Chapter04.ch04_ex1 import ( &#13;
...    floats_from_pair, float_lat_lon, row_iter_kml, haversine &#13;
... ) &#13;
&gt;&gt;&gt; import urllib.request &#13;
 &#13;
&gt;&gt;&gt; data = "file:./Winter%202012-2013.kml" &#13;
&gt;&gt;&gt; with urllib.request.urlopen(data) as source: &#13;
...     path_gen = floats_from_pair( &#13;
...         float_lat_lon(row_iter_kml(source))) &#13;
...     path = list(path_gen) &#13;
 &#13;
&gt;&gt;&gt; distances_1 = map( &#13;
...     lambda s_e: (s_e[0], s_e[1], haversine(*s_e)), &#13;
...     zip(path, path[1:]) &#13;
... )</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve built a list of waypoints, and labeled<span id="dx1-106031"/> this with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">path</code></span></span> variable. This is an ordered sequence of latitude-longitude pairs. As we’re going to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip(path,</code><code class="inlineCode"> path[1:])</code></span></span> design pattern, we must have a materialized sequence and not an iterable.</p>&#13;
<p>The results of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function will be pairs that have a start and end. We want our output to be a triple with the start, end, and distance. The lambda we’re using will decompose the original start-end two-tuple and create a new three-tuple from the start, end, and distance.</p>&#13;
<p>We can simplify this by using a clever feature of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function, which is as follows:</p>&#13;
<div id="tcolobox-108" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; distances_2 = map( &#13;
...     lambda s, e: (s, e, haversine(s, e)), &#13;
...     path, path[1:] &#13;
... )</code></pre>&#13;
&#13;
</div>&#13;
<p>Note that we’ve provided a lambda object and two iterables to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function will take the next item from each iterable and apply those two values as the arguments to the given function. In this case, the given function is a lambda that creates the desired three-tuple from the start, end, and distance.</p>&#13;
<p>The formal definition for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function states that it will do <span class="keyWord">star-map</span> processing with an indefinite number of iterables. It will take items from each iterable to create a tuple of argument values for the given function. This saves us from having to add the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip</code></span></span> function to combine sequences. <span id="x1-106037r111"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="using-the-filter-function-to-pass-or-reject-data" class="level3 sectionHead" data-number="0.9.3">&#13;
<h3 class="sectionHead" data-number="0.9.3"><span class="titlemark">5.3 </span> <span id="x1-1070003"/>Using the filter() function to pass or reject data</h3>&#13;
<p>The job of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function<span id="dx1-107001"/> is to use and apply a decision<span id="dx1-107002"/> function called<span id="dx1-107003"/> a <span class="keyWord">predicate </span>to each value in a collection. When the predicate function’s result is true, the value is passed; otherwise, the value is rejected. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module includes <span class="obeylines-h"><span class="verb"><code class="inlineCode">filterfalse()</code></span></span> as a variation on this theme. Refer to <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 8</span></a>, <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">The</span> <span class="cmti-10x-x-109">Itertools Module</span></a>, to understand the usage of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module’s <span class="obeylines-h"><span class="verb"><code class="inlineCode">filterfalse()</code></span></span> function.</p>&#13;
<p>We might apply this to our trip data to create a subset of legs that are over 50 nautical miles long, as follows:</p>&#13;
<div id="tcolobox-109" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; long_legs = list( &#13;
...     filter(lambda leg: dist(leg) &gt;= 50, trip) &#13;
... )</code></pre>&#13;
&#13;
</div>&#13;
<p>The predicate<span id="dx1-107008"/> lambda will be <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span> for long legs, which will be passed. Short legs will be rejected. The output contains the 14 legs that pass this distance test.</p>&#13;
<p>This kind of processing clearly segregates the filter rule <span class="obeylines-h"><span class="verb"><code class="inlineCode">(lambda</code><code class="inlineCode"> leg:</code><code class="inlineCode"> dist(leg)</code><code class="inlineCode"> &gt;=</code><code class="inlineCode"> 50)</code></span></span> from any other processing that creates the trip object or analyzes the long legs.</p>&#13;
<p>For another simple example, look at the following code snippet:</p>&#13;
<div id="tcolobox-110" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; filter(lambda x: x % 3 == 0 or x % 5 == 0, range(10)) &#13;
&lt;filter object at ...&gt; &#13;
&gt;&gt;&gt; sum(_) &#13;
23</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve defined a small lambda to check whether a number is a multiple of three or a multiple of five. We’ve applied that function to an iterable, <span class="obeylines-h"><span class="verb"><code class="inlineCode">range(10)</code></span></span>. The result is an iterable sequence of numbers that are passed by the decision rule.</p>&#13;
<p>The numbers for which the lambda is <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span> are <span class="obeylines-h"><span class="verb"><code class="inlineCode">[0,</code><code class="inlineCode"> 3,</code><code class="inlineCode"> 5,</code><code class="inlineCode"> 6,</code><code class="inlineCode"> 9]</code></span></span>, so these values are passed. As the lambda is <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span> for all other numbers, they are rejected.</p>&#13;
<div id="tcolobox-111" class="packt_tip">&#13;
&#13;
&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">_</code></span></span> variable is a special feature of Python’s REPL. It is implicitly set to the result of an expression. In the previous example, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter(...)</code></span></span> result was assigned to <span class="obeylines-h"><span class="verb"><code class="inlineCode">_</code></span></span>. On the next line, <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum(_)</code></span></span> consumed the values from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter(...)</code></span></span> result.</p>&#13;
<p>This is only available in the REPL, and exists to save us a little bit of typing when we’re exploring complex functions interactively.</p>&#13;
&#13;
</div>&#13;
<p>This can also be done with a generator expression<span id="dx1-107014"/> by executing the following code:</p>&#13;
<div id="tcolobox-112" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; list(x for x in range(10) if x % 3 == 0 or x % 5 == 0) &#13;
[0, 3, 5, 6, 9]</code></pre>&#13;
&#13;
</div>&#13;
<p>We can formalize this using the following set comprehension notation:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file47.jpg" class="math-display" alt="{x | 0 ≤ x &lt; 10 ∧ (x ≡ 0 mod 3 ∨ x ≡ 0 mod 5)} "/>&#13;
</div>&#13;
<p>This says that we’re building a collection of <span class="italic">x </span>values such that <span class="italic">x </span>is in <span class="obeylines-h"><span class="verb"><code class="inlineCode">range(10)</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code><code class="inlineCode"> %</code><code class="inlineCode"> 3</code><code class="inlineCode"> ==</code><code class="inlineCode"> 0</code><code class="inlineCode"> or</code><code class="inlineCode"> x</code><code class="inlineCode"> %</code><code class="inlineCode"> 5</code><code class="inlineCode"> ==</code><code class="inlineCode"> 0</code></span></span>. There’s a very elegant symmetry between the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function and formal mathematical set comprehensions.</p>&#13;
<p>We often want to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function with defined functions instead of lambda forms. The following is an example of reusing a predicate defined earlier:</p>&#13;
<div id="tcolobox-113" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from Chapter02.ch02_ex1 import isprimeg &#13;
 &#13;
&gt;&gt;&gt; list(filter(isprimeg, range(100))) &#13;
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]</code></pre>&#13;
&#13;
</div>&#13;
<p>In this example, we imported a function from another module called <span class="obeylines-h"><span class="verb"><code class="inlineCode">isprimeg()</code></span></span>. We then applied this function to a collection of values to pass the prime numbers and reject any non-prime numbers from the collection.</p>&#13;
<p>This can be a remarkably inefficient way to generate a table of prime numbers. The superficial simplicity of this is the kind of thing lawyers call an <span class="cmti-10x-x-109">attractive</span> <span class="cmti-10x-x-109">nuisance</span>. It looks like it might be fun, but it doesn’t scale well at all. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">isprimeg()</code></span></span> function duplicates all of the testing effort for each new value. Some kind of cache is essential to provide redoing the testing of primality. A better algorithm<span id="dx1-107023"/> is the <span class="keyWord">Sieve of Eratosthenes</span>; this algorithm retains the previously located<span id="dx1-107024"/> prime numbers and uses them to prevent recalculation.</p>&#13;
<p>For more information on primality testing, and this algorithm for finding small prime numbers, see <a href="https://primes.utm.edu/prove/prove2_1.html" class="url">https://primes.utm.edu/prove/prove2_1.html</a>. <span id="x1-107025r113"/></p>&#13;
<section id="using-filter-to-identify-outliers" class="level4 subsectionHead" data-number="0.9.3.1">&#13;
<h4 class="subsectionHead" data-number="0.9.3.1"><span class="titlemark">5.3.1 </span> <span id="x1-1080001"/>Using filter() to identify outliers</h4>&#13;
<p>In the previous chapter, we defined<span id="dx1-108001"/> some useful statistical functions to compute mean and standard deviation and normalize a value. We can use these functions to locate outliers in our trip data. What we can do is apply the <span class="obeylines-h"><span class="verb"><code class="inlineCode">mean()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">stdev()</code></span></span> functions to the distance value in each leg of a trip to get the population mean and standard deviation.</p>&#13;
<p>We can then use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">z()</code></span></span> function to compute a normalized value for each leg. If the normalized value is more than 3, the data is potentially far from the mean. If we reject these outliers, we have a more uniform set of data that’s less likely to harbor reporting or measurement errors.</p>&#13;
<p>The following is how we can tackle this:</p>&#13;
<pre id="listing-90" class="lstlisting"><code>&gt;&gt;&gt; from Chapter04.ch04_ex3 import mean, stdev, z &#13;
 &#13;
&gt;&gt;&gt; dist_data = list(map(dist, trip)) &#13;
&gt;&gt;&gt; μ_d = mean(dist_data) &#13;
&gt;&gt;&gt; σ_d = stdev(dist_data) &#13;
 &#13;
&gt;&gt;&gt; outlier = lambda leg: abs(z(dist(leg), μ_d, σ_d)) &gt; 3 &#13;
 &#13;
&gt;&gt;&gt; list(filter(outlier, trip))</code></pre>&#13;
<p>We’ve mapped the distance function to each leg in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">trip</code></span></span> collection. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">dist()</code></span></span> function is the function created by <span class="obeylines-h"><span class="verb"><code class="inlineCode">itemgetter(2)</code></span></span>. As we’ll do several things with the result, we must materialize a <span class="obeylines-h"><span class="verb"><code class="inlineCode">list</code></span></span> object. We can’t rely on the iterator, as the first function in this sequence of steps will consume all of the iterator’s values. We can then use this extraction to compute population statistics <span class="obeylines-h"><span class="verb"><span class="italic">μ</span><code class="inlineCode">_d</code></span></span> and <span class="obeylines-h"><span class="verb"><span class="italic">σ</span><code class="inlineCode">_d</code></span></span> with the mean and standard deviation.</p>&#13;
<p>Given the mean and standard deviation values, we used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">outlier</code></span></span> lambda to filter our data. If the normalized value is too large, the data is an outlier. The threshold for ”too far from the mean” can vary based<span id="dx1-108011"/> on the kind of distribution. For a normal distribution, the probability of a value being within three standard deviations from the mean is 0.997.</p>&#13;
<p>The result of <span class="obeylines-h"><span class="verb"><code class="inlineCode">list(filter(outlier,</code><code class="inlineCode"> trip))</code></span></span> is a list of two legs that are quite long compared to the rest of the legs in the population. The average distance is about 34 nm, with a standard deviation of 24 nm.</p>&#13;
<div id="tcolobox-114" class="packt_tip">&#13;
&#13;
&#13;
<p>We’re able to decompose a fairly complex problem into a number of independent functions, each of which can be easily tested in isolation. Our processing is a composition of simpler functions. This can lead to succinct, expressive functional programming.</p>&#13;
&#13;
</div>&#13;
<p><span id="x1-108012r114"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="the-iter-function-with-a-sentinel-value" class="level3 sectionHead" data-number="0.9.4">&#13;
<h3 class="sectionHead" data-number="0.9.4"><span class="titlemark">5.4 </span> <span id="x1-1090004"/>The iter() function with a sentinel value</h3>&#13;
<p>The built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> function<span id="dx1-109001"/> creates an iterator<span id="dx1-109002"/> over an object of a collection class. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">list</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">dict</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">set</code></span></span> classes all work with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> function to provide an iterator object for the items in the underlying collection. In most cases, we’ll allow the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement to do this implicitly. In a few cases, however, we need to create an iterator explicitly. One example of this is to separate the head from the tail of a collection.</p>&#13;
<p>Other uses of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> function include building iterators to consume the values created by a callable object (for example, a function) until a sentinel value is found. This feature is sometimes used with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">read()</code></span></span> method of a file to consume items until some end-of-line or end-of-file sentinel value is found. An expression such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter(file.read,</code><code class="inlineCode"> ’\n’)</code></span></span> will evaluate the given function until the sentinel value, <span class="obeylines-h"><span class="verb"><code class="inlineCode">’\n’</code></span></span>, is found. This must be used carefully: if the sentinel is not found, it can continue reading zero-length strings forever.</p>&#13;
<p>Providing a callable function to <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> can be a bit challenging because the function we provide must maintain some state internally. This is generally looked at as undesirable in functional programs.</p>&#13;
<p>However, hidden state is a feature of an open file: each <span class="obeylines-h"><span class="verb"><code class="inlineCode">read()</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">readline()</code></span></span> method of a file advances the internal state to the next character or the next line.</p>&#13;
<p>Another example of explicit iteration is the way that a mutable collection object’s <span class="obeylines-h"><span class="verb"><code class="inlineCode">pop()</code></span></span> method makes a stateful change to a collection object. The following is an example of using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pop()</code></span></span> method:</p>&#13;
<div id="tcolobox-115" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; source = [1, 2, 3, None, 4, 5, 6] &#13;
&gt;&gt;&gt; tail = iter(source.pop, None) &#13;
&gt;&gt;&gt; list(tail) &#13;
[6, 5, 4]</code></pre>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">tail</code></span></span> variable was set to an iterator over the list <span class="obeylines-h"><span class="verb"><code class="inlineCode">[1,</code><code class="inlineCode"> 2,</code><code class="inlineCode"> 3,</code><code class="inlineCode"> None,</code><code class="inlineCode"> 4,</code><code class="inlineCode"> 5,</code><code class="inlineCode"> 6]</code></span></span> that will be traversed by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pop()</code></span></span> function. The default behavior of <span class="obeylines-h"><span class="verb"><code class="inlineCode">pop()</code></span></span> is <span class="obeylines-h"><span class="verb"><code class="inlineCode">pop(-1)</code></span></span>; that is, the elements are popped in the reverse order. This makes<span id="dx1-109008"/> a stateful change to the list object: each time <span class="obeylines-h"><span class="verb"><code class="inlineCode">pop()</code></span></span> is called, the item is removed, mutating the list. When the sentinel value is found, the iterator stops returning values. If the sentinel is not found, this will break with an <span class="obeylines-h"><span class="verb"><code class="inlineCode">IndexError</code></span></span> exception.</p>&#13;
<p>This kind of internal state management is something we’d like to avoid. Consequently, we won’t try to contrive a use for this feature. <span id="x1-109009r116"/></p>&#13;
</section>&#13;
<section id="using-sorted-to-put-data-in-order" class="level3 sectionHead" data-number="0.9.5">&#13;
<h3 class="sectionHead" data-number="0.9.5"><span class="titlemark">5.5 </span> <span id="x1-1100005"/>Using sorted() to put data in order</h3>&#13;
<p>When we need to produce<span id="dx1-110001"/> results in a defined order, Python gives us two choices. We can create a list object and use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">list.sort()</code></span></span> method to put items in an order. An alternative is to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sorted()</code></span></span> function. This function<span id="dx1-110002"/> works with any iterable, but it creates a final <span class="obeylines-h"><span class="verb"><code class="inlineCode">list</code></span></span> object as part of the sorting operation.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">sorted()</code></span></span> function can be used in two ways. It can be simply applied to collections. It can also be used as a higher-order function using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">key=</code></span></span> argument.</p>&#13;
<p>Let’s say we have our trip data from the examples in <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with</span> <span class="cmti-10x-x-109">Collections</span></a>. We have a function that will generate a sequence of tuples with the starting location, end location, and distance for each leg of a trip. The data looks as follows:</p>&#13;
<div id="tcolobox-116" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>[ &#13;
 ((37.54901619777347, -76.33029518659048), (37.840832, -76.273834), 17.7246), &#13;
 ((37.840832, -76.273834), (38.331501, -76.459503), 30.7382), &#13;
 ((38.331501, -76.459503), (38.845501, -76.537331), 31.0756), &#13;
 ((36.843334, -76.298668), (37.549, -76.331169), 42.3962), &#13;
 ((37.549, -76.331169), (38.330166, -76.458504), 47.2866), &#13;
 ((38.330166, -76.458504), (38.976334, -76.473503), 38.8019) &#13;
]</code></pre>&#13;
&#13;
</div>&#13;
<p>We can see the default behavior of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sorted()</code></span></span> function using the following interaction:</p>&#13;
<div id="tcolobox-117" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; sorted(dist(x) for x in trip) &#13;
[0.1731, 0.1898, 1.4235, 4.3155, ... 86.2095, 115.1751, 129.7748]</code></pre>&#13;
&#13;
</div>&#13;
<p>We used a generator expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">(dist(x)</code><code class="inlineCode"> for</code><code class="inlineCode"> x</code><code class="inlineCode"> in</code><code class="inlineCode"> trip)</code></span></span> to extract the distances from our trip data. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">dist()</code></span></span> function is the function<span id="dx1-110015"/> created by <span class="obeylines-h"><span class="verb"><code class="inlineCode">itemgetter(2)</code></span></span>. We then sorted this iterable collection of numbers to get the distances from 0.17 nm to 129.77 nm.</p>&#13;
<p>If we want to keep the legs and distances together in their original three-tuples, we can have the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sorted()</code></span></span> function apply a <span class="obeylines-h"><span class="verb"><code class="inlineCode">key=</code></span></span> function to determine how to sort the tuples, as shown in the following code snippet:</p>&#13;
<div id="tcolobox-118" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; sorted(trip, key=dist) &#13;
[((35.505665, -76.653664), (35.508335, -76.654999), 0.1731), ...</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve sorted the trip data, using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">dist()</code></span></span> function to extract the distance from each tuple. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">dist()</code></span></span> function, shown earlier, is created by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itemgetter()</code></span></span> function as follows:</p>&#13;
<div id="tcolobox-119" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from operator import itemgetter &#13;
&gt;&gt;&gt; dist = itemgetter(2)</code></pre>&#13;
&#13;
</div>&#13;
<p>As an alternative, we can also use a <span class="obeylines-h"><span class="verb"><code class="inlineCode">lambda</code><code class="inlineCode"> leg:</code><code class="inlineCode"> leg[2]</code></span></span> to select a specific value from a tuple. Providing a name, <span class="obeylines-h"><span class="verb"><code class="inlineCode">dist</code></span></span>, makes it a little more clear which item is being selected from the tuple. <span id="x1-110022r117"/></p>&#13;
</section>&#13;
<section id="overview-of-writing-higher-order-functions" class="level3 sectionHead" data-number="0.9.6">&#13;
<h3 class="sectionHead" data-number="0.9.6"><span class="titlemark">5.6 </span> <span id="x1-1110006"/>Overview of writing higher-order functions</h3>&#13;
<p>We’ll look at designing<span id="dx1-111001"/> our own higher-order functions. We’ll summarize some of the process before diving into some more complex kinds of design patterns. We’ll start by looking at common data transformations, such as the following:</p>&#13;
<ul>&#13;
<li><p>Wrap objects to create more complex objects</p></li>&#13;
<li><p>Unwrap complex objects into their components</p></li>&#13;
<li><p>Flatten a structure</p></li>&#13;
<li><p>Structure a flat sequence</p></li>&#13;
</ul>&#13;
<p>These patterns can help to visualize ways higher-order functions can be designed in Python.</p>&#13;
<p>It can also help to recall that a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable</code></span></span> class definition is a function that returns a callable object. We’ll look at this as a way to write flexible functions into which configuration parameters can be injected.</p>&#13;
<p>We’ll defer deeper consideration of decorators until <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 12</span></a>, <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Decorator Design</span> <span class="cmti-10x-x-109">Techniques</span></a>. A decorator is also a higher-order function, but it consumes one function and returns another, making it more complex than the examples in this chapter. We’ll start with developing highly-customized versions of <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span>. <span id="x1-111002r118"/></p>&#13;
</section>&#13;
<section id="writing-higher-order-mappings-and-filters" class="level3 sectionHead" data-number="0.9.7">&#13;
<h3 class="sectionHead" data-number="0.9.7"><span class="titlemark">5.7 </span> <span id="x1-1120007"/>Writing higher-order mappings and filters</h3>&#13;
<p>Python’s two built-in higher-order functions, <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span>, generally handle almost everything we might<span id="dx1-112001"/> want to throw at them. It’s difficult to optimize them in a general way to achieve higher performance. We’ll look at similar functions such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">imap()</code></span></span> in <a href="Chapter_14.xhtml#x1-28300014"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 14</span></a>, <a href="Chapter_14.xhtml#x1-28300014"><span class="cmti-10x-x-109">The Multiprocessing, Threading,</span> <span class="cmti-10x-x-109">and Concurrent.Futures Modules</span></a>.</p>&#13;
<p>We have three largely equivalent ways to express a mapping. Assume that we have some function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">f(x)</code></span></span>, and some collection of objects, <span class="obeylines-h"><span class="verb"><code class="inlineCode">C</code></span></span>. The ways we can compute a mapping from the domain value in <span class="italic">C </span>to a range value are as follows:</p>&#13;
<ul>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function:</p>&#13;
<pre id="listing-91" class="lstlisting"><code>map(f, C)</code></pre></li>&#13;
<li><p>A generator expression:</p>&#13;
<pre id="listing-92" class="lstlisting"><code>(f(x) for x in C)</code></pre></li>&#13;
<li><p>A generator function with a <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code></span></span> statement:</p>&#13;
<pre id="listing-93" class="lstlisting"><code>from collections.abc import Callable, Iterable, Iterator &#13;
from typing import Any &#13;
 &#13;
def mymap(f: Callable[[Any], Any], C: Iterable[Any]) -&gt; Iterator[Any]: &#13;
    for x in C: &#13;
        yield f(x)</code></pre>&#13;
<p>This <span class="obeylines-h"><span class="verb"><code class="inlineCode">mymap()</code></span></span> function can be used as an expression with the function to apply and the iterable source of data:</p>&#13;
<pre id="listing-94" class="lstlisting"><code>mymap(f, C)</code></pre></li>&#13;
</ul>&#13;
<p>Similarly, we have three ways to apply a filter function<span id="dx1-112011"/> to a collection, all of which are equivalent:</p>&#13;
<ul>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function:</p>&#13;
<pre id="listing-95" class="lstlisting"><code>filter(f, C)</code></pre></li>&#13;
<li><p>A generator expression:</p>&#13;
<pre id="listing-96" class="lstlisting"><code>(x for x in C if f(x))</code></pre></li>&#13;
<li><p>A generator function with a <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code></span></span> statement:</p>&#13;
<pre id="listing-97" class="lstlisting"><code>from collections.abc import Callable, Iterable, Iterator &#13;
from typing import Any &#13;
 &#13;
def myfilter(f: Callable[[Any], bool], C: Iterable[Any]) -&gt; Iterator[Any]: &#13;
    for x in C: &#13;
        if f(x): &#13;
            yield x</code></pre>&#13;
<p>This <span class="obeylines-h"><span class="verb"><code class="inlineCode">myfilter()</code></span></span> function<span id="dx1-112021"/> can be used as an expression with the function to apply and the iterable source of data:</p>&#13;
<pre id="listing-98" class="lstlisting"><code>myfilter(f, C)</code></pre></li>&#13;
</ul>&#13;
<p>There are some minor performance differences; often the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> functions are fastest. More importantly, there are different kinds of extensions that fit these mapping and filtering designs, which are as follows:</p>&#13;
<ul>&#13;
<li><p>If we need to modify the processing, we can create a more sophisticated function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">g(x)</code></span></span>, that is applied to each element. This is the most general approach and applies to all three designs. This is where the bulk of our functional design energy is invested. We may define our new function around the existing <span class="obeylines-h"><span class="verb"><code class="inlineCode">f(x)</code></span></span>, or we may find that we need to refactor the original function. In all cases, this design effort seems to yield the most benefits.</p></li>&#13;
<li><p>We can tweak the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> loop inside the generator expression or generator function. One obvious tweak is to combine mapping and filtering into a single operation by extending the generator expression with an <span class="obeylines-h"><span class="verb"><code class="inlineCode">if</code></span></span> clause. We can also merge the <span class="obeylines-h"><span class="verb"><code class="inlineCode">mymap()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">myfilter()</code></span></span> functions to combine mapping and filtering. This requires some care to be sure the resulting function is not a clutter of features.</p></li>&#13;
</ul>&#13;
<p>Profound changes that alter the structure of the data handled by the loop often happen as software evolves and matures. We have a number of design patterns, including wrapping, unwrapping (or extracting), flattening, and structuring. We’ve looked at a few of these techniques in previous chapters.</p>&#13;
<p>In the following sections, we’ll look at ways to design our own higher-order functions. We’ll start with unwrapping complex data while also applying a mapping function. For each example, it’s important to look at where the complexity arises, and decide if the resulting code really is succinct and expressive. <span id="x1-112023r115"/></p>&#13;
<section id="unwrapping-data-while-mapping" class="level4 subsectionHead" data-number="0.9.7.1">&#13;
<h4 class="subsectionHead" data-number="0.9.7.1"><span class="titlemark">5.7.1 </span> <span id="x1-1130001"/>Unwrapping data while mapping</h4>&#13;
<p>When we use a construct<span id="dx1-113001"/> such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">(f(x)</code><code class="inlineCode"> for</code><code class="inlineCode"> x,</code><code class="inlineCode"> y</code><code class="inlineCode"> in</code><code class="inlineCode"> C)</code></span></span>, we use the multiple assignment feature of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement to unwrap a multi-valued tuple and then apply a function. The whole expression is a mapping. This is a common Python optimization to change the structure and apply a function.</p>&#13;
<p>We’ll use our trip data from <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>. The following is a concrete example of unwrapping while mapping:</p>&#13;
<pre id="listing-99" class="lstlisting"><code>from collections.abc import Callable, Iterable, Iterator &#13;
from typing import Any, TypeAlias &#13;
 &#13;
Conv_F: TypeAlias = Callable[[float], float] &#13;
Leg: TypeAlias = tuple[Any, Any, float] &#13;
 &#13;
def convert( &#13;
        conversion: Conv_F, &#13;
        trip: Iterable[Leg]) -&gt; Iterator[float]: &#13;
    return ( &#13;
        conversion(distance) &#13;
        for start, end, distance in trip &#13;
    )</code></pre>&#13;
<p>This higher-order function would be supported by conversion functions that we can apply to our raw data, as follows:</p>&#13;
<pre id="listing-100" class="lstlisting"><code>from collections.abc import Callable &#13;
from typing import TypeAlias &#13;
 &#13;
Conversion: TypeAlias = Callable[[float], float] &#13;
 &#13;
to_miles: Conversion = lambda nm: nm * 6076.12 / 5280 &#13;
 &#13;
to_km: Conversion = lambda nm: nm * 1.852 &#13;
 &#13;
to_nm: Conversion = lambda nm: nm</code></pre>&#13;
<p>These have been defined as lambdas and assigned to variables. Some static analysis tools will object to this because PEP-8 frowns on it.</p>&#13;
<p>The following shows how we can extract distance and apply a conversion<span id="dx1-113025"/> function:</p>&#13;
<div id="tcolobox-120" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; convert(to_miles, trip) &#13;
&lt;generator object ...&gt; &#13;
&gt;&gt;&gt; miles = list(convert(to_miles, trip)) &#13;
&gt;&gt;&gt; trip[0] &#13;
((37.54901619777347, -76.33029518659048), (37.840832, -76.273834), 17.7246) &#13;
&gt;&gt;&gt; miles[0] &#13;
20.397120559090908 &#13;
&gt;&gt;&gt; trip[-1] &#13;
((38.330166, -76.458504), (38.976334, -76.473503), 38.8019) &#13;
&gt;&gt;&gt; miles[-1] &#13;
44.652462240151515</code></pre>&#13;
&#13;
</div>&#13;
<p>As we’re unwrapping, the result will be a sequence of floating-point values. The results are as follows:</p>&#13;
<div id="tcolobox-121" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>[20.397120559090908, 35.37291511060606, ..., 44.652462240151515]</code></pre>&#13;
&#13;
</div>&#13;
<p>This <span class="obeylines-h"><span class="verb"><code class="inlineCode">convert()</code></span></span> function is highly specific to our start-end-distance trip data structure, as the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement decomposes a specific three-tuple.</p>&#13;
<p>We can build a more general solution for this kind of <span class="keyWord">unwrapping-while-mapping</span> design<span id="dx1-113040"/> pattern. It suffers from being a bit more complex. First, we need general-purpose decomposition functions,<span id="dx1-113041"/> as in the following code snippet:</p>&#13;
<pre id="listing-101" class="lstlisting"><code>from collections.abc import Callable &#13;
from operator import itemgetter &#13;
from typing import TypeAlias &#13;
 &#13;
Selector: TypeAlias = Callable[[tuple[Any, ...]], Any] &#13;
 &#13;
fst: Selector = itemgetter(0) &#13;
 &#13;
snd: Selector = itemgetter(1) &#13;
 &#13;
sel2: Selector = itemgetter(2)</code></pre>&#13;
<p>We’d like to be able to express <span class="obeylines-h"><span class="verb"><code class="inlineCode">f(sel2(s_e_d))</code><code class="inlineCode"> for</code><code class="inlineCode"> s_e_d</code><code class="inlineCode"> in</code><code class="inlineCode"> trip</code></span></span>. This involves functional composition; we’re combining a function, such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">to_miles()</code></span></span>, and a selector, such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">sel2()</code></span></span>.</p>&#13;
<p>More descriptive names are often more useful than generic names. We’ll leave the renaming as an exercise for the reader. We can express functional composition in Python using yet another lambda, as follows:</p>&#13;
<pre id="listing-102" class="lstlisting"><code>from collections.abc import Callable &#13;
 &#13;
to_miles_sel2: Callable[[tuple[Any, Any, float]], float] = ( &#13;
    lambda s_e_d: to_miles(sel2(s_e_d)) &#13;
)</code></pre>&#13;
<p>This gives us a longer but more specialized version of unwrapping and mapping, as follows:</p>&#13;
<div id="tcolobox-122" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; miles2 = list( &#13;
...     to_miles_sel2(s_e_d) for s_e_d in trip &#13;
... )</code></pre>&#13;
&#13;
</div>&#13;
<p>We can compare the higher-order <span class="obeylines-h"><span class="verb"><code class="inlineCode">convert()</code></span></span> function against this generator expression. Both apply a number of transformations. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">convert()</code></span></span> function ”conceals” a processing detail—the composition of a tuple as start, end, and distance—with a <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement that decomposes the tuple. This expression<span id="dx1-113062"/> exposes this decomposition by including the <span class="obeylines-h"><span class="verb"><code class="inlineCode">sel2()</code></span></span> function as part of the definition of a composite function.</p>&#13;
<p>Neither is ”better” by any measure. They represent two approaches to exposing or concealing details. In a specific application development context, the exposure (or concealment) might be more desirable.</p>&#13;
<p>The same design principle works to create hybrid filters as well as mappings. We’d apply the filter in an <span class="obeylines-h"><span class="verb"><code class="inlineCode">if</code></span></span> clause of the generator expression that was returned.</p>&#13;
<p>We can combine mapping and filtering to create yet more complex functions. While it is appealing to create more complex functions, it isn’t always valuable. A complex function might not beat the performance of a nested use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> functions. Generally, we only want to create a more complex function if it encapsulates a concept and makes the software easier to understand. <span id="x1-113063r120"/></p>&#13;
</section>&#13;
<section id="wrapping-additional-data-while-mapping" class="level4 subsectionHead" data-number="0.9.7.2">&#13;
<h4 class="subsectionHead" data-number="0.9.7.2"><span class="titlemark">5.7.2 </span> <span id="x1-1140002"/>Wrapping additional data while mapping</h4>&#13;
<p>When we use a construct such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">((f(x),</code><code class="inlineCode"> x)</code><code class="inlineCode"> for</code><code class="inlineCode"> x</code><code class="inlineCode"> in</code><code class="inlineCode"> C)</code></span></span>, we’ve used wrapping to create a multi-valued tuple while also applying a transformational mapping. This is a common technique to save derived results<span id="dx1-114001"/> by creating larger constructs. This has the benefit of avoiding recalculation without the liability of complex objects with an internal state change. In this case, the state change is structural and very visible.</p>&#13;
<p>This is part of the example shown in <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, to create the trip data from the path of points. The code looks like this:</p>&#13;
<div id="tcolobox-123" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from Chapter04.ch04_ex1 import ( &#13;
...    floats_from_pair, float_lat_lon, row_iter_kml, haversine, legs &#13;
... ) &#13;
&gt;&gt;&gt; import urllib.request &#13;
&gt;&gt;&gt; data = "file:./Winter%202012-2013.kml" &#13;
 &#13;
&gt;&gt;&gt; with urllib.request.urlopen(data) as source: &#13;
...     path = floats_from_pair(float_lat_lon(row_iter_kml(source))) &#13;
...     trip = tuple( &#13;
...         (start, end, round(haversine(start, end), 4)) &#13;
...         for start, end in legs(path) &#13;
...     )</code></pre>&#13;
&#13;
</div>&#13;
<p>We can revise this slightly to create a higher-order function that separates the wrapping from the other functions. We can refactor this design to create a function<span id="dx1-114015"/> that constructs a new tuple including the original tuple and the distance. This function can be defined as follows:</p>&#13;
<pre id="listing-103" class="lstlisting"><code>from collections.abc import Callable, Iterable, Iterator &#13;
from typing import TypeAlias &#13;
 &#13;
Point: TypeAlias = tuple[float, float] &#13;
Leg_Raw: TypeAlias = tuple[Point, Point] &#13;
Point_Func: TypeAlias = Callable[[Point, Point], float] &#13;
Leg_D: TypeAlias = tuple[Point, Point, float] &#13;
 &#13;
def cons_distance( &#13;
        distance: Point_Func, &#13;
        legs_iter: Iterable[Leg_Raw]) -&gt; Iterator[Leg_D]: &#13;
    return ( &#13;
        (start, end, round(distance(start,end), 4)) &#13;
        for start, end in legs_iter &#13;
    )</code></pre>&#13;
<p>This function will decompose each leg into two variables, <span class="obeylines-h"><span class="verb"><code class="inlineCode">start</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">end</code></span></span>. These variables will be <span class="obeylines-h"><span class="verb"><code class="inlineCode">Point</code></span></span> instances, defined as tuples of two float values. These will be used with the given <span class="obeylines-h"><span class="verb"><code class="inlineCode">distance()</code></span></span> function to compute the distance between the points. The function is a callable that accepts two <span class="obeylines-h"><span class="verb"><code class="inlineCode">Point</code></span></span> objects and returns a float result. The result will build a three-tuple that includes the original two <span class="obeylines-h"><span class="verb"><code class="inlineCode">Point</code></span></span> objects and also the calculated float result.</p>&#13;
<p>We can then rewrite<span id="dx1-114031"/> our trip assignment to apply the <span class="obeylines-h"><span class="verb"><code class="inlineCode">haversine()</code></span></span> function to compute distances, as follows:</p>&#13;
<div id="tcolobox-124" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; source_url = "file:./Winter%202012-2013.kml" &#13;
&gt;&gt;&gt; with urllib.request.urlopen(source_url) as source: &#13;
...    path = floats_from_pair( &#13;
...        float_lat_lon(row_iter_kml(source)) &#13;
...    ) &#13;
...    trip2 = tuple( &#13;
...        cons_distance(haversine, legs(iter(path))) &#13;
...    )</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve replaced a generator expression with a higher-order function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">cons_distance()</code></span></span>. The function not only accepts a function as an argument, but it also returns a generator expression. In some applications, this larger and more complex processing step is a helpful way to elide unecessary details.</p>&#13;
<p>In <a href="Chapter_10.xhtml#x1-21700010"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 10</span></a>, <a href="Chapter_10.xhtml#x1-21700010"><span class="cmti-10x-x-109">The Functools Module</span></a>, we’ll show how to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">partial()</code></span></span> function to set a value for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">R</code></span></span> parameter of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">haversine()</code></span></span> function, which changes the units in which the distance is calculated. <span id="x1-114041r121"/></p>&#13;
</section>&#13;
<section id="flattening-data-while-mapping" class="level4 subsectionHead" data-number="0.9.7.3">&#13;
<h4 class="subsectionHead" data-number="0.9.7.3"><span class="titlemark">5.7.3 </span> <span id="x1-1150003"/>Flattening data while mapping</h4>&#13;
<p>In <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, we looked at algorithms<span id="dx1-115001"/> that flattened a nested tuple-of-tuples structure into a single iterable. Our goal at the time was simply to restructure some data without doing any real processing. We can create hybrid solutions that combine a function with a flattening operation.</p>&#13;
<p>Let’s assume that we have a block of text that we want to convert to a flat sequence of numbers. The text looks as follows:</p>&#13;
<div id="tcolobox-125" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; text = """2 3 5 7 11 13 17 19 23 29 &#13;
... 31 37 41 43 47 53 59 61 67 71 &#13;
... 73 79 83 89 97 101 103 107 109 113 &#13;
... 127 131 137 139 149 151 157 163 167 173 &#13;
... 179 181 191 193 197 199 211 223 227 229 &#13;
... """</code></pre>&#13;
&#13;
</div>&#13;
<p>Each line is a block of 10 numbers. We need to unblock the rows to create a flat sequence of numbers.</p>&#13;
<p>This is done with a two-part generator<span id="dx1-115009"/> function, as follows:</p>&#13;
<div id="tcolobox-126" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; data = list( &#13;
...     v &#13;
...     for line in text.splitlines() &#13;
...         for v in line.split() &#13;
... )</code></pre>&#13;
&#13;
</div>&#13;
<p>This will split the text into lines and iterate through each line. It will split each line into words and iterate through each word. The output from this is a list of strings, as follows:</p>&#13;
<div id="tcolobox-127" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>[’2’, ’3’, ’5’, ’7’, ’11’, ’13’, ’17’, ’19’, ’23’, ’29’, ’31’, ’37’, &#13;
’41’, ’43’, ’47’, ’53’, ’59’, ’61’, ’67’, ’71’, ’73’, ’79’, ’83’, &#13;
’89’, ’97’, ’101’, ’103’, ’107’, ’109’, ’113’, ’127’, ’131’, ’137’, &#13;
’139’, ’149’, ’151’, ’157’, ’163’, ’167’, ’173’, ’179’, ’181’, ’191’, &#13;
’193’, ’197’, ’199’, ’211’, ’223’, ’227’, ’229’]</code></pre>&#13;
&#13;
</div>&#13;
<p>There’s an optimization to this, which applies to this specific text. We’ll leave that as an exercise for the reader.</p>&#13;
<p>To convert the strings to numbers, we must apply a conversion function as well as unwind the blocked structure from its original format, using the following code snippet:</p>&#13;
<pre id="listing-104" class="lstlisting"><code>from collections.abc import Callable, Iterator &#13;
from typing import TypeAlias &#13;
 &#13;
Num_Conv: TypeAlias = Callable[[str], float] &#13;
 &#13;
def numbers_from_rows( &#13;
        conversion: Num_Conv, &#13;
        text: str) -&gt; Iterator[float]: &#13;
    return ( &#13;
        conversion(value) &#13;
        for line in text.splitlines() &#13;
        for value in line.split() &#13;
    )</code></pre>&#13;
<p>This function has a <span class="obeylines-h"><span class="verb"><code class="inlineCode">conversion</code></span></span> argument, which is a function that is applied to each value that will be emitted. The values are created by flattening<span id="dx1-115035"/> using the algorithm shown previously.</p>&#13;
<p>We can use this <span class="obeylines-h"><span class="verb"><code class="inlineCode">numbers_from_rows()</code></span></span> function in the following kind of expression:</p>&#13;
<div id="tcolobox-128" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; list(numbers_from_rows(float, text))</code></pre>&#13;
&#13;
</div>&#13;
<p>Here we’ve used the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">float()</code></span></span> to create a list of floating-point values from the block of text.</p>&#13;
<p>We have many alternatives using mixtures of higher-order functions and generator expressions. For example, we might express this as follows:</p>&#13;
<div id="tcolobox-129" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; text = (value &#13;
...     for line in text.splitlines() &#13;
...        for value in line.split() &#13;
... ) &#13;
&gt;&gt;&gt; numbers = map(float, text) &#13;
&gt;&gt;&gt; list(numbers)</code></pre>&#13;
&#13;
</div>&#13;
<p>This might help us understand the overall structure of the algorithm. The principle is called <span class="keyWord">chunking</span>: we summarize the details of a function<span id="dx1-115045"/> with a meaningful name. With this summary, the details are abstracted<span id="dx1-115046"/> and we can work with the function as a small concept in a larger context. While we often use higher-order functions, there are times when a generator expression can be clearer. <span id="x1-115047r122"/></p>&#13;
</section>&#13;
<section id="structuring-data-while-filtering" class="level4 subsectionHead" data-number="0.9.7.4">&#13;
<h4 class="subsectionHead" data-number="0.9.7.4"><span class="titlemark">5.7.4 </span> <span id="x1-1160004"/>Structuring data while filtering</h4>&#13;
<p>The previous three examples combined<span id="dx1-116001"/> additional processing with mapping. Combining processing with filtering doesn’t seem to be quite as expressive as combining it with mapping. We’ll look at an example in detail to show that, although it is useful, it doesn’t seem to have as compelling a use case as combining mapping and processing.</p>&#13;
<p>In <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, we looked at structuring algorithms. We can easily combine a filter with the structuring algorithm into a single, complex function. The following is a version of our preferred function to group the output from an iterable:</p>&#13;
<pre id="listing-105" class="lstlisting"><code>from collections.abc import Iterator &#13;
from typing import TypeVar &#13;
 &#13;
ItemT = TypeVar("ItemT") &#13;
 &#13;
def group_by_iter( &#13;
        n: int, &#13;
        iterable: Iterator[ItemT] &#13;
) -&gt; Iterator[tuple[ItemT, ...]]: &#13;
    def group(n: int, iterable: Iterator[ItemT]) -&gt; Iterator[ItemT]: &#13;
        for i in range(n): &#13;
            try: &#13;
                yield next(iterable) &#13;
            except StopIteration: &#13;
                return &#13;
 &#13;
    while row := tuple(group(n, iterable)): &#13;
        yield row</code></pre>&#13;
<p>This will try to assemble a tuple of <span class="obeylines-h"><span class="verb"><code class="inlineCode">n</code></span></span> items taken from an iterable object. If there are any items in the tuple, they are yielded as part of the resulting iterable. In principle, the function then operates recursively on the remaining items from the original iterable. As the recursion has limitations in Python, we’ve optimized the tail call structure into an explicit <span class="obeylines-h"><span class="verb"><code class="inlineCode">while</code></span></span> statement.</p>&#13;
<p>The results of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">group_by_iter()</code></span></span> function is a sequence of <span class="cmti-10x-x-109">n</span>-tuples. In the following example, we’ll create a sequence of numbers<span id="dx1-116020"/> using a filter function, and then group them into 7-tuples:</p>&#13;
<div id="tcolobox-130" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from pprint import pprint &#13;
&gt;&gt;&gt; data = list( &#13;
...     filter(lambda x: x % 3 == 0 or x % 5 == 0, range(1, 50)) &#13;
... ) &#13;
&gt;&gt;&gt; data &#13;
[3, 5, 6, 9, 10, ..., 48] &#13;
&gt;&gt;&gt; grouped = list(group_by_iter(7, iter(data))) &#13;
&gt;&gt;&gt; pprint(grouped) &#13;
[(3, 5, 6, 9, 10, 12, 15), &#13;
 (18, 20, 21, 24, 25, 27, 30), &#13;
 (33, 35, 36, 39, 40, 42, 45), &#13;
 (48,)]</code></pre>&#13;
&#13;
</div>&#13;
<p>We can merge grouping and filtering into a single function that does both operations in a single function body. The modification to <span class="obeylines-h"><span class="verb"><code class="inlineCode">group_by_iter()</code></span></span> looks as follows:</p>&#13;
<pre id="listing-106" class="lstlisting"><code>from collections.abc import Callable, Iterator, Iterable &#13;
from typing import Any, TypeAlias &#13;
 &#13;
ItemFilterPredicate: TypeAlias = Callable[[Any], bool] &#13;
 &#13;
def group_filter_iter( &#13;
        n: int, &#13;
        predicate: ItemFilterPredicate, &#13;
        items: Iterator[ItemT] &#13;
) -&gt; Iterator[tuple[ItemT, ...]]: &#13;
    def group(n: int, iterable: Iterator[ItemT]) -&gt; Iterator[ItemT]: &#13;
        for i in range(n): &#13;
            try: &#13;
                yield next(iterable) &#13;
            except StopIteration: &#13;
                return &#13;
 &#13;
    subset = filter(predicate, items) &#13;
    # ^-- Added this to apply the filter &#13;
    while row := tuple(group(n, subset)): &#13;
                              # ^-- Changed to use the filter &#13;
        yield row</code></pre>&#13;
<p>We’ve added a single line to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">group_by_iter()</code></span></span> function. This application of <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> creates a subset. We’ve changed the <span class="obeylines-h"><span class="verb"><code class="inlineCode">while</code><code class="inlineCode"> row</code><code class="inlineCode"> :=</code><code class="inlineCode"> tuple(group(n,</code><code class="inlineCode"> subset)):</code></span></span> line to use the subset instead of the original collection of items.</p>&#13;
<p>This <span class="obeylines-h"><span class="verb"><code class="inlineCode">group_filter_iter()</code></span></span> function applies the filter predicate function to the source iterable provided as the <span class="obeylines-h"><span class="verb"><code class="inlineCode">items</code></span></span> parameter. As the filter output is itself a non-strict iterable, the subset value isn’t computed in advance; the values are created as needed. The bulk of this function<span id="dx1-116056"/> is identical to the version shown previously.</p>&#13;
<p>We can slightly simplify the context in which we use this function. We can compare the explicit use of <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> and this combined function where the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> is implicit. The comparison is in the following example:</p>&#13;
<div id="tcolobox-131" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; rule: ItemFilterPredicate = lambda x: x % 3 == 0 or x % 5 == 0 &#13;
&gt;&gt;&gt; groups_explicit = list( &#13;
...    group_by_iter(7, filter(rule, range(1, 50))) &#13;
... ) &#13;
&gt;&gt;&gt; groups = list( &#13;
...     group_filter_iter(7, rule, iter(range(1, 50))) &#13;
... )</code></pre>&#13;
&#13;
</div>&#13;
<p>Here, we’ve applied the filter predicate and grouped the results in a single function invocation. In the case of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function, it’s rarely a clear advantage to apply the filter in conjunction with other processing. It seems as if a separate, visible <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function is more helpful than a combined function. <span id="x1-116065r119"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="building-higher-order-functions-with-callables" class="level3 sectionHead" data-number="0.9.8">&#13;
<h3 class="sectionHead" data-number="0.9.8"><span class="titlemark">5.8 </span> <span id="x1-1170008"/>Building higher-order functions with callables</h3>&#13;
<p>We can define higher-order functions<span id="dx1-117001"/> as callable classes. This builds on the idea of writing generator functions; we’ll write callables<span id="dx1-117002"/> because we need stateful features of Python, like instance variables. In addition to using statements, we can also apply a static configuration when creating the higher-order functions. The <span class="keyWord">Strategy </span>design pattern, in particular, works very nicely to alter the features of callable objects.</p>&#13;
<p>What’s important about a callable<span id="dx1-117003"/> class definition is that the class object, created by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">class</code></span></span> statement, defines a function that emits a function. Commonly, we’ll use a callable object to create a composite function that combines functions into something relatively complex.</p>&#13;
<p>To emphasize this, consider the following class:</p>&#13;
<pre id="listing-107" class="lstlisting"><code>from collections.abc import Callable &#13;
from typing import Any &#13;
 &#13;
class NullAware: &#13;
    def __init__(self, some_func: Callable[[Any], Any]) -&gt; None: &#13;
        self.some_func = some_func &#13;
 &#13;
    def __call__(self, arg: Any) -&gt; Any: &#13;
        return None if arg is None else self.some_func(arg)</code></pre>&#13;
<p>This class is used to create a new function that is null aware. When an instance of this class is created, a function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">some_func</code></span></span>, is provided. The only restriction stated is that <span class="obeylines-h"><span class="verb"><code class="inlineCode">some_func</code></span></span> be <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[[Any],</code><code class="inlineCode"> Any]</code></span></span>. This means the argument takes a single argument and results in a single result. The resulting object is callable. A single, optional argument is expected. The implementation of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">__call__()</code></span></span> method handles the use of <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> objects as an argument. This method has the effect of making the resulting object <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[[Optional[Any]],</code><code class="inlineCode"> Optional[Any]]</code></span></span>.</p>&#13;
<p>For example, evaluating the <span class="obeylines-h"><span class="verb"><code class="inlineCode">NullAware(math.log)</code></span></span> expression will create a new function that can be applied to argument values. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">__init__()</code></span></span> method will save the given function in the resulting object. This object is a function that can then be used to process data.</p>&#13;
<p>The common approach is to create the new function<span id="dx1-117013"/> and save it for future use by assigning it a name, as follows:</p>&#13;
<pre id="listing-108" class="lstlisting"><code>import math &#13;
 &#13;
null_log_scale = NullAware(math.log) &#13;
 &#13;
null_round_4 = NullAware(lambda x: round(x, 4))</code></pre>&#13;
<p>The first example creates a new function,<span id="dx1-117019"/> and assigns the name <span class="obeylines-h"><span class="verb"><code class="inlineCode">null_log_scale()</code></span></span>. The second example creates a null-aware function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">null_round_4</code></span></span>, that uses a lambda object as the internal value of the function to apply if the parameter is not <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span>. We can then use the function in another context. Take a look at the following example:</p>&#13;
<div id="tcolobox-132" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; some_data = [10, 100, None, 50, 60] &#13;
&gt;&gt;&gt; scaled = map(null_log_scale, some_data) &#13;
&gt;&gt;&gt; [null_round_4(v) for v in scaled] &#13;
[2.3026, 4.6052, None, 3.912, 4.0943]</code></pre>&#13;
&#13;
</div>&#13;
<p>This example’s <span class="obeylines-h"><span class="verb"><code class="inlineCode">__call__()</code></span></span> method relies entirely on expression evaluation. It’s an elegant and tidy way to define composite functions built up from lower-level component functions. <span id="x1-117025r123"/></p>&#13;
<section id="assuring-good-functional-design" class="level4 subsectionHead" data-number="0.9.8.1">&#13;
<h4 class="subsectionHead" data-number="0.9.8.1"><span class="titlemark">5.8.1 </span> <span id="x1-1180001"/>Assuring good functional design</h4>&#13;
<p>The idea of stateless functional<span id="dx1-118001"/> programming requires some care when using Python objects. Objects are typically stateful. Indeed, one can argue that the entire purpose of object-oriented programming<span id="dx1-118002"/> is to encapsulate state change into class definitions. Because of this, we find ourselves pulled in opposing directions between functional programming and imperative programming when using Python class definitions to process collections.</p>&#13;
<p>The benefit of using a callable object to create a composite function gives us slightly simpler syntax when the resulting composite function is used. When we start working with iterable mappings or reductions, we have to be aware of how and why we introduce stateful objects.</p>&#13;
<p>We’ll turn to a fairly complex function<span id="dx1-118003"/> that contains the following features:</p>&#13;
<ul>&#13;
<li><p>It applies a filter to a source of items.</p></li>&#13;
<li><p>It applies a mapping to the items which pass the filter.</p></li>&#13;
<li><p>It computes a sum of the mapped values.</p></li>&#13;
</ul>&#13;
<p>We can try to define it as a simple higher-order function, but with three separate parameter values, it would be cumbersome to use. Instead, we’ll create a callable object that is configured by the filter and mapping functions.</p>&#13;
<p>Using objects to configure an object is the <span class="keyWord">Strategy </span>design pattern, used in object-oriented programming. Here’s a class definition that requires the filter and mapping function in order to create a callable:</p>&#13;
<pre id="listing-109" class="lstlisting"><code>from collections.abc import Callable, Iterable &#13;
 &#13;
class Sum_Filter: &#13;
    __slots__ = ["filter", "function"] &#13;
 &#13;
    def __init__(self, &#13;
            filter: Callable[[float], bool], &#13;
            func: Callable[[float], float]) -&gt; None: &#13;
        self.filter = filter &#13;
        self.function = func &#13;
 &#13;
    def __call__(self, iterable: Iterable[float]) -&gt; float: &#13;
        return sum( &#13;
            self.function(x) &#13;
            for x in iterable &#13;
            if self.filter(x) &#13;
        )</code></pre>&#13;
<p>This class has two slots in each object; this puts a few constraints on our ability to use the function as a stateful object. It doesn’t prevent all modifications to the resulting object, but it limits us to just two attributes. Attempting to add an attribute will result in an exception.</p>&#13;
<p>The initialization method, <span class="obeylines-h"><span class="verb"><code class="inlineCode">__init__()</code></span></span>, stows the two function objects, <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">func</code></span></span>, in the object’s instance variables. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">__call__()</code></span></span> method returns a value based on a generator expression that uses the two internal function definitions. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">self.filter()</code></span></span> function is used to pass or reject items. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">self.function()</code></span></span> function is used to transform objects that are passed by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function.</p>&#13;
<p>An instance of this class is a function<span id="dx1-118021"/> that has two Strategy functions built into it. We create an instance as follows:</p>&#13;
<pre id="listing-110" class="lstlisting"><code>count_not_none = Sum_Filter( &#13;
    lambda x: x is not None, &#13;
    lambda x: 1 &#13;
)</code></pre>&#13;
<p>We’ve built a function named <span class="obeylines-h"><span class="verb"><code class="inlineCode">count_not_none()</code></span></span> that counts the non-<span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> values in a sequence. It does this by using a lambda to pass non-<span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> values and a function that uses a constant, 1, instead of the actual values present.</p>&#13;
<p>Generally, this <span class="obeylines-h"><span class="verb"><code class="inlineCode">count_not_none()</code></span></span> object will behave like any other Python function. We can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">count_not_None()</code></span></span> function as follows:</p>&#13;
<div id="tcolobox-133" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; some_data = [10, 100, None, 50, 60] &#13;
&gt;&gt;&gt; count_not_none(some_data) &#13;
4</code></pre>&#13;
&#13;
</div>&#13;
<p>This shows a technique for using some of Python’s object-oriented programming<span id="dx1-118030"/> features to create callable objects that are used in a functional approach to designing and building software. We can delegate some complexity to creating a sophisticated function. Having a single function with multiple features can simplify understanding of the context in which the function is used. <span id="x1-118031r124"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="review-of-some-design-patterns" class="level3 sectionHead" data-number="0.9.9">&#13;
<h3 class="sectionHead" data-number="0.9.9"><span class="titlemark">5.9 </span> <span id="x1-1190009"/>Review of some design patterns</h3>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">sorted()</code></span></span> functions have a default behavior without a <span class="obeylines-h"><span class="verb"><code class="inlineCode">key=</code></span></span> function. They can be customized<span id="dx1-119001"/> by providing a function that defines how to compute a key from the available data. For many of our examples, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">key=</code></span></span> function has been a simple extraction of available data. This isn’t a requirement; the <span class="obeylines-h"><span class="verb"><code class="inlineCode">key=</code></span></span> function can do anything.</p>&#13;
<p>Imagine the following method: <span class="obeylines-h"><span class="verb"><code class="inlineCode">max(trip,</code><code class="inlineCode"> key=random.randint())</code></span></span>. Generally, we try not to have <span class="obeylines-h"><span class="verb"><code class="inlineCode">key=</code></span></span> functions that do something obscure like this.</p>&#13;
<p>The use of a <span class="obeylines-h"><span class="verb"><code class="inlineCode">key=</code></span></span> function is a common design pattern. Functions we design can easily follow this pattern.</p>&#13;
<p>We’ve also looked at the way lambda forms can simplify the application of higher-order functions. One significant advantage of using lambda forms is that it follows the functional paradigm very closely. When writing more conventional functions, we can create imperative programs that might clutter an otherwise succinct and expressive functional design.</p>&#13;
<p>We’ve looked at several kinds of higher-order functions that work with a collection of values. Throughout the previous chapters, we’ve hinted at several different design patterns for higher-order functions that apply to collection objects and scalar objects. The following is a broad classification:</p>&#13;
<ul>&#13;
<li><p><span class="keyWord">Return a generator</span>: A higher-order function<span id="dx1-119002"/> can return a generator expression. We consider the function higher-order because it didn’t return scalar values or collections of values. Some of these higher-order functions also accept functions as arguments.</p></li>&#13;
<li><p><span class="keyWord">Act as a generator</span>: Some function<span id="dx1-119003"/> examples use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">yield</code></span></span> statement to make them first-class generator functions. The value of a generator function is an iterable collection of values that are evaluated lazily. We suggest that a generator function is essentially indistinguishable from a function that returns a generator expression. Both are non-strict. Both can yield a sequence of values. For this reason, we’ll also consider generator functions as higher order. Built-in functions, such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span>, fall into this category.</p></li>&#13;
<li><p><span class="keyWord">Materialize a collection</span>: Some functions<span id="dx1-119004"/> must return a materialized collection object: list, tuple, set, or mapping. These kinds of functions can be of a higher order if they have a function as part of the arguments. Otherwise, they’re ordinary functions that happen to work with collections.</p></li>&#13;
<li><p><span class="keyWord">Reduce a collection</span>: Some functions<span id="dx1-119005"/> work with an iterable to create a scalar result. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> functions are examples of this. We can create higher-order reductions when we accept a function as an argument. We’ll return to this in the next chapter.</p></li>&#13;
<li><p><span class="keyWord">Scalar</span>: Some functions<span id="dx1-119006"/> act on individual<span id="dx1-119007"/> data items. These can be higher-order functions if they accept another function as an argument.</p></li>&#13;
</ul>&#13;
<p>As we design our own software, we can pick and choose among these established design patterns. <span id="x1-119008r126"/></p>&#13;
</section>&#13;
<section id="summary-4" class="level3 sectionHead" data-number="0.9.10">&#13;
<h3 class="sectionHead" data-number="0.9.10"><span class="titlemark">5.10 </span> <span id="x1-12000010"/>Summary</h3>&#13;
<p>In this chapter, we have seen two reductions that are higher-order functions: <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">min()</code></span></span>. We looked at the two central higher-order functions, <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span>. We also looked at <span class="obeylines-h"><span class="verb"><code class="inlineCode">sorted()</code></span></span>.</p>&#13;
<p>In addition, we looked at how to use a higher-order function to transform the structure of data. We can perform several common transformations, including wrapping, unwrapping, flattening, and structuring sequences of different kinds.</p>&#13;
<p>We looked at two ways to define our own higher-order functions, which are as follows:</p>&#13;
<ul>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">def</code></span></span> statement. Similar to a lambda form that we assign to a variable.</p></li>&#13;
<li><p>Defining a callable class as a kind of function that emits composite functions.</p></li>&#13;
</ul>&#13;
<p>We can also use decorators to emit composite functions. We’ll return to this in <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 12</span></a>, <a href="Chapter_12.xhtml#x1-25000012"><span class="cmti-10x-x-109">Decorator Design Techniques</span></a>.</p>&#13;
<p>In the next chapter, we’ll look at the idea of purely functional iteration via recursion. We’ll use Pythonic structures to make several common improvements over purely functional techniques. We’ll also look at the associated problem of performing reductions from collections to individual values. <span id="x1-120001r127"/></p>&#13;
</section>&#13;
<section id="exercises-4" class="level3 sectionHead" data-number="0.9.11">&#13;
<h3 class="sectionHead" data-number="0.9.11"><span class="titlemark">5.11 </span> <span id="x1-12100011"/>Exercises</h3>&#13;
<p>This chapter’s exercises are based on code available from Packt Publishing on GitHub. See <a href="https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition" class="url">https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition</a>.</p>&#13;
<p>In some cases, the reader will notice that the code provided on GitHub includes partial solutions to some of the exercises. These serve as hints, allowing the reader to explore alternative solutions.</p>&#13;
<p>In many cases, exercises will need unit test cases to confirm they actually solve the problem. These are often identical to the unit test cases provided in the GitHub repository. The reader should replace the book’s example function name with their own solution to confirm that it works. <span id="x1-121001r125"/></p>&#13;
<section id="classification-of-state" class="level4 subsectionHead" data-number="0.9.11.1">&#13;
<h4 class="subsectionHead" data-number="0.9.11.1"><span class="titlemark">5.11.1 </span> <span id="x1-1220001"/>Classification of state</h4>&#13;
<p>A web application might have a number of servers of various kinds, a database, and installed software components. Someone responsible for website reliability will want to know when things are running reasonably well. When things are broken, they’ll want details.</p>&#13;
<p>As part of monitoring, a health application can gather status from the various components and summarize the status into an overall ”health” value. The idea is to perform a kind of ”reduce” on the status information.</p>&#13;
<p>Each individual service has a status URL that can be pinged for status information. The results can take one of these four values:</p>&#13;
<ul>&#13;
<li><p>No response at all. The service is not working. This is bad.</p></li>&#13;
<li><p>A response that is outside a healthy time window. Even if the response is <span class="obeylines-h"><span class="verb"><code class="inlineCode">"working"</code></span></span>, the service is degraded.</p></li>&#13;
<li><p>A response of <span class="obeylines-h"><span class="verb"><code class="inlineCode">"not</code><code class="inlineCode"> working"</code></span></span>. A response of ”not working” is almost as bad as no response at all. It indicates a severe problem, but it also means monitoring software is working.</p></li>&#13;
<li><p>A response of <span class="obeylines-h"><span class="verb"><code class="inlineCode">"working"</code></span></span>. This is the ideal response.</p></li>&#13;
</ul>&#13;
<p>The status forms a collection of 3-tuples: <span class="obeylines-h"><span class="verb"><code class="inlineCode">("service",</code><code class="inlineCode"> "status",</code><code class="inlineCode"> response</code><code class="inlineCode"> time)</code></span></span>. The service is a name, like <span class="obeylines-h"><span class="verb"><code class="inlineCode">"primary</code><code class="inlineCode"> database"</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">"router"</code></span></span> or any of numerous other services that can be part of a distributed web application. The status value is a string value of either <span class="obeylines-h"><span class="verb"><code class="inlineCode">"working"</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">"not</code><code class="inlineCode"> working"</code></span></span>. The response time is the number of milliseconds it took to respond. Typical numbers are 10-50.</p>&#13;
<p>The summary is one of the following values:</p>&#13;
<ul>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">Stopped</code></span></span>: There is one service that is not responding.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">Degraded</code></span></span>: There is one service that has responded with a time that is out of the healthy time window of 50 milliseconds or less. Or, there is one service that has responded with <span class="obeylines-h"><span class="verb"><code class="inlineCode">"not</code><code class="inlineCode"> working"</code></span></span>.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">Running</code></span></span>: All services are working and responding within the 50 millisecond window.</p></li>&#13;
</ul>&#13;
<p>Two of the possible implementations are as follows:</p>&#13;
<ul>&#13;
<li><p>Write four filter functions. Apply the filters to the sequence of status values and count how many match each filter. Based on the number of matches, decide which of the three responses to provide for the overall health of the system.</p></li>&#13;
<li><p>Write a mapping to apply a severity number: 2 for an indication of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Stopped</code></span></span>, 1 for either of the indications of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Degraded</code></span></span>, or 0 for all other service status messages. The maximum value of this vector is the overall health of the system.</p></li>&#13;
</ul>&#13;
<p>Implement all variations. Compare the resulting code for clarity and expressiveness. <span id="x1-122001r129"/></p>&#13;
</section>&#13;
<section id="classification-of-state-part-ii" class="level4 subsectionHead" data-number="0.9.11.2">&#13;
<h4 class="subsectionHead" data-number="0.9.11.2"><span class="titlemark">5.11.2 </span> <span id="x1-1230002"/>Classification of state, Part II</h4>&#13;
<p>In the previous exercise, services were described as reporting a status value as a string value of either <span class="obeylines-h"><span class="verb"><code class="inlineCode">"working"</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">"not</code><code class="inlineCode"> working"</code></span></span>.</p>&#13;
<p>Before proceeding, either complete the previous exercise, or develop a workable design to solve the previous exercise.</p>&#13;
<p>Due to technology upgrades, the status values for some services include a third value: <span class="obeylines-h"><span class="verb"><code class="inlineCode">"degraded"</code></span></span>. This has the same implication as a slow response from a service. This may change the design. It will certainly change the implementation.</p>&#13;
<p>Provide an implementation that gracefully handles the idea of additional or distinct status messages. The idea is to isolate the status-message checking to a function that can be replaced easily. For example, we might start with three functions to evaluate status values: <span class="obeylines-h"><span class="verb"><code class="inlineCode">is_stopped()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">is_degraded()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">is_working()</code></span></span>. When a change is required, we can write a new version, <span class="obeylines-h"><span class="verb"><code class="inlineCode">is_degraded_2()</code></span></span>, that can be used in place of the old <span class="obeylines-h"><span class="verb"><code class="inlineCode">is_degraded()</code></span></span> function.</p>&#13;
<p>The objective is to create an application that does not require a change to the implementation of any particular function. Instead, new functions are added; these new functions will reuse existing functions plus new functions to complete the expanded objectives. <span id="x1-123001r130"/></p>&#13;
</section>&#13;
<section id="optimizing-a-file-parser" class="level4 subsectionHead" data-number="0.9.11.3">&#13;
<h4 class="subsectionHead" data-number="0.9.11.3"><span class="titlemark">5.11.3 </span> <span id="x1-1240003"/>Optimizing a file parser</h4>&#13;
<p>In <a href="#x1-1150003"><span class="cmti-10x-x-109">Flattening data while mapping</span></a>, we used the following expression to extract a sequence of numbers from text with space separators:</p>&#13;
<pre id="listing-111" class="lstlisting"><code>( &#13;
    v &#13;
    for line in text.splitlines() &#13;
        for v in line.split() &#13;
)</code></pre>&#13;
<p>The definition of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">split()</code></span></span> method includes the <span class="obeylines-h"><span class="verb"><code class="inlineCode">\n</code></span></span> character, which is also used by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">splitlines()</code></span></span> method. It seems like this can be optimized to use only the <span class="obeylines-h"><span class="verb"><code class="inlineCode">split()</code></span></span> method.</p>&#13;
<p>After getting this to work, change the source text in the example to:</p>&#13;
<div id="tcolobox-134" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; text = """2,3,5,7,11,13,17,19,23,29 &#13;
... 31,37,41,43,47,53,59,61,67,71 &#13;
... 73,79,83,89,97,101,103,107,109,113 &#13;
... 127,131,137,139,149,151,157,163,167,173 &#13;
... 179,181,191,193,197,199,211,223,227,229 &#13;
... """</code></pre>&#13;
&#13;
</div>&#13;
<p>We can parse this with a single use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">split()</code></span></span> method. This requires restructuring a single, long sequence of values into various rows and columns.</p>&#13;
<p>Is this faster than the use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">splitlines()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">split()</code></span></span> methods?</p>&#13;
</section>&#13;
</section>&#13;
<section id="join-our-community-discord-space-5" class="level3 likesectionHead" data-number="0.9.12">&#13;
<h3 class="likesectionHead" data-number="0.9.12"><span id="x1-1250003"/>Join our community Discord space</h3>&#13;
<p>Join our Python Discord workspace to discuss and know more about the book: <a href="https://packt.link/dHrHU">https://packt.link/dHrHU</a></p>&#13;
<p><img src="../Images/file1.png" alt="PIC" width="85" height="85"/> <span id="x1-125001r107"/></p>&#13;
</section>&#13;
</section>&#13;
</body></html>