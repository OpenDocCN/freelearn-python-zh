- en: Chapter 2. Acquiring Intelligence Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to acquire intelligence data from a variety of sources. We might
    interview people. We might steal files from a secret underground base. We might
    search the **World Wide Web** (**WWW**), and this is what we'll focus on in this
    chapter. Using our own cameras or recording devices is the subject of the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Important espionage targets include natural resources, popular opinion, and
    strategic economic strengths. This kind of background information is useful in
    a number of ways. A great deal of the world's data is already on the Web, and
    the rest will get there eventually. Any modern search for intelligence starts
    with the Web.
  prefs: []
  type: TYPE_NORMAL
- en: We can use Python libraries such as `http.client` and `urllib` to get data from
    remote servers and transfer files to other servers. Once we've found remote files
    of interest, we're going to need a number of Python libraries to parse and extract
    data from these libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Our Espionage Toolkit"), *Our Espionage
    Toolkit*, we looked at how we can peek inside a ZIP archive. We'll look inside
    other kinds of files in this chapter. We'll focus on JSON files, because they're
    widely used for web services APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along the way, we''ll cover a number of topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to access online data from Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP protocol and how to access websites from our applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The FTP protocol and how to upload and download large volumes of bulk data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of the core Python data structures will include lists, tuples, dictionaries,
    and sets, and how we use these structures to organize and manage information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter, we'll be able to build applications that access
    live, current, up-to-the-minute data from the Web. Once we've got the data, we
    can filter and analyze it to create useful intelligence assets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing data from the Internet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The WWW and Internet are based on a series of agreements called **Request for
    Comments** (**RFC**). The RFCs define the standards and protocols to interconnect
    different networks, that is, the rules for internetworking. The WWW is defined
    by a subset of these RFCs that specifies the protocols, behaviors of hosts and
    agents (servers and clients), and file formats, among other details.
  prefs: []
  type: TYPE_NORMAL
- en: In a way, the Internet is a controlled chaos. Most software developers agree
    to follow the RFCs. Some don't. If their idea is really good, it can catch on,
    even though it doesn't precisely follow the standards. We often see this in the
    way some browsers don't work with some websites. This can cause confusion and
    questions. We'll often have to perform both espionage and plain old debugging
    to figure out what's available on a given website.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides a variety of modules that implement the software defined in
    the Internet RFCs. We'll look at some of the common protocols to gather data through
    the Internet and the Python library modules that implement these protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Background briefing – the TCP/IP protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The essential idea behind the WWW is the Internet. The essential idea behind
    the Internet is the TCP/IP protocol stack. The IP part of this is the internetworking
    protocol. This defines how messages can be routed between networks. Layered on
    top of IP is the TCP protocol to connect two applications to each other. TCP connections
    are often made via a software abstraction called a **socket**. In addition to
    TCP, there's also UDP; it's not used as much for the kind of WWW data we're interested
    in.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we can use the low-level `socket` library to work with the TCP protocol,
    but we won't. A socket is a file-like object that supports open, close, input,
    and output operations. Our software will be much simpler if we work at a higher
    level of abstraction. The Python libraries that we'll use will leverage the socket
    concept under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Internet RFCs defines a number of protocols that build on TCP/IP sockets.
    These are more useful definitions of interactions between host computers (servers)
    and user agents (clients). We''ll look at two of these: **Hypertext Transfer Protocol**
    (**HTTP**) and **File Transfer Protocol** (**FTP**).'
  prefs: []
  type: TYPE_NORMAL
- en: Using http.client for HTTP GET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The essence of web traffic is HTTP. This is built on TCP/IP. HTTP defines two
    roles: host and user agent, also called server and client, respectively. We''ll
    stick to server and client. HTTP defines a number of kinds of request types, including
    `GET` and `POST`.'
  prefs: []
  type: TYPE_NORMAL
- en: A web browser is one kind of client software we can use. This software makes
    `GET` and `POST` requests, and displays the results from the web server. We can
    do this kind of client-side processing in Python using two library modules.
  prefs: []
  type: TYPE_NORMAL
- en: The `http.client` module allows us to make `GET` and `POST` requests as well
    as `PUT` and `DELETE`. We can read the response object. Sometimes, the response
    is an HTML page. Sometimes, it's a graphic image. There are other things too,
    but we're mostly interested in text and graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Here's a picture of a mysterious device we've been trying to find. We need to
    download this image to our computer so that we can see it and send it to our informant
    from [http://upload.wikimedia.org/wikipedia/commons/7/72/IPhone_Internals.jpg](http://upload.wikimedia.org/wikipedia/commons/7/72/IPhone_Internals.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: '![Using http.client for HTTP GET](img/Image_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a picture of the currency we''re supposed to track down and pay with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using http.client for HTTP GET](img/0420OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to download this image. Here is the link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://upload.wikimedia.org/wikipedia/en/c/c1/1drachmi_1973.jpg](http://upload.wikimedia.org/wikipedia/en/c/c1/1drachmi_1973.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can use `http.client` to get these two image files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We're using `http.client` to handle the client side of the HTTP protocol. We're
    also using the `contextlib` module to politely disentangle our application from
    network resources when we're done using them.
  prefs: []
  type: TYPE_NORMAL
- en: We've assigned a list of paths to the `path_list` variable. This example introduces
    list objects without providing any background. We'll return to lists in the *Organizing
    collections of data* section later in the chapter. It's important that lists are
    surrounded by `[]` and the items are separated by `,`. Yes, there's an extra `,`
    at the end. This is legal in Python.
  prefs: []
  type: TYPE_NORMAL
- en: We created an `http.client.HTTPConnection` object using the host computer name.
    This connection object is a little like a file; it entangles Python with operating
    system resources on our local computer plus a remote server. Unlike a file, an
    `HTTPConnection` object isn't a proper context manager. As we really like context
    managers to release our resources, we made use of the `contextlib.closing()` function
    to handle the context management details. The connection needs to be closed; the
    `closing()` function assures that this will happen by calling the connection's
    `close()` method.
  prefs: []
  type: TYPE_NORMAL
- en: For all of the paths in our `path_list`, we make an HTTP `GET` request. This
    is what browsers do to get the image files mentioned in an HTML page. We print
    a few things from each response. The status, if everything worked, will be 200\.
    If the status is not 200, then something went wrong and we'll need to read up
    on the HTTP status code to see what happened.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you use a coffee shop Wi-Fi connection, perhaps you're not logged in. You
    might need to open a browser to set up a connection.
  prefs: []
  type: TYPE_NORMAL
- en: An HTTP response includes headers that provide some additional details about
    the request and response. We've printed the headers because they can be helpful
    in debugging any problems we might have. One of the most useful headers is `('Content-Type',
    'image/jpeg')`. This confirms that we really did get an image.
  prefs: []
  type: TYPE_NORMAL
- en: We used `_, _, filename = path.rpartition("/")` to locate the right-most `/`
    character in the path. Recall that the `partition()` method locates the left-most
    instance. We're using the right-most one here. We assigned the directory information
    and separator to the variable `_`. Yes, `_` is a legal variable name. It's easy
    to ignore, which makes it a handy shorthand for *we don't care*. We kept the filename
    in the `filename` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We create a nested context for the resulting image file. We can then read the
    body of the response—a collection of bytes—and write these bytes to the image
    file. In one quick motion, the file is ours.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP `GET` request is what underlies much of the WWW. Programs such as `curl`
    and `wget` are expansions of this example. They execute batches of `GET` requests
    to locate one or more pages of content. They can do quite a bit more, but this
    is the essence of extracting data from the WWW.
  prefs: []
  type: TYPE_NORMAL
- en: Changing our client information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An HTTP `GET` request includes several headers in addition to the URL. In the
    previous example, we simply relied on the Python `http.client` library to supply
    a suitable set of default headers. There are several reasons why we might want
    to supply different or additional headers.
  prefs: []
  type: TYPE_NORMAL
- en: First, we might want to tweak the `User-Agent` header to change the kind of
    browser that we're claiming to be. We might also need to provide cookies for some
    kinds of interactions. For information on the user agent string, see [http://en.wikipedia.org/wiki/User_agent_string#User_agent_identification](http://en.wikipedia.org/wiki/User_agent_string#User_agent_identification).
  prefs: []
  type: TYPE_NORMAL
- en: 'This information may be used by the web server to determine if a mobile device
    or desktop device is being used. We can use something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes our Python request appear to come from the Safari browser instead
    of a Python application. We can use something like this to appear to be a different
    browser on a desktop computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use something like this to appear to be an iPhone instead of a Python
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We make this change by adding headers to the request we''re making. The change
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will make the web server treat our Python application like it's on an iPhone.
    This might lead to a more compact page of data than might be provided to a full
    desktop computer that makes the same request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The header information is a structure with the `{ key: value, }` syntax. This
    is a dictionary. We''ll return to dictionaries in the following *Organizing collections
    of data* section. It''s important that dictionaries are surrounded by `{}`, the
    keys and values are separated by `:`, and each key-value pair is separated by
    `,`. Yes, there''s an extra `,` at the end. This is legal in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many more HTTP headers we can provide. The `User-Agent` header is
    perhaps most important to gather different kinds of intelligence data from web
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Using FTP in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'FTP specifies ways to transfer files between computers. There are two principle
    variants: the original FTP and the more secure version, FTPS. This more secure
    version uses SSL to assure that the lower-level sockets are fully encrypted. It''s
    sometimes called `FTP_TLS`, FTP with transport layer security.'
  prefs: []
  type: TYPE_NORMAL
- en: The SSH standard includes a file-transfer protocol, SFTP. This is a part of
    SSH and is separate from other FTP variants. This is supported by the `ftplib`
    module, even though it's really a different protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, FTP access is anonymous. No security credentials (such as usernames
    or passwords) are used. This is usually reserved for download-only content. Sometimes,
    anonymous access expects a placeholder username and password—the username should
    be *anonymous*, and typically, your e-mail address is used as a password. In other
    cases, we need to have proper credentials. We'll focus on publicly accessible
    FTP servers.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to look for the CIA World Factbooks. We know that there are copies
    in Project Gutenberg. This leads us to use the [ftp.ibiblio.org](http://ftp.ibiblio.org)
    server as the target of our investigation. The base URL is [ftp://ftp.ibiblio.org/pub/docs/books/gutenberg/](ftp://ftp.ibiblio.org/pub/docs/books/gutenberg/).
  prefs: []
  type: TYPE_NORMAL
- en: FTP has its own language of commands used to examine remote (and local) filesystems,
    create and remove directories, as well as get and put files. Some of this language
    is exposed through the Python FTP module. Some of it is kept hidden under the
    hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see some top-level documents available on the Project Gutenberg server
    with a script like the following. Here''s our initial step in discovering the
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We imported the FTP library. We'll need this to do anything using the FTP protocol.
    We assigned the host, `host`, and root path, `root`, as strings. We'll use this
    in several functions that we need to define.
  prefs: []
  type: TYPE_NORMAL
- en: We defined a `directory_list()` function that will display names, types, and
    sizes from a directory. This lets us explore the files in our local directories.
    We'll use this function with different parameters after we've tracked down the
    directory with our candidate files.
  prefs: []
  type: TYPE_NORMAL
- en: The `directory_list()` function opens a context using a `ftplib.FTP` object.
    We don't need to use the `contextlib.closing()` function, because this context
    is well behaved. This object will manage the various sockets used to exchange
    data with the FTP server. One of the methods, `getwelcome()`, retrieves any welcome
    message. We'll see that this is pretty short. Sometimes, they're more elaborate.
  prefs: []
  type: TYPE_NORMAL
- en: We'll dump the top-level directory information that shows the various files,
    directories, and their sizes. The `details['type']` syntax is how we pick a particular
    name out of the name-value pairs in a dictionary. The `details.get('size')` syntax
    does a similar thing. Getting an item with `[]` will raise an exception if the
    name is not found. Getting an item with the `get()` method supplies a default
    value instead of an exception. Unless specified otherwise, the default value is
    `None`.
  prefs: []
  type: TYPE_NORMAL
- en: We're making the claim that the `details` dictionary must have a `type` item.
    If it doesn't, the program will crash, because something's very wrong. We're also
    making the claim that the `details` dictionary might or might not have the `size`
    item. If the size isn't present, the `None` value will do instead.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of files here. The `README` and `GUTINDEX.ALL` files look
    promising; let's examine them.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading a file via FTP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The FTP library relies on a technique called a **callback function** to support
    incremental processing. Downloading a 13 MB file takes some time. Having our computer
    just doze off while downloading is impolite. It's good to provide some ongoing
    status with respect to progress (or lack of it thereof).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define callback functions in a number of ways. If we''re going to use
    class definitions, the callback function will simply be another method of the
    class. Class definitions get a bit beyond the scope of our book. They''re quite
    simple, but we have to focus on espionage, not software design. Here''s a general-purpose
    `get()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `get()` function contains a function definition buried inside it. The `line_save()`
    function is the callback function that's used by the `retrlines()` function of
    an FTP connection. Each line of data from the server will be passed to the `line_save()`
    function to process it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `line_save()` function uses three `nonlocal` variables: `download`, `expected`,
    and `dots`. These variables are neither global nor are they local to the `line_save()`
    function. They''re initialized before any lines are downloaded, and they are updated
    within the `line_save()` function on a line-by-line basis. As they are a saved
    state for the `line_save()` function, we need to notify Python not to create local
    variables when these are used in an assignment statement.'
  prefs: []
  type: TYPE_NORMAL
- en: The function's primary job is to print the line to the file named in the `output`
    variable. Interestingly, the `output` variable is also nonlocal. As we never try
    to assign a new value to this variable, we don't need to notify Python about its
    use in an assignment statement. A function has read access to nonlocal variables;
    write access requires special arrangements via the `global` or `nonlocal` statements.
  prefs: []
  type: TYPE_NORMAL
- en: If the output file is `sys.stdout`, we're displaying the file on the console.
    Writing status information is just confusing. If the output file is not `sys.stdout`,
    we're saving the file. Showing some status is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: We compute how many dots (from 0 to 19) to show. If the number of dots has increased,
    we'll print another dash. Yes, we called the variable `dots` but decided to print
    dashes. Obscurity is never a good thing. You might want to take an independent
    mission and write your own version, which is clearer than this.
  prefs: []
  type: TYPE_NORMAL
- en: The `get()` function creates a context using an `ftplib.FTP` object. This object
    will manage the various sockets used to exchange data with the FTP server. We
    use the `getwelcome()` method to get the welcome message. We use the `size()`
    method to get the size of the file we're about to request. By setting the `expected`
    variable, we can assure that up to 20 dashes are displayed to show the state of
    the download.
  prefs: []
  type: TYPE_NORMAL
- en: The `retrlines()` method of the connection requires an FTP command and a callback
    function. It sends the command; each line of the response is sent to the callback
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Using our FTP get() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use this `get()` function to download files from the server. We''ll
    start with two examples of extracting files from an FTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first example is a small file. We'll display the `README` file, which might
    have useful information. It's usually small, and we can write it to `stdout` immediately.
    The second example will open a file processing context to save the large `GUTINDEX.ALL`
    file locally for further analysis. It's quite large, and we certainly don't want
    to display it immediately. We can search this index file for CIA World Factbooks.
    There are several Factbooks.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction to the `GUTINDEX.ALL` file describes how document numbers turn
    into directory paths. One of the CIA World Factbooks, for example, is document
    number 35830\. This becomes the directory path `3/5/3/35380/`. The document will
    be in this directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use our `directory_list()` function to see what else is there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show us that there are several subdirectories and a ZIP file that
    appears to have images. We''ll start with the text document. We can use our `get()`
    function to download the CIA Factbook in a script like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This gets us one of the CIA World Factbooks. We can easily track down the others.
    We can then analyze information from these downloaded documents.
  prefs: []
  type: TYPE_NORMAL
- en: Using urllib for HTTP, FTP, or file access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `urllib` package wraps HTTP, FTP, and local file access in a single, tidy
    package. In the most common situations, this package allows us to elide some of
    the processing details we saw in the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of the general approach in `urllib` is that we can write smallish
    programs that can work with data from a wide variety of locations. We can rely
    on `urllib` to work with HTTP, FTP, or local files seamlessly. The disadvantage
    is that we can''t do some more complex HTTP or FTP interactions. Here''s an example
    of downloading two images with the `urllib` version of the HTTP `get` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We've defined two URLs. When using `urllib`, we can provide full URLs without
    having to distinguish between the host and the path we're tying to access.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a context using `urllib.request.urlopen()`. This context will contain
    all of the resources used for getting the file from the World Wide Web. The `response`
    object is called a **file-like object** in Python parlance. We can use it the
    way we''d use a file: it supports `read()` and `readline()` methods. It can be
    used in a `for` statement to iterate over lines of a text file.'
  prefs: []
  type: TYPE_NORMAL
- en: Using urllib for FTP access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use a simple `urllib.request` to get a file via FTP. We can simply change
    the URL to reflect the protocol we''re using. Something like this works well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will open the source file and print it on `sys.stdout`. Note that we had
    to decode the bytes from ASCII to create proper Unicode characters for use by
    Python. We can print the other status and header information if we find it necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use a local file URL. The schema is `file:` instead of `http:`
    or `ftp:`. Generally, the hostname is omitted, thus leading to file URLs like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using `urllib` leads to a few pleasant simplifications. We can treat resources
    located across the WWW with code that's similar to handling a local file. Remote
    resources are often slower than local files; we might want to give up waiting
    after a period of time. Also, there's the possibility of network disconnections.
    Our error handling needs to be more robust when working with remote data.
  prefs: []
  type: TYPE_NORMAL
- en: Using a REST API in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great deal of intelligence data is available through REST APIs. Much of the
    data is available in simple JSON, CSV, or XML documents. In order to make sense
    of this data, we need to be able to parse these various kinds of serialization
    formats. We'll focus on JSON because it's widely used. Sadly, it's not universal.
  prefs: []
  type: TYPE_NORMAL
- en: 'A REST protocol is essentially HTTP. It will leverage `POST`, `GET`, `PUT`,
    and `DELETE` requests to implement the essential four stages in the life of persistent
    data: **Create, Retrieve, Update, and Delete** (**CRUD**) rules.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at currency conversion as a simple web API. This can both help us
    bribe our information sources as well as provide important information on the
    overall state of a nation's economy. We can measure national economies against
    each other as well as measure them against non-national crypto currencies such
    as bitcoins.
  prefs: []
  type: TYPE_NORMAL
- en: We'll get exchange and currency information from [http://www.coinbase.com](http://www.coinbase.com).
    There are a lot of similar services; this one seems reasonably complete. They
    seem to have up-to-date currency information that we can report to HQ as part
    of an overall intelligence assessment.
  prefs: []
  type: TYPE_NORMAL
- en: Their API documentation is available at [https://coinbase.com/api/doc](https://coinbase.com/api/doc).
    This tells us what URLs to use, what data to provide with the URL, and what kind
    of response to expect.
  prefs: []
  type: TYPE_NORMAL
- en: Getting simple REST data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can get the currency exchange data either with the `http.client` or `urllib.request`
    module. This won't be new to us; we already grabbed data using both libraries.
    The responses from this website will be in the JSON notation. For more information,
    see [http://www.json.org/](http://www.json.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To parse a JSON document, we''ll need to import the `json` module from the
    standard library. The response that we get from `urllib` is a sequence of bytes.
    We''ll need to decode these bytes to get a string. We can then use the `json.loads()`
    function to build Python objects from that string. Here''s how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We imported the two libraries that we need: `urllib.request` to get the data
    and `json` to parse the response.'
  prefs: []
  type: TYPE_NORMAL
- en: The currency query (`/api/v1/currencies/`) is described in the API documentation
    on the Coinbase website. When we make this request, the resulting document will
    have all of the currencies they know about.
  prefs: []
  type: TYPE_NORMAL
- en: We printed `document.info().items()`; this is the collection of headers that
    came back with the response. Sometimes, these are interesting. In this case, they
    don't tell us too much that we don't already know. What's important is that the
    `Content-Type` header has a `application/json; charset=utf-8` value . This tells
    us how to decode the bytes.
  prefs: []
  type: TYPE_NORMAL
- en: We read the resulting document (`document.read()`) and then converted the bytes
    to characters. The `Content-Type` header says that the characters were encoded
    using `utf-8`, so we'll use `utf-8` to decode the bytes and recover the original
    sequence of characters. Once we have the characters, we can use `json.loads()`
    to create a Python object from the characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will get us a list of currencies we can work with. The response object
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is a list of lists that provides the names of 161 currencies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at ways to work with a list-of-tuple structure.
    Working with a list of list is going to be very similar to working with a list
    of tuple.
  prefs: []
  type: TYPE_NORMAL
- en: To make this more flexible, we need to turn the header `items()` list into a
    dictionary. From this, we can get the `Content-Type` value string from the dictionary.
    This string can be partitioned on `;` to locate the `charset=utf-8` substring.
    This string can subsequently be partitioned on the `=` character to locate the
    `utf-8` encoding information. This would be slightly better than assuming a `utf-8`
    encoding. The first step, creating a dictionary from the headers, has to wait
    until the *Organizing collections of data* section. First, we'll look at getting
    other information using the REST protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Using more complex RESTful queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have a list of currencies, we can request spot conversion rates. This
    involves a somewhat more complex URL. We need to provide a currency code to get
    the current bitcoin exchange rate for that specific currency.
  prefs: []
  type: TYPE_NORMAL
- en: While it's not perfectly clear from the API documentation, the RFCs for the
    web state that we should encode the query string as part of our processing. In
    this specific situation, it doesn't seem possible for the query string to contain
    any characters that *require* encoding.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to be fussy though and encode the query string properly using the
    `urllib` module. Encoding will be essential for a number of examples in [Chapter
    4](ch04.html "Chapter 4. Drops, Hideouts, Meetups, and Lairs"), *Drops, Hideouts,
    Meetups, and Lairs*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Query string encoding is done using the `urllib.parse` module. It looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `scheme_netloc_path` variable has a portion of the URL. It has the scheme
    (`http`), network location (`coinbase.com`), and path (`api/v1/prices/spot_rate`).
    This fragment of the URL doesn't have the query string; we'll encode this separately
    because it had dynamic information that changes from request to request.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, a query string is a bunch of parameters that have been encoded
    so that certain reserved characters such as `?` and `#` don't cause any confusion
    to the web server. Pragmatically, the query string used here is very simple with
    only a single parameter.
  prefs: []
  type: TYPE_NORMAL
- en: To handle query strings in a general-purpose way, we defined an HTML form using
    a dictionary and assigned it to the `form` variable. This dictionary is a model
    of a form on an HTML web page with a single input field. We modeled an input field
    with a name, `currency`, that has an `EUR` value.
  prefs: []
  type: TYPE_NORMAL
- en: The `urllib.parse.urlencode()` function encodes all the fields of the form into
    a tidy representation with any reserved characters handled properly. In this case,
    there's only one field, and no reserved characters are used by the field name
    or the field value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can play with this in interactive Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how we built a form object as a dictionary and then
    encoded it to create a valid URL-encoded query string. As the data was so simple,
    the encoding is quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example with a more complex piece of data in the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we updated the form with different input; we changed the currency value
    to `Something with # or ?`. We''ll look at dictionary updates in the next section.
    The updated value has reserved characters in it. When we encoded this form, the
    result shows how reserved characters are handled by URL encoding.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we start working with more complex structures, we''ll find that the built-in
    `print()` function isn''t going to do everything we need. In the `pprint` module,
    the `pprint()` function does a much nicer job working with complex data. We can
    use this to get the pretty-print function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use our query template and the encoded data like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The expression, `scheme_netloc_path+"?"+query`, assembled the complete URL from,
    the relatively static portions, and the dynamic query string. We've used a `with`
    statement to be sure that all of the network resources are properly released when
    we're done. We used the `pprint()` function to show the headers, which tell us
    the content type. The headers also include three cookies, which we're studiously
    ignoring for these examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we print the `spot_rate` value, we see that the Python object looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These are Python dictionary objects. We'll need to learn more about dictionaries
    to be able to work with these responses. Stay tuned for the *Using a Python dictionary
    mapping* section.
  prefs: []
  type: TYPE_NORMAL
- en: Saving our data via JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we want to save the data we downloaded? This is something in which JSON
    excels. We can use the JSON module to serialize objects into a string and write
    this string to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can save our two-spot currency rate pieces of data into a JSON
    document. First, we need to turn our `spot_rate` example from the *Getting more
    RESTful data* section into a function. Here''s how it might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This function requires the currency code as an argument. Given the currency
    code, it creates a tiny input form and encodes this to create the query string.
    In this case, we saved that string in the `query` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created the URL from a template and the data. This URL was used as a request
    to get a currency spot rate. We read the entire response and decoded the string
    from bytes. Once we had the string, we loaded a Python dictionary object using
    this string. We returned this dictionary using the `get_spot_rate()` function.
    We can now use this function to get some spot-rate dictionary objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This statement built a list-of-dictionary structure from our three spot-rate
    dictionaries. It assigned the collection to the `rates` variable. Once we have
    this, we can serialize it and create a file that has some useful exchange-rate
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we use JSON to save a Python object to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We opened a file to write something and used this as a processing context to
    be assured that the file will be properly closed when we're done. We then used
    the `json.dump()` function to dump our `rates` object to this file.
  prefs: []
  type: TYPE_NORMAL
- en: What's important about this is that JSON works most simply when we encode one
    object to a file. In this case, we built a list of individual objects and encoded
    that list into the file. As we can't easily perform any sort of partial or incremental
    encoding of objects into a JSON file, we built a list with everything in it. Except
    in cases of huge mountains of data, this technique of building and dumping a list
    works very nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing collections of data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We introduced some data collections earlier in the chapter. It's time to come
    clean on what these collections are and how we can use them effectively. As we
    observed in [Chapter 1](ch01.html "Chapter 1. Our Espionage Toolkit"), *Our Espionage
    Toolkit*, Python offers a tower of different types of numbers. The commonly used
    numbers are built in; the more specialized numbers are imported from the standard
    library.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way, Python has a number of built-in collections. There is also
    a very large number of additional collection types available in the standard library.
    We'll look at the built-in lists, tuples, dictionaries, and sets. These cover
    the essential bases to work with groups of data items.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Python list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python list class can be summarized as a mutable sequence. **Mutability**
    means that we can add, change, and remove items (the list can be changed). Sequence
    means that the items are accessed based on their positions within the list.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is pleasantly simple; we put the data items in `[]` and separate
    the items with `,`. We can use any Python object in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: HQ wants information on per capita consumption of selected cheese varieties.
    While HQ doesn't reveal much to field agents, we know that they often want to
    know about natural resources and strategic economic strengths.
  prefs: []
  type: TYPE_NORMAL
- en: We can find cheese consumption data at [http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls](http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls).
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, the data is in a proprietary spreadsheet format and rather difficult
    to work with. To automate the data gathering, we would need something like Project
    Stingray to extract the data from this document. For manual data gathering, we
    can copy and paste the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the data starting in 2000 and extending through 2010; we''ll use it
    to show some simple list processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We created a list object and assigned it to the `cheese` variable. We used the
    `min()` function, which reveals the least value in the `29.87` sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The `index()` method searches through the sequence for the matching value. We
    see that the maximum consumption found with the `max()` function has an index
    of `7` corresponding to 2007\. After that, cheese consumption fell slightly.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have prefix function notations (`min()`, `max()`, `len()`, and
    several others). We also have method function notation, `cheese.index()`, and
    many others. Python offers a rich variety of notations. There's no fussy adherence
    to using only method functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a list is mutable, we can append additional values to the list. We can use
    an `cheese.extend()` function to extend a given list with an additional list of
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can also use the `+` operator to combine two lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reorder the data so that it''s strictly ascending using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `sort()` method doesn't return a value. It mutates the list object
    itself; it doesn't return a new list. If we try something like `sorted_cheese=
    cheese.sort()`, we see that `sorted_cheese` has a `None` value. This is a consequence
    of `sort()` not returning a value; it mutates the list.
  prefs: []
  type: TYPE_NORMAL
- en: When working with time-series data, this kind of transformation will be confusing
    because the relationship between year and cheese consumption is lost when we sort
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: Using list index operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can access individual items using the `cheese[index]` notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to pick specific items from a list. As the list was sorted,
    the item `0` is the least, and the item `1` is the next larger value. We can index
    *backwards* from the end of the list, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With the sorted data, the `-2` item is next to the largest one; the `-1` item
    is the last one, which is the largest value seen. In the original, unsorted `cheese[-2]`
    data would have been the 2009 data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take a *slice* from a list too. Some common slice manipulations look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first slice picks the first five values—the values of least cheese consumption.
    As we sorted the time-series data, we don't readily know which years' these were.
    We might need a more sophisticated data collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with collections, we find that we have a new comparison operator,
    `in`. We can use a simple `in` test to see if a value occurs anywhere in the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `in` operator works for tuples, dictionary keys, and sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The comparison operators compare the elements in order, looking for the first
    nonequal element between two sequences. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As the first two elements were equal, it was the third element that determined
    the relationship between the two lists. This rule also works for tuples.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Python tuple
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python tuple class can be summarized as an immutable sequence. Immutability
    means that once created, the tuple cannot be changed. The value of the number
    3 is immutable, also: it''s always 3\. Sequence means that the items are accessed
    based on their positions within the tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is pleasantly simple; we might need to put the data items in `()`
    and must separate the items with `,`. We can use any Python objects in the sequence.
    The idea is to create an object that looks like a mathematical coordinate: `(3,
    4)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples are used under the hood at many places within Python. When we use multiple
    assignments, for example, the right-hand side of the following code creates a
    tuple and the left-hand side decomposes it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The right-hand side created a two-tuple `(0, 1)`. The syntax doesn't require
    `()` around the tuple. The left-hand side broke down a two-tuple, assigning the
    values to two distinct variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'We generally use tuples for data objects where the number of elements is fixed
    by the problem domain. We often use tuples for coordinate pairs such as latitude
    and longitude. We don''t need the flexible length that a list offers because the
    size of a tuple cannot change. What would a three-tuple mean when it''s supposed
    to have just two values, latitude and longitude? A different kind of problem might
    involve longitude, latitude, and altitude; in this case, we''re working with three-tuples.
    Using two-tuples or three-tuples in these examples is an essential feature of
    the problem: we won''t be mutating objects to add or remove values.'
  prefs: []
  type: TYPE_NORMAL
- en: When we looked at HTTP headers in requests and responses, we saw that these
    are represented as a list of two-tuples, such as `('Content-Type', 'text/html;
    charset=utf-8')`. Each tuple has a header name (`'Content-Type'`) and header value
    (`'text/html; charset=utf-8'`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of using a two-tuple to include year and cheese consumption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This list-of-tuple structure allows us to perform a slightly simpler analysis
    of the data. Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We applied the `max()` function to our list of tuples. The second argument to
    the `max()` function is another function—in this case, an anonymous `lambda` object—that
    evaluates just the second value in each tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two more examples that show what''s happening with the `lambda` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `(2007, 33.5)` two-tuple has the `[1]` get item operation applied; this
    will pick the item at position `1`, that is, the `33.5` value. The item at position
    zero is the year 2007.
  prefs: []
  type: TYPE_NORMAL
- en: The `(lambda x:x[1])` expression creates an anonymous `lambda` function. We
    can then apply this function to the `(2007, 33.5)` two-tuple. As the `x[1]` expression
    picks the item at index position `1`, we get the `33.5` value.
  prefs: []
  type: TYPE_NORMAL
- en: We can, if we want, create a fully defined, named function instead of using
    `lambda`, as shown in the following code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A named function has two advantages: it has a name, and it can have multiple
    lines of code. A `lambda` function has the advantage of being tiny when the entire
    function can be reduced to a single expression.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this technique to sort these two-tuples with a function instead
    of `lambda`, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We used a separate function to create a sorted copy of a sequence. The `sorted()`
    function requires an iterable item (the `year_cheese` list in this case) and a
    key function; it creates a new list from the old sequence that is sorted into
    order by the key function. In this case, our key function is the named function,
    `by_weight()`. Unlike the `list.sort()` method, the `sorted()` function does not
    modify the original sequence; the new list contains references to the original
    items.
  prefs: []
  type: TYPE_NORMAL
- en: Using generator expressions with list of tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to locate cheese production for a given year, we need to search
    this sequence of two-tuples for the matching year. We can''t simply use the `list.index()`
    function to locate an item, as we''re only using part of the item. One strategy
    is to extract the year from the list using a generator expression, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `item[0] for item in year_cheese` expression is a generator. It iterates
    through the `year_cheese` list, assigning each item to the variable named `item`.
    The `item[0]` subexpression is evaluated for each value of `item`. This will decompose
    the two-tuples, returning a single value from each tuple. The result is collected
    into a resulting list and assigned to the `years` variable. We'll return to this
    in the *Transforming sequences with generator functions* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use `years.index(2005)` to get the index for a given year, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As `years.index(2005)` gives us the position of a given year, we can use `year_cheese[
    years.index( 2005 ) ]` to get the `year-cheese` two-tuple for the year 2005.
  prefs: []
  type: TYPE_NORMAL
- en: This idea of mapping from year to cheese consumption is directly implemented
    by a Python dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: The `in` operator and other comparison operators work for tuples in the same
    way they work for lists. They compare the target tuple to each tuple in the list
    using a simple item-by-item comparison between the items in the tuples.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Python dictionary mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A dictionary contains a mapping from keys to values. The Python dictionary class
    can be summarized as a mutable mapping. Mutability means that we can add, change,
    and remove items. Mapping means that the values are accessed based on their keys.
    Order is not preserved in a mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is pleasantly simple: we put the key-value pairs in `{}`, separate
    the key from the value with `:`, and separate the pairs with `,`. The values can
    be any kind of Python object. The keys, however, suffer from a restriction—they
    must be immutable objects. As strings and numbers are immutable, they make perfect
    keys. A tuple is immutable and a good key. A list is mutable though, and can''t
    be used as a key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we looked at creating an HTTP form data, in the *Getting more RESTful
    data* section, we used a mapping from field name to field value. We got back a
    response, which was a mapping from keys to values. The response looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: After creating the `spot_rate` dictionary, we used the `dict[key]` syntax to
    get values of two of the keys, `currency` and `amount`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a dictionary is mutable, we can easily change the values associated with
    the keys. Here''s how we can create and modify a form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We created the `form` variable as a small dictionary. We can use this to make
    one spot-rate query. We then changed the value in the `form` dictionary. We can
    use this updated form to make a second spot-rate query.
  prefs: []
  type: TYPE_NORMAL
- en: 'When getting a value, the key must exist; otherwise, we''ll get an exception.
    As noted earlier, we can also use `dict.get(key, default)` to get values when
    a key might not exist in the dictionary. Here are several examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: First, we fetched the value mapped to the `currency` key. We tried to fetch
    a value mapped to the `oops` key. We got a `KeyError` exception because the `oops`
    key isn't in the `spot_rate` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: We did the same kinds of things using the `get()` method. When we executed `spot_rate.get('amount')`,
    the key-value pair existed, so the value was returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we executed `spot_rate.get(''oops'')`, the key didn''t exist; the default
    return value was `None`. Python doesn''t print `None` values, so we don''t see
    any obvious result from this. When we executed `spot_rate.get(''oops'', ''#Missing'')`,
    we provided a return value that is not `None`, which displayed something visible.
    The idea is that we can then do things like this to make a series of related queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` statement includes a tuple of values: `''USD'', ''EUR'', ''UAH''`.
    We aren''t required to put `()` around the tuple in this particular case because
    the syntax is unambiguous.'
  prefs: []
  type: TYPE_NORMAL
- en: Each value from the literal tuple is used to set the `currency` value in the
    form. We can then use the `urllib.parse.urlencode()` function to build a query
    string. We might be using this in a `urllib.urlopen()` function to get a current
    spot price for bitcoins in that currency.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dictionary access methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Other interesting methods of a dictionary mapping include the `keys()`, `values()`,
    and `items()` methods. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `keys()` method gave us a `dict_keys` object, which contains just the keys
    in a simple list. We can sort this list or do other processing outside the dictionary.
    Similarly, the `values()` method gave us a `dict_values` object, which contains
    just the values in a simple list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `items()` method gave us a sequence of two-tuples, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We created the `rate_as_list` variable from the `spot_rate.items()` list of
    two-tuples. We can easily convert a list of two-tuple to a dictionary using the
    `dict()` function and vice versa, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This gives us a way to deal with the 161 currencies. We'll look at this in the
    next section, *Transforming sequences with generator functions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `in` operator works against the dictionary keys, not the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `currency` key exists in the `spot_rate` dictionary. The `USD` value is
    not checked by the `in` operator. If we''re looking for a specific value, we have
    to use the `values()` method explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Other comparison operators don't really make sense for a dictionary. It's essential
    to explicitly compare a dictionary's keys, values, or items.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming sequences with generator functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The data at [http://www.coinbase.com/api/v1/currencies/](http://www.coinbase.com/api/v1/currencies/),
    which was a RESTful request, was a giant list of lists. It started like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If we apply the `dict()` function to this list of lists, we''ll build a dictionary.
    However, this dictionary isn''t what we want; the following code is how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The keys in this dictionary are long `country currency (code)` strings. The
    values are the three-letter currency code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might want the keys of this as a handy lookup table for a person''s reference
    to track down the proper currency for a given country. We might use something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This shows how we can create a dictionary from a list of lists and then extract
    just the `keys()` from this dictionary. This is, in a way, an excessive amount
    of processing for a simple result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We showed an example of picking up some data using a generator function in
    the *Using a Python tuple* section. Here''s how we''d apply it to this problem.
    We''ll create a list comprehension using a generator function. The generator,
    surrounded by `[]`, will lead to a new list object, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `currencies` object is the original list of lists. The real one has 161
    items; we're working with a piece of it here to keep the output small.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generator expression has three clauses. These are *subexpressions* for
    *targets* in *source*. The `[]` characters are separate punctuations used to create
    a list objects from the generated values; they''re not part of the generator expression
    itself. The *subexpression* is evaluated for each target value. The *target* variable
    is assigned to each element from the *source* iterable object. Each two-tuple
    from the currencies list is assigned to the `name` and `code` target variables.
    The subexpression is just `name`. We can use this to build a dictionary from currency
    to full name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We used a generator function to swap the two elements of each item of the currency
    list. The targets were `name` and `code`; the resulting subexpression is the `(code,name)`
    two-tuple. We built a dictionary from this; this dictionary maps currency codes
    to country names.
  prefs: []
  type: TYPE_NORMAL
- en: Using the defaultdict and counter mappings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of sophisticated mappings that are part of the standard library.
    Two of these are the `defaultdict` and `Counter` mappings. The `defaultdict` allows
    us to work more flexibly with keys that don't exist.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the word corpus we used to recover a ZIP file password. We can
    use this word corpus for other purposes. One of the things that can help the crypto
    department decode messages is knowledge of two-letter sequences (`digram` or `bigram`)
    that occur commonly in the source documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'What are the most common two-letter digrams in English? We can easily gather
    this from our dictionary, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We need to import the `defaultdict` class from the `collections` module because
    it's not built in. We created an empty `defaultdict` object, `digram_count`, using
    `int` as the initialization function. The initialization function handles missing
    keys; we'll look at the details in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: We opened our word `corpus`. We iterated through each line in `corpus`. We transformed
    each line into a word by stripping the trailing spaces and mapping it to lowercase.
    We used the `range()` function to generate a sequence of positions from zero to
    one less than the length of the word (`len(word)-1`). We can pluck a two-character
    digram from each word using the `word[position:position+2]` slice notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we evaluate `digram_count[digram]`, one of two things will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: If the key exists in the mapping, the value is returned, just like any ordinary
    dictionary. We can then add one to the value that is returned, thus updating the
    dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the key does not exist in this mapping, then the initialization function
    is evaluated to create a default value. The value of `int()` is `0`, which is
    ideal to count things. We can then add `1` to this value and update the dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cool feature of a `defaultdict` class is that no exception is raised for
    a missing key value. Instead of raising an exception, the initialization function
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `defaultdict(int)` class is so common that we can use the `Counter` class
    definition for this. We can make two tiny changes to the previous example. The
    first change is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The second change is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for making this change is that `Counter` classes do some additional
    things. In particular, we often want to know the most common counts, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `most_common()` method of a `Counter` object returns the counts in the descending
    order. This shows us that `er` is the most common English-language digram. This
    information might help the decoders back at HQ.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Python set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python set class is mutable; we can add, change, and remove items. Items
    are either present or absent. We don't use positions or keys; we merely add, remove,
    or test the items. This means that sets have no inherent order.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is pleasantly simple; we put the data items in `{}` and separated
    the items with `,`. We can use any immutable Python objects in the set. It's important
    to note that the items must be immutable—we can include strings, numbers, and
    tuples. We can't include a list or dictionary in a set.
  prefs: []
  type: TYPE_NORMAL
- en: As the `{}` characters are used both by dictionaries and sets, it's unclear
    what the empty pair, `{}`, means. Is this an empty dictionary or an empty set?
    It's much more clear if we use `dict()` to mean an empty dictionary and `set()`
    to mean an empty set.
  prefs: []
  type: TYPE_NORMAL
- en: A set is a simple collection of things; it is perhaps the simplest possible
    collection of things.
  prefs: []
  type: TYPE_NORMAL
- en: 'In looking at the digrams, we noticed that there were some digrams, including
    a `-` character. How many hyphenated words are in the dictionary? This is a simple
    set processing example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We created an empty set and assigned it to the `hyphenated` variable. We checked
    each word in our collection of words to see if the `-` character is in the collection
    of characters. If we find the hyphen, we can add this word to our set of hyphenated
    words.
  prefs: []
  type: TYPE_NORMAL
- en: The word corpus on the author's computer had two hyphenated words. This raises
    more questions than it answers.
  prefs: []
  type: TYPE_NORMAL
- en: The `in` operator is essential for working with sets. The comparison operators
    implement subset and superset comparisons between two sets. The `a <= b` operation
    asks if `a` is a subset of `b`, mathematically, ![Using a Python set](img/0420OS_02_03.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Using the for statement with a collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for` statement is the primary tool to iterate through the items in a collection.
    When working with lists, tuples, or sets, the `for` statement will pleasantly
    assure that all values in the collection are assigned to the target variable,
    one at a time. Something like this works out nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `for` statement assigns each item in the cheese sequence to the target variable.
    We simply print each value from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with the list-of-tuples structures, we can do something a bit
    more interesting, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this example, each two-tuple was decomposed, and the two values were assigned
    to the target variables, `year` and `pounds`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can leverage this when transforming a `Count` object into percentages. Let''s
    look at our `digram_count` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: First, we computed the sum of the values in the collection. This is the total
    number of digrams found in the original corpus. In this example, it was 2,021,337\.
    Different corpora will have different numbers of digrams.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for` statement iterates through the sequence created by `digram_count.items()`.
    The `items()` method produces a sequence of two-tuples with the key and value.
    We assign these to two target variables: `digram` and `count`. We can then produce
    a nicely formatted table of all 620 digrams, their counts, and their relative
    frequency.'
  prefs: []
  type: TYPE_NORMAL
- en: This is the kind of thing that the folks in the crypto department love.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we apply the `for` statement to a dictionary directly, it iterates just
    over the keys. We could use something like this to iterate through the digram
    counts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The target variable, `digram`, is assigned to each key. We can then use a syntax
    such as `digram_count[digram]` to extract the value for this key.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python operators on collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the mathematical operators work with collections. We can use the `+`
    and `*` operators with sequences such as lists and tuples, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: These examples showed how we can concatenate two lists and multiply a list to
    create a longer list with multiple copies of the original list. The `[0]*10` statement
    shows a more useful technique to initialize a list to a fixed number of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets have a number of operators for union (`|`), intersection (`&`), difference
    (`-`), and symmetric difference (`^`). Also, the comparison operators are redefined
    to work as subset or superset comparisons. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The union operator, `|`, combines the two sets. A set means an element only
    occurs once, so there are no duplicated elements in the union of the sets. The
    intersection of two sets, `&`, is the set of common elements in the two sets.
    The subtraction operator, `-`, removes elements from the set on the left-hand
    side. The symmetric difference operator, `^`, creates a new set that has elements
    which are in one or the other set but not both; essentially, it is the same as
    an exclusive `OR`.
  prefs: []
  type: TYPE_NORMAL
- en: We showed just one comparison operator, the `<=` subset operator, between two
    sets. The other comparison operators perform just as can be expected.
  prefs: []
  type: TYPE_NORMAL
- en: Solving problems – currency conversion rates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem we have is that our informants are always asking for odd or unusual
    currencies. This isn't really all that surprising; we're dealing with spies and
    criminals on the run. They always seem to need obscure foreign currencies for
    their own nefarious projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get a big pile of international exchange rates using a piece of code
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The query string is a simple URL. When we make the request, we get back a long
    string of bytes. We decode this to make a proper string and use `json.loads()`
    to build a Python object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that we get a giant dictionary object that''s not really all
    that useful. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Also, it goes on and on for 632 different combinations of currencies.
  prefs: []
  type: TYPE_NORMAL
- en: The keys to this mapping involve two currencies separated by `_to_` and written
    in lowercase letters. The currency code pieces that we got in the earlier example
    (see the *Using a REST API in Python* section) are in uppercase. We got a bit
    of work on our hands to match this data up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to break this long list of currencies down into sublists. The neat
    way to handle this is with a dictionary of lists. We can use the `defaultdict`
    class to build these lists. Here''s a typical approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We set the `rates` variable to be a `defaultdict(list)` object. When a key is
    not found in this dictionary, an empty list will be built as the value for that
    missing key.
  prefs: []
  type: TYPE_NORMAL
- en: We can iterate through each conversion and rate in the `items()` method of the
    raw data. We'll convert the conversion string to uppercase and then partition
    the conversion on the `_TO_` string. This will separate the two currency codes,
    assigning them to `source` and `target`. As they're uppercase, we can also match
    them against our list of currency-to-country codes.
  prefs: []
  type: TYPE_NORMAL
- en: We also converted the rate from a string to a more useful `float` number. The
    string isn't useful for further calculations.
  prefs: []
  type: TYPE_NORMAL
- en: We can then accumulate a list for each currency within the `rates` dictionary.
    If the `source` currency exists, we'll append it to the list that's already present
    in the dictionary. If the `source` currency doesn't exist, we'll create an empty
    list and append it to that empty list.
  prefs: []
  type: TYPE_NORMAL
- en: We'll append a target currency and the conversion rate as a simple two-tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we''re done, we''ll have tidy, short lists. Here''s how we can pick a
    few currencies and display the conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: For a select few currencies, we printed the currency and the list of conversion
    rates available right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows us results like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `USD` list is rather large, as it includes 159 other countries and currencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we got the currency details from our earlier query, we can do this to make
    our output a little more useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We built a dictionary that maps a currency code to the full name for the currency.
    When we look up the details for a currency, our output looks a little nicer, as
    shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This is the kind of thing that can help us convert the bribe amounts into budget
    numbers that the accountants at HQ will find useful. We can also use this information
    to send national assessments based on the value of the local currency.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can use this for our own purposes to buy and sell bitcoins. This might
    help keep us one step ahead of international chaos. Alternatively, it may help
    us leverage the advantages of crypto currency.
  prefs: []
  type: TYPE_NORMAL
- en: We can save our currency details to a file using `json.dump(currency_details,
    some_open_file)`. See the example in the *Saving our data via JSON* section for
    a refresher on how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw the basics of using Python to access data available
    on the WWW. We used the HTTP protocol and the FTP protocol to transfer files around.
    We can use HTTPS and FTPS to assure that our data is kept secret.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at using RESTful web services to gather data from information sources
    that have a defined API. RESTful web services are available for many kinds of
    data. They allow us to gather and analyze data from a variety of sources without
    a lot of tedious, error-prone pointing and clicking.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also saw how to work with the various Python collections: lists, tuples,
    dictionaries, and sets. This gives us ways to capture and manage larger collections
    of information.'
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the JSON notation for Python objects. This is a handy way to transmit
    objects through the WWW. It's also handy for saving objects locally on our personal
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at how we can work with image files. These are
    a bit more complex than JSON files, but the Python `pillow` package makes them
    easy to work with. We'll specifically use image files as a way to transmit hidden
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Drops, Hideouts, Meetups, and Lairs"),
    *Drops, Hideouts, Meetups, and Lairs*, we'll expand on the web services we saw
    in this chapter. We'll use geocoding web services and extract data from more complex
    online datasets.
  prefs: []
  type: TYPE_NORMAL
