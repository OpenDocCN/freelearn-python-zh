- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Getting Started with FastAPI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速入门FastAPI
- en: The **application programming interface** (**API**) is the cornerstone of your
    FARM stack, functioning as the brain of the system. It implements business logic
    that dictates how the data flows in and out of the system, but more importantly,
    how it relates to the business requirements inside your system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序编程接口**（**API**）是您的FARM堆栈的基石，作为系统的“大脑”。它实现了业务逻辑，决定了数据如何进出系统，但更重要的是，它如何与系统内的业务需求相关联。'
- en: Frameworks such as FastAPI are much easier to showcase through examples. In
    this chapter, you’ll explore some simple endpoints that make up for a minimal,
    self-contained REST API. These examples will help you understand how FastAPI handles
    requests and responses.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如同FastAPI这样的框架，通过示例更容易展示。在本章中，您将探索一些简单的端点，这些端点构成了一个最小、自包含的REST API。这些示例将帮助您了解FastAPI如何处理请求和响应。
- en: This chapter focuses on introducing the framework, along with the standard REST
    API practices and how they are implemented in FastAPI. You’ll learn how to send
    requests and modify them according to your needs, and how to retrieve all the
    data from HTTP requests, including parameters and request bodies. You’ll also
    understand how to handle responses and how you can use FastAPI to easily set cookies,
    headers, and other standard web-related topics.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍该框架，以及标准REST API实践及其在FastAPI中的实现。您将学习如何发送请求并根据您的需求修改它们，以及如何从HTTP请求中检索所有数据，包括参数和请求体。您还将了解如何处理响应，以及您如何可以使用FastAPI轻松设置cookies、headers和其他标准网络相关主题。
- en: 'This chapter will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An overview of the FastAPI framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FastAPI框架概述
- en: Setup and requirements for a simple FastAPI app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单FastAPI应用的设置和需求
- en: Python features in FastAPI, such as type hinting, annotations, and `async/await`
    syntax
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FastAPI中的Python特性，例如类型提示、注解和`async/await`语法
- en: How FastAPI handles typical REST API tasks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FastAPI如何处理典型的REST API任务
- en: Working with form data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理表单数据
- en: Anatomy of a FastAPI project and routers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FastAPI项目的结构和路由
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要以下内容：
- en: Python setup
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python设置
- en: Virtual environments
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟环境
- en: Code editor and plugins
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码编辑器和插件
- en: REST client
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST客户端
- en: The following sections cover these requirements in more detail.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将更详细地介绍这些要求。
- en: Python setup
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python设置
- en: If you do not have Python installed, visit the Python download site ([https://www.python.org/downloads/](https://www.python.org/downloads/))
    to get the installer for your OS. In this book, you will be using **version**
    **3.11.7** or later.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装Python，请访问Python下载网站（[https://www.python.org/downloads/](https://www.python.org/downloads/））以获取您操作系统的安装程序。在本书中，您将使用**版本**
    **3.11.7**或更高版本。
- en: FastAPI relies heavily on Python hints and annotations, and Python versions
    after 3.6 treat type hints in a similar, modern way; so, while theoretically any
    version later than 3.6 should work, the code in this book uses Python version
    3.11.7, for compatibility reasons.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI严重依赖于Python提示和注解，Python 3.6之后的版本以类似现代的方式处理类型提示；因此，虽然理论上任何高于3.6的版本都应该可以工作，但本书中的代码使用Python版本3.11.7，出于兼容性的原因。
- en: 'Ensure that your Python installation is upgraded to one of the latest Python
    versions—as stated, at least version 3.11.7—and is reachable and the default version.
    You can check this by:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的Python安装已升级到最新的Python版本之一——如前所述，至少为版本3.11.7——并且是可访问的且是默认版本。您可以通过以下方式进行检查：
- en: Typing `python` in your terminal of choice.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您选择的终端中键入`python`。
- en: Using **pyenv**, a handy tool that manages multiple Python versions on the same
    machine.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**pyenv**，一个方便的工具，可以在同一台机器上管理多个Python版本。
- en: Virtual environments
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟环境
- en: If you have ever worked with a Python project before, chances are you needed
    to include some, if not dozens, Python third-party packages. After all, one of
    Python’s main strengths lies in its vast ecosystem, which is one of the primary
    reasons it's chosen for the FARM stack.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前曾经参与过Python项目，那么您可能需要包含一些，如果不是几十个，Python第三方包。毕竟，Python的主要优势之一在于其庞大的生态系统，这也是它被选为FARM堆栈的主要原因之一。
- en: Without getting into the detailed specifics of how Python manages third-party
    package installations, let’s just go over the main problems that can arise should
    you decide to use only one Python installation for all of your projects, or even
    worse, should that installation be the default operating system Python installation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入探讨Python如何管理第三方包的安装细节，让我们先概述一下，如果你决定为所有项目仅使用一个Python安装，或者更糟糕的是，如果这个安装是默认操作系统的Python安装，可能会出现的主要问题。
- en: 'Following are a few challenges:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些挑战：
- en: Operating systems often lag in terms of Python versions, so the latest couple
    of versions likely won’t be available.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统在Python版本方面通常滞后，所以最新的几个版本可能不可用。
- en: Packages will get installed into the same namespace or in the same packages
    folder, creating havoc in any application or package that depends on that package.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包将安装到相同的命名空间或相同的包文件夹中，这会在任何依赖于该包的应用程序或包中造成混乱。
- en: Python packages depend on other packages and those packages also have versions.
    Let’s suppose that you are using package A, which depends on packages B and C,
    and for some reason, you need to keep package B to a specific version (i.e., 1.2.3).
    You might need package B for a totally different project and that project might
    require a different version.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python包依赖于其他包，这些包也有版本。假设你正在使用包A，它依赖于包B和C，并且由于某种原因，你需要将包B保持在一个特定的版本（即1.2.3）。你可能需要包B用于完全不同的项目，而这个项目可能需要不同的版本。
- en: 'Reduced or impossible reproducibility: without a separate Python virtual environment,
    it would prove very difficult to quickly replicate the desired functionality with
    all the required packages.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少或无法复现：没有单独的Python虚拟环境，将很难快速复制所有必需的包所需的功能。
- en: 'Python virtual environments are the solution to the aforementioned problems
    as they allow you to work in a pristine Python development with only the packages
    and package versions that you need. In our case, the virtual environment will
    certainly include the core packages: FastAPI and Uvicorn. FastAPI, on the other
    hand, depends on Starlette, Pydantic, and so on, so it is really important to
    have the package versions under control.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Python虚拟环境是解决上述问题的解决方案，因为它们允许你在一个纯净的Python开发环境中工作，只包含你需要的包和包版本。在我们的例子中，虚拟环境将肯定包括核心包：FastAPI和Uvicorn。另一方面，FastAPI依赖于Starlette、Pydantic等，因此控制包版本非常重要。
- en: The best practice for Python development states that each project, no matter
    how big or small, should have its own virtual environment. While there are several
    ways of creating a virtual environment, which is a separated and isolated Python
    environment, you will use `virtualenv`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Python开发的最佳实践指出，无论项目大小如何，每个项目都应该有自己的虚拟环境。虽然有多种创建虚拟环境的方法，它是一个分离和独立的Python环境，但你将使用`virtualenv`。
- en: 'The basic syntax for creating new virtual environments with `virtualenv` is
    given in the following command. Once you are in the project folder, name your
    folder `FARM` or `chapter4`, open a terminal, and enter the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`virtualenv`创建新虚拟环境的基本语法如下所示。一旦你处于项目文件夹中，将你的文件夹命名为`FARM`或`chapter4`，打开一个终端，并输入以下命令：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command will create a new virtual environment for your project, a copy
    of the Python interpreter (or if you are using macOS, a brand new Python interpreter)
    and the necessary folder structure, a couple of commands necessary for activating
    and deactivating the environment, as well as a copy of the `pip` installer (pip
    installs packages).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将为你的项目创建一个新的虚拟环境，Python解释器的副本（或者在macOS上，一个全新的Python解释器），必要的文件夹结构，以及一些激活和停用环境的命令，以及`pip`安装程序的副本（pip用于安装包）。
- en: 'In order to activate your new virtual environment, you will choose one of the
    following commands, depending on your operating system. For Windows systems, type
    the following in the shell:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了激活你的新虚拟环境，你将根据你的操作系统选择以下命令之一。对于Windows系统，在shell中输入以下内容：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On Linux or macOS systems, use the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux或macOS系统上，使用以下命令：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In both cases, your shell should now be prepended with the name that you have
    given to your environment. In the command to create a new virtual environment,
    the final parameter is the name of the environment, so it was `venv` in this case.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你的shell现在应该以你为环境所取的名字作为前缀。在创建新虚拟环境的命令中，最后一个参数是环境名称，所以在这个例子中是`venv`。
- en: 'Some considerations when working with virtual environments are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用虚拟环境时，以下是一些需要考虑的事项：
- en: There are different schools of thought when it comes to virtual environment
    placement. For now, it will suffice if you keep them inside your project folder
    like you did.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚拟环境放置方面，存在不同的观点。目前，如果你像之前那样将它们保存在项目文件夹内就足够了。
- en: Similar to the `activate` command, there is also a `deactivate` command to exit
    your virtual environment.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `activate` 命令类似，还有一个 `deactivate` 命令可以退出你的虚拟环境。
- en: Saving the exact package versions in a `requirements.txt` file and pinning the
    dependencies is not only useful but also often mandatory when deploying.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `requirements.txt` 文件中保存确切的包版本并固定依赖项不仅有用，而且在部署时通常是必需的。
- en: There are many alternatives to `virtualenv` in the Python community, as well
    as many complementary packages. Poetry is a tool that manages virtual environments
    and dependencies simultaneously, `virtualenvwrapper` is a set of utilities that
    further simplify the process of environment management. `pyenv` is a bit more
    complex—it manages Python versions and allows you to have different virtual environments
    based on different Python versions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Python 社区中有许多 `virtualenv` 的替代方案，以及许多互补的包。Poetry 是一个同时管理虚拟环境和依赖项的工具，`virtualenvwrapper`
    是一组进一步简化环境管理过程的实用工具。`pyenv` 稍微复杂一些——它管理 Python 版本，并允许你根据不同的 Python 版本拥有不同的虚拟环境。
- en: Code editors
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码编辑器
- en: While there are many great code editors and **integrated development environments**
    (**IDEs**) for Python, a common choice is **Visual Studio Code** (**VS Code**)
    from Microsoft. Released in 2015, it’s cross-platform, providing a lot of integrated
    tools, such as an integrated terminal for running your development server. It’s
    lightweight and offers hundreds of plugins for virtually any programming task
    you may have. Since you’ll be working with JavaScript, Python, React, and CSS
    for styling, along with running command-line processes, using VS Code is the easiest
    option.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多优秀的 Python 代码编辑器和 **集成开发环境**（**IDE**），但一个常见的选择是微软的 **Visual Studio Code**（**VS
    Code**）。2015 年发布，它是跨平台的，提供了许多集成工具，例如用于运行开发服务器的集成终端。它轻量级，提供了数百个插件，几乎可以满足你任何编程任务的需求。由于你将使用
    JavaScript、Python、React 和 CSS 进行样式设计，以及运行命令行进程，因此使用 VS Code 是最简单的方法。
- en: 'There’s also an excellent MongoDB plugin named **MongoDB for VS Code**, that
    allows you to connect to a MongoDB or Atlas cluster, navigate through databases
    and collections, get a quick overview of the schema and indexes, and view documents
    in collections. This proves very handy in a full stack scenario when you find
    yourself dealing with backend code in Python, frontend code in JavaScript and
    React or Next.js, running shells, and needing to quickly view the state of the
    MongoDB database. The extension is available here: [https://marketplace.visualstudio.com/items?itemName=mongodb.mongodb-vscode](https://marketplace.visualstudio.com/items?itemName=mongodb.mongodb-vscode).
    You can install it from the **Extensions** tab in Visual Studio Code as well,
    just by searching for MongoDB.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一个名为 **MongoDB for VS Code** 的优秀 MongoDB 插件，它允许你连接到 MongoDB 或 Atlas 集群，浏览数据库和集合，快速查看模式索引，以及查看集合中的文档。这在全栈场景中非常有用，当你发现自己正在处理
    Python 的后端代码、JavaScript 和 React 或 Next.js 的前端代码、运行外壳，并需要快速查看 MongoDB 数据库的状态时。扩展程序可在以下链接找到：[https://marketplace.visualstudio.com/items?itemName=mongodb.mongodb-vscode](https://marketplace.visualstudio.com/items?itemName=mongodb.mongodb-vscode)。你还可以在
    Visual Studio Code 的 **扩展** 选项卡中通过搜索 MongoDB 来安装它。
- en: Terminal
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端
- en: Besides Python and Git, you’ll need a shell program. Linux and Mac users usually
    have one pre-installed. For Windows, you can use Windows PowerShell or a console
    emulator such as **Cmder** ([https://cmder.app](https://cmder.app/)), which offers
    additional features.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Python 和 Git 之外，你还需要一个外壳程序。Linux 和 Mac 用户通常已经预装了一个。对于 Windows，你可以使用 Windows
    PowerShell 或像 **Cmder** ([https://cmder.app](https://cmder.app/)) 这样的控制台模拟器，它提供了额外的功能。
- en: REST clients
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST 客户端
- en: To effectively test your REST API, you’ll need a REST client. While **Postman**
    ([https://www.postman.](https://www.postman.com/)) is robust and customizable,
    there are other viable alternatives. **Insomnia** () and the REST GUI offer a
    simpler interface, while **HTTPie** (), a command-line REST API client, allows
    quick testing without leaving the shell. It offers features such as an expressive
    syntax, handling of forms and uploads, and sessions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地测试您的REST API，您需要一个REST客户端。虽然**Postman**([https://www.postman.com/](https://www.postman.com/))功能强大且可定制，但还有其他可行的替代方案。**Insomnia**()和REST
    GUI提供了一个更简单的界面，而**HTTPie**()，一个命令行REST API客户端，允许在不离开shell的情况下快速测试。它提供了诸如表达性语法、表单和上传处理以及会话等功能。
- en: HTTPie is probably the easiest REST client to install, as it can be done using
    `pip` or some other package manager, such as Chocolatey, apt (for Linux), or Homebrew.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPie可能是安装最简单的REST客户端，因为它可以使用`pip`或其他包管理器，如Chocolatey、apt（用于Linux）或Homebrew。
- en: 'The easiest way to install HTTPie is to activate your virtual environment and
    use `pip`, as shown in the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 安装HTTPie的最简单方法是激活您的虚拟环境并使用`pip`，如下面的命令所示：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once it’s been installed, you can test HTTPie with the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以使用以下命令测试HTTPie：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The output should begin with an `HTTP/1.1 200` `OK` response.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该以`HTTP/1.1 200` `OK`响应开始。
- en: '`venv` signifies that the virtual environment is active. HTTPie simplifies
    issuing HTTP requests by simply adding `POST` for `POST` requests, payloads, form
    values, and so on.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`venv`表示虚拟环境已激活。HTTPie通过简单地添加`POST`来简化HTTP请求，包括有效载荷、表单值等。'
- en: Installing the necessary packages
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装必要的包
- en: 'After setting up the virtual environment, you should activate it and install
    the Python libraries required for your first simple application: FastAPI and Uvicorn.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置虚拟环境之后，您应该激活它并安装运行第一个简单应用程序所需的Python库：FastAPI和Uvicorn。
- en: 'For FastAPI to run, it needs a server. In this case, a server is a software
    designed to serve web applications (or REST APIs). FastAPI relies on the **asynchronous
    server gateway interface** (**ASGI**), which enables async non-blocking applications,
    which is something you can completely use with your FastAPI capabilities. You
    can read more about ASGI in the following documentation: [https://asgi.readthedocs.io/](https://asgi.readthedocs.io/).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使FastAPI运行，它需要一个服务器。在这种情况下，服务器是一种用于提供Web应用程序（或REST API）的软件。FastAPI依赖于**异步服务器网关接口**（**ASGI**），它使异步非阻塞应用程序成为可能，这是您可以完全利用FastAPI功能的地方。您可以在以下文档中了解更多关于ASGI的信息：[https://asgi.readthedocs.io/](https://asgi.readthedocs.io/)。
- en: 'At present, the FastAPI documentation lists three compatible Python ASGI-compatible
    servers: **Uvicorn**, **Hypercorn**, and **Daphne**. This book will focus on Uvicorn,
    the most widely used and recommended option for working with FastAPI. Uvicorn
    offers high performance, and if you get stuck, there’s extensive documentation
    available online.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，FastAPI文档列出了三个兼容Python ASGI的服务器：**Uvicorn**、**Hypercorn**和**Daphne**。本书将重点介绍Uvicorn，这是与FastAPI一起使用最广泛和推荐的选择。Uvicorn提供高性能，如果您遇到困难，网上有大量的文档可供参考。
- en: 'To install the first two dependencies, ensure you’re in your working directory
    with the desired virtual environment activated, then execute the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装前两个依赖项，请确保您位于工作目录中，并激活了所需的虚拟环境，然后执行以下命令：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, you have a Python coding environment that contains a shell, one or two
    REST clients, a great editor, and a great REST framework. If you’ve previously
    developed a **Django** or **Flask** application, this should all be familiar ground.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您拥有了一个包含shell、一个或两个REST客户端、一个优秀的编辑器和优秀的REST框架的Python编码环境。如果您之前开发过**Django**或**Flask**应用程序，这些都应该很熟悉。
- en: Finally, choose a folder or clone this book’s GitHub repository and activate
    a virtual environment. It is customary to create the environment in a folder named
    `venv` within the working directory, but feel free to structure your directories
    and code as you prefer.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，选择一个文件夹或克隆这本书的GitHub仓库，并激活一个虚拟环境。通常，在工作目录中创建一个名为`venv`的文件夹来创建环境，但请随意根据您的喜好来组织您的目录和代码。
- en: Later, this chapter will briefly discuss some options for structuring your FastAPI
    code. For now, ensure you’re in a folder with your newly created virtual environment
    activated.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，本章将简要讨论一些结构化您的FastAPI代码的选项。现在，请确保您在一个已激活新创建的虚拟环境的文件夹中。
- en: FastAPI in a nutshell
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速了解FastAPI
- en: In [*Chapter 1*](B22406_01.xhtml#_idTextAnchor010), *Web Development and the
    FARM Stack*, it was mentioned why FastAPI is the preferred REST framework in the
    FARM stack. What sets FastAPI apart is its coding speed and the resulting clean
    code, with which you can spot bugs quickly and early. The author of the framework
    himself, *Sebastian Ramirez*, often modestly emphasizes that FastAPI is just a
    mix of Starlette and Pydantic, while heavily relying on modern Python features,
    especially type hinting.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 1 章*](B22406_01.xhtml#_idTextAnchor010)，*Web 开发和 FARM 栈*中，提到了为什么 FastAPI
    是 FARM 栈中首选的 REST 框架。使 FastAPI 独特的是其编码速度和由此产生的干净代码，这使得你可以快速发现并修复错误。该框架的作者 *Sebastian
    Ramirez* 经常谦逊地强调，FastAPI 只是 Starlette 和 Pydantic 的混合，同时大量依赖现代 Python 特性，特别是类型提示。
- en: Before diving into an example and building a FastAPI app, it is useful to quickly
    go over the frameworks that FastAPI is based on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入示例和构建 FastAPI 应用程序之前，快速回顾 FastAPI 所基于的框架是有用的。
- en: Starlette
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Starlette
- en: Starlette is an ASGI framework known for its top performance and numerous features,
    which are also available in FastAPI. These include WebSocket support, events on
    startup and shutdown, session and cookie support, background tasks, middleware
    implementations, and templates. While you will not be coding directly in Starlette,
    it is important to know how FastAPI works under the hood and what its origins
    are.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Starlette 是一个以高性能和众多特性著称的 ASGI 框架，这些特性在 FastAPI 中也有提供。这些包括 WebSocket 支持、启动和关闭时的事件、会话和
    Cookie 支持、后台任务、中间件实现和模板。虽然你不会直接在 Starlette 中编码，但了解 FastAPI 内部的工作原理及其起源是很重要的。
- en: If you’re interested in knowing its functionalities, visit Starlette’s excellent
    documentation (https://www.starlette.io/).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对其功能感兴趣，请访问 Starlette 优秀的文档（https://www.starlette.io/）。
- en: Asynchronous programming
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步编程
- en: You will likely have learned about the asynchronous programming paradigm when
    developing apps with Node.js. It involves running slow operations, such as network
    calls and file reading, allowing the system to respond to other requests without
    blocking. This is achieved by using an event loop, an asynchronous task manager
    that enables it to move requests to the next one, even though the previous one
    hasn’t finished and yielded a response.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在学习使用 Node.js 开发应用程序时已经接触过异步编程范式。这涉及到执行慢速操作，例如网络调用和文件读取，使得系统可以在不阻塞的情况下响应其他请求。这是通过使用事件循环，一个异步任务管理器来实现的，它允许系统将请求移动到下一个，即使前一个请求尚未完成并返回响应。
- en: Python added support for asynchronous I/O programming in version 3.4 and the
    `async`/`await` keywords in version 3.6\. ASGI emerged shortly afterward in the
    Python world, outlining how applications should be structured and called, and
    defining the events that can be sent and received. FastAPI relies on ASGI and
    returns an ASGI-compatible app.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在 3.4 版本中增加了对异步 I/O 编程的支持，并在 3.6 版本中引入了 `async`/`await` 关键字。ASGI 在 Python
    世界中随后出现，概述了应用程序应该如何构建和调用，并定义了可以发送和接收的事件。FastAPI 依赖于 ASGI 并返回一个 ASGI 兼容的应用程序。
- en: In this book, all the endpoint functions are prefixed with the `async` keyword,
    even before they become necessary, since you will be using the asynchronous Motor
    Python MongoDB driver.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，所有端点函数都带有 `async` 关键字前缀，甚至在它们成为必要之前，因为你会使用异步的 Motor Python MongoDB 驱动程序。
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are developing a simple application not expecting high stress, you can
    use simple synchronous code and the official PyMongo driver.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发一个不需要高压力的简单应用程序，你可以使用简单的同步代码和官方的 PyMongo 驱动程序。
- en: Functions with the `async` keyword are coroutines; they run on the event loop.
    While simple examples in this chapter may work without `async`, the real power
    of asynchronous programming in FastAPI will be visible when you connect to your
    MongoDB server through an `async` driver, such as **Motor** (https://motor.readthedocs.io/en/stable/).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 `async` 关键字的函数是协程；它们在事件循环上运行。虽然本章中的简单示例可能不需要 `async` 就能工作，但当你通过一个异步驱动程序，如
    **Motor** (https://motor.readthedocs.io/en/stable/)，连接到你的 MongoDB 服务器时，FastAPI
    中异步编程的真正力量将变得明显。
- en: Standard REST API operations
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准的 REST API 操作
- en: This section will discuss some common terminologies in API development. Usually,
    communication occurs via the HTTP protocol, through HTTP requests and responses.
    You’ll explore how FastAPI handles these aspects and leverages additional libraries
    such as Pydantic and type hints to improve efficiency. In the examples, you’ll
    be using Uvicorn as the server.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论API开发中的一些常见术语。通常，通信通过HTTP协议进行，通过HTTP请求和响应。你将探索FastAPI如何处理这些方面，并利用Pydantic和类型提示等额外库来提高效率。在示例中，你将使用Uvicorn作为服务器。
- en: The basis of any REST API communication is a system of URLs and paths. The URL
    for your local web development server will be `http://localhost:8000` since `8000`
    is the default port that Uvicorn uses. The path part (optional) of an endpoint
    could be `/cars`, while `http` is the scheme. You will see how FastAPI handles
    paths, query strings, and the request and response bodies, the significance of
    defining endpoint functions in a certain order, and how to extract variables from
    dynamic path segments effectively.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 任何REST API通信的基础是一个URL和路径的系统。你的本地Web开发服务器的URL将是`http://localhost:8000`，因为`8000`是Uvicorn使用的默认端口。端点的路径部分（可选）可以是`/cars`，而`http`是方案。你将看到FastAPI如何处理路径、查询字符串、请求和响应正文，定义端点函数的特定顺序的重要性，以及如何有效地从动态路径段中提取变量。
- en: In every path or address, the URL and the path combined, there’s a set of approved
    actions that can be performed on it—HTTP verbs. For example, a page or URL might
    list all the cars on sale, but you cannot issue a `POST` request since this is
    not allowed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个路径或地址中，URL和路径的组合，都有一组可以执行的操作—HTTP动词。例如，一个页面或URL可能列出所有待售的汽车，但你不能发出`POST`请求，因为这不被允许。
- en: In FastAPI, these verbs are implemented as Python **decorators**. To put it
    better, they are exposed as decorators, and they are implemented only if you,
    the developer, implement them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在FastAPI中，这些动词作为Python**装饰器**实现。换句话说，它们被公开为装饰器，并且只有当你，即开发者，实现它们时，它们才会被实现。
- en: FastAPI encourages the proper and semantic use of HTTP verbs for data resource
    operations. For example, you should always use `POST` (or the `@post` decorator)
    when creating new resources, `GET` for reading data (individual or lists of items),
    `PATCH` for updating, and so on.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI鼓励正确和语义化地使用HTTP动词进行数据资源操作。例如，在创建新资源时，你应该始终使用`POST`（或`@post`装饰器），对于读取数据（单个或项目列表），使用`GET`，对于更新使用`PATCH`等等。
- en: HTTP messages consist of a request/status line, headers, and, optionally, body
    data. FastAPI offers tools to easily create and modify headers, set response codes,
    and manipulate request and response bodies in a clean and intuitive way.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP消息由请求/状态行、头部和可选的正文数据组成。FastAPI提供了工具，可以轻松创建和修改头部、设置响应代码以及以干净直观的方式操作请求和响应正文。
- en: This section describes the programming concepts and specific Python features
    that underpin FastAPI’s performance and enable maintainable code. In the next
    section, you’ll learn about standard REST API operations and see how they’re achieved
    with FastAPI.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了支撑FastAPI性能的编程概念和特定的Python特性，使代码易于维护。在下一节中，你将了解标准的REST API操作，并了解它们是如何通过FastAPI实现的。
- en: How does FastAPI speak REST?
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FastAPI是如何表达REST的？
- en: 'Observing even a minimal FastAPI application, the classic **Hello World** example,
    you can start examining how FastAPI structures endpoints. In this context, an
    endpoint specifies the following details:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 观察一个最小的FastAPI应用程序，例如经典的**Hello World**示例，你可以开始检查FastAPI如何构建端点。在这个上下文中，端点指定以下详细信息：
- en: 'A unique combination of a URL: This will be the same in your development server—`localhost:8000`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个独特的URL组合：这将在你的开发服务器中保持一致—`localhost:8000`。
- en: 'A path: The part after the slash.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径：斜杠后面的部分。
- en: An HTTP method.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP方法。
- en: 'In a new folder named `Chapter4`, for example, create a new Python file named
    `chapter4_01.py` by using Visual Studio Code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在名为`Chapter4`的新文件夹中，使用Visual Studio Code创建一个名为`chapter4_01.py`的新Python文件：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this code, you can accomplish several things. Here’s a breakdown of what
    each part does:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，你可以完成几件事情。以下是每个部分的作用分解：
- en: In the first line of `chapter4_01.py`, you imported the FastAPI class from the
    `fastapi` package.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`chapter4_01.py`的第一行中，你从`fastapi`包中导入了FastAPI类。
- en: Next, you instantiated an application object. This is just a Python class with
    all the API functionalities that exposes an ASGI-compatible application, which
    must be passed to Uvicorn.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，你实例化了一个应用程序对象。这只是一个具有所有API功能并暴露一个ASGI兼容应用程序的Python类，这个应用程序必须传递给Uvicorn。
- en: Now, the application is ready and instantiated. But without endpoints, it can’t
    do or say much. It has one endpoint, the root, which you can view at `http://127.0.0.1:8000/`.
    FastAPI exposes decorators for HTTP methods to tell the application how and whether
    to respond. However, you must implement them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序已经准备就绪并实例化。但没有端点，它无法做或说很多。它有一个端点，即根端点，你可以在 `http://127.0.0.1:8000/` 上查看。FastAPI
    提供了用于 HTTP 方法的装饰器，以告诉应用程序如何以及是否响应。然而，你必须实现它们。
- en: After that, you used the `@get` decorator, which corresponds to the `GET` method,
    and passed a URL—in this case, the root path, `/`, is used.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你使用了 `@get` 装饰器，它对应于 `GET` 方法，并传递了一个 URL——在这种情况下，使用了根路径 `/`。
- en: The decorated function, named `root`, is responsible for responding to requests.
    It accepts any arguments (in this case, there aren’t any). The value returned
    by the function, typically a Python dictionary, will be transformed into a **JavaScript
    Object Notation** (**JSON**) response by the ASGI server and returned as an HTTP
    response. This may seem obvious, but it is useful to break things down to understand
    the fundamentals.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰的函数，命名为 `root`，负责响应请求。它接受任何参数（在这种情况下，没有参数）。函数返回的值，通常是 Python 字典，将由 ASGI 服务器转换为
    **JavaScript 对象表示法**（**JSON**）响应，并作为 HTTP 响应返回。这看起来可能很显然，但将其分解以了解基础知识是有用的。
- en: 'The preceding code defines a fully functional application with a single endpoint.
    To test it, you need a Uvicorn server. Now, you must run the live server with
    Uvicorn in your command line:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个具有单个端点的完整功能应用程序。要测试它，你需要一个 Uvicorn 服务器。现在，你必须使用 Uvicorn 在你的命令行中运行实时服务器：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You will use this code snippet quite often when developing with FastAPI, so
    the following note will break it down.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 FastAPI 进行开发时，你将非常频繁地使用此代码片段，所以以下说明将对其进行分解。
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Uvicorn is your ASGI-compatible web server. You can call it directly by passing
    it the combination of the executable Python file (without the extension) and the
    instantiated app (the FastAPI instance), separated by a colon (`:`). The `--reload`
    flag instructs Uvicorn to reload the server each time you save your code, similar
    to *Nodemon* in Node.js. Unless specified otherwise, you can run all the examples
    in this book containing FastAPI apps using this syntax.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Uvicorn 是你的 ASGI 兼容的 Web 服务器。你可以通过传递可执行 Python 文件（不带扩展名）和实例化应用（FastAPI 实例）的组合（由冒号
    `:` 分隔）来直接调用它。`--reload` 标志指示 Uvicorn 在你保存代码时每次重新加载服务器，类似于 Node.js 中的 *Nodemon*。除非指定其他方式，否则你可以使用此语法运行本书中包含
    FastAPI 应用的所有示例。
- en: 'Here’s the output when testing your only endpoint with HTTPie. Remember, when
    you omit the keyword for the method, it defaults to a `GET` request:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 HTTPie 测试唯一端点时的输出。记住，当你省略方法的关键字时，它默认为 `GET` 请求：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: HTTPie informs you that your simple endpoint is running. You will get a `200
    OK` status code, the `content-type` is correctly set to `application/json`, and
    the response is a JSON object containing the desired message.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPie 通知你你的简单端点正在运行。你将获得 `200 OK` 状态码，`content-type` 设置正确为 `application/json`，并且响应是一个包含所需消息的
    JSON 对象。
- en: Every REST API guide begins with similar *hello world* examples, but with FastAPI,
    this is particularly useful. With a couple of lines of code, you can see the anatomy
    of a simple endpoint. This endpoint only covers the `GET` method directed toward
    the root URL (`/`). So, if you try to test this app with a `POST` request, you
    should get a `405 Method Not Allowed` error (or any method other than `GET`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每个REST API指南都以类似的 *hello world* 示例开始，但使用 FastAPI，这尤其有用。只需几行代码，你就可以看到简单端点的结构。这个端点仅覆盖针对根
    URL (`/`) 的 `GET` 方法。因此，如果你尝试使用 `POST` 请求测试此应用，你应该会收到 `405 Method Not Allowed`
    错误（或任何非 `GET` 方法）。
- en: 'If you want to create an endpoint that responds with the same message but for
    `POST` requests, you will just have to change the decorator. Add the following
    code to the end of your file (`chapter4_01.py`):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个对 `POST` 请求返回相同消息的端点，你只需更改装饰器。将以下代码添加到文件末尾（`chapter4_01.py`）：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'HTTPie will respond accordingly in the terminal:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPie 将在终端中相应地响应：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that you’ve created a couple of endpoints, head over to `http://localhost:8000/docs`
    and see what FastAPI has generated for you.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一些端点，请转到 `http://localhost:8000/docs`，看看 FastAPI 为你生成了什么。
- en: Automatic documentation
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动文档
- en: When developing REST APIs, you will find yourself needing to constantly perform
    API calls—`GET` and `POST` requests—analyze the responses, set payloads and headers,
    and so on. Choosing a viable REST client is largely a matter of preference and
    is something that should be carefully considered. While there are numerous clients
    on the market— ranging from full-blown API IDEs such as Postman ([https://www.postman.com/](https://www.postman.com/))
    to the slightly more lightweight Insomnia ([https://insomnia.rest/](https://insomnia.rest/))
    or Visual Studio Code’s REST Client ([https://marketplace.visualstudio.com/items?itemName=humao.rest-client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client))—this
    book mostly uses the very simple command-line based HTTPie client, which exposes
    a minimalistic command-line interface.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 REST API 时，你会发现你需要不断执行 API 调用——`GET` 和 `POST` 请求——分析响应，设置有效载荷和头信息，等等。选择一个可行的
    REST 客户端在很大程度上是一个个人喜好问题，这是一件应该仔细考虑的事情。虽然市场上有很多客户端——从功能齐全的 API IDE，如 Postman ([https://www.postman.com/](https://www.postman.com/))，到稍微轻量级的
    Insomnia ([https://insomnia.rest/](https://insomnia.rest/)) 或 Visual Studio Code
    的 REST 客户端 ([https://marketplace.visualstudio.com/items?itemName=humao.rest-client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client))——本书主要使用非常简单的基于命令行的
    HTTPie 客户端，它提供了一个简约的命令行界面。
- en: This, however, is the right moment to introduce another of FastAPI’s most beloved
    features—interactive documentation—a tool that facilitates the development process
    of REST APIs in FastAPI.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这正是介绍 FastAPI 最受欢迎的另一个特性的正确时机——交互式文档——这是一个有助于在 FastAPI 中开发 REST API 的工具。
- en: With each endpoint or router that you develop, FastAPI creates automatically
    generated documentation. It is interactive, allowing you to test your API as you
    develop it. FastAPI lists all the endpoints you define and provides information
    about expected inputs and responses. The documentation is based on the OpenAPI
    specification and relies heavily on Python hints and the Pydantic library. It
    allows setting the JSON or form data to be sent to the endpoints, displays responses
    or errors, is tightly coupled with Pydantic, and is able to handle simple authorization
    procedures such as the bearer token flow that will be implemented in [*Chapter
    6*](B22406_06.xhtml#_idTextAnchor105)*, Authentication and Authorization*. Rather
    than having to use a REST client, you can just open the documentation, select
    the desired endpoint to be tested, input the test data conveniently into a standard
    web page, and hit the **Submit** button!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你开发的每个端点或路由器，FastAPI 会自动生成文档。它是交互式的，允许你在开发过程中测试你的 API。FastAPI 列出你定义的所有端点，并提供有关预期输入和响应的信息。该文档基于
    OpenAPI 规范，并大量依赖于 Python 提示和 Pydantic 库。它允许设置要发送到端点的 JSON 或表单数据，显示响应或错误，与 Pydantic
    紧密耦合，并且能够处理简单的授权程序，例如将在 [*第 6 章*](B22406_06.xhtml#_idTextAnchor105)*，认证和授权* 中实现的携带令牌流。你无需使用
    REST 客户端，只需打开文档，选择要测试的端点，方便地将测试数据输入到标准网页中，然后点击 **提交** 按钮！
- en: In this section, you created a minimal, yet fully functional API with a single
    endpoint, giving you insights into the syntax and structure of an app. In the
    next section, you will learn about the basic elements of a REST API request-response
    cycle and how you can control every single aspect of the process. Standard REST
    clients provide a more transferable experience and enable you to compare different
    APIs, even those that aren’t Python-based.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你创建了一个最小化但功能齐全的 API，具有单个端点，让你了解了应用程序的语法和结构。在下一节中，你将了解 REST API 请求-响应周期的基本元素以及如何控制过程的每个方面。标准
    REST 客户端提供了一种更可移植的体验，并允许你比较不同的 API，即使它们不是基于 Python 的。
- en: Building a showcase API
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建展示 API
- en: REST APIs revolve around HTTP requests and responses, which power the web and
    are implemented in every web framework using the HTTP protocol. To showcase the
    capabilities of FastAPI, you will now create simple endpoints that focus on specific
    parts of code that achieve the desired functionalities. Rather than the usual
    CRUD operations, the next sections will focus on the process of retrieving and
    setting request and response elements.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 围绕 HTTP 请求和响应展开，这些是网络的动力，并且在每个使用 HTTP 协议的 Web 框架中实现。为了展示 FastAPI 的功能，你现在将创建简单的端点，专注于实现所需功能的特定代码部分。而不是常规的
    CRUD 操作，接下来的部分将专注于检索和设置请求和响应元素的过程。
- en: Retrieving path and query parameters
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取路径和查询参数
- en: The first endpoint will be for retrieving a fictional car by its unique ID.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个端点将用于通过其唯一的 ID 获取一个虚构的汽车。
- en: 'Create a file called `chapter4_02.py` and insert the following code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `chapter4_02.py` 的文件，并插入以下代码：
- en: '[PRE11]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Try it out and test the endpoint with an ID equal to `1`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试一下，并使用等于 `1` 的 ID 来测试端点：
- en: '[PRE12]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You got your JSON response back, but here, `1` in the response is a string
    (hint: quotes). You can try this same route with an ID equal to a string:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你收到了你的 JSON 响应，但在这里，响应中的 `1` 是一个字符串（提示：引号）。你可以尝试用等于字符串的 ID 来执行相同的路由：
- en: '[PRE13]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: FastAPI returns your string, which was provided as part of the dynamic parameter.
    However, Python’s newer features, such as type hinting, come into play.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FastAPI 返回你提供的字符串，它是作为动态参数的一部分提供的。然而，Python 的新特性，如类型提示，也派上用场。
- en: 'Returning to your FastAPI route (or endpoint) to make the car ID become an
    integer, it is enough to hint at the type of the variable parameter. The endpoint
    will look like this:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到你的 FastAPI 路径（或端点），使汽车 ID 成为整数，只需对变量参数的类型进行提示即可。端点将看起来像这样：
- en: '[PRE14]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You have given it a new path: `/carh/{id}` (the `h` after `car` means hint).
    Apart from the function’s name (`hinted_car_id`), the only difference is in the
    argument: the semicolon followed by `int` means that you can expect an integer,
    but FastAPI takes this very seriously and you can already see how the framework
    puts the hinting system to good use.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经给它指定了一个新的路径：`/carh/{id}`（`car` 后面的 `h` 表示提示）。除了函数名（`hinted_car_id`）外，唯一的区别在于参数：紧跟在
    `int` 后面的分号表示你可以期望一个整数，但 FastAPI 对此非常认真，你已经在框架中看到了如何很好地使用提示系统。
- en: If you take a look at the interactive documentation at `http://localhost:8000/docs`
    and try to insert a string in the `id` field for the `/carh/` endpoint, you will
    get an error.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `http://localhost:8000/docs` 上的交互式文档，并尝试在 `/carh/` 端点的 `id` 字段中插入一个字符串，你会得到一个错误。
- en: 'Now, try it out in your REST client and test the `/carh/` route by passing
    it a string. First, FastAPI sets the status code for you correctly—that is, `422
    Unprocessable Entity`—and in the body of the response, it pointed out what the
    problem was—the value is not a valid integer. It also informs you of the exact
    location where the error occurred: in the `id` path.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的 REST 客户端中尝试运行它，并通过传递一个字符串来测试 `/carh/` 路径。首先，FastAPI 为你正确地设置了状态码——即 `422
    Unprocessable Entity`——并在响应体中指出问题所在——值不是一个有效的整数。它还告知你错误发生的确切位置：在 `id` 路径中。
- en: This is a trivial example but imagine that you are sending a complex request
    with a complicated path, several query strings, and maybe additional information
    in the header. Using type hinting quickly solves these problems.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，但想象一下你正在发送一个复杂的请求，路径复杂，有多个查询字符串，也许还有头部中的附加信息。使用类型提示可以快速解决这些问题。
- en: 'If you try to access the endpoint without specifying any ID, you will get yet
    another error:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试访问端点而不指定任何 ID，你将得到另一个错误：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: FastAPI has, again, correctly set the status code, giving you a `404 Not Found`
    error, and repeated this message in the body. The endpoint you hit does not exist;
    you must specify a value after the slash.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 再次正确地设置了状态码，给你一个 `404 Not Found` 错误，并在响应体中重复了此消息。你访问的端点不存在；你必须在斜杠后指定一个值。
- en: 'Situations may arise where you have similar paths: both dynamic and static.
    A typical case is an application that has numerous users. Directing the API at
    the URL defined by `/users/id` would give you some information about the user
    with the selected ID, while `/users/me` would typically be an endpoint that displays
    your information and allows you to modify it, in some way.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现你拥有类似路径的情况：既有动态路径也有静态路径。一个典型的情况是拥有众多用户的应用程序。将 API 定向到由 `/users/id` 定义的
    URL 将会给你一些关于选定 ID 的用户信息，而 `/users/me` 通常是一个显示你的信息并允许你以某种方式修改它的端点。
- en: In these situations, it is important to remember that, like in other web frameworks,
    order matters. Because of said order of path handler declarations, the following
    piece of code will not yield the desired results as the application will try to
    match the `/me` route with the first endpoint that it encounters—the one that
    requires an ID—and since the `/me` part is not a valid ID, you will get an error.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，重要的是要记住，与其他 Web 框架一样，顺序很重要。由于路径处理程序声明的顺序，以下代码将不会产生预期的结果，因为应用程序会尝试将 `/me`
    路径与它遇到的第一个端点匹配——需要 ID 的那个端点——由于 `/me` 部分不是一个有效的 ID，你会得到一个错误。
- en: 'Create a new file called `chapter4_03.py` and paste the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `chapter4_03.py` 的新文件，并将以下代码粘贴进去：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When you run the application and test the `/user/me` endpoint, you will get
    a `422 Unprocessable Entity` error, like previously. This is quite logical once
    you remember that order matters—FastAPI finds the first matching URL, checks the
    types, and throws an error. If the first match is the one with the fixed path,
    everything works as intended. Just change the order of the two routes and everything
    will work as expected.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用程序并测试 `/user/me` 端点时，你将得到一个与之前相同的 `422 Unprocessable Entity` 错误。一旦你记住顺序很重要——FastAPI
    会找到第一个匹配的 URL，检查类型，并抛出错误。如果第一个匹配的是具有固定路径的那个，那么一切都会按预期工作。只需更改两个路由的顺序，一切就会按预期工作。
- en: Another powerful feature of the path treatment of FastAPI is how it limits the
    path to a specific set of values and a path function, imported from FastAPI, which
    enables you to perform additional validation on the path.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 对路径处理的一个强大功能是它如何限制路径到一组特定的值和一个从 FastAPI 导入的路径函数，这使你能够在路径上执行额外的验证。
- en: 'Suppose you want to have a URL path that accepts two values and allows the
    following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要一个 URL 路径，它接受两个值并允许以下操作：
- en: '`account_type`: This can be `free` or `pro`.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`account_type`：可以是 `free` 或 `pro`。'
- en: '`months`: This must be an integer between 3 and 12.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`months`：这必须是一个介于 3 和 12 之间的整数。'
- en: 'FastAPI solves this by letting you create a class based on `Enum` for the account
    type. This class defines all the possible values for the account variable. In
    this case, there are just two—`free` and `pro`. Create a new file and name it
    `chapter4_04.py` and edit it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 通过让你创建一个基于 `Enum` 的类来解决这个问题，用于账户类型。这个类定义了账户变量所有可能的值。在这种情况下，只有两个——`free`
    和 `pro`。创建一个新的文件，并将其命名为 `chapter4_04.py`，然后编辑它：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, in the actual endpoint, you can combine this class with the utilities
    from the `Path` function (do not forget to import it along with FastAPI from `fastapi`).
    Paste the following code at the end of the file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在实际的端点中，你可以将这个类与 `Path` 函数的实用工具结合起来（不要忘记与 FastAPI 一起从 `fastapi` 导入它）。将以下代码粘贴到文件的末尾：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, FastAPI sets the type of the `acc_type` part of the path
    to your previously defined class and ensures that only the `free` or `pro` value
    can be passed. The `months` variable, however, is handled by the `Path` utility
    function. When you try to hit this endpoint, `account_type` will show that there
    are only two values available, while the actual value of the enumeration can be
    accessed through the `.``value` syntax.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，FastAPI 将路径的 `acc_type` 部分的类型设置为之前定义的类，并确保只能传递 `free` 或 `pro` 值。然而，`months`
    变量是由 `Path` 实用函数处理的。当你尝试访问这个端点时，`account_type` 将显示只有两个值可用，而实际的枚举值可以通过 `.value`
    语法访问。
- en: FastAPI allows you to declare path parameters using standard Python types. If
    no type is declared, FastAPI will assume that you’re working with strings.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 允许你使用标准的 Python 类型声明路径参数。如果没有声明类型，FastAPI 将假设你正在使用字符串。
- en: For more details on these topics, you can visit the excellent documentation
    site and see what other options are available (https://fastapi.tiangolo.com/tutorial/path-params/).
    In this case, the `Path` function received three parameters. The three dots mean
    that the value is required and that no default value has been provided, `ge=3`
    means that the value can be greater than or equal to `3`, while `le=12` means
    that it can be smaller than or equal to `12`. This syntax allows you to define
    validation right inside the path functions quickly.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些主题的更多详细信息，你可以访问优秀的文档网站，看看其他可用的选项（https://fastapi.tiangolo.com/tutorial/path-params/）。在这种情况下，`Path`
    函数接收了三个参数。三个点表示该值是必需的，并且没有提供默认值，`ge=3` 表示该值可以大于或等于 `3`，而 `le=12` 表示它可以小于或等于 `12`。这种语法允许你在路径函数中快速定义验证。
- en: Query parameters
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询参数
- en: Now that you’ve learned how to validate, restrict, and properly order your path
    parameters and endpoints, it’s time to look at **query parameters**. These parameters
    are a simple mechanism of passing data to a server through the URL and they are
    represented as key-value pairs, separated by an equals sign (=). You can have
    multiple pairs of keys and values separated by an ampersand (&).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何验证、限制和正确排序你的路径参数和端点，是时候看看**查询参数**了。这些参数是通过 URL 将数据传递给服务器的简单机制，它们以键值对的形式表示，由等号（=）分隔。你可以有多个键值对，由与号（&）分隔。
- en: 'Query parameters are added at the end of the URL by using the question mark/equals
    notation: `?``min_ price=2000&max_price=4000`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数通过在 URL 的末尾使用问号/等号记法添加：`?min_price=2000&max_price=4000`。
- en: The question mark, `?`, is a separator that tells you where the query string
    begins, while the ampersand, `&`, allows you to add more than one (the equals
    sign, `=`) assignment.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 问号（`?`）是一个分隔符，它告诉您查询字符串从哪里开始，而与号（`&`）允许您添加多个（等号`=`）赋值。
- en: Query parameters are usually used to apply filters, sort, order, or limit query
    sets, paginate a long list of results, and similar tasks. FastAPI treats them
    very similarly to path parameters as it automatically picks them up and makes
    them available for processing in your endpoint functions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数通常用于应用过滤器、排序、排序或限制查询集、分页长列表的结果以及类似任务。FastAPI将它们处理得与路径参数非常相似，因为它会自动提取它们并在您的端点函数中使它们可用于处理。
- en: 'Create a simple endpoint that accepts two query parameters for the minimum
    and maximum prices of the car, and name it `chapter4_05.py`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的端点，接受两个查询参数，用于汽车的最低价和最高价，并将其命名为`chapter4_05.py`：
- en: '[PRE19]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Test this endpoint with HTTPie:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用HTTPie测试此端点：
- en: '[PRE20]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this solution, you can’t ensure the basic condition that the minimum price
    should be lower than the maximum price. This is handled by the object-level validation
    of Pydantic.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解决方案中，您无法确保基本条件，即最低价格应低于最高价格。这是由Pydantic的对象级验证处理的。
- en: FastAPI picks your query parameters and performs the same parsing and validation
    checks it did previously. It provides the `Query` function, like the `Path` function.
    You can use the *greater than*, *less than*, or *equal* conditions, as well as
    set default values. They can also be set to default to `None`. Query parameters
    will be converted into Boolean values as needed. You can write rather complex
    combinations of path and query parameters, as FastAPI can distinguish between
    them and handle them inside the function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI选择您的查询参数，并执行与之前相同的解析和验证检查。它提供了`Query`函数，就像`Path`函数一样。您可以使用**大于**、**小于**或**等于**条件，以及设置默认值。它们也可以设置为默认为`None`。根据需要，查询参数将被转换为布尔值。您可以编写相当复杂的路径和查询参数的组合，因为FastAPI可以区分它们并在函数内部处理它们。
- en: 'With that, you’ve seen how FastAPI enables working with data that is passed
    through the path and query parameters, as well as the tools it uses under the
    hood to perform parsing and validation as soon as possible. Now, you will examine
    the main data vehicle of REST APIs: the **request body**.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，您已经看到了FastAPI如何使您能够处理通过路径和查询参数传递的数据，以及它使用的工具在幕后尽快进行解析和验证。现在，您将检查REST API的主要数据载体：**请求体**。
- en: The request body—the bulk of the data
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求体——数据的大部分
- en: REST APIs enable two-way communication between a client—a web browser or a mobile
    application and an API server. The bulk of this data is carried over in the request
    and response body. A request body has data sent from the client to your API, while
    the response body is data sent from the API server to the client(s).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: REST API允许客户端（一个网页浏览器或移动应用程序）与API服务器之间进行双向通信。大部分数据都通过请求和响应体传输。请求体包含从客户端发送到您的API的数据，而响应体是从API服务器发送到客户端（们）的数据。
- en: This data can be encoded in various ways, but many users prefer to encode data
    with JSON since it is exceptionally nice with our database solution of choice,
    MongoDB—which operates with BSON, a close relative to JSON.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据可以用各种方式编码，但许多用户更喜欢使用JSON编码数据，因为它与我们的数据库解决方案MongoDB非常出色——MongoDB使用BSON，与JSON非常相似。
- en: 'When modifying data on the server, you should always use:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当在服务器上修改数据时，您应该始终使用：
- en: '`POST` requests: To create new resources'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`请求：用于创建新资源'
- en: '`PUT` and `PATCH`: To update resources'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`和`PATCH`：用于更新资源'
- en: '`DELETE`: To delete resources'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：用于删除资源'
- en: Since the body of a request will contain raw data—in this case, MongoDB documents
    or arrays of documents—you can use Pydantic models. But first, see how the mechanism
    works, without any validation or modeling. In HTTP terminology, the `GET` method
    should be *idempotent*, meaning it should always return the same value for the
    same set of parameters.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于请求体将包含原始数据——在这种情况下，MongoDB文档或文档数组——您可以使用Pydantic模型。但首先，看看这个机制是如何工作的，没有任何验证或建模。在HTTP术语中，`GET`方法应该是**幂等的**，这意味着它应该总是为同一组参数返回相同的值。
- en: 'In the following code for a hypothetical endpoint used to insert new cars in
    your future database, you can pass the generic request body as the data. It can
    be a dictionary without entering into the specifics of how that dictionary should
    be shaped. Create a new file called `chapter4_06.py` and paste the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下用于将新车插入未来数据库的假设端点的代码中，你可以将通用的请求体作为数据传递。它可以是字典，无需进入该字典应该如何构建的细节。创建一个名为 `chapter4_06.py`
    的新文件，并将以下代码粘贴进去：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Intuitively, the `Body` function is similar to the previously introduced `Path`
    and `Query` functions. Yet the difference is, when working with the request body,
    this function is mandatory.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 直观来看，`Body` 函数与之前介绍的 `Path` 和 `Query` 函数类似。然而，区别在于，当处理请求体时，此函数是强制性的。
- en: 'The three dots indicate that the body is required (you must send something),
    but this is the only requirement. Try to insert a car (a Fiat 500, made in 2015):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 三个点表示请求体是必需的（你必须发送一些内容），但这仅是唯一的要求。尝试插入一辆车（2015年制造的菲亚特500）：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: FastAPI does the heavy lifting. You can retrieve all the data passed to the
    request body and make it available to your function for further processing – database
    insertion, optional preprocessing, and so on.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 会做繁重的工作。你可以检索传递给请求体的所有数据，并将其提供给函数以进行进一步处理——数据库插入、可选预处理等。
- en: On the other hand, you could have passed any key-value pairs to the body. Of
    course, this is just an illustration of the general mechanism—in reality, Pydantic
    will be your data guardian, ensuring you only let the right data in.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你可以向请求体传递任何键值对。当然，这只是一个说明一般机制的例子——在现实中，Pydantic 将成为你的数据守护者，确保你只让正确的数据进入。
- en: While all went well, FastAPI sends you a `200 response` status again, even though
    a `201 Resource Created` error is more appropriate and exact. You could, for instance,
    have some document inserted into MongoDB at the end of the function and a `201
    CREATED` status message would be appropriate. You will see how easy it is to modify
    the response body as well, but for now, you will be able to see why Pydantic shines
    when it comes to request bodies.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一切顺利，但 FastAPI 仍然会发送一个 `200` 响应状态，尽管 `201 Resource Created` 错误更为合适和准确。例如，你可以在函数末尾将一些文档插入
    MongoDB，并使用 `201 CREATED` 状态消息。你将看到修改响应体是多么容易，但就目前而言，你将能够看到 Pydantic 在处理请求体时的优势。
- en: To create new car entries, you would only need the `brand`, `model`, and production
    `year` fields.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的汽车条目，你只需要 `brand`、`model` 和生产 `year` 字段。
- en: 'So, create a simple Pydantic model with the desired types in the `chapter4_07.py`
    file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `chapter4_07.py` 文件中创建一个简单的 Pydantic 模型，其中包含所需的数据类型：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By now, you know that the first two parameters are expected to be strings, while
    the year must be an integer; all of them are required.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你知道前两个参数应该是字符串，而年份必须是整数；它们都是必需的。
- en: Now, if you try to post the same data that you did previously but with additional
    fields, you will only get these three fields back. Also, these fields will go
    through Pydantic parsing and validation and throw meaningful error messages if
    something does not conform to the data specification.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试发送之前相同的数据，但带有额外的字段，你将只会收到这三个字段。此外，这些字段将经过 Pydantic 解析和验证，如果某些内容不符合数据规范，将抛出有意义的错误信息。
- en: This combination of Pydantic model validation and the `Body` function provides
    all the necessary flexibility when working with request data. This is because
    you can combine them and pass different bits of information using the same request
    bus ride.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 模型验证和 `Body` 函数的组合，在处理请求数据时提供了所有必要的灵活性。这是因为你可以将它们结合起来，并通过相同的请求总线传递不同的信息片段。
- en: 'If you want to pass a promo code attached to a user, along with the new car
    data, you could try defining a Pydantic model for the user and extracting the
    promo code with the `Body` function. First, define a minimal user model in a new
    file and name it `chapter4_08.py`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要传递与用户关联的促销代码以及新车数据，你可以尝试定义一个用于用户的 Pydantic 模型，并使用 `Body` 函数提取促销代码。首先，在新的文件中定义一个最小的用户模型，并将其命名为
    `chapter4_08.py`：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, create a more complex function that will process two Pydantic models and
    an optional user promo code – set the default value to `None`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个更复杂的函数，该函数将处理两个 Pydantic 模型和可选的用户促销代码——将默认值设置为 `None`：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For this request, which contains a full-fledged JSON object with two nested
    objects and some code, you might opt to use Insomnia or a similar GUI client since
    it’s easier than typing JSON in the command prompt or resorting to piping. While
    it is largely a matter of preference, when developing and testing REST APIs, it
    is useful to have a GUI tool such as Insomnia or Postman and a command-line client
    (such as cURL or HTTPie).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个请求，它包含一个完整的JSON对象，其中有两个嵌套对象和一些代码，你可能选择使用Insomnia或类似的图形用户界面客户端，因为这样做比在命令提示符中输入JSON或使用管道要容易。虽然这主要是一个个人偏好的问题，但在开发和测试REST
    API时，拥有一个如Insomnia或Postman之类的图形用户界面工具以及一个命令行客户端（如cURL或HTTPie）是非常有用的。
- en: The `Body` class constructor’s parameters are very similar to the `Path` and
    `Query` constructors, and since they will often be much more complex, it is useful
    to try and tame them with Pydantic. Parsing, validation, and meaningful error
    messages – Pydantic provides us with the whole package before allowing the request
    body data to make it to the real data processing functionality. The `POST` requests
    are almost exclusively fed an appropriate Pydantic model as a parameter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Body`类构造函数的参数与`Path`和`Query`构造函数非常相似，并且由于它们通常会更加复杂，因此尝试使用Pydantic来驯服它们是有用的。解析、验证和有意义的错误消息——Pydantic在允许请求数据到达真实数据处理功能之前为我们提供了整个包。`POST`请求几乎总是以适当的Pydantic模型作为参数传入。'
- en: After playing around with the combination of request bodies and Pydantic models,
    you have seen that you can control the inflow of the data and be confident that
    the data that’s available to your API endpoint will be what you want and expect
    it to be. Sometimes, however, you may want to go to the bare metal, and work with
    the raw request object. FastAPI covers that case too, as is discussed in the next
    section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试了请求体和Pydantic模型的组合之后，你已经看到你可以控制数据的流入，并且可以确信提供给你的API端点的数据将是你想要和期望的数据。然而，有时你可能想要直接与裸金属打交道，并处理原始请求对象。FastAPI也覆盖了这种情况，如下一节所述。
- en: The request object
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求对象
- en: 'FastAPI is built on the Starlette web framework. The raw request object in
    FastAPI is Starlette’s request object and it can be accessed in your functions
    once it’s been imported from FastAPI directly. By using the request object directly,
    you are missing out on FastAPI’s most important features: Pydantic’s parsing and
    validation and self-documentation! However, there might be situations in which
    you need to have the raw request.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI建立在Starlette网络框架之上。FastAPI中的原始请求对象是Starlette的请求对象，一旦从FastAPI直接导入，你就可以在你的函数中访问它。通过直接使用请求对象，你错过了FastAPI最重要的功能：Pydantic的解析和验证以及自文档化！然而，可能存在你需要拥有原始请求的情况。
- en: 'Look at the following example in the `chapter4_09.py` file:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`chapter4_09.py`文件中的以下示例：
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, you created a minimal FastAPI app, imported the `Request`
    class, and used it in the endpoint. If you test this endpoint with your `REST`
    client, you will only get the base URL as the message, while the `all` part lists
    all the methods and properties of the `Request` object so that you have an idea
    of what is available.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你创建了一个最小的FastAPI应用程序，导入了`Request`类，并在端点中使用它。如果你使用`REST`客户端测试此端点，你将只得到基础URL作为消息，而`all`部分列出了`Request`对象的全部方法和属性，以便你了解可用的内容。
- en: All of these methods and properties are available for you to use in your application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法和属性都可供你在你的应用程序中使用。
- en: With that, you’ve seen how FastAPI facilitates your work with the main HTTP
    transport mechanisms—request bodies, query strings, and paths. Next, you’ll explore
    equally important aspects of any web framework solution—cookies, headers, form
    data, and files.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，你已经看到了FastAPI如何帮助你与主要的HTTP传输机制——请求体、查询字符串和路径——一起工作。接下来，你将探索任何网络框架解决方案同样重要的方面——cookies、headers、表单数据和文件。
- en: Cookies and headers, form data, and files
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cookies和headers，表单数据，和文件
- en: Speaking of the ways the web framework ingests data, topics such as handling
    form data, handling files, and manipulating cookies and headers must be included.
    This section will provide simple examples of how FastAPI handles these tasks.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 说到网络框架如何摄取数据，处理表单数据、处理文件以及操作Cookies和headers等主题必须包括在内。本节将提供FastAPI如何处理这些任务的简单示例。
- en: Headers
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Headers
- en: Header parameters are handled in a similar way to query and path parameters
    and, as you’ll see later, cookies. You can collect them, so to speak, using the
    `Header` function. Headers are essential in topics such as authentication and
    authorization as they often carry **JSON Web Tokens** (**JWTs**), which are used
    for identifying users and their permissions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 标头参数的处理方式与查询和路径参数类似，正如你稍后将会看到的，还有cookie。你可以通过使用`Header`函数来收集它们，可以说。在诸如身份验证和授权等主题中，标头是必不可少的，因为它们经常携带**JSON
    Web Tokens**（JWTs），这些用于识别用户及其权限。
- en: 'Try to read the user agent by using the `Header` function in a new file called
    `chapter4_10.py`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用新文件`chapter4_10.py`中的`Header`函数读取用户代理：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Depending on the software you use to execute the test for the endpoint, you’ll
    get different results. Here’s an example of using HTTPie:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的软件来执行端点的测试，你将得到不同的结果。以下是一个使用HTTPie的示例：
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can extract all the headers in this way and FastAPI will provide further
    assistance—it will convert names into lowercase, convert the keys into snake case,
    and so on.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用这种方式提取所有标头，FastAPI将提供进一步的帮助——它将名称转换为小写，将键转换为蛇形命名法，等等。
- en: Cookies
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Cookie
- en: Cookies work similarly, although they can be extracted manually from the `Cookies`
    header. The framework offers a utility function, conveniently named `Cookie`,
    that does all the work in a way similar to `Query`, `Path`, and `Header`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie的工作方式类似，尽管它们可以从`Cookies`标头中手动提取。该框架提供了一个名为`Cookie`的实用函数，它以类似于`Query`、`Path`和`Header`的方式完成所有工作。
- en: Forms (and files)
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表单（和文件）
- en: So far, you’ve only dealt with JSON data. It is the ubiquitous language of the
    web and your main vehicle for moving data back and forth. There are cases, however,
    that require a different data encoding – forms might be processed directly by
    your API, with data encoded as `multipart`/`form-data` or `form-urlencoded`. Since
    the arrival of modern React Server Actions, form data has become more popular
    in frontend development too.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只处理了JSON数据。它是网络上的通用语言，也是你在数据往返中的主要载体。然而，有些情况需要不同的数据编码——表单可能直接由你的API处理，数据编码为`multipart/form-data`或`form-urlencoded`。随着现代React
    Server Actions的出现，表单数据在前端开发中也变得更加流行。
- en: Note
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although you can have multiple Form parameters in a path operation, you cannot
    declare the `Body` fields expected in JSON. The HTTP request will have the body
    encoded using only `application/x-www-form-urlencoded instead of application/json`.
    This limitation is part of the HTTP protocol and is not specific to FastAPI.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以在路径操作中声明多个表单参数，但你不能声明JSON中预期的`Body`字段。HTTP请求将使用仅`application/x-www-form-urlencoded`而不是`application/json`进行编码。这种限制是HTTP协议的一部分，并不特定于FastAPI。
- en: 'The simplest way to cover both form cases—with and without including files
    for upload—is to start by installing `python-multipart`, a streaming multipart
    parser for Python. For this, you must stop your server and use `pip` to install
    it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖这两种表单情况——包括和不包括上传文件的最简单方法是首先安装`python-multipart`，这是一个Python的流式多部分解析器。为此，你必须停止你的服务器并使用`pip`来安装它：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `Form` function works similarly to the previously examined utility functions,
    but with the difference that it looks for form-encoded parameters. For simple
    fields, data is usually encoded using the media type (`application/x-www-form-urlencoded`),
    while if files are included, the encoding corresponds to `mutlipart/form-data`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Form`函数与之前检查的实用函数类似，但不同之处在于它寻找表单编码的参数。对于简单字段，数据通常使用媒体类型（`application/x-www-form-urlencoded`）进行编码，而如果包含文件，编码对应于`multipart/form-data`。'
- en: Look at a simple example in which you wish to upload an image and a couple of
    form fields, such as the brand and the model.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 看一个简单的例子，你希望上传一张图片和一些表单字段，比如品牌和型号。
- en: You will use a photo that can be found on Pexels ([https://www.pexels.com/photo/white-](https://www.pexels.com/photo/white-vintage-car-parked-on-green-grass-8746027/)),
    renamed to `car.jpeg` and saved in the current directory.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用一张可以在Pexels上找到的照片（[https://www.pexels.com/photo/white-](https://www.pexels.com/photo/white-vintage-car-parked-on-green-grass-8746027/)），重命名为`car.jpeg`并保存在当前目录中。
- en: 'Create a file named `chapter4_11.py` and paste the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`chapter4_11.py`的文件，并将以下代码粘贴进去：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code handles the form parameters via the `Form` function and the
    uploaded file by using the `UploadFile` utility class.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码通过`Form`函数处理表单参数，并通过使用`UploadFile`实用类上传文件。
- en: 'The photo, however, isn’t saved on the disk—its presence is merely acknowledged,
    and the filename is returned. Testing this endpoint, that has a file upload, in
    HTTPie looks like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，照片并没有保存在磁盘上——它的存在只是被确认，并返回文件名。在HTTPie中测试具有文件上传的端点如下所示：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding HTTPie call returns the following output:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的HTTPie调用返回以下输出：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To save the image to a disk, you must copy the buffer to an actual file on
    the disk. The following code achieves this (`chapter4_12.py`):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像保存到磁盘，你必须将缓冲区复制到磁盘上的实际文件中。以下代码实现了这一点（`chapter4_12.py`）：
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `open` block opens a file on the disk using a specified filename and copies
    the FastAPI file that’s sent through the form. You will have hardcoded the filename,
    so any new upload will simply overwrite the existing file, but you could use some
    randomly generated filename while using the **universally unique identifier**
    (**UUID**) library, for example.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`open`块使用指定的文件名在磁盘上打开一个文件，并复制通过表单发送的FastAPI文件。你将硬编码文件名，因此任何新的上传将简单地覆盖现有文件，但你可以使用**通用唯一识别码**（**UUID**）库等随机生成文件名。'
- en: File uploading is an operation that can be achieved in different ways—file uploads
    can be also handled by the Python `async` file library known as `aiofiles` or
    as a background task, which is another feature of FastAPI, as will be shown later
    in [*Chapter 5*](B22406_05.xhtml#_idTextAnchor090), *Setting Up a* *React Workflow*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 文件上传可以通过不同的方式实现——文件上传也可以由Python的`async`文件库`aiofiles`或作为后台任务处理，这是FastAPI的另一个特性，将在[第5章](B22406_05.xhtml#_idTextAnchor090)中展示，*设置React工作流程*。
- en: FastAPI response customization
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FastAPI响应自定义
- en: The previous sections discussed numerous examples of FastAPI requests how you
    can reach every corner of the request—the path, the query string, the request
    body, headers, and cookies—and how to work with form-encoded requests.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 前几节讨论了FastAPI请求的许多示例，说明了你可以如何触及请求的每一个角落——路径、查询字符串、请求体、头部和Cookies，以及如何处理表单编码的请求。
- en: Now, let’s take a closer look at FastAPI’s response objects. In all previous
    cases, you returned a Python dictionary that was serialized into JSON by FastAPI.
    The framework enables customizations to the response.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看看FastAPI的响应对象。在所有之前的案例中，你返回了一个由FastAPI序列化为JSON的Python字典。该框架允许对响应进行自定义。
- en: The first thing you might want to change in an HTTP response is the status code,
    for instance to provide some meaningful errors when things do not go as planned.
    FastAPI conveniently raises classic Python exceptions when HTTP errors are present.
    It also uses standard-compliant meaningful response codes that minimize the need
    to create custom payload messages. For instance, you don’t want to send a `200
    OK` status code for everything and then notify users of errors by using the payload—FastAPI
    encourages good practices.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP响应中，你可能首先想要更改的是状态码，例如，在事情没有按计划进行时提供一些有意义的错误。当存在HTTP错误时，FastAPI方便地引发经典的Python异常。它还使用符合标准的、有意义的响应代码，以最大限度地减少创建自定义有效负载消息的需求。例如，你不希望为所有内容发送`200
    OK`状态码，然后通过有效负载通知用户错误——FastAPI鼓励良好的实践。
- en: Setting status codes
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置状态码
- en: 'HTTP status codes indicate whether an operation was successful or there was
    an error. These codes also provide information about the type of operation, and
    they can be divided into several groups: informational, successful, client errors,
    server errors, and so on. It isn’t necessary to memorize the status codes, although
    you probably know what a `404` or `500` code is.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态码表示操作是否成功或存在错误。这些代码还提供了关于操作类型的信息，并且可以根据几个组来划分：信息性、成功、客户端错误、服务器错误等。虽然不需要记住状态码，但你可能知道`404`或`500`代码的含义。
- en: 'FastAPI makes it incredibly easy to set a status code—it is enough to just
    pass the desired `status_code` variable to the decorator. Here, you are using
    the `208 status` code for a simple endpoint (`chapter4_13.py`):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI使设置状态码变得非常简单——只需将所需的`status_code`变量传递给装饰器即可。在这里，你正在使用`208 status`代码为一个简单的端点（`chapter4_13.py`）：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Testing the root route in HTTPie yields the following output:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTPie中测试根路由产生以下输出：
- en: '[PRE35]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Similarly, you can set status codes for the `delete`, `update`, and `create`
    operations.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以为`delete`、`update`和`create`操作设置状态码。
- en: FastAPI sets the `200 status` code by default if it doesn’t encounter exceptions,
    so it is up to you to set the correct codes for the various API operations, such
    as `204 No Content` for deleting and `201` for creating. This is a good practice
    that is particularly encouraged.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI默认设置`200状态码`，如果没有遇到异常，因此设置各种API操作的正确代码取决于你，例如删除时使用`204 No Content`，创建时使用`201`。这是一个特别值得鼓励的良好实践。
- en: Pydantic can be used for response modeling. You can limit or modify the fields
    that should appear in the response and perform similar checks that it does for
    the request body by using the `response_model` argument.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic可用于响应建模。您可以使用`response_model`参数限制或修改应在响应中出现的字段，并执行与请求体类似的检查。
- en: FastAPI does not enable customizing the response, but modifying and setting
    headers and cookies is as simple as reading them from the HTTP request and the
    framework has you covered.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI不启用自定义响应，但修改和设置头和cookie与从HTTP请求和框架中读取它们一样简单。
- en: 'Although beyond the scope of this book, it is worth noting that JSON is by
    no means the only response that FastAPI can provide: you can output an `HTMLResponse`
    and use classic Flask-like Jinja templates, `StreamingResponse`, `FileResponse`,
    `RedirectResponse`, and so on.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这超出了本书的范围，但值得注意的是，JSON绝不是FastAPI可以提供的唯一响应：您可以输出`HTMLResponse`并使用经典的Flask-like
    Jinja模板，`StreamingResponse`，`FileResponse`，`RedirectResponse`等等。
- en: HTTP errors
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: HTTP错误
- en: Errors are bound to happen. For example, users somehow find a way to send the
    wrong parameters to a query, the frontend sends the wrong request body, or the
    database goes offline (although this is unlikely with MongoDB)—anything can happen.
    It is crucial to detect these errors as soon as possible (this is a leitmotiv
    in FastAPI) and send clear and complete messages to the frontend, as well as the
    user by raising exceptions.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是不可避免的。例如，用户可能以某种方式向查询发送了错误的参数，前端发送了错误的请求体，或者数据库离线（尽管在MongoDB中这种情况不太可能）——任何情况都可能发生。尽快检测这些错误（这是FastAPI的一个主题）并向前端以及用户发送清晰完整的消息，通过抛出异常至关重要。
- en: FastAPI relies on web standards and enforces good practices in every facet of
    the development process, so it puts a lot of emphasis on using HTTP status codes.
    These codes provide a clear indication of the type of problem that has arisen,
    while the payload can be used to further clarify the cause of the problem.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI依赖于网络标准，并在开发过程的各个方面强制执行良好实践，因此它非常重视使用HTTP状态码。这些代码提供了对出现问题的清晰指示，而有效载荷可以用来进一步阐明问题的原因。
- en: FastAPI uses a Python exception, aptly called `HTTPException`, to raise HTTP
    errors. This class allows you to set a status code and set an error message.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI使用一个称为`HTTPException`的Python异常来引发HTTP错误。这个类允许您设置状态码并设置错误消息。
- en: 'Returning to the example of inserting new cars into the database, you could
    set a custom exception like the following (`chapter4_14.py`):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 回到将新汽车插入数据库的例子，您可以设置一个自定义异常，如下所示（`chapter4_14.py`）：
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When trying to insert a car that hasn’t been built yet, the response is as
    follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试插入尚未建造的汽车时，响应如下：
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is a pretty contrived example of making custom exceptions for a possible
    problem that might arise. However, this gives a good idea of what is possible
    and the flexibility that FastAPI gives you.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当牵强的例子，用于为可能出现的潜在问题创建自定义异常。然而，这很好地说明了可能实现的内容以及FastAPI提供的灵活性。
- en: Dependency injection
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 依赖注入
- en: To make a brief but self-contained introduction to FastAPI, the system of dependency
    injection must be mentioned. In broad terms, **dependency injection** (**DI**)
    is a way of providing necessary functionalities (classes, functions, database
    connections, authorization statuses and so on) to a path operation function at
    the right time. FastAPI’s DI system is very useful for sharing logic across endpoints,
    sharing database connections, for instance, as you will see when you connect to
    your MongoDB Atlas instance—performing security and authentication checks, and
    so on.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简要但自包含地介绍FastAPI，必须提到依赖注入系统。从广义上讲，**依赖注入**（**DI**）是在适当的时间向路径操作函数提供必要功能（类、函数、数据库连接、授权状态等）的一种方式。FastAPI的DI系统对于在端点之间共享逻辑、共享数据库连接等非常有用，正如您在连接到您的MongoDB
    Atlas实例时将看到的——执行安全性和身份验证检查等。
- en: Dependencies aren’t special; they are just normal functions that can take the
    same arguments as path operations. In fact, the official documentation compares
    them to path operations without the decorator. Dependencies are used a bit differently,
    though. They are given a single parameter (typically a callable) and they are
    not called directly; they are just passed as a parameter to `Depends()`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'An example inspired by the official FastAPI documentation is the following;
    you can use a pagination dependency and use it in different resources (`chapter4_15.py`):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: One of the most common cases of DI used in a full stack FastAPI project is authentication;
    you can use the same authentication logic, that is, some class or function that
    checks the header for an authorization token and applies it to all the routes
    or routers that need to require authentication, as you will see in [*Chapter 6*](B22406_06.xhtml#_idTextAnchor105)*,
    Authentication* *and Authorization*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Structuring FastAPI applications with routers
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although putting all of our `request`/`response` logic in one big file is possible,
    as you start building even a moderately sized project, you will quickly see that
    this is not feasible, maintainable, or pleasant to work with. FastAPI, like Express.js
    in the Node.js world, or Flask with its blueprints, provides `cars`, at the `/cars`
    path, another to handle the creation and management of users at `/users`, and
    so on. FastAPI proposes a type of project structure that is simple and intuitive
    enough, yet able to accommodate the most common cases.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: API Routers
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FastAPI provides a class named APIRouter that is used for grouping routes, usually
    related to the same type of resource (users, shopping items, and so on). This
    concept, known in Flask as **Blueprints** and present in every modern web framework,
    allows the code to be more modular and distributed in smaller units, with each
    router managing only a certain type of resource. These APIRouters are finally
    included in the main FastAPI instance and provide very similar functionality.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of applying the path decorators (`@get`, `@post` and so on) directly
    on the main application instance (usually called app), they are applied to the
    APIRouter instance. Below is a simple example of an application broken into two
    APIRouters:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a `chapter4_16.py` file that will host the main FastAPI instance:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, create a new folder named `/routers`, and in this folder, create an APIRouter
    in a file named `users.py`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create another file, in the same `/routers` directory, named `cars.py`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When connecting the routers to the main application, in the `chapter4_17.py`
    file, you are able to provide different optional arguments to the APIRouter—tags
    and a set of dependencies, such as an authentication requirement. The prefix,
    however, is mandatory, as the application needs to know at which URL to mount
    the APIRouter.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'If you test this application with Uvicorn with the following command:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And then, head over to the automatically generated documentation, you will see
    that the two APIRouters are mounted just as if you defined two separate endpoints.
    They are, however, grouped under the respective tags, for easier navigation and
    testing.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: If you now navigate to the documentation, you should indeed find just one route
    defined at `/cars` and responding only to `GET` requests. It is intuitive that
    this procedure can have you build parallel or same-level routers in no time, but
    one of the biggest benefits of using APIRouters is that they support nesting,
    which enables managing quite complex hierarchies of endpoints effortlessly!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Routers are subsystems of an application and are not meant to be used autonomously,
    although you are free to mount entire separate FastAPI applications under specific
    paths, but that is beyond the scope of this book.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Middleware
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: FastAPI implements the concept of `request`/`response` cycle, intercepting the
    request, manipulating it in some desired way, then taking the response before
    it is sent to the browser or client, performing additional manipulation if needed,
    and finally, returning the final response.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Middleware is based on the ASGI specification, and it is implemented in Starlette,
    so FastAPI enables using it in all your routes and optionally tying it to a part
    of an application (via APIRouter) or the entire app.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly to the mentioned frameworks, the FastAPI middleware is just a function
    that receives the request and a `call_next` function. Create a new file named
    `chapter4_17.py`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you now start this small application, and test the only route, the route
    at [`http://127.0.0.1:8000/`](http://127.0.0.1:8000/), you will notice that the
    returned headers contain an integer between 1 and 10, and on every request this
    integer will be different.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Middleware plays a large role in authentication with **cross-origin resource
    sharing** (**CORS**), something you’re bound to face when developing full stack
    applications, but also for redirecting, managing proxies, and so on. It is a very
    powerful concept that can greatly simplify and enhance your application efficiency.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered very simple examples of how FastAPI achieves the most common
    REST API tasks and the way it can help you by leveraging modern Python features
    and libraries such as Pydantic.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also detailed how FastAPI enables you to perform requests and responses
    through HTTP and how you can tap into it, at any point, and customize and access
    the elements of the request, as well as the response. Finally, it also detailed
    how to split your API into routers and how to organize your app into logical resource-based
    units.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will give you a quick introduction to React—the user interface
    library of choice in the FARM stack.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
