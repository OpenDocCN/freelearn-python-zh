- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with FastAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **application programming interface** (**API**) is the cornerstone of your
    FARM stack, functioning as the brain of the system. It implements business logic
    that dictates how the data flows in and out of the system, but more importantly,
    how it relates to the business requirements inside your system.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks such as FastAPI are much easier to showcase through examples. In
    this chapter, you’ll explore some simple endpoints that make up for a minimal,
    self-contained REST API. These examples will help you understand how FastAPI handles
    requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on introducing the framework, along with the standard REST
    API practices and how they are implemented in FastAPI. You’ll learn how to send
    requests and modify them according to your needs, and how to retrieve all the
    data from HTTP requests, including parameters and request bodies. You’ll also
    understand how to handle responses and how you can use FastAPI to easily set cookies,
    headers, and other standard web-related topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the FastAPI framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setup and requirements for a simple FastAPI app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python features in FastAPI, such as type hinting, annotations, and `async/await`
    syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How FastAPI handles typical REST API tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with form data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anatomy of a FastAPI project and routers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Python setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code editor and plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following sections cover these requirements in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Python setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you do not have Python installed, visit the Python download site ([https://www.python.org/downloads/](https://www.python.org/downloads/))
    to get the installer for your OS. In this book, you will be using **version**
    **3.11.7** or later.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI relies heavily on Python hints and annotations, and Python versions
    after 3.6 treat type hints in a similar, modern way; so, while theoretically any
    version later than 3.6 should work, the code in this book uses Python version
    3.11.7, for compatibility reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that your Python installation is upgraded to one of the latest Python
    versions—as stated, at least version 3.11.7—and is reachable and the default version.
    You can check this by:'
  prefs: []
  type: TYPE_NORMAL
- en: Typing `python` in your terminal of choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **pyenv**, a handy tool that manages multiple Python versions on the same
    machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have ever worked with a Python project before, chances are you needed
    to include some, if not dozens, Python third-party packages. After all, one of
    Python’s main strengths lies in its vast ecosystem, which is one of the primary
    reasons it's chosen for the FARM stack.
  prefs: []
  type: TYPE_NORMAL
- en: Without getting into the detailed specifics of how Python manages third-party
    package installations, let’s just go over the main problems that can arise should
    you decide to use only one Python installation for all of your projects, or even
    worse, should that installation be the default operating system Python installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are a few challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: Operating systems often lag in terms of Python versions, so the latest couple
    of versions likely won’t be available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages will get installed into the same namespace or in the same packages
    folder, creating havoc in any application or package that depends on that package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python packages depend on other packages and those packages also have versions.
    Let’s suppose that you are using package A, which depends on packages B and C,
    and for some reason, you need to keep package B to a specific version (i.e., 1.2.3).
    You might need package B for a totally different project and that project might
    require a different version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reduced or impossible reproducibility: without a separate Python virtual environment,
    it would prove very difficult to quickly replicate the desired functionality with
    all the required packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python virtual environments are the solution to the aforementioned problems
    as they allow you to work in a pristine Python development with only the packages
    and package versions that you need. In our case, the virtual environment will
    certainly include the core packages: FastAPI and Uvicorn. FastAPI, on the other
    hand, depends on Starlette, Pydantic, and so on, so it is really important to
    have the package versions under control.'
  prefs: []
  type: TYPE_NORMAL
- en: The best practice for Python development states that each project, no matter
    how big or small, should have its own virtual environment. While there are several
    ways of creating a virtual environment, which is a separated and isolated Python
    environment, you will use `virtualenv`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic syntax for creating new virtual environments with `virtualenv` is
    given in the following command. Once you are in the project folder, name your
    folder `FARM` or `chapter4`, open a terminal, and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command will create a new virtual environment for your project, a copy
    of the Python interpreter (or if you are using macOS, a brand new Python interpreter)
    and the necessary folder structure, a couple of commands necessary for activating
    and deactivating the environment, as well as a copy of the `pip` installer (pip
    installs packages).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to activate your new virtual environment, you will choose one of the
    following commands, depending on your operating system. For Windows systems, type
    the following in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'On Linux or macOS systems, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, your shell should now be prepended with the name that you have
    given to your environment. In the command to create a new virtual environment,
    the final parameter is the name of the environment, so it was `venv` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some considerations when working with virtual environments are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: There are different schools of thought when it comes to virtual environment
    placement. For now, it will suffice if you keep them inside your project folder
    like you did.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to the `activate` command, there is also a `deactivate` command to exit
    your virtual environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving the exact package versions in a `requirements.txt` file and pinning the
    dependencies is not only useful but also often mandatory when deploying.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many alternatives to `virtualenv` in the Python community, as well
    as many complementary packages. Poetry is a tool that manages virtual environments
    and dependencies simultaneously, `virtualenvwrapper` is a set of utilities that
    further simplify the process of environment management. `pyenv` is a bit more
    complex—it manages Python versions and allows you to have different virtual environments
    based on different Python versions.
  prefs: []
  type: TYPE_NORMAL
- en: Code editors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While there are many great code editors and **integrated development environments**
    (**IDEs**) for Python, a common choice is **Visual Studio Code** (**VS Code**)
    from Microsoft. Released in 2015, it’s cross-platform, providing a lot of integrated
    tools, such as an integrated terminal for running your development server. It’s
    lightweight and offers hundreds of plugins for virtually any programming task
    you may have. Since you’ll be working with JavaScript, Python, React, and CSS
    for styling, along with running command-line processes, using VS Code is the easiest
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s also an excellent MongoDB plugin named **MongoDB for VS Code**, that
    allows you to connect to a MongoDB or Atlas cluster, navigate through databases
    and collections, get a quick overview of the schema and indexes, and view documents
    in collections. This proves very handy in a full stack scenario when you find
    yourself dealing with backend code in Python, frontend code in JavaScript and
    React or Next.js, running shells, and needing to quickly view the state of the
    MongoDB database. The extension is available here: [https://marketplace.visualstudio.com/items?itemName=mongodb.mongodb-vscode](https://marketplace.visualstudio.com/items?itemName=mongodb.mongodb-vscode).
    You can install it from the **Extensions** tab in Visual Studio Code as well,
    just by searching for MongoDB.'
  prefs: []
  type: TYPE_NORMAL
- en: Terminal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides Python and Git, you’ll need a shell program. Linux and Mac users usually
    have one pre-installed. For Windows, you can use Windows PowerShell or a console
    emulator such as **Cmder** ([https://cmder.app](https://cmder.app/)), which offers
    additional features.
  prefs: []
  type: TYPE_NORMAL
- en: REST clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To effectively test your REST API, you’ll need a REST client. While **Postman**
    ([https://www.postman.](https://www.postman.com/)) is robust and customizable,
    there are other viable alternatives. **Insomnia** () and the REST GUI offer a
    simpler interface, while **HTTPie** (), a command-line REST API client, allows
    quick testing without leaving the shell. It offers features such as an expressive
    syntax, handling of forms and uploads, and sessions.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPie is probably the easiest REST client to install, as it can be done using
    `pip` or some other package manager, such as Chocolatey, apt (for Linux), or Homebrew.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to install HTTPie is to activate your virtual environment and
    use `pip`, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it’s been installed, you can test HTTPie with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The output should begin with an `HTTP/1.1 200` `OK` response.
  prefs: []
  type: TYPE_NORMAL
- en: '`venv` signifies that the virtual environment is active. HTTPie simplifies
    issuing HTTP requests by simply adding `POST` for `POST` requests, payloads, form
    values, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the necessary packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After setting up the virtual environment, you should activate it and install
    the Python libraries required for your first simple application: FastAPI and Uvicorn.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For FastAPI to run, it needs a server. In this case, a server is a software
    designed to serve web applications (or REST APIs). FastAPI relies on the **asynchronous
    server gateway interface** (**ASGI**), which enables async non-blocking applications,
    which is something you can completely use with your FastAPI capabilities. You
    can read more about ASGI in the following documentation: [https://asgi.readthedocs.io/](https://asgi.readthedocs.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'At present, the FastAPI documentation lists three compatible Python ASGI-compatible
    servers: **Uvicorn**, **Hypercorn**, and **Daphne**. This book will focus on Uvicorn,
    the most widely used and recommended option for working with FastAPI. Uvicorn
    offers high performance, and if you get stuck, there’s extensive documentation
    available online.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the first two dependencies, ensure you’re in your working directory
    with the desired virtual environment activated, then execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, you have a Python coding environment that contains a shell, one or two
    REST clients, a great editor, and a great REST framework. If you’ve previously
    developed a **Django** or **Flask** application, this should all be familiar ground.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, choose a folder or clone this book’s GitHub repository and activate
    a virtual environment. It is customary to create the environment in a folder named
    `venv` within the working directory, but feel free to structure your directories
    and code as you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Later, this chapter will briefly discuss some options for structuring your FastAPI
    code. For now, ensure you’re in a folder with your newly created virtual environment
    activated.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B22406_01.xhtml#_idTextAnchor010), *Web Development and the
    FARM Stack*, it was mentioned why FastAPI is the preferred REST framework in the
    FARM stack. What sets FastAPI apart is its coding speed and the resulting clean
    code, with which you can spot bugs quickly and early. The author of the framework
    himself, *Sebastian Ramirez*, often modestly emphasizes that FastAPI is just a
    mix of Starlette and Pydantic, while heavily relying on modern Python features,
    especially type hinting.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into an example and building a FastAPI app, it is useful to quickly
    go over the frameworks that FastAPI is based on.
  prefs: []
  type: TYPE_NORMAL
- en: Starlette
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starlette is an ASGI framework known for its top performance and numerous features,
    which are also available in FastAPI. These include WebSocket support, events on
    startup and shutdown, session and cookie support, background tasks, middleware
    implementations, and templates. While you will not be coding directly in Starlette,
    it is important to know how FastAPI works under the hood and what its origins
    are.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in knowing its functionalities, visit Starlette’s excellent
    documentation (https://www.starlette.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will likely have learned about the asynchronous programming paradigm when
    developing apps with Node.js. It involves running slow operations, such as network
    calls and file reading, allowing the system to respond to other requests without
    blocking. This is achieved by using an event loop, an asynchronous task manager
    that enables it to move requests to the next one, even though the previous one
    hasn’t finished and yielded a response.
  prefs: []
  type: TYPE_NORMAL
- en: Python added support for asynchronous I/O programming in version 3.4 and the
    `async`/`await` keywords in version 3.6\. ASGI emerged shortly afterward in the
    Python world, outlining how applications should be structured and called, and
    defining the events that can be sent and received. FastAPI relies on ASGI and
    returns an ASGI-compatible app.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, all the endpoint functions are prefixed with the `async` keyword,
    even before they become necessary, since you will be using the asynchronous Motor
    Python MongoDB driver.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are developing a simple application not expecting high stress, you can
    use simple synchronous code and the official PyMongo driver.
  prefs: []
  type: TYPE_NORMAL
- en: Functions with the `async` keyword are coroutines; they run on the event loop.
    While simple examples in this chapter may work without `async`, the real power
    of asynchronous programming in FastAPI will be visible when you connect to your
    MongoDB server through an `async` driver, such as **Motor** (https://motor.readthedocs.io/en/stable/).
  prefs: []
  type: TYPE_NORMAL
- en: Standard REST API operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section will discuss some common terminologies in API development. Usually,
    communication occurs via the HTTP protocol, through HTTP requests and responses.
    You’ll explore how FastAPI handles these aspects and leverages additional libraries
    such as Pydantic and type hints to improve efficiency. In the examples, you’ll
    be using Uvicorn as the server.
  prefs: []
  type: TYPE_NORMAL
- en: The basis of any REST API communication is a system of URLs and paths. The URL
    for your local web development server will be `http://localhost:8000` since `8000`
    is the default port that Uvicorn uses. The path part (optional) of an endpoint
    could be `/cars`, while `http` is the scheme. You will see how FastAPI handles
    paths, query strings, and the request and response bodies, the significance of
    defining endpoint functions in a certain order, and how to extract variables from
    dynamic path segments effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In every path or address, the URL and the path combined, there’s a set of approved
    actions that can be performed on it—HTTP verbs. For example, a page or URL might
    list all the cars on sale, but you cannot issue a `POST` request since this is
    not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: In FastAPI, these verbs are implemented as Python **decorators**. To put it
    better, they are exposed as decorators, and they are implemented only if you,
    the developer, implement them.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI encourages the proper and semantic use of HTTP verbs for data resource
    operations. For example, you should always use `POST` (or the `@post` decorator)
    when creating new resources, `GET` for reading data (individual or lists of items),
    `PATCH` for updating, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP messages consist of a request/status line, headers, and, optionally, body
    data. FastAPI offers tools to easily create and modify headers, set response codes,
    and manipulate request and response bodies in a clean and intuitive way.
  prefs: []
  type: TYPE_NORMAL
- en: This section describes the programming concepts and specific Python features
    that underpin FastAPI’s performance and enable maintainable code. In the next
    section, you’ll learn about standard REST API operations and see how they’re achieved
    with FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: How does FastAPI speak REST?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Observing even a minimal FastAPI application, the classic **Hello World** example,
    you can start examining how FastAPI structures endpoints. In this context, an
    endpoint specifies the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A unique combination of a URL: This will be the same in your development server—`localhost:8000`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A path: The part after the slash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An HTTP method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a new folder named `Chapter4`, for example, create a new Python file named
    `chapter4_01.py` by using Visual Studio Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With this code, you can accomplish several things. Here’s a breakdown of what
    each part does:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first line of `chapter4_01.py`, you imported the FastAPI class from the
    `fastapi` package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, you instantiated an application object. This is just a Python class with
    all the API functionalities that exposes an ASGI-compatible application, which
    must be passed to Uvicorn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, the application is ready and instantiated. But without endpoints, it can’t
    do or say much. It has one endpoint, the root, which you can view at `http://127.0.0.1:8000/`.
    FastAPI exposes decorators for HTTP methods to tell the application how and whether
    to respond. However, you must implement them.
  prefs: []
  type: TYPE_NORMAL
- en: After that, you used the `@get` decorator, which corresponds to the `GET` method,
    and passed a URL—in this case, the root path, `/`, is used.
  prefs: []
  type: TYPE_NORMAL
- en: The decorated function, named `root`, is responsible for responding to requests.
    It accepts any arguments (in this case, there aren’t any). The value returned
    by the function, typically a Python dictionary, will be transformed into a **JavaScript
    Object Notation** (**JSON**) response by the ASGI server and returned as an HTTP
    response. This may seem obvious, but it is useful to break things down to understand
    the fundamentals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code defines a fully functional application with a single endpoint.
    To test it, you need a Uvicorn server. Now, you must run the live server with
    Uvicorn in your command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You will use this code snippet quite often when developing with FastAPI, so
    the following note will break it down.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Uvicorn is your ASGI-compatible web server. You can call it directly by passing
    it the combination of the executable Python file (without the extension) and the
    instantiated app (the FastAPI instance), separated by a colon (`:`). The `--reload`
    flag instructs Uvicorn to reload the server each time you save your code, similar
    to *Nodemon* in Node.js. Unless specified otherwise, you can run all the examples
    in this book containing FastAPI apps using this syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output when testing your only endpoint with HTTPie. Remember, when
    you omit the keyword for the method, it defaults to a `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: HTTPie informs you that your simple endpoint is running. You will get a `200
    OK` status code, the `content-type` is correctly set to `application/json`, and
    the response is a JSON object containing the desired message.
  prefs: []
  type: TYPE_NORMAL
- en: Every REST API guide begins with similar *hello world* examples, but with FastAPI,
    this is particularly useful. With a couple of lines of code, you can see the anatomy
    of a simple endpoint. This endpoint only covers the `GET` method directed toward
    the root URL (`/`). So, if you try to test this app with a `POST` request, you
    should get a `405 Method Not Allowed` error (or any method other than `GET`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to create an endpoint that responds with the same message but for
    `POST` requests, you will just have to change the decorator. Add the following
    code to the end of your file (`chapter4_01.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'HTTPie will respond accordingly in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve created a couple of endpoints, head over to `http://localhost:8000/docs`
    and see what FastAPI has generated for you.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When developing REST APIs, you will find yourself needing to constantly perform
    API calls—`GET` and `POST` requests—analyze the responses, set payloads and headers,
    and so on. Choosing a viable REST client is largely a matter of preference and
    is something that should be carefully considered. While there are numerous clients
    on the market— ranging from full-blown API IDEs such as Postman ([https://www.postman.com/](https://www.postman.com/))
    to the slightly more lightweight Insomnia ([https://insomnia.rest/](https://insomnia.rest/))
    or Visual Studio Code’s REST Client ([https://marketplace.visualstudio.com/items?itemName=humao.rest-client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client))—this
    book mostly uses the very simple command-line based HTTPie client, which exposes
    a minimalistic command-line interface.
  prefs: []
  type: TYPE_NORMAL
- en: This, however, is the right moment to introduce another of FastAPI’s most beloved
    features—interactive documentation—a tool that facilitates the development process
    of REST APIs in FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: With each endpoint or router that you develop, FastAPI creates automatically
    generated documentation. It is interactive, allowing you to test your API as you
    develop it. FastAPI lists all the endpoints you define and provides information
    about expected inputs and responses. The documentation is based on the OpenAPI
    specification and relies heavily on Python hints and the Pydantic library. It
    allows setting the JSON or form data to be sent to the endpoints, displays responses
    or errors, is tightly coupled with Pydantic, and is able to handle simple authorization
    procedures such as the bearer token flow that will be implemented in [*Chapter
    6*](B22406_06.xhtml#_idTextAnchor105)*, Authentication and Authorization*. Rather
    than having to use a REST client, you can just open the documentation, select
    the desired endpoint to be tested, input the test data conveniently into a standard
    web page, and hit the **Submit** button!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you created a minimal, yet fully functional API with a single
    endpoint, giving you insights into the syntax and structure of an app. In the
    next section, you will learn about the basic elements of a REST API request-response
    cycle and how you can control every single aspect of the process. Standard REST
    clients provide a more transferable experience and enable you to compare different
    APIs, even those that aren’t Python-based.
  prefs: []
  type: TYPE_NORMAL
- en: Building a showcase API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST APIs revolve around HTTP requests and responses, which power the web and
    are implemented in every web framework using the HTTP protocol. To showcase the
    capabilities of FastAPI, you will now create simple endpoints that focus on specific
    parts of code that achieve the desired functionalities. Rather than the usual
    CRUD operations, the next sections will focus on the process of retrieving and
    setting request and response elements.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving path and query parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first endpoint will be for retrieving a fictional car by its unique ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `chapter4_02.py` and insert the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try it out and test the endpoint with an ID equal to `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You got your JSON response back, but here, `1` in the response is a string
    (hint: quotes). You can try this same route with an ID equal to a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: FastAPI returns your string, which was provided as part of the dynamic parameter.
    However, Python’s newer features, such as type hinting, come into play.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Returning to your FastAPI route (or endpoint) to make the car ID become an
    integer, it is enough to hint at the type of the variable parameter. The endpoint
    will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You have given it a new path: `/carh/{id}` (the `h` after `car` means hint).
    Apart from the function’s name (`hinted_car_id`), the only difference is in the
    argument: the semicolon followed by `int` means that you can expect an integer,
    but FastAPI takes this very seriously and you can already see how the framework
    puts the hinting system to good use.'
  prefs: []
  type: TYPE_NORMAL
- en: If you take a look at the interactive documentation at `http://localhost:8000/docs`
    and try to insert a string in the `id` field for the `/carh/` endpoint, you will
    get an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try it out in your REST client and test the `/carh/` route by passing
    it a string. First, FastAPI sets the status code for you correctly—that is, `422
    Unprocessable Entity`—and in the body of the response, it pointed out what the
    problem was—the value is not a valid integer. It also informs you of the exact
    location where the error occurred: in the `id` path.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a trivial example but imagine that you are sending a complex request
    with a complicated path, several query strings, and maybe additional information
    in the header. Using type hinting quickly solves these problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to access the endpoint without specifying any ID, you will get yet
    another error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: FastAPI has, again, correctly set the status code, giving you a `404 Not Found`
    error, and repeated this message in the body. The endpoint you hit does not exist;
    you must specify a value after the slash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Situations may arise where you have similar paths: both dynamic and static.
    A typical case is an application that has numerous users. Directing the API at
    the URL defined by `/users/id` would give you some information about the user
    with the selected ID, while `/users/me` would typically be an endpoint that displays
    your information and allows you to modify it, in some way.'
  prefs: []
  type: TYPE_NORMAL
- en: In these situations, it is important to remember that, like in other web frameworks,
    order matters. Because of said order of path handler declarations, the following
    piece of code will not yield the desired results as the application will try to
    match the `/me` route with the first endpoint that it encounters—the one that
    requires an ID—and since the `/me` part is not a valid ID, you will get an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `chapter4_03.py` and paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When you run the application and test the `/user/me` endpoint, you will get
    a `422 Unprocessable Entity` error, like previously. This is quite logical once
    you remember that order matters—FastAPI finds the first matching URL, checks the
    types, and throws an error. If the first match is the one with the fixed path,
    everything works as intended. Just change the order of the two routes and everything
    will work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Another powerful feature of the path treatment of FastAPI is how it limits the
    path to a specific set of values and a path function, imported from FastAPI, which
    enables you to perform additional validation on the path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to have a URL path that accepts two values and allows the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`account_type`: This can be `free` or `pro`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`months`: This must be an integer between 3 and 12.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FastAPI solves this by letting you create a class based on `Enum` for the account
    type. This class defines all the possible values for the account variable. In
    this case, there are just two—`free` and `pro`. Create a new file and name it
    `chapter4_04.py` and edit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the actual endpoint, you can combine this class with the utilities
    from the `Path` function (do not forget to import it along with FastAPI from `fastapi`).
    Paste the following code at the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, FastAPI sets the type of the `acc_type` part of the path
    to your previously defined class and ensures that only the `free` or `pro` value
    can be passed. The `months` variable, however, is handled by the `Path` utility
    function. When you try to hit this endpoint, `account_type` will show that there
    are only two values available, while the actual value of the enumeration can be
    accessed through the `.``value` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI allows you to declare path parameters using standard Python types. If
    no type is declared, FastAPI will assume that you’re working with strings.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on these topics, you can visit the excellent documentation
    site and see what other options are available (https://fastapi.tiangolo.com/tutorial/path-params/).
    In this case, the `Path` function received three parameters. The three dots mean
    that the value is required and that no default value has been provided, `ge=3`
    means that the value can be greater than or equal to `3`, while `le=12` means
    that it can be smaller than or equal to `12`. This syntax allows you to define
    validation right inside the path functions quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Query parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve learned how to validate, restrict, and properly order your path
    parameters and endpoints, it’s time to look at **query parameters**. These parameters
    are a simple mechanism of passing data to a server through the URL and they are
    represented as key-value pairs, separated by an equals sign (=). You can have
    multiple pairs of keys and values separated by an ampersand (&).
  prefs: []
  type: TYPE_NORMAL
- en: 'Query parameters are added at the end of the URL by using the question mark/equals
    notation: `?``min_ price=2000&max_price=4000`.'
  prefs: []
  type: TYPE_NORMAL
- en: The question mark, `?`, is a separator that tells you where the query string
    begins, while the ampersand, `&`, allows you to add more than one (the equals
    sign, `=`) assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Query parameters are usually used to apply filters, sort, order, or limit query
    sets, paginate a long list of results, and similar tasks. FastAPI treats them
    very similarly to path parameters as it automatically picks them up and makes
    them available for processing in your endpoint functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple endpoint that accepts two query parameters for the minimum
    and maximum prices of the car, and name it `chapter4_05.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test this endpoint with HTTPie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this solution, you can’t ensure the basic condition that the minimum price
    should be lower than the maximum price. This is handled by the object-level validation
    of Pydantic.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI picks your query parameters and performs the same parsing and validation
    checks it did previously. It provides the `Query` function, like the `Path` function.
    You can use the *greater than*, *less than*, or *equal* conditions, as well as
    set default values. They can also be set to default to `None`. Query parameters
    will be converted into Boolean values as needed. You can write rather complex
    combinations of path and query parameters, as FastAPI can distinguish between
    them and handle them inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, you’ve seen how FastAPI enables working with data that is passed
    through the path and query parameters, as well as the tools it uses under the
    hood to perform parsing and validation as soon as possible. Now, you will examine
    the main data vehicle of REST APIs: the **request body**.'
  prefs: []
  type: TYPE_NORMAL
- en: The request body—the bulk of the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: REST APIs enable two-way communication between a client—a web browser or a mobile
    application and an API server. The bulk of this data is carried over in the request
    and response body. A request body has data sent from the client to your API, while
    the response body is data sent from the API server to the client(s).
  prefs: []
  type: TYPE_NORMAL
- en: This data can be encoded in various ways, but many users prefer to encode data
    with JSON since it is exceptionally nice with our database solution of choice,
    MongoDB—which operates with BSON, a close relative to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'When modifying data on the server, you should always use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST` requests: To create new resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` and `PATCH`: To update resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: To delete resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the body of a request will contain raw data—in this case, MongoDB documents
    or arrays of documents—you can use Pydantic models. But first, see how the mechanism
    works, without any validation or modeling. In HTTP terminology, the `GET` method
    should be *idempotent*, meaning it should always return the same value for the
    same set of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code for a hypothetical endpoint used to insert new cars in
    your future database, you can pass the generic request body as the data. It can
    be a dictionary without entering into the specifics of how that dictionary should
    be shaped. Create a new file called `chapter4_06.py` and paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Intuitively, the `Body` function is similar to the previously introduced `Path`
    and `Query` functions. Yet the difference is, when working with the request body,
    this function is mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three dots indicate that the body is required (you must send something),
    but this is the only requirement. Try to insert a car (a Fiat 500, made in 2015):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: FastAPI does the heavy lifting. You can retrieve all the data passed to the
    request body and make it available to your function for further processing – database
    insertion, optional preprocessing, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you could have passed any key-value pairs to the body. Of
    course, this is just an illustration of the general mechanism—in reality, Pydantic
    will be your data guardian, ensuring you only let the right data in.
  prefs: []
  type: TYPE_NORMAL
- en: While all went well, FastAPI sends you a `200 response` status again, even though
    a `201 Resource Created` error is more appropriate and exact. You could, for instance,
    have some document inserted into MongoDB at the end of the function and a `201
    CREATED` status message would be appropriate. You will see how easy it is to modify
    the response body as well, but for now, you will be able to see why Pydantic shines
    when it comes to request bodies.
  prefs: []
  type: TYPE_NORMAL
- en: To create new car entries, you would only need the `brand`, `model`, and production
    `year` fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, create a simple Pydantic model with the desired types in the `chapter4_07.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: By now, you know that the first two parameters are expected to be strings, while
    the year must be an integer; all of them are required.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you try to post the same data that you did previously but with additional
    fields, you will only get these three fields back. Also, these fields will go
    through Pydantic parsing and validation and throw meaningful error messages if
    something does not conform to the data specification.
  prefs: []
  type: TYPE_NORMAL
- en: This combination of Pydantic model validation and the `Body` function provides
    all the necessary flexibility when working with request data. This is because
    you can combine them and pass different bits of information using the same request
    bus ride.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to pass a promo code attached to a user, along with the new car
    data, you could try defining a Pydantic model for the user and extracting the
    promo code with the `Body` function. First, define a minimal user model in a new
    file and name it `chapter4_08.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a more complex function that will process two Pydantic models and
    an optional user promo code – set the default value to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: For this request, which contains a full-fledged JSON object with two nested
    objects and some code, you might opt to use Insomnia or a similar GUI client since
    it’s easier than typing JSON in the command prompt or resorting to piping. While
    it is largely a matter of preference, when developing and testing REST APIs, it
    is useful to have a GUI tool such as Insomnia or Postman and a command-line client
    (such as cURL or HTTPie).
  prefs: []
  type: TYPE_NORMAL
- en: The `Body` class constructor’s parameters are very similar to the `Path` and
    `Query` constructors, and since they will often be much more complex, it is useful
    to try and tame them with Pydantic. Parsing, validation, and meaningful error
    messages – Pydantic provides us with the whole package before allowing the request
    body data to make it to the real data processing functionality. The `POST` requests
    are almost exclusively fed an appropriate Pydantic model as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: After playing around with the combination of request bodies and Pydantic models,
    you have seen that you can control the inflow of the data and be confident that
    the data that’s available to your API endpoint will be what you want and expect
    it to be. Sometimes, however, you may want to go to the bare metal, and work with
    the raw request object. FastAPI covers that case too, as is discussed in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The request object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'FastAPI is built on the Starlette web framework. The raw request object in
    FastAPI is Starlette’s request object and it can be accessed in your functions
    once it’s been imported from FastAPI directly. By using the request object directly,
    you are missing out on FastAPI’s most important features: Pydantic’s parsing and
    validation and self-documentation! However, there might be situations in which
    you need to have the raw request.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following example in the `chapter4_09.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you created a minimal FastAPI app, imported the `Request`
    class, and used it in the endpoint. If you test this endpoint with your `REST`
    client, you will only get the base URL as the message, while the `all` part lists
    all the methods and properties of the `Request` object so that you have an idea
    of what is available.
  prefs: []
  type: TYPE_NORMAL
- en: All of these methods and properties are available for you to use in your application.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’ve seen how FastAPI facilitates your work with the main HTTP
    transport mechanisms—request bodies, query strings, and paths. Next, you’ll explore
    equally important aspects of any web framework solution—cookies, headers, form
    data, and files.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies and headers, form data, and files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Speaking of the ways the web framework ingests data, topics such as handling
    form data, handling files, and manipulating cookies and headers must be included.
    This section will provide simple examples of how FastAPI handles these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Headers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Header parameters are handled in a similar way to query and path parameters
    and, as you’ll see later, cookies. You can collect them, so to speak, using the
    `Header` function. Headers are essential in topics such as authentication and
    authorization as they often carry **JSON Web Tokens** (**JWTs**), which are used
    for identifying users and their permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to read the user agent by using the `Header` function in a new file called
    `chapter4_10.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the software you use to execute the test for the endpoint, you’ll
    get different results. Here’s an example of using HTTPie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can extract all the headers in this way and FastAPI will provide further
    assistance—it will convert names into lowercase, convert the keys into snake case,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Cookies work similarly, although they can be extracted manually from the `Cookies`
    header. The framework offers a utility function, conveniently named `Cookie`,
    that does all the work in a way similar to `Query`, `Path`, and `Header`.
  prefs: []
  type: TYPE_NORMAL
- en: Forms (and files)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far, you’ve only dealt with JSON data. It is the ubiquitous language of the
    web and your main vehicle for moving data back and forth. There are cases, however,
    that require a different data encoding – forms might be processed directly by
    your API, with data encoded as `multipart`/`form-data` or `form-urlencoded`. Since
    the arrival of modern React Server Actions, form data has become more popular
    in frontend development too.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Although you can have multiple Form parameters in a path operation, you cannot
    declare the `Body` fields expected in JSON. The HTTP request will have the body
    encoded using only `application/x-www-form-urlencoded instead of application/json`.
    This limitation is part of the HTTP protocol and is not specific to FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to cover both form cases—with and without including files
    for upload—is to start by installing `python-multipart`, a streaming multipart
    parser for Python. For this, you must stop your server and use `pip` to install
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `Form` function works similarly to the previously examined utility functions,
    but with the difference that it looks for form-encoded parameters. For simple
    fields, data is usually encoded using the media type (`application/x-www-form-urlencoded`),
    while if files are included, the encoding corresponds to `mutlipart/form-data`.
  prefs: []
  type: TYPE_NORMAL
- en: Look at a simple example in which you wish to upload an image and a couple of
    form fields, such as the brand and the model.
  prefs: []
  type: TYPE_NORMAL
- en: You will use a photo that can be found on Pexels ([https://www.pexels.com/photo/white-](https://www.pexels.com/photo/white-vintage-car-parked-on-green-grass-8746027/)),
    renamed to `car.jpeg` and saved in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `chapter4_11.py` and paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code handles the form parameters via the `Form` function and the
    uploaded file by using the `UploadFile` utility class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The photo, however, isn’t saved on the disk—its presence is merely acknowledged,
    and the filename is returned. Testing this endpoint, that has a file upload, in
    HTTPie looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding HTTPie call returns the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To save the image to a disk, you must copy the buffer to an actual file on
    the disk. The following code achieves this (`chapter4_12.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `open` block opens a file on the disk using a specified filename and copies
    the FastAPI file that’s sent through the form. You will have hardcoded the filename,
    so any new upload will simply overwrite the existing file, but you could use some
    randomly generated filename while using the **universally unique identifier**
    (**UUID**) library, for example.
  prefs: []
  type: TYPE_NORMAL
- en: File uploading is an operation that can be achieved in different ways—file uploads
    can be also handled by the Python `async` file library known as `aiofiles` or
    as a background task, which is another feature of FastAPI, as will be shown later
    in [*Chapter 5*](B22406_05.xhtml#_idTextAnchor090), *Setting Up a* *React Workflow*.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI response customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous sections discussed numerous examples of FastAPI requests how you
    can reach every corner of the request—the path, the query string, the request
    body, headers, and cookies—and how to work with form-encoded requests.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a closer look at FastAPI’s response objects. In all previous
    cases, you returned a Python dictionary that was serialized into JSON by FastAPI.
    The framework enables customizations to the response.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you might want to change in an HTTP response is the status code,
    for instance to provide some meaningful errors when things do not go as planned.
    FastAPI conveniently raises classic Python exceptions when HTTP errors are present.
    It also uses standard-compliant meaningful response codes that minimize the need
    to create custom payload messages. For instance, you don’t want to send a `200
    OK` status code for everything and then notify users of errors by using the payload—FastAPI
    encourages good practices.
  prefs: []
  type: TYPE_NORMAL
- en: Setting status codes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'HTTP status codes indicate whether an operation was successful or there was
    an error. These codes also provide information about the type of operation, and
    they can be divided into several groups: informational, successful, client errors,
    server errors, and so on. It isn’t necessary to memorize the status codes, although
    you probably know what a `404` or `500` code is.'
  prefs: []
  type: TYPE_NORMAL
- en: 'FastAPI makes it incredibly easy to set a status code—it is enough to just
    pass the desired `status_code` variable to the decorator. Here, you are using
    the `208 status` code for a simple endpoint (`chapter4_13.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing the root route in HTTPie yields the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can set status codes for the `delete`, `update`, and `create`
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI sets the `200 status` code by default if it doesn’t encounter exceptions,
    so it is up to you to set the correct codes for the various API operations, such
    as `204 No Content` for deleting and `201` for creating. This is a good practice
    that is particularly encouraged.
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic can be used for response modeling. You can limit or modify the fields
    that should appear in the response and perform similar checks that it does for
    the request body by using the `response_model` argument.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI does not enable customizing the response, but modifying and setting
    headers and cookies is as simple as reading them from the HTTP request and the
    framework has you covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although beyond the scope of this book, it is worth noting that JSON is by
    no means the only response that FastAPI can provide: you can output an `HTMLResponse`
    and use classic Flask-like Jinja templates, `StreamingResponse`, `FileResponse`,
    `RedirectResponse`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP errors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Errors are bound to happen. For example, users somehow find a way to send the
    wrong parameters to a query, the frontend sends the wrong request body, or the
    database goes offline (although this is unlikely with MongoDB)—anything can happen.
    It is crucial to detect these errors as soon as possible (this is a leitmotiv
    in FastAPI) and send clear and complete messages to the frontend, as well as the
    user by raising exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI relies on web standards and enforces good practices in every facet of
    the development process, so it puts a lot of emphasis on using HTTP status codes.
    These codes provide a clear indication of the type of problem that has arisen,
    while the payload can be used to further clarify the cause of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI uses a Python exception, aptly called `HTTPException`, to raise HTTP
    errors. This class allows you to set a status code and set an error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the example of inserting new cars into the database, you could
    set a custom exception like the following (`chapter4_14.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When trying to insert a car that hasn’t been built yet, the response is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is a pretty contrived example of making custom exceptions for a possible
    problem that might arise. However, this gives a good idea of what is possible
    and the flexibility that FastAPI gives you.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To make a brief but self-contained introduction to FastAPI, the system of dependency
    injection must be mentioned. In broad terms, **dependency injection** (**DI**)
    is a way of providing necessary functionalities (classes, functions, database
    connections, authorization statuses and so on) to a path operation function at
    the right time. FastAPI’s DI system is very useful for sharing logic across endpoints,
    sharing database connections, for instance, as you will see when you connect to
    your MongoDB Atlas instance—performing security and authentication checks, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies aren’t special; they are just normal functions that can take the
    same arguments as path operations. In fact, the official documentation compares
    them to path operations without the decorator. Dependencies are used a bit differently,
    though. They are given a single parameter (typically a callable) and they are
    not called directly; they are just passed as a parameter to `Depends()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example inspired by the official FastAPI documentation is the following;
    you can use a pagination dependency and use it in different resources (`chapter4_15.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: One of the most common cases of DI used in a full stack FastAPI project is authentication;
    you can use the same authentication logic, that is, some class or function that
    checks the header for an authorization token and applies it to all the routes
    or routers that need to require authentication, as you will see in [*Chapter 6*](B22406_06.xhtml#_idTextAnchor105)*,
    Authentication* *and Authorization*.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring FastAPI applications with routers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although putting all of our `request`/`response` logic in one big file is possible,
    as you start building even a moderately sized project, you will quickly see that
    this is not feasible, maintainable, or pleasant to work with. FastAPI, like Express.js
    in the Node.js world, or Flask with its blueprints, provides `cars`, at the `/cars`
    path, another to handle the creation and management of users at `/users`, and
    so on. FastAPI proposes a type of project structure that is simple and intuitive
    enough, yet able to accommodate the most common cases.
  prefs: []
  type: TYPE_NORMAL
- en: API Routers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FastAPI provides a class named APIRouter that is used for grouping routes, usually
    related to the same type of resource (users, shopping items, and so on). This
    concept, known in Flask as **Blueprints** and present in every modern web framework,
    allows the code to be more modular and distributed in smaller units, with each
    router managing only a certain type of resource. These APIRouters are finally
    included in the main FastAPI instance and provide very similar functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of applying the path decorators (`@get`, `@post` and so on) directly
    on the main application instance (usually called app), they are applied to the
    APIRouter instance. Below is a simple example of an application broken into two
    APIRouters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a `chapter4_16.py` file that will host the main FastAPI instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a new folder named `/routers`, and in this folder, create an APIRouter
    in a file named `users.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another file, in the same `/routers` directory, named `cars.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When connecting the routers to the main application, in the `chapter4_17.py`
    file, you are able to provide different optional arguments to the APIRouter—tags
    and a set of dependencies, such as an authentication requirement. The prefix,
    however, is mandatory, as the application needs to know at which URL to mount
    the APIRouter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you test this application with Uvicorn with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: And then, head over to the automatically generated documentation, you will see
    that the two APIRouters are mounted just as if you defined two separate endpoints.
    They are, however, grouped under the respective tags, for easier navigation and
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: If you now navigate to the documentation, you should indeed find just one route
    defined at `/cars` and responding only to `GET` requests. It is intuitive that
    this procedure can have you build parallel or same-level routers in no time, but
    one of the biggest benefits of using APIRouters is that they support nesting,
    which enables managing quite complex hierarchies of endpoints effortlessly!
  prefs: []
  type: TYPE_NORMAL
- en: Routers are subsystems of an application and are not meant to be used autonomously,
    although you are free to mount entire separate FastAPI applications under specific
    paths, but that is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: FastAPI implements the concept of `request`/`response` cycle, intercepting the
    request, manipulating it in some desired way, then taking the response before
    it is sent to the browser or client, performing additional manipulation if needed,
    and finally, returning the final response.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware is based on the ASGI specification, and it is implemented in Starlette,
    so FastAPI enables using it in all your routes and optionally tying it to a part
    of an application (via APIRouter) or the entire app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly to the mentioned frameworks, the FastAPI middleware is just a function
    that receives the request and a `call_next` function. Create a new file named
    `chapter4_17.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you now start this small application, and test the only route, the route
    at [`http://127.0.0.1:8000/`](http://127.0.0.1:8000/), you will notice that the
    returned headers contain an integer between 1 and 10, and on every request this
    integer will be different.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware plays a large role in authentication with **cross-origin resource
    sharing** (**CORS**), something you’re bound to face when developing full stack
    applications, but also for redirecting, managing proxies, and so on. It is a very
    powerful concept that can greatly simplify and enhance your application efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered very simple examples of how FastAPI achieves the most common
    REST API tasks and the way it can help you by leveraging modern Python features
    and libraries such as Pydantic.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also detailed how FastAPI enables you to perform requests and responses
    through HTTP and how you can tap into it, at any point, and customize and access
    the elements of the request, as well as the response. Finally, it also detailed
    how to split your API into routers and how to organize your app into logical resource-based
    units.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will give you a quick introduction to React—the user interface
    library of choice in the FARM stack.
  prefs: []
  type: TYPE_NORMAL
