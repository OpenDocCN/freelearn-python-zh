- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Network Monitoring with Python – Part 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行网络监控——第一部分
- en: 'Imagine you get a call from your company’s network operations center at 2:00
    a.m. The person on the other end says: “Hi, we are facing a difficult issue that
    is impacting production services. We suspect it might be network related. Can
    you check for us?” For this type of urgent, open-ended question, what would be
    the first thing you do? Most of the time, the thing that comes to mind would be:
    What changed in the time between when the network was working and when something
    went wrong? We would check our monitoring tool and see if any key metrics have
    changed in the last few hours. Better yet, we may have received monitoring alerts
    for any metrics that deviated from the normal baseline numbers.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你在凌晨2点接到公司网络操作中心的电话。电话那头的人说：“嗨，我们遇到了一个影响生产服务的问题，我们怀疑可能是网络相关的问题。你能帮我们检查一下吗？”对于这种紧急的开放式问题，你首先会做什么？大多数情况下，你可能会想到：网络在正常工作和出现问题之间发生了什么变化？我们会检查我们的监控工具，看看在过去几小时内是否有任何关键指标发生变化。更好的是，我们可能已经收到了任何偏离正常基线数值的监控警报。
- en: Throughout this book, we have been discussing various ways to systematically
    make predictable changes to our network, intending to keep the network running
    as smoothly as possible. However, networks are not static – far from it. They
    are probably one of the most fluid parts of the entire infrastructure. By definition,
    a network connects different parts of the infrastructure, constantly passing traffic
    back and forth.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直在讨论系统地对我们网络进行可预测的更改的各种方法，目的是让网络尽可能平稳运行。然而，网络并非静态——远非如此。它们可能是整个基础设施中最流动的部分。根据定义，网络连接基础设施的不同部分，不断进行双向流量传输。
- en: 'There are lots of moving parts that can cause our network to stop working as
    expected: hardware failures, software with bugs, human mistakes despite their
    best intentions, and many more. It is not a question of whether things will go
    wrong but of when and what will go wrong when it happens. We need ways to monitor
    our network to make sure it works as expected and hopefully be notified when it
    does not.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多因素可能导致我们的网络无法按预期工作：硬件故障、有缺陷的软件、尽管有最好的意图但人为错误，等等。这不是一个会不会出错的问题，而是出错的时机和出错的内容。我们需要监控网络，确保它按预期工作，并在它不工作时通知我们。
- en: In the upcoming two chapters, we will look at various ways to perform network
    monitoring tasks. Many tools we have looked at thus far can be tied together or
    directly managed by Python. Like many tools we have looked at, network monitoring
    has two parts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将探讨执行网络监控任务的各种方法。到目前为止，我们查看的许多工具都可以通过Python连接起来或直接管理。就像我们查看过的许多工具一样，网络监控也有两个部分。
- en: First, we need to know what monitoring-related information the equipment can
    transmit. Second, we need to identify what useful, actionable information we can
    interpret from the data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要知道设备可以传输哪些监控相关信息。其次，我们需要确定我们可以从数据中解释哪些有用、可操作的信息。
- en: 'In this chapter, we will begin by looking at a few tools that allow us to monitor
    the network effectively:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先探讨一些能够有效监控网络的工具：
- en: The lab setup
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验室设置
- en: The **Simple Network Management Protocol** (**SNMP**) and related Python libraries
    to work with SNMP
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单网络管理协议**（**SNMP**）和相关Python库用于处理SNMP'
- en: 'Python visualization libraries:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python可视化库：
- en: Matplotlib and examples
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matplotlib和示例
- en: Pygal and examples
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pygal和示例
- en: Python integration with MRTG and Cacti for network visualization
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python与MRTG和Cacti集成进行网络可视化
- en: This list is not exhaustive, and there is certainly no lack of commercial vendors
    in the network monitoring space. The basics of network monitoring that we will
    look at, however, carry well for both open source and commercial tools.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表并不全面，网络监控领域的商业供应商当然也不少。然而，我们将探讨的网络监控的基本原理，无论是开源工具还是商业工具都适用。
- en: Lab Setup
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验室设置
- en: 'The lab for this chapter consists of IOSv devices to simplify device configuration.
    We will use the same lab for this and the next chapters. The topology is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的实验室由IOSv设备组成，以简化设备配置。我们将使用这个实验室以及下一章的实验室。拓扑结构如下：
- en: '![Diagram  Description automatically generated](img/B18403_07_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图示  描述自动生成](img/B18403_07_01.png)'
- en: 'Figure 7.1: Lab topology'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：实验室拓扑结构
- en: 'The device configuration is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 设备配置如下：
- en: '| **Device** | **Management IP** | **Loopback IP** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **设备** | **管理IP** | **环回IP** |'
- en: '| r1 | `192.168.2.218` | `192.168.0.1` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| r1 | `192.168.2.218` | `192.168.0.1` |'
- en: '| r2 | `192.168.2.219` | `192.168.0.2` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| r2 | `192.168.2.219` | `192.168.0.2` |'
- en: '| r3 | `192.168.2.220` | `192.168.0.3` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| r3 | `192.168.2.220` | `192.168.0.3` |'
- en: '| r5 | `192.168.2.221` | `192.168.0.4` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| r5 | `192.168.2.221` | `192.168.0.4` |'
- en: '| r6 | `192.168.2.222` | `192.168.0.5` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| r6 | `192.168.2.222` | `192.168.0.5` |'
- en: 'The Ubuntu hosts information is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 主机的信息如下：
- en: '| **Device Name** | **External Link Eth0** | **Internal IP Eth1** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **设备名称** | **外部链接 Eth0** | **内部 IP Eth1** |'
- en: '| Client | `192.168.2.211` | `10.0.0.9` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 客户端 | `192.168.2.211` | `10.0.0.9` |'
- en: '| Server | `192.168.2.212` | `10.0.0.5` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 服务器 | `192.168.2.212` | `10.0.0.5` |'
- en: 'The Linux hosts are `tinycore-linux` ([http://tinycorelinux.net/](http://tinycorelinux.net/))
    migrated from previous versions of VIRL. The default username and password are
    both `cisco`. If we need to change the interface IP and default gateways, they
    can be done via the following commands:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 主机是 `tinycore-linux` ([http://tinycorelinux.net/](http://tinycorelinux.net/))，从之前的
    VIRL 版本迁移而来。默认用户名和密码都是 `cisco`。如果我们需要更改接口 IP 和默认网关，可以通过以下命令完成：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The two Ubuntu hosts will be used to generate traffic across the network so
    that we can look at some non-zero counters. The lab file is included in the book’s
    GitHub repository.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用两个 Ubuntu 主机在网络中生成流量，以便我们可以查看一些非零计数器。实验室文件包含在本书的 GitHub 仓库中。
- en: SNMP
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SNMP
- en: SNMP is a standardized protocol used to collect and manage devices. Although
    the standard allows you to use SNMP for device management, in my experience, most
    network administrators prefer to keep SNMP as an information collection mechanism
    only. Since SNMP operates on UDP, which is connectionless, and considering the
    relatively weak security mechanism in versions 1 and 2, making device changes
    via SNMP tends to make network operators uneasy. SNMP version 3 has added cryptographic
    security and new concepts and terminology to the protocol, but how SNMP version
    3 is adapted varies among network device vendors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP 是一种用于收集和管理设备的标准化协议。尽管标准允许您使用 SNMP 进行设备管理，但根据我的经验，大多数网络管理员更喜欢将 SNMP 仅作为信息收集机制。由于
    SNMP 在无连接的 UDP 上运行，并且考虑到版本 1 和 2 中相对较弱的安全机制，通过 SNMP 进行设备更改往往会让网络运营商感到不安。SNMP 版本
    3 在协议中增加了加密安全性和新的概念和术语，但 SNMP 版本 3 的适应方式在不同网络设备供应商之间有所不同。
- en: 'SNMP is widely used in network monitoring and has been around since 1988 as
    part of RFC 1065\. The operations are straightforward, with the network manager
    sending `GET` and `SET` requests toward the device and the device with the SNMP
    agent responding with the information per request. The most widely adopted standard
    is SNMPv2c, defined in RFC 1901 – RFC 1908\. It uses a simple community-based
    security scheme for security. It has also introduced new features, such as the
    ability to get bulk information. The following diagram displays the high-level
    operation for SNMP:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP 在网络监控中被广泛使用，自 1988 年作为 RFC 1065 的一部分以来一直存在。操作简单，网络管理员向设备发送 `GET` 和 `SET`
    请求，具有 SNMP 代理的设备根据请求返回信息。最广泛采用的标准是 SNMPv2c，定义在 RFC 1901 – RFC 1908 中。它使用基于社区的简单安全方案进行安全保护。它还引入了新的功能，例如获取大量信息的能力。以下图表显示了
    SNMP 的高级操作：
- en: '![Diagram  Description automatically generated](img/B18403_07_02.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B18403_07_02.png)'
- en: 'Figure 7.2: SNMP operations'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：SNMP 操作
- en: The information residing in the device is structured in the **management information
    base** (**MIB**). The MIB uses a hierarchical namespace containing an **object
    identifier** (**OID**), which represents the information that can be read and
    fed back to the requester. When we talk about using SNMP to query device information,
    we are talking about using the management station to query the specific OID that
    represents the information we are after. A common OID structure, such as a systems
    and interfaces OID, is shared among vendors. Besides common OID, each vendor can
    also supply an enterprise-level OID specific to them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 设备中驻留的信息以 **管理信息库**（**MIB**）的结构化形式存在。MIB 使用包含 **对象标识符**（**OID**）的分层命名空间，它代表可以读取并反馈给请求者的信息。当我们谈论使用
    SNMP 查询设备信息时，我们是在谈论使用管理站查询代表我们所需信息的特定 OID。一个常见的 OID 结构，如系统和接口 OID，在供应商之间是共享的。除了常见的
    OID，每个供应商还可以提供针对他们自己的企业级 OID。
- en: As an operator, we must put some effort into consolidating information into
    an OID structure in our environment to retrieve useful information. This can sometimes
    be a tedious process of finding one OID at a time. For example, you might be requesting
    a device OID and receive a value of 10,000\. What is that value? Is that interface
    traffic? Is it in bytes or bits? Or maybe it represents the number of packets?
    How do we know? We will need to consult either the standard or the vendor documentation
    to find out. There are tools that help with this process, such as a MIB browser
    that can provide more metadata to the value. But, at least in my experience, constructing
    an SNMP-based monitoring tool for your network can sometimes feel like a cat-and-mouse
    game of trying to find that one missing value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作员，我们必须在我们的环境中投入一些努力，将信息整合到OID结构中，以便检索有用的信息。这有时可能是一个繁琐的过程，一次只找到一个OID。例如，你可能会请求一个设备OID并收到一个值为10,000。这个值是什么？是接口流量吗？是字节还是比特？或者它可能代表数据包的数量？我们怎么知道？我们需要查阅标准或供应商文档来找出答案。有一些工具可以帮助这个过程，例如可以提供更多元数据的MIB浏览器。但至少在我的经验中，为你的网络构建基于SNMP的监控工具有时感觉像是一场猫捉老鼠的游戏，试图找到那个缺失的值。
- en: 'Some of the main points to take away from the operation are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从操作中可以吸取的一些主要观点如下：
- en: 'The implementation relies heavily on the amount of information the device agent
    can provide. This, in turn, relies on how the vendor treats SNMP: as a core feature
    or an added feature.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现高度依赖于设备代理可以提供的信息量。这反过来又取决于供应商如何对待SNMP：作为一个核心功能还是一个附加功能。
- en: SNMP agents generally require CPU cycles from the control plane to return a
    value. Not only is this inefficient for devices with, say, large BGP tables, it
    is also not feasible to use SNMP to query the data at small intervals.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SNMP代理通常需要从控制平面获取CPU周期来返回一个值。这不仅对具有大型BGP表等设备的设备来说效率低下，而且使用SNMP在小间隔内查询数据也是不可行的。
- en: The user needs to know the OID to query the data.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户需要知道OID来查询数据。
- en: Since SNMP has been around for a while, I assume you have some experience with
    it already. Let’s jump directly into package installation and our first SNMP example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SNMP已经存在了一段时间，我假设你已经对它有一些经验了。让我们直接进入包安装和我们的第一个SNMP示例。
- en: Setup
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置
- en: First, let’s ensure we have the SNMP managing device and agent working in our
    setup. The SNMP bundle can be installed on either the hosts (client or server)
    in our lab or the managing device on the management network. As long as the SNMP
    manager has IP reachability to the device and the managed device allows the inbound
    connection, SNMP should work. In production, you should only install the software
    on the management host and only allow SNMP traffic in the control plane.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们确保我们的SNMP管理设备和代理在我们的设置中正常工作。SNMP包可以安装在我们实验室中的主机（客户端或服务器）或管理网络中的管理设备上。只要SNMP管理器对设备有IP可达性，并且被管理设备允许入站连接，SNMP就应该工作。在生产环境中，你应该只在管理主机上安装软件，并且只在控制平面允许SNMP流量。
- en: 'In this lab, we have installed SNMP on both the Ubuntu host on the management
    network and the client host in the lab:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验室中，我们在管理网络上的Ubuntu主机和实验室中的客户端主机上都安装了SNMP：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next step is to turn on and configure the SNMP options on the network devices.
    There are many optional parameters you can configure on the network device, such
    as contact, location, chassis ID, and SNMP packet size. The SNMP configuration
    options are device-specific, and you should check the documentation for the particular
    device. For IOSv devices, we will configure an access list to limit only the desired
    host for querying the device and tying the access list with the SNMP community
    string. In our example, we will use the word `secret` as the read-only community
    string and `permit_snmp` as the access list name:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在网络设备上启用和配置SNMP选项。你可以在网络设备上配置许多可选参数，例如联系人、位置、机架ID和SNMP数据包大小。SNMP配置选项是设备特定的，你应该检查特定设备的文档。对于IOSv设备，我们将配置一个访问列表来限制只允许查询设备的所需主机，并将访问列表与SNMP社区字符串绑定。在我们的示例中，我们将使用单词`secret`作为只读社区字符串，并将`permit_snmp`作为访问列表名称：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The SNMP community string is acting as a shared password between the manager
    and the agent; therefore, it needs to be included any time you want to query the
    device.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP社区字符串充当管理器和代理之间的共享密码；因此，每次你想查询设备时都需要包含它。
- en: As mentioned earlier in this chapter, finding the right OID is oftentimes half
    of the battle when working with SNMP. We can use tools such as Cisco SNMP Object
    Navigator ([https://snmp.cloudapps.cisco.com/Support/SNMP/do/BrowseOID.do?local=en](https://cloudsso.cisco.com/as/authorization.oauth2?response_type=code&code_challenge=ngEnA4XYgjNQYcrfs1YqSc5DMFgNzZ7gqLljZkt7gnY&code_challenge_method=S256&client_id=wam_prod_ac&redirect_uri=https%3A%2F%2Fsnmp.cloudapps.cisco.com%2Fpa%2Foidc%2Fcb&state=eyJ6aXAiOiJERUYiLCJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2Iiwia2lkIjoiRUU2UUxudnVkSm1OMmVaYUpxcHhXNy02SWI4Iiwic3VmZml4IjoiVU5ZRU9NLjE2NzM2MDI1NjgifQ..TUfcVL2mjdqQ8HCH_OkAcw.3VfzJObgb7ak5DdJQGzP4H6DPuQCfDTez1jSiP9r9h3iJLDUbipZ7wsoGmEHWW8pfRngsJ9tCWdpPOsu3YtmUe-JBeUxD91Z0H4lb17SU0kIlM-cVuwRylmF3nYZiIM0UVVvX4b4mJPUqTOjYbM-ZQFOPhfuZDSh6gVGkXOYQf0REPvaD38pxhntp12igJod.vH_7zysxoaMerV1XEUYU3w&nonce=J2Cc7sHznKF_at2Ghrf8z63yUIh0FIjvrIY5h7kIoys&acr_values=stdnomfa&scope=openid%20profile%20address%20email%20phone&vnd_pi_requested_resource=https%3A%2F%2Fsnmp.cloudapps.cisco.com%2FSupport%2FSNMP%2Fdo%2FBrowseOID.do%3Flocal%3Den&vnd_pi_application_name=CAEAXprod-snmp.cloudapps))
    to find specific OIDs to query.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，在处理 SNMP 时，找到正确的 OID 往往是战斗的一半。我们可以使用像 Cisco SNMP Object Navigator ([https://snmp.cloudapps.cisco.com/Support/SNMP/do/BrowseOID.do?local=en](https://cloudsso.cisco.com/as/authorization.oauth2?response_type=code&code_challenge=ngEnA4XYgjNQYcrfs1YqSc5DMFgNzZ7gqLljZkt7gnY&code_challenge_method=S256&client_id=wam_prod_ac&redirect_uri=https%3A%2F%2Fsnmp.cloudapps.cisco.com%2Fpa%2Foidc%2Fcb&state=eyJ6aXAiOiJERUYiLCJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2Iiwia2lkIjoiRUU2UUxudnVkSm1OMmVaYUpxcHhXNy02SWI4Iiwic3VmZml4IjoiVU5ZRU9NLjE2NzM2MDI1NjgifQ..TUfcVL2mjdqQ8HCH_OkAcw.3VfzJObgb7ak5DdJQGzP4H6DPuQCfDTez1jSiP9r9h3iJLDUbipZ7wsoGmEHWW8pfRngsJ9tCWdpPOsu3YtmUe-JBeUxD91Z0H4lb17SU0kIlM-cVuwRylmF3nYZiIM0UVVvX4b4mJPUqTOjYbM-ZQFOPhfuZDSh6gVGkXOYQf0REPvaD38pxhntp12igJod.vH_7zysxoaMerV1XEUYU3w&nonce=J2Cc7sHznKF_at2Ghrf8z63yUIh0FIjvrIY5h7kIoys&acr_values=stdnomfa&scope=openid%20profile%20address%20email%20phone&vnd_pi_requested_resource=https%3A%2F%2Fsnmp.cloudapps.cisco.com%2FSupport%2FSNMP%2Fdo%2FBrowseOID.do%3Flocal%3Den&vnd_pi_application_name=CAEAXprod-snmp.cloudapps))
    这样的工具来查找特定的 OID 以进行查询。
- en: 'Alternatively, we can just start walking through the SNMP tree, starting from
    the top of Cisco’s enterprise tree at `.1.3.6.1.4.1.9`. We will perform the walk
    to make sure that the SNMP agent and the access list are working:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以从 Cisco 企业树的顶部 `.1.3.6.1.4.1.9` 开始遍历 SNMP 树。我们将执行遍历以确保 SNMP 代理和访问列表正常工作：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can be more specific about the OID we need to query as well:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对需要查询的 OID 进行更具体的说明：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As a matter of demonstration, what if we type in the wrong value by `1` digit,
    from `0` to `1` at the end of the last OID? This is what we would see:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为演示，如果我们输入错误值，错误值比最后 OID 的 `0` 到 `1` 多 `1` 位，我们会看到什么：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Unlike API calls, there are no useful error codes or messages; it simply states
    that the OID does not exist. This can be pretty frustrating at times.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与 API 调用不同，没有有用的错误代码或消息；它只是简单地声明该 OID 不存在。有时这可能会非常令人沮丧。
- en: 'The last thing to check would be that the access list we configured will deny
    unwanted SNMP queries. Because we had the log keyword for both the `permit` and
    `deny` entries in the access list, only `172.16.1.123` is permitted to query the
    devices:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要检查的是，我们配置的访问列表是否会拒绝不想要的 SNMP 查询。因为我们已经在访问列表的 `permit` 和 `deny` 条目中使用了日志关键字，所以只有
    `172.16.1.123` 被允许查询设备：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the biggest challenge in setting up SNMP is finding the right
    OID. Some OIDs are defined in standardized MIB-2; others are under the enterprise
    portion of the tree. Vendor documentation is the best bet, though. Some tools
    can help, such as a MIB browser; you can add MIBs (again, provided by the vendors)
    to the browser and see the description of the enterprise-based OIDs. A tool such
    as Cisco’s SNMP Object Navigator ([http://snmp.cloudapps.cisco.com/Support/SNMP/do/BrowseOID.do?local=en](http://snmp.cloudapps.cisco.com/Support/SNMP/do/BrowseOID.do?local=en))
    proves to be very valuable when you need to find the correct OID of the object
    you are looking for.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，设置 SNMP 最大的挑战在于找到正确的 OID。一些 OID 定义在标准化的 MIB-2 中；其他则位于树的企业部分。尽管如此，供应商的文档仍然是最佳选择。一些工具可以帮助，例如
    MIB 浏览器；您可以将 MIB（同样由供应商提供）添加到浏览器中，并查看基于企业的 OID 描述。当您需要找到所需对象的正确 OID 时，像 Cisco
    的 SNMP Object Navigator ([http://snmp.cloudapps.cisco.com/Support/SNMP/do/BrowseOID.do?local=en](http://snmp.cloudapps.cisco.com/Support/SNMP/do/BrowseOID.do?local=en))
    这样的工具证明非常有价值。
- en: PySNMP
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PySNMP
- en: PySNMP is a cross-platform, pure Python SNMP engine implementation developed
    by Ilya Etingof ([https://github.com/etingof](https://github.com/etingof)). It
    abstracts a lot of SNMP details for you, as great libraries do, and supports both
    Python 2 and Python 3.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: PySNMP 是由 Ilya Etingof ([https://github.com/etingof](https://github.com/etingof))
    开发的跨平台、纯 Python SNMP 引擎实现。它为您抽象了许多 SNMP 细节，就像优秀的库一样，并支持 Python 2 和 Python 3。
- en: 'PySNMP requires the PyASN1 package. The following is taken from Wikipedia:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: PySNMP需要PyASN1包。以下内容摘自维基百科：
- en: ”ASN.1 is a standard and notation that describes rules and structures for representing,
    encoding, transmitting, and decoding data in telecommunication and computer networking.”
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “ASN.1是一种标准和表示法，它描述了在电信和计算机网络中表示、编码、传输和解析数据时的规则和结构。”
- en: 'PyASN1 conveniently provides a Python wrapper around ASN.1\. Let’s install
    the package first. Note that since we are using a virtual environment, we will
    use the virtual environment’s Python interpreter:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: PyASN1方便地为ASN.1提供了Python包装器。让我们首先安装这个包。注意，由于我们使用的是虚拟环境，我们将使用虚拟环境的Python解释器：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, install the PySNMP package:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装PySNMP包：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are using an older version of PySNMP due to the fact that `pysnmp.entity.rfc3413.oneliner`
    was removed starting with version 5.0.0 ([https://github.com/etingof/pysnmp/blob/a93241007b970c458a0233c16ae2ef82dc107290/CHANGES.txt](https://github.com/etingof/pysnmp/blob/a93241007b970c458a0233c16ae2ef82dc107290/CHANGES.txt)).
    If you use `pip` to install the packages, the examples will probably break.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用PySNMP的较旧版本，因为从5.0.0版本开始移除了`pysnmp.entity.rfc3413.oneliner`（[https://github.com/etingof/pysnmp/blob/a93241007b970c458a0233c16ae2ef82dc107290/CHANGES.txt](https://github.com/etingof/pysnmp/blob/a93241007b970c458a0233c16ae2ef82dc107290/CHANGES.txt)）。如果你使用`pip`安装包，示例可能会出错。
- en: 'Let’s look at how to use PySNMP to query the same Cisco contact information
    we used in the previous example. We will import the necessary module and create
    a `CommandGenerator` object first:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用PySNMP查询之前示例中使用的相同思科联系信息。我们首先导入必要的模块并创建一个`CommandGenerator`对象：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can perform SNMP using the `getCmd` method. The result is unpacked into
    various variables; of these, we care most about `varBinds`, which contains the
    query result:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`getCmd`方法执行SNMP。结果被解包到各种变量中；在这些变量中，我们最关心的是`varBinds`，它包含查询结果：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the response values are PyASN1 objects. The `prettyPrint()` method
    will convert some of these values into a human-readable format, but the result
    in our return variable was not converted. We converted it into a string manually.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，响应值是PyASN1对象。`prettyPrint()`方法将转换一些这些值到可读的格式，但我们的返回变量中的结果没有被转换。我们手动将其转换为字符串。
- en: 'We can write a script based on the preceding interactive example. We will name
    it `pysnmp_1.py` with error checking. We can also include multiple OIDs in the
    `getCmd()` method:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以基于前面的交互示例编写一个脚本。我们将命名为`pysnmp_1.py`并包含错误检查。我们还可以在`getCmd()`方法中包含多个OID：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result will be unpacked and list the values of the two OIDs:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将被解包并列出两个OID的值：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the following example, we will persist the values we received from the queries
    to perform other functions, such as visualization, with the data. For our example,
    we will use `ifEntry` within the MIB-2 tree for interface-related values to be
    graphed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将持久化我们从查询中接收到的值，以便使用数据进行其他操作，例如可视化。在我们的示例中，我们将使用MIB-2树中的`ifEntry`来获取与接口相关的值进行绘图。
- en: 'You can find a number of resources that map out the `ifEntry` tree; here is
    a screenshot of the Cisco SNMP Object Navigator site that we accessed previously
    for `ifEntry`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以找到许多映射`ifEntry`树的资源；以下是我们在之前访问的思科SNMP对象导航器网站的截图：
- en: '![A picture containing text  Description automatically generated](img/B18403_07_03.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片 自动生成描述](img/B18403_07_03.png)'
- en: 'Figure 7.3: SNMP ifEntry OID tree'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：SNMP ifEntry OID树
- en: 'A quick test will illustrate the OID mapping of the interfaces on the device:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 快速测试将展示设备上接口的OID映射：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From the documentation, we can map the values of `ifInOctets(10)`, `ifInUcastPkts(11)`,
    `ifOutOctets(16)`, and `ifOutUcastPkts(17)` into their respective OID values.
    From a quick check of the CLI and MIB documentation, we can see that the value
    of the `GigabitEthernet0/0` packets output maps to OID `1.3.6.1.2.1.2.2.1.17.1`.
    We will follow the rest of the same process to map out the rest of the OIDs for
    the interface statistics. When checking between the CLI and SNMP, keep in mind
    that the values should be close but not the same since there might be some traffic
    on the wire between the time of the CLI output and the SNMP query time:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从文档中，我们可以将`ifInOctets(10)`、`ifInUcastPkts(11)`、`ifOutOctets(16)`和`ifOutUcastPkts(17)`的值映射到它们各自的OID值。从CLI和MIB文档的快速检查中，我们可以看到`GigabitEthernet0/0`数据包输出的值映射到OID
    `1.3.6.1.2.1.2.2.1.17.1`。我们将遵循相同的流程来映射接口统计信息的其余OID。在CLI和SNMP之间检查时，请注意，值应该接近但不相同，因为CLI输出时间和SNMP查询时间之间可能会有一些流量：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we are in a production environment, we will probably write the results into
    a database. But since this is just an example, we will write the query values
    to a flat file. We will write the `pysnmp_3.py` script for information queries
    and write the results to the file. In the script, we have defined various OIDs
    that we need to query:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于生产环境，我们可能会将结果写入数据库。但既然这是一个例子，我们将把查询值写入一个平面文件。我们将编写`pysnmp_3.py`脚本来进行信息查询并将结果写入文件。在脚本中，我们定义了需要查询的各种OID：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The values were consumed in the `snmp_query()` function, with `host`, `community`,
    and `oid` as input:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 值在`snmp_query()`函数中被消耗，以`host`、`community`和`oid`作为输入：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All of the values are put in a dictionary with various keys and written to
    a file called `results.txt`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所有值都放入一个带有各种键的字典中，并写入一个名为`results.txt`的文件：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The outcome will be a file with results showing the interface packets represented
    at the time of the query:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个文件，显示了查询时表示的接口数据包：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can make this script executable and schedule a `cron` job to be executed
    every 5 minutes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使这个脚本可执行，并安排一个每5分钟执行一次的`cron`作业：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As mentioned previously, in a production environment, we would put the information
    in a database. For a SQL database, you can use a unique ID as the primary key.
    In a NoSQL database, we might use time as the primary index (or key) because it
    is always unique, followed by various key-value pairs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在生产环境中，我们会将信息放入数据库。对于SQL数据库，你可以使用唯一ID作为主键。在NoSQL数据库中，我们可能会使用时间作为主索引（或键），因为它是始终唯一的，后面跟着各种键值对。
- en: We will wait for the script to be executed a few times for the values to be
    populated. If you are the impatient type, you can shorten the `cron` job interval
    to 1 minute. After you see enough values in the `results.txt` file to make an
    interesting graph, we can move on to the next section to see how we can use Python
    to visualize the data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将等待脚本执行几次，以便填充值。如果你是那种没有耐心的人，你可以将`cron`作业间隔缩短到1分钟。在你看到`results.txt`文件中有足够的数据来制作有趣的图表后，我们可以继续到下一部分，看看我们如何使用Python来可视化数据。
- en: Python for Data Visualization
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python数据可视化
- en: We gather network data to gain insight into our network. One of the best ways
    to know what the data means is to visualize it with graphs. This is true for almost
    all data, but especially true for time series data in the context of network monitoring.
    How much data was transmitted over the network in the last week? What is the percentage
    of the TCP protocol among all of the traffic? These are values we can glean from
    using data-gathering mechanisms such as SNMP, and we can produce visualization
    graphs with some of the popular Python libraries.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收集网络数据以深入了解我们的网络。了解数据含义的最好方法之一是使用图表进行可视化。这几乎适用于所有数据，但在网络监控的上下文中，对于时间序列数据来说尤其如此。上周网络传输了多少数据？在所有流量中TCP协议的百分比是多少？这些都是我们可以通过使用如SNMP之类的数据收集机制获得的值，我们可以使用一些流行的Python库生成可视化图表。
- en: In this section, we will use the data we collected from the last section using
    SNMP and use two popular Python libraries, Matplotlib and Pygal, to graph them.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用上一节通过SNMP收集的数据，并使用两个流行的Python库，Matplotlib和Pygal，来绘制它们。
- en: Matplotlib
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Matplotlib
- en: '**Matplotlib** ([http://matplotlib.org/](http://matplotlib.org/)) is a Python
    2D plotting library for the Python language and its NumPy mathematical extension.
    It can produce publication-quality figures, such as plots, histograms, and bar
    graphs, with a few lines of code.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**Matplotlib** ([http://matplotlib.org/](http://matplotlib.org/))是Python语言的2D绘图库及其NumPy数学扩展。它可以用几行代码生成出版物质量的图表，如图表、直方图和条形图。'
- en: NumPy is an extension of the Python programming language. It is open source
    and widely used in various data science projects. You can learn more about it
    at [https://en.wikipedia.org/wiki/NumPy](https://en.wikipedia.org/wiki/NumPy).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy是Python编程语言的扩展。它是开源的，在各种数据科学项目中广泛使用。你可以在[https://en.wikipedia.org/wiki/NumPy](https://en.wikipedia.org/wiki/NumPy)了解更多关于它的信息。
- en: Let’s begin with the installation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装开始。
- en: Installation
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装
- en: 'The installation can be done using the Linux package management system for
    the distribution or Python `pip`. In the latest version of Matplotlib, we will
    also install `python3-tk` for display:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 安装可以通过Linux发行版的包管理系统或Python `pip`来完成。在Matplotlib的最新版本中，我们还将安装`python3-tk`以进行显示：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, let’s get into our first example.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入我们的第一个例子。
- en: Matplotlib – the first example
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Matplotlib – 第一个例子
- en: For the following examples, the output figures are displayed as the standard
    output by default. Typically, the standard output is your monitor screen. During
    development, it is often easier to try out the code initially and produce the
    graph on the standard output first before finalizing the code with a script. If
    you have been following along with this book via a virtual machine, it is recommended
    that you use the VM window instead of SSH so that you can see the graphs. If you
    do not have access to the standard output, you can save the figure and view it
    after downloading it (as you will see soon). Note that you will need to set the
    `$DISPLAY` variable in some of the graphs we produce in this section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下示例，默认情况下输出图形以标准输出形式显示。通常，标准输出是你的显示器屏幕。在开发过程中，通常更容易先尝试代码并首先在标准输出上生成图形，然后再用脚本最终确定代码。如果你通过虚拟机跟随这本书，建议你使用VM窗口而不是SSH，这样你就可以看到图形。如果你无法访问标准输出，你可以保存图形并在下载后查看（如你将看到的）。请注意，你将需要在某些我们在这个部分生成的图形中设置`$DISPLAY`变量。
- en: 'The following screenshot of the Ubuntu desktop is used in this chapter’s visualization
    example. As soon as the `plt.show()` command is issued in the Terminal window,
    **Figure 1** will appear on the screen. When you close the figure, you will return
    to the Python shell:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本章可视化示例中使用的Ubuntu桌面屏幕截图。一旦在终端窗口中发出`plt.show()`命令，**图1**将出现在屏幕上。当你关闭图形时，你将返回到Python
    shell：
- en: '![A screenshot of a computer  Description automatically generated](img/B18403_07_04.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B18403_07_04.png)'
- en: 'Figure 7.4: Matplotlib visualization with the Ubuntu desktop'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：使用Ubuntu桌面的Matplotlib可视化
- en: 'Let’s look at the line graph first. A line graph simply gives two lists of
    numbers that correspond to the *x*-axis and *y*-axis values:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看折线图。折线图简单地给出两组数字，分别对应于*x*轴和*y*轴的值：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The graph will be a line graph:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图形将是一个折线图：
- en: '![Graphical user interface, chart, line chart  Description automatically generated](img/B18403_07_05.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，图表，折线图  自动生成的描述](img/B18403_07_05.png)'
- en: 'Figure 7.5: Matplotlib line graph'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：Matplotlib折线图
- en: 'Alternatively, if you do not have access to standard output or have saved the
    figure first, you can use the `savefig()` method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你无法访问标准输出或已先保存图形，你可以使用`savefig()`方法：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With this basic knowledge of graphing plots, we can now graph the results we
    receive from SNMP queries.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了基本的绘图知识后，我们现在可以绘制从SNMP查询中获得的结果。
- en: Matplotlib for SNMP results
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Matplotlib用于SNMP结果
- en: In our first Matplotlib example, `matplotlib_1.py`, we will import the `dates`
    module besides `pyplot`. We will use the `matplotlib.dates` module instead of
    the Python standard library `dates` module.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个Matplotlib示例`matplotlib_1.py`中，我们将导入`pyplot`模块的同时导入`dates`模块。我们将使用`matplotlib.dates`模块而不是Python标准库中的`dates`模块。
- en: 'Unlike the Python `dates` module, the `matplotlib.dates` library will convert
    the date value internally into a float type, which is required by Matplotlib:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python的`dates`模块不同，`matplotlib.dates`库将内部将日期值转换为浮点类型，这是Matplotlib所要求的：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Matplotlib provides sophisticated date plotting capabilities; you can find more
    information on this at [https://matplotlib.org/stable/api/dates_api.html](https://matplotlib.org/stable/api/dates_api.html).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib提供了复杂的日期绘图功能；你可以在[https://matplotlib.org/stable/api/dates_api.html](https://matplotlib.org/stable/api/dates_api.html)找到更多相关信息。
- en: 'In the script, we will create two empty lists, each representing the *x*-axis
    and *y*-axis values. Note that on line 12, we used the built-in `eval()` Python
    function to read the input as a dictionary instead of a default string:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我们将创建两个空列表，每个列表代表*x*轴和*y*轴的值。请注意，在第12行，我们使用了内置的`eval()`Python函数将输入读取为字典而不是默认字符串：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In order to read the *x*-axis value back in a human-readable date format, we
    will need to use the `plot_date()` function instead of `plot()`. We will also
    tweak the size of the figure a bit, as well as rotate the value on the *x*-axis
    so that we can read the value in full:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以人类可读的日期格式读取*x*轴值，我们需要使用`plot_date()`函数而不是`plot()`函数。我们还将稍微调整图形的大小，以及旋转*x*轴上的值，以便我们可以完整地读取值：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The final result will display the **Router1 G0/0** and **Output Unicast Packets**,
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果将显示**Router1 G0/0**和**输出单播数据包**，如下所示：
- en: '![Graphical user interface, chart, line chart  Description automatically generated](img/B18403_07_06.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，图表，折线图  自动生成的描述](img/B18403_07_06.png)'
- en: 'Figure 7.6: Router1 Matplotlib graph'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：Router1 Matplotlib图表
- en: 'Note that if you prefer a straight line instead of dots, you can use the third
    optional parameter in the `plot_date()` function:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你更喜欢直线而不是点，你可以在`plot_date()`函数的第三个可选参数中使用：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can repeat the steps for the rest of the values for output octets, input
    unicast packets, and input as individual graphs. However, in our next example,
    that is, `matplotlib_2.py`, we will show you how to graph multiple values against
    the same time range, as well as additional Matplotlib options.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重复这些步骤来输出输出八位字节、输入单播数据包和输入作为单独的图表的其余值。然而，在我们的下一个例子，即`matplotlib_2.py`中，我们将向您展示如何将多个值与相同的时间范围进行绘图，以及额外的Matplotlib选项。
- en: 'In this case, we will create additional lists and populate the values accordingly:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建额外的列表并相应地填充值：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since we have identical *x*-axis values, we can just add the different *y*-axis
    values to the same graph:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的*x*轴值相同，我们只需将不同的*y*轴值添加到同一个图表中：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Also, add `grid` and `legend` to the graph:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将`grid`和`legend`添加到图表中：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The final result will combine all of the values in a single graph. Note that
    some of the values in the upper-left corner are blocked by the legend. You can
    resize the figure and/or use the pan/zoom option to move around the graph to see
    the values:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果将结合单个图表中的所有值。请注意，左上角的一些值被图例遮挡。你可以调整图表大小和/或使用平移/缩放选项来移动图表以查看这些值：
- en: '![Graphical user interface, application, table  Description automatically generated](img/B18403_07_07.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、应用程序、表格  自动生成描述](img/B18403_07_07.png)'
- en: 'Figure 7.7: Router1 – Matplotlib multiline graph'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：Router1 – Matplotlib多行图
- en: 'There are many more graphing options available in Matplotlib; we are certainly
    not limited to plot graphs. For example, in `matplotlib_3.py`, we can use the
    following mock data to graph the percentage of different traffic types that we
    can see on the wire:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib提供了许多更多的绘图选项；我们当然不仅限于绘制图表。例如，在`matplotlib_3.py`中，我们可以使用以下模拟数据来绘制我们可以在线缆上看到的不同流量类型的百分比：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code leads to this pie chart from `plt.show()`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码导致`plt.show()`生成了以下饼图：
- en: '![Chart, pie chart  Description automatically generated](img/B18403_07_08.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图表、饼图  自动生成描述](img/B18403_07_08.png)'
- en: 'Figure 7.8: Matplotlib pie chart'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：Matplotlib饼图
- en: In this section, we have used Matplotlib to graph our network data into more
    visually appealing graphs to help us understand the state of our network. This
    was done with bar graphs, line charts, and pie charts, which are appropriate for
    the data at hand. Matplotlib is a powerful tool that is not limited to Python.
    As an open-source tool, many additional Matplotlib resources can be leveraged
    to learn about the tool.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用了Matplotlib将我们的网络数据绘制成更具有视觉吸引力的图表，以帮助我们理解网络的状态。这是通过条形图、折线图和饼图来完成的，这些图表非常适合手头的数据。Matplotlib是一个强大的工具，不仅限于Python。作为一个开源工具，我们可以利用许多额外的Matplotlib资源来了解这个工具。
- en: Additional Matplotlib resources
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 额外的Matplotlib资源
- en: Matplotlib is one of the best Python plotting libraries, able to produce publication-quality
    figures. Like Python, it aims to make complex tasks simple. With over 10,000 stars
    (and counting) on GitHub, it is also one of the most popular open-source projects.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib是最佳的Python绘图库之一，能够生成出版物质量的图表。像Python一样，它旨在使复杂任务变得简单。在GitHub上有超过10,000颗星（并且还在增加），它也是最受欢迎的开源项目之一。
- en: Its popularity directly translates into faster bug fixes, a friendly user community,
    extensive documentation, and general usability. Using the package has a bit of
    a learning curve, but it is well worth the effort.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它的流行度直接转化为更快的错误修复、友好的用户社区、广泛的文档和通用易用性。使用这个包需要一点学习曲线，但这是值得努力的。
- en: In this section, we barely scratched the surface of Matplotlib. You’ll find
    additional resources at [https://matplotlib.org/stable/index.html](https://matplotlib.org/stable/index.html)
    (the Matplotlib project page) and [https://github.com/matplotlib/matplotlib](https://github.com/matplotlib/matplotlib)
    (the Matplotlib GitHub repository).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们对Matplotlib的探索还只是触及了皮毛。你可以在[https://matplotlib.org/stable/index.html](https://matplotlib.org/stable/index.html)（Matplotlib项目页面）和[https://github.com/matplotlib/matplotlib](https://github.com/matplotlib/matplotlib)（Matplotlib
    GitHub仓库）找到更多资源。
- en: 'In the coming section, we will take a look at another popular Python graph
    library: **Pygal**.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨另一个流行的Python绘图库：**Pygal**。
- en: Pygal
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pygal
- en: Pygal ([https://www.pygal.org/en/stable/](https://www.pygal.org/en/stable/))
    is a dynamic **Scalable Vector Graphics** (**SVG**) charting library written in
    Python. The biggest advantage of Pygal, in my opinion, is that it produces write
    SVG graphs easily and natively. There are many advantages of SVG over other graph
    formats. Two of the main advantages are that it is web browser-friendly and it
    provides scalability without sacrificing image quality. In other words, you can
    display the resulting image in any modern web browser and zoom in and out of the
    image without losing the details of the graph. Did I mention that we can do this
    in a few lines of Python code? How cool is that?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Pygal ([https://www.pygal.org/en/stable/](https://www.pygal.org/en/stable/))
    是一个用 Python 编写的动态 **可缩放矢量图形** (**SVG**) 图表库。在我看来，Pygal 的最大优点是它能够轻松地以原生方式生成 SVG
    图表。SVG 相比其他图表格式有许多优点。其中两个主要优点是它对网页浏览器友好，并且在不牺牲图像质量的情况下提供可伸缩性。换句话说，您可以在任何现代网页浏览器中显示生成的图像，并放大和缩小图像而不会丢失图表的细节。我提到过我们可以在几行
    Python 代码中做到这一点吗？这有多酷？
- en: Let’s get Pygal installed, then move on to the first example.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装 Pygal，然后继续第一个示例。
- en: Installation
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装
- en: 'The installation is done via `pip`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 安装是通过 `pip` 完成的：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Pygal – the first example
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pygal – 第一个示例
- en: 'Let’s look at the line chart example demonstrated on Pygal’s documentation,
    available at [http://pygal.org/en/stable/documentation/types/line.html](http://pygal.org/en/stable/documentation/types/line.html):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Pygal 文档中展示的线形图示例，该文档可在 [http://pygal.org/en/stable/documentation/types/line.html](http://pygal.org/en/stable/documentation/types/line.html)
    找到：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, we created a line object with the `x_labels` automatically
    rendered as strings for 11 units. Each of the objects can be added with the label
    and the value in a list format, such as Firefox, Chrome, and IE.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个线对象，`x_labels` 自动渲染为 11 个单位的字符串。每个对象都可以以列表格式添加标签和值，例如 Firefox、Chrome
    和 IE。
- en: The interesting bit to focus on is the fact that each of the line chart items
    has the exact number of matching numbers to the number of x units. When there
    is no value, for example, the years 2002 – 2007 for Chrome, the value **None**
    is entered.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要关注的有意思的一点是，每个线形图项都有与 x 单位数量完全匹配的匹配数字。例如，如果没有值，例如 Chrome 的 2002-2007 年，则输入
    **None**。
- en: 'Here’s the resulting graph, as viewed in the Firefox browser:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Firefox 浏览器中查看的结果图，如下所示：
- en: '![Chart, line chart  Description automatically generated](img/B18403_07_09.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图表，线形图描述自动生成](img/B18403_07_09.png)'
- en: 'Figure 7.9: Pygal sample graph'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9：Pygal 示例图表
- en: Now that we can see the general usage of Pygal, we can use the same method to
    graph the SNMP results we have in hand. We will do this in the coming section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了 Pygal 的一般用法，我们可以使用相同的方法来绘制我们手头的 SNMP 结果。我们将在下一节中这样做。
- en: Pygal for SNMP results
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pygal SNMP 结果
- en: 'For the Pygal line graph, we can largely follow the same pattern as our Matplotlib
    example, where we create lists of values by reading the file. We no longer need
    to convert the *x*-axis value into an internal float, as we did for Matplotlib;
    however, we do need to convert the numbers in each of the values we would have
    received into float:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Pygal 线形图，我们可以很大程度上遵循我们 Matplotlib 示例中的相同模式，即通过读取文件创建值列表。我们不再需要将 *x*-轴值转换为内部浮点数，就像我们为
    Matplotlib 做的那样；然而，我们需要将每个值中的数字转换为浮点数：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can use the same mechanism that we saw to construct the line graph:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们之前看到用来构建线图的相同机制：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The outcome is similar to what we have already seen, but the graph is now in
    an SVG format that can be easily displayed on a web page. It can be viewed in
    a modern web browser:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与我们已经看到的结果相似，但现在图表是以 SVG 格式呈现的，可以在网页上轻松显示。它可以在现代网页浏览器中查看：
- en: '![Table  Description automatically generated](img/B18403_07_10.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![表格描述自动生成](img/B18403_07_10.png)'
- en: 'Figure 7.10: Router 1— Pygal multiline graph'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10：路由器 1— Pygal 多行图
- en: 'Just like Matplotlib, Pygal provides many more options for graphs. For example,
    to graph the pie chart we saw previously in Matplotlib, we can use the `pygal.Pie()`
    object. This is shown in `pygal_2.py`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Matplotlib 一样，Pygal 为图表提供了更多选项。例如，为了在 Matplotlib 中绘制我们之前看到的饼图，我们可以使用 `pygal.Pie()`
    对象。这可以在 `pygal_2.py` 中看到：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The resulting SVG file is shown here:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 SVG 文件如下所示：
- en: '![Chart, pie chart  Description automatically generated](img/B18403_07_11.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图表，饼图描述自动生成](img/B18403_07_11.png)'
- en: 'Figure 7.11: Pygal pie chart'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11：Pygal 饼图
- en: Pygal is a great tool when it comes to generating production-ready SVG graphs.
    If this is the type of graph required, look no further than the Pygal library.
    In this section, we have examined examples of using Pygal to generate graphs for
    our network data. Similar to Matplotlib, there are many additional resources to
    help us to learn about Pygal if you’re interested.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要生成生产就绪的SVG图形时，Pygal是一个伟大的工具。如果需要这种类型的图形，无需寻找其他库，只需查看Pygal库。在本节中，我们检查了使用Pygal生成网络数据图形的示例。类似于Matplotlib，如果你对Pygal感兴趣，有许多额外的资源可以帮助你学习。
- en: Additional Pygal resources
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 额外的Pygal资源
- en: 'Pygal provides many more customizable features and graphing capabilities for
    the data you collect from basic network monitoring tools such as SNMP. We demonstrated
    a simple line graph and pie graph in this section. You can find more information
    about the project here:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Pygal为从基本的网络监控工具（如SNMP）收集的数据提供了许多更多可定制的功能和绘图能力。在本节中，我们演示了简单的折线图和饼图。你可以在以下链接中找到更多关于这个项目的信息：
- en: '**Pygal documentation**: [http://www.pygal.org/en/stable/index.html](http://www.pygal.org/en/stable/index.html)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pygal文档**：[http://www.pygal.org/en/stable/index.html](http://www.pygal.org/en/stable/index.html)'
- en: '**Pygal GitHub project page**: [https://github.com/Kozea/pygal](https://github.com/Kozea/pygal)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pygal GitHub项目页面**：[https://github.com/Kozea/pygal](https://github.com/Kozea/pygal)'
- en: In the coming section, we will continue with the SNMP theme of network monitoring
    but with a fully featured network monitoring system called **Cacti**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将继续探讨网络监控的SNMP主题，但将使用一个功能齐全的网络监控系统，称为**Cacti**。
- en: Python for Cacti
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cacti的Python
- en: In my early days as a junior network engineer at a regional ISP, we used the
    open-source cross-platform **Multi Router Traffic Grapher** (**MRTG**) ([https://en.wikipedia.org/wiki/Multi_Router_Traffic_Grapher](https://en.wikipedia.org/wiki/Multi_Router_Traffic_Grapher))
    tool to check the traffic load on network links. We relied on the tool almost
    exclusively for traffic monitoring. I was amazed at how good and useful an open-source
    project could be. It was one of the first open-source high-level network monitoring
    systems that abstracted the details of SNMP, the database, and HTML for network
    engineers. Then came the **round-robin database tool** (**RRDtool**) ([https://en.wikipedia.org/wiki/RRDtool](https://en.wikipedia.org/wiki/RRDtool)).
    In its first release in 1999, it was referred to as “MRTG Done Right.” It greatly
    improved the database and poller performance in the backend.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我作为地区ISP的初级网络工程师的早期日子里，我们使用开源的跨平台**多路由流量图器**（**MRTG**）（[https://en.wikipedia.org/wiki/Multi_Router_Traffic_Grapher](https://en.wikipedia.org/wiki/Multi_Router_Traffic_Grapher)）工具来检查网络链路上的流量负载。我们几乎完全依赖这个工具进行流量监控。我对一个开源项目能如此出色和有用感到惊讶。它是第一个为网络工程师抽象SNMP、数据库和HTML细节的开源高级网络监控系统之一。随后出现了**循环冗余检测数据库工具**（**RRDtool**）（[https://en.wikipedia.org/wiki/RRDtool](https://en.wikipedia.org/wiki/RRDtool)）。在1999年的首次发布中，它被称为“MRTG
    Done Right”。它极大地提高了后端数据库和轮询器的性能。
- en: Released in 2001, Cacti ([https://en.wikipedia.org/wiki/Cacti_(software)](https://en.wikipedia.org/wiki/Cacti_(software)))
    is an open-source web-based network monitoring and graphing tool designed as an
    improved frontend for RRDtool. Because of the heritage of MRTG and RRDtool, you
    will notice a familiar graph layout, templates, and SNMP poller. As a packaged
    tool, the installation and usage will need to stay within the boundary of the
    tool. However, Cacti offers a custom data query feature that we can use Python
    to handle. In this section, we will see how we can use Python as an input method
    for Cacti.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 2001年发布的Cacti ([https://en.wikipedia.org/wiki/Cacti_(software)](https://en.wikipedia.org/wiki/Cacti_(software)))
    是一个开源的基于Web的网络监控和绘图工具，设计为RRDtool的改进前端。由于MRTG和RRDtool的传承，你会注意到熟悉的图形布局、模板和SNMP轮询器。作为一个打包的工具，安装和使用需要保持在工具的边界内。然而，Cacti提供了一个自定义数据查询功能，我们可以使用Python来处理。在本节中，我们将看到如何使用Python作为Cacti的输入方法。
- en: First, we’ll go through the installation process.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍安装过程。
- en: Installation
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: Because Cacti is an all-in-one tool, including web frontend, collection scripts,
    and database backend, unless you already have experience with Cacti, I would recommend
    installing the tool on a standalone VM or a container in our lab. The following
    instructions will be shown for a VM, but a container Dockerfile would be similar.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Cacti是一个包含前端、收集脚本和数据库后端的综合性工具，除非你已经有了Cacti的使用经验，否则我建议在我们的实验室中安装一个独立的虚拟机或容器。以下指令将针对虚拟机进行展示，但容器Dockerfile将类似。
- en: 'Installation on Ubuntu is straightforward when using APT on the Ubuntu management
    VM:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Ubuntu管理虚拟机上的APT时，在Ubuntu上安装是直接的：
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It will trigger a series of installation and setup steps, including the MySQL
    database, web server (Apache or `lighttpd`), and various configuration tasks.
    Once it’s installed, navigate to `http://<ip>/cacti` to get started. The last
    step is to log in with the default username and password (`admin/admin`); you
    will be prompted to change the password.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 它将触发一系列安装和设置步骤，包括MySQL数据库、Web服务器（Apache或`lighttpd`）以及各种配置任务。安装完成后，导航到`http://<ip>/cacti`开始。最后一步是使用默认用户名和密码（`admin/admin`）登录；您将被提示更改密码。
- en: During installation, when in doubt, go with the default option and keep it simple.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中，如果有疑问，请选择默认选项并保持简单。
- en: 'Once logged in, we can follow the documentation to add a device and associate
    it with a template. There is a Cisco router premade template that you can go with.
    Cacti has good documentation at [http://docs.cacti.net/](http://docs.cacti.net/)
    for adding a device and creating your first graph, so we will quickly look at
    some screenshots that you can expect to see:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，我们可以按照文档添加设备并将其与模板关联。Cacti有很好的文档[http://docs.cacti.net/](http://docs.cacti.net/)，用于添加设备和创建您的第一个图表，所以我们将快速查看您可能会看到的截图：
- en: '![Graphical user interface, application  Description automatically generated](img/B18403_07_12.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B18403_07_12.png)'
- en: 'Figure 7.12: Cacti device edit page'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12：Cacti设备编辑页面
- en: 'A sign indicating the SNMP communication is working is when you can see the
    device uptime:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当您可以看到设备运行时间时，这是一个表示SNMP通信正在工作的标志：
- en: '![Text  Description automatically generated](img/B18403_07_13.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18403_07_13.png)'
- en: 'Figure 7.13: Device edit result page'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13：设备编辑结果页面
- en: 'You can add graphs to the device for interface traffic and other statistics:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为设备添加图表以显示接口流量和其他统计数据：
- en: '![Graphical user interface  Description automatically generated](img/B18403_07_14.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面描述自动生成](img/B18403_07_14.png)'
- en: 'Figure 7.14: New graphs for the device'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14：设备的新的图表
- en: 'After some time, you will start seeing traffic, as shown here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间，您将开始看到流量，如图所示：
- en: '![Table  Description automatically generated](img/B18403_07_15.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![表格描述自动生成](img/B18403_07_15.png)'
- en: 'Figure 7.15: 5-minute average graph'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15：5分钟平均图
- en: We are now ready to look at how to use Python scripts to extend Cacti’s data-gathering
    functionality.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备看看如何使用Python脚本来扩展Cacti的数据收集功能。
- en: Python script as an input source
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python脚本作为输入源
- en: 'There are two documents that we should read before we try to use our Python
    script as an input source:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试将Python脚本作为输入源使用之前，我们应该阅读两个文档：
- en: '**Data input methods**: [http://www.cacti.net/downloads/docs/html/data_input_methods.html](http://www.cacti.net/downloads/docs/html/data_input_methods.html
    )'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据输入方法**：[http://www.cacti.net/downloads/docs/html/data_input_methods.html](http://www.cacti.net/downloads/docs/html/data_input_methods.html)'
- en: '**Making your scripts work with Cacti**: [http://www.cacti.net/downloads/docs/html/making_scripts_work_with_cacti.html](http://www.cacti.net/downloads/docs/html/making_scripts_work_with_cacti.html)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使脚本与Cacti协同工作**：[http://www.cacti.net/downloads/docs/html/making_scripts_work_with_cacti.html](http://www.cacti.net/downloads/docs/html/making_scripts_work_with_cacti.html)'
- en: You might wonder what the use cases are for using a Python script as an extension
    for data inputs. One of the use cases would be to provide monitoring to resources
    that do not have a corresponding OID, for example, if we would like to know how
    to graph how many times the access list `permit_snmp` has allowed the host `172.16.1.173`
    to conduct an SNMP query.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道使用Python脚本作为数据输入扩展的使用场景。其中一个使用场景是为没有相应OID的资源提供监控，例如，如果我们想知道如何绘制访问列表`permit_snmp`允许主机`172.16.1.173`进行SNMP查询的次数。
- en: The example assumes the SNMP station is at IP `172.16.1.173`; please substitute
    the IP for the current lab management station IP.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例假设SNMP站点的IP地址为`172.16.1.173`；请将IP地址替换为当前实验室管理站点的IP地址。
- en: 'We know we can see the number of matches via the CLI:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们可以通过CLI看到匹配的数量：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: However, the chances are there are no OIDs associated with this value (or we
    can just pretend that there are none). This is where we can use an external script
    to produce an output that can be consumed by the Cacti host.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，很可能是没有OID与这个值相关联（或者我们假装没有）。这就是我们可以使用外部脚本来生成可以被Cacti主机消费的输出的地方。
- en: 'We can reuse the Pexpect script we discussed in *Chapter 2*, *Low-Level Network
    Device Interactions*, `chapter1_1.py`. We will rename it `cacti_1.py`. Everything
    should be the same as the original script, except that we will execute the CLI
    command and save the output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用第2章中讨论的Pexpect脚本，`chapter1_1.py`。我们将将其重命名为`cacti_1.py`。除了我们将执行CLI命令并保存输出之外，一切都应该与原始脚本相同：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output in its raw form will appear as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 其原始输出将如下所示：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will use the `split()` function for the string to only leave the number
    of matches and print them out on standard output in the script:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在脚本中使用`split()`函数对字符串进行处理，只留下匹配的数量，并在脚本中将它们打印到标准输出：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To test this, we can see the number of increments by executing the script a
    number of times:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们可以通过多次执行脚本来查看增加的数量：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can make the script executable and put it into the default Cacti script
    location:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使脚本可执行，并将其放入默认的Cacti脚本位置：
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The Cacti documentation, available at [http://www.cacti.net/downloads/docs/html/how_to.html](http://www.cacti.net/downloads/docs/html/how_to.html),
    provides detailed steps on how to add the script result to the output graph.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Cacti文档，可在[http://www.cacti.net/downloads/docs/html/how_to.html](http://www.cacti.net/downloads/docs/html/how_to.html)找到，提供了如何将脚本结果添加到输出图的详细步骤。
- en: 'These steps include adding the script as a data input method, adding the input
    method to a data source, and then creating a graph to be viewed:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤包括将脚本作为数据输入方法添加，将输入方法添加到数据源，然后创建一个可查看的图表：
- en: '![Graphical user interface  Description automatically generated](img/B18403_07_16.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面 自动生成的描述](img/B18403_07_16.png)'
- en: 'Figure 7.16: Data input method results page'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16：数据输入方法结果页面
- en: SNMP is a common way to provide network monitoring services to devices. RRDtool
    with Cacti as the frontend provides a good platform for all network devices via
    SNMP. We can also use Python scripts to extend information gathering beyond SNMP.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP是向设备提供网络监控服务的一种常见方式。使用Cacti作为前端，RRDtool为所有网络设备提供了一个良好的SNMP平台。我们还可以使用Python脚本来扩展超出SNMP的信息收集。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored ways to perform network monitoring via SNMP. We
    configured SNMP-related commands on network devices and used our network management
    VM with an SNMP poller to query the devices. We used the PySNMP module to simplify
    and automate our SNMP queries. We also learned how to save the query results in
    a flat file or database to be used for future examples.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了通过SNMP执行网络监控的方法。我们在网络设备上配置了与SNMP相关的命令，并使用我们的带有SNMP轮询器的网络管理VM来查询设备。我们使用了PySNMP模块来简化并自动化我们的SNMP查询。我们还学习了如何将查询结果保存到平面文件或数据库中，以供未来示例使用。
- en: Later in this chapter, we used two different Python visualization packages,
    Matplotlib and Pygal, to graph SNMP results. Each package has its distinct advantages.
    Matplotlib is a mature, feature-rich library widely used in data science projects.
    Pygal can natively generate SVG-format graphs that are flexible and web-friendly.
    We saw how to generate line and pie graphs relevant to network monitoring.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们使用了两个不同的Python可视化包，Matplotlib和Pygal，来绘制SNMP结果。每个包都有其独特的优势。Matplotlib是一个成熟、功能丰富的库，在数据科学项目中广泛使用。Pygal可以原生生成SVG格式的图表，这些图表灵活且适合网页。我们看到了如何生成与网络监控相关的折线图和饼图。
- en: Toward the end of this chapter, we looked at an all-inclusive network monitoring
    tool named Cacti. It primarily uses SNMP for network monitoring, but we saw how
    we could use Python scripts as an input source to extend the platform’s monitoring
    capabilities when SNMP OID is not available on the remote host.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的末尾，我们查看了一个名为Cacti的全能网络监控工具。它主要使用SNMP进行网络监控，但我们看到了如何使用Python脚本作为输入源来扩展平台监控能力，当远程主机上没有SNMP
    OID时。
- en: In *Chapter 8*, *Network Monitoring with Python – Part 2*, we will continue
    to discuss the tools we can use to monitor our networks and gain insight into
    whether the network is behaving as expected. We will look at flow-based monitoring
    using NetFlow, sFlow, and IPFIX. We will also use tools such as Graphviz to visualize
    our network topology and detect any topological changes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章，“使用Python进行网络监控（第二部分）”中，我们将继续讨论我们可以用来监控我们的网络并了解网络是否按预期运行的工具。我们将查看基于流量的监控，使用NetFlow、sFlow和IPFIX。我们还将使用Graphviz等工具来可视化我们的网络拓扑并检测任何拓扑变化。
- en: Join our book community
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的书籍社区
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的社区——在这里您可以分享反馈、向作者提问，并了解新版本信息——请扫描下面的二维码：
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
- en: '![](img/QR_Code2903617220506617062.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2903617220506617062.png)'
