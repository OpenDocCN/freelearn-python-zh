["```py\nfile_roots:\n  base:\n    - /srv/salt/\n```", "```py\nfileserver_backend:\n  - roots\n```", "```py\nfileserver_backend:\n  - git\n  - roots\n```", "```py\n'''\nThe backend for serving files from an SFTP account.\n\nTo enable, add ``sftp`` to the :conf_master:`fileserver_backend` option in the\nMaster config file.\n\n.. code-block:: yaml\n\n    fileserver_backend:\n      - sftp\n\nEach environment is configured as a directory inside the SFTP account. The name\nof the directory must match the name of the environment.\n\n.. code-block:: yaml\n\n    sftpfs_host: sftp.example.com\n    sftpfs_port: 22\n    sftpfs_username: larry\n    sftpfs_password: 123pass\n    sftpfs_root: /srv/sftp/salt/\n'''\nimport os\nimport os.path\nimport logging\nimport time\nimport salt.fileserver\nimport salt.utils\nimport salt.syspaths\n\ntry:\n    import fcntl\n    HAS_FCNTL = True\nexcept ImportError:\n    HAS_FCNTL = False\n\ntry:\n    import paramiko\n    from paramiko import AuthenticationException\n    HAS_LIBS = True\nexcept ImportError:\n    HAS_LIBS = False\n\n__virtualname__ = 'sftp'\n\nlog = logging.getLogger()\n\ntransport = None\nclient = None\n\ndef __virtual__():\n    '''\n    Only load if proper conditions are met\n    '''\n    if __virtualname__ not in __opts__['fileserver_backend']:\n        return False\n\n    if not HAS_LIBS:\n        return False\n\n    if __opts__.get('sftpfs_root', None) is None:\n        return False\n\n    global client\n    global transport\n\n    host = __opts__.get('sftpfs_host')\n    port = __opts__.get('sftpfs_port', 22)\n    username = __opts__.get('sftpfs_username')\n    password = __opts__.get('sftpfs_password')\n    try:\n        transport = paramiko.Transport((host, port))\n        transport.connect(username=username, password=password)\n        client = paramiko.SFTPClient.from_transport(transport)\n    except AuthenticationException:\n        return False\n\n    return True\n```", "```py\ndef envs():\n    '''\n    Treat each directory as an environment\n    '''\n    ret = []\n    root = __opts__.get('sftpfs_root')\n    for entry in client.listdir_attr(root):\n        if str(oct(entry.st_mode)).startswith('04'):\n            ret.append(entry.filename)\n    return ret\n```", "```py\ndef file_list(load):\n    '''\n    Return a list of all files on the file server in a specified environment\n    '''\n    root = __opts__.get('sftpfs_root')\n    path = os.path.join(root, load['saltenv'], load['prefix'])\n    return _recur_path(path, load['saltenv'])\n\ndef dir_list(load):\n    '''\n    Return a list of all directories on the master\n    '''\n    root = __opts__.get('sftpfs_root')\n    path = os.path.join(root, load['saltenv'], load['prefix'])\n    return _recur_path(path, load['saltenv'], True)\n\ndef _recur_path(path, saltenv, only_dirs=False):\n    '''\n    Recurse through the remote directory structure\n    '''\n    root = __opts__.get('sftpfs_root')\n    ret = []\n    try:\n        for entry in client.listdir_attr(path):\n            full = os.path.join(path, entry.filename)\n            if str(oct(entry.st_mode)).startswith('04'):\n                ret.append(full)\n                ret.extend(_recur_path(full, saltenv, only_dirs))\n            else:\n                if only_dirs is False:\n                    ret.append(full)\n        return ret\n    except IOError:\n        return []\n```", "```py\n0100755  # This is a file, with 0755 permissions\n040755  # This is a directory, with 0755 permissions\n```", "```py\n{'cmd': '_file_list', 'prefix': '', 'saltenv': 'base'}\n```", "```py\n# salt-call --local cp.list_master\nlocal:\n - testdir\n - testfile\n# salt-call --local cp.list_master_dirs\nlocal:\n - testdir\n\n```", "```py\n'''\ndef find_file(path, saltenv='base', **kwargs):\n    '''\n    Search the environment for the relative path\n    '''\n    fnd = {'path': '',\n           'rel': ''}\n\n    full = os.path.join(salt.syspaths.CACHE_DIR, 'sftpfs', saltenv, path)\n\n    if os.path.isfile(full) and not salt.fileserver.is_file_ignored(__opts__, full):\n        fnd['path'] = full\n        fnd['rel'] = path\n\n    return fnd\n```", "```py\ndef serve_file(load, fnd):\n    '''\n    Return a chunk from a file based on the data received\n    '''\n    ret = {'data': '',\n           'dest': ''}\n\n    if 'path' not in load or 'loc' not in load or 'saltenv' not in load:\n        return ret\n\n    if not fnd['path']:\n        return ret\n\n    ret['dest'] = fnd['rel']\n    gzip = load.get('gzip', None)\n\n    full = os.path.join(salt.syspaths.CACHE_DIR, 'sftpfs', fnd['path'])\n\n    with salt.utils.fopen(fnd['path'], 'rb') as fp_:\n        fp_.seek(load['loc'])\n        data = fp_.read(__opts__['file_buffer_size'])\n        if gzip and data:\n            data = salt.utils.gzip_util.compress(data, gzip)\n            ret['gzip'] = gzip\n        ret['data'] = data\n    return ret\n```", "```py\n# salt-call --local cp.get_file salt://testfile /tmp/testfile\nlocal:\n /tmp/testfile\n\n```", "```py\ndef update():\n    '''\n    Update the cache, and reap old entries\n    '''\n    base_dir = os.path.join(salt.syspaths.CACHE_DIR, 'sftpfs')\n    if not os.path.isdir(base_dir):\n        os.makedirs(base_dir)\n\n    try:\n        salt.fileserver.reap_fileserver_cache_dir(\n            os.path.join(base_dir, 'hash'),\n            find_file\n        )\n    except (IOError, OSError):\n        # Hash file won't exist if no files have yet been served up\n        pass\n\n    # Find out what the latest file is, so that we only update files more\n    # recent than that, and not the entire filesystem\n    if os.listdir(base_dir):\n        all_files = []\n        for root, subFolders, files in os.walk(base_dir):\n            for fn_ in files:\n                full_path = os.path.join(root, fn_)\n                all_files.append([\n                    os.path.getmtime(full_path),\n                    full_path,\n                ])\n\n    # Pull in any files that have changed\n    for env in envs():\n        path = os.path.join(__opts__['sftpfs_root'], env)\n        result = client.listdir_attr(path)\n        for fileobj in result:\n            file_name = os.path.join(base_dir, env, fileobj.filename)\n\n            # Make sure the directory exists first\n            comps = file_name.split('/')\n            file_path = '/'.join(comps[:-1])\n            if not os.path.exists(file_path):\n                os.makedirs(file_path)\n\n            if str(oct(fileobj.st_mode)).startswith('04'):\n                # Create the directory\n                if not os.path.exists(file_name):\n                    os.makedirs(file_name)\n            else:\n                # Write out the file\n                if fileobj.st_mtime > all_files[file_name]:\n                    client.get(os.path.join(path, fileobj.filename), file_name)\n            os.utime(file_name, (fileobj.st_atime, fileobj.st_mtime))\n```", "```py\n# rm /var/cache/salt/sftpfs/base/testfile\n# salt-call --local cp.get_file salt://testfile /tmp/testfile\nlocal:\n /tmp/testfile\n\n```", "```py\ndef file_hash(load, fnd):\n    '''\n    Return a file hash, the hash type is set in the master config file\n    '''\n    path = fnd['path']\n    ret = {}\n\n    # if the file doesn't exist, we can't get a hash\n    if not path or not os.path.isfile(path):\n        return ret\n\n    # set the hash_type as it is determined by config\n    ret['hash_type'] = __opts__['hash_type']\n\n    # Check if the hash is cached\n    # Cache file's contents should be 'hash:mtime'\n    cache_path = os.path.join(\n        salt.syspaths.CACHE_DIR,\n        'sftpfs',\n        'hash',\n        load['saltenv'],\n        '{0}.hash.{1}'.format(\n            fnd['rel'],\n            ret['hash_type']\n        )\n    )\n\n    # If we have a cache, serve that if the mtime hasn't changed\n    if os.path.exists(cache_path):\n        try:\n            with salt.utils.fopen(cache_path, 'rb') as fp_:\n                try:\n                    hsum, mtime = fp_.read().split(':')\n                except ValueError:\n                    log.debug(\n                        'Fileserver attempted to read incomplete cache file. Retrying.'\n                    )\n                    file_hash(load, fnd)\n                    return ret\n                if os.path.getmtime(path) == mtime:\n                    # check if mtime changed\n                    ret['hsum'] = hsum\n                    return ret\n        except os.error:\n            # Can't use Python select() because we need Windows support\n            log.debug(\n                'Fileserver encountered lock when reading cache file. Retrying.'\n            )\n            file_hash(load, fnd)\n            return ret\n\n    # If we don't have a cache entry-- lets make one\n    ret['hsum'] = salt.utils.get_hash(path, __opts__['hash_type'])\n    cache_dir = os.path.dirname(cache_path)\n\n    # Make cache directory if it doesn't exist\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n\n    # Save the cache object 'hash:mtime'\n    if HAS_FCNTL:\n        with salt.utils.flopen(cache_path, 'w') as fp_:\n            fp_.write('{0}:{1}'.format(ret['hsum'], os.path.getmtime(path)))\n            fcntl.flock(fp_.fileno(), fcntl.LOCK_UN)\n        return ret\n    else:\n        with salt.utils.fopen(cache_path, 'w') as fp_:\n            fp_.write('{0}:{1}'.format(ret['hsum'], os.path.getmtime(path)))\n        return ret\n```", "```py\n/var/cache/salt/sftpfs/hash/base/testfile.hash.md5\n```", "```py\n'''\nThe backend for serving files from an SFTP account.\n\nTo enable, add ``sftp`` to the :conf_master:`fileserver_backend` option in the\nMaster config file.\n\n.. code-block:: yaml\n\n    fileserver_backend:\n      - sftp\n\nEach environment is configured as a directory inside the SFTP account. The name\nof the directory must match the name of the environment.\n\n.. code-block:: yaml\n\n    sftpfs_host: sftp.example.com\n    sftpfs_port: 22\n    sftpfs_username: larry\n    sftpfs_password: 123pass\n    sftpfs_root: /srv/sftp/salt/\n'''\nimport os\nimport os.path\nimport logging\nimport time\n\ntry:\n    import fcntl\n    HAS_FCNTL = True\nexcept ImportError:\n    # fcntl is not available on windows\n    HAS_FCNTL = False\n\nimport salt.fileserver\nimport salt.utils\nimport salt.syspaths\n\ntry:\n    import paramiko\n    from paramiko import AuthenticationException\n    HAS_LIBS = True\nexcept ImportError:\n    HAS_LIBS = False\n\n__virtualname__ = 'sftp'\n\nlog = logging.getLogger() \ntransport = None\nclient = None\n\ndef __virtual__():\n    '''\n    Only load if proper conditions are met\n    '''\n    if __virtualname__ not in __opts__['fileserver_backend']:\n        return False\n\n    if not HAS_LIBS:\n        return False\n\n    if __opts__.get('sftpfs_root', None) is None:\n        return False\n\n    global client\n    global transport\n\n    host = __opts__.get('sftpfs_host')\n    port = __opts__.get('sftpfs_port', 22)\n    username = __opts__.get('sftpfs_username')\n    password = __opts__.get('sftpfs_password')\n    try:\n        transport = paramiko.Transport((host, port))\n        transport.connect(username=username, password=password)\n        client = paramiko.SFTPClient.from_transport(transport)\n    except AuthenticationException:\n        return False\n\n    return True\n\ndef envs():\n    '''\n    Treat each directory as an environment\n    '''\n    ret = []\n    root = __opts__.get('sftpfs_root')\n    for entry in client.listdir_attr(root):\n        if str(oct(entry.st_mode)).startswith('04'):\n            ret.append(entry.filename)\n    return ret\n\ndef file_list(load):\n    '''\n    Return a list of all files on the file server in a specified environment\n    '''\n    root = __opts__.get('sftpfs_root')\n    path = os.path.join(root, load['saltenv'], load['prefix'])\n    return _recur_path(path, load['saltenv'])\n\ndef dir_list(load):\n    '''\n    Return a list of all directories on the master\n    '''\n    root = __opts__.get('sftpfs_root')\n    path = os.path.join(root, load['saltenv'], load['prefix'])\n    return _recur_path(path, load['saltenv'], True)\n\ndef _recur_path(path, saltenv, only_dirs=False):\n    '''\n    Recurse through the remote directory structure\n    '''\n    root = __opts__.get('sftpfs_root')\n    ret = []\n    try:\n        for entry in client.listdir_attr(path):\n            full = os.path.join(path, entry.filename)\n            if str(oct(entry.st_mode)).startswith('04'):\n                ret.append(full)\n                ret.extend(_recur_path(full, saltenv, only_dirs))\n            else:\n                if only_dirs is False:\n                    ret.append(full)\n        return ret\n    except IOError:\n        return []\n\ndef find_file(path, saltenv='base', env=None, **kwargs):\n    '''\n    Search the environment for the relative path\n    '''\n    fnd = {'path': '',\n           'rel': ''}\n\n    full = os.path.join(salt.syspaths.CACHE_DIR, 'sftpfs', saltenv, path)\n\n    if os.path.isfile(full) and not salt.fileserver.is_file_ignored(__opts__, full):\n        fnd['path'] = full\n        fnd['rel'] = path\n\n    return fnd\n\ndef serve_file(load, fnd):\n    '''\n    Return a chunk from a file based on the data received\n    '''\n    ret = {'data': '',\n           'dest': ''}\n\n    if 'path' not in load or 'loc' not in load or 'saltenv' not in load:\n        return ret\n\n    if not fnd['path']:\n        return ret\n\n    ret['dest'] = fnd['rel']\n    gzip = load.get('gzip', None)\n\n    full = os.path.join(salt.syspaths.CACHE_DIR, 'sftpfs', fnd['path'])\n\n    with salt.utils.fopen(fnd['path'], 'rb') as fp_:\n        fp_.seek(load['loc'])\n        data = fp_.read(__opts__['file_buffer_size'])\n        if gzip and data:\n            data = salt.utils.gzip_util.compress(data, gzip)\n            ret['gzip'] = gzip\n        ret['data'] = data\n    return ret\n\ndef update():\n    '''\n    Update the cache, and reap old entries\n    '''\n    base_dir = os.path.join(salt.syspaths.CACHE_DIR, 'sftpfs')\n    if not os.path.isdir(base_dir):\n        os.makedirs(base_dir)\n\n    try:\n        salt.fileserver.reap_fileserver_cache_dir(\n            os.path.join(base_dir, 'hash'),\n            find_file\n        )\n    except (IOError, OSError):\n        # Hash file won't exist if no files have yet been served up\n        pass\n\n    # Find out what the latest file is, so that we only update files more\n    # recent than that, and not the entire filesystem\n    if os.listdir(base_dir):\n        all_files = {}\n        for root, subFolders, files in os.walk(base_dir):\n            for fn_ in files:\n                full_path = os.path.join(root, fn_)\n                all_files[full_path] = os.path.getmtime(full_path)\n\n    # Pull in any files that have changed\n    for env in envs():\n        path = os.path.join(__opts__['sftpfs_root'], env)\n        result = client.listdir_attr(path)\n        for fileobj in result:\n            file_name = os.path.join(base_dir, env, fileobj.filename)\n\n            # Make sure the directory exists first\n            comps = file_name.split('/')\n            file_path = '/'.join(comps[:-1])\n            if not os.path.exists(file_path):\n                os.makedirs(file_path)\n\n            if str(oct(fileobj.st_mode)).startswith('04'):\n                # Create the directory\n                if not os.path.exists(file_name):\n                    os.makedirs(file_name)\n            else:\n                # Write out the file\n                if fileobj.st_mtime > all_files[file_name]:\n                    client.get(os.path.join(path, fileobj.filename), file_name)\n            os.utime(file_name, (fileobj.st_atime, fileobj.st_mtime))\n\ndef file_hash(load, fnd):\n    '''\n    Return a file hash, the hash type is set in the master config file\n    '''\n    path = fnd['path']\n    ret = {}\n\n    # if the file doesn't exist, we can't get a hash\n    if not path or not os.path.isfile(path):\n        return ret\n\n    # set the hash_type as it is determined by config\n    # -- so mechanism won't change that\n    ret['hash_type'] = __opts__['hash_type']\n\n    # Check if the hash is cached\n    # Cache file's contents should be 'hash:mtime'\n    cache_path = os.path.join(\n        salt.syspaths.CACHE_DIR,\n        'sftpfs',\n        'hash',\n        load['saltenv'],\n        '{0}.hash.{1}'.format(\n            fnd['rel'],\n            ret['hash_type']\n        )\n    )\n\n    # If we have a cache, serve that if the mtime hasn't changed\n    if os.path.exists(cache_path):\n        try:\n            with salt.utils.fopen(cache_path, 'rb') as fp_:\n                try:\n                    hsum, mtime = fp_.read().split(':')\n                except ValueError:\n                    log.debug(\n                        'Fileserver attempted to read'\n                        'incomplete cache file. Retrying.'\n                    )\n                    file_hash(load, fnd)\n                    return ret\n                if os.path.getmtime(path) == mtime:\n                    # check if mtime changed\n                    ret['hsum'] = hsum\n                    return ret\n        except os.error:\n            # Can't use Python select() because we need Windows support\n            log.debug(\n                'Fileserver encountered lock when reading cache file. Retrying.'\n            )\n            file_hash(load, fnd)\n            return ret\n\n    # If we don't have a cache entry-- lets make one\n    ret['hsum'] = salt.utils.get_hash(path, __opts__['hash_type'])\n    cache_dir = os.path.dirname(cache_path)\n\n    # Make cache directory if it doesn't exist\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n\n    # Save the cache object 'hash:mtime'\n    if HAS_FCNTL:\n        with salt.utils.flopen(cache_path, 'w') as fp_:\n            fp_.write('{0}:{1}'.format(ret['hsum'], os.path.getmtime(path)))\n            fcntl.flock(fp_.fileno(), fcntl.LOCK_UN)\n        return ret\n    else:\n        with salt.utils.fopen(cache_path, 'w') as fp_:\n            fp_.write('{0}:{1}'.format(ret['hsum'], os.path.getmtime(path)))\n        return ret\n```"]