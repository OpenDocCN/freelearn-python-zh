<html><head></head><body>
<div><div><h1 id="_idParaDest-160"><em class="italic"><a id="_idTextAnchor162"/>Chapter 13</em>: Applying GOF Design Patterns – Part 2</h1>
<p>In this chapter, we will continue looking at the concept of design patterns in Python 3 and its various categories and their implementation while developing software using Python.</p>
<p>In the previous chapter, we learned how to apply behavioral design patterns with examples. In this chapter, we will continue looking at the remaining two categories – structural and creational design patterns. We will see how they can be applied in Python using our core example of <em class="italic">ABC Megamart</em>.</p>
<p>In this chapter, we will be looking at the following main topics:</p>
<ul>
<li>Understanding structural design patterns</li>
<li>Understanding creational design patterns</li>
</ul>
<p>By the end of this chapter, you should be able to understand some of the examples of important structural and creational design patterns and learn how they can be implemented in various applications.</p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor163"/>Technical requirements</h1>
<p>The code examples shared in this chapter are available on GitHub under the code for this chapter here: <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter13">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter13</a>.</p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor164"/>Exploring structural design patterns</h1>
<p>As the name suggests, structural design patterns are used to design the structure of classes and their implementation in such a way that the classes and objects can be extended or reused effectively. In this section, we will be covering three such structural design patterns — bridge, façade, and proxy patterns. We are considering these three design patterns because they are unique and they represent three different aspects of how structural design patterns can be used.</p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor165"/>Understanding the bridge pattern</h2>
<p>The bridge design pattern is<a id="_idIndexMarker605"/> applied to bridge multiple elements or operations of implementation using the concept of abstraction or the abstract method. To explain this further and to implement this design pattern, our code should have the<a id="_idIndexMarker606"/> following elements:</p>
<ul>
<li><strong class="bold">Abstraction superclass</strong>: The<a id="_idIndexMarker607"/> base class with the abstract method to perform a specific action, along with methods to bridge any additional implementation</li>
<li><strong class="bold">Abstraction subclasses</strong>: One<a id="_idIndexMarker608"/> or more subclasses that implement the abstract method from the abstraction superclass to perform their respective action</li>
<li><strong class="bold">Implementation superclass</strong>: A base <a id="_idIndexMarker609"/>that adds an additional implementation or design over the abstraction</li>
<li><strong class="bold">Implementation subclasses</strong>: Subclasses<a id="_idIndexMarker610"/> that inherit the implementation superclass</li>
</ul>
<p>Let’s look at the<a id="_idIndexMarker611"/> bridge pattern with an example. In this example, we will look at printing the business card for branch managers that belong to two different supermarkets – <em class="italic">ABC Megamart</em> and <em class="italic">XYZ Megamart</em>. Let’s see how:</p>
<ol>
<li>To illustrate the design pattern further, let’s create an abstraction superclass named <code>PrintCard</code>, and add three methods. The <code>add_name</code> method adds the name of the supermarket, and the <code>add_manager</code> method adds the formatting specific to a manager. The <code>add_manager</code> method gets the formatting input from the implementation subclass, which we will discuss later in this section. The third method is the <code>printcard</code> method, which is an abstract method and will be defined in the subclasses:<pre>from abc import abstractmethod, ABC
class PrintCard(ABC):    
    def add_name(self, name):
        self.name = name        
    def add_manager(self, branch):
        self.branch = branch.FORMATTING        
    @abstractmethod
    def printcard(self):
        pass</pre></li>
<li>Let’s<a id="_idIndexMarker612"/> further create an abstraction subclass named <code>CardABC</code>. This class will initialize the logo, name from the super class, and manager from the super class. The <code>printcard</code> method will print the logo, the name of the supermarket, and the address of the branch:<pre>class CardABC(PrintCard):
    def __init__(self, logo, name, branch):
        self.logo = logo
        super().add_name(name)
        super().add_manager(branch)
        
    def printcard(self, *args):
        print(self.logo + self.name)
        for arg in args:
            print(self.branch + str(arg))</pre></li>
<li>Next, create an abstraction subclass named <code>CardXYZ</code>. It will initialize the following variables – style, logo, name from super class, and manager from the superclass. The <code>printcard</code> method will print the logo, the style for the card, the name of the supermarket, and the address of the branch:<pre>class CardXYZ(PrintCard):
    def __init__(self, style, logo, name, branch):
        self.style = style
        self.logo = logo
        super().add_name(name)
        super().add_manager(branch)
        
    def printcard(self, *args):
        print(self.logo + self.style + self.name)
        for arg in args:
            print(self.branch + str(arg))</pre></li>
<li>Now, let’s <a id="_idIndexMarker613"/>create the implementation superclass named <code>Manager</code> with a method named <code>formatting</code>:<pre>class Manager:
    def formatting(self):
        pass</pre></li>
<li>Next, create an implementation subclass named <code>Manager_manhattan</code> to add formatting to the business card, specifically for the branch manager from the Manhattan branch:<pre>class Manager_manhattan(Manager):
    def __init__(self):
        self.formatting()
    
    def formatting(self):
        self.FORMATTING = '\33[7m'</pre></li>
<li>Let’s now create an implementation subclass named <code>Manager_albany</code> to add formatting for the business card specifically for the branch manager from the Albany branch:<pre>class Manager_albany(Manager):
    def __init__(self):
        self.formatting()
    
    def formatting(self):
        self.FORMATTING = '\033[94m'</pre></li>
<li>Next, instantiate <code>CardABC</code>, which is an abstraction subclass. The three input parameters<a id="_idIndexMarker614"/> for this class are the format of the logo, the name of the supermarket, and the branch from where the formatting will be added to the card:<pre>manager_manhattan = CardABC(logo = '\33[43m', name = 'ABC Megamart', branch = Manager_manhattan())</pre></li>
<li>And now we will print the card:<pre>manager_manhattan.printcard('John M',
              'john.m@abcmegamart.com',
  '40097 5th Main Street',
  'Manhattan',
  'New York City',
  'New York',
  11007)</pre></li>
</ol>
<p>The output is represented as follows, with the formatting as provided in the class instantiation:</p>
<pre><strong class="bold">ABC Megamart</strong>
<strong class="bold">John M</strong>
<strong class="bold">john.m@abcmegamart.com</strong>
<strong class="bold">40097 5th Main Street</strong>
<strong class="bold">Manhattan</strong>
<strong class="bold">New York City</strong>
<strong class="bold">New York</strong>
<strong class="bold">11007</strong></pre>
<ol>
<li value="9">Let’s now<a id="_idIndexMarker615"/> instantiate <code>CardXYZ</code>, which is an abstraction subclass. The four input parameters for this class are the style, the format of the logo, the name of the supermarket, and the branch from where the formatting will be added to the card:<pre>manager_albany = CardXYZ(style = '\33[43m',logo = '\33[5m', name = 'XYZ Megamart', branch = Manager_albany())</pre></li>
<li>Now, let’s print the card.<pre>manager_albany.printcard('Ron D','ron.d@abcmegamart.com','123 Main Street','Albany','New York', 12084)</pre></li>
</ol>
<p>The output is represented as follows, with the style and formatting as provided in the class instantiation:</p>
<pre><strong class="bold">XYZ Megamart</strong>
<strong class="bold">Ron D</strong>
<strong class="bold">ron.d@abcmegamart.com</strong>
<strong class="bold">123 Main Street</strong>
<strong class="bold">Albany</strong>
<strong class="bold">New York</strong>
<strong class="bold">12084</strong></pre>
<p>Let’s connect the elements of this design pattern with their corresponding objects in the example with the following graphical representation:</p>
<div><div><img alt="Figure 13.1 – Bridge pattern classes " height="1012" src="img/Figure_13.1_B13426.jpg" width="891"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Bridge pattern classes</p>
<p>So, the bridge <a id="_idIndexMarker616"/>pattern has been implemented by creating a bridge between the abstraction and the implementation classes. With this understanding, let’s look at the facade pattern.</p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor166"/>Understanding the facade pattern</h2>
<p>In this section, we <a id="_idIndexMarker617"/>will look at the facade pattern, where we will design a black box kind of implementation to hide the complexity of a system that handles multiple subsystems from the end user or client. To explain this further and to implement this design<a id="_idIndexMarker618"/>/core pattern, our code needs the following elements:</p>
<ul>
<li><strong class="bold">Functionality</strong>: The core functionalities that need to be implemented for a system are defined in these <a id="_idIndexMarker619"/>functionality classes.</li>
<li><strong class="bold">Facade</strong>: This is<a id="_idIndexMarker620"/> the class that wraps the core functionalities and their implementation from the end users.</li>
<li><strong class="bold">End user</strong>: The function, method, or class <a id="_idIndexMarker621"/>using which the core functionalities of a system are accessed using the facade class.</li>
</ul>
<p>To understand the<a id="_idIndexMarker622"/> facade pattern further, let’s create a set of functionalities that starts from adding items to the shopping cart, moving to the counter, scanning bar codes, billing, and finally, printing the invoice: </p>
<ol>
<li value="1">The first functionality class in this series is <code>Cart</code>, where items will be added to the shopping cart in the <code>return_cart</code> method:<pre>class Cart:
    def __init__(self, items):
        self.items = items
    def return_cart(self):
        cart_items = []
        for i in self.items:
            cart_items.append(i)
        print("Running return_cart...")
        return cart_items</pre></li>
<li>The second functionality class is the <code>Counter</code> class, where the name of the counter is returned in the <code>goto_counter</code> method:<pre>class Counter:
    def __init__(self, name):
        self.name = name
    def goto_counter(self):
        countername = self.name
        print("Running goto_counter...")
        return countername</pre></li>
<li>The third functionality class is the <code>BarCode</code> class, where the scanned bar codes are returned in the <code>scan_bar_code</code> method:<pre>class BarCode:
    def __init__(self, scan):
        self.scan = scan
    def scan_bar_code(self):
        codes = []
        for i in self.scan:
            codes.append(i)
        print("Running scan_bar_code...")
        return codes</pre></li>
<li>The fourth<a id="_idIndexMarker623"/> functionality is the <code>Billing</code> class, where the price is tagged to the bar codes and returned as a dictionary object in the <code>add_billing</code> method:<pre>class Billing:
    def __init__(self, codes, units ):
        self.codes = codes
        self.units = units
    def add_billing(self):
        codes = self.codes.scan_bar_code()
        pricetag = []
        for i in self.units:
            pricetag.append(i)
        bill = dict(zip(codes, pricetag))
        print("Running add_billing...")
        return bill</pre></li>
<li>The next <a id="_idIndexMarker624"/>functionality is the <code>Tax</code> class, where tax values are returned using the <code>add_tax</code> method in the class:<pre>class Tax:
    def __init__(self, tax):
        self.tax = tax
    def add_tax(self):
        taxed = []
        for i in self.tax:
            taxed.append(i)
        print("Running add_tax...")
        return taxed</pre></li>
<li>The functionality after this is the <code>FinalBill</code> class, where we will be calculating the final bill using the <code>calc_bill</code> method:<pre>class FinalBill:
    def __init__(self, billing, cart, tax):
        self.billing = billing
        self.cart = cart
        self.tax = tax    
    def calc_bill(self):
        bill = self.billing.add_billing()
        items = []
        cart_items = self.cart.return_cart()
        calc_bill = []
        taxes = self.tax.add_tax()
        for item,tax in zip(bill.items(),taxes):
            items.append(item[1])
            calc_bill.append(item[1] + item[1]*tax)
        finalbill = dict(zip(cart_items, calc_bill))
        print("Running calc_bill...")
        return finalbill</pre></li>
<li>The <a id="_idIndexMarker625"/>final functionality class in the facade pattern is the <code>Invoice</code> class, where we will be creating a <code>print_invoice</code> method to print the final invoice:<pre>class Invoice:
    def __init__(self, finalbill, counter):
        self.finalbill = finalbill
        self.counter = counter
    def print_invoice(self):
        finalbill = self.finalbill.calc_bill()
        final_total = sum(finalbill.values())
        print("Running print_invoice...")
        print('**************ABC 
               Megamart*****************')
        print('***********------------------
               **************')
        print('Counter Name: ', 
               self.counter.goto_counter())
        for item,price in finalbill.items():
            print(item,": ", price)
        print('Total:',final_total)
        print('***********------------------
               **************')
        print('***************PAID********************
               ****')</pre></li>
<li>Now, let’s <a id="_idIndexMarker626"/>create the <code>Facade</code> class named <code>Queue</code>. It has two functions – the <code>pipeline</code> method to explicitly run some of the methods in the functionality classes, and the <code>pipeline_implicit</code> method to run the <code>print_invoice</code> method from the <code>Invoice</code> class, which will in turn call all other methods in the rest of the functionality classes:<pre>class Queue:
    def __init__(self, items, name, scan, units, tax):
        self.cart = Cart(items)
        self.counter = Counter(name)
        self.barcode = BarCode(scan)
        self.billing = Billing(self.barcode, units)
        self.tax = Tax(tax)
        self.finalbill = FinalBill(self.billing, 
                         self.cart, self.tax)
        self.invoice = Invoice(self.finalbill, 
                               self.counter)
    def pipeline(self):
        self.cart.return_cart()
        self.counter.goto_counter()
        self.barcode.scan_bar_code()
        self.tax.add_tax()
    def pipeline_implicit(self):
        self.invoice.print_invoice()</pre></li>
<li>Let’s create<a id="_idIndexMarker627"/> an end user function to run the methods in functionality classes using the <code>Facade</code> class by creating an instance for <code>Queue</code> and calling the <code>pipeline</code> method:<pre>def run_facade():
    queue = Queue(items = ['paperclips','blue 
                    pens','stapler','pencils'],
             name = ['Regular Counter'],
             scan = [113323,3434332,2131243,2332783],
             units = [10,15,12,14],
             tax = [0.04,0.03,0.035,0.025],
             )
    queue.pipeline()</pre></li>
<li>Now, let’s call the <code>run_facade</code> method to test the design pattern:<pre>run_facade()</pre></li>
</ol>
<p>The output for the preceding test is as follows:</p>
<pre><strong class="bold">Running return_cart...</strong>
<strong class="bold">Running goto_counter...</strong>
<strong class="bold">Running scan_bar_code...</strong>
<strong class="bold">Running add_tax...</strong></pre>
<ol>
<li value="11">Finally, let’s create another end user function to run the methods in functionality classes using the <code>Facade</code> class by creating an instance for <code>Queue</code> and calling the <code>pipeline_implicit</code> method:<pre>def run_facade_implicit():
    queue = Queue(items = ['paperclips','blue 
                     pens','stapler','pencils'],
             name = ['Regular Counter'],
             scan = [113323,3434332,2131243,2332783],
             units = [10,15,12,14],
             tax = [0.04,0.03,0.035,0.025],
             )
    queue.pipeline_implicit()</pre></li>
<li>Then, let’s <a id="_idIndexMarker628"/>call the <code>run_facade_implicit</code> method to test the design pattern:<pre>run_facade_implicit()</pre></li>
</ol>
<p>The output for the preceding test is as follows:</p>
<pre><strong class="bold">Running scan_bar_code...</strong>
<strong class="bold">Running add_billing...</strong>
<strong class="bold">Running return_cart...</strong>
<strong class="bold">Running add_tax...</strong>
<strong class="bold">Running calc_bill...</strong>
<strong class="bold">Running print_invoice...</strong>
<strong class="bold">**************ABC Megamart*****************</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">Running goto_counter...</strong>
<strong class="bold">Counter Name:  ['Regular Counter']</strong>
<strong class="bold">paperclips :  10.4</strong>
<strong class="bold">blue pens :  15.45</strong>
<strong class="bold">stapler :</strong><strong class="bold">  12.42</strong>
<strong class="bold">pencils :  14.35</strong>
<strong class="bold">Total: 52.620000000000005</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">***************PAID************************</strong></pre>
<p>Let’s connect<a id="_idIndexMarker629"/> the elements of this design pattern with their corresponding objects in the example in the following graphical representation:</p>
<div><div><img alt="Figure 13.2 – Facade pattern classes " height="859" src="img/Figure_13.2_B13426.jpg" width="737"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Facade pattern classes</p>
<p>So, the facade pattern has been implemented by creating a black box that provides the end users with an interface to access the functions of a complex system without worrying about the implementation details. Now, let’s look at the proxy pattern.</p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor167"/>Understanding the proxy pattern</h2>
<p>In this section, we <a id="_idIndexMarker630"/>will look at the proxy design pattern. As the name implies, the proxy pattern is applied to create a proxy around the actual functionality so that the actual functionality is executed only when the proxy allows it based on certain preconditions. To explain this further and to implement this design pattern, our code<a id="_idIndexMarker631"/> needs the following elements:</p>
<ul>
<li><strong class="bold">Functionality class</strong>: The <a id="_idIndexMarker632"/>base functionalities of the system are designed in this class as methods.</li>
<li><code>functionality</code> class and it provides restrictions <a id="_idIndexMarker634"/>as to when to execute the base functionalities from the <code>functionality</code> class.</li>
</ul>
<p>In this example, let’s <a id="_idIndexMarker635"/>consider the NYC branch of <em class="italic">ABC Megamart</em> and create a class named <code>NYC</code>: </p>
<ol>
<li value="1">The <code>NYC</code> class is initialized with four empty dictionary parameters named <code>manager</code>, <code>branch</code>, <code>product</code>, and <code>sales</code>. Let’s also add three methods named <code>set_parameters</code> (to set the four dictionary parameters), <code>get_parameters</code> (to return the parameters), and <code>calc_tax_nyc</code> (to calculate the tax and return the parameters along with selling price data):<pre>class NYC:
    def __init__(self):
        self.manager = {}
        self.branch = {}
        self.product = {}
        self.sales = {}        
    def set_parameters(self, manager, branch, product,
                       sales):
        self.manager = manager
        self.branch = branch
        self.product = product
        self.sales = sales        
    def get_parameters(self):
        return self.manager, self.branch, 
               self.product, self.sales    
    def calc_tax_nyc(self):
        branch = self.branch
        manager = self.manager
        product = self.product
        sales = self.sales
        pricebeforetax = sales['purchase_price'] + 
                         sales['purchase_price'] * 
                         sales['profit_margin']
        finalselling_price = pricebeforetax + 
            (pricebeforetax * (sales['tax_rate'] + 
             sales['local_rate']))  
        sales['selling_price'] = finalselling_price
        return branch, manager, product, sales   </pre></li>
<li>The <a id="_idIndexMarker636"/>next step of the implementation is to create a proxy <code>ReturnBook</code> class to call the methods from the <code>NYC</code> class to set parameters, get parameters, and calculate tax:<pre>class ReturnBook(NYC):
    def __init__(self, nyc):
        self.nyc = nyc
    def add_book_details(self, state, manager, branch, 
                         product, sales):
        if state in ['NY', 'NYC', 'New York']:
            self.nyc.set_parameters(manager, branch, 
                                    product, sales)
        else:
            print("There is no branch in the state:", 
                  state)
    def show_book_details(self, state):
        if state in ['NY', 'NYC', 'New York']:
            return self.nyc.get_parameters()
        else:
            print(state, "has no data")
    def calc_tax(self, state):
        if state in ['NY', 'NYC', 'New York']:
            return self.nyc.calc_tax_nyc()
        else:
            print("The state", state, "is not 
                   supported") </pre></li>
<li>Let’s now<a id="_idIndexMarker637"/> instantiate the proxy <code>ReturnBook</code> class and provide the <code>NYC</code> functionality class as the input parameter:<pre>branch_manhattan = ReturnBook(NYC())</pre></li>
<li>To set the parameters from the <code>NYC</code> class, we will be calling the <code>add_book_details</code> method from the proxy class. The parameters will be set in the <code>NYC</code> class only if the conditions provided in <code>add_book_details</code> are successfully met by the input state parameter: <pre>branch_manhattan.add_book_details(state = 'NY', manager = {'regional_manager': 'John M',
  'branch_manager': 'Tom H',
  'sub_branch_id': '2021-01'},
   branch = {'branchID': 2021,
  'branch_street': '40097 5th Main Street',
  'branch_borough': 'Manhattan',
  'branch_city': 'New York City',
  'branch_state': 'New York',
  'branch_zip': 11007},
   product = {'productId': 100002,
  'product_name': 'WashingMachine',
  'product_brand': 'Whirlpool'},
   sales = {'purchase_price': 450,
  'profit_margin': 0.19,
  'tax_rate': 0.4,
  'local_rate': 0.055})</pre></li>
<li>Let’s further<a id="_idIndexMarker638"/> call the <code>show_book_details</code> method to get the parameters from the <code>NYC</code> class, provided that the state parameter in the input is <code>NY</code>, <code>NYC</code>, or <code>New York</code>:<pre>branch_manhattan.show_book_details('NY')</pre></li>
</ol>
<p>The output of the preceding code is as follows:</p>
<pre><strong class="bold">({'regional_manager': 'John M',</strong>
<strong class="bold">  'branch_manager': 'Tom H',</strong>
<strong class="bold">  'sub_branch_id': '2021-01'},</strong>
<strong class="bold"> {'branchID': 2021,</strong>
<strong class="bold">  'branch_street': '40097 5th Main Street',</strong>
<strong class="bold">  'branch_borough': 'Manhattan',</strong>
<strong class="bold">  'branch_city': 'New York City',</strong>
<strong class="bold">  'branch_state': 'New York',</strong>
<strong class="bold">  'branch_zip': 11007},</strong>
<strong class="bold"> {'productId': 100002,</strong>
<strong class="bold">  'product_name': 'WashingMachine',</strong>
<strong class="bold">  'product_brand': 'Whirlpool'},</strong>
<strong class="bold"> {'purchase_price': 450,</strong>
<strong class="bold">  'profit_margin': 0.19,</strong>
<strong class="bold">  'tax_rate': 0.4,</strong>
<strong class="bold">  'local_rate': 0.055})</strong></pre>
<ol>
<li value="6">Let’s further<a id="_idIndexMarker639"/> call the <code>calc_tax</code> method from the proxy class to calculate the selling price, provided the state parameters are successful:<pre>branch_manhattan.calc_tax('NY')</pre></li>
<li>Let’s test the restrictions in the proxy methods by providing incorrect input to the state parameter:<pre>branch_manhattan.add_book_details(state = 'LA', manager = {'regional_manager': 'John M',
  'branch_manager': 'Tom H',
  'sub_branch_id': '2021-01'},
   branch = {'branchID': 2021,
  'branch_street': '40097 5th Main Street',
  'branch_borough': 'Manhattan',
  'branch_city': 'New York City',
  'branch_state': 'New York',
  'branch_zip': 11007},
   product = {'productId': 100002,
  'product_name': 'WashingMachine',
  'product_brand': 'Whirlpool'},
   sales = {'purchase_price': 450,
  'profit_margin': 0.19,
  'tax_rate': 0.4,
  'local_rate': 0.055})</pre></li>
</ol>
<p>The output of the preceding code is as follows:</p>
<pre><strong class="bold">There is no branch in the state: LA</strong></pre>
<ol>
<li value="8">Similarly, let’s<a id="_idIndexMarker640"/> also test the <code>show_book_details</code> method:<pre>branch_manhattan.show_book_details('LA')</pre></li>
</ol>
<p>The output of the preceding code is as follows:</p>
<pre><strong class="bold">LA has no data</strong></pre>
<ol>
<li value="9">Finally, let’s test the <code>calc_tax</code> method from the proxy:<pre>branch_manhattan.calc_tax('LA')</pre></li>
</ol>
<p>The output is as follows:</p>
<pre><strong class="bold">The state LA is not supported</strong></pre>
<p>Let’s connect the elements of this design pattern with their corresponding objects in the example in the following graphical representation:</p>
<div><div><img alt="Figure 13.3 – Proxy design pattern classes " height="775" src="img/Figure_13.3_B13426.jpg" width="862"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Proxy design pattern classes</p>
<p>So, the <a id="_idIndexMarker641"/>proxy pattern has been implemented by creating a proxy class that adds the required conditions to execute the actual functionalities. Next, we’re moving on to exploring the creational design patterns.</p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor168"/>Exploring creational design patterns</h1>
<p>Creational design patterns are<a id="_idIndexMarker642"/> various methods to add abstraction in the process of object creation. In <a id="_idIndexMarker643"/>this section, we will be looking at three such design patterns, namely the factory method, prototype pattern, and singleton pattern.</p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor169"/>Understanding the factory method</h2>
<p>The<a id="_idIndexMarker644"/> factory design pattern is<a id="_idIndexMarker645"/> a method of abstraction where a factory class is created to create an object for the class from the factory class instead of directly instantiating the object. To explain this further and to implement this design pattern, our code needs the<a id="_idIndexMarker646"/> following elements:</p>
<ul>
<li><strong class="bold">Abstract class</strong>: The<a id="_idIndexMarker647"/> abstract class with the abstract methods for functionalities to be defined in the subclasses.</li>
<li><strong class="bold">Abstraction subclasses</strong>: The <a id="_idIndexMarker648"/>subclasses are inherited from the abstract class and overwrite the abstract methods.</li>
<li><strong class="bold">Factory class</strong>: The class <a id="_idIndexMarker649"/>to create objects for the abstraction subclasses.</li>
<li><strong class="bold">End user method</strong>: The <a id="_idIndexMarker650"/>class or method to test or call the factory method.</li>
</ul>
<p>For this example, let’s implement<a id="_idIndexMarker651"/> using another scenario from <em class="italic">ABC Megamart</em>:</p>
<ol>
<li value="1">Let’s create an abstract class with two methods, <code>buy_product</code> and <code>maintenance_cost</code>:<pre>from abc import abstractmethod
class Branch:
    @abstractmethod
    def buy_product(self):
        pass
    @abstractmethod
    def maintenance_cost(self):
        pass</pre></li>
<li>Now, let’s create a subclass for the <code>Branch</code> class named <code>Brooklyn</code> and implement the <code>buy_product</code> and <code>maintenance_cost</code> methods:<pre>class Brooklyn(Branch):
    def __init__(self,product,unit_price,quantity,
                 product_type):
        self.product = product
        self.unit_price = unit_price
        self.quantity = quantity
        self.product_type = product_type        
    def buy_product(self):
        if (self.product_type == 'FMCG'):
            self.statetax_rate = 0.035
            self.promotiontype = 'Discount'
            self.discount = 0.10
            self.initialprice = 
                self.unit_price*self.quantity 
            self.salesprice = self.initialprice + 
                self.initialprice*self.statetax_rate
            self.finalprice = self.salesprice * 
                (1-self.discount)
            return self.salesprice, 
                self.product,self.promotiontype
        else:
            return "We don't stock this product"
     def maintenance_cost(self):
        self.coldstorageCost = 100
        if (self.product_type == 'FMCG'):
            self.maintenance_cost = self.quantity * 
                0.25 + self.coldstorageCost    
            return self.maintenance_cost
        else:
            return "We don't stock this product"</pre></li>
<li>Similarly, let’s create <a id="_idIndexMarker652"/>another subclass, named <code>Manhattan</code>, which inherits the <code>Branch</code> class, as follows:<pre>class Manhattan(Branch):
    def __init__(self,product,unit_price,quantity,
                 product_type):
        self.product = product
        self.unit_price = unit_price
        self.quantity = quantity
        self.product_type = product_type</pre></li>
<li>Let’s further define a method named <code>buy_product</code> to return the product price, product name, and promotion in cases where the product is electronic:<pre>    def buy_product(self):
        if (self.product_type == 'Electronics'):
            self.statetax_rate = 0.05        
            self.promotiontype = 'Buy 1 Get 1'
            self.discount = 0.50
            self.initialprice = 
                self.unit_price*self.quantity 
            self.salesprice = self.initialprice + 
                self.initialprice*self.statetax_rate
            self.finalprice = self.salesprice * 
                (1-self.discount)
            return self.finalprice, 
                self.product,self.promotiontype
        else:
            return "We don't stock this product"</pre></li>
<li>Let’s now <a id="_idIndexMarker653"/>define another method to calculate the maintenance cost:<pre>    def maintenance_cost(self):
        if (self.product_type == 'Electronics'):
          self.maintenance_cost = self.quantity * 0.05
            return self.maintenance_cost
        else:
            return "We don't stock this product"</pre></li>
<li>In the next step, let’s create a factory class named <code>BranchFactory</code>, which creates the instance for the branch subclasses, <code>Brooklyn</code> or <code>Manhattan</code>:<pre>Class BranchFactory:
    def create_branch(self,branch,product,unit_price,
                      quantity,product_type):
        if str.upper(branch) == 'BROOKLYN':
            return Brooklyn(product,unit_price,
                            quantity,product_type)
        
        elif str.upper(branch) == 'MANHATTAN':
            return Manhattan(product,unit_price,
                             quantity,product_type)</pre></li>
<li>Now, let’s test the factory method by creating a function named <code>test_factory</code>:<pre>def test_factory(branch,product,unit_price,quantity,product_type):
    branchfactory = BranchFactory()
    branchobject = branchfactory.create_branch(branch,
            product,unit_price,quantity,product_type) 
    print(branchobject)
    print(branchobject.buy_product())
    print(branchobject.maintenance_cost())</pre></li>
<li>Let’s<a id="_idIndexMarker654"/> now call the <code>test_factory</code> function with inputs as <code>Brooklyn</code>, <code>Milk</code>, <code>10.5</code>, and <code>FMCG</code> as follows:<pre>test_factory('Brooklyn','Milk', 10,5,'FMCG')</pre></li>
</ol>
<p>The output for the preceding code is as follows:</p>
<pre><strong class="bold">&lt;__main__.Brooklyn object at 0x000002101D4569A0&gt;</strong>
<strong class="bold">(51.75, 'Milk', 'Discount')</strong>
<strong class="bold">101.25</strong></pre>
<ol>
<li value="9">Now, call the <code>test_factory</code> function with inputs as <code>manhattan</code>, <code>iPhone</code>, <code>1000</code>, <code>1</code>, and <code>Electronics</code> as follows:<pre>test_factory('manhattan','iPhone', 1000,1,'Electronics')</pre></li>
</ol>
<p>The output for the preceding code is as follows:</p>
<pre><strong class="bold">&lt;__main__.Manhattan object at 0x000002101D456310&gt;</strong>
<strong class="bold">(525.0, 'iPhone', 'Buy 1 Get 1')</strong>
<strong class="bold">0.05</strong></pre>
<p>Let’s connect the elements of this design pattern with their corresponding objects in the example with the following graphical representation:</p>
<div><div><img alt="Figure 13.4 – Factory pattern classes " height="546" src="img/Figure_13.4_B13426.jpg" width="1377"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Factory pattern classes</p>
<p>So, the<a id="_idIndexMarker655"/> factory pattern has been implemented by creating a factory class that instantiates the <code>Abstraction</code> subclasses. With this implementation, we have learned about the creational design pattern with an example.</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor170"/>Understanding the prototype method</h2>
<p>The <a id="_idIndexMarker656"/>prototype design pattern is also used to <a id="_idIndexMarker657"/>implement abstraction during the creation of a Python object. A prototype can be used by the end user to create a copy of an object of a class without the overhead of understanding the detailed implementation behind it. To explain this further and to implement this design pattern, our code needs the<a id="_idIndexMarker658"/> following elements:</p>
<ul>
<li><strong class="bold">Prototype class</strong>: This <a id="_idIndexMarker659"/>class has a method to clone or copy another Python object that has the implementation.</li>
<li><strong class="bold">Implementation class</strong>: This <a id="_idIndexMarker660"/>class has the<a id="_idIndexMarker661"/> actual implementation of the functionalities as attributes and methods.</li>
</ul>
<p>For this example, let’s<a id="_idIndexMarker662"/> implement using another scenario from <em class="italic">ABC Megamart</em>:</p>
<ol>
<li value="1">Let’s create a class named <code>Prototype</code> and define a method named <code>clone</code> to copy the Python object provided as input to the method:<pre>class Prototype:
    def __init__(self):
        self.cp = __import__('copy')
                
    def clone(self, objname):
        return self.cp.deepcopy(objname)</pre></li>
<li>Let’s now create an implementation class named <code>FMCG</code> and initialize a set of variables pertaining to the supplier details, and add a method to get the supplier details:<pre>class FMCG:
    def __init__(self,supplier_name,supplier_code,
    supplier_address,supplier_contract_start_date,\
    supplier_contract_end_date,supplier_quality_code):
        self.supplier_name = supplier_name
        self.supplier_code = supplier_code
        self.supplier_address = supplier_address
        self.supplier_contract_start_date = 
             supplier_contract_start_date
        self.supplier_contract_end_date = 
             supplier_contract_end_date
        self.supplier_quality_code = 
             supplier_quality_code
        
    def get_supplier_details(self):
        supplierDetails = {
           'Supplier_name': self.supplier_name, 
            'Supplier_code': self.supplier_code,
            'Supplier_address': self.supplier_address,
            'ContractStartDate': 
                 self.supplier_contract_start_date,
            'ContractEndDate': 
                 self.supplier_contract_end_date, 
            'QualityCode': self.supplier_quality_code
        }
        return supplierDetails</pre></li>
<li>In the<a id="_idIndexMarker663"/> next step, let’s create an object named <code>fmcg_supplier</code> for the <code>FMCG</code> class:<pre>fmcg_supplier = FMCG('Test Supplier','a0015','5093 9th Main Street, Pasadena,California, 91001', '05/04/2020', '05/04/2025',1)</pre></li>
<li>Let’s also create an object for the <code>Prototype</code> class, named <code>proto</code>:<pre>proto = Prototype()</pre></li>
<li>Now, we can directly clone the <code>fmcg_supplier</code> object without passing all the attributes of the <code>FMCG</code> class as input. To do this, we will make use of the <code>clone</code> method from the <code>Prototype</code> class:<pre>fmcg_supplier_reuse = proto.clone(fmcg_supplier)</pre></li>
<li>The <code>fmcg_supplier_reuse</code> object is a clone of the <code>fmcg_supplier</code> object<a id="_idIndexMarker664"/> and it is not the same object itself. This can be verified by looking at the ID of both of these objects:<pre>id(fmcg_supplier)</pre></li>
</ol>
<p>The output is as follows:</p>
<pre><strong class="bold">2268233820528</strong></pre>
<ol>
<li value="7">Similarly, we can also look at the ID of the cloned object:<pre>id(fmcg_supplier_reuse)</pre></li>
</ol>
<p>The output is as follows:</p>
<pre><strong class="bold">2268233819616</strong></pre>
<ol>
<li value="8">Let’s also verify that the cloned object can be modified without impacting the actual object:<pre>fmcg_supplier_reuse.supplier_name = 'ABC Supplier'
fmcg_supplier_reuse.get_supplier_details()</pre></li>
</ol>
<p>The output is as follows:</p>
<pre><strong class="bold">{'Supplier_name': 'ABC Supplier',</strong>
<strong class="bold"> 'Supplier_code': 'a0015',</strong>
<strong class="bold"> 'Supplier_address': '5093 9th Main Street, Pasadena,California, 91001',</strong>
<strong class="bold"> 'ContractStartDate': '05/04/2020',</strong>
<strong class="bold"> 'ContractEndDate': '05/04/2025',</strong>
<strong class="bold"> 'QualityCode': 1}</strong></pre>
<ol>
<li value="9">In the preceding output, we have modified the cloned object and this should not impact <a id="_idIndexMarker665"/>the original object. Let’s verify the original object:<pre>fmcg_supplier.get_supplier_details()</pre></li>
</ol>
<p>The output is as follows:</p>
<pre><strong class="bold">{'Supplier_name': 'Test Supplier',</strong>
<strong class="bold"> 'Supplier_code': 'a0015',</strong>
<strong class="bold"> 'Supplier_address': '5093 9th Main Street, Pasadena,California, 91001',</strong>
<strong class="bold"> 'ContractStartDate': '05/04/2020',</strong>
<strong class="bold"> 'ContractEndDate': '05/04/2025',</strong>
<strong class="bold"> 'QualityCode': 1}</strong></pre>
<p>So, the prototype pattern has been implemented by creating a <code>Prototype</code> class that copies the object of the implementation class. Now that you’ve understood this, let’s look at the singleton design pattern.</p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor171"/>Understanding the singleton pattern</h2>
<p>As the name <a id="_idIndexMarker666"/>suggests, the singleton<a id="_idIndexMarker667"/> pattern is a design pattern where we can limit the number of class instances created for a class while initializing the class itself. To explain this further and implement this design pattern, we need to develop the elements of <a id="_idIndexMarker668"/>the <strong class="bold">singleton class</strong> in our code. </p>
<p>Unlike the other<a id="_idIndexMarker669"/> patterns, this pattern has only one element – the singleton class. A singleton class will have a constraint set within its <code>init</code> method to limit the number of instances to one.</p>
<p>For this example, let’s<a id="_idIndexMarker670"/> implement using another scenario from <em class="italic">ABC Megamart</em>:</p>
<ol>
<li value="1">Let’s define a class named <code>SingletonBilling</code>. This class will have the attributes required to generate a bill for a product: <pre>class SingletonBilling:
    billing_instance = None
    product_name = 'Dark Chocolate'
    unit_price = 6
    quantity = 4
    tax = 0.054</pre></li>
<li>Let’s add a <a id="_idIndexMarker671"/>constraint in the <code>init</code> method of this class to limit the number of class instances to one:<pre>    def __init__(self):
        if SingletonBilling.billing_instance == None:
            SingletonBilling.billing_instance = self
        else:
            print("Billing can have only one 
                   instance")</pre></li>
<li>In the next step, let’s also add a <code>generate_bill</code> method to perform the function of generating a bill for a product based on the class attributes:<pre>    def generate_bill(self):
        total = self.unit_price * self.quantity 
        final_total = total + total*self.tax
        print('***********------------------
               **************')
        print('Product:', self.product_name)
        print('Total:',final_total)
        print('***********------------------
               **************')</pre></li>
<li>In the<a id="_idIndexMarker672"/> next step, we can instantiate the class object for the first time and call its <code>generate_bill</code> method:<pre>invoice1 = SingletonBilling()
invoice1.generate_bill()</pre></li>
</ol>
<p>The output is displayed as follows:</p>
<pre><strong class="bold">***********------------------**************</strong>
<strong class="bold">Product: Dark Chocolate</strong>
<strong class="bold">Total: 25.296</strong>
<strong class="bold">***********------------------**************</strong></pre>
<ol>
<li value="5">Let’s now test the singleton pattern by instantiating one more instance for the class:<pre>invoice2 = SingletonBilling()</pre></li>
</ol>
<p>The second instance could not be created for the class due to its singleton property. The output is as expected:</p>
<pre><strong class="bold">Billing can have only one instance</strong></pre>
<p>So, the singleton pattern has been implemented by restricting the singleton class from creating more than one instance. With this example, we have covered three types of creational design patterns and their implementation.</p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor172"/>Summary</h1>
<p>In this chapter, we have learned about the concept of structural and creational design patterns by applying some of these design patterns in Python 3. We implemented the bridge design pattern and understood each of its elements. We understood the facade design pattern and its various elements. We also implemented the proxy design pattern with an example. We also covered creational design patterns such as the factory method, prototype, and singleton patterns with their corresponding examples.</p>
<p>Similar to other chapters covered in this book, this chapter, which explains the second part of design patterns, also focused on metaprogramming and its impact on Python code.</p>
<p>In the next chapter, we will continue the code generation with some examples.</p>
</div>
</div></body></html>