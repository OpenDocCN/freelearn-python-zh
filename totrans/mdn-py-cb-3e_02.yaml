- en: '2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Statements and Syntax
  prefs: []
  type: TYPE_NORMAL
- en: Python syntax is designed to be simple. In this chapter, we’ll look at some
    of the most commonly used statements in the language as a way to understand the
    rules. Concrete examples can help clarify the language’s syntax.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover some of the basics of creating script files first. Then we’ll move
    on to looking at some of the more commonly used statements. Python only has about
    20 or so different kinds of imperative statements in the language. We’ve already
    looked at two kinds of statements in Chapter [1](ch005_split_000.xhtml#x1-170001),
    the assignment statement and the expression statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We’re actually executing a statement that contains only the evaluation of a
    function, print(). This kind of statement—where we evaluate a function or a method
    of an object—is common.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other kind of statement we’ve already seen is the assignment statement.
    Python has many variations on this theme. Most of the time, we’re assigning a
    single value to a single variable. When a function returns a tuple as a result,
    we can unpack that collection and assign more than one variable at the same time
    in a single assignment statement. It is done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The recipes in this chapter will look at the if, while, for, with, and try statements.
    We’ll also touch on a few of the simpler statements as we go, like pass, break,
    and raise.
  prefs: []
  type: TYPE_NORMAL
- en: 'In later chapters, we’ll look at other statements. Here’s a summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Statement | Chapter |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| def | Chapter [3](ch007_split_000.xhtml#x1-1610003) |'
  prefs: []
  type: TYPE_TB
- en: '| return | Chapter [3](ch007_split_000.xhtml#x1-1610003) |'
  prefs: []
  type: TYPE_TB
- en: '| import | Chapter [3](ch007_split_000.xhtml#x1-1610003) |'
  prefs: []
  type: TYPE_TB
- en: '| del | Chapter [4](ch008_split_000.xhtml#x1-2240004) |'
  prefs: []
  type: TYPE_TB
- en: '| class | Chapter [7](ch011_split_000.xhtml#x1-3760007) |'
  prefs: []
  type: TYPE_TB
- en: '| match | Chapter [8](ch012.xhtml#x1-4520008) |'
  prefs: []
  type: TYPE_TB
- en: '| type | Chapter [10](ch014.xhtml#x1-57300010) |'
  prefs: []
  type: TYPE_TB
- en: '| assert | Chapter [10](ch014.xhtml#x1-57300010) |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.1: Python Statements and Chapters'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Writing Python script and module files – syntax basics](ch006_split_000.xhtml#x1-850001)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Writing long lines of code](ch006_split_000.xhtml#x1-910002)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Including descriptions and documentation](ch006_split_000.xhtml#x1-1010003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Writing better docstrings with RST markup](ch006_split_000.xhtml#x1-1090004)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Designing complex if...elif chains](ch006_split_000.xhtml#x1-1170005)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Saving intermediate results with the := ”walrus” operator](ch006_split_001.xhtml#x1-1230006)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Avoiding a potential problem with break statements](ch006_split_001.xhtml#x1-1290007)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Leveraging exception matching rules](ch006_split_001.xhtml#x1-1350008)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Avoiding a potential problem with an except: clause](ch006_split_001.xhtml#x1-1410009)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Concealing an exception root cause](ch006_split_001.xhtml#x1-14600010)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Managing a context using the with statement](ch006_split_001.xhtml#x1-15200011)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll start by looking at the big picture – scripts and modules – and then we’ll
    move down into details of individual statements.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Writing Python script and module files – syntax basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The point of Python (and programming in general) is to create automated solutions
    to problems that involve data and processing. Further, the software we write is
    a kind of knowledge representation; this means clarity is perhaps the most important
    quality aspect of software.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we implement automated solutions by creating script files. These
    are the top-level, main programs of Python programming. In addition to main scripts,
    we may also create modules (and packages of modules) to help organize the software
    into intellectually manageable chunks. A script is a module; however, it has a
    distinct intent to do useful processing when started by the OS.
  prefs: []
  type: TYPE_NORMAL
- en: A key part of creating clear, readable Python files is making sure our code
    follows the widely adopted conventions.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we need to be sure to save our files in UTF-8 encoding. While ASCII
    encoding is still supported by Python, it’s a poor choice for modern programming.
    We’ll also need to be sure our editor uses spaces instead of the tab character.
    This is often a configuration setting in programming editors. Using Unix newlines
    is also helpful for portability.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To edit Python scripts, we’ll need a good programming editor. It’s nearly impossible
    to suggest just one. So we’ll suggest a few.
  prefs: []
  type: TYPE_NORMAL
- en: The JetBrains PyCharm editor has numerous features. The community edition version
    is free. See [https://www.jetbrains.com/pycharm/download/](https://www.jetbrains.com/pycharm/download/).
  prefs: []
  type: TYPE_NORMAL
- en: ActiveState has Komodo IDE, which is also very sophisticated. The Komodo Edit
    version is free and does some of the same things as the full Komodo IDE. See [http://komodoide.com/komodo-edit/](http://komodoide.com/komodo-edit/).
  prefs: []
  type: TYPE_NORMAL
- en: Notepad++ is good for Windows developers. See [https://notepad-plus-plus.org](https://notepad-plus-plus.org).
  prefs: []
  type: TYPE_NORMAL
- en: BBEdit is very nice for macOS X developers. See [http://www.barebones.com/products/bbedit/](http://www.barebones.com/products/bbedit/).
    Sublime is also popular on macOS X. See [https://www.sublimetext.com](https://www.sublimetext.com).
  prefs: []
  type: TYPE_NORMAL
- en: For Linux developers, there are several built-in editors, including Vim and
    gedit. Since Linux tends to be biased toward developers, the editors available
    are all suitable for writing Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is helpful is to have two windows open while working:'
  prefs: []
  type: TYPE_NORMAL
- en: An editor to create the final script or module file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A terminal session with Python’s >>> prompt, where we can try things out to
    see what works and what doesn’t.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most editors recognize the .py extension and provide appropriate formatting
    based on [PEP-8](https://peps.python.org/pep-0008/). This generally includes the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The file encoding should be UTF-8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indentation should be four spaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want the Tab key on the keyboard to insert spaces instead of the tab character,
    \t.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the editor is configured, we can write a script file that other people
    can easily use or extend.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s how we create a script file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line of most Python script files looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sets an association between the file you’re writing and Python. If the
    file’s mode is set to executable with the bash chmod command, and the directory
    is on the OS PATH list, the script will be a first-class application, as usable
    as any of the built-in commands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For Windows, the filename-to-program association is done through a setting in
    the Default Programs control panel. Find the panel for Set Associations, and make
    sure .py files are bound to the Python program. This is often set by the installer,
    and we rarely need to change it or set it manually.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After the preamble, convention suggests we include a triple-quoted block of
    text. This is the documentation string (called a docstring) for the file we’re
    going to create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because Python triple-quoted strings can be indefinitely long, feel free to
    write as much as necessary. This should be the primary vehicle for describing
    the script or library module. This can even include examples of how it works.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now comes the interesting part of the script: the part that really does something.
    We can write all the statements we need to get the job done. For now, we’ll use
    this as a placeholder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This isn’t much, but at least the script does something. It’s common to create
    function and class definitions, as well as to write statements to use the functions
    and classes to do things.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For our first, simple script, all of the statements must begin at the left margin
    and must be complete on a single line. There are many Python statements that have
    blocks of statements nested inside them. These internal blocks of statements will
    be indented to clarify their scope. Generally—because we set indentation to four
    spaces—we can hit the Tab key to properly indent the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 2.1.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike other languages, there’s very little boilerplate in Python. There’s
    only one line of overhead and even the #!/usr/bin/env python3 line is generally
    optional.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do we set the encoding to UTF-8? While the language was originally designed
    to work using just the original 128 ASCII characters, we often find that ASCII
    is limiting. This is legal Python if we save our file in UTF-8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to be consistent when choosing between spaces and tabs in Python.
    They are both more or less invisible, and mixing them up can easily lead to errors
    when trying to run the script. Spaces are suggested.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial #! line is a comment. Because the two characters are sometimes
    called sharp and bang, the combination is called ”shebang.” Everything between
    a # and the end of the line is ignored. The Linux loader (a program named execve)
    looks at the first few bytes of a file to see what the file contains. These first
    few bytes are sometimes called magic bytes because the loader’s behavior seems
    magical. When present, this two-character sequence of #! is followed by the path
    to the program responsible for processing the rest of the data in the file. We
    prefer to use /usr/bin/env to start the Python program for us. We can leverage
    the env program to make Python-specific environment settings.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python Standard Library documents are derived, in part, from the documentation
    strings present in the module files. It’s common practice to write sophisticated
    docstrings in modules, packages, and scripts. There are tools like pydoc and Sphinx
    that can reformat the module docstrings into elegant documentation. We’ll look
    at this in the [Writing better docstrings with RST markup](ch006_split_000.xhtml#x1-1090004)
    recipe, as well as the [Using Sphinx autodoc to create the API reference](ch021.xhtml#x1-9270003)
    recipe in Chapter [17](ch021.xhtml#x1-91400017).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, unit test cases can be included in the docstrings. Tools like
    doctest can extract examples from the document strings and execute the code to
    see if the answers in the documentation match the answers found by running the
    code. This is the subject of many recipes in Chapter [15](ch019_split_000.xhtml#x1-79400015).
    Many examples in this book are validated by doctest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Triple-quoted documentation strings are preferred over # comments. While all
    text between # and the end of the line is ignored, this is limited to a single
    line; the conventional approach is to use it sparingly. A docstring can be of
    indefinite size; they are used widely.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s another bit of overhead that’s sometimes included. The Vim and gedit
    editors let us keep edit preferences in the file. This is called a modeline. Here’s
    a typical modeline that’s useful for Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This makes sure any tab characters will be transformed into eight spaces; when
    we hit the Tab key, we’ll shift four spaces. This is widely used because tab characters
    are traditionally indented eight spaces, and this replacement is likely to create
    proper indentation. This setting is embedded in the code; we don’t have to do
    any Vim setup to apply these settings to our Python script files.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at how to write useful document strings in the [Including descriptions
    and documentation](ch006_split_000.xhtml#x1-1010003) and [Writing better docstrings
    with RST markup](ch006_split_000.xhtml#x1-1090004) recipes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on suggested style, see [PEP-8](https://www.python.org/dev/peps/pep-0008/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.2 Writing long lines of code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many times when we need to write lines of code that are so long that
    they’re very hard to read. Many people like to limit the length of a line of code
    to 80 characters or fewer. It’s a well-known principle of graphic design that
    a narrower area of text is easier to read. See [http://webtypography.net/2.1.2](http://webtypography.net/2.1.2)
    for a deeper discussion of line width and readability.
  prefs: []
  type: TYPE_NORMAL
- en: While fewer characters per line is easier on the eyes, our code can refuse to
    cooperate with this principle. How can we break long Python statements into more
    manageable pieces?
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say we’ve got something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code includes a long formula, and a long format string into which we’re
    injecting values. This looks bad when typeset in a book; the f-string line may
    be broken incorrectly. It may look bad on our screen when trying to edit this
    script. (For more on f-strings, see [Building complicated strings with f-strings](ch005_split_000.xhtml#x1-410004)
    in Chapter [1](ch005_split_000.xhtml#x1-170001).)
  prefs: []
  type: TYPE_NORMAL
- en: We can’t haphazardly break Python statements into chunks. The syntax rules are
    clear that a statement must be complete on a single logical line.
  prefs: []
  type: TYPE_NORMAL
- en: The term ”logical line” provides a hint as to how we can proceed. Python makes
    a distinction between logical lines and physical lines; we’ll leverage these syntax
    rules to break up long statements.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python gives us several ways to wrap long statements so they’re more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use \ at the end of a line to continue the logical line onto the next
    physical line. While this always works, it can be hard to spot the \.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python has a rule that a statement can span multiple logical lines because
    the (), [], and {} characters must balance. Further, we can also exploit the way
    Python automatically concatenates adjacent string literals to make a single, longer
    string literal: ("a" "b") is the same as "ab".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, we can decompose a statement into multiple statements by assigning
    intermediate results to separate variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll look at each one of these in separate parts of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using a backslash to break a long statement into logical lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If there’s a meaningful break, insert the \ to separate the statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For this to work, the \ must be the last character on the line. An extra space
    after the \ is fairly hard to see; some care is required. The [PEP-8](https://www.python.org/dev/peps/pep-0008/)
    proposal provides guidelines on formatting and tends to discourage this technique.
  prefs: []
  type: TYPE_NORMAL
- en: In spite of this being a little hard to see, the \ can always be used. Think
    of it as the last resort in making a line of code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Using the () characters to break a long statement into sensible pieces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Write the whole statement on one line, even if it’s confusing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the extra () characters, which don’t change the value but allow breaking
    the expression into multiple lines:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Break the line inside the () characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The matching () characters technique is quite powerful and will work in a wide
    variety of cases. This is widely used and highly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: We can almost always find a way to add extra () characters to a statement. In
    rare cases when we can’t add () characters, we can fall back on using \ to break
    the statement into sections.
  prefs: []
  type: TYPE_NORMAL
- en: Using string literal concatenation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can combine the () characters with another rule that joins adjacent string
    literals. This is particularly effective for long, complex format strings:'
  prefs: []
  type: TYPE_NORMAL
- en: Wrap the long string value in the () characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Break the string into meaningful substrings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can always break a long string literal into adjacent pieces. We can then
    use as many physical line breaks as we need. With string literal values, no explicit
    operator is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning intermediate results to separate variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s the context for this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can break this into three intermediate values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Identify sub-expressions in the overall expression. Assign these to variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the sub-expressions with the variables that were created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can always take a sub-expression and assign it to a variable, and use the
    variable everywhere the sub-expression was used. The 15*sqrt(5) product is repeated;
    this, too, is a good candidate for refactoring the expression.
  prefs: []
  type: TYPE_NORMAL
- en: We didn’t give these variables descriptive names. In some cases, the sub-expressions
    have some semantics that we can capture with meaningful names.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python language manual makes a distinction between logical lines and physical
    lines. A logical line contains a complete statement. It can span multiple physical
    lines through a technique called line joining. The manual identifies two techniques:
    explicit line joining and implicit line joining.'
  prefs: []
  type: TYPE_NORMAL
- en: The use of \ for explicit line joining is sometimes helpful. Because it’s easy
    to overlook, it’s not generally encouraged. [PEP-8](https://www.python.org/dev/peps/pep-0008/)
    suggests this should be the method of last resort.
  prefs: []
  type: TYPE_NORMAL
- en: The use of () for implicit line joining can be used in many cases. It often
    fits semantically with the structure of the expressions, so it is encouraged.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Expressions are used widely in a number of Python statements. Any expression
    can have () characters added. This gives us a lot of flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, however, a few places where we may have a long statement that does
    not specifically involve a long expression. The most notable example of this is
    the import statement—it can become long, but doesn’t use any expressions. In spite
    of not having a proper expression, it does, however, still permit the use of ().
    The following example shows we can surround a very long list of imported names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: While the () characters are emphatically not part of an expression, they are
    part of the syntax available to help make the statement more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implicit line joining also applies to the matching [] and {} characters. These
    apply to collection data structures that we’ll look at in Chapter [4](ch008_split_000.xhtml#x1-2240004).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.3 Including descriptions and documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have a useful script, we often need to leave notes for ourselves—and
    others—on what it does, how it solves some particular problem, and when it should
    be used. This recipe contains a suggested outline to help make the documentation
    reasonably complete.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we’ve used the [Writing Python script and module files – syntax basics](ch006_split_000.xhtml#x1-850001)
    recipe to start a script file, we’ll have a small documentation string in place.
    We’ll expand on this documentation string in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There are other places where documentation strings should be used. We’ll look
    at these additional locations in Chapter [3](ch007_split_000.xhtml#x1-1610003)
    and Chapter [7](ch011_split_000.xhtml#x1-3760007).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two general kinds of modules for which we’ll be writing summary docstrings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Library modules: These files will contain mostly function definitions as well
    as class definitions. The docstring summary should focus on the definitions in
    the module, describing what the module is. The docstring can provide examples
    of using the functions and classes that are defined in the module. In Chapter [3](ch007_split_000.xhtml#x1-1610003),
    and Chapter [7](ch011_split_000.xhtml#x1-3760007), we’ll look more closely at
    these modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scripts: These are files that we generally expect will do some real work. The
    docstring should describe what the module does and how to use it. The options,
    environment variables, and configuration files are important parts of this docstring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will sometimes create files that contain a little of both. This requires
    a proper balance between doing and being.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step in writing documentation is the same for both library modules
    and scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a brief summary of what the script or module is or does. The summary doesn’t
    need to dig too deeply into how it works. Like a lede in a newspaper article,
    it introduces the who, what, when, where, how, and why of the module. Details
    will follow in the body of the docstring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It can help to avoid needless phrases like This script. We might start our
    module docstring like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We’ll separate the other steps based on the general focus of the module.
  prefs: []
  type: TYPE_NORMAL
- en: Writing docstrings for scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we document a script, we need to focus on the needs of a person who will
    use the script.
  prefs: []
  type: TYPE_NORMAL
- en: Start as shown earlier, creating a summary sentence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sketch an outline for the rest of the docstring. We’ll be using ReStructuredText
    (RST) markup. Write the topic on one line, then put a line of = under the topic
    to make it a proper section title. Remember to leave a blank line between each
    topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Topics may include:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'SYNOPSIS: A summary of how to run this script. If the script uses the argparse
    module to process command-line arguments, the help text produced by argparse is
    the ideal synopsis text. Other installable tools like click or invoke can also
    produce elegant synopsis text. (See [Using argparse to get command-line input](ch010.xhtml#x1-3490004)
    in Chapter [6](ch010.xhtml#x1-3300006).)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DESCRIPTION: An explanation of what this script does.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OPTIONS: This provides the details of all parameters and options. (See [Using
    argparse to get command-line input](ch010.xhtml#x1-3490004) in Chapter [6](ch010.xhtml#x1-3300006).)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ENVIRONMENT: This provides the place to describe the environment variables
    and what they mean. (See [Using the OS environment settings](ch010.xhtml#x1-3670007)
    in Chapter [6](ch010.xhtml#x1-3300006).)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FILES: The names of files that are created or read by a script are very important
    pieces of information.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'EXAMPLES: Some examples of using the script are always helpful. In some cases,
    this is the only part a user will read.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SEE ALSO: Any related scripts or background information.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Other topics that might be interesting include EXIT STATUS, AUTHOR, BUGS, REPORTING
    BUGS, HISTORY, or COPYRIGHT. In some cases, advice on reporting bugs, for instance,
    doesn’t really belong in a module’s docstring, but rather elsewhere in the project’s
    GitHub or SourceForge pages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fill in the details under each topic. It’s important to be accurate. Since the
    documentation is in the same file as the code, it’s easier to be correct, complete,
    and consistent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an example of a docstring for a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the SYNOPSIS section, we used :: as a separate paragraph. In the EXAMPLES
    section, we used :: at the end of a paragraph. Both versions are hints to the
    RST processing tools that the indented section that follows should be typeset
    as code. See Chapter [17](ch021.xhtml#x1-91400017), [Documentation and Style](ch021.xhtml#x1-91400017).'
  prefs: []
  type: TYPE_NORMAL
- en: Writing docstrings for library modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we document a library module, we need to focus on the needs of a programmer
    who will import the module to use it in their code:'
  prefs: []
  type: TYPE_NORMAL
- en: Sketch an outline for the rest of the docstring. We’ll be using RST markup.
    Write the topic on one line. Include a line of = characters under each topic to
    make the topic into a proper heading. Remember to leave a blank line between each
    paragraph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start as shown previously, creating a summary sentence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DESCRIPTION: A summary of what the module contains and why the module is useful'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MODULE CONTENTS: The classes and functions defined in this module'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'EXAMPLES: Examples of using the module'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fill in the details for each topic. The module contents may be a long list of
    class or function definitions. The docstring should be a summary. Within each
    class or function, we’ll have a separate docstring with the details for that item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2.3.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the decades, the man page outline has evolved to contain a complete description
    of Linux commands. This general approach to writing documentation has proven useful
    and resilient. We can capitalize on a large body of experience, and structure
    our documentation to follow the man page model.
  prefs: []
  type: TYPE_NORMAL
- en: We want to prepare module docstrings that can be used by the Sphinx Python documentation
    generator (see [http://www.sphinx-doc.org/en/stable/](http://www.sphinx-doc.org/en/stable/)).
    This is the tool used to produce Python’s documentation files. The autodoc extension
    in Sphinx will read the docstring headers on our modules, classes, and functions
    to produce the final documentation that looks like other modules in the Python
    ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RST markup has a simple, central syntax rule: paragraphs are separated by blank
    lines.'
  prefs: []
  type: TYPE_NORMAL
- en: This rule makes it easy to write documents that can be examined by the various
    RST processing tools and reformatted to look nice.
  prefs: []
  type: TYPE_NORMAL
- en: It can be challenging to write good software documentation. There’s a broad
    chasm between too little information and documentation that recapitulates details
    apparent from looking at the code.
  prefs: []
  type: TYPE_NORMAL
- en: What’s important is to focus on the needs of a person who doesn’t know too much
    about the software or how it works, but can read the Python code. Provide this
    semi-knowledgeable user with the information they need to understand what the
    software does and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We look at additional techniques in [Writing better docstrings with RST markup](ch006_split_000.xhtml#x1-1090004).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we’ve used the [Writing Python script and module files – syntax basics](ch006_split_000.xhtml#x1-850001)
    recipe, we’ll have put a documentation string in our script file. When we build
    functions in Chapter [3](ch007_split_000.xhtml#x1-1610003), and classes in Chapter [7](ch011_split_000.xhtml#x1-3760007),
    we’ll look at other places where documentation strings can be placed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [http://www.sphinx-doc.org/en/stable/](http://www.sphinx-doc.org/en/stable/)
    for more information on Sphinx.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more background on the man page outline, see [https://en.wikipedia.org/wiki/Man_page](https://en.wikipedia.org/wiki/Man_page).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.4 Writing better docstrings with RST markup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have a useful script, we often need to leave notes on what it does,
    how it works, and when it should be used. Many tools for producing documentation,
    including Docutils, work with RST markup. This allows us to write plain text documentation.
    It can include some special punctuation to pick a bold or italic font variant
    to call attention to details. In addition, RST permits organizing content via
    lists and section headings.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Including descriptions and documentation](ch006_split_000.xhtml#x1-1010003)
    recipe, we looked at putting some basic documentation into a module. We’ll look
    at a few of the RST formatting rules for creating readable documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start with an outline of the key point, creating RST section titles to organize
    the material. A section title has a one-line title followed by a line of underline
    characters using =, -, ^, ~ as long as the title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A heading will look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The heading text is on one line and the underlining characters are on the next
    line. This must be surrounded by blank lines. There can be more underline characters
    than title characters, but never fewer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The RST tools will infer our chosen pattern of using underlining characters.
    As long as the underline characters are used consistently, the docutil tools will
    detect the document’s structure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When starting out, it can help to have an explicit standard for heading underlines:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| Character | Level |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| = | 1 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| - | 2 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ^ | 3 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ~ | 4 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Fill in the various paragraphs. Paragraphs (including the section titles) are
    separated by at least one empty line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the programming editor has a spell checker, use it. Doing this can be frustrating
    because the code samples often have abbreviations that fail spell checking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2.4.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Docutils conversion programs will examine the document, looking for sections
    and body elements. A section is identified by a title. The underlines are used
    to organize the sections into a properly nested hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'A properly nested document might have the following sequence of underline characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When an HTML file is created from the documentation it will have <h1>, <h2>,
    and <h3> tags for the various levels. Creating a LaTeX file requires some additional
    configuration choices, but the common Article template means the resulting document
    will use \section, \subsection, and \subsubsection headings. These final presentation
    choices aren’t our primary concern when writing; the most important point is to
    use proper underlines to reflect the desired organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several different kinds of body elements the RST parser can recognize.
    We’ve shown a few. A more complete list includes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Paragraphs of text: These might use inline markup for different kinds of emphasis
    or highlighting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Literal blocks: These are introduced with :: and indented with four spaces.
    They may also be introduced with the .. parsed-literal:: directive. A doctest
    block is indented with four spaces and includes the Python >>> prompt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lists, tables, and block quotes: We’ll look at these later. These can contain
    other body elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Footnotes: These are special paragraphs. When rendered, they may be displayed
    at the bottom of a page or at the end of a section. These can also contain other
    body elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hyperlink targets, substitution definitions, and RST comments: These are more
    specialized text items that we won’t look at closely here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.4.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the Including descriptions and documentation recipe, we looked at several
    different kinds of body elements we might use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Paragraphs of text: This is a block of text surrounded by blank lines. Within
    these, we can make use of inline markup to emphasize words or phrases. We’ll look
    at inline markup in the [Writing better docstrings with RST markup](ch006_split_000.xhtml#x1-1090004)
    recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lists: These are paragraphs that begin with something that looks like a number
    or a bullet. We might have paragraphs like this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Other characters can be used at the start of the line, but - and * seem to be
    the most common choices.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Numbered lists: There are a variety of patterns that are recognized. This includes
    leading digits or letters followed by . or ). Using # instead of a digit or letter
    will continue from the previous paragraph value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Literal blocks: A code sample is presented literally, without looking for RST
    elements. The text for this must be indented. A handy prefix is ::. A .. code-block::
    directive is also possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Directives: A directive is a paragraph that generally looks like .. directive::.
    It may have some content that’s indented to be contained within the directive.
    It might look like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The .. important:: text is the directive. This is followed by text indented
    within the directive.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docutils has several built-in directives. The Sphinx tool adds a large number
    of additional directives with a variety of features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most commonly used directives are the admonitions: attention, caution,
    danger, error, hint, important, note, tip, warning, and a generic admonition.
    These are compound body elements because they have nested text within them. Above,
    we provided an example of the important admonition.'
  prefs: []
  type: TYPE_NORMAL
- en: Using inline markup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within a paragraph, we have several forms of inline markup we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: We can surround a word or phrase with * for *emphasis*. This is commonly typeset
    as italic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can surround a word or phrase with ** for **strong**. This is commonly typeset
    as bold.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We surround references with single back-ticks, ‘. Links are followed by an
    underscore, _. We might use ‘section title‘_ to refer to a specific section within
    a document. We don’t generally need to put any markup around URLs. The Docutils
    tools recognize these. Sometimes we want a word or phrase to be shown and the
    URL concealed. We can use this: ‘the \textbf{Sphinx} documentation <http://www.sphinx-doc.org/en/stable/>‘_.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can surround code-related words with a double back-tick, ‘‘, to make them
    look like ‘‘code‘‘. This will be typeset as code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There’s also a more general technique called a role. A role starts with :word:
    as the role name, followed by the applicable word or phrase in single ‘ back-ticks.
    A text role looks like this: :strong:‘this‘.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of standard role names, including :emphasis:, :literal:,
    :code:, :math:, :pep-reference:, :rfc-reference:, :strong:, :subscript:, :superscript:,
    and :title-reference:. Some of these are also available with simpler markup like
    *emphasis* or **strong**.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can define new roles with a directive. If we want to do very sophisticated
    processing, we can provide the Docutils tool with class definitions for handling
    new roles. This allows us to tweak the way our document is processed.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on RST syntax, see [http://docutils.sourceforge.net](http://docutils.sourceforge.net).
    This includes a description of the Docutils tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For information on Sphinx Python Documentation Generator, see [http://www.sphinx-doc.org/en/stable/](http://www.sphinx-doc.org/en/stable/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.5 Designing complex if...elif chains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, our scripts will involve a number of choices. Sometimes the choices
    are simple, and we can judge the quality of the design with a glance at the code.
    In other cases, the choices are more complicated, and it’s not easy to determine
    whether or not our if statements are designed properly to handle all of the conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In the simplest case, we have one condition, C, and its inverse, ¬C. These are
    the two conditions for an if...else statement. One condition, C, is stated in
    the if clause; the inversion condition, ¬C, is implied in the else clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'This follows the Law of the Excluded Middle: we’re claiming there’s no missing
    alternative between the two conditions, C and ¬C. For a complex condition, though,
    this can be difficult to visualize.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It may not be immediately obvious, but we’ve omitted a number of possible alternatives.
    The weather and plan variables have four different combinations of values. One
    of the conditions is stated explicitly, the other three are assumed:'
  prefs: []
  type: TYPE_NORMAL
- en: weather == RAIN and plan == GO_OUT. Bringing an umbrella seems right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: weather != RAIN and plan == GO_OUT. Bringing sunglasses seems appropriate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: weather == RAIN and plan != GO_OUT. If we’re staying in, then neither accessory
    seems right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: weather != RAIN and plan != GO_OUT. Again, the accessory question seems moot
    if we’re not going out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we be sure we haven’t missed anything? How can we be sure we have not
    conflated too many things into a condition that’s assumed instead of being stated?
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at a concrete example of an if...elif chain. In the casino game
    of Craps, there are a number of rules that apply to a roll of two dice. These
    rules apply on the first roll of the game, called the come-out roll:'
  prefs: []
  type: TYPE_NORMAL
- en: 2, 3, or 12 is craps, which is a loss for most bets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7 or 11 is a winner for most bets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining numbers establish a point. The dice-rolling continues based on
    another set of rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll use this set of three conditions as an example for looking at this recipe
    because it has a potentially vague clause in it.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we write an if statement, even when it appears trivial, we need to be sure
    that all conditions are covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enumerate the conditions we know. In our example, we have three rules: the
    (2, 3, 12) rule, the (7, 11) rule, and a vague statement of ”the remaining numbers.”
    This can form a first draft of an if statement.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Determine the universe of all possible alternatives. For this example, there
    are 11 alternative outcomes: the numbers from 2 to 12, inclusive.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compare the various if and elif conditions, C, with the universe of alternatives,
    U. There are three possible design patterns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have more if conditions in the code than are possible in the universe of
    alternatives, C ⊂ U. The most common cause is failing to completely enumerate
    all possible alternatives in the universe. We might, for example, have modeled
    dice using 0 to 5 instead of 1 to 6\. The universe of alternatives appears to
    be the values from 0 to 10, yet there are conditions for 11 and 12.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have gaps in the conditions in our code, U ∖ C≠∅. The most common cause of
    alternatives in the universe without a clearly-stated if condition is failing
    to fully understand the conditions in the code. We might, for example, have enumerated
    the values as two tuples instead of sums. The numbers 2, 3 and 12 are defined
    by a number of pairs, including (1, 1), (1, 2), and (6, 6). It’s possible to overlook
    the condition (2, 1), leaving this untested by any clause of the if statement.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We can prove there’s a match between conditions expressed in the code and the
    universe of alternatives, U ≡ C. This is ideal. The universe of all possible alternatives
    matches all the conditions in the if and elif clauses of the statement.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, it’s easy to enumerate all of the possible alternatives. In
    other cases, it can take some careful reasoning to understand any gaps or omissions.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have a vague term, remaining numbers, which we can replace
    with the list of values (4, 5, 6, 8, 9, 10). Supplying a list removes any possible
    gaps and doubts.
  prefs: []
  type: TYPE_NORMAL
- en: When there are exactly two alternatives, we can write a condition expression
    for one of the alternatives. The other condition can be implied; an if and else
    will work.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have more than two alternatives, we can use this recipe to write a
    chain of if and elif statements, one statement per alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write an if ... elif ... elif chain that covers all of the known alternatives.
    For our example, it might start like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an else clause that raises an exception, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This extra else gives us a way to positively identify when a logic problem is
    found. We can be sure that any design error we made will lead to a conspicuous
    problem when the program runs. Ideally, we’ll find any problems while we’re unit
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, it is clear that all 11 alternatives are covered by the if statement
    conditions. The extra else can’t ever be used. Not all real-world problems have
    this kind of easy proof that all the alternatives are covered by conditions. It
    can help to provide a noisy failure mode.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our goal is to be sure that our program works reliably. While testing helps,
    we can still have the same wrong assumptions when doing design and creating test
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: While rigorous logic is essential, we can still make mistakes. Further, someone
    doing ordinary software maintenance might introduce an error. Adding a new feature
    to a complex if statement is a potential source of problems.
  prefs: []
  type: TYPE_NORMAL
- en: This Else-Raise design pattern forces us to be explicit for each and every condition.
    Nothing is assumed. As we noted previously, any error in our logic will be uncovered
    if the exception gets raised.
  prefs: []
  type: TYPE_NORMAL
- en: Crashing with an exception is sensible behavior in the presence of a design
    problem. While an alternative is to write a message to an error log, a program
    with this kind of profound design flaw should be viewed as fatally broken.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many cases, we can derive an if...elif...elif chain from an examination of
    the desired post condition at some point in the program’s processing. For example,
    we may need a statement that establishes something like m is equal to the larger
    of a or b.
  prefs: []
  type: TYPE_NORMAL
- en: (For the sake of working through the logic, we’ll avoid Python’s handy m = max(a, b),
    and focus on the way we can compute a result from exclusive choices.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can formalize the final condition like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![(m = a ∨m = b)∧ m ≥ a∧ m ≥ b ](img/file12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can work backward from this final condition, by writing the goal as an assert
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the goal stated, we can identify statements that lead to that goal.
    Clearly, assignment statements like m = a or m = b would be appropriate, but each
    of these works only under limited conditions.
  prefs: []
  type: TYPE_NORMAL
- en: We can derive the precondition that shows when these statements should be used.
    The preconditions for an assignment statement will be written in if and elif expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to use the statement m = a when a >= b. Similarly, we need to use the
    statement m = b when b >= a. Rearranging logic into code gives us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that our universe of conditions, U = {a ≥ b,b ≥ a}, is complete; there’s
    no other possible relationship. Also notice that in the edge case of a = b, we
    don’t actually care which assignment statement is used. Python will process the
    decisions in order and will execute m = a. The fact that this choice is consistent
    shouldn’t have any impact on our design of the if...elif...elif chain. We can
    design the conditions without regard to the order of evaluation of the clauses.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is somewhat similar to the syntactic problem of the ”dangling else.” See
    [https://docs.oracle.com/javase/specs/jls/se9/html/jls-14.html](https://docs.oracle.com/javase/specs/jls/se9/html/jls-14.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This isn’t the same problem; Python’s indentation removes the ”dangling else”
    syntax problem. This is an adjacent semantic problem of trying to be sure that
    all conditions are properly accounted for in a complex if...elif...elif chain.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2.6 Saving intermediate results with the := ”walrus” operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes we’ll have a complex condition where we want to preserve an expensive
    intermediate result for later use. Imagine a condition that involves a complex
    calculation; the cost of computing is high measured in time, input-output operations,
    memory resources, or all three.
  prefs: []
  type: TYPE_NORMAL
- en: An example includes doing repetitive searches using the Regular Expression (re)
    package. A match() method can do quite a bit of computation before returning either
    a Match object or a None object to show the pattern wasn’t found. Once this computation
    is completed, we may have several uses for the result, and we emphatically do
    not want to perform the computation again. Often, the initial use is the simple
    check to see if the result is a Match object or None.
  prefs: []
  type: TYPE_NORMAL
- en: This is an example where it can be helpful to assign a name to the value of
    an expression and also use the expression in an if statement. We’ll look at how
    to use the ”assignment expression” or ”walrus” operator. It’s called the walrus
    because the assignment expression operator, :=, looks like the face of a walrus
    to some people.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s a summation where—eventually—each term becomes so small that there’s
    no point in continuing to add it to the overall total:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∑ (--1---)2 0≤n<∞ 2n+ 1 ](img/file13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In effect, this is something like the following summation function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: What’s not clear is the question of how many terms are required. In the example,
    we’ve summed 20,000 values. But what if 16,000 are enough to provide an accurate
    answer?
  prefs: []
  type: TYPE_NORMAL
- en: 'We don’t want to write a summation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This example repeats an expensive computation, (1/(2*n+1))**2\. We can avoid
    processing that includes this kind of time-wasting overhead by using the walrus
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we isolate an expensive operation that’s part of a conditional test.
    In this example, the variable term is used to hold the expensive result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rewrite the assignment statement to use the := assignment operator. This replaces
    the simple condition of the if statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an else condition to break out of the for statement if no more terms are
    needed. Here’s the results of these two steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we changed the summation variable. In the previous step of the recipe,
    it was p. In this step, it’s q. This permits easy side-by-side comparisons to
    be sure the results are still correct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The assignment expression := lets us do two things in the if statement.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The assignment expression operator := saves an intermediate result. The operator’s
    result value is the same as the right-hand side operand. This means that the expression
    a + (b := c+d) is the same as the expression a+(c+d). The difference between the
    expression a + (b := c+d) and the expression a+(c+d) is the side-effect of setting
    the value of the b variable partway through the evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: An assignment expression can be used in almost any kind of context where expressions
    are permitted in Python. The most common cases are if statements. Another good
    idea is inside a while condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'They’re also forbidden in a few places. They cannot be used as the operator
    in an expression statement. We’re specifically prohibited from writing a := 2
    as a statement: there’s a perfectly good assignment statement for this purpose
    and an assignment expression, while similar in intent, is potentially confusing.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.6.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can do some more optimization of our infinite summation example, shown earlier
    in this recipe. The use of a for statement and a range() object seems simple.
    The problem is that we want to end the for statement early—when the terms being
    added are so small that they have no significant change in the final sum.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can combine the early exit with the term computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We’ve used a while statement with the assignment expression operator. This will
    compute a value using (1/(2*n+1))**2, and assign this to the term variable. If
    the value is significant, we’ll add it to the sum, r, and increment the value
    for the n variable. If the value assigned to term is too small to be significant,
    the while statement will end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example, showing how to compute running sums of a collection
    of values. This looks forward to concepts in Chapter [4](ch008_split_000.xhtml#x1-2240004).
    Specifically, this shows a list comprehension built using the assignment expression
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We’ve started with some data, in the data variable. This might be minutes of
    exercise each day for most of a week. The value of the final running_sum variable
    is a list object, built by evaluating the expression (total := total + d) for
    each value, d, in the data variable. Because the assignment expression changes
    the value of the total variable, the resulting list is the result of each new
    value being accumulated.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For details on assignment expression, see [PEP-572](https://www.python.org/dev/peps/pep-0572/),
    where the feature was first described.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.7 Avoiding a potential problem with break statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The common way to understand a for statement is that it creates a for all condition.
    At the end of the statement, we can assert that, for all items in a collection,
    the processing in the body of the statement has been done.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t the only meaning a for statement can have. When the break statement
    is used inside the body of a for statement, it changes the semantics to there
    exists. When the break statement leaves the for (or while) statement, we can assert
    there exists at least one item that caused the enclosing statement to end.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a side issue here. What if the for statement ends without executing
    the break statement? Either way, we’re at the statement after the for statement.
    The condition that’s true upon leaving a for or while statement with a break statement
    can be ambiguous. We can’t easily tell; this recipe gives some design guidance.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is magnified when we have multiple break statements, each with its
    own condition. How can we minimize the problems created by having these complicated
    conditions for leaving a for or while statement?
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When parsing configuration files, we often need to find the first occurrence
    of a : or = character in a string. The property file format uses a property name
    and : or = followed by a value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding the punctuation mark is an example of a there exists modification to
    a for statement. We don’t want to process all characters; we want to know where
    the leftmost : or = character is found.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the sample data we’re going use as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a small for statement to locate the leftmost : or = character in the
    sample string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When the = character is found, the break statement ends the for statement. The
    value of the position variable shows where the desired character was found.
  prefs: []
  type: TYPE_NORMAL
- en: What about the following edge case?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is awkwardly wrong: the y character got dropped from the value of
    name. Why did this happen? And, more importantly, how can we make the condition
    at the end of the for statement clearer?'
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every statement establishes a post-condition. When designing a for or while
    statement, we need to articulate the condition that should be true at the end
    of the statement. Ideally, the post-condition is something simple like text[position] in ’=:’.
    However, in the case where there’s no = or : in the given text, the overly simple
    post-condition can’t be true.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the for statement, one of these two things are true:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Either the character with the index of position is : or ='
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or all characters have been examined and no character is : or ='
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our application code needs to handle both cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the obvious post-condition. We sometimes call this the happy-path condition
    because it’s the one that’s true when nothing unusual has happened:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the overall post-condition by adding the conditions for the edge cases.
    In this example, we have two additional conditions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There’s no = or :.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no characters at all. This means the len() is zero, and the for statement
    never actually did anything. This also means the position variable will never
    be created.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, then, we have discovered a total of three conditions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: len(text) == 0
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: not(’=’ in text or ’:’ in text), which can be stated in a number of ways. not(text[position] == ’:’ or text[position] == ’=’)
    might be most clear.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: text[position] in ’=:’
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A while statement can be redesigned to have the complete set of post conditions
    in the while clause. This can eliminate the need for a break statement. Proper
    initialization of variables is still required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When a for statement is being used, proper initialization of variables is required.
    Add if statements for the various terminating conditions after the body of the
    for statement. Here’s the resulting for statement and a complicated if statement
    to examine all of the possible post conditions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the statements after the for statement, we’ve enumerated all of the terminating
    conditions explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This approach forces us to work out the post-condition carefully so that we
    can be absolutely sure that we know all the reasons the for or while statement
    ended.
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is to forego any assumptions or intuition. With a little bit of
    discipline, we can be sure of the post-conditions. It’s imperative to be explicit
    about the condition that’s true when a statement works. This is the goal of our
    software, and we can work backward from the goal by choosing the simplest statements
    that will make the goal conditions true.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also use an else clause on a for statement to determine if the statement
    finished normally or a break statement was executed. We can use something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Using an else clause in a for statement is sometimes confusing, and we don’t
    recommend it. It’s not clear if this version is substantially better than any
    of the alternatives. It’s too easy to forget the reason why the else is executed
    because it’s used so rarely.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A classic article on this topic is by David Gries, A note on a standard strategy
    for developing loop invariants and loops. See [http://www.sciencedirect.com/science/article/pii/0167642383900151](http://www.sciencedirect.com/science/article/pii/0167642383900151)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.8 Leveraging exception matching rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The try statement lets us capture an exception. When an exception is raised,
    we have a number of choices for handling it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ignore it: If we do nothing, the program stops. We can do this in two ways—don’t
    use a try statement in the first place, or don’t have a matching except clause
    in the try statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Log it: We can write a message and use a raise statement to let the exception
    propagate after writing to a log. The expectation is that this will stop the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Recover from it: We can write an except clause to do some recovery action to
    undo any effects of the partially completed try clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Silence it: If we do nothing (that is, use the pass statement), then processing
    is resumed after the try statement. This silences the exception, but does not
    correct the underlying problem, or supply alternative results as a recovery attempt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rewrite it: We can raise a different exception. The original exception becomes
    a context for the newly raised exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What about nested contexts? In this case, an exception could be ignored by an
    inner try but handled by an outer context. The basic set of options for each try
    context is the same. The overall behavior of the software depends on the nested
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: The design of a try statement depends on the way that Python exceptions form
    a class hierarchy. For details, see the Exception hierarchy section of Python
    Standard Library. For example, the ZeroDivisionError exception is also an ArithmeticError
    and an Exception. For another example, the FileNotFoundError exception is also
    an OSError as well as an Exception.
  prefs: []
  type: TYPE_NORMAL
- en: This hierarchy can lead to confusion if we’re trying to handle detailed exceptions
    as well as generic exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 2.8.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we’re going to make use of the shutil module to copy a file from one
    place to another. Most of the exceptions that might be raised indicate a problem
    too serious to work around. However, in the specific event of a FileNotFoundError
    exception, we’d like to attempt a recovery action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a rough outline of what we’d like to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We have two directory paths, source_dir and target_dir. We’ve used the glob()
    method to locate all of the files under source_dir that have *.csv files.
  prefs: []
  type: TYPE_NORMAL
- en: The expression source_path.relative_to(source_dir) gives us the tail end of
    the filename, the portion after the directory. We use this to build a new, similar
    path under the target_dir directory. This assures that a file named wc1.csv in
    the source_dir directory will have a similar name in the target_dir directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problems arise with handling exceptions raised by the shutil.copy() function.
    We need a try statement so that we can recover from certain kinds of errors. We’ll
    see this kind of error if we try to run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: (We’ve replaced some details with ... because they’ll be different on your computer.)
  prefs: []
  type: TYPE_NORMAL
- en: This exception is raised when the backup directory hasn’t been created. It will
    also happen when there are subdirectories inside the source_dir directory tree
    that don’t also exist in the target_dir tree. How do we create a try statement
    that handles these exceptions and creates the missing directories?
  prefs: []
  type: TYPE_NORMAL
- en: 2.8.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write the code we want to use indented in the try block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Include the most specific exception classes first in an except clause. In this
    case, we have a meaningful response to the specific FileNotFoundError exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include any more general exceptions later. In this case, we’ll report any generic
    OSError exception that’s encountered. This leads to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve matched exceptions with the most specific first and the more generic after
    that.
  prefs: []
  type: TYPE_NORMAL
- en: We handled the FileNotFoundError exception by creating the missing directories.
    Then we tried the copy() again, knowing it would now work properly.
  prefs: []
  type: TYPE_NORMAL
- en: We logged any other exceptions of the class OSError. For example, if there’s
    a permission problem, that error will be written to a log and the next file will
    be tried. Our objective is to try and copy all of the files. Any files that cause
    problems will be logged, but the overall copying process will continue.
  prefs: []
  type: TYPE_NORMAL
- en: And, yes, the line of code to copy the files is repeated in two distinct contexts.
    The first repetition is when there has been no error. The second is after attempted
    recovery from the initial error. To an extent, this feels like breaking the Don’t
    Repeat Yourself principle. Let’s look at the alternative, which doesn’t seem as
    good.
  prefs: []
  type: TYPE_NORMAL
- en: To meet the DRY standard, we could try to nest this operation in a for statement.
    The break statement is used if things work, otherwise, multiple attempts can be
    made. The extra complication of the for statement seems to be worse than the repetition.
  prefs: []
  type: TYPE_NORMAL
- en: A common compromise is to write a one-line function that reduces the repetition
    to the name of the function. This has the advantage of making it possible to change
    to another of the shutil copy functions in one place.
  prefs: []
  type: TYPE_NORMAL
- en: 2.8.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python’s matching rules for exceptions are intended to be simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Process except clauses in order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Match the actual exception against the exception class (or tuple of exception
    classes). A match means that the actual exception object (or any of the base classes
    of the exception object) is of the given class in the except clause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These rules show why we put the most specific exception classes first and the
    more general exception classes last. A generic exception class like Exception
    will match almost every kind of exception. We don’t want this first, because no
    other clauses will be checked.
  prefs: []
  type: TYPE_NORMAL
- en: There’s an even more generic class, the BaseException class. There’s no good
    reason to ever handle exceptions of this class. If we do, we will be catching
    SystemExit and KeyboardInterrupt exceptions; this interferes with the ability
    to kill a misbehaving application. We only use the BaseException class as a superclass
    when defining new exception classes that exist outside the normal exception hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 2.8.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our example includes a nested context in which a second exception can be raised.
    Consider this except clause snippet (taken out of context):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If the mkdir() method or shutil.copy() functions actually raise exceptions while
    handling the original FileNotFoundError exception, it won’t be handled. Any exceptions
    raised within an except clause can crash the program as a whole. Handling these
    nested exceptions can involve nested try statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite the exception clause to include a nested try during recovery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a nested context writes one message for an OSError exception.
    In the outer context, a slightly different error message is used to log a similar
    error. In both cases, processing can continue. The distinct error messages can
    make it slightly easier to debug the problems.
  prefs: []
  type: TYPE_NORMAL
- en: 2.8.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the [Avoiding a potential problem with an except: clause](ch006_split_001.xhtml#x1-1410009)
    recipe, we look at some additional considerations when designing exception handling
    statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2.9 Avoiding a potential problem with an except: clause'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some common mistakes in exception handling. These can cause programs
    to become unresponsive.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the mistakes we can make is to use the except: clause with no named
    exception class to match. There are a few other mistakes that we can make if we’re
    not cautious about the exceptions we try to handle.'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show some common exception handling errors that we can avoid.
  prefs: []
  type: TYPE_NORMAL
- en: 2.9.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When code can raise a variety of exceptions, it’s sometimes tempting to try
    and match as many as possible. Matching too many exception classes can interfere
    with stopping a misbehaving Python program. We’ll extend the idea of what not
    to do in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 2.9.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to avoid using the bare except: clause. Instead, use except Exception:
    to match the most general kind of exception that an application can reasonably
    handle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Handling too many exception classes can interfere with our ability to stop
    a misbehaving Python program. When we hit Ctrl + C, or send a SIGINT signal via
    the OS’s kill -2 command, we generally want the program to stop. We rarely want
    the program to write a message and keep running. If we use a bare except: clause,
    we can accidentally silence important exceptions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few other classes of exceptions that we should be wary of attempting
    to handle:'
  prefs: []
  type: TYPE_NORMAL
- en: SystemError
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RuntimeError
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MemoryError
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, these exceptions mean things are going badly somewhere in Python’s
    internals. Rather than silence these exceptions, or attempt some recovery, we
    should allow the program to fail, find the root cause, and fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, if we capture any of these exceptions, we can interfere with the way
    these internal exceptions are handled:'
  prefs: []
  type: TYPE_NORMAL
- en: SystemExit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KeyboardInterrupt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeneratorExit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying to handle these exceptions can cause a program to become unresponsive
    at exactly the time we need to stop it.
  prefs: []
  type: TYPE_NORMAL
- en: 2.9.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three techniques we should avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t match the BaseException class in an except BaseException: clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Don’t use except: with no exception class. This matches all exceptions, including
    exceptions we should avoid trying to handle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t match exceptions from which there’s no sensible recovery.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we handle too many kinds of exceptions, we may exacerbate a problem, transforming
    it into a larger and more mysterious problem by way of flawed exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a noble aspiration to write a program that never crashes. Interfering with
    some of Python’s internal exceptions, however, doesn’t create a more reliable
    program. Instead, it creates a program where a clear failure is masked and made
    into an obscure problem.
  prefs: []
  type: TYPE_NORMAL
- en: 2.9.4 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Leveraging exception matching rules](ch006_split_001.xhtml#x1-1350008)
    recipe, we look at some considerations when designing exception-handling statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.10 Concealing an exception root cause
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions contain a root cause. The default behavior of internally raised exceptions
    is to use an implicit __context__ attribute to include the root cause of an exception.
    In some cases, we may want to deemphasize the root cause because it’s misleading
    or unhelpful for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is almost always paired with an application or library that defines
    a unique exception. The idea is to show the unique exception without the clutter
    of an irrelevant exception from outside the application or library.
  prefs: []
  type: TYPE_NORMAL
- en: 2.10.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assume we’re writing some complex string processing. We’d like to treat a number
    of different kinds of detailed exceptions as a single generic error so that users
    of our software are insulated from the implementation details. We can attach details
    to the generic error.
  prefs: []
  type: TYPE_NORMAL
- en: 2.10.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new exception, we can do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates a new, unique class of exception that our library or application
    can use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When handling exceptions, we can conceal the root cause exception like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, we raise a new instance of the module’s unique MyAppError exception
    class. The new exception will not have any connection with the root cause AttributeError
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 2.10.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python exception classes all have a place to record the cause of the exception.
    We can set this __cause__ attribute using the raise Visible from RootCause statement.
    This is done implicitly using the exception context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it looks when this exception is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The underlying cause has been concealed. If we omit the from None in the raise
    statement, then the exception will include two parts and will be quite a bit more
    complex. When the root cause is shown, the output looks more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This shows the underlying AttributeError exception. This may be an implementation
    detail that’s unhelpful and better left off the printed display of the exception.
  prefs: []
  type: TYPE_NORMAL
- en: The more useful part of the exception (with some details replaced by ...) follows
    the initial (and possibly irrelevant) root cause information.
  prefs: []
  type: TYPE_NORMAL
- en: 2.10.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of internal attributes of an exception. These include __cause__,
    __context__, __traceback__, and __suppress_context__. The overall exception context
    is in the __context__ attribute. The cause, if provided via a raise from statement,
    is in __cause__. The context for the exception is available but can be suppressed
    from being printed.
  prefs: []
  type: TYPE_NORMAL
- en: 2.10.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Leveraging exception matching rules](ch006_split_001.xhtml#x1-1350008)
    recipe, we look at some considerations when designing exception-handling statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the [Avoiding a potential problem with an except: clause](ch006_split_001.xhtml#x1-1410009)
    recipe, we look at some additional considerations when designing exception-handling
    statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.11 Managing a context using the with statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many instances where our scripts will be entangled with external resources.
    The most common examples are disk files and network connections to external hosts.
    A common bug is retaining these entanglements forever, tying up these resources
    uselessly. These are sometimes called a memory leak because the available memory
    is reduced each time a new file is opened without closing a previously used file.
  prefs: []
  type: TYPE_NORMAL
- en: We’d like to isolate each entanglement so that we can be sure that the resource
    is acquired and released properly. The idea is to create a context in which our
    script uses an external resource. At the end of the context, our program is no
    longer bound to the resource and we want to be guaranteed that the resource is
    released.
  prefs: []
  type: TYPE_NORMAL
- en: 2.11.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we want to write lines of data to a file in CSV format. When we’re
    done, we want to be sure that the file is closed and the various OS resources—including
    buffers and file handles—are released. We can do this in a context manager, which
    guarantees that the file will be properly closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’ll be working with CSV files, we can use the csv module to handle
    the details of the formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also use the pathlib module to locate the files we’ll be working with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'For the purposes of having something to write, we’ll use this silly data source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also need a working directory. In the examples, we’re using data under
    the current working directory. We can create this directory using a terminal window
    command, or we can create it from within Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This will give us a context in which to learn about the with statement.
  prefs: []
  type: TYPE_NORMAL
- en: 2.11.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the context by opening the Path, or creating the network connection
    with urllib.request.urlopen(). Other common contexts include creating archives
    like zip files and tar files. Here’s the essential context creation for an open
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include all the processing, indented within the with statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we use a file as a context manager, the file is automatically closed at
    the end of the indented context block. Even if an exception is raised, the file
    is still closed properly. Outdent the processing that is done after the context
    is finished and the resources are released:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The statements outside the with context will be executed after the context is
    closed. The named resource — the file opened by target_path.open() — will be properly
    closed.
  prefs: []
  type: TYPE_NORMAL
- en: (We assign the result of the writerow() method of a writer to the _ variable.
    This is a trick required to avoid showing this result. It’s the number 21, telling
    us how many characters were written.)
  prefs: []
  type: TYPE_NORMAL
- en: Even if an exception is raised inside the with context, the file is still properly
    closed. The context manager is notified of the exception. It can close the file
    and allow the exception to propagate.
  prefs: []
  type: TYPE_NORMAL
- en: 2.11.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A context manager is notified of three significant events surrounding the indented
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: Entry to the context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normal exit from the context with no exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exit from the context because of an exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The context manager will—under all conditions—disentangle our program from external
    resources. Files can be closed. Network connections can be dropped. Database transactions
    can be committed or rolled back. Locks can be released.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can experiment with this by including a manual exception inside the with
    statement. This can show that the file was properly closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’ve wrapped the real work in a try statement. This allows
    us to raise an exception after writing the first line of data to the CSV file.
    Because the exception handling is outside the with context, the file is closed
    properly. All resources are released and the part that was written is properly
    accessible and usable by other programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output confirms the expected file state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This shows us that the file was properly closed. It also shows us the message
    associated with the exception to confirm that it was the exception we raised manually.
    This kind of technique allows us to work with expensive resources like database
    connections and network connections and be sure these don’t ”leak.”
  prefs: []
  type: TYPE_NORMAL
- en: Resource leak is a common description used when resources are not released properly
    back to the OS. It’s as if a pool is slowly drained away, and the application
    stops working because there are no more available OS network sockets or file handles.
    The with statement can be used to properly disentangle our Python application
    from OS resources.
  prefs: []
  type: TYPE_NORMAL
- en: 2.11.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python offers us a number of context managers. We noted that an open file is
    a context, as is an open network connection created by urllib.request.urlopen().
  prefs: []
  type: TYPE_NORMAL
- en: For all file operations, and all network connections, we should always use a
    with statement as a context manager. It’s very difficult to find an exception
    to this rule.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that the decimal module makes use of a context manager to allow
    localized changes to the way decimal arithmetic is performed. We can use the decimal.localcontext()
    function as a context manager to change rounding rules or precision for calculations
    isolated by a with statement.
  prefs: []
  type: TYPE_NORMAL
- en: We can define our own context managers, also. The contextlib module contains
    functions and decorators that can help us create context managers around resources
    that don’t explicitly offer them.
  prefs: []
  type: TYPE_NORMAL
- en: When working with locks, the with statement context manager is the ideal way
    to acquire and release a lock. See [https://docs.python.org/3/library/threading.html#with-locks](https://docs.python.org/3/library/threading.html#with-locks)
    for the relationship between a lock object created by the threading module and
    a context manager.
  prefs: []
  type: TYPE_NORMAL
- en: 2.11.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [PEP-343](https://www.python.org/dev/peps/pep-0343/) for the origins of
    the with statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numerous recipes in Chapter [9](ch013_split_000.xhtml#x1-5020009), will make
    use of this technique. The recipes [Reading delimited files with the CSV module](ch015_split_000.xhtml#x1-6320003),
    [Reading complex formats using regular expressions](ch015_split_001.xhtml#x1-6440005),
    and [Reading HTML documents](ch015_split_001.xhtml#x1-6660008), among others,
    will make use of the with statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community Discord space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
