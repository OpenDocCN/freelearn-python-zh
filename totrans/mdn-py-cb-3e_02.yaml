- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: Statements and Syntax
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 语句和语法
- en: Python syntax is designed to be simple. In this chapter, we’ll look at some
    of the most commonly used statements in the language as a way to understand the
    rules. Concrete examples can help clarify the language’s syntax.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python语法被设计得非常简单。在本章中，我们将通过查看语言中最常用的语句来了解规则。具体的例子可以帮助阐明语言的语法。
- en: We’ll cover some of the basics of creating script files first. Then we’ll move
    on to looking at some of the more commonly used statements. Python only has about
    20 or so different kinds of imperative statements in the language. We’ve already
    looked at two kinds of statements in Chapter [1](ch005_split_000.xhtml#x1-170001),
    the assignment statement and the expression statement.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍创建脚本文件的一些基础知识。然后我们将转向查看一些更常用的语句。Python在语言中只有大约20种不同的命令式语句。我们已经在第1章(ch005_split_000.xhtml#x1-170001)中看到了两种语句，即赋值语句和表达式语句。
- en: 'When we write something like this:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写如下内容时：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’re actually executing a statement that contains only the evaluation of a
    function, print(). This kind of statement—where we evaluate a function or a method
    of an object—is common.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上执行的是一个只包含函数评估的语句，即print()。这种类型的语句——评估一个函数或对象的某个方法——是很常见的。
- en: 'The other kind of statement we’ve already seen is the assignment statement.
    Python has many variations on this theme. Most of the time, we’re assigning a
    single value to a single variable. When a function returns a tuple as a result,
    we can unpack that collection and assign more than one variable at the same time
    in a single assignment statement. It is done like this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到的其他类型的语句是赋值语句。Python在这方面有很多变体。大多数时候，我们都是将单个值赋给单个变量。当一个函数返回一个元组作为结果时，我们可以解包这个集合，并在单个赋值语句中同时赋值给多个变量。这样做如下：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The recipes in this chapter will look at the if, while, for, with, and try statements.
    We’ll also touch on a few of the simpler statements as we go, like pass, break,
    and raise.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的食谱将探讨if、while、for、with和try语句。我们还将简要介绍一些更简单的语句，如pass、break和raise。
- en: 'In later chapters, we’ll look at other statements. Here’s a summary:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将探讨其他语句。以下是一个总结：
- en: '|'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Statement | Chapter |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 语句 | 章节 |'
- en: '|'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| def | Chapter [3](ch007_split_000.xhtml#x1-1610003) |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| def | 第3章(ch007_split_000.xhtml#x1-1610003) |'
- en: '| return | Chapter [3](ch007_split_000.xhtml#x1-1610003) |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| return | 第3章(ch007_split_000.xhtml#x1-1610003) |'
- en: '| import | Chapter [3](ch007_split_000.xhtml#x1-1610003) |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| import | 第3章(ch007_split_000.xhtml#x1-1610003) |'
- en: '| del | Chapter [4](ch008_split_000.xhtml#x1-2240004) |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| del | 第4章(ch008_split_000.xhtml#x1-2240004) |'
- en: '| class | Chapter [7](ch011_split_000.xhtml#x1-3760007) |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| class | 第7章(ch011_split_000.xhtml#x1-3760007) |'
- en: '| match | Chapter [8](ch012.xhtml#x1-4520008) |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| match | 第8章(ch012.xhtml#x1-4520008) |'
- en: '| type | Chapter [10](ch014.xhtml#x1-57300010) |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| type | 第10章(ch014.xhtml#x1-57300010) |'
- en: '| assert | Chapter [10](ch014.xhtml#x1-57300010) |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| assert | 第10章(ch014.xhtml#x1-57300010) |'
- en: '|'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|  |  |'
- en: 'Table 2.1: Python Statements and Chapters'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1：Python语句和章节
- en: 'In this chapter, we’ll look at the following recipes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: '[Writing Python script and module files – syntax basics](ch006_split_000.xhtml#x1-850001)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编写Python脚本和模块文件——语法基础](ch006_split_000.xhtml#x1-850001)'
- en: '[Writing long lines of code](ch006_split_000.xhtml#x1-910002)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编写长行代码](ch006_split_000.xhtml#x1-910002)'
- en: '[Including descriptions and documentation](ch006_split_000.xhtml#x1-1010003)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[包括描述和文档](ch006_split_000.xhtml#x1-1010003)'
- en: '[Writing better docstrings with RST markup](ch006_split_000.xhtml#x1-1090004)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用RST标记编写更好的docstrings](ch006_split_000.xhtml#x1-1090004)'
- en: '[Designing complex if...elif chains](ch006_split_000.xhtml#x1-1170005)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[设计复杂的if...elif链](ch006_split_000.xhtml#x1-1170005)'
- en: '[Saving intermediate results with the := ”walrus” operator](ch006_split_001.xhtml#x1-1230006)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用“walrus”运算符保存中间结果](ch006_split_001.xhtml#x1-1230006)'
- en: '[Avoiding a potential problem with break statements](ch006_split_001.xhtml#x1-1290007)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[避免break语句的潜在问题](ch006_split_001.xhtml#x1-1290007)'
- en: '[Leveraging exception matching rules](ch006_split_001.xhtml#x1-1350008)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[利用异常匹配规则](ch006_split_001.xhtml#x1-1350008)'
- en: '[Avoiding a potential problem with an except: clause](ch006_split_001.xhtml#x1-1410009)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[避免except子句的潜在问题](ch006_split_001.xhtml#x1-1410009)'
- en: '[Concealing an exception root cause](ch006_split_001.xhtml#x1-14600010)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[隐藏异常的根本原因](ch006_split_001.xhtml#x1-14600010)'
- en: '[Managing a context using the with statement](ch006_split_001.xhtml#x1-15200011)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用with语句管理上下文](ch006_split_001.xhtml#x1-15200011)'
- en: We’ll start by looking at the big picture – scripts and modules – and then we’ll
    move down into details of individual statements.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从宏观的角度开始，即脚本和模块，然后我们将深入到单个语句的细节。
- en: 2.1 Writing Python script and module files – syntax basics
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 编写Python脚本和模块文件 – 语法基础
- en: The point of Python (and programming in general) is to create automated solutions
    to problems that involve data and processing. Further, the software we write is
    a kind of knowledge representation; this means clarity is perhaps the most important
    quality aspect of software.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python（以及一般编程）的目的是创建涉及数据和处理的自动化解决方案。此外，我们编写的软件是一种知识表示；这意味着清晰性可能是软件最重要的质量方面。
- en: In Python, we implement automated solutions by creating script files. These
    are the top-level, main programs of Python programming. In addition to main scripts,
    we may also create modules (and packages of modules) to help organize the software
    into intellectually manageable chunks. A script is a module; however, it has a
    distinct intent to do useful processing when started by the OS.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们通过创建脚本文件来实现自动化解决方案。这些是Python编程的顶级、主要程序。除了主脚本外，我们还可以创建模块（以及模块的包）来帮助将软件组织成智力上可管理的块。脚本是一个模块；然而，它有一个明确的意图，当由操作系统启动时执行有用的处理。
- en: A key part of creating clear, readable Python files is making sure our code
    follows the widely adopted conventions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建清晰、可读的Python文件的关键部分是确保我们的代码遵循广泛采用的约定。
- en: For example, we need to be sure to save our files in UTF-8 encoding. While ASCII
    encoding is still supported by Python, it’s a poor choice for modern programming.
    We’ll also need to be sure our editor uses spaces instead of the tab character.
    This is often a configuration setting in programming editors. Using Unix newlines
    is also helpful for portability.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们需要确保将文件以UTF-8编码保存。虽然Python仍然支持ASCII编码，但它对于现代编程来说是一个较差的选择。我们还需要确保我们的编辑器使用空格而不是制表符。这通常是编程编辑器中的一个配置设置。使用Unix换行符也有助于可移植性。
- en: 2.1.1 Getting ready
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1.1 准备工作
- en: To edit Python scripts, we’ll need a good programming editor. It’s nearly impossible
    to suggest just one. So we’ll suggest a few.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编辑Python脚本，我们需要一个好的编程编辑器。几乎不可能只推荐一个。所以我们将推荐几个。
- en: The JetBrains PyCharm editor has numerous features. The community edition version
    is free. See [https://www.jetbrains.com/pycharm/download/](https://www.jetbrains.com/pycharm/download/).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: JetBrains PyCharm编辑器具有许多功能。社区版是免费的。请参阅[https://www.jetbrains.com/pycharm/download/](https://www.jetbrains.com/pycharm/download/)。
- en: ActiveState has Komodo IDE, which is also very sophisticated. The Komodo Edit
    version is free and does some of the same things as the full Komodo IDE. See [http://komodoide.com/komodo-edit/](http://komodoide.com/komodo-edit/).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ActiveState的Komodo IDE非常复杂。Komodo Edit版本是免费的，并且与完整的Komodo IDE做了一些相同的事情。请参阅[http://komodoide.com/komodo-edit/](http://komodoide.com/komodo-edit/)。
- en: Notepad++ is good for Windows developers. See [https://notepad-plus-plus.org](https://notepad-plus-plus.org).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Notepad++非常适合Windows开发者。请参阅[https://notepad-plus-plus.org](https://notepad-plus-plus.org)。
- en: BBEdit is very nice for macOS X developers. See [http://www.barebones.com/products/bbedit/](http://www.barebones.com/products/bbedit/).
    Sublime is also popular on macOS X. See [https://www.sublimetext.com](https://www.sublimetext.com).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: BBEdit非常适合macOS X开发者。请参阅[http://www.barebones.com/products/bbedit/](http://www.barebones.com/products/bbedit/)。Sublime在macOS
    X上也很受欢迎。请参阅[https://www.sublimetext.com](https://www.sublimetext.com)。
- en: For Linux developers, there are several built-in editors, including Vim and
    gedit. Since Linux tends to be biased toward developers, the editors available
    are all suitable for writing Python.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux开发者，有几个内置的编辑器，包括Vim和gedit。由于Linux倾向于偏向开发者，因此可用的编辑器都适合编写Python。
- en: 'It is helpful is to have two windows open while working:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作时有两个窗口打开是有帮助的：
- en: An editor to create the final script or module file.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个编辑器来创建最终的脚本或模块文件。
- en: A terminal session with Python’s >>> prompt, where we can try things out to
    see what works and what doesn’t.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有Python的>>>提示符的终端会话，我们可以尝试一些事情来看看哪些可行，哪些不可行。
- en: 'Most editors recognize the .py extension and provide appropriate formatting
    based on [PEP-8](https://peps.python.org/pep-0008/). This generally includes the
    following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编辑器都识别.py扩展名，并根据[PEP-8](https://peps.python.org/pep-0008/)提供适当的格式化。这通常包括以下内容：
- en: The file encoding should be UTF-8.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件编码应该是UTF-8。
- en: Indentation should be four spaces.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩进应该是四个空格。
- en: We want the Tab key on the keyboard to insert spaces instead of the tab character,
    \t.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望键盘上的Tab键插入空格而不是制表符，\t。
- en: Once the editor is configured, we can write a script file that other people
    can easily use or extend.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了编辑器，我们就可以编写一个其他人可以轻松使用或扩展的脚本文件。
- en: 2.1.2 How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1.2 如何做到...
- en: 'Here’s how we create a script file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建脚本文件的方法：
- en: 'The first line of most Python script files looks like this:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数 Python 脚本文件的第一行看起来像这样：
- en: '[PRE2]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This sets an association between the file you’re writing and Python. If the
    file’s mode is set to executable with the bash chmod command, and the directory
    is on the OS PATH list, the script will be a first-class application, as usable
    as any of the built-in commands.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这在您正在编写的文件和 Python 之间设置了一个关联。如果文件的权限设置为可执行，并且目录在 OS PATH 列表中，那么脚本将是一个一等应用，就像任何内置命令一样可用。
- en: For Windows, the filename-to-program association is done through a setting in
    the Default Programs control panel. Find the panel for Set Associations, and make
    sure .py files are bound to the Python program. This is often set by the installer,
    and we rarely need to change it or set it manually.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 Windows，文件名到程序的关联是通过默认程序控制面板中的一个设置完成的。找到设置关联的面板，并确保 .py 文件绑定到 Python 程序。这通常由安装程序设置，我们很少需要更改它或手动设置它。
- en: 'After the preamble, convention suggests we include a triple-quoted block of
    text. This is the documentation string (called a docstring) for the file we’re
    going to create:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前言之后，惯例建议我们包括一个三引号文本块。这是我们即将创建的文件的文档字符串（称为 docstring）：
- en: '[PRE3]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because Python triple-quoted strings can be indefinitely long, feel free to
    write as much as necessary. This should be the primary vehicle for describing
    the script or library module. This can even include examples of how it works.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 Python 的三引号字符串可以无限长，请随意写尽可能多的内容。这应该是描述脚本或库模块的主要工具。这甚至可以包括如何工作的示例。
- en: 'Now comes the interesting part of the script: the part that really does something.
    We can write all the statements we need to get the job done. For now, we’ll use
    this as a placeholder:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是脚本的有趣部分：真正做事情的这部分。我们可以编写完成工作所需的所有语句。目前，我们将使用它作为占位符：
- en: '[PRE4]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This isn’t much, but at least the script does something. It’s common to create
    function and class definitions, as well as to write statements to use the functions
    and classes to do things.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这并不多，但至少脚本做了些事情。创建函数和类定义，以及编写使用函数和类做事情的语句是很常见的。
- en: For our first, simple script, all of the statements must begin at the left margin
    and must be complete on a single line. There are many Python statements that have
    blocks of statements nested inside them. These internal blocks of statements will
    be indented to clarify their scope. Generally—because we set indentation to four
    spaces—we can hit the Tab key to properly indent the code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个简单脚本，所有的语句都必须从左边界开始，并且必须在单行内完成。Python 中有许多语句包含嵌套的语句块。这些内部语句块将被缩进来明确它们的范围。通常——因为我们把缩进设置为四个空格——我们可以按
    Tab 键来正确地缩进代码。
- en: 'Our file should look like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们文件应该看起来像这样：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 2.1.3 How it works...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1.3 它是如何工作的...
- en: 'Unlike other languages, there’s very little boilerplate in Python. There’s
    only one line of overhead and even the #!/usr/bin/env python3 line is generally
    optional.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '与其他语言不同，Python 中几乎没有样板代码。只有一行开销，甚至 #!/usr/bin/env python3 行通常是可选的。'
- en: 'Why do we set the encoding to UTF-8? While the language was originally designed
    to work using just the original 128 ASCII characters, we often find that ASCII
    is limiting. This is legal Python if we save our file in UTF-8:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要将编码设置为 UTF-8？虽然该语言最初是为了仅使用原始的 128 个 ASCII 字符而设计的，但我们经常发现 ASCII 是有限的。如果我们以
    UTF-8 格式保存文件，这是合法的 Python：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It’s important to be consistent when choosing between spaces and tabs in Python.
    They are both more or less invisible, and mixing them up can easily lead to errors
    when trying to run the script. Spaces are suggested.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中选择空格和制表符时保持一致性很重要。它们都是或多或少不可见的，混合使用它们很容易在尝试运行脚本时出错。建议使用空格。
- en: 'The initial #! line is a comment. Because the two characters are sometimes
    called sharp and bang, the combination is called ”shebang.” Everything between
    a # and the end of the line is ignored. The Linux loader (a program named execve)
    looks at the first few bytes of a file to see what the file contains. These first
    few bytes are sometimes called magic bytes because the loader’s behavior seems
    magical. When present, this two-character sequence of #! is followed by the path
    to the program responsible for processing the rest of the data in the file. We
    prefer to use /usr/bin/env to start the Python program for us. We can leverage
    the env program to make Python-specific environment settings.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的#!行是一个注释。因为这两个字符有时被称为sharp和bang，所以组合被称为“shebang”。#和行尾之间的所有内容都被忽略。Linux加载器（一个名为execve的程序）查看文件的第一个几个字节以确定文件内容。这些第一个几个字节有时被称为magic
    bytes，因为加载器的行为看起来很神奇。当存在时，这个由#!组成的两字符序列后面跟着处理文件中其余数据的程序的路径。我们更喜欢使用/usr/bin/env为我们启动Python程序。我们可以利用env程序来设置Python特定的环境变量。
- en: 2.1.4 There’s more...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1.4 更多内容...
- en: The Python Standard Library documents are derived, in part, from the documentation
    strings present in the module files. It’s common practice to write sophisticated
    docstrings in modules, packages, and scripts. There are tools like pydoc and Sphinx
    that can reformat the module docstrings into elegant documentation. We’ll look
    at this in the [Writing better docstrings with RST markup](ch006_split_000.xhtml#x1-1090004)
    recipe, as well as the [Using Sphinx autodoc to create the API reference](ch021.xhtml#x1-9270003)
    recipe in Chapter [17](ch021.xhtml#x1-91400017).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库文档部分来源于模块文件中存在的文档字符串。在模块、包和脚本中编写复杂的docstrings是常见做法。有像pydoc和Sphinx这样的工具可以将模块docstrings重新格式化为优雅的文档。我们将在[使用RST标记编写更好的docstrings](ch006_split_000.xhtml#x1-1090004)的菜谱中查看这一点，以及第[17](ch021_split_000.xhtml#x1-91400017)章中的[使用Sphinx
    autodoc创建API参考](ch021_split_000.xhtml#x1-9270003)的菜谱。
- en: Additionally, unit test cases can be included in the docstrings. Tools like
    doctest can extract examples from the document strings and execute the code to
    see if the answers in the documentation match the answers found by running the
    code. This is the subject of many recipes in Chapter [15](ch019_split_000.xhtml#x1-79400015).
    Many examples in this book are validated by doctest.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，单元测试用例可以包含在docstrings中。像doctest这样的工具可以从文档字符串中提取示例并执行代码，以查看文档中的答案是否与运行代码找到的答案匹配。这是第[15](ch019_split_000.xhtml#x1-79400015)章中许多菜谱的主题。本书中的许多示例都经过doctest验证。
- en: 'Triple-quoted documentation strings are preferred over # comments. While all
    text between # and the end of the line is ignored, this is limited to a single
    line; the conventional approach is to use it sparingly. A docstring can be of
    indefinite size; they are used widely.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 三引号文档字符串比#注释更受欢迎。虽然#和行尾之间的所有文本都被忽略，但这仅限于单行；传统做法是尽量少用。docstring可以是不定长度的；它们被广泛使用。
- en: 'There’s another bit of overhead that’s sometimes included. The Vim and gedit
    editors let us keep edit preferences in the file. This is called a modeline. Here’s
    a typical modeline that’s useful for Python:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时还会包含一些额外的开销。Vim和gedit编辑器允许我们在文件中保留编辑偏好。这被称为modeline。以下是一个典型的modeline，对Python很有用：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This makes sure any tab characters will be transformed into eight spaces; when
    we hit the Tab key, we’ll shift four spaces. This is widely used because tab characters
    are traditionally indented eight spaces, and this replacement is likely to create
    proper indentation. This setting is embedded in the code; we don’t have to do
    any Vim setup to apply these settings to our Python script files.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保任何制表符字符都将转换为八个空格；当我们按下Tab键时，我们将移动四个空格。这被广泛使用，因为传统上制表符字符缩进八个空格，这种替换很可能创建正确的缩进。这个设置嵌入在代码中；我们不需要对Vim进行任何设置来将这些设置应用到我们的Python脚本文件中。
- en: 2.1.5 See also
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1.5 参考阅读
- en: We’ll look at how to write useful document strings in the [Including descriptions
    and documentation](ch006_split_000.xhtml#x1-1010003) and [Writing better docstrings
    with RST markup](ch006_split_000.xhtml#x1-1090004) recipes.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在[包括描述和文档](ch006_split_000.xhtml#x1-1010003)和[使用RST标记编写更好的docstrings](ch006_split_000.xhtml#x1-1090004)的菜谱中查看如何编写有用的文档字符串。
- en: For more information on suggested style, see [PEP-8](https://www.python.org/dev/peps/pep-0008/).
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于建议的样式更多信息，请参阅[PEP-8](https://www.python.org/dev/peps/pep-0008/)。
- en: 2.2 Writing long lines of code
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 编写长行代码
- en: There are many times when we need to write lines of code that are so long that
    they’re very hard to read. Many people like to limit the length of a line of code
    to 80 characters or fewer. It’s a well-known principle of graphic design that
    a narrower area of text is easier to read. See [http://webtypography.net/2.1.2](http://webtypography.net/2.1.2)
    for a deeper discussion of line width and readability.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多次我们需要编写非常长的代码行，以至于很难阅读。很多人喜欢将代码行的长度限制在 80 个字符或更少。图形设计的一个众所周知的原则是，较窄的文本区域更容易阅读。有关行宽和可读性的更深入讨论，请参阅
    [http://webtypography.net/2.1.2](http://webtypography.net/2.1.2)。
- en: While fewer characters per line is easier on the eyes, our code can refuse to
    cooperate with this principle. How can we break long Python statements into more
    manageable pieces?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每行字符较少对眼睛更友好，但我们的代码可能会拒绝遵守这个原则。我们如何将长 Python 语句拆分成更易管理的部分？
- en: 2.2.1 Getting ready
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2.1 准备工作
- en: 'Let’s say we’ve got something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一些像这样的事情：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code includes a long formula, and a long format string into which we’re
    injecting values. This looks bad when typeset in a book; the f-string line may
    be broken incorrectly. It may look bad on our screen when trying to edit this
    script. (For more on f-strings, see [Building complicated strings with f-strings](ch005_split_000.xhtml#x1-410004)
    in Chapter [1](ch005_split_000.xhtml#x1-170001).)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '这段代码包含一个长公式和一个长格式字符串，我们将值注入其中。当在书中排版时，这看起来很糟糕；f-string 行可能被错误地断行。当尝试编辑此脚本时，它可能看起来很糟糕。（有关
    f-string 的更多信息，请参阅第 [1](ch005_split_000.xhtml#x1-170001) 章的 [构建复杂的字符串与 f-string](ch005_split_000.xhtml#x1-410004)）。 '
- en: We can’t haphazardly break Python statements into chunks. The syntax rules are
    clear that a statement must be complete on a single logical line.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能随意将 Python 语句拆分成块。语法规则明确指出，一个语句必须在单个逻辑行上完整。
- en: The term ”logical line” provides a hint as to how we can proceed. Python makes
    a distinction between logical lines and physical lines; we’ll leverage these syntax
    rules to break up long statements.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: “逻辑行”这个术语为我们提供了如何继续进行的线索。Python 在逻辑行和物理行之间做出了区分；我们将利用这些语法规则来拆分长语句。
- en: 2.2.2 How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2.2 如何操作...
- en: 'Python gives us several ways to wrap long statements so they’re more readable:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Python 给我们提供了几种方法来包装长语句，使它们更易读：
- en: We can use \ at the end of a line to continue the logical line onto the next
    physical line. While this always works, it can be hard to spot the \.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在一行的末尾使用 \ 来将逻辑行延续到下一物理行。虽然这总是可行的，但有时候很难找到 \。
- en: 'Python has a rule that a statement can span multiple logical lines because
    the (), [], and {} characters must balance. Further, we can also exploit the way
    Python automatically concatenates adjacent string literals to make a single, longer
    string literal: ("a" "b") is the same as "ab".'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 有一个规则，即一个语句可以跨越多个逻辑行，因为括号、方括号和花括号必须平衡。此外，我们还可以利用 Python 自动连接相邻字符串字面量以形成一个较长的字符串字面量的方式：("a"
    "b") 与 "ab" 相同。
- en: In some cases, we can decompose a statement into multiple statements by assigning
    intermediate results to separate variables.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可以通过将中间结果分配给不同的变量来将一个语句分解成多个语句。
- en: We’ll look at each one of these in separate parts of this recipe.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这份食谱的单独部分逐一查看这些内容。
- en: Using a backslash to break a long statement into logical lines
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用反斜杠将长语句拆分为逻辑行
- en: 'If there’s a meaningful break, insert the \ to separate the statement:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有有意义的断行，插入 \ 来分隔语句：
- en: '[PRE9]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For this to work, the \ must be the last character on the line. An extra space
    after the \ is fairly hard to see; some care is required. The [PEP-8](https://www.python.org/dev/peps/pep-0008/)
    proposal provides guidelines on formatting and tends to discourage this technique.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这可行，\ 必须是行的最后一个字符。反斜杠后面的额外空格很难看到；需要一些小心。PEP-8 [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)
    建议提供了格式化指南，并倾向于不鼓励这种技术。
- en: In spite of this being a little hard to see, the \ can always be used. Think
    of it as the last resort in making a line of code more readable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这有点难以看清，但 \ 总是可以使用的。把它看作是使代码行更易读的最后一招。
- en: Using the () characters to break a long statement into sensible pieces
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用括号将长语句拆分成合理的部分
- en: 'Write the whole statement on one line, even if it’s confusing:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使令人困惑，也要将整个语句写在一行上：
- en: '[PRE10]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the extra () characters, which don’t change the value but allow breaking
    the expression into multiple lines:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加额外的括号，这些括号不会改变值，但允许将表达式拆分成多行：
- en: '[PRE11]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Break the line inside the () characters:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在括号内断行：
- en: '[PRE12]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The matching () characters technique is quite powerful and will work in a wide
    variety of cases. This is widely used and highly recommended.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配()字符的技术非常强大，并且可以在许多情况下工作。这被广泛使用，并且强烈推荐。
- en: We can almost always find a way to add extra () characters to a statement. In
    rare cases when we can’t add () characters, we can fall back on using \ to break
    the statement into sections.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎总是可以找到一种方法在语句中添加额外的()字符。在极少数情况下，当我们不能添加()字符时，我们可以退回到使用\来将语句分成几个部分。
- en: Using string literal concatenation
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用字符串字面量连接
- en: 'We can combine the () characters with another rule that joins adjacent string
    literals. This is particularly effective for long, complex format strings:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将()字符与另一个规则结合起来，该规则连接相邻的字符串字面量。这对于长而复杂的格式字符串特别有效：
- en: Wrap the long string value in the () characters.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将长字符串值包裹在()字符中。
- en: 'Break the string into meaningful substrings:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字符串分解成有意义的子字符串：
- en: '[PRE13]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can always break a long string literal into adjacent pieces. We can then
    use as many physical line breaks as we need. With string literal values, no explicit
    operator is needed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是可以将长字符串字面量分解成相邻的部分。然后我们可以使用我们需要的物理行断行。对于字符串字面量值，不需要显式运算符。
- en: Assigning intermediate results to separate variables
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将中间结果分配给单独的变量
- en: 'Here’s the context for this technique:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个技术的背景：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can break this into three intermediate values:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个表达式分解成三个中间值：
- en: 'Identify sub-expressions in the overall expression. Assign these to variables:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在整体表达式中识别子表达式。将这些分配给变量：
- en: '[PRE15]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Replace the sub-expressions with the variables that were created:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用创建的变量替换子表达式：
- en: '[PRE16]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can always take a sub-expression and assign it to a variable, and use the
    variable everywhere the sub-expression was used. The 15*sqrt(5) product is repeated;
    this, too, is a good candidate for refactoring the expression.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是可以将子表达式分配给变量，并在子表达式被使用的地方使用该变量。15*sqrt(5)的乘积被重复；这也是重构表达式的良好候选。
- en: We didn’t give these variables descriptive names. In some cases, the sub-expressions
    have some semantics that we can capture with meaningful names.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有给出这些变量有描述性的名称。在某些情况下，子表达式有一些语义，我们可以用有意义的名称来捕捉。
- en: 2.2.3 How it works...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2.3 它是如何工作的...
- en: 'The Python language manual makes a distinction between logical lines and physical
    lines. A logical line contains a complete statement. It can span multiple physical
    lines through a technique called line joining. The manual identifies two techniques:
    explicit line joining and implicit line joining.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言手册在逻辑行和物理行之间做出了区分。一个逻辑行包含一个完整的语句。它可以通过称为行连接的技术跨越多个物理行。手册确定了两种技术：显式行连接和隐式行连接。
- en: The use of \ for explicit line joining is sometimes helpful. Because it’s easy
    to overlook, it’s not generally encouraged. [PEP-8](https://www.python.org/dev/peps/pep-0008/)
    suggests this should be the method of last resort.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用\进行显式行连接有时是有帮助的。因为它很容易被忽视，所以通常不鼓励这样做。[PEP-8](https://www.python.org/dev/peps/pep-0008/)建议这应该是最后的手段。
- en: The use of () for implicit line joining can be used in many cases. It often
    fits semantically with the structure of the expressions, so it is encouraged.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下可以使用()进行隐式行连接。它通常与表达式的结构在语义上相匹配，因此是鼓励的。
- en: 2.2.4 There’s more...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2.4 更多...
- en: Expressions are used widely in a number of Python statements. Any expression
    can have () characters added. This gives us a lot of flexibility.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式在许多Python语句中被广泛使用。任何表达式都可以添加()字符。这给了我们很多灵活性。
- en: 'There are, however, a few places where we may have a long statement that does
    not specifically involve a long expression. The most notable example of this is
    the import statement—it can become long, but doesn’t use any expressions. In spite
    of not having a proper expression, it does, however, still permit the use of ().
    The following example shows we can surround a very long list of imported names:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有几个地方我们可能有一个长的语句，它并不特别涉及长的表达式。最显著的例子是导入语句——它可以变得很长，但并不使用任何表达式。尽管没有适当的表达式，但它确实仍然允许使用()。以下示例显示我们可以围绕一个非常长的导入名称列表：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: While the () characters are emphatically not part of an expression, they are
    part of the syntax available to help make the statement more readable.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然()字符绝对不是表达式的一部分，但它们是可用的语法的一部分，有助于使语句更易于阅读。
- en: 2.2.5 See also
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2.5 参见
- en: Implicit line joining also applies to the matching [] and {} characters. These
    apply to collection data structures that we’ll look at in Chapter [4](ch008_split_000.xhtml#x1-2240004).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式行连接也适用于匹配的[]和{}字符。这些适用于我们在第[4](ch008_split_000.xhtml#x1-2240004)章中将要查看的集合数据结构。
- en: 2.3 Including descriptions and documentation
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3 包含描述和文档
- en: When we have a useful script, we often need to leave notes for ourselves—and
    others—on what it does, how it solves some particular problem, and when it should
    be used. This recipe contains a suggested outline to help make the documentation
    reasonably complete.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个有用的脚本时，我们经常需要为自己和其他人留下关于它做什么、如何解决某些特定问题以及何时应该使用的笔记。这个配方包含一个建议的大纲，以帮助使文档合理完整。
- en: 2.3.1 Getting ready
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3.1 准备工作
- en: If we’ve used the [Writing Python script and module files – syntax basics](ch006_split_000.xhtml#x1-850001)
    recipe to start a script file, we’ll have a small documentation string in place.
    We’ll expand on this documentation string in this recipe.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用了[编写Python脚本和模块文件 – 语法基础](ch006_split_000.xhtml#x1-850001)配方来开始脚本文件，我们将有一个小的文档字符串。我们将在这个配方中扩展这个文档字符串。
- en: There are other places where documentation strings should be used. We’ll look
    at these additional locations in Chapter [3](ch007_split_000.xhtml#x1-1610003)
    and Chapter [7](ch011_split_000.xhtml#x1-3760007).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他地方也应该使用文档字符串。我们将在第[3](ch007_split_000.xhtml#x1-1610003)章和第[7](ch011_split_000.xhtml#x1-3760007)章中查看这些附加位置。
- en: 'We have two general kinds of modules for which we’ll be writing summary docstrings:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写总结文档字符串的两种通用类型的模块：
- en: 'Library modules: These files will contain mostly function definitions as well
    as class definitions. The docstring summary should focus on the definitions in
    the module, describing what the module is. The docstring can provide examples
    of using the functions and classes that are defined in the module. In Chapter [3](ch007_split_000.xhtml#x1-1610003),
    and Chapter [7](ch011_split_000.xhtml#x1-3760007), we’ll look more closely at
    these modules.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库模块：这些文件将主要包含函数定义以及类定义。文档字符串摘要应侧重于模块中的定义，描述模块是什么。文档字符串可以提供使用模块中定义的函数和类的示例。在第[3](ch007_split_000.xhtml#x1-1610003)章和第[7](ch011_split_000.xhtml#x1-3760007)章中，我们将更详细地查看这些模块。
- en: 'Scripts: These are files that we generally expect will do some real work. The
    docstring should describe what the module does and how to use it. The options,
    environment variables, and configuration files are important parts of this docstring.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本：这些是我们通常期望会执行一些实际工作的文件。文档字符串应该描述模块的功能和使用方法。选项、环境变量和配置文件是文档字符串的重要组成部分。
- en: We will sometimes create files that contain a little of both. This requires
    a proper balance between doing and being.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时会创建包含两者一部分的文件。这需要在行动和存在之间保持适当的平衡。
- en: 2.3.2 How to do it...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3.2 如何操作...
- en: 'The first step in writing documentation is the same for both library modules
    and scripts:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 编写文档的第一步对库模块和脚本都是相同的：
- en: Write a brief summary of what the script or module is or does. The summary doesn’t
    need to dig too deeply into how it works. Like a lede in a newspaper article,
    it introduces the who, what, when, where, how, and why of the module. Details
    will follow in the body of the docstring.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简要总结脚本或模块是什么或做什么。总结不需要深入挖掘其工作原理。就像报纸文章的开头一样，它介绍了模块的谁、什么、何时、何地、如何和为什么。细节将在文档字符串的主体中跟随。
- en: 'It can help to avoid needless phrases like This script. We might start our
    module docstring like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于避免像“此脚本”这样的不必要的短语。我们可能以这样的方式开始模块的文档字符串：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We’ll separate the other steps based on the general focus of the module.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据模块的一般重点来区分其他步骤。
- en: Writing docstrings for scripts
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为脚本编写文档字符串
- en: When we document a script, we need to focus on the needs of a person who will
    use the script.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们记录脚本时，我们需要关注将使用脚本的人的需求。
- en: Start as shown earlier, creating a summary sentence.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照前面所示开始，创建一个总结句。
- en: Sketch an outline for the rest of the docstring. We’ll be using ReStructuredText
    (RST) markup. Write the topic on one line, then put a line of = under the topic
    to make it a proper section title. Remember to leave a blank line between each
    topic.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为文档字符串的其余部分草拟一个大纲。我们将使用ReStructuredText（RST）标记。在一行上写上主题，然后在主题下方写一行=，使其成为合适的标题。记住，在每个主题之间留一个空行。
- en: 'Topics may include:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 主题可能包括：
- en: 'SYNOPSIS: A summary of how to run this script. If the script uses the argparse
    module to process command-line arguments, the help text produced by argparse is
    the ideal synopsis text. Other installable tools like click or invoke can also
    produce elegant synopsis text. (See [Using argparse to get command-line input](ch010.xhtml#x1-3490004)
    in Chapter [6](ch010.xhtml#x1-3300006).)'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概要：如何运行此脚本的摘要。如果脚本使用 argparse 模块处理命令行参数，argparse 生成的帮助文本是理想的概要文本。其他可安装的工具，如
    click 或 invoke，也可以生成优雅的概要文本。（参见第[6](ch010.xhtml#x1-3300006)章中的[使用 argparse 获取命令行输入](ch010.xhtml#x1-3490004)）
- en: 'DESCRIPTION: An explanation of what this script does.'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述：解释此脚本的功能。
- en: 'OPTIONS: This provides the details of all parameters and options. (See [Using
    argparse to get command-line input](ch010.xhtml#x1-3490004) in Chapter [6](ch010.xhtml#x1-3300006).)'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项：这提供了所有参数和选项的详细信息。（参见第[6](ch010.xhtml#x1-3300006)章中的[使用 argparse 获取命令行输入](ch010.xhtml#x1-3490004)）
- en: 'ENVIRONMENT: This provides the place to describe the environment variables
    and what they mean. (See [Using the OS environment settings](ch010.xhtml#x1-3670007)
    in Chapter [6](ch010.xhtml#x1-3300006).)'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境：这提供了描述环境变量及其含义的地方。（参见第[6](ch010.xhtml#x1-3300006)章中的[使用 OS 环境设置](ch010.xhtml#x1-3670007)）
- en: 'FILES: The names of files that are created or read by a script are very important
    pieces of information.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件：脚本创建或读取的文件名是非常重要的信息。
- en: 'EXAMPLES: Some examples of using the script are always helpful. In some cases,
    this is the only part a user will read.'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：一些使用脚本的示例总是很有帮助。在某些情况下，这可能是用户唯一会阅读的部分。
- en: 'SEE ALSO: Any related scripts or background information.'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见：任何相关的脚本或背景信息。
- en: Other topics that might be interesting include EXIT STATUS, AUTHOR, BUGS, REPORTING
    BUGS, HISTORY, or COPYRIGHT. In some cases, advice on reporting bugs, for instance,
    doesn’t really belong in a module’s docstring, but rather elsewhere in the project’s
    GitHub or SourceForge pages.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其他可能有趣的主题包括退出状态、作者、错误、报告错误、历史或版权。在某些情况下，例如报告错误的建议可能并不真正属于模块的文档字符串，而更可能位于项目的
    GitHub 或 SourceForge 页面的其他地方。
- en: Fill in the details under each topic. It’s important to be accurate. Since the
    documentation is in the same file as the code, it’s easier to be correct, complete,
    and consistent.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个主题下填写详细信息。准确性很重要。由于文档与代码位于同一文件中，因此更容易做到正确、完整和一致。
- en: 'Here’s an example of a docstring for a script:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个脚本的文档字符串示例：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the SYNOPSIS section, we used :: as a separate paragraph. In the EXAMPLES
    section, we used :: at the end of a paragraph. Both versions are hints to the
    RST processing tools that the indented section that follows should be typeset
    as code. See Chapter [17](ch021.xhtml#x1-91400017), [Documentation and Style](ch021.xhtml#x1-91400017).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '在概要部分，我们使用了 :: 作为独立的段落。在示例部分，我们在段落的末尾使用了 ::。这两种版本都是对 RST 处理工具的提示，表明接下来的缩进部分应该被格式化为代码。参见第[17](ch021.xhtml#x1-91400017)章，[文档和风格](ch021.xhtml#x1-91400017)。'
- en: Writing docstrings for library modules
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为库模块编写文档字符串
- en: 'When we document a library module, we need to focus on the needs of a programmer
    who will import the module to use it in their code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们记录库模块时，我们需要关注将导入模块以在他们的代码中使用程序员的需需求：
- en: Sketch an outline for the rest of the docstring. We’ll be using RST markup.
    Write the topic on one line. Include a line of = characters under each topic to
    make the topic into a proper heading. Remember to leave a blank line between each
    paragraph.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为文档字符串的其余部分绘制一个大纲。我们将使用 RST 标记。在一行上写下主题。在每个主题下方包括一行等号字符，以将主题转换为适当的标题。请记住，在每段之间留一个空行。
- en: 'Start as shown previously, creating a summary sentence:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照之前所示开始，创建一个总结句子：
- en: 'DESCRIPTION: A summary of what the module contains and why the module is useful'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述：模块内容的摘要以及为什么模块是有用的
- en: 'MODULE CONTENTS: The classes and functions defined in this module'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块内容：在此模块中定义的类和函数
- en: 'EXAMPLES: Examples of using the module'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：使用此模块的示例
- en: Fill in the details for each topic. The module contents may be a long list of
    class or function definitions. The docstring should be a summary. Within each
    class or function, we’ll have a separate docstring with the details for that item.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个主题填写详细信息。模块内容可能是一长串类或函数定义的列表。文档字符串应该是一个摘要。在每个类或函数中，我们将有一个单独的文档字符串，其中包含该项目的详细信息。
- en: 2.3.3 How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3.3 它是如何工作的...
- en: Over the decades, the man page outline has evolved to contain a complete description
    of Linux commands. This general approach to writing documentation has proven useful
    and resilient. We can capitalize on a large body of experience, and structure
    our documentation to follow the man page model.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，man 页面大纲已经发展成为一个包含 Linux 命令完整描述的工具。这种编写文档的通用方法已被证明是有用且具有弹性的。我们可以利用大量的经验，并使我们的文档结构遵循
    man 页面模型。
- en: We want to prepare module docstrings that can be used by the Sphinx Python documentation
    generator (see [http://www.sphinx-doc.org/en/stable/](http://www.sphinx-doc.org/en/stable/)).
    This is the tool used to produce Python’s documentation files. The autodoc extension
    in Sphinx will read the docstring headers on our modules, classes, and functions
    to produce the final documentation that looks like other modules in the Python
    ecosystem.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要准备模块文档字符串，这些文档字符串可以被 Sphinx Python 文档生成器使用（参见 [http://www.sphinx-doc.org/en/stable/](http://www.sphinx-doc.org/en/stable/)）。这是用于生成
    Python 文档文件的工具。Sphinx 中的 autodoc 扩展会读取我们模块、类和函数上的文档字符串标题，以生成最终看起来像 Python 生态系统中的其他模块的文档。
- en: 2.3.4 There’s more...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3.4 更多内容...
- en: 'RST markup has a simple, central syntax rule: paragraphs are separated by blank
    lines.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: RST 标记具有简单、中心的语法规则：段落由空白行分隔。
- en: This rule makes it easy to write documents that can be examined by the various
    RST processing tools and reformatted to look nice.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则使得编写可以被各种 RST 处理工具检查并重新格式化以看起来很棒的文档变得容易。
- en: It can be challenging to write good software documentation. There’s a broad
    chasm between too little information and documentation that recapitulates details
    apparent from looking at the code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 编写好的软件文档可能具有挑战性。信息不足和重复代码中明显细节的文档之间存在很大的鸿沟。
- en: What’s important is to focus on the needs of a person who doesn’t know too much
    about the software or how it works, but can read the Python code. Provide this
    semi-knowledgeable user with the information they need to understand what the
    software does and how to use it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要关注那些对软件或其工作方式不太了解的人的需求，但他们可以阅读 Python 代码。为这样的半知识用户提供他们需要的信息，以便理解软件的功能和使用方法。
- en: 2.3.5 See also
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3.5 参考信息
- en: We look at additional techniques in [Writing better docstrings with RST markup](ch006_split_000.xhtml#x1-1090004).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 [使用 RST 标记编写更好的文档字符串](ch006_split_000.xhtml#x1-1090004) 中探讨了额外的技术。
- en: If we’ve used the [Writing Python script and module files – syntax basics](ch006_split_000.xhtml#x1-850001)
    recipe, we’ll have put a documentation string in our script file. When we build
    functions in Chapter [3](ch007_split_000.xhtml#x1-1610003), and classes in Chapter [7](ch011_split_000.xhtml#x1-3760007),
    we’ll look at other places where documentation strings can be placed.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用了 [编写 Python 脚本和模块文件 – 语法基础](ch006_split_000.xhtml#x1-850001) 的配方，我们将在脚本文件中放置一个文档字符串。当我们构建第
    3 章 [3](ch007_split_000.xhtml#x1-1610003) 中的函数和第 7 章 [7](ch011_split_000.xhtml#x1-3760007)
    中的类时，我们将查看其他可以放置文档字符串的地方。
- en: See [http://www.sphinx-doc.org/en/stable/](http://www.sphinx-doc.org/en/stable/)
    for more information on Sphinx.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 Sphinx 的信息，请参见 [http://www.sphinx-doc.org/en/stable/](http://www.sphinx-doc.org/en/stable/)。
- en: For more background on the man page outline, see [https://en.wikipedia.org/wiki/Man_page](https://en.wikipedia.org/wiki/Man_page).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 man 页面大纲的背景信息，请参见 [https://en.wikipedia.org/wiki/Man_page](https://en.wikipedia.org/wiki/Man_page)。
- en: 2.4 Writing better docstrings with RST markup
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.4 使用 RST 标记编写更好的文档字符串
- en: When we have a useful script, we often need to leave notes on what it does,
    how it works, and when it should be used. Many tools for producing documentation,
    including Docutils, work with RST markup. This allows us to write plain text documentation.
    It can include some special punctuation to pick a bold or italic font variant
    to call attention to details. In addition, RST permits organizing content via
    lists and section headings.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个有用的脚本时，我们经常需要留下关于它做什么、如何工作以及何时应该使用的笔记。包括 Docutils 在内的许多生成文档的工具都与 RST 标记一起工作。这允许我们编写纯文本文档。它可以包括一些特殊标点符号，以选择粗体或斜体字体变体来强调细节。此外，RST
    允许通过列表和章节标题来组织内容。
- en: 2.4.1 Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4.1 准备工作
- en: In the [Including descriptions and documentation](ch006_split_000.xhtml#x1-1010003)
    recipe, we looked at putting some basic documentation into a module. We’ll look
    at a few of the RST formatting rules for creating readable documentation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [包含描述和文档](ch006_split_000.xhtml#x1-1010003) 的配方中，我们探讨了将一些基本文档放入模块中。我们将查看一些
    RST 格式化规则，用于创建可读的文档。
- en: 2.4.2 How to do it...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4.2 如何做...
- en: Start with an outline of the key point, creating RST section titles to organize
    the material. A section title has a one-line title followed by a line of underline
    characters using =, -, ^, ~ as long as the title.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从关键点的概述开始，创建 RST 部分标题以组织材料。一个部分标题有一行标题，后面跟着一行与标题长度相等的下划线字符，使用 =、-、^、~。
- en: 'A heading will look like this:'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个标题看起来像这样：
- en: '[PRE20]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The heading text is on one line and the underlining characters are on the next
    line. This must be surrounded by blank lines. There can be more underline characters
    than title characters, but never fewer.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标题文本在一行，下划线字符在下一行。这必须被空白行包围。下划线字符可以多于标题字符，但决不能少于。
- en: The RST tools will infer our chosen pattern of using underlining characters.
    As long as the underline characters are used consistently, the docutil tools will
    detect the document’s structure.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RST 工具将推断我们选择的下划线字符的使用模式。只要下划线字符使用一致，docutil 工具就能检测文档的结构。
- en: 'When starting out, it can help to have an explicit standard for heading underlines:'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在开始时，有一个明确的标题下划线标准可能会有所帮助：
- en: '|'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '| Character | Level |'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 字符 | 级别 |'
- en: '|'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '| = | 1 |'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| = | 1 |'
- en: '| - | 2 |'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| - | 2 |'
- en: '| ^ | 3 |'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ^ | 3 |'
- en: '| ~ | 4 |'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| ~ | 4 |'
- en: '|'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |  |'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  |  |'
- en: Fill in the various paragraphs. Paragraphs (including the section titles) are
    separated by at least one empty line.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写各种段落。段落（包括部分标题）至少由一个空行分隔。
- en: If the programming editor has a spell checker, use it. Doing this can be frustrating
    because the code samples often have abbreviations that fail spell checking.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果编程编辑器有拼写检查器，请使用它。这样做可能会很令人沮丧，因为代码示例通常包含拼写检查失败的缩写。
- en: 2.4.3 How it works...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4.3 它是如何工作的...
- en: The Docutils conversion programs will examine the document, looking for sections
    and body elements. A section is identified by a title. The underlines are used
    to organize the sections into a properly nested hierarchy.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Docutils 转换程序将检查文档，寻找部分和主体元素。部分通过标题识别。下划线用于将部分组织成适当的嵌套层次结构。
- en: 'A properly nested document might have the following sequence of underline characters:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正确嵌套的文档可能具有以下下划线字符序列：
- en: '[PRE21]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When an HTML file is created from the documentation it will have <h1>, <h2>,
    and <h3> tags for the various levels. Creating a LaTeX file requires some additional
    configuration choices, but the common Article template means the resulting document
    will use \section, \subsection, and \subsubsection headings. These final presentation
    choices aren’t our primary concern when writing; the most important point is to
    use proper underlines to reflect the desired organization.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当从文档创建 HTML 文件时，它将具有 <h1>、<h2> 和 <h3> 标签以表示不同级别。创建 LaTeX 文件需要一些额外的配置选择，但常见的文章模板意味着生成的文档将使用
    \section、\subsection 和 \subsubsection 标题。当我们写作时，这些最终的表现选择并不是我们的主要关注点；最重要的是使用适当的下划线来反映所需的组织结构。
- en: 'There are several different kinds of body elements the RST parser can recognize.
    We’ve shown a few. A more complete list includes:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: RST 解析器可以识别几种不同的主体元素。我们已经展示了几个。更完整的列表包括：
- en: 'Paragraphs of text: These might use inline markup for different kinds of emphasis
    or highlighting.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本段落：这些可能使用内联标记来表示不同类型的强调或突出显示。
- en: 'Literal blocks: These are introduced with :: and indented with four spaces.
    They may also be introduced with the .. parsed-literal:: directive. A doctest
    block is indented with four spaces and includes the Python >>> prompt.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '文本块：这些通过 :: 引入，并缩进四个空格。它们也可以通过 .. parsed-literal:: 指令引入。doctest 块缩进四个空格，并包含
    Python >>> 提示符。'
- en: 'Lists, tables, and block quotes: We’ll look at these later. These can contain
    other body elements.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表、表格和块引用：我们稍后会讨论这些。这些可以包含其他主体元素。
- en: 'Footnotes: These are special paragraphs. When rendered, they may be displayed
    at the bottom of a page or at the end of a section. These can also contain other
    body elements.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚注：这些是特殊的段落。在渲染时，它们可能显示在页面底部或部分末尾。它们也可以包含其他主体元素。
- en: 'Hyperlink targets, substitution definitions, and RST comments: These are more
    specialized text items that we won’t look at closely here.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超链接目标、替换定义和 RST 注释：这些是更专业的文本项，我们在这里不会详细讨论。
- en: 2.4.4 There’s more...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4.4 更多内容...
- en: 'In the Including descriptions and documentation recipe, we looked at several
    different kinds of body elements we might use:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含描述和文档的食谱中，我们查看了几种不同的主体元素，我们可能会使用：
- en: 'Paragraphs of text: This is a block of text surrounded by blank lines. Within
    these, we can make use of inline markup to emphasize words or phrases. We’ll look
    at inline markup in the [Writing better docstrings with RST markup](ch006_split_000.xhtml#x1-1090004)
    recipe.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本段落：这是一个由空白行包围的文本块。在这些段落中，我们可以使用内联标记来强调单词或短语。我们将在[使用RST标记编写更好的docstrings](ch006_split_000.xhtml#x1-1090004)菜谱中查看内联标记。
- en: 'Lists: These are paragraphs that begin with something that looks like a number
    or a bullet. We might have paragraphs like this.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表：这些段落以看起来像数字或项目符号的东西开始。我们可能会有这样的段落。
- en: '[PRE22]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Other characters can be used at the start of the line, but - and * seem to be
    the most common choices.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 行首可以使用其他字符，但 - 和 * 似乎是最常见的选项。
- en: 'Numbered lists: There are a variety of patterns that are recognized. This includes
    leading digits or letters followed by . or ). Using # instead of a digit or letter
    will continue from the previous paragraph value.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '编号列表：存在多种可识别的模式。这包括以数字或字母开头，后跟 . 或 )。使用 # 而不是数字或字母将延续前一段落的值。'
- en: 'Literal blocks: A code sample is presented literally, without looking for RST
    elements. The text for this must be indented. A handy prefix is ::. A .. code-block::
    directive is also possible.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '文字块：代码示例以纯文本形式呈现，不寻找RST元素。此文本必须缩进。一个方便的前缀是 ::。也可以使用 .. code-block:: 指令。'
- en: 'Directives: A directive is a paragraph that generally looks like .. directive::.
    It may have some content that’s indented to be contained within the directive.
    It might look like this:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令：指令通常看起来像 .. directive::。它可能有一些内容，这些内容缩进以包含在指令内。它可能看起来像这样：
- en: '[PRE23]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The .. important:: text is the directive. This is followed by text indented
    within the directive.'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '.. important:: 文本是指令。这后面跟着指令内的缩进文本。'
- en: Using directives
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用指令
- en: Docutils has several built-in directives. The Sphinx tool adds a large number
    of additional directives with a variety of features.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Docutils有几个内置指令。Sphinx工具添加了大量具有各种功能的额外指令。
- en: 'Some of the most commonly used directives are the admonitions: attention, caution,
    danger, error, hint, important, note, tip, warning, and a generic admonition.
    These are compound body elements because they have nested text within them. Above,
    we provided an example of the important admonition.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的指令之一是警告：注意、警告、危险、错误、提示、重要、注意、技巧、警告和通用警告。这些是复合体元素，因为它们内部有嵌套文本。上面，我们提供了一个重要警告的例子。
- en: Using inline markup
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内联标记
- en: 'Within a paragraph, we have several forms of inline markup we can use:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个段落中，我们有几种内联标记可以使用：
- en: We can surround a word or phrase with * for *emphasis*. This is commonly typeset
    as italic.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以用 * 将单词或短语包围起来以实现 *强调*。这通常以斜体形式排版。
- en: We can surround a word or phrase with ** for **strong**. This is commonly typeset
    as bold.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以用 ** 将单词或短语包围起来以实现 **强烈**强调。这通常以粗体形式排版。
- en: 'We surround references with single back-ticks, ‘. Links are followed by an
    underscore, _. We might use ‘section title‘_ to refer to a specific section within
    a document. We don’t generally need to put any markup around URLs. The Docutils
    tools recognize these. Sometimes we want a word or phrase to be shown and the
    URL concealed. We can use this: ‘the \textbf{Sphinx} documentation <http://www.sphinx-doc.org/en/stable/>‘_.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们用单反引号 `‘` 将引用包围起来，链接后跟下划线 `_. 我们可能使用 `‘section title‘_` 来引用文档中的特定部分。我们通常不需要在URL周围放置任何标记。Docutils工具可以识别这些。有时我们希望显示一个单词或短语，而隐藏URL。我们可以使用这个：`‘the \textbf{Sphinx} documentation
    <http://www.sphinx-doc.org/en/stable/>‘_`。
- en: We can surround code-related words with a double back-tick, ‘‘, to make them
    look like ‘‘code‘‘. This will be typeset as code.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以用双反引号 `‘‘` 将与代码相关的单词包围起来，使它们看起来像 `‘‘代码‘‘`。这将作为代码排版。
- en: 'There’s also a more general technique called a role. A role starts with :word:
    as the role name, followed by the applicable word or phrase in single ‘ back-ticks.
    A text role looks like this: :strong:‘this‘.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，还有一种更通用的技术称为角色。角色以 :word: 作为角色名称开始，后跟单引号 `‘` 中的适用单词或短语。一个文本角色看起来像这样：:strong:‘this‘。'
- en: There are a number of standard role names, including :emphasis:, :literal:,
    :code:, :math:, :pep-reference:, :rfc-reference:, :strong:, :subscript:, :superscript:,
    and :title-reference:. Some of these are also available with simpler markup like
    *emphasis* or **strong**.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '有许多标准角色名称，包括 :emphasis:、:literal:、:code:、:math:、:pep-reference:、:rfc-reference:、:strong:、:subscript:、:superscript:
    和 :title-reference:。其中一些也可以使用更简单的标记，如 *emphasis* 或 **strong**。'
- en: Also, we can define new roles with a directive. If we want to do very sophisticated
    processing, we can provide the Docutils tool with class definitions for handling
    new roles. This allows us to tweak the way our document is processed.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用指令定义新的角色。如果我们想进行非常复杂的处理，我们可以为Docutils工具提供处理新角色的类定义。这允许我们调整文档的处理方式。
- en: 2.4.5 See also
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4.5 参考信息
- en: For more information on RST syntax, see [http://docutils.sourceforge.net](http://docutils.sourceforge.net).
    This includes a description of the Docutils tool.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于RST语法的更多信息，请参阅[http://docutils.sourceforge.net](http://docutils.sourceforge.net)。这包括对Docutils工具的描述。
- en: For information on Sphinx Python Documentation Generator, see [http://www.sphinx-doc.org/en/stable/](http://www.sphinx-doc.org/en/stable/).
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Sphinx Python文档生成器的信息，请参阅[http://www.sphinx-doc.org/en/stable/](http://www.sphinx-doc.org/en/stable/)。
- en: 2.5 Designing complex if...elif chains
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.5 设计复杂的if...elif链
- en: In most cases, our scripts will involve a number of choices. Sometimes the choices
    are simple, and we can judge the quality of the design with a glance at the code.
    In other cases, the choices are more complicated, and it’s not easy to determine
    whether or not our if statements are designed properly to handle all of the conditions.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们的脚本将涉及许多选择。有时选择很简单，我们可以通过查看代码来判断设计的质量。在其他情况下，选择更复杂，很难确定我们的if语句是否设计得当，能够处理所有条件。
- en: In the simplest case, we have one condition, C, and its inverse, ¬C. These are
    the two conditions for an if...else statement. One condition, C, is stated in
    the if clause; the inversion condition, ¬C, is implied in the else clause.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，我们有一个条件C及其逆否¬C。这是if...else语句的两个条件。一个条件C在if子句中声明；逆否条件¬C在else子句中隐含。
- en: 'This follows the Law of the Excluded Middle: we’re claiming there’s no missing
    alternative between the two conditions, C and ¬C. For a complex condition, though,
    this can be difficult to visualize.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循排中律：我们声称在两个条件C和¬C之间没有缺失的替代方案。然而，对于复杂条件，这可能很难可视化。
- en: 'If we have something like:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有类似以下的情况：
- en: '[PRE24]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It may not be immediately obvious, but we’ve omitted a number of possible alternatives.
    The weather and plan variables have four different combinations of values. One
    of the conditions is stated explicitly, the other three are assumed:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始并不明显，但我们已经省略了许多可能的替代方案。天气和计划变量有四种不同的值组合。其中一种条件是明确声明的，其他三种则是假设的：
- en: weather == RAIN and plan == GO_OUT. Bringing an umbrella seems right.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: weather == RAIN and plan == GO_OUT。带伞似乎是正确的。
- en: weather != RAIN and plan == GO_OUT. Bringing sunglasses seems appropriate.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: weather != RAIN and plan == GO_OUT。带太阳镜似乎是合适的。
- en: weather == RAIN and plan != GO_OUT. If we’re staying in, then neither accessory
    seems right.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: weather == RAIN and plan != GO_OUT。如果我们待在家里，那么似乎没有哪个附加物品是合适的。
- en: weather != RAIN and plan != GO_OUT. Again, the accessory question seems moot
    if we’re not going out.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: weather != RAIN and plan != GO_OUT。如果我们不出门，附加问题似乎就无关紧要了。
- en: How can we be sure we haven’t missed anything? How can we be sure we have not
    conflated too many things into a condition that’s assumed instead of being stated?
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确保我们没有遗漏任何东西？我们如何确保我们没有将太多东西合并到一个假设的条件中，而不是明确声明？
- en: 2.5.1 Getting ready
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5.1 准备工作
- en: 'Let’s look at a concrete example of an if...elif chain. In the casino game
    of Craps, there are a number of rules that apply to a roll of two dice. These
    rules apply on the first roll of the game, called the come-out roll:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个if...elif链的具体例子。在骰子游戏Craps中，有一些规则适用于两个骰子的投掷。这些规则适用于游戏的第一次投掷，称为开场投掷：
- en: 2, 3, or 12 is craps, which is a loss for most bets.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2, 3, 或 12是Craps，对于大多数赌注来说，这是输。
- en: 7 or 11 is a winner for most bets.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7或11是大多数赌注的赢家。
- en: The remaining numbers establish a point. The dice-rolling continues based on
    another set of rules.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余的数字确定一个点。掷骰子将继续根据另一组规则进行。
- en: We’ll use this set of three conditions as an example for looking at this recipe
    because it has a potentially vague clause in it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这组三个条件作为例子来查看这个食谱，因为它包含一个可能含糊不清的条款。
- en: 2.5.2 How to do it...
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5.2 如何做到...
- en: When we write an if statement, even when it appears trivial, we need to be sure
    that all conditions are covered.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写if语句时，即使它看起来很 trivial，我们也需要确保所有条件都已涵盖。
- en: 'Enumerate the conditions we know. In our example, we have three rules: the
    (2, 3, 12) rule, the (7, 11) rule, and a vague statement of ”the remaining numbers.”
    This can form a first draft of an if statement.'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举我们已知的条件。在我们的例子中，我们有三个规则：（2, 3, 12）规则，（7, 11）规则，以及“剩余的数字”的模糊陈述。这可以形成一个if语句的第一稿。
- en: 'Determine the universe of all possible alternatives. For this example, there
    are 11 alternative outcomes: the numbers from 2 to 12, inclusive.'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定所有可能选择的全集。对于这个例子，有11种可能的结果：从2到12的数字，包括2和12。
- en: 'Compare the various if and elif conditions, C, with the universe of alternatives,
    U. There are three possible design patterns:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将各种if和elif条件C与选择的全集U进行比较。存在三种可能的设计模式：
- en: We have more if conditions in the code than are possible in the universe of
    alternatives, C ⊂ U. The most common cause is failing to completely enumerate
    all possible alternatives in the universe. We might, for example, have modeled
    dice using 0 to 5 instead of 1 to 6\. The universe of alternatives appears to
    be the values from 0 to 10, yet there are conditions for 11 and 12.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中，我们有的if条件比选择的全集C ⊂ U中的可能条件要多。最常见的原因是未能完全列举宇宙中所有可能的选择。例如，我们可能用0到5而不是1到6来模拟骰子。选择的全集看起来是从0到10的值，但实际上有针对11和12的条件。
- en: We have gaps in the conditions in our code, U ∖ C≠∅. The most common cause of
    alternatives in the universe without a clearly-stated if condition is failing
    to fully understand the conditions in the code. We might, for example, have enumerated
    the values as two tuples instead of sums. The numbers 2, 3 and 12 are defined
    by a number of pairs, including (1, 1), (1, 2), and (6, 6). It’s possible to overlook
    the condition (2, 1), leaving this untested by any clause of the if statement.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们代码中的条件有间隙，U ∖ C≠∅。宇宙中未明确声明的if条件的选择的最常见原因是未能完全理解代码中的条件。例如，我们可能将值列举为两个元组而不是总和。2、3和12由一对数字定义，包括（1,
    1）、（1, 2）和（6, 6）。可能会忽略条件（2, 1），使得if语句的任何子句都没有对其进行测试。
- en: We can prove there’s a match between conditions expressed in the code and the
    universe of alternatives, U ≡ C. This is ideal. The universe of all possible alternatives
    matches all the conditions in the if and elif clauses of the statement.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以证明代码中表达的条件与选择的全集U之间有匹配，即U ≡ C。这是理想的。所有可能选择的全集与语句的if和elif子句中的所有条件相匹配。
- en: In this example, it’s easy to enumerate all of the possible alternatives. In
    other cases, it can take some careful reasoning to understand any gaps or omissions.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，列举所有可能的选择很容易。在其他情况下，可能需要一些仔细的推理来理解任何间隙或遗漏。
- en: In this example, we have a vague term, remaining numbers, which we can replace
    with the list of values (4, 5, 6, 8, 9, 10). Supplying a list removes any possible
    gaps and doubts.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个模糊的术语，剩余的数字，我们可以用值列表（4, 5, 6, 8, 9, 10）来替换。提供列表可以消除任何可能的间隙和疑问。
- en: When there are exactly two alternatives, we can write a condition expression
    for one of the alternatives. The other condition can be implied; an if and else
    will work.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当恰好有两个选择时，我们可以为其中一个选择编写条件表达式。另一个条件可以隐含；if和else将工作。
- en: 'When we have more than two alternatives, we can use this recipe to write a
    chain of if and elif statements, one statement per alternative:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有超过两个选择时，我们可以使用这个方法来编写一系列的if和elif语句，每个选择一个语句：
- en: 'Write an if ... elif ... elif chain that covers all of the known alternatives.
    For our example, it might start like this:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个涵盖所有已知选择的if ... elif ... elif链。对于我们的例子，它可能开始如下：
- en: '[PRE25]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add an else clause that raises an exception, like this:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个引发异常的else子句，如下所示：
- en: '[PRE26]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This extra else gives us a way to positively identify when a logic problem is
    found. We can be sure that any design error we made will lead to a conspicuous
    problem when the program runs. Ideally, we’ll find any problems while we’re unit
    testing.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这个额外的else为我们提供了一种方法来正确定位逻辑问题时。我们可以确信，我们做出的任何设计错误在程序运行时都会导致一个明显的问题。理想情况下，我们将在单元测试期间发现任何问题。
- en: In this case, it is clear that all 11 alternatives are covered by the if statement
    conditions. The extra else can’t ever be used. Not all real-world problems have
    this kind of easy proof that all the alternatives are covered by conditions. It
    can help to provide a noisy failure mode.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，很明显，所有11个选择都被if语句的条件所覆盖。额外的else永远不会被使用。并非所有现实世界的问题都有这种简单的方法来证明所有选择都被条件所覆盖。这有助于提供一个嘈杂的故障模式。
- en: 2.5.3 How it works...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5.3 它是如何工作的...
- en: Our goal is to be sure that our program works reliably. While testing helps,
    we can still have the same wrong assumptions when doing design and creating test
    cases.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是确保我们的程序可靠地工作。虽然测试有帮助，但在设计和创建测试用例时，我们仍然可能做出错误的假设。
- en: While rigorous logic is essential, we can still make mistakes. Further, someone
    doing ordinary software maintenance might introduce an error. Adding a new feature
    to a complex if statement is a potential source of problems.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然严格的逻辑是必不可少的，但我们仍然可能犯错。此外，进行普通软件维护的人可能会引入错误。向复杂if语句中添加新功能可能是问题的潜在来源。
- en: This Else-Raise design pattern forces us to be explicit for each and every condition.
    Nothing is assumed. As we noted previously, any error in our logic will be uncovered
    if the exception gets raised.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这种Else-Raise设计模式迫使我们对每个条件都进行明确说明。没有任何假设。正如我们之前提到的，如果异常被抛出，我们逻辑中的任何错误都将被揭露。
- en: Crashing with an exception is sensible behavior in the presence of a design
    problem. While an alternative is to write a message to an error log, a program
    with this kind of profound design flaw should be viewed as fatally broken.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计问题时，通过异常崩溃是一种合理的行为。虽然另一种选择是将消息写入错误日志，但具有这种深刻设计缺陷的程序应被视为致命损坏。
- en: 2.5.4 There’s more...
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5.4 更多内容...
- en: In many cases, we can derive an if...elif...elif chain from an examination of
    the desired post condition at some point in the program’s processing. For example,
    we may need a statement that establishes something like m is equal to the larger
    of a or b.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们可以通过检查程序处理过程中的某个点的期望后置条件来推导出if...elif...elif链。例如，我们可能需要一个语句来建立类似于m等于a或b中较大的数。
- en: (For the sake of working through the logic, we’ll avoid Python’s handy m = max(a, b),
    and focus on the way we can compute a result from exclusive choices.)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: （为了处理逻辑，我们将避免使用Python的便捷的m = max(a, b)，并关注我们如何从排他性选择中计算结果。）
- en: 'We can formalize the final condition like this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样形式化最终条件：
- en: '![(m = a ∨m = b)∧ m ≥ a∧ m ≥ b ](img/file12.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![（m = a ∨ m = b）∧ m ≥ a ∧ m ≥ b](img/file12.png)'
- en: 'We can work backward from this final condition, by writing the goal as an assert
    statement:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将目标写成断言语句来从这个最终条件反向工作：
- en: '[PRE27]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once we have the goal stated, we can identify statements that lead to that goal.
    Clearly, assignment statements like m = a or m = b would be appropriate, but each
    of these works only under limited conditions.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们明确了目标，我们就可以识别出导致该目标实现的语句。显然，像m = a或m = b这样的赋值语句是合适的，但每个都只在有限条件下有效。
- en: We can derive the precondition that shows when these statements should be used.
    The preconditions for an assignment statement will be written in if and elif expressions.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以推导出这些语句应该使用的前提条件。赋值语句的前提条件将用if和elif表达式编写。
- en: 'We need to use the statement m = a when a >= b. Similarly, we need to use the
    statement m = b when b >= a. Rearranging logic into code gives us this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当a >= b时，我们需要使用语句m = a。同样，当b >= a时，我们需要使用语句m = b。将逻辑重新排列成代码，我们得到如下：
- en: '[PRE28]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that our universe of conditions, U = {a ≥ b,b ≥ a}, is complete; there’s
    no other possible relationship. Also notice that in the edge case of a = b, we
    don’t actually care which assignment statement is used. Python will process the
    decisions in order and will execute m = a. The fact that this choice is consistent
    shouldn’t have any impact on our design of the if...elif...elif chain. We can
    design the conditions without regard to the order of evaluation of the clauses.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的条件集合U = {a ≥ b, b ≥ a}是完整的；没有其他可能的关系。此外，请注意，在a = b的边缘情况下，我们实际上并不关心使用哪个赋值语句。Python将按顺序处理决策，并执行m
    = a。这种选择的一致性不应该对我们的if...elif...elif链的设计有任何影响。我们可以不考虑子句的评估顺序来设计条件。
- en: 2.5.5 See also
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5.5 参见
- en: This is somewhat similar to the syntactic problem of the ”dangling else.” See
    [https://docs.oracle.com/javase/specs/jls/se9/html/jls-14.html](https://docs.oracle.com/javase/specs/jls/se9/html/jls-14.html).
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这与“悬挂else”的语法问题有些相似。参见[https://docs.oracle.com/javase/specs/jls/se9/html/jls-14.html](https://docs.oracle.com/javase/specs/jls/se9/html/jls-14.html)。
- en: This isn’t the same problem; Python’s indentation removes the ”dangling else”
    syntax problem. This is an adjacent semantic problem of trying to be sure that
    all conditions are properly accounted for in a complex if...elif...elif chain.
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这不是同一个问题；Python的缩进消除了“悬挂else”语法问题。这是一个相邻的语义问题，试图确保在复杂的if...elif...elif链中所有条件都得到适当考虑。
- en: 2.6 Saving intermediate results with the := ”walrus” operator
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.6 使用 := “walrus” 运算符保存中间结果
- en: Sometimes we’ll have a complex condition where we want to preserve an expensive
    intermediate result for later use. Imagine a condition that involves a complex
    calculation; the cost of computing is high measured in time, input-output operations,
    memory resources, or all three.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们会遇到一个复杂的情况，需要保留一个昂贵的中间结果以供后续使用。想象一下一个涉及复杂计算的条件；计算的成本很高，以时间、输入输出操作、内存资源或三者兼而有之来衡量。
- en: An example includes doing repetitive searches using the Regular Expression (re)
    package. A match() method can do quite a bit of computation before returning either
    a Match object or a None object to show the pattern wasn’t found. Once this computation
    is completed, we may have several uses for the result, and we emphatically do
    not want to perform the computation again. Often, the initial use is the simple
    check to see if the result is a Match object or None.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是使用正则表达式（re）包进行重复搜索。match()方法可以在返回Match对象或None对象（表示没有找到模式）之前进行相当多的计算。一旦这个计算完成，我们可能需要使用这个结果，并且我们绝对不希望再次进行计算。通常，最初的使用是简单地检查结果是否是Match对象或None。
- en: This is an example where it can be helpful to assign a name to the value of
    an expression and also use the expression in an if statement. We’ll look at how
    to use the ”assignment expression” or ”walrus” operator. It’s called the walrus
    because the assignment expression operator, :=, looks like the face of a walrus
    to some people.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可以给表达式的值命名并也在if语句中使用表达式的例子。我们将探讨如何使用“赋值表达式”或“walrus”操作符。它被称为walrus，因为赋值表达式操作符
    := 对某些人来说看起来像海象的脸。
- en: 2.6.1 Getting ready
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6.1 准备工作
- en: 'Here’s a summation where—eventually—each term becomes so small that there’s
    no point in continuing to add it to the overall total:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个求和示例，最终每个项都变得如此之小，以至于继续将其加到总和中已经没有意义了：
- en: '![ ∑ (--1---)2 0≤n<∞ 2n+ 1 ](img/file13.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑ (--1---)2 0≤n<∞ 2n+ 1 ](img/file13.png)'
- en: 'In effect, this is something like the following summation function:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这类似于以下求和函数：
- en: '[PRE29]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: What’s not clear is the question of how many terms are required. In the example,
    we’ve summed 20,000 values. But what if 16,000 are enough to provide an accurate
    answer?
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 不清楚的是需要多少项的问题。在示例中，我们求和了20,000个值。但如果16,000个就足以提供一个准确的答案呢？
- en: 'We don’t want to write a summation like this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想编写这样的求和：
- en: '[PRE30]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This example repeats an expensive computation, (1/(2*n+1))**2\. We can avoid
    processing that includes this kind of time-wasting overhead by using the walrus
    operator.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子重复了一个昂贵的计算，(1/(2*n+1))**2。我们可以通过使用walrus操作符来避免包含这种浪费时间开销的处理。
- en: 2.6.2 How to do it...
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6.2 如何做...
- en: 'First we isolate an expensive operation that’s part of a conditional test.
    In this example, the variable term is used to hold the expensive result:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们隔离一个昂贵的操作，它是条件测试的一部分。在这个例子中，变量term用于保存昂贵的计算结果：
- en: '[PRE31]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Rewrite the assignment statement to use the := assignment operator. This replaces
    the simple condition of the if statement.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将赋值语句重写为使用 := 赋值操作符。这取代了if语句的简单条件。
- en: 'Add an else condition to break out of the for statement if no more terms are
    needed. Here’s the results of these two steps:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个else条件以跳出for语句，如果不再需要更多项的话。以下是这两个步骤的结果：
- en: '[PRE32]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that we changed the summation variable. In the previous step of the recipe,
    it was p. In this step, it’s q. This permits easy side-by-side comparisons to
    be sure the results are still correct.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们改变了求和变量。在食谱的先前的步骤中，它是p。在这个步骤中，它是q。这允许我们轻松地进行并排比较，以确保结果仍然是正确的。
- en: The assignment expression := lets us do two things in the if statement.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值表达式 := 允许我们在if语句中做两件事。
- en: 2.6.3 How it works...
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6.3 它是如何工作的...
- en: The assignment expression operator := saves an intermediate result. The operator’s
    result value is the same as the right-hand side operand. This means that the expression
    a + (b := c+d) is the same as the expression a+(c+d). The difference between the
    expression a + (b := c+d) and the expression a+(c+d) is the side-effect of setting
    the value of the b variable partway through the evaluation.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值表达式操作符 := 保存了一个中间结果。操作符的结果值与右侧操作数相同。这意味着表达式 a + (b := c+d) 与表达式 a+(c+d) 相同。表达式
    a + (b := c+d) 与表达式 a+(c+d) 之间的区别在于在评估过程中设置b变量值的副作用。
- en: An assignment expression can be used in almost any kind of context where expressions
    are permitted in Python. The most common cases are if statements. Another good
    idea is inside a while condition.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值表达式可以在Python中几乎任何允许表达式的地方使用。最常见的情况是if语句。另一个好主意是放在while条件中。
- en: 'They’re also forbidden in a few places. They cannot be used as the operator
    in an expression statement. We’re specifically prohibited from writing a := 2
    as a statement: there’s a perfectly good assignment statement for this purpose
    and an assignment expression, while similar in intent, is potentially confusing.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 它在几个地方也是被禁止的。它们不能用作表达式语句中的运算符。我们特别禁止将:=2写为一个语句：这里有一个完美的赋值语句用于此目的，而赋值表达式，虽然意图相似，但可能存在混淆。
- en: 2.6.4 There’s more...
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6.4 更多内容...
- en: We can do some more optimization of our infinite summation example, shown earlier
    in this recipe. The use of a for statement and a range() object seems simple.
    The problem is that we want to end the for statement early—when the terms being
    added are so small that they have no significant change in the final sum.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对前面这个菜谱中展示的无限求和示例进行一些优化。使用for语句和range()对象看起来很简单。问题是，我们希望提前结束for语句——当被加的项非常小，对最终总和没有显著变化时。
- en: 'We can combine the early exit with the term computation:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将提前退出与项计算结合起来：
- en: '[PRE33]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We’ve used a while statement with the assignment expression operator. This will
    compute a value using (1/(2*n+1))**2, and assign this to the term variable. If
    the value is significant, we’ll add it to the sum, r, and increment the value
    for the n variable. If the value assigned to term is too small to be significant,
    the while statement will end.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个带有赋值表达式运算符的while语句。这将计算一个值，使用(1/(2*n+1))**2，并将其分配给term变量。如果这个值是显著的，我们将它加到总和r上，并增加n变量的值。如果分配给term的值太小，不足以显著，while语句将结束。
- en: 'Here’s another example, showing how to compute running sums of a collection
    of values. This looks forward to concepts in Chapter [4](ch008_split_000.xhtml#x1-2240004).
    Specifically, this shows a list comprehension built using the assignment expression
    operator:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，展示了如何计算一系列值的运行总和。这预示了第[4](ch008_split_000.xhtml#x1-2240004)章中的概念。具体来说，这展示了使用赋值表达式运算符构建的列表推导式：
- en: '[PRE34]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We’ve started with some data, in the data variable. This might be minutes of
    exercise each day for most of a week. The value of the final running_sum variable
    is a list object, built by evaluating the expression (total := total + d) for
    each value, d, in the data variable. Because the assignment expression changes
    the value of the total variable, the resulting list is the result of each new
    value being accumulated.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一些数据开始，在data变量中。这可能是大多数一周内每天的锻炼分钟数。final_running_sum变量的值是一个列表对象，通过评估表达式(total
    := total + d)对data变量中的每个值d进行计算而构建。因为赋值表达式改变了total变量的值，所以得到的列表是每个新值累加的结果。
- en: 2.6.5 See also
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6.5 参考内容
- en: For details on assignment expression, see [PEP-572](https://www.python.org/dev/peps/pep-0572/),
    where the feature was first described.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于赋值表达式的详细信息，请参阅[PEP-572](https://www.python.org/dev/peps/pep-0572/)，其中首次描述了该功能。
- en: 2.7 Avoiding a potential problem with break statements
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.7 避免使用break语句可能引起的问题
- en: The common way to understand a for statement is that it creates a for all condition.
    At the end of the statement, we can assert that, for all items in a collection,
    the processing in the body of the statement has been done.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 理解for语句的常见方式是它创建了一个对所有条件的for条件。在语句的末尾，我们可以断言，对于集合中的所有项目，语句体内的处理已经完成。
- en: This isn’t the only meaning a for statement can have. When the break statement
    is used inside the body of a for statement, it changes the semantics to there
    exists. When the break statement leaves the for (or while) statement, we can assert
    there exists at least one item that caused the enclosing statement to end.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: for语句并不只有一种含义。当break语句在for语句的体内使用时，它改变了语义为存在。当break语句离开for（或while）语句时，我们可以断言至少存在一个项目导致了包含语句的结束。
- en: There’s a side issue here. What if the for statement ends without executing
    the break statement? Either way, we’re at the statement after the for statement.
    The condition that’s true upon leaving a for or while statement with a break statement
    can be ambiguous. We can’t easily tell; this recipe gives some design guidance.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个附带问题。如果for语句在没有执行break语句的情况下结束，会怎样？无论如何，我们都在for语句之后的语句。使用break语句退出for或while语句时，所得到的条件可能是模糊的。我们无法轻易判断；这个方案提供了一些设计指导。
- en: The problem is magnified when we have multiple break statements, each with its
    own condition. How can we minimize the problems created by having these complicated
    conditions for leaving a for or while statement?
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有多条break语句，每条都有其自己的条件时，问题会放大。我们如何最小化由这些复杂的条件造成的退出for或while语句时产生的问题？
- en: 2.7.1 Getting ready
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7.1 准备工作
- en: 'When parsing configuration files, we often need to find the first occurrence
    of a : or = character in a string. The property file format uses a property name
    and : or = followed by a value.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析配置文件时，我们经常需要在字符串中找到第一个:或=字符。属性文件格式使用属性名和:或=后跟值。
- en: 'Finding the punctuation mark is an example of a there exists modification to
    a for statement. We don’t want to process all characters; we want to know where
    the leftmost : or = character is found.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 找到标点符号是for语句存在修改的一个例子。我们不想处理所有字符；我们想知道最左边的:或=字符在哪里被找到。
- en: 'Here’s the sample data we’re going use as an example:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们要用作例子的样本数据：
- en: '[PRE35]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here’s a small for statement to locate the leftmost : or = character in the
    sample string value:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小的for语句，用于在样本字符串值中定位最左边的:或=字符：
- en: '[PRE36]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When the = character is found, the break statement ends the for statement. The
    value of the position variable shows where the desired character was found.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当发现等号（=）字符时，break语句结束for语句。位置变量的值显示了所需字符被找到的位置。
- en: What about the following edge case?
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 关于以下边缘情况怎么办？
- en: '[PRE37]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The result is awkwardly wrong: the y character got dropped from the value of
    name. Why did this happen? And, more importantly, how can we make the condition
    at the end of the for statement clearer?'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是尴尬的错误：name的值中丢失了y字符。这是为什么？更重要的是，我们如何使for语句末尾的条件更清晰？
- en: 2.7.2 How to do it...
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7.2 如何实现...
- en: 'Every statement establishes a post-condition. When designing a for or while
    statement, we need to articulate the condition that should be true at the end
    of the statement. Ideally, the post-condition is something simple like text[position] in ’=:’.
    However, in the case where there’s no = or : in the given text, the overly simple
    post-condition can’t be true.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 每个语句都建立了一个后置条件。当设计for或while语句时，我们需要明确语句末尾应该成立的条件。理想情况下，后置条件是像text[position] in ’=:’这样的简单条件。然而，在给定文本中没有=或:的情况下，过于简单的后置条件可能不成立。
- en: 'At the end of the for statement, one of these two things are true:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在for语句的末尾，以下两种情况之一是真实的：
- en: 'Either the character with the index of position is : or ='
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要么是位置索引的字符是:或=
- en: 'Or all characters have been examined and no character is : or ='
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者所有字符都已检查，并且没有字符是:或=
- en: Our application code needs to handle both cases.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序代码需要处理这两种情况。
- en: 'Write the obvious post-condition. We sometimes call this the happy-path condition
    because it’s the one that’s true when nothing unusual has happened:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出明显的后置条件。我们有时称这为“快乐路径”条件，因为它是在没有发生任何异常时为真的条件：
- en: '[PRE38]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create the overall post-condition by adding the conditions for the edge cases.
    In this example, we have two additional conditions:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加边缘情况的条件来创建整体的后置条件。在这个例子中，我们有两个额外的条件：
- en: There’s no = or :.
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有等号（=）或冒号（:）。
- en: There are no characters at all. This means the len() is zero, and the for statement
    never actually did anything. This also means the position variable will never
    be created.
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有字符。这意味着len()是零，for语句实际上从未执行过。这也意味着位置变量永远不会被创建。
- en: 'In this example, then, we have discovered a total of three conditions:'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，我们已经发现了总共三个条件：
- en: len(text) == 0
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: len(text) == 0
- en: not(’=’ in text or ’:’ in text), which can be stated in a number of ways. not(text[position] == ’:’ or text[position] == ’=’)
    might be most clear.
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: not(’=’ in text or ’:’ in text)，这可以用多种方式表达。not(text[position] == ’:’ or text[position] == ’=’)可能最清晰。
- en: text[position] in ’=:’
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: text[position] in ’=:’
- en: A while statement can be redesigned to have the complete set of post conditions
    in the while clause. This can eliminate the need for a break statement. Proper
    initialization of variables is still required.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个while语句可以被重新设计以在while子句中包含完整的后置条件集时，这可以消除使用break语句的需要。仍然需要正确初始化变量。
- en: 'When a for statement is being used, proper initialization of variables is required.
    Add if statements for the various terminating conditions after the body of the
    for statement. Here’s the resulting for statement and a complicated if statement
    to examine all of the possible post conditions:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用for语句时，需要正确初始化变量。在for语句的主体之后添加if语句，以处理各种终止条件。以下是结果for语句和复杂的if语句，用于检查所有可能的后置条件：
- en: '[PRE39]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the statements after the for statement, we’ve enumerated all of the terminating
    conditions explicitly.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在for语句之后的语句中，我们已经明确地列举了所有终止条件。
- en: 2.7.3 How it works...
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7.3 它是如何工作的...
- en: This approach forces us to work out the post-condition carefully so that we
    can be absolutely sure that we know all the reasons the for or while statement
    ended.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法迫使我们仔细地确定后置条件，以确保我们绝对知道for或while语句结束的所有原因。
- en: The idea here is to forego any assumptions or intuition. With a little bit of
    discipline, we can be sure of the post-conditions. It’s imperative to be explicit
    about the condition that’s true when a statement works. This is the goal of our
    software, and we can work backward from the goal by choosing the simplest statements
    that will make the goal conditions true.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是放弃任何假设或直觉。通过一点点的纪律，我们可以确保知道所有后置条件的原因。当语句正常工作时，明确该条件是真实的至关重要。这是我们软件的目标，我们可以通过选择最简单的语句来实现目标条件，从而从目标逆向工作。
- en: 2.7.4 There’s more...
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7.4 更多...
- en: 'We can also use an else clause on a for statement to determine if the statement
    finished normally or a break statement was executed. We can use something like
    this:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在for语句上使用else子句来确定语句是否正常完成或执行了break语句。我们可以使用类似以下的方法：
- en: '[PRE40]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using an else clause in a for statement is sometimes confusing, and we don’t
    recommend it. It’s not clear if this version is substantially better than any
    of the alternatives. It’s too easy to forget the reason why the else is executed
    because it’s used so rarely.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在for语句中使用else子句有时会令人困惑，我们不推荐这样做。不清楚这个版本是否实质上优于任何其他替代方案。因为它很少使用，所以很容易忘记else执行的原因。
- en: 2.7.5 See also
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7.5 参见
- en: A classic article on this topic is by David Gries, A note on a standard strategy
    for developing loop invariants and loops. See [http://www.sciencedirect.com/science/article/pii/0167642383900151](http://www.sciencedirect.com/science/article/pii/0167642383900151)
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于这个主题的经典文章是David Gries的《关于开发循环不变量和循环的标准策略的笔记》。见[http://www.sciencedirect.com/science/article/pii/0167642383900151](http://www.sciencedirect.com/science/article/pii/0167642383900151)
- en: 2.8 Leveraging exception matching rules
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.8 利用异常匹配规则
- en: 'The try statement lets us capture an exception. When an exception is raised,
    we have a number of choices for handling it:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: try语句让我们能够捕获异常。当引发异常时，我们有许多处理它的选择：
- en: 'Ignore it: If we do nothing, the program stops. We can do this in two ways—don’t
    use a try statement in the first place, or don’t have a matching except clause
    in the try statement.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略它：如果我们什么都不做，程序将停止。我们可以通过两种方式做到这一点——一开始不要使用try语句，或者在try语句中没有匹配的except子句。
- en: 'Log it: We can write a message and use a raise statement to let the exception
    propagate after writing to a log. The expectation is that this will stop the program.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录它：我们可以写一条消息并使用raise语句在写入日志后让异常传播。预期这将停止程序。
- en: 'Recover from it: We can write an except clause to do some recovery action to
    undo any effects of the partially completed try clause.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从中恢复：我们可以编写一个except子句来执行一些恢复操作，以撤销部分完成的try子句的任何影响。
- en: 'Silence it: If we do nothing (that is, use the pass statement), then processing
    is resumed after the try statement. This silences the exception, but does not
    correct the underlying problem, or supply alternative results as a recovery attempt.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使其静默：如果我们什么都不做（即使用pass语句），那么在try语句之后会继续处理。这使异常静默，但不会纠正根本问题，或作为恢复尝试提供替代结果。
- en: 'Rewrite it: We can raise a different exception. The original exception becomes
    a context for the newly raised exception.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新编写它：我们可以引发不同的异常。原始异常成为新引发的异常的上下文。
- en: What about nested contexts? In this case, an exception could be ignored by an
    inner try but handled by an outer context. The basic set of options for each try
    context is the same. The overall behavior of the software depends on the nested
    definitions.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 关于嵌套上下文呢？在这种情况下，一个异常可以被内部 try 语句忽略，但由外部上下文处理。每个 try 上下文的基本选项集是相同的。软件的整体行为取决于嵌套定义。
- en: The design of a try statement depends on the way that Python exceptions form
    a class hierarchy. For details, see the Exception hierarchy section of Python
    Standard Library. For example, the ZeroDivisionError exception is also an ArithmeticError
    and an Exception. For another example, the FileNotFoundError exception is also
    an OSError as well as an Exception.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: try 语句的设计取决于 Python 异常如何形成类层次结构。有关详细信息，请参阅 Python 标准库中的异常层次结构部分。例如，ZeroDivisionError
    异常也是 ArithmeticError 和 Exception。另一个例子，FileNotFoundError 异常也是 OSError 以及 Exception。
- en: This hierarchy can lead to confusion if we’re trying to handle detailed exceptions
    as well as generic exceptions.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们试图同时处理详细异常和通用异常，这种层次结构可能会导致混淆。
- en: 2.8.1 Getting ready
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.8.1 准备工作
- en: Let’s say we’re going to make use of the shutil module to copy a file from one
    place to another. Most of the exceptions that might be raised indicate a problem
    too serious to work around. However, in the specific event of a FileNotFoundError
    exception, we’d like to attempt a recovery action.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将使用 shutil 模块从一个地方复制文件到另一个地方。大多数可能引发的异常表明问题严重到无法解决。然而，在 FileNotFoundError
    异常的具体事件中，我们希望尝试恢复操作。
- en: 'Here’s a rough outline of what we’d like to do:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们想要做的粗略概述：
- en: '[PRE41]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We have two directory paths, source_dir and target_dir. We’ve used the glob()
    method to locate all of the files under source_dir that have *.csv files.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个目录路径，source_dir 和 target_dir。我们使用了 glob() 方法来定位 source_dir 下所有具有 *.csv
    文件的文件。
- en: The expression source_path.relative_to(source_dir) gives us the tail end of
    the filename, the portion after the directory. We use this to build a new, similar
    path under the target_dir directory. This assures that a file named wc1.csv in
    the source_dir directory will have a similar name in the target_dir directory.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 source_path.relative_to(source_dir) 给我们文件名的尾部，即目录之后的部分。我们使用这个来在 target_dir
    目录下构建一个新的、类似的路径。这确保了在 source_dir 目录中的文件名为 wc1.csv，在 target_dir 目录中也将有类似的名称。
- en: 'The problems arise with handling exceptions raised by the shutil.copy() function.
    We need a try statement so that we can recover from certain kinds of errors. We’ll
    see this kind of error if we try to run this:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 shutil.copy() 函数引发的异常时会出现问题。我们需要一个 try 语句，以便从某些类型的错误中恢复。如果我们尝试运行以下内容，我们将看到这种错误：
- en: '[PRE42]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: (We’ve replaced some details with ... because they’ll be different on your computer.)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: （我们用 ... 替换了一些细节，因为它们在您的计算机上会有所不同。）
- en: This exception is raised when the backup directory hasn’t been created. It will
    also happen when there are subdirectories inside the source_dir directory tree
    that don’t also exist in the target_dir tree. How do we create a try statement
    that handles these exceptions and creates the missing directories?
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 当备份目录尚未创建时，会引发此异常。当源目录树中存在而目标目录树中不存在的子目录时，也会发生这种情况。我们如何创建一个 try 语句来处理这些异常并创建缺失的目录？
- en: 2.8.2 How to do it...
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.8.2 如何实现...
- en: 'Write the code we want to use indented in the try block:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们想要使用的代码缩进写入 try 块中：
- en: '[PRE43]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Include the most specific exception classes first in an except clause. In this
    case, we have a meaningful response to the specific FileNotFoundError exception.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 except 子句中首先包含最具体的异常类。在这种情况下，我们对特定的 FileNotFoundError 异常有一个有意义的响应。
- en: 'Include any more general exceptions later. In this case, we’ll report any generic
    OSError exception that’s encountered. This leads to the following:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后面包含任何更通用的异常。在这种情况下，我们将报告遇到的任何通用 OSError 异常。这导致以下结果：
- en: '[PRE44]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We’ve matched exceptions with the most specific first and the more generic after
    that.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先匹配最具体的异常，然后是更通用的异常。
- en: We handled the FileNotFoundError exception by creating the missing directories.
    Then we tried the copy() again, knowing it would now work properly.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建缺失的目录来处理 FileNotFoundError 异常。然后我们再次尝试 copy()，因为我们知道现在它将正常工作。
- en: We logged any other exceptions of the class OSError. For example, if there’s
    a permission problem, that error will be written to a log and the next file will
    be tried. Our objective is to try and copy all of the files. Any files that cause
    problems will be logged, but the overall copying process will continue.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们记录了任何其他属于OSError类的异常。例如，如果存在权限问题，该错误将被写入日志，然后尝试下一个文件。我们的目标是尝试复制所有文件。任何引起问题的文件将被记录，但整体复制过程将继续。
- en: And, yes, the line of code to copy the files is repeated in two distinct contexts.
    The first repetition is when there has been no error. The second is after attempted
    recovery from the initial error. To an extent, this feels like breaking the Don’t
    Repeat Yourself principle. Let’s look at the alternative, which doesn’t seem as
    good.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，是的，复制文件的代码在两个不同的上下文中重复。第一次重复是在没有错误的情况下。第二次是在尝试从初始错误中恢复后。在一定程度上，这感觉像是违反了“不要重复自己”的原则。让我们看看替代方案，它似乎并不那么好。
- en: To meet the DRY standard, we could try to nest this operation in a for statement.
    The break statement is used if things work, otherwise, multiple attempts can be
    made. The extra complication of the for statement seems to be worse than the repetition.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足DRY标准，我们可以尝试在for循环中嵌套这个操作。如果一切顺利，则使用break语句，否则可以尝试多次。for循环的额外复杂性似乎比重复更糟糕。
- en: A common compromise is to write a one-line function that reduces the repetition
    to the name of the function. This has the advantage of making it possible to change
    to another of the shutil copy functions in one place.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的折衷方案是编写一个单行函数，将重复的内容简化为函数名。这样做的好处是可以在一个地方将其更改为shutil.copy函数中的另一个函数。
- en: 2.8.3 How it works...
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.8.3 它是如何工作的...
- en: 'Python’s matching rules for exceptions are intended to be simple:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Python的异常匹配规则旨在简单：
- en: Process except clauses in order.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按顺序处理except子句。
- en: Match the actual exception against the exception class (or tuple of exception
    classes). A match means that the actual exception object (or any of the base classes
    of the exception object) is of the given class in the except clause.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实际异常与异常类（或异常类的元组）进行匹配。匹配意味着实际异常对象（或异常对象的任何基类）在except子句中属于给定的类。
- en: These rules show why we put the most specific exception classes first and the
    more general exception classes last. A generic exception class like Exception
    will match almost every kind of exception. We don’t want this first, because no
    other clauses will be checked.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则说明了为什么我们将最具体的异常类放在最前面，而将更一般的异常类放在最后。像Exception这样的通用异常类几乎可以匹配任何类型的异常。我们不希望它排在第一位，因为其他子句将不会被检查。
- en: There’s an even more generic class, the BaseException class. There’s no good
    reason to ever handle exceptions of this class. If we do, we will be catching
    SystemExit and KeyboardInterrupt exceptions; this interferes with the ability
    to kill a misbehaving application. We only use the BaseException class as a superclass
    when defining new exception classes that exist outside the normal exception hierarchy.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个更通用的类，即BaseException类。没有很好的理由去处理这个类的异常。如果我们这样做，我们将捕获SystemExit和KeyboardInterrupt异常；这会干扰终止不当行为的应用程序的能力。我们只在定义存在于正常异常层次结构之外的新异常类时使用BaseException类作为超类。
- en: 2.8.4 There’s more...
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.8.4 更多内容...
- en: 'Our example includes a nested context in which a second exception can be raised.
    Consider this except clause snippet (taken out of context):'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子包括一个嵌套的上下文，其中可以引发第二个异常。考虑这个except子句片段（从上下文中摘出）：
- en: '[PRE45]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If the mkdir() method or shutil.copy() functions actually raise exceptions while
    handling the original FileNotFoundError exception, it won’t be handled. Any exceptions
    raised within an except clause can crash the program as a whole. Handling these
    nested exceptions can involve nested try statements.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果mkdir()方法或shutil.copy()函数在处理原始FileNotFoundError异常时实际引发异常，则不会被处理。在except子句中引发的任何异常都可能使整个程序崩溃。处理这些嵌套异常可能需要嵌套的try语句。
- en: 'We can rewrite the exception clause to include a nested try during recovery:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重写except子句以包括恢复过程中的嵌套try：
- en: '[PRE46]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this example, a nested context writes one message for an OSError exception.
    In the outer context, a slightly different error message is used to log a similar
    error. In both cases, processing can continue. The distinct error messages can
    make it slightly easier to debug the problems.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，嵌套的上下文为OSError异常写入一条消息。在外部上下文中，使用略微不同的错误消息来记录类似错误。在这两种情况下，处理都可以继续。不同的错误消息可以使调试问题稍微容易一些。
- en: 2.8.5 See also
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.8.5 参考内容
- en: 'In the [Avoiding a potential problem with an except: clause](ch006_split_001.xhtml#x1-1410009)
    recipe, we look at some additional considerations when designing exception handling
    statements.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在[Avoiding a potential problem with an except: clause](ch006_split_001.xhtml#x1-1410009)菜谱中，我们探讨了设计异常处理语句时的一些额外考虑。'
- en: '2.9 Avoiding a potential problem with an except: clause'
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.9 避免使用except:子句可能带来的潜在问题
- en: There are some common mistakes in exception handling. These can cause programs
    to become unresponsive.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在异常处理中存在一些常见的错误。这些错误可能导致程序变得无响应。
- en: 'One of the mistakes we can make is to use the except: clause with no named
    exception class to match. There are a few other mistakes that we can make if we’re
    not cautious about the exceptions we try to handle.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能犯的一个错误是使用没有命名异常类的except:子句进行匹配。如果我们不谨慎地处理异常，我们可能会犯一些其他的错误。
- en: This recipe will show some common exception handling errors that we can avoid.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱将展示一些我们可以避免的常见异常处理错误。
- en: 2.9.1 Getting ready
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.9.1 准备工作
- en: When code can raise a variety of exceptions, it’s sometimes tempting to try
    and match as many as possible. Matching too many exception classes can interfere
    with stopping a misbehaving Python program. We’ll extend the idea of what not
    to do in this recipe.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码可以引发各种异常时，有时会诱使我们尝试匹配尽可能多的异常。匹配过多的异常类可能会干扰停止行为不端的Python程序。我们将在本菜谱中扩展“不要做什么”的概念。
- en: 2.9.2 How to do it...
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.9.2 如何操作...
- en: 'We need to avoid using the bare except: clause. Instead, use except Exception:
    to match the most general kind of exception that an application can reasonably
    handle.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要避免使用裸except:子句。相反，使用except Exception:来匹配一个应用可以合理处理的最为通用的异常类型。
- en: 'Handling too many exception classes can interfere with our ability to stop
    a misbehaving Python program. When we hit Ctrl + C, or send a SIGINT signal via
    the OS’s kill -2 command, we generally want the program to stop. We rarely want
    the program to write a message and keep running. If we use a bare except: clause,
    we can accidentally silence important exceptions.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 处理过多的异常类可能会干扰我们停止行为不端的Python程序的能力。当我们按下Ctrl + C，或者通过操作系统的kill -2命令发送SIGINT信号时，我们通常希望程序停止。我们很少希望程序写一条消息然后继续运行。如果我们使用裸except:子句，我们可能会意外地静音重要的异常。
- en: 'There are a few other classes of exceptions that we should be wary of attempting
    to handle:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该小心避免尝试处理以下几类异常：
- en: SystemError
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SystemError
- en: RuntimeError
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RuntimeError
- en: MemoryError
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MemoryError
- en: Generally, these exceptions mean things are going badly somewhere in Python’s
    internals. Rather than silence these exceptions, or attempt some recovery, we
    should allow the program to fail, find the root cause, and fix it.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些异常意味着Python内部某个地方出了问题。而不是静音这些异常或尝试恢复，我们应该允许程序失败，找到根本原因，并修复它。
- en: 'Further, if we capture any of these exceptions, we can interfere with the way
    these internal exceptions are handled:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们捕获了这些异常，可能会干扰这些内部异常的处理方式：
- en: SystemExit
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SystemExit
- en: KeyboardInterrupt
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KeyboardInterrupt
- en: GeneratorExit
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GeneratorExit
- en: Trying to handle these exceptions can cause a program to become unresponsive
    at exactly the time we need to stop it.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试处理这些异常可能会在我们需要停止程序的时候导致程序变得无响应。
- en: 2.9.3 How it works...
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.9.3 工作原理...
- en: 'There are three techniques we should avoid:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该避免以下三种技术：
- en: 'Don’t match the BaseException class in an except BaseException: clause.'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在except BaseException:子句中匹配BaseException类。
- en: 'Don’t use except: with no exception class. This matches all exceptions, including
    exceptions we should avoid trying to handle.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用没有异常类的except:。这会匹配所有异常，包括我们应避免尝试处理的异常。
- en: Don’t match exceptions from which there’s no sensible recovery.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要匹配那些无法合理恢复的异常。
- en: If we handle too many kinds of exceptions, we may exacerbate a problem, transforming
    it into a larger and more mysterious problem by way of flawed exception handling.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理过多的异常类型，可能会加剧问题，通过错误的异常处理方式将其转化为更大、更神秘的问题。
- en: It’s a noble aspiration to write a program that never crashes. Interfering with
    some of Python’s internal exceptions, however, doesn’t create a more reliable
    program. Instead, it creates a program where a clear failure is masked and made
    into an obscure problem.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个永远不会崩溃的程序是一种崇高的愿望。然而，干扰Python的一些内部异常并不会创建一个更可靠的程序。相反，它创建了一个清晰的失败被掩盖并变成一个难以理解的问题的程序。
- en: 2.9.4 See also
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.9.4 相关内容
- en: In the [Leveraging exception matching rules](ch006_split_001.xhtml#x1-1350008)
    recipe, we look at some considerations when designing exception-handling statements.
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [利用异常匹配规则](ch006_split_001.xhtml#x1-1350008) 菜谱中，我们探讨了设计异常处理语句时的考虑因素。
- en: 2.10 Concealing an exception root cause
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.10 隐藏异常的根本原因
- en: Exceptions contain a root cause. The default behavior of internally raised exceptions
    is to use an implicit __context__ attribute to include the root cause of an exception.
    In some cases, we may want to deemphasize the root cause because it’s misleading
    or unhelpful for debugging.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 异常包含一个根本原因。内部引发的异常的默认行为是使用隐式的 __context__ 属性来包含异常的根本原因。在某些情况下，我们可能想淡化根本原因，因为它可能会误导或对调试无帮助。
- en: This technique is almost always paired with an application or library that defines
    a unique exception. The idea is to show the unique exception without the clutter
    of an irrelevant exception from outside the application or library.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术几乎总是与定义了唯一异常的应用程序或库配对。想法是显示唯一的异常，而不显示来自应用程序或库外部的无关异常的杂乱。
- en: 2.10.1 Getting ready
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.10.1 准备工作
- en: Assume we’re writing some complex string processing. We’d like to treat a number
    of different kinds of detailed exceptions as a single generic error so that users
    of our software are insulated from the implementation details. We can attach details
    to the generic error.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在编写一些复杂的字符串处理。我们希望将多种不同类型的详细异常视为一个通用的错误，以便我们的软件用户免受实现细节的影响。我们可以在通用错误中附加详细信息。
- en: 2.10.2 How to do it...
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.10.2 如何做...
- en: 'To create a new exception, we can do this:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的异常，我们可以这样做：
- en: '[PRE47]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This creates a new, unique class of exception that our library or application
    can use.
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建一个新的、独特的异常类别，我们的库或应用程序可以使用。
- en: 'When handling exceptions, we can conceal the root cause exception like this:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当处理异常时，我们可以像这样隐藏根本原因异常：
- en: '[PRE48]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this example, we raise a new instance of the module’s unique MyAppError exception
    class. The new exception will not have any connection with the root cause AttributeError
    exception.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们引发模块的唯一 MyAppError 异常类的新实例。新的异常将不会与根本原因 AttributeError 异常有任何联系。
- en: 2.10.3 How it works...
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.10.3 它是如何工作的...
- en: The Python exception classes all have a place to record the cause of the exception.
    We can set this __cause__ attribute using the raise Visible from RootCause statement.
    This is done implicitly using the exception context.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: Python 异常类都有一个记录异常原因的地方。我们可以使用 raise Visible from RootCause 语句设置此 __cause__
    属性。这是通过异常上下文隐式完成的。
- en: 'Here’s how it looks when this exception is raised:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个异常被引发时，看起来是这样的：
- en: '[PRE49]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The underlying cause has been concealed. If we omit the from None in the raise
    statement, then the exception will include two parts and will be quite a bit more
    complex. When the root cause is shown, the output looks more like this:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 根本原因已被隐藏。如果我们省略 raise 语句中的 from None，那么异常将包含两部分，并且会复杂得多。当显示根本原因时，输出看起来更像是这样：
- en: '[PRE50]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This shows the underlying AttributeError exception. This may be an implementation
    detail that’s unhelpful and better left off the printed display of the exception.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了底层的 AttributeError 异常。这可能是一个无助于调试的实现细节，最好不将其打印在异常的显示中。
- en: The more useful part of the exception (with some details replaced by ...) follows
    the initial (and possibly irrelevant) root cause information.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 异常更有用的部分（一些细节被省略了...）跟在初始（可能是不相关的）根本原因信息之后。
- en: 2.10.4 There’s more...
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.10.4 更多内容...
- en: There are a number of internal attributes of an exception. These include __cause__,
    __context__, __traceback__, and __suppress_context__. The overall exception context
    is in the __context__ attribute. The cause, if provided via a raise from statement,
    is in __cause__. The context for the exception is available but can be suppressed
    from being printed.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 异常有许多内部属性。这些包括 __cause__、__context__、__traceback__ 和 __suppress_context__。整体的异常上下文在
    __context__ 属性中。如果通过 raise from 语句提供，原因在 __cause__ 中。异常的上下文是可用的，但可以抑制其打印。
- en: 2.10.5 See also
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.10.5 相关阅读
- en: In the [Leveraging exception matching rules](ch006_split_001.xhtml#x1-1350008)
    recipe, we look at some considerations when designing exception-handling statements.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [利用异常匹配规则](ch006_split_001.xhtml#x1-1350008) 菜谱中，我们探讨了设计异常处理语句时的考虑因素。
- en: 'In the [Avoiding a potential problem with an except: clause](ch006_split_001.xhtml#x1-1410009)
    recipe, we look at some additional considerations when designing exception-handling
    statements.'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[避免except子句的潜在问题](ch006_split_001.xhtml#x1-1410009)的菜谱中，我们探讨了设计异常处理语句时的一些额外考虑。
- en: 2.11 Managing a context using the with statement
  id: totrans-516
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.11 使用with语句管理上下文
- en: There are many instances where our scripts will be entangled with external resources.
    The most common examples are disk files and network connections to external hosts.
    A common bug is retaining these entanglements forever, tying up these resources
    uselessly. These are sometimes called a memory leak because the available memory
    is reduced each time a new file is opened without closing a previously used file.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们的脚本将与外部资源纠缠在一起。最常见的情况是磁盘文件和连接到外部主机的网络连接。一个常见的错误是永远保留这些纠缠，无用地占用这些资源。这些有时被称为内存泄漏，因为每次打开一个新文件而不关闭之前使用的文件时，可用的内存都会减少。
- en: We’d like to isolate each entanglement so that we can be sure that the resource
    is acquired and released properly. The idea is to create a context in which our
    script uses an external resource. At the end of the context, our program is no
    longer bound to the resource and we want to be guaranteed that the resource is
    released.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望隔离每个纠缠，以确保资源被正确获取和释放。想法是在我们的脚本使用外部资源的环境中创建一个上下文。在上下文结束时，我们的程序不再绑定到资源，我们希望得到保证，资源将被释放。
- en: 2.11.1 Getting ready
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.11.1 准备工作
- en: Let’s say we want to write lines of data to a file in CSV format. When we’re
    done, we want to be sure that the file is closed and the various OS resources—including
    buffers and file handles—are released. We can do this in a context manager, which
    guarantees that the file will be properly closed.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将数据行写入CSV格式的文件。完成之后，我们想要确保文件已关闭，并且释放了各种操作系统资源——包括缓冲区和文件句柄。我们可以在上下文管理器中这样做，这保证了文件将被正确关闭。
- en: 'Since we’ll be working with CSV files, we can use the csv module to handle
    the details of the formatting:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将处理CSV文件，我们可以使用csv模块来处理格式化的细节：
- en: '[PRE51]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We’ll also use the pathlib module to locate the files we’ll be working with:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用pathlib模块来定位我们将要处理文件：
- en: '[PRE52]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For the purposes of having something to write, we’ll use this silly data source:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有东西可以写入，我们将使用这个愚蠢的数据源：
- en: '[PRE53]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We’ll also need a working directory. In the examples, we’re using data under
    the current working directory. We can create this directory using a terminal window
    command, or we can create it from within Python:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个工作目录。在示例中，我们使用当前工作目录下的数据。我们可以使用终端窗口命令创建此目录，或者我们可以从Python内部创建它：
- en: '[PRE54]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This will give us a context in which to learn about the with statement.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个了解with语句的上下文。
- en: 2.11.2 How to do it...
  id: totrans-530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.11.2 如何做...
- en: 'Create the context by opening the Path, or creating the network connection
    with urllib.request.urlopen(). Other common contexts include creating archives
    like zip files and tar files. Here’s the essential context creation for an open
    file:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过打开Path或使用urllib.request.urlopen()创建网络连接来创建上下文。其他常见的上下文包括创建归档，如zip文件和tar文件。以下是打开文件的必要上下文创建：
- en: '[PRE55]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Include all the processing, indented within the with statement:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含所有在with语句内缩进的加工：
- en: '[PRE56]'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When we use a file as a context manager, the file is automatically closed at
    the end of the indented context block. Even if an exception is raised, the file
    is still closed properly. Outdent the processing that is done after the context
    is finished and the resources are released:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们将文件用作上下文管理器时，文件将在缩进的上下文块结束时自动关闭。即使引发异常，文件也会被正确关闭。在上下文完成后和资源释放后，缩进完成后的处理：
- en: '[PRE57]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The statements outside the with context will be executed after the context is
    closed. The named resource — the file opened by target_path.open() — will be properly
    closed.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: with上下文之外的语句将在上下文关闭后执行。命名资源——由target_path.open()打开的文件——将被正确关闭。
- en: (We assign the result of the writerow() method of a writer to the _ variable.
    This is a trick required to avoid showing this result. It’s the number 21, telling
    us how many characters were written.)
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: （我们将writerow()方法的结果赋值给变量_。这是一个避免显示此结果的技巧。它是数字21，告诉我们写了多少个字符。）
- en: Even if an exception is raised inside the with context, the file is still properly
    closed. The context manager is notified of the exception. It can close the file
    and allow the exception to propagate.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在with上下文中抛出异常，文件仍然会被正确关闭。上下文管理器会通知异常。它可以关闭文件并允许异常传播。
- en: 2.11.3 How it works...
  id: totrans-540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.11.3 它是如何工作的...
- en: 'A context manager is notified of three significant events surrounding the indented
    block of code:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器会通知围绕缩进代码块的三项重要事件：
- en: Entry to the context
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入上下文
- en: Normal exit from the context with no exception
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有异常的正常退出上下文
- en: Exit from the context because of an exception
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于异常而退出上下文
- en: The context manager will—under all conditions—disentangle our program from external
    resources. Files can be closed. Network connections can be dropped. Database transactions
    can be committed or rolled back. Locks can be released.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器将在所有情况下将我们的程序从外部资源中解耦。文件可以被关闭。网络连接可以被断开。数据库事务可以被提交或回滚。锁可以被释放。
- en: 'We can experiment with this by including a manual exception inside the with
    statement. This can show that the file was properly closed:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在with语句中包含一个手动异常来实验这个。这可以显示文件被正确关闭：
- en: '[PRE58]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this example, we’ve wrapped the real work in a try statement. This allows
    us to raise an exception after writing the first line of data to the CSV file.
    Because the exception handling is outside the with context, the file is closed
    properly. All resources are released and the part that was written is properly
    accessible and usable by other programs.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将实际工作封装在try语句中。这允许我们在将第一行数据写入CSV文件后抛出异常。因为异常处理在with上下文之外，所以文件被正确关闭。所有资源都得到释放，所写入的部分可以由其他程序正确访问和使用。
- en: 'The output confirms the expected file state:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 输出确认了预期的文件状态：
- en: '[PRE59]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This shows us that the file was properly closed. It also shows us the message
    associated with the exception to confirm that it was the exception we raised manually.
    This kind of technique allows us to work with expensive resources like database
    connections and network connections and be sure these don’t ”leak.”
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明文件被正确关闭。它还显示了与异常相关的消息，以确认这是我们手动抛出的异常。这种技术允许我们与像数据库连接和网络连接这样的昂贵资源一起工作，并确保这些资源不会“泄漏”。
- en: Resource leak is a common description used when resources are not released properly
    back to the OS. It’s as if a pool is slowly drained away, and the application
    stops working because there are no more available OS network sockets or file handles.
    The with statement can be used to properly disentangle our Python application
    from OS resources.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 资源泄漏是在资源没有正确释放回操作系统时常用的一个描述。这就像一个池子慢慢被排空，应用程序停止工作，因为没有更多的可用操作系统网络套接字或文件句柄。with语句可以用来正确地将我们的Python应用程序与操作系统资源解耦。
- en: 2.11.4 There’s more...
  id: totrans-553
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.11.4 更多内容...
- en: Python offers us a number of context managers. We noted that an open file is
    a context, as is an open network connection created by urllib.request.urlopen().
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了一系列上下文管理器。我们注意到一个打开的文件是一个上下文，就像由`urllib.request.urlopen()`创建的打开网络连接一样。
- en: For all file operations, and all network connections, we should always use a
    with statement as a context manager. It’s very difficult to find an exception
    to this rule.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有文件操作和所有网络连接，我们应该始终使用with语句作为上下文管理器。很难找到这个规则的例外。
- en: It turns out that the decimal module makes use of a context manager to allow
    localized changes to the way decimal arithmetic is performed. We can use the decimal.localcontext()
    function as a context manager to change rounding rules or precision for calculations
    isolated by a with statement.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，十进制模块使用上下文管理器来允许对十进制算术执行方式的本地化更改。我们可以使用`decimal.localcontext()`函数作为上下文管理器来更改计算中隔离的舍入规则或精度。
- en: We can define our own context managers, also. The contextlib module contains
    functions and decorators that can help us create context managers around resources
    that don’t explicitly offer them.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以定义自己的上下文管理器。`contextlib`模块包含函数和装饰器，可以帮助我们在不明确提供它们的情况下创建资源周围的上下文管理器。
- en: When working with locks, the with statement context manager is the ideal way
    to acquire and release a lock. See [https://docs.python.org/3/library/threading.html#with-locks](https://docs.python.org/3/library/threading.html#with-locks)
    for the relationship between a lock object created by the threading module and
    a context manager.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用锁时，with 语句上下文管理器是获取和释放锁的理想方式。查看 [https://docs.python.org/3/library/threading.html#with-locks](https://docs.python.org/3/library/threading.html#with-locks)
    了解由 threading 模块创建的锁对象与上下文管理器之间的关系。
- en: 2.11.5 See also
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.11.5 参考信息
- en: See [PEP-343](https://www.python.org/dev/peps/pep-0343/) for the origins of
    the with statement.
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看 [PEP-343](https://www.python.org/dev/peps/pep-0343/) 了解 with 语句的起源。
- en: Numerous recipes in Chapter [9](ch013_split_000.xhtml#x1-5020009), will make
    use of this technique. The recipes [Reading delimited files with the CSV module](ch015_split_000.xhtml#x1-6320003),
    [Reading complex formats using regular expressions](ch015_split_001.xhtml#x1-6440005),
    and [Reading HTML documents](ch015_split_001.xhtml#x1-6660008), among others,
    will make use of the with statement.
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 [9](ch013_split_000.xhtml#x1-5020009) 章中的许多食谱将使用这项技术。包括 [使用 CSV 模块读取定界文件](ch015_split_000.xhtml#x1-6320003)、[使用正则表达式读取复杂格式](ch015_split_001.xhtml#x1-6440005)
    和 [读取 HTML 文档](ch015_split_001.xhtml#x1-6660008) 等食谱都将使用 with 语句。
- en: Join our community Discord space
  id: totrans-562
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-564
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
