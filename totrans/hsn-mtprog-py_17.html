<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer142">
<h1 id="_idParaDest-171"><em class="italic"><a id="_idTextAnchor173"/>Chapter 14</em>: Generating Code from AST</h1>
<p>In this chapter, we <a id="_idIndexMarker673"/>will learn how to use ASTs in Python to generate code for various applications. We will apply these abstract syntax trees to metaprogramming to implement automatic code generated in this chapter. </p>
<p>Automatic code generation is one way of making the life of a programmer easier. An abstract syntax tree is an excellent functionality that can help us generate code in a much simpler way.</p>
<p>The concept of AST is discussed with examples in <a href="B13426_09_Final_PG_epub.xhtml#_idTextAnchor124"><em class="italic">Chapter 9</em></a> of this book. In this chapter, we will be tapping the advantages of ASTs to generate code automatically. Code generation can be implemented to enable no-code or limited coding while developing applications. In this chapter, we will continue to use the example of <em class="italic">ABC Megamart</em> to generate code from ASTs. </p>
<p>In this chapter, we will be looking at the following main topics:</p>
<ul>
<li>Generating a simple class with a template</li>
<li>Generating multiple classes from a list</li>
<li>Generating a class with attributes</li>
<li>Generating a class with methods</li>
<li>Defining a custom class factory</li>
<li>Developing a code generator to generate a simple library</li>
</ul>
<p>By the end of this chapter, you should be able to understand how to use the existing methods of the <strong class="source-inline">ast</strong> library in Python to enable your application to generate its own code, how to avoid repeating yourself, and how to generate code dynamically.</p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor174"/>Technical requirements</h1>
<p>The code examples shared in this chapter are available on GitHub under the code for this chapter here: <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter14">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter14</a>.</p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor175"/>Generating a simple class with a template</h1>
<p>In this section, we<a id="_idIndexMarker674"/> will be looking at how to generate code for a class without actually defining the class itself. We will be creating a string-based template with the structure of a class we want to develop but not the actual code that can be executed. To explain this further, let us look at an example where we will generate a class named <strong class="source-inline">VegCounter</strong> by parsing a series of strings using the <strong class="source-inline">ast</strong> module.</p>
<p>The sequence of steps to be followed to generate code for a class is represented in the following flow diagram: </p>
<div>
<div class="IMG---Figure" id="_idContainer134">
<img alt="Figure 14.1 – A code generation sequence for a simple class " height="776" src="image/Figure_14.1_B13426.jpg" width="1335"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – A code generation sequence for a simple class</p>
<p>Let us look at the implementation of this example: </p>
<ol>
<li>We <a id="_idIndexMarker675"/>will start by importing the <strong class="source-inline">ast</strong> library:<p class="source-code">import ast</p></li>
<li>Let us now create a variable to pass the class name with which the code needs to be generated:<p class="source-code">classname = "VegCounter"</p></li>
<li>We will next define a variable that becomes the template for the class generated in this example:<p class="source-code">classtemplate = """class """ +classname+ """():pass"""</p></li>
<li>In the next step, we will parse the class template with the parse method in the <strong class="source-inline">ast</strong> module:<p class="source-code">print(ast.dump(class_tree, indent = 4))</p></li>
<li>The output of the preceding code displays the abstract syntax tree of the class template:<p class="source-code"><strong class="bold">Module(</strong></p><p class="source-code"><strong class="bold">    body=[</strong></p><p class="source-code"><strong class="bold">        ClassDef(</strong></p><p class="source-code"><strong class="bold">            name='VegCounter',</strong></p><p class="source-code"><strong class="bold">            bases=[],</strong></p><p class="source-code"><strong class="bold">            keywords=[],</strong></p><p class="source-code"><strong class="bold">            body=[</strong></p><p class="source-code"><strong class="bold">                Pass()],</strong></p><p class="source-code"><strong class="bold">            decorator_list=[])],</strong></p><p class="source-code"><strong class="bold">    type_ignores=[])</strong></p></li>
<li>The preceding tree can be compiled and executed as follows:<p class="source-code">actualclass = compile(class_tree, 'vegctr_tree', 'exec')</p><p class="source-code">actualclass</p></li>
</ol>
<p>Thus, this leads to the following output:</p>
<p class="source-code"><strong class="bold">&lt;code object &lt;module&gt; at 0x0000028AAB0D2A80, file "vegctr_tree", line 1&gt;</strong></p>
<ol>
<li value="7">In the <a id="_idIndexMarker676"/>next step, we will unparse the tree to generate the actual code for the class:<p class="source-code">VegCounter.</p><p class="source-code">print(ast.unparse(class_tree))</p></li>
</ol>
<p>Executing the preceding code leads to the following output:</p>
<p class="source-code"><strong class="bold">class VegCounter:</strong></p>
<p class="source-code"><strong class="bold">    pass</strong></p>
<ol>
<li value="8">In the next step, let us write the preceding class code to a file named <strong class="source-inline">classtemplate.py</strong>:<p class="source-code">code = open("classtemplate.py", "w")</p><p class="source-code">script = code.write(ast.unparse(class_tree))</p><p class="source-code">code.close()</p></li>
<li>The <strong class="source-inline">classtemplate</strong> file looks as follows:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer135">
<img alt="Figure 14.2 – The classtemplate.py file " height="40" src="image/Figure_14.2_B13426.jpg" width="165"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – The classtemplate.py file</p>
<ol>
<li value="10">Let us now import the <strong class="source-inline">classtemplate</strong> and create an object:<p class="source-code">import classtemplate as c</p><p class="source-code">vegc = c.VegCounter()</p><p class="source-code">vegc</p></li>
</ol>
<p>The output is as follows:</p>
<p class="source-code"><strong class="bold">&lt;classtemplate.VegCounter at 0x28aab1d6a30&gt;</strong></p>
<p>In this <a id="_idIndexMarker677"/>section, we have generated a simple class code using the <strong class="source-inline">ast</strong> module. This example helps us in understanding the steps to be followed to generate code for a custom class since it is easier to start understanding code generation by starting simple. With this understanding, let us generate code for multiple classes.</p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor176"/>Generating multiple classes from a list</h1>
<p>In this section, we <a id="_idIndexMarker678"/>will look at generating code for multiple classes dynamically using the <strong class="source-inline">ast</strong> module and its <strong class="source-inline">unparse</strong> method. </p>
<p>Generating the code for more than one class dynamically gives us a direction for implementing code generation for multiple functionalities of an application. The classes need not be for the same functionality and the class code thus generated can later be modified to include additional methods or attributes as required by the application. The skeletal class code will be generated through this example.</p>
<p>To understand this further, we will follow the sequence described in the following flow diagram.</p>
<div>
<div class="IMG---Figure" id="_idContainer136">
<img alt="Figure 14.3 – A code generation sequence for multiple classes " height="778" src="image/Figure_14.3_B13426.jpg" width="1336"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – A code generation sequence for multiple classes</p>
<p>Let us now<a id="_idIndexMarker679"/> look at how to implement this scenario: </p>
<ol>
<li value="1">We will first define a variable that can be assigned a list of class names as values:<p class="source-code">classnames = ["VegCounter", "ElectronicsCounter", "PasadenaBranch", "VegasBranch"]</p></li>
<li>In the next step, let us look at generating class templates for each of the class names from the preceding list:<p class="source-code">classgenerator = []</p><p class="source-code">for classname in classnames:</p><p class="source-code">    classcode = """class """ +classname+ """():pass"""</p><p class="source-code">    classgenerator.append(classcode)</p><p class="source-code">classgenerator</p></li>
</ol>
<p>The class templates are added to another list named <strong class="source-inline">classgenerator</strong>, and the list is as follows:</p>
<p class="source-code">['class VegCounter():pass',</p>
<p class="source-code"> 'class ElectronicsCounter():pass',</p>
<p class="source-code"> 'class PasadenaBranch():pass',</p>
<p class="source-code"> 'class VegasBranch():pass']</p>
<ol>
<li value="3">To parse <a id="_idIndexMarker680"/>the string templates from the preceding output and generate their abstract syntax trees, let us create another list named <strong class="source-inline">classtrees</strong> and store the trees:<p class="source-code">classtrees = []</p><p class="source-code">for i in classgenerator:</p><p class="source-code">    classtree = ast.parse(i)</p><p class="source-code">    classtrees.append(classtree)</p><p class="source-code">classtrees</p></li>
</ol>
<p>The parsed class trees that are assigned to the <strong class="source-inline">classtrees</strong> list variable are displayed as follows:</p>
<p class="source-code">[&lt;ast.Module at 0x1efa91fde20&gt;,</p>
<p class="source-code"> &lt;ast.Module at 0x1efa91e6d30&gt;,</p>
<p class="source-code"> &lt;ast.Module at 0x1efa91e6220&gt;,</p>
<p class="source-code"> &lt;ast.Module at 0x1efa91e6370&gt;]</p>
<ol>
<li value="4">In this step, we will review one of the trees to ensure that the abstract syntax tree is generated for the class as expected:<p class="source-code">print(ast.dump(classtrees[0], indent = 4))</p></li>
</ol>
<p>The output is generated as follows:</p>
<p class="source-code"><strong class="bold">Module(</strong></p>
<p class="source-code"><strong class="bold">    body=[</strong></p>
<p class="source-code"><strong class="bold">        ClassDef(</strong></p>
<p class="source-code"><strong class="bold">            name='VegCounter',</strong></p>
<p class="source-code"><strong class="bold">            bases=[],</strong></p>
<p class="source-code"><strong class="bold">            keywords=[],</strong></p>
<p class="source-code"><strong class="bold">            body=[</strong></p>
<p class="source-code"><strong class="bold">                Pass()],</strong></p>
<p class="source-code"><strong class="bold">            decorator_list=[])],</strong></p>
<p class="source-code"><strong class="bold">    type_ignores=[])</strong></p>
<ol>
<li value="5">We can<a id="_idIndexMarker681"/> further unparse the <strong class="source-inline">classtrees</strong> variable to generate the code for each class:<p class="source-code">print(ast.unparse(classtrees[1]))</p></li>
</ol>
<p>An example output looks as follows:</p>
<p class="source-code"><strong class="bold">class ElectronicsCounter:</strong></p>
<p class="source-code"><strong class="bold">    pass</strong></p>
<ol>
<li value="6">Let us further write all the generated classes into a file:<p class="source-code">code = open("classtemplates.py", "w")</p><p class="source-code">for i in classtrees:</p><p class="source-code">    code.write(ast.unparse(i))</p><p class="source-code">    code.write("\n")</p><p class="source-code">    code.write("\n")</p><p class="source-code">code.close()</p></li>
</ol>
<p>The generated <strong class="source-inline">classtemplates.py</strong> file looks as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer137">
<img alt="Figure 14.4 – The classtemplates.py file " height="240" src="image/Figure_14.4_B13426.jpg" width="285"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – The classtemplates.py file</p>
<ol>
<li value="7">Let us <a id="_idIndexMarker682"/>import the file and call an instance of each class to check if it works:<p class="source-code">import classtemplates as ct</p><p class="source-code">print(ct.ElectronicsCounter())</p><p class="source-code">print(ct.PasadenaBranch())</p><p class="source-code">print(ct.VegasBranch())</p><p class="source-code">print(ct.VegCounter())</p></li>
</ol>
<p>The output of the preceding code is as follows:</p>
<p class="source-code"><strong class="bold">&lt;classtemplates.ElectronicsCounter object at 0x00000255C0760FA0&gt;</strong></p>
<p class="source-code"><strong class="bold">&lt;classtemplates.PasadenaBranch object at 0x00000255C0760F10&gt;</strong></p>
<p class="source-code"><strong class="bold">&lt;classtemplates.VegasBranch object at 0x00000255C0760FA0&gt;</strong></p>
<p class="source-code"><strong class="bold">&lt;classtemplates.VegCounter object at 0x00000255C0760F10&gt;</strong></p>
<p>In this section, we <a id="_idIndexMarker683"/>have generated code for multiple classes using the <strong class="source-inline">ast</strong> module. This example is the next step toward working on automatic code generation for multiple functionalities or modules of an application.</p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor177"/>Generating a class with attributes</h1>
<p>In this <a id="_idIndexMarker684"/>section, we will generate code for a class, along with a list of attributes, that will also be included dynamically in the class. Generating code for a class alone can give the initial skeletal structure for a module, whereas we need to add attributes if we want to make the class more specific. The following flow diagram represents the sequence of steps to be followed for this example:</p>
<div>
<div class="IMG---Figure" id="_idContainer138">
<img alt="Figure 14.5 – A code generation sequence for a class with multiple attributes " height="891" src="image/Figure_14.5_B13426.jpg" width="1168"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 – A code generation sequence for a class with multiple attributes</p>
<p>Let us look<a id="_idIndexMarker685"/> at the code for this example:</p>
<ol>
<li value="1">We will first define a variable to provide <strong class="source-inline">classname</strong> as input, followed by a <strong class="source-inline">classtemplate</strong> to create the template of the class declaration:<p class="source-code">classname = "VegCounter"</p><p class="source-code">classtemplate =  '''class ''' +classname+ ''':'''+'\n    '</p></li>
<li>In the next step, let us define another variable to provide attribute names as input:<p class="source-code">attributename = ['items', 'countername', 'billamount']</p></li>
<li>Let us further update <strong class="source-inline">classtemplate</strong> by providing each of the preceding attributes that are required to generate the class code:<p class="source-code">for attr in attributename:</p><p class="source-code">    classtemplate = classtemplate + attr +''' = </p><p class="source-code">        None''' + '\n    '</p></li>
<li>Let us now parse the <strong class="source-inline">classtemplate</strong> and review the abstract syntax tree:<p class="source-code">class_tree = ast.parse(classtemplate)</p><p class="source-code">print(ast.dump(class_tree, indent = 4))</p></li>
<li>The syntax tree for the preceding class template looks as follows:<p class="source-code">Module(</p><p class="source-code">    body=[</p><p class="source-code">        ClassDef(</p><p class="source-code">            name='VegCounter',</p><p class="source-code">            bases=[],</p><p class="source-code">            keywords=[],</p><p class="source-code">            body=[</p><p class="source-code">                Assign(</p><p class="source-code">                    targets=[</p><p class="source-code">                        Name(id='items', </p><p class="source-code">                    ctx=Store())],</p><p class="source-code">                    value=Constant(value=None)),</p><p class="source-code">                Assign(</p><p class="source-code">                    targets=[</p><p class="source-code">                        Name(id='countername', </p><p class="source-code">                        ctx=Store())],</p><p class="source-code">                    value=Constant(value=None)),</p><p class="source-code">                Assign(</p><p class="source-code">                    targets=[</p><p class="source-code">                        Name(id='billamount', </p><p class="source-code">                        ctx=Store())],</p><p class="source-code">                    value=Constant(value=None))],</p><p class="source-code">            decorator_list=[])],</p><p class="source-code">    type_ignores=[])</p></li>
</ol>
<p>All three <a id="_idIndexMarker686"/>variables – <strong class="source-inline">items</strong>, <strong class="source-inline">countername</strong>, and <strong class="source-inline">billamount</strong> added into the class template – are now part of the syntax tree. If we review the tree in detail, we can look at these variables under <strong class="source-inline">body</strong> | <strong class="source-inline">assign</strong> | <strong class="source-inline">targets</strong> | <strong class="source-inline">name</strong> | <strong class="source-inline">id</strong>.</p>
<ol>
<li value="6">We can further unparse the tree and look at the code of the class:<p class="source-code">print(ast.unparse(class_tree))</p></li>
</ol>
<p>The output looks as follows:</p>
<p class="source-code"><strong class="bold">class VegCounter:</strong></p>
<p class="source-code"><strong class="bold">    items = None</strong></p>
<p class="source-code"><strong class="bold">    countername = None</strong></p>
<p class="source-code"><strong class="bold">    billamount = None</strong></p>
<p>Let us write the code to a file and import it:</p>
<p class="source-code">code = open("classtemplateattr.py", "w")</p>
<p class="source-code">script = code.write(ast.unparse(class_tree))</p>
<p class="source-code">code.close()</p>
<p>The<a id="_idIndexMarker687"/> generated code looks as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer139">
<img alt="Figure 14.6 –The classtemplateattr.py file " height="74" src="image/Figure_14.6_B13426.jpg" width="197"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6 –The classtemplateattr.py file</p>
<p>We can import the <strong class="source-inline">classtemplateattr.py</strong> file and the class can be accessed as follows:</p>
<p class="source-code">import classtemplateattr as c</p>
<p class="source-code">c.VegCounter()</p>
<p class="source-code">vegc = c.VegCounter()</p>
<p class="source-code">vegc.items = ['onions','tomatoes','carrots','lettuce']</p>
<p class="source-code">vegc.countername = 'Veg Counter'</p>
<p class="source-code">vegc.billamount = 200</p>
<p>The output is displayed as follows, with all the attributes and their corresponding values assigned:</p>
<p class="source-code"><strong class="bold">['onions', 'tomatoes', 'carrots', 'lettuce']</strong></p>
<p class="source-code"><strong class="bold">Veg Counter</strong></p>
<p class="source-code"><strong class="bold">200</strong></p>
<p>In this section, we <a id="_idIndexMarker688"/>have generated a class with multiple attributes without writing the code for the class. Instead, we have defined a template that takes in a class name and a list of attributes as input. With this understanding, we can look at generating a class with methods.</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor178"/>Generating a class with methods</h1>
<p>In this section, let <a id="_idIndexMarker689"/>us generate code for a class and its methods. Throughout this chapter, our goal is to generate code dynamically for building applications that can solve a specific purpose. Adding methods along with attributes makes the code generation for a class even more application-specific. We can look at two variations of this example:</p>
<ul>
<li>Generating a class with an <strong class="source-inline">init</strong> method</li>
<li>Generating a class with a user-defined method </li>
</ul>
<p>Let’s discuss each in detail.</p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor179"/>Generating a class with an init method</h2>
<p>In this<a id="_idIndexMarker690"/> example, let us generate code for a class and add an <strong class="source-inline">init</strong> method to the class and also initialize attributes. In this example, we will define a <a id="_idIndexMarker691"/>class for the vegetable counter of <em class="italic">ABC Megamart</em>. In the <strong class="source-inline">init</strong> method, let us initialize cart items from the vegetable counter of <em class="italic">ABC Megamart</em> in this class:</p>
<pre class="source-code">classname = "VegCounter"</pre>
<pre class="source-code">classtemplate =  '''class ''' +classname+ ''':'''+'\n' +''' def __init__(self,*items):</pre>
<pre class="source-code">        cartItems = []</pre>
<pre class="source-code">        for i in items:</pre>
<pre class="source-code">            cartItems.append(i)</pre>
<pre class="source-code">        self.items = cartItems'''</pre>
<pre class="source-code">class_tree = ast.parse(classtemplate)</pre>
<pre class="source-code">print(ast.unparse(class_tree))</pre>
<p>The <a id="_idIndexMarker692"/>parsed class template generates the following code:</p>
<pre class="source-code">class VegCounter:</pre>
<pre class="source-code">    def __init__(self, *items):</pre>
<pre class="source-code">        cartItems = []</pre>
<pre class="source-code">        for i in items:</pre>
<pre class="source-code">            cartItems.append(i)</pre>
<pre class="source-code">        self.items = cartItems</pre>
<p>The abstract <a id="_idIndexMarker693"/>syntax tree for this class is generated with the function definition, as represented in the following figure:</p>
<div>
<div class="IMG---Figure" id="_idContainer140">
<img alt="Figure 14.7 – The function definition of the init method " height="234" src="image/Figure_14.7_B13426.jpg" width="353"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.7 – The function definition of the init method</p>
<p>With this understanding, let us look at one more example of this same class by generating code for a user-defined method.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor180"/>Generating a class with a user-defined method</h2>
<p>In this <a id="_idIndexMarker694"/>section, let us look at a variation of the <a id="_idIndexMarker695"/>class by creating a template that generates a user-defined method for the class:</p>
<pre class="source-code">classname = "VegCounter"</pre>
<pre class="source-code">methodname = "returnCart"</pre>
<pre class="source-code">classtemplate =  '''class ''' +classname+ ''':'''+'\n' +''' def '''+methodname+'''(self,*items):</pre>
<pre class="source-code">        cartItems = []</pre>
<pre class="source-code">        for i in items:</pre>
<pre class="source-code">            cartItems.append(i)</pre>
<pre class="source-code">        return cartItems'''</pre>
<pre class="source-code">class_tree = ast.parse(classtemplate)</pre>
<pre class="source-code">print(ast.unparse(class_tree))</pre>
<p>The parsed <strong class="source-inline">classtemplate</strong> generates the following code:</p>
<pre class="source-code">class VegCounter:</pre>
<pre class="source-code">    def returnCart(self, *items):</pre>
<pre class="source-code">        cartItems = []</pre>
<pre class="source-code">        for i in items:</pre>
<pre class="source-code">            cartItems.append(i)</pre>
<pre class="source-code">        return cartItems</pre>
<p>The abstract syntax tree for this class is generated with the function definition, as represented in the following figure:</p>
<div>
<div class="IMG---Figure" id="_idContainer141">
<img alt="Figure 14.8 – The function definition of the user-defined method " height="234" src="image/Figure_14.8_B13426.jpg" width="351"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.8 – The function definition of the user-defined method</p>
<p>We can<a id="_idIndexMarker696"/> either use the <strong class="source-inline">init</strong> method when we <a id="_idIndexMarker697"/>want to initialize the cart items at the class level or use the attributes later. By contrast, the user-defined method can be used if we want to keep the attributes specific to the method and perform actions based on the attributes within the method. </p>
<p>With this understanding, let us look at defining a custom class factory. </p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor181"/>Defining a custom class factory</h1>
<p>In this<a id="_idIndexMarker698"/> section, let us define a function named <strong class="source-inline">classgenerator</strong> that generates a custom class, attribute, and method using a class template as follows:</p>
<pre class="source-code">def classgenerator(classname, attribute, method):</pre>
<pre class="source-code">    classtemplate = '''class ''' +classname+ </pre>
<pre class="source-code">          ''':'''+'\n    ' +attribute+''' = </pre>
<pre class="source-code">          None\n    def '''+method+'''(self,item,status):</pre>
<pre class="source-code">        if (status == 'Y'):</pre>
<pre class="source-code">            print('Test passed for', item)</pre>
<pre class="source-code">        else:</pre>
<pre class="source-code">            print('Get another', item)</pre>
<pre class="source-code">        '''</pre>
<pre class="source-code">    return classtemplate</pre>
<p>In this section, we <a id="_idIndexMarker699"/>are making the code generation more dynamic by creating a function that can generate code with custom values for the class name, attribute name, and method name, respectively. This helps in creating custom code for multiple functionalities in an application.</p>
<p>Let us provide a custom class name, attribute name, and method name as input to the preceding function:</p>
<pre class="source-code">class_tree = ast.parse(classgenerator('ElectronicCounter', 'TestItem', 'verifyCart')</pre>
<pre class="source-code">actualclass = compile(class_tree, 'elec_tree', 'exec')</pre>
<pre class="source-code">print(ast.unparse(class_tree))</pre>
<p>The generated class code is as follows:</p>
<pre class="source-code"><strong class="bold">class ElectronicCounter:</strong></pre>
<pre class="source-code"><strong class="bold">    TestItem = None</strong></pre>
<pre class="source-code"><strong class="bold">    def verifyCart(self, item, status):</strong></pre>
<pre class="source-code"><strong class="bold">        if status == 'Y':</strong></pre>
<pre class="source-code"><strong class="bold">            print('Test passed for', item)</strong></pre>
<pre class="source-code"><strong class="bold">        else:</strong></pre>
<pre class="source-code"><strong class="bold">            print('Get another', item)</strong></pre>
<p>We can expand this example further by developing a code generator library in the following section.</p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor182"/>Developing a code generator to generate a simple library</h1>
<p>In this section, let us develop a <a id="_idIndexMarker700"/>simple code generator that generates code for a class with <strong class="source-inline">get</strong>, <strong class="source-inline">set</strong>, and <strong class="source-inline">delete</strong> properties for its custom attributes. The purpose of this section is to generate a complete library through automatic code generation. To fulfill this, let us write the following code:</p>
<ol>
<li value="1">Let us define the code generator as follows:<p class="source-code">class CodeGenerator:</p><p class="source-code">    def __init__(self, classname, attribute):</p><p class="source-code">        self.classname = classname</p><p class="source-code">        self.attribute = attribute </p></li>
<li>Let us further define the method to define the class template in the code generator as follows:<p class="source-code">def generatecode(self):</p><p class="source-code">        classtemplate = '''class ''' +self.classname+ ''':'''+'''\n    def __init__(self):''' + '\n    '+'''    self._'''+self.attribute+''' = None\n\n    @property</p><p class="source-code">    def test'''+self.attribute+'''(self):\n        return self.test'''+self.attribute+'''\n\n    @test'''+self.attribute+'''.getter</p><p class="source-code">    def test'''+self.attribute+'''(self):\n        print("get test'''+self.attribute+'''")\n        return self._test'''+self.attribute+'''</p><p class="source-code">    @test'''+self.attribute+'''.setter</p><p class="source-code">    def test'''+self.attribute+'''(self, value):</p><p class="source-code">        print("set test'''+self.attribute+'''")</p><p class="source-code">        self._test'''+self.attribute+''' = value</p><p class="source-code">    @test'''+self.attribute+'''.deleter</p><p class="source-code">    def test'''+self.attribute+'''(self):</p><p class="source-code">        print("del test'''+self.attribute+'''")</p><p class="source-code">        del self._test'''+self.attribute+'''</p><p class="source-code">        '''</p><p class="source-code">        class_tree = ast.parse(classtemplate)</p><p class="source-code">        print(ast.unparse(class_tree))</p><p class="source-code">        print('\n')</p></li>
<li>We will<a id="_idIndexMarker701"/> now save the preceding code into a file named <strong class="source-inline">codegenerator.py</strong> and import the file as a library:<p class="source-code">from codegenerator import CodeGenerator as c</p></li>
<li>Let us define a dictionary object and assign multiple class names and their corresponding attribute names as input:<p class="source-code">classes = {'VegCounter' : 'items',</p><p class="source-code">           'ElectronicCounter' : 'goods',</p><p class="source-code">           'BranchManhattan' : 'Sales',</p><p class="source-code">           'BranchPasadena' : 'Products'</p><p class="source-code">          }</p></li>
<li>Let us further define a function named <strong class="source-inline">generatelib</strong> and add <strong class="source-inline">classes</strong> as input parameters. This function takes in the class names and their attribute names as input and generates the code from the class templates of the <strong class="source-inline">codegenerator</strong> library:<p class="source-code">def generatelib(classes):</p><p class="source-code">    for key, value in classes.items():</p><p class="source-code">        codegen = c(key, value)</p><p class="source-code">        codegen.generatecode()   </p></li>
<li>In this<a id="_idIndexMarker702"/> step, let us write the generated code into a file to generate a custom library that can be used further:<p class="source-code">from contextlib import redirect_stdout</p><p class="source-code">with open('abcmegamartlib.py', 'w') as code:</p><p class="source-code">    with redirect_stdout(code):</p><p class="source-code">        generatelib(classes)</p><p class="source-code">code.close()</p></li>
<li>The generated code is in the following format for each input class:<p class="source-code">class VegCounter:</p><p class="source-code">    def __init__(self):</p><p class="source-code">        self._items = None</p><p class="source-code">    @property</p><p class="source-code">    def testitems(self):</p><p class="source-code">        return self.testitems</p><p class="source-code">    @testitems.getter</p><p class="source-code">    def testitems(self):</p><p class="source-code">        print('get testitems')</p><p class="source-code">        return self._testitems</p><p class="source-code">    @testitems.setter</p><p class="source-code">    def testitems(self, value):</p><p class="source-code">        print('set testitems')</p><p class="source-code">        self._testitems = value</p><p class="source-code">    @testitems.deleter</p><p class="source-code">    def testitems(self):</p><p class="source-code">        print('del testitems')</p><p class="source-code">        del self._testitems</p></li>
<li>We <a id="_idIndexMarker703"/>can further import the generated library and define objects as follows:<p class="source-code">import abcmegamartlib as abc</p><p class="source-code">abc.BranchManhattan()</p></li>
</ol>
<p>The preceding code returns the following output:</p>
<p class="source-code"><strong class="bold">&lt;abcmegamartlib.BranchManhattan at 0x21c4800c7f0&gt;</strong></p>
<p>These are various examples of code generation that can be implemented using Python’s metaprogramming <strong class="source-inline">ast</strong> module.</p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor183"/>Summary</h1>
<p>In this chapter, we have looked at various examples to generate code for a custom class and a class with custom attributes. We have also covered examples of generating code for a custom class with methods and attributes. Finally, we have developed a code generator that can be used to develop a custom library using the concept of abstract syntax trees in Python. </p>
<p>Overall, we have seen various scenarios that can help us utilize the abstract syntax tree within Python’s <strong class="source-inline">ast</strong> module and generate dynamic code using Python metaprogramming.</p>
<p>In the next chapter, we will be discussing a case study to which we can apply all the concepts of metaprogramming that we have covered so far in the book.</p>
</div>
</div></body></html>