<html><head></head><body>
  <div id="_idContainer317" class="Basic-Text-Frame">
    <h1 class="chapterNumber">12</h1>
    <h1 id="_idParaDest-222" class="chapterTitle">Selection Algorithms</h1>
    <p class="normal">One interesting set of algorithms related to finding elements in an unordered list of items is<a id="_idIndexMarker996"/> selection algorithms. Given a list of elements, selection algorithms are used to find the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest or largest element from the list. So given a list of data elements and a number (<code class="inlineCode">k</code>), the aim is to find the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest or largest element. The simplest case of selection algorithms is to find the minimum or maximum data element from the list. However, sometimes, we may need to find the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest or largest element in the list. The simplest way is to first sort the list using any sorting algorithm, and then we can easily obtain the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest (or largest) element. However, when the list is very large, then it is not efficient to sort the list to get the <code class="inlineCode">k</code><sup class="superscript">th </sup>smallest or largest element. In that case, we can use different selection algorithms that can efficiently produce the <code class="inlineCode">k</code><sup class="superscript">th </sup>smallest or largest element.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Selection by sorting</li>
      <li class="bulletList">Randomized selection</li>
      <li class="bulletList">Deterministic selection</li>
    </ul>
    <p class="normal">We will start with the technical requirements, and then we will discuss selection by sorting.</p>
    <h1 id="_idParaDest-223" class="heading-1">Technical requirements</h1>
    <p class="normal">All of the source code that’s used in this chapter is provided in the given GitHub link: <a href="https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter12"><span class="url">https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter12</span></a>.</p>
    <h1 id="_idParaDest-224" class="heading-1">Selection by sorting</h1>
    <p class="normal">Items <a id="_idIndexMarker997"/>in a list may undergo statistical inquiries such as finding the mean, median, and mode values. Finding the mean and mode values does not require the list to be ordered. However, to find the median in a list of numbers, the list must first be ordered. Finding the median requires you to find the element in the middle position of the ordered list. In addition, this can be used when we want to find the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest item in the list. To find the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest number in an unordered list of items, an obvious method is to first sort the list, and after sorting, you can rest assured that the element at index 0 will hold the smallest element in the list. Likewise, the last element in the list will hold the largest element in the list. </p>
    <p class="normal">For more information on how to order data items within a list, see <em class="chapterRef">Chapter 11</em>, <em class="italic">Sorting</em>. However, in order to obtain a <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest element from the list, it is not a good solution to apply a sorting algorithm to a long list of elements to obtain the minimum or maximum or <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest or largest value from the list since sorting is quite an expensive operation. Thus, if we need to find out the <code class="inlineCode">k</code><sup class="superscript">th </sup>smallest or largest element from a given list, there is no need to sort the complete list as we have other methods that we can use for this purpose. Let’s discuss better techniques to find the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest element without having to sort the list in the first place, starting with randomized selection.</p>
    <h1 id="_idParaDest-225" class="heading-1">Randomized selection</h1>
    <p class="normal">The randomized selection algorithm<a id="_idIndexMarker998"/> is used to obtain the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest number that is based on the quicksort algorithm; the randomized selection algorithm is also known as quickselect. In <em class="chapterRef">Chapter 11</em>, <em class="italic">Sorting</em>, we discussed the quicksort algorithm. The quicksort algorithm is an efficient algorithm to sort an unordered list of items. To summarize, the quicksort algorithm<a id="_idIndexMarker999"/> works as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">It selects a pivot.</li>
      <li class="numberedList">It partitions the unsorted list around the pivot.</li>
      <li class="numberedList">It recursively sorts the two halves of the partitioned list using <em class="italic">steps 1</em> and <em class="italic">2.</em></li>
    </ol>
    <p class="normal">One important fact about<a id="_idIndexMarker1000"/> quicksort is that after every partitioning step, the index of the pivot does not change, even after the list becomes sorted. This means that after each iteration, the selected pivot value will be placed in its correct position in the list. This property of quicksort enables us to obtain the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest number without sorting the complete list. Let’s discuss the randomized selection method, which is also known as the quickselect algorithm, to obtain the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest element from a list of n data items.</p>
    <h2 id="_idParaDest-226" class="heading-2">Quickselect</h2>
    <p class="normal">The quickselect algorithm<a id="_idIndexMarker1001"/> is used to obtain the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest element in an unordered list of items. It is based on the quicksort algorithm, in which we recursively sort the elements of both the sublists from the pivot point. In each iteration, the pivot value reaches the correct position in the list, which divides the list into two unordered sublists (left and right sublists), where the left sublist has smaller values as compared to the pivot value, and the right sublist has greater values compared to the pivot value. Now, in the case of the quickselect algorithm, we recursively call the function only for the sublist that has the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest element. </p>
    <p class="normal">In the quickselect algorithm, we compare the index of the pivot point with the <code class="inlineCode">k</code> value to obtain the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest element from the given unordered list. There will be three cases in the quickselect algorithm, as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">If the index of the pivot point is smaller than <code class="inlineCode">k</code>, then we are sure that the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest value will be present on the right-hand sublist of the pivot point. So we only recursively call the quickselect function for the right sublist.</li>
      <li class="numberedList">If the index of the pivot point is greater than <code class="inlineCode">k</code>, then it is obvious that the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest element will be present on the left-hand side of the pivot point. So we only recursively look for the <code class="inlineCode">i</code><sup class="superscript">th</sup> element in the left sublist.</li>
      <li class="numberedList">If the index of the pivot point is equal to <code class="inlineCode">k</code>, then it means that we have found out the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest value, and we return it.</li>
    </ol>
    <p class="normal">Let’s understand the working<a id="_idIndexMarker1002"/> of the quickselect algorithm with an example. Consider a list of elements, <code class="inlineCode">{45, 23, 87, 12, 72, 4, 54, 32, 52}</code>. We can use the quickselect algorithm to find the third smallest element in this list.</p>
    <p class="normal">We start the algorithm by selecting a pivot value, that is, <code class="inlineCode">45</code>. Here we are choosing the first element as the pivot element for simplicity; however, any other element can be chosen as a pivot element. After the first iteration of the algorithm, the pivot value moves to its correct position in the list, which in this example is at index 4 (the index is starting from 0). Next, we check the condition <code class="inlineCode">k&lt;pivot</code> point (that is, <code class="inlineCode">2&lt;4</code>). Case- 2 is applicable, so we only consider the left sublist, and recursively call the function. Here, we compare the index of the pivot value (that is, <code class="inlineCode">4</code>) with the value of <code class="inlineCode">k</code> (that is, the 3<sup class="superscript">rd</sup> position or at index 2).</p>
    <p class="normal">Next, we take the<a id="_idIndexMarker1003"/> left sublist and select the pivot point (that is, <code class="inlineCode">4</code>). After the run, the <code class="inlineCode">4</code> is placed in its correct position (that is, the 0<sup class="superscript">th</sup> index). As the index of the pivot is less than the value of <code class="inlineCode">k</code>, we consider the right sublist. </p>
    <p class="normal">Similarly, we take <code class="inlineCode">23</code> as the pivot point, which is also placed in its correct position. Now, when we compare the index of the pivot point and the value of <code class="inlineCode">k</code>, they are equal, which means we have found the 3<sup class="superscript">rd</sup> smallest element, and it will be returned. The complete step-by-step process to find the 3<sup class="superscript">rd</sup> smallest element is shown in <em class="italic">Figure 12.1</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_12_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.1: Step-by-step demonstration of the quickselect algorithm</p>
    <p class="normal">Let’s discuss <a id="_idIndexMarker1004"/>the implementation of the <code class="inlineCode">quick_select</code> method. It is defined as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">quick_select</span><span class="hljs-function">(</span><span class="hljs-params">array_list, start, end, k</span><span class="hljs-function">):</span>
    split = partition(array_list, start, end)
    <span class="hljs-keyword">if</span> split == k:
        <span class="hljs-keyword">return</span> array_list[split]
    <span class="hljs-keyword">elif</span> split &lt; k:
        <span class="hljs-keyword">return</span> quick_select(array_list, split + <span class="hljs-number">1</span>, end, k)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> quick_select(array_list, start, split-<span class="hljs-number">1</span>, k)
</code></pre>
    <p class="normal">In the above<a id="_idIndexMarker1005"/> code, the <code class="inlineCode">quick_select</code> function takes the complete array, the index of the first element of the list, the index of the last element, and the <code class="inlineCode">k</code><sup class="superscript">th</sup> element specified by value <code class="inlineCode">k</code> as parameters. The value of <code class="inlineCode">k</code> maps with the index that the user is searching for, meaning the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest number in the list.</p>
    <p class="normal">Initially, we use the <code class="inlineCode">partition()</code> method (which is defined and discussed in detail in <em class="chapterRef">Chapter 11</em>, <em class="italic">Sorting</em>) to place the selected pivot point in such a way that it divides the given list of elements in the left sublist and the right sublist, in which the left sublist has data elements that are smaller than the pivot value, and right subtree has data elements that are greater than the pivot value. The <code class="inlineCode">partition()</code> method is called <code class="inlineCode">split = partition(array_list, start, end)</code> and returns the <code class="inlineCode">split</code> index. Here, the <code class="inlineCode">split</code> index is the position where the pivot element is placed in the array, and (<code class="inlineCode">start</code>, <code class="inlineCode">end</code>) is the starting and ending indices of the list. Once we get the split point, we compare the <code class="inlineCode">split</code> index with the required value of <code class="inlineCode">k</code> to find out whether we have reached the position of the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest data item or whether the required <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest element will be on the left sublist or the right sublist. These three conditions are as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">If the <code class="inlineCode">split</code> is equal to the value of <code class="inlineCode">k</code>, then it means that we have reached the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest data item in the list.</li>
      <li class="numberedList">If the <code class="inlineCode">split</code> is less than <code class="inlineCode">k</code>, then it means that the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest item should exist or be found between <code class="inlineCode">split+1</code> and <code class="inlineCode">right</code>.</li>
      <li class="numberedList">If the <code class="inlineCode">split</code> is greater than <code class="inlineCode">k</code>, then it means that the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest item should exist or be found between <code class="inlineCode">left</code> and <code class="inlineCode">split-1</code>.</li>
    </ol>
    <p class="normal">In the preceding example, a split point occurs at index 4 (index starting from 0). If we are searching for the 3<sup class="superscript">rd </sup>smallest number, then since 4 &lt; 2 yields <code class="inlineCode">false</code>, a recursive call to the right sublist is made using <code class="inlineCode">quick_select(array_list, left, split-1, k)</code>. </p>
    <p class="normal">Here, for the completeness of this algorithm, the <code class="inlineCode">partition()</code> method is given as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">partition</span><span class="hljs-function">(</span><span class="hljs-params">unsorted_array, first_index, last_index</span><span class="hljs-function">):</span>
    pivot = unsorted_array[first_index]
    pivot_index = first_index
    index_of_last_element = last_index
    less_than_pivot_index = index_of_last_element
    greater_than_pivot_index = first_index + <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-keyword">while</span> unsorted_array[greater_than_pivot_index] &lt; pivot <span class="hljs-keyword">and</span> greater_than_pivot_index &lt; last_index:
            greater_than_pivot_index += <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> unsorted_array[less_than_pivot_index] &gt; pivot <span class="hljs-keyword">and</span> less_than_pivot_index &gt;= first_index:
            less_than_pivot_index -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> greater_than_pivot_index &lt; less_than_pivot_index:
            temp = unsorted_array[greater_than_pivot_index]
            unsorted_array[greater_than_pivot_index] = unsorted_array[less_than_pivot_index]
            unsorted_array[less_than_pivot_index] = temp
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span>
    unsorted_array[pivot_index] = unsorted_array[less_than_pivot_index]
    unsorted_array[less_than_pivot_index] = pivot
    <span class="hljs-keyword">return</span> less_than_pivot_index
</code></pre>
    <p class="normal">We can use the <a id="_idIndexMarker1006"/>below code snippet to find out the k<sup class="superscript">th</sup> smallest element using the <code class="inlineCode">quickselect</code> algorithm for a given array.</p>
    <pre class="programlisting code"><code class="hljs-code">list1 = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>]
<span class="hljs-built_in">print</span>(<span class="hljs-string">"The 2nd smallest element is"</span>, quick_select(list1, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"The 3rd smallest element is"</span>, quick_select(list1, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>))
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">The 2nd smallest element is 3
The 3rd smallest element is 4
</code></pre>
    <p class="normal">In the above code, we get the 2<sup class="superscript">nd</sup> and 3<sup class="superscript">rd</sup> smallest elements from the given list of elements. The worst-case performance of a randomized selection-based <code class="inlineCode">quick-select</code> algorithm is O(n<sup class="superscript">2</sup>).</p>
    <p class="normal">In the above implementation of the <code class="inlineCode">partition()</code> method, we use the first element of the list as the pivot element for simplicity, but any element can be chosen from the list as the pivot element. A good pivot element is one that divides the list into almost equal halves. Therefore, it is possible to improve the performance of the quickselect algorithm by selecting the split point more efficiently in linear time with the worst-case complexity of <code class="inlineCode">O(n)</code>. We discuss how to do this in the next section using deterministic selection.</p>
    <h1 id="_idParaDest-227" class="heading-1">Deterministic selection</h1>
    <p class="normal">Deterministic selection <a id="_idIndexMarker1007"/>is an algorithm for finding out the <code class="inlineCode">k</code><sup class="superscript">th</sup> item in an unordered list of elements. As we have seen in the <code class="inlineCode">quickselect</code> algorithm, we select a random “pivot” element that partitions the list into two sublists and calls itself recursively for one of the two sublists. In a deterministic selection algorithm, we choose a pivot element more efficiently instead of taking any random pivot element.</p>
    <p class="normal">The main concept of the deterministic algorithm is to select a pivot element that produces a good split of the list, and a good split is one that divides the list into two halves. For instance, a good way to select a pivot element would be to choose the median of all the values. But we will need to sort the elements in order to find out the median element, which is not efficient, so instead, we try to find a way to select a pivot element that divides the list roughly in the middle.</p>
    <p class="normal">The median of medians is a method that provides us with the approximate median value, that is, a value close to the actual median for a given unsorted list of elements. It divides the given list of elements in such a way that in the worst case, at least 3 out of 10 (3/10) of the list will be below the pivot element, and at least 3 out of 10 of the elements will be above the list.</p>
    <p class="normal">Let’s take an example to understand this. Let’s say we have a list of 15 elements: <code class="inlineCode">{11, 13, 12, 111, 110, 15, 14, 16, 113, 112, 19, 18, 17, 114, 115}</code>.</p>
    <p class="normal">Next, we divide it into groups of 5 elements and sort them as follows: <code class="inlineCode">{{11, 12, 13, 110, 111}, {14, 15, 16, 112, 113}, {17, 18, 19, 114, 115}}</code>.</p>
    <p class="normal">Next, we compute the median of each of these groups, and they are <code class="inlineCode">13</code>, <code class="inlineCode">16</code>, and <code class="inlineCode">19</code>, respectively. Further, the median of these median values <code class="inlineCode">{13, 16, 19}</code> is <code class="inlineCode">16</code>. This is the median of medians for the given list. Here, we can see that 5 elements are smaller, and <code class="inlineCode">9</code> elements are greater than the pivot element. When we select this median of the median as a pivot element, the list of <code class="inlineCode">n</code> elements is divided in such a way that at least <code class="inlineCode">3n/10</code> elements are smaller than the pivot element.</p>
    <p class="normal">The deterministic algorithm<a id="_idIndexMarker1008"/> to select the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest element works as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Split the list of unordered items into groups of five elements each (the number 5 is not mandatory; it can be changed to any other number, for example, 8)</li>
      <li class="numberedList">Sort these groups (in general, we use insertion sort for this purpose) and find the median of all these groups</li>
      <li class="numberedList">Recursively, find the median of the medians obtained from these groups; let’s say that is point <strong class="keyWord">p</strong></li>
      <li class="numberedList">Using this point <strong class="keyWord">p</strong> as the pivot element, recursively call the partition algorithm similar to quickselect to find out the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest element</li>
    </ol>
    <p class="normal">Let’s consider an example list of 15 elements to understand the working of the deterministic algorithm to find out the 3<sup class="superscript">rd</sup> smallest element from the list, as shown in <em class="italic">Figure 12.2</em>. First, we divide the list into groups of 5 elements each, and then we sort these groups/sublists. Once we have sorted the lists, we find out the median of the sublists. For this example, items <strong class="keyWord">23</strong>, <strong class="keyWord">52</strong>, and <strong class="keyWord">34</strong> are the medians of these three sublists, as shown in <em class="italic">Figure 12.2</em>.</p>
    <p class="normal">Next, we sort the list of <a id="_idIndexMarker1009"/>medians for all the sublists. Further, we find out the median of this list, that is, the median of the median, which is <strong class="keyWord">34</strong>. This median of medians is used to select the partition/pivot point for the whole list. Further, we divide the given list using this pivot element to partition the list into 2 sublists, placing the given pivot element at its correct position in the list. For this example, the index of the pivot element is 7 (index starting from 0; this is shown in <em class="italic">Figure 12.2.</em>).</p>
    <figure class="mediaobject"><img src="../Images/B17217_12_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.2: Step-by-step procedure for the deterministic selection algorithm</p>
    <p class="normal">The index of the <a id="_idIndexMarker1010"/>pivot element is greater than the <code class="inlineCode">k</code><sup class="superscript">th</sup> value, and hence, we recursively call the algorithm on the left sublist to obtain the required <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest element.</p>
    <p class="normal">Next, we will discuss the implementation of the deterministic selection algorithm.</p>
    <h2 id="_idParaDest-228" class="heading-2">Implementation of the deterministic selection algorithm</h2>
    <p class="normal">To implement the <a id="_idIndexMarker1011"/>deterministic algorithm for determining the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest value from the list, we start implementing the updated <code class="inlineCode">partition()</code> method, which divides the list where we select the pivot element using the median of medians method. Let’s now understand the code for the <code class="inlineCode">partition</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">partition</span><span class="hljs-function">(</span><span class="hljs-params">unsorted_array, first_index, last_index</span><span class="hljs-function">):</span> 
    <span class="hljs-keyword">if</span> first_index == last_index: 
        <span class="hljs-keyword">return</span> first_index 
    <span class="hljs-keyword">else</span>: 
        nearest_median = median_of_medians(unsorted_array[first_index:last_index]) 
    index_of_nearest_median = get_index_of_nearest_median(unsorted_array, first_index, last_index, nearest_median) 
    swap(unsorted_array, first_index, index_of_nearest_median) 
 
    pivot = unsorted_array[first_index] 
    pivot_index = first_index 
    index_of_last_element = last_index 
    less_than_pivot_index = index_of_last_element 
    greater_than_pivot_index = first_index + <span class="hljs-number">1</span> 
 
    <span class="hljs-comment">## This while loop is used to correctly place pivot element at its correct position </span>
    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:
        <span class="hljs-keyword">while</span> unsorted_array[greater_than_pivot_index] &lt; pivot <span class="hljs-keyword">and</span> greater_than_pivot_index &lt; last_index:
            greater_than_pivot_index += <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> unsorted_array[less_than_pivot_index] &gt; pivot <span class="hljs-keyword">and</span> less_than_pivot_index &gt;= first_index:
            less_than_pivot_index -= <span class="hljs-number">1</span>
 
        <span class="hljs-keyword">if</span> greater_than_pivot_index &lt; less_than_pivot_index:
            temp = unsorted_array[greater_than_pivot_index]
            unsorted_array[greater_than_pivot_index] = unsorted_array[less_than_pivot_index]
            unsorted_array[less_than_pivot_index] = temp
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span>
 
    unsorted_array[pivot_index]=unsorted_array[less_than_pivot_index]
    unsorted_array[less_than_pivot_index]=pivot
    <span class="hljs-keyword">return</span> less_than_pivot_index
</code></pre>
    <p class="normal">In the above code, we implement the partition method, which is very similar to what we did in the quickselect algorithm. In the quickselect algorithm, we used a random pivot element (for simplicity, the first element of the list), but in the deterministic selection algorithm, we select the pivot element using the median of medians. The partition method divides the list into two sublists – the left and right sublists, in which the left sublist has elements that are smaller than the pivot element, and the right sublist has elements that are greater than the pivot element. The main benefit of using the pivot element with the median of medians is that it, in general, divides the list into almost two halves.</p>
    <p class="normal">At the start of the<a id="_idIndexMarker1012"/> code, firstly, in the <code class="inlineCode">if-else</code> condition, we check the length of the given list of elements. If the length of the list is 1, then we return the index of that element, so if the <code class="inlineCode">unsorted_array</code> has only one element, <code class="inlineCode">first_index</code> and <code class="inlineCode">last_index</code> will be equal. Therefore, <code class="inlineCode">first_index</code> is returned. And, if the length is greater than 1, then we call the <code class="inlineCode">median_of_medians()</code> method to compute the median of medians of the list passed to this method with the starting and ending indices as <code class="inlineCode">first_index</code> and <code class="inlineCode">last_index</code>. The return median of medians value is stored in the <code class="inlineCode">nearest_median</code> variable.</p>
    <p class="normal">Now, let’s understand the code of the <code class="inlineCode">median_of_medians()</code> method. It is given as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">median_of_medians</span><span class="hljs-function">(</span><span class="hljs-params">elems</span><span class="hljs-function">):</span>  
    sublists = [elems[j:j+<span class="hljs-number">5</span>] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(elems), <span class="hljs-number">5</span>)] 
    medians = [] 
    <span class="hljs-keyword">for</span> sublist <span class="hljs-keyword">in</span> sublists: 
        medians.append(<span class="hljs-built_in">sorted</span>(sublist)[<span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(sublist)/<span class="hljs-number">2</span>)]) 
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(medians) &lt;= <span class="hljs-number">5</span>: 
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sorted</span>(medians)[<span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(medians)/<span class="hljs-number">2</span>)]
    <span class="hljs-keyword">else</span>: 
        <span class="hljs-keyword">return</span> median_of_medians(medians)
</code></pre>
    <p class="normal">In the above code of the <code class="inlineCode">median_of_medians</code> function, recursion is used to compute the median of medians for the given list. The function begins by splitting the given list, <code class="inlineCode">elems</code>, into groups of five elements each. As discussed earlier in the deterministic algorithm, we divide the given list into groups of 5 elements. Here, we choose 5 elements since it mostly performs well. However, we could have used any other number as well. This means that if <code class="inlineCode">elems</code> contains 100 items, there will be 20 groups that are created by the <code class="inlineCode">sublists = [elems[j:j+5] for j in range(0, len(elems), 5)]</code> statement, with each containing a maximum of five elements.</p>
    <p class="normal">After creating sublists of five elements each, we create an empty array, <code class="inlineCode">medians</code>, that stores the medians of each of the five-element arrays (i.e., <code class="inlineCode">sublists</code>). Further, the <code class="inlineCode">for</code> loop iterates over the list of lists inside <code class="inlineCode">sublists</code>. Each sublist is sorted, the median is found, and it is stored in the <code class="inlineCode">medians</code> list. The <code class="inlineCode">medians.append(sorted(sublist)[len(sublist)//2])</code> statement will sort the list and obtain the element stored in its middle index. The <code class="inlineCode">medians</code> variable becomes the median list of all the sublists of which there are five elements in each sublist. In this implementation, we use an existing sorting function of Python; it will not impact the performance of the algorithm due to the list’s small size.</p>
    <p class="normal">Thereafter, the next <a id="_idIndexMarker1013"/>step is to recursively compute the median of medians, which we will use as a pivot element. It is important to note here that the length of the median array can itself be a large array because if the original length of the array is n, then the length of the median array will be n/5, and sorting this may be time-consuming in itself. Hence, we check the length of the <code class="inlineCode">medians</code> array, and if it is less than 5, we sort the <code class="inlineCode">medians</code> list and return the element located in its middle index. If, on the other hand, the size of the list is greater than five, we recursively call the <code class="inlineCode">median_of_medians</code> function again, supplying it with the list of the medians stored in <code class="inlineCode">medians</code>. Finally, the function returns the median of medians of the given list of elements.</p>
    <p class="normal">Let’s take another example to better understand the concept of the median of medians with the following list of numbers:</p>
    <pre class="programlisting code"><code class="hljs-code">[2, 3, 5, 4, 1, 12, 11, 13, 16, 7, 8, 6, 10, 9, 17, 15, 19, 20, 18, 23, 21, 22, 25, 24, 14]
</code></pre>
    <p class="normal">We can break this list down into groups of five elements, each with the <code class="inlineCode">sublists = [elems[j:j+5] for j in range(0, len(elems), 5)]</code> code statement, in order to obtain the following list:</p>
    <pre class="programlisting code"><code class="hljs-code">[[2, 3, 5, 4, 1], [12, 11, 13, 16, 7], [8, 6, 10, 9, 17], [15, 19, 20, 18, 23], [21, 22, 25, 24, 14]]
</code></pre>
    <p class="normal">Each of the five-element lists will be sorted as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">[[1, 2, 3, 5, 5], [7, 11, 12, 13, 16], [6, 8, 9, 10, 17], [15, 18, 19, 20, 23], [14, 21, 22, 24, 25]]
</code></pre>
    <p class="normal">Next, we obtain their medians to produce the following list:</p>
    <pre class="programlisting code"><code class="hljs-code">[3, 12, 9, 19, 22]
</code></pre>
    <p class="normal">We sort the above list:</p>
    <pre class="programlisting code"><code class="hljs-code">[3, 9, 12, 19, 22]
</code></pre>
    <p class="normal">Since the list is five elements in size, we only return the median of the sorted list, which is <code class="inlineCode">12</code> in this case. Otherwise, if the length of this array had been greater than 5, we would have made another call to the <code class="inlineCode">median_of_median</code> function. </p>
    <p class="normal">Once we have the <a id="_idIndexMarker1014"/>median of the median value, we need to find out its index in the given list. We write the <code class="inlineCode">get_index_of_nearest_median</code> function for this purpose. This function takes the starting and ending indices of the list indicated by the <code class="inlineCode">first</code> and <code class="inlineCode">last</code> parameters:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get_index_of_nearest_median</span><span class="hljs-function">(</span><span class="hljs-params">array_list, first, last, median</span><span class="hljs-function">):</span> 
    <span class="hljs-keyword">if</span> first == last: 
        <span class="hljs-keyword">return</span> first 
    <span class="hljs-keyword">else</span>: 
        <span class="hljs-keyword">return</span> array_list.index(median)
</code></pre>
    <p class="normal">Next in the partition method, we swap the median of medians value with the first element of the list, that is, we swap <code class="inlineCode">index_of_nearest_median</code> with <code class="inlineCode">first_index</code> of the <code class="inlineCode">unsorted_array</code> using the <code class="inlineCode">swap</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code">swap(unsorted_array, first_index, index_of_nearest_median)
</code></pre>
    <p class="normal">The <code class="inlineCode">utility</code> function to swap two array elements is shown here:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">swap</span><span class="hljs-function">(</span><span class="hljs-params">array_list, first, index_of_nearest_median</span><span class="hljs-function">):</span>
    temp = array_list[first]
    array_list[first] = array_list[index_of_nearest_median]
    array_list[index_of_nearest_median] = temp
</code></pre>
    <p class="normal">We swap these two elements. The rest of the implementation is quite similar to what we discussed in the <code class="inlineCode">quick_select</code> algorithm. Now, we have the median of the median for the given list, which is stored in <code class="inlineCode">first_index</code> of the unsorted list. </p>
    <p class="normal">Now, the rest of the implementation is similar to the partition method of the <code class="inlineCode">quick_select</code> algorithm and also the quicksort algorithm, which is discussed in detail in <em class="chapterRef">Chapter 11</em>, <em class="italic">Sorting</em>. For the completeness of the algorithm here, we discuss this again.</p>
    <p class="normal">We consider the first<a id="_idIndexMarker1015"/> element as a pivot element, and we take two pointers, that is, left and right. The left pointer moves from the left to the right direction in the list to keep elements that are smaller than the pivot element on the left hand side of the pivot element. It is initialized with the second element of the list, that is, <code class="inlineCode">first_index+1</code>, whereas the right pointer moved from the right to the left direction, which maintains the list in a way that elements greater than the pivot element are on the right-hand side of the pivot element in the list. It is initialized with the last element of the list. So we have two variables <code class="inlineCode">less_than_pivot_index</code> (the right pointer) and <code class="inlineCode">greater_than_pivot_index</code> (the left pointer) in which <code class="inlineCode">less_than_pivot_index</code> is initialized with <code class="inlineCode">index_of_last_element</code> and <code class="inlineCode">greater_than_pivot_index</code> with <code class="inlineCode">first_index + 1</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">    less_than_pivot_index = index_of_last_element
    greater_than_pivot_index = first_index + <span class="hljs-number">1</span>
</code></pre>
    <p class="normal">Next, we move the left and right pointers in such a way that after one iteration, the pivot element is placed in its correct position in the list. That means it divides the list into two sublists such that the left sublist has all the elements that are smaller than the pivot element, and the right sublist has elements greater than the pivot element. We do this with these three steps given below:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-comment">## This while loop is used to correctly place pivot element at its correct position </span>
    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:
        <span class="hljs-keyword">while</span> unsorted_array[greater_than_pivot_index] &lt; pivot <span class="hljs-keyword">and</span> greater_than_pivot_index &lt; last_index:
            greater_than_pivot_index += <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> unsorted_array[less_than_pivot_index] &gt; pivot <span class="hljs-keyword">and</span> less_than_pivot_index &gt;= first_index:
            less_than_pivot_index -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> greater_than_pivot_index &lt; less_than_pivot_index:
            temp = unsorted_array[greater_than_pivot_index]
            unsorted_array[greater_than_pivot_index] = unsorted_array[less_than_pivot_index]
            unsorted_array[less_than_pivot_index] = temp
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span>
</code></pre>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The first while loop will move <code class="inlineCode">greater_than_pivot_index</code> to the right side of the array until the element pointed out by <code class="inlineCode">greater_than_pivot_index</code> is less than the pivot element and <code class="inlineCode">greater_than_pivot_index</code> is less than <code class="inlineCode">last_index</code>:
        <pre class="programlisting gen"><code class="hljs"><span class="hljs-keyword">while</span> unsorted_array[greater_than_pivot_index] &lt; pivot <span class="hljs-keyword">and</span> greater_than_pivot_index &lt; last_index: greater_than_pivot_index += <span class="hljs-number">1</span>
</code></pre>
      </li>
      <li class="numberedList">In the second <code class="inlineCode">while</code> loop, we’ll be doing the same thing but for the <code class="inlineCode">less_than_pivot_index</code> in the array. We’ll move <code class="inlineCode">less_than_pivot_index</code> to the left direction until the element pointed out by <code class="inlineCode">less_than_pivot_index</code> is greater than the pivot element and <code class="inlineCode">less_than_pivot_index</code> is greater than or equal to <code class="inlineCode">first_index</code>:
        <pre class="programlisting gen"><code class="hljs"><span class="hljs-keyword">while</span> unsorted_array[less_than_pivot_index] &gt; pivot <span class="hljs-keyword">and</span> less_than_pivot_index &gt;= first_index: less_than_pivot_index -= <span class="hljs-number">1</span>
</code></pre>
      </li>
      <li class="numberedList">Now, we <a id="_idIndexMarker1016"/>check if <code class="inlineCode">greater_than_pivot_index</code> and <code class="inlineCode">less_than_pivot_index</code> have crossed each other or not. If <code class="inlineCode">greater_than_pivot_index</code> is still less than <code class="inlineCode">less_than_pivot_index</code> (that is, we have not found the correct position for the pivot element yet), we swap the elements indicated by <code class="inlineCode">greater_than_pivot_index</code> and <code class="inlineCode">less_than_pivot_index</code>, and then we will repeat the same three steps again. If they have crossed each other, that means we have found the correct position for the pivot element, and we will break from the loop:
        <pre class="programlisting gen"><code class="hljs"><span class="hljs-keyword">if</span> greater_than_pivot_index &lt; less_than_pivot_index:
    temp = unsorted_array[greater_than_pivot_index]
    unsorted_array[greater_than_pivot_index] = unsorted_array[less_than_pivot_index]
    unsorted_array[less_than_pivot_index] = temp
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">break</span>
</code></pre>
      </li>
    </ol>
    <p class="normal">After exiting the loop, the variable <code class="inlineCode">less_than_pivot_index</code> will point to the correct index of the pivot, so we will just swap the values that are present at <code class="inlineCode">less_than_pivot_index</code> and <code class="inlineCode">pivot_index</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">    unsorted_array[pivot_index]=unsorted_array[less_than_pivot_index]
    unsorted_array[less_than_pivot_index]=pivot
</code></pre>
    <p class="normal">Finally, we will simply return the pivot index, which is stored in the variable <code class="inlineCode">less_than_pivot_index</code>.</p>
    <p class="normal">After the partition method, the pivot element reaches its correct position in the list. Thereafter, we recursively call the partition method to one of the sublists (the left sublist or the right sublist) depending on the required value of <code class="inlineCode">k</code> and the pivot element position to find out the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest element. This process is the same as the quickselect algorithm.</p>
    <p class="normal">The implementation of <a id="_idIndexMarker1017"/>the deterministic select algorithm is given as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">deterministic_select</span><span class="hljs-function">(</span><span class="hljs-params">array_list, start, end, k</span><span class="hljs-function">):</span> 
    split = partition(array_list, start, end) 
    <span class="hljs-keyword">if</span> split == k: 
        <span class="hljs-keyword">return</span> array_list[split] 
    <span class="hljs-keyword">elif</span> split &lt; k:
        <span class="hljs-keyword">return</span> deterministic_select(array_list, split + <span class="hljs-number">1</span>, end, k) 
    <span class="hljs-keyword">else</span>: 
        <span class="hljs-keyword">return</span> deterministic_select(array_list, start, split-<span class="hljs-number">1</span>, k)
</code></pre>
    <p class="normal">As you may have observed, the implementation of the deterministic selection algorithm looks exactly the same as the quickselect algorithm. The only difference between the two is how we select the pivot element; apart from that, everything is the same.</p>
    <p class="normal">After the initial <code class="inlineCode">array_list</code> has been partitioned by the selected pivot element, which is the median of medians of the list, a comparison with the <code class="inlineCode">k</code><sup class="superscript">th</sup> element is made:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">If the index of the split point, that is, <code class="inlineCode">split</code>, is equal to the required value of <code class="inlineCode">k</code>, it means that we have found the required <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest element.</li>
      <li class="numberedList">If the index of the split point, the, <code class="inlineCode">split</code> is less than the required value of <code class="inlineCode">k</code>, then a recursive call to the right sublist is made as <code class="inlineCode">deterministic_select(array_list, split + 1, right, k)</code>. This will look for the <code class="inlineCode">k</code><sup class="superscript">th</sup> element on the right-hand side of the array. </li>
      <li class="numberedList">Otherwise, if the split index is greater than the value of k, then the function call to the left sublist is made as <code class="inlineCode">deterministic_select(array_list, left, split-1, k)</code>.</li>
    </ol>
    <p class="normal">The following code snippet can be used to create a list and further use the deterministic algorithm to find out the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest element from the list:</p>
    <pre class="programlisting code"><code class="hljs-code">list1= [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">16</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">17</span>, <span class="hljs-number">15</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">18</span>, <span class="hljs-number">23</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">25</span>, <span class="hljs-number">24</span>, <span class="hljs-number">14</span>]
<span class="hljs-built_in">print</span>(<span class="hljs-string">"The 6th smallest element is"</span>, deterministic_select(list1, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(list1)-<span class="hljs-number">1</span>, <span class="hljs-number">5</span>))
</code></pre>
    <p class="normal">The output of the above code is as follows.</p>
    <pre class="programlisting con"><code class="hljs-con">The 6th smallest element is 6
</code></pre>
    <p class="normal">In the output of the above code, we have the 6<sup class="superscript">th</sup> smallest element from a given list of 25 elements. The deterministic selection algorithm improves the quickselect algorithm by using the median of medians element as a pivot point for selecting the <code class="inlineCode">k</code><sup class="superscript">th</sup> smallest element from a list. It improves performance because the median of medians method finds out the estimated median in linear time, and when this estimated median is used as a pivot <a id="_idIndexMarker1018"/>point in the quickselect algorithm, the worst-case running time’s complexity improves from O(n<sup class="superscript">2</sup>) to the linear O(n).</p>
    <p class="normal">The median of medians algorithm can also be used to choose a pivot point in the quicksort algorithm for sorting a list of elements. This significantly improves the worst-case performance of the quicksort algorithm from O(n<sup class="superscript">2</sup>) to a complexity of O(nlogn).</p>
    <h1 id="_idParaDest-229" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we discussed two important methods to find the k<sup class="superscript">th</sup> smallest element in a list, randomized selection and deterministic selection algorithms. The simple solution of merely sorting a list to perform the operation of finding the k<sup class="superscript">th</sup> smallest element is not optimal as we can use better methods to determine the k<sup class="superscript">th</sup> smallest element. The quickselect algorithm, which is the random selection algorithm, divides the list into two sublists. One list has smaller values, and the other list has greater values as compared to the selected pivot element. We reclusively use one of the sublists to find the location of the k<sup class="superscript">th</sup> smallest element, which can be further improved by selecting the pivot point using the median of medians method in the deterministic selection algorithm.</p>
    <p class="normal">In the next chapter, we will discuss several important string matching algorithms.</p>
    <h1 id="_idParaDest-230" class="heading-1">Exercise</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">What will be the output if the quickselect algorithm is applied to the given array <p class="normal"><code class="inlineCode">arr = [3, 1, 10, 4, 6, 5]</code> with <code class="inlineCode">k</code> given as 2?</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Can quickselect find the smallest element in an array with duplicate values?</li>
      <li class="numberedList">What is the difference between the quicksort algorithm and the quickselect algorithm?</li>
      <li class="numberedList">What is the main difference between the deterministic selection algorithm and the quickselect algorithm?</li>
      <li class="numberedList">What triggers the worst-case behavior of the selection algorithm?</li>
    </ol>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://packt.link/MEvK4"><span class="url">https://packt.link/MEvK4</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1421249772551223062.png" alt=""/></p>
  </div>
</body></html>