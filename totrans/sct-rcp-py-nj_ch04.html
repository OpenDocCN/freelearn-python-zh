<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Using Python Collections</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using Python Collections</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will look at Python collection objects, which take the regular, built-in Python containers (list, tuple, dictionary, and set being the most common) and add special functionality for particular situations. We will cover:</p>
<ul>
<li>Reviewing containers</li>
<li>Implementing namedtuple</li>
<li>Implementing deque</li>
<li>Implementing ChainMap</li>
<li>Implementing Counters</li>
<li>Implementing OrderedDict</li>
<li>Implementing defaultdict</li>
<li>Implementing UserDict</li>
<li>Implementing UserList</li>
<li>Implementing UserString</li>
<li>Improving Python collections</li>
<li>Looking at the collections – extended module</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>While the base containers do the grunt work of holding data for most programmers, there are times when something with a bit more functionality and capability is required. Collections are built-in tools that provide specialized alternatives to the regular containers. Most of them are just subclasses or wrappers to existing containers that can make life easier for a developer, provide new features, or just provide more options for a programmer so a developer doesn't have to worry about making boilerplate code and can focus on getting the work done.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reviewing containers</h1>
                </header>
            
            <article>
                
<p>Before we get into collections, we will take a little bit of time to review the existing containers so we know what is, and is not, provided with them. This will allow us to better understand the capabilities and potential limitations of collections.</p>
<p>Sequence types include lists, tuples, and ranges, though only lists and tuples are relevant here. Sequence types include the <kbd>__iter___</kbd> function by default, so they can naturally iterate over the sequence of objects they contain.</p>
<p>Lists are mutable sequences, that is, they can be modified in-place. They most commonly hold homogeneous items, but this is not a requirement. Lists are probably the most common container to be used in Python, as it is easy to add new items to a list by simply using <kbd>&lt;list&gt;.append</kbd> to extend the sequence.</p>
<p>Tuples are immutable, meaning they cannot be modified in-place and a new tuple must be created if a modification is to occur. They frequently hold heterogeneous data, such as capturing multiple return values. Because they cannot be modified, they are also useful to use if you want to ensure that a sequential list isn't modified by accident.</p>
<p>Dictionaries map values to keys. They are known as hash tables, associated arrays, or by other names in different programming languages. Dictionaries are mutable, just like lists, so they can be changed in-place without having to create a new dictionary. A key feature of dictionaries is that keys must be hashable, that is, the hash digest of the object cannot change during its lifetime. Thus, mutable objects, such as lists or other dictionaries, cannot be used as keys. However, they can be used as values mapped to the keys.</p>
<p>Sets are similar to dictionaries in that they are containers of unordered, hashable objects, but they are just values; no keys exist in a set. Sets are used to test for membership, removing duplicates from sequences, and a variety of mathematical operations.</p>
<p>Sets are mutable objects, while frozensets are immutable. Since sets can be modified, they are not suitable for dictionary keys or as elements of another set. Frozensets, being unchanging, can be used as dictionary keys or as a set element.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Sequence objects (lists and tuples) have the following common&#160;operations. Note: <kbd>s</kbd> and <kbd>t</kbd> are sequences of the same type; <kbd>n</kbd>, <kbd>i</kbd>, <kbd>j</kbd>, and <kbd>k</kbd> are integer values, and <kbd>x</kbd> is an object that meets the restrictions required by <kbd>s</kbd>:</p>
<ul>
<li><kbd>x in s</kbd>: This returns <kbd>true</kbd>&#160;if an item in sequence <kbd>s</kbd> is equal to <kbd>x</kbd>; otherwise, it returns&#160;<kbd>false</kbd></li>
<li><kbd>x not in s</kbd>: This returns true if no item in sequence <kbd>s</kbd> is equal to <kbd>x</kbd>; otherwise, it returns&#160;<kbd>false</kbd></li>
<li><kbd>s + t</kbd>: This concatenates sequence <kbd>s</kbd> with sequence <kbd>t</kbd> (concatenating immutable sequences creates a new object)</li>
<li><kbd>s * n</kbd>: This adds <kbd>s</kbd> to itself <kbd>n</kbd> times (items in the sequence are not copied, but referenced multiple times)</li>
<li><kbd>s[i]</kbd>: This retrieves the <kbd>i<sup>th</sup></kbd> item in sequence <kbd>s</kbd>, with count starting from 0 (negative numbers start counting from the end of the sequence, rather than the beginning)</li>
<li><kbd>s[i:j]</kbd>: This retrieves a slice of <kbd>s</kbd>, from <kbd>i</kbd> (inclusive) to <kbd>j</kbd> (exclusive)</li>
<li><kbd>s[i:j:k]</kbd>: This retrieves a slice from <kbd>s</kbd>, from <kbd>i</kbd> to <kbd>j</kbd>, skipping <kbd>k</kbd> times</li>
<li><kbd>len(s)</kbd>: This returns the length of <kbd>s</kbd></li>
<li><kbd>min(s)</kbd>: This returns the smallest item in <kbd>s</kbd></li>
<li><kbd>max(s)</kbd>: This returns the largest item in <kbd>s</kbd></li>
<li><kbd>s.index(x[, i[, j]])</kbd>: This indexes the first instance of <kbd>x</kbd> in <kbd>s</kbd>; optionally, it returns&#160;<kbd>x</kbd> at or after index <kbd>i</kbd> and (optionally) before index <kbd>j</kbd></li>
<li><kbd>s.count(x)</kbd>: This returns the total count of <kbd>x</kbd> instances in <kbd>s</kbd></li>
</ul>
<p>Mutable sequence objects, such as lists, have the following specific operations available to them (note: <kbd>s</kbd> is a mutable sequence, <kbd>t</kbd> is an iterable object, <kbd>i</kbd> and <kbd>j</kbd> are integer values, and the <kbd>x</kbd> object meets any sequence restrictions).</p>
<ul>
<li><kbd>s[i] = x</kbd>: This replaces the object at index position <kbd>i</kbd> with object <kbd>x</kbd></li>
<li><kbd>s[i:j] = t</kbd>: The slice from <kbd>i</kbd> (inclusive) to <kbd>j</kbd> (exclusive) is replaced with the contents of object <kbd>t</kbd></li>
<li><kbd>del s[i:j]</kbd>: This deletes the contents of <kbd>s</kbd> from indexes <kbd>i</kbd> to <kbd>j</kbd></li>
</ul>
<ul>
<li><kbd>s[i:j:k] = t</kbd>: This replaces the slice of <kbd>i</kbd> to <kbd>j</kbd> (stepping by <kbd>k</kbd>) by object <kbd>t</kbd> (<kbd>t</kbd> must have the same length as <kbd>s</kbd>)</li>
<li><kbd>del s[i:j:k]</kbd>: This deletes elements of the sequence, as determined by the slice indexes and stepping, if present</li>
<li><kbd>s.append(x)</kbd>: This adds <kbd>x</kbd> to the end of <kbd>s</kbd></li>
<li><kbd>s.clear()</kbd>: This deletes all elements from the sequence</li>
<li><kbd>s.copy()</kbd>: This <span>is used to&#160;</span>shallow copy of <kbd>s</kbd></li>
<li><kbd>s.extend(t)</kbd>: This extends <kbd>s</kbd> with the contents of <kbd>t</kbd> (can also use <kbd>s += t</kbd>)</li>
<li><kbd>s *= n</kbd>: This <span>is used to&#160;</span>update <kbd>s</kbd> with its contents repeated <kbd>n</kbd> times</li>
<li><kbd>s.insert(i, x)</kbd>: This inserts&#160;<kbd>x</kbd> into <kbd>s</kbd> at position <kbd>i</kbd></li>
<li><kbd>s.pop([i])</kbd>: This is used to extract an item at index <kbd>i</kbd> from <kbd>s</kbd>, returning it as a result and removing it from <kbd>s</kbd> (defaults to removing the last item from <kbd>s</kbd>)</li>
<li><kbd>s.remove(x)</kbd>: This <span>is used to&#160;</span>delete the first item from <kbd>s</kbd> that matches <kbd>x</kbd> (throws an exception if <kbd>x</kbd> is not present)</li>
<li><kbd>s.reverse()</kbd>: This is used to reverse <kbd>s</kbd> in-place</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Nearly every container in Python has special methods associated with it. While the methods described previously are universal for their respective containers, some containers have methods that apply just to them.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Lists and tuples</h1>
                </header>
            
            <article>
                
<p>In addition to implementing all common and mutable sequence operations, lists and tuples also have the following special method available to them:</p>
<ul>
<li><kbd>sort(*, [reverse=False, key=None])</kbd><span>: This is used to sort a list in-place, using the</span> <kbd><em>&lt;</em></kbd> <span>comparator. Reverse comparison, that is, high-to-low, can be accomplished by using</span> <kbd>reverse=True</kbd><span>. The optional</span> <kbd>key</kbd> <span>argument specifies a function that returns the list, as sorted by the function.</span></li>
</ul>
<p>As an example of how to use the <kbd>key</kbd> argument, assume you have a list of lists:</p>
<div class="float float-listings">
<pre><strong>&gt;&gt;&gt; l = [[3, 56], [2, 34], [6, 98], [1, 43]]</strong></pre>
</div>
<p>To sort this list, call the <kbd>sort()</kbd> method on the list, and then print the list. Without having a function that combines the two steps, they have to be called separately. This is actually a feature, as normally sorted lists are then programatically operated on, rather than always printed out:</p>
<div class="float float-listings">
<pre><strong>&gt;&gt;&gt; l.sort()
&gt;&gt;&gt; l
[[1, 43], [2, 34], [3, 56], [6, 98]]</strong></pre>
</div>
<p>If you wanted a different sorting, such as sorting by the second item in each list item, you can pass that as a argument into a function:</p>
<div class="float float-listings">
<pre><strong>&gt;&gt;&gt; l = [[3, 56], [2, 34], [6, 98], [1, 43]]
&gt;&gt;&gt; def diffSort(item):
...     return item[1]
... 
&gt;&gt;&gt; l.sort(key=diffSort)
&gt;&gt;&gt; l
[[2, 34], [1, 43], [3, 56], [6, 98]]</strong></pre>
</div>
<p>In this example, you can see that the sorting isn't by the first item in each sublist, but by the second item, that is, it is now <kbd>34-&gt;43-&gt;56-&gt;98</kbd> instead of <kbd>1-&gt;2-&gt;3-&gt;6</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dictionaries</h1>
                </header>
            
            <article>
                
<p>As mappable objects, dictionaries have a number of built-in methods, as they cannot use the normal sequence operations (note: <kbd>d</kbd> represents a dictionary, <kbd>key</kbd> is a particular key for the dictionary, and&#160;<kbd>value</kbd> is the value associated with a key):</p>
<ul>
<li><kbd>len(d)</kbd>: This returns the number of items in a dictionary.</li>
<li><kbd>d[key]</kbd>: This return the <kbd>value</kbd> associated with <kbd>key</kbd>.</li>
<li><kbd>d[key] = value</kbd>: This is used to set the mapping of <kbd>key</kbd> to <kbd>value</kbd>.</li>
<li><kbd>del d[key]</kbd>: This deletes the value associated with <kbd>key</kbd>.</li>
<li><kbd>key in d</kbd>: If <kbd>key</kbd> exists in the dictionary, return <kbd>True</kbd>; otherwise, return <kbd>False</kbd>.</li>
<li><kbd>key not in d</kbd>: If <kbd>key</kbd> exists in the dictionary, return <kbd>False</kbd>; otherwise, return <kbd>True</kbd>.</li>
<li><kbd>iter(d)</kbd>: This returns an interator object from the dictionary <kbd>keys</kbd>. To actually use the iterated <kbd>keys</kbd>, you must use a <kbd>for</kbd> loop.</li>
<li><kbd>clear()</kbd>: This removes all items from the dictionary.</li>
<li><kbd>copy()</kbd>: This returns a shallow copy of the dictionary.</li>
</ul>
<ul>
<li><kbd>fromkeys(seq[, value])</kbd>: This creates a new dictionary using the <kbd>keys</kbd> listed in <kbd>seq</kbd> and sets their <kbd>values</kbd> to <kbd>value</kbd>. If no <kbd>value</kbd> is provided, it defaults to <kbd>None</kbd>.</li>
<li><kbd>get(key[, default])</kbd>: This returns the <kbd>value</kbd> associated with <kbd>key</kbd>, if <kbd>key</kbd> exists. Otherwise, the <kbd>default</kbd> value is returned. If <kbd>default</kbd> is not set, then <kbd>None</kbd> is returned, that is, no response, but not an error.</li>
<li><kbd>items()</kbd>: This returns a <kbd>view</kbd> object of the <kbd>key:value</kbd> pairs in the dictionary.</li>
<li><kbd>keys()</kbd>: This returns a <kbd>view</kbd> object of just the dictionary keys.</li>
<li><kbd>pop(key[, default])</kbd>: This is used if <kbd>key</kbd> exists in the dictionary; remove it from the dictionary and return its <kbd>value</kbd>; otherwise, return <kbd>default</kbd>. If <kbd>default</kbd> isn't provided and the <kbd>key</kbd> doesn't exist, then an error is raised.</li>
<li><kbd>popitem()</kbd>: This removes and returns an arbitrary pair from the dictionary. As dictionaries are unsorted, the returned pair is effectively randomly selected.</li>
<li><kbd>setdefault(key[, default])</kbd>: This is used if <kbd>key</kbd> is present in the dictionary; return its <kbd>value</kbd>. If not present, then make a new <kbd>key:value</kbd> pair with the provided <kbd>key</kbd> and the <kbd>default</kbd> value. If <kbd>default</kbd> isn't set, it defaults to <kbd>None</kbd>.</li>
<li><kbd>update([other])</kbd>: This modifies the dictionary by updating it with the pairs from <kbd>other</kbd>. If existing <kbd>keys</kbd> are present, they will be overwritten. <kbd>other</kbd> can be another dictionary or an iterable object of <kbd>key:value</kbd> pairs, such as a tuple.</li>
<li><kbd>values()</kbd>: This returns a <kbd>view</kbd> object of the dictionaries values.</li>
</ul>
<p>Dictionary <kbd>view</kbd> objects are actually dynamic objects that show a dictionary's items; when a dictionary changes, the view updates to reflect those changes. <kbd>view</kbd> objects actually have their own methods available to them:</p>
<ul>
<li><kbd>len(dictview)</kbd>: This returns the number of items in a dictionary</li>
<li><kbd>iter(dictview)</kbd><em>:</em>&#160;This returns an iterator object over the dictionary <kbd>keys</kbd><em>,</em> <kbd>values</kbd><em>,</em> or <kbd>key:value</kbd> pairs</li>
<li><kbd>x in dictview</kbd>: This returns <kbd>True</kbd> if <kbd>x</kbd> exists within the <kbd>view</kbd> object</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sets</h1>
                </header>
            
            <article>
                
<p>Since sets are similar to dictionaries, they have a number of methods associated with them, which apply to both set and frozenset:</p>
<ul>
<li><kbd>len(s)</kbd>: This returns the number of items in set <kbd>s</kbd></li>
<li><kbd>x in s</kbd>: This returns <kbd>True</kbd> if <kbd>x</kbd> exists in <kbd>s</kbd>;&#160; otherwise, it is <kbd>False</kbd></li>
</ul>
<ul>
<li><kbd>x not in s</kbd>: This returns <kbd>False</kbd> if <kbd>x</kbd> exists in <kbd>s</kbd>; otherwise, it is&#160;<kbd>True</kbd></li>
<li><kbd>isdisjoint(other)</kbd>: This returns&#160;<kbd>True</kbd> if the set has no elements in common with object <kbd>other</kbd></li>
<li><kbd>issubset(other)</kbd>: This tests whether all elements in the <kbd>set</kbd> are also in <kbd>other</kbd></li>
<li><kbd>issuperset(other)</kbd>: This tests whether all elements in <kbd>other</kbd> are also in <kbd>set</kbd></li>
<li><kbd>union(*others)</kbd>: This returns a new set that includes elements from the original <kbd>set</kbd> and all <kbd>other</kbd> objects</li>
<li><kbd>intersection(*others)</kbd>: This returns a new set that only contains objects that are in common between the <kbd>set</kbd> and all <kbd>other</kbd> objects</li>
<li><kbd>difference(*others)</kbd>: This returns a new set that is only the elements that exist in the <kbd>set</kbd>, but are not in <kbd>others</kbd></li>
<li><kbd>symmetric_different(other)</kbd>: This returns a new set of elements that are either in <kbd>set</kbd> or <kbd>other</kbd>, but not both</li>
<li><kbd>copy()</kbd>: This returns a new set with a shallow copy of the set</li>
</ul>
<p>The following are methods only available to set, but not to frozenset:</p>
<ul>
<li><kbd>update(*others)</kbd>: This updates the set by adding elements from all <kbd>others</kbd></li>
<li><kbd>intersection_update(*others)</kbd>: This updates the set by keeping only the elements that are in the <kbd>set</kbd> and <kbd>others</kbd></li>
<li><kbd>difference_update(*others)</kbd>: This updates the set by keeping only the elements found in <kbd>others</kbd></li>
<li><kbd>symmetric_difference_update(other)</kbd>: This updates the set with only the elements found in either <kbd>set</kbd> or <kbd>other</kbd>, but not common to both</li>
<li><kbd>add(elem)</kbd>: This adds&#160;<kbd>elem</kbd> to the set</li>
<li><kbd>remove(elem)</kbd>: This deletes&#160;<kbd>elem</kbd> from the set; it throws an exception if&#160;<kbd>elem</kbd> is not present</li>
<li><kbd>discard(elem)</kbd>: This deletes&#160;<kbd>elem</kbd> from the set if present</li>
<li><kbd>pop()</kbd>: This removes&#160;<kbd>elem</kbd> from the set, if present, and returns its value; it throws an exception if the set contains no values</li>
<li><kbd>clear()</kbd>: This deletes all elements from the set</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing namedtuple</h1>
                </header>
            
            <article>
                
<p>Using&#160;<kbd>namedtuple</kbd>, a developer can give meaning to each item in a tuple and allow the tuple's fields to be accessed by name rather than by index value. This allows for more readable and better self-documenting code. Named tuples can be used in place of regular tuples with no adverse effects.</p>
<p>Named tuples can be thought of as using dictionary-type <kbd>key:value</kbd> pairs, except in a tuple. It's not a true mapping of key to value, because named tuples are simply assigning a name to a sequence index position, that is, name=value, but it may help to conceptually think of them as unchanging mapped pairs. Named positions can be called by name or by position index.</p>
<p><kbd>namedtuple</kbd> is generated using the following command format:</p>
<div class="float float-listings">
<pre>collections.namedtuple(typename, field_names, *, verbose=False, rename=False, module=None)</pre>
</div>
<p>The following is an explanation of the parts of the preceding command:</p>
<ul>
<li><kbd>typename</kbd>: The name of the tuple subclass being created. Subclass instances automatically generate <kbd>docstrings</kbd> incorporating the <kbd>typename</kbd> and field names, as well as creating a <kbd>__repr__</kbd> method that automatically lists the tuple contents in <kbd>name=value</kbd> format.</li>
<li><kbd>field_names</kbd>: A sequence (list or tuple) of strings to signify the names of the tuple fields, for example, [<em>X</em>-axis, <em>Y</em>-axis, <em>Z</em>-axis]. The field names can also be signified using a single string, rather than a sequence object, with each field name separated by whitespace or commas, such as <em>X</em>-axis, <em>Y</em>-axis, <em>Z</em>-axis. Any legitimate Python name can be used; not allowed names include ones that start with numbers or underscores, as well as any Python keywords.</li>
<li><kbd>*</kbd>: It helps to capture all argument inputs. This is actually no different than the more commonly seen <kbd>*args</kbd>, as the <kbd>*</kbd> is the item of concern for Python when working with arguments; <kbd>args</kbd> is simply a convention used by programmers.</li>
<li><kbd>verbose</kbd>: (deprecated) if true, the class definition will be printed after it is built. The preferred way to do this nowadays is to print the <kbd>_source</kbd> attribute.</li>
<li><kbd>rename</kbd>: If true, invalid field names are automatically replaced with positional names. For example, <kbd>abc, def, xyz, abc</kbd>&#160;would automatically become <kbd>abc, _1, xyz, _3</kbd>&#160;to replace the redundant <kbd>abc</kbd> and the Python keyword <kbd>def</kbd>.</li>
<li><kbd>module</kbd>: If defined, the <kbd>__module__</kbd> attribute of the <kbd>namedtuple</kbd> is set to the value provided.</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>It doesn't get much better than the official documentation, so here is an example from <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple">https://docs.python.org/3/library/collections.html#collections.namedtuple</a>:</p>
<ol>
<li>Make <kbd>namedtuple</kbd>:</li>
</ol>
<pre style="color: black" class="standard"><strong>      &gt;&gt;&gt; from collections import namedtuple</strong><br/><strong>      &gt;&gt;&gt; Point = namedtuple("Point", ["x", "y"])</strong></pre>
<ol start="2">
<li>Make a new instance of the <kbd>namedtuple</kbd>. You can use positional or keyword arguments:</li>
</ol>
<pre style="color: black" class="standard"><strong>      &gt;&gt;&gt; p = Point(11, y=22)</strong></pre>
<ol start="3">
<li>The new <kbd>namedtuple</kbd> can be indexed like a normal tuple:</li>
</ol>
<pre style="color: black" class="standard"><strong>      &gt;&gt;&gt; p[0] + p[1]</strong><br/><strong>      33</strong></pre>
<ol start="4">
<li>It can also be unpacked like a regular tuple:</li>
</ol>
<pre style="color: black" class="standard"><strong>      &gt;&gt;&gt; x, y = p</strong><br/><strong>      &gt;&gt;&gt; x, y</strong><br/><strong>      (11, 22)</strong></pre>
<ol start="5">
<li>Tuple objects can be accessed by their assigned names instead of index:</li>
</ol>
<pre style="color: black" class="standard"><strong>      &gt;&gt;&gt; p.x + p.y</strong><br/><strong>      33</strong></pre>
<ol start="6">
<li>Because <kbd>__repr__</kbd> is provided automatically, calling the <kbd>namedtuple</kbd> instance provides all information about the <kbd>namedtuple</kbd>:</li>
</ol>
<pre style="color: black" class="standard"><strong>      &gt;&gt;&gt; p</strong><br/><strong>      Point(x=11, y=22)</strong></pre>
<ol start="7">
<li>Another example from the documentation shows how named tuples can be utilized with CSV or SQLite. First, create a <kbd>namedtuple</kbd> (<kbd>employee_record_tuple.py</kbd>):</li>
</ol>
<pre style="color: black">        EmployeeRecord = namedtuple('EmployeeRecord', 'name, age, title, <br/>                                    department, paygrade')</pre>
<ol start="8">
<li>For a CSV file, import the <kbd>csv</kbd> module and then map the imported file data to the <kbd>namedtuple</kbd>. "<kbd>rb</kbd>" is used because the CSV format is considered a binary file type, even though it is human-readable. The method <kbd>_make()</kbd> is explained in the next section (<kbd>import_csv.py</kbd>):</li>
</ol>
<pre style="color: black">        import csv<br/>        for emp in map(EmployeeRecord._make, csv.reader(open("employees.csv", "rb"))):<br/>            print(emp.name, emp.title)</pre>
<ol start="9">
<li>For SQLite, import the module and create the connection. After the cursor is executed to select the fields from the database, they are mapped to the <kbd>namedtuple</kbd> just like the CSV example (<kbd>import_sqlite.py</kbd>):</li>
</ol>
<pre style="color: black">        import sqlite3<br/>        conn = sqlite3.connect('/companydata')<br/>        cursor = conn.cursor()<br/>        cursor.execute('SELECT name, age, title, department, paygrade FROM employees')<br/>        for emp in map(EmployeeRecord._make, cursor.fetchall()):<br/>            print(emp.name, emp.title)</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>As seen in the preceding examples, named tuples have special methods and attributes available to them, as well as the methods available to normal tuples. The <kbd>namedtuple</kbd> methods and attributes are denoted with an underscore prefix to ensure that they don't conflict with field names, as shown here:</p>
<ul>
<li><kbd>&lt;namedtuple&gt;._make(iterable)</kbd>: A class method that creates a new instance from an existing sequence or iterable object:</li>
</ul>
<pre style="color: black" class="standard"><strong>      &gt;&gt;&gt; t = [12, 34]</strong><br/><strong>      &gt;&gt;&gt; Point._make(t)</strong><br/><strong>      Point(x=12, y=34)</strong></pre>
<ul>
<li><kbd>&lt;namedtuple&gt;._asdict()</kbd>: It returns an <kbd>OrderedDict</kbd> object that maps field names to corresponding values:</li>
</ul>
<pre style="color: black" class="standard"><strong>      &gt;&gt;&gt; p = Point(x=12, y=34)</strong><br/><strong>      &gt;&gt;&gt; p._asdict()</strong><br/><strong>      OrderedDict([('x', 11), ('y', 22)])&gt;</strong></pre>
<ul>
<li><kbd>&lt;namedtupled&gt;._replace(**kwargs)</kbd>: It returns an instance of the named tuple that replaces specific fields with new values:</li>
</ul>
<pre style="color: black" class="standard"><strong>      &gt;&gt;&gt; p = Point(x=11, y=22)</strong><br/><strong>      &gt;&gt;&gt; p._replace(x=33)</strong><br/><strong>      Point(x=33, y=22)</strong><br/><strong>      &gt;&gt;&gt; for partnum, record in inventory.items():</strong><br/><strong>      ... inventory[partnum] = record._replace(price=newprices[partnum], timestamp=time.now())</strong></pre>
<ul>
<li><kbd>&lt;namedtuple&gt;._source</kbd><span>: This attribute provides a string with the raw Python source code that actually creates the <kbd>namedtuple</kbd> class; this code makes the <kbd>namedtuple</kbd> self-documenting. The string can be printed, executed, saved to a file, imported as a module, and so on:</span></li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img style="font-size: 1em;color: black;width:38.42em;height:24.08em;" src="images/aacec847-1206-4f3a-9c36-25e898fd5dcc.png"/></div>
<ul>
<li><kbd>&lt;namedtuple&gt;._fields</kbd>: It returns a tuple of field names as strings. This is useful when needing to create new named tuples from existing named tuples:</li>
</ul>
<pre style="color: black" class="standard"><strong>      &gt;&gt;&gt; p._fields # view the field names</strong><br/><strong>      ('x', 'y')</strong><br/><strong>      &gt;&gt;&gt; Color = namedtuple('Color', 'red green blue')</strong><br/><strong>      &gt;&gt;&gt; Pixel = namedtuple('Pixel', Point._fields +  Color._fields)</strong><br/><strong>      &gt;&gt;&gt; Pixel(11, 22, 128, 255, 0)</strong><br/><strong>      Pixel(x=11, y=22, red=128, green=255, blue=0)</strong></pre>
<p>In addition to the preceding methods and attributes, named tuples have some special functionality that can be utilized to maximize their versatility.</p>
<ul>
<li>If a field's name is a string,&#160;<kbd>getattr()</kbd> can be used to obtain its value:</li>
</ul>
<pre><strong>      &gt;&gt;&gt; getattr(p, "x")</strong><br/><strong>      11</strong></pre>
<ul>
<li>Dictionaries can be converted to named tuples, due to the <kbd>field:value</kbd> mapping. The double-star operator that unpacks argument lists, that is,&#160;<kbd>**kwargs</kbd>, is used to obtain this effect:</li>
</ul>
<pre><strong>      &gt;&gt;&gt; position = {"x": 11, "y": 22}</strong><br/><strong>      &gt;&gt;&gt; Point(**position)</strong><br/><strong>      Point(x=11, y=22)</strong></pre>
<ul>
<li>As a normal Python class, named tuples can be subclassed to modify or add functionality. Here is an example from the documentation of adding a calculated field and fixed-width printing:</li>
</ul>
<pre><strong>      &gt;&gt;&gt; class Point(namedtuple('Point', ['x', 'y'])):</strong><br/><strong>      ...     __slots__ = ()</strong><br/><strong>      ...     @property</strong><br/><strong>      ...     def hypot(self):</strong><br/><strong>      ...         return (self.x ** 2 + self.y ** 2) ** 0.5</strong><br/><strong>      ...     def __str__(self):</strong><br/><strong>      ...         return 'Point: x=%6.3f y=%6.3f hypot=%6.3f' % <br/>                  (self.x, self.y, self.hypot)</strong></pre>
<p style="padding-left: 90px">We will get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/0ba20439-f05b-40b4-971e-548f4f8520a9.png" style="width:32.75em;height:9.08em;"/></div>
<p style="padding-left: 90px">The <kbd>@property</kbd> decorator is an alternative to getter and setter interfaces. While not a detailed walk-through, here is a brief summary for the curious. If a module is written from the beginning to use getter and setter methods, there isn't an issue with updates. However, if a module incorporated them at a later time, any programs written with the module would have to be rewritten to incorporate the new features. This is because getter/setter methods retrieve and assign values to variables, replacing previous functionality, such as via initialization, or to throw exceptions when out-of-bounds values are used.</p>
<p style="padding-left: 90px">Using the <kbd>@property</kbd> decorator means programs implementing the modified module don't have to be rewritten; all the changes are internal to the module. Thus, backwards compatibility is maintained and users of the module don't have to worry about the internals.</p>
<ul>
<li>By directly modifying the <kbd>namedtuple __doc__</kbd> fields, <kbd>docstrings</kbd> can be customized to reflect the <kbd>namedtuple</kbd> fields:</li>
</ul>
<pre><strong>      &gt;&gt;&gt; Book = namedtuple('Book', ['id', 'title', 'authors'])</strong><br/><strong>      &gt;&gt;&gt; Book.__doc__ += ': Hardcover book in active collection'</strong><br/><strong>      &gt;&gt;&gt; Book.id.__doc__ = '13-digit ISBN'</strong><br/><strong>      &gt;&gt;&gt; Book.title.__doc__ = 'Title of first printing'</strong><br/><strong>      &gt;&gt;&gt; Book.authors.__doc__ = 'List of authors sorted by last name'</strong></pre>
<ul>
<li>Finally, default values can be set via the <kbd>_replace()</kbd> method:</li>
</ul>
<pre><strong>      &gt;&gt;&gt; Account = namedtuple('Account', 'owner balance<br/>                               transaction_count')</strong><br/><strong>      &gt;&gt;&gt; default_account = Account('&lt;owner name&gt;', 0.0, 0)</strong><br/><strong>      &gt;&gt;&gt; johns_account = default_account._replace(owner='John')</strong><br/><strong>      &gt;&gt;&gt; janes_account = default_account._replace(owner='Jane')</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing deque</h1>
                </header>
            
            <article>
                
<p>Deques (pronounced <em>decks</em>) are list-like containers that have fast appending and pop values from either end. The name deque comes from this action: double-ended queues. Deques are thread safe, meaning data is manipulated in such a way that all threads behave without overwriting data or otherwise operate with unintended actions. Popped values from either end of the deque have the same performance, regardless of being on the front or the rear of the queue.</p>
<p>For those familiar with big <em>O</em> notation, performance is <em>O(1)</em> for both front- and rear-popped values. For those unfamiliar with big <em>O</em> notation, this just means it takes the same amount of time for a deque to pop a value from the front as it does for the back. This is significant because lists, which have similar operations as the deque, are optimized for quick, fixed-length operations and take a performance hit of <em>O(n)</em> to memory movement when popping and inserting values, as they both modify the size and position of the data structure. <em>O(n)</em> simply means that the time to completion of a process increases linearly and is proportional to the number of input values.</p>
<p>The downside to using deques is that they have slow data access; that is, reading data from a deque is functionally slower than reading from a list. Hence, deques are ideal when quick data insertion/removal from either end of the deque is necessary.</p>
<p>The format for using deque is as follows:</p>
<div class="float float-listings">
<pre>collections.deque([iterable[, maxlen]])</pre>
</div>
<ul>
<li><kbd>iterable</kbd>: A data object that can be iterated through. This iteration is used to generate a new deque object that is initialized in a left-to-right manner, that is, an empty deque object is filled using <kbd>append()</kbd> on each iterated object. If <kbd>iterable</kbd> is not specified, an empty deque object is created.</li>
<li><kbd>maxlen</kbd>: It specifies how long a deque object can be. If this is not provided, or if it is equal to <kbd>None</kbd>, then the deque can be extended to any length. If the max length of a deque is exceeded, then for every item that is added to it, an equal quantity is removed from the opposite end. In terms of functionality, bounded-length deques operate like the <kbd>tail</kbd> command in *NIX; they are also used for transaction tracking, and monitoring recent data transactions within a pool of data.</li>
</ul>
<p>Methods used with deque are similar to lists, but they naturally have their own, special methods due to their nature:</p>
<ul>
<li><kbd>append(x)</kbd>: It adds value <kbd>x</kbd> to the end (right-sight) of the deque object.</li>
<li><kbd>appendleft(x)</kbd>: It adds value <kbd>x</kbd> to the front (left-sight) of the deque.</li>
<li><kbd>clear()</kbd>: It deletes all items from the deque.</li>
<li><kbd>copy()</kbd>: It creates a shallow copy of the deque.</li>
<li><kbd>count(x)</kbd>: It counts the number of elements in the deque that are equal to <kbd>x</kbd>.</li>
<li><kbd>extend(iterable)</kbd>: It extends the end of the deque by appending items from <kbd>iterable</kbd>.</li>
</ul>
<ul>
<li><kbd>extendleft(iterable)</kbd>: It extends the front of the deque by appending items from <kbd>iterable</kbd>; this results in the items from <kbd>iterable</kbd> being reversed within the deque.</li>
<li><kbd>index(x[, start[, stop]])</kbd>: It returns the position of <kbd>x</kbd> in the deque; if provided, the position will be limited to or after the <kbd>start</kbd> index and before the <kbd>stop</kbd> position. If found, the first match will be returned; otherwise, an error is given.</li>
<li><kbd>insert(i, x)</kbd>: It inserts item <kbd>x</kbd> at position <kbd>i</kbd>; if the deque is bounded and the insertion results in exceeding the max length, an error will occur.</li>
<li><kbd>pop()</kbd>: It removes and returns an element from the end of the deque. If no items are in the deque, an error will occur.</li>
<li><kbd>popleft()</kbd>: It removes and returns an element from the front of the deque; an error is returned if no items are present.</li>
<li><kbd>remove(value)</kbd>: It deletes the first item that matches <kbd>value</kbd>; if there is no match, an error occurs.</li>
<li><kbd>reverse()</kbd>: It reverses the deque in-place.</li>
<li><kbd>rotate(n=1)</kbd>: It rotates the deque to the right <kbd>n</kbd> times, moving the end element to the front. If <kbd>n</kbd> is negative, the rotation is to the left.</li>
</ul>
<p>In addition to the preceding methods, deques can also perform the following operations:</p>
<ul>
<li><kbd>Iteration</kbd>: Walk through sequence</li>
<li><kbd>Pickling</kbd>: Data serialization</li>
<li><kbd>len(deque)</kbd>: Length assessment</li>
<li><kbd>reversed(deque)</kbd>: Reversal object return</li>
<li><kbd>copy.copy(deque)</kbd>: Shallow copy</li>
<li><kbd>copy.deepcopy(deque)</kbd>: Deep copy</li>
<li><span><kbd>in</kbd>:&#160;</span>Membership testing via the <kbd>in</kbd> operator</li>
<li><kbd>deque[1]</kbd>: Indexed accessing</li>
</ul>
<p>Index access is fast <em>[O(1)]</em> at the end of the deque, but slows to <em>O(n)</em>&#160;in the middle. As mentioned earlier, if fast random access to items in the sequence is more important than having the ability to insert/remove from both ends, then a list object is the better choice.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's walk through an example from <a href="https://docs.python.org/3/library/collections.html#collections.deque">https://docs.python.org/3/library/collections.html#collections.deque</a>:</p>
<ol>
<li>Import <kbd>deque</kbd> from the <kbd>collections</kbd> module:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; from collections import deque</strong></pre>
<ol start="2">
<li>Create a <kbd>deque</kbd> object. In this case, we will give it a string object as an argument:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; d = deque("ghi")</strong></pre>
<ol start="3">
<li>Simple iteration over the string:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; for elem in d: </strong><br/><strong>      ...     print(elem.upper())</strong><br/><strong>      G</strong><br/><strong>      H</strong><br/><strong>      I</strong></pre>
<ol start="4">
<li>Add additional items to the front and rear of the deque:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; d.append('j') # add a new entry to the right side</strong><br/><strong>      &gt;&gt;&gt; d.appendleft('f') # add a new entry to the left side</strong></pre>
<ol start="5">
<li>Show the new <kbd>deque</kbd> object:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; d # show the representation of the deque</strong><br/><strong>      deque(['f', 'g', 'h', 'i', 'j'])</strong></pre>
<ol start="6">
<li>Pop out the left- and right-most elements:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; d.pop() </strong><br/><strong>      'j'</strong><br/><strong>      &gt;&gt;&gt; d.popleft() </strong><br/><strong>      'f'</strong></pre>
<ol start="7">
<li>Show the updated <kbd>deque</kbd> object:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; list(d) </strong><br/><strong>      ['g', 'h', 'i']</strong></pre>
<ol start="8">
<li>See that the deque can be accessed just like a list:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; d[0] # peek at leftmost item</strong><br/><strong>      'g'</strong><br/><strong>      &gt;&gt;&gt; d[-1] # peek at rightmost item</strong><br/><strong>      'i'</strong></pre>
<ol start="9">
<li>Reverse the deque object in-place and create a list from it:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; list(reversed(d)) </strong><br/><strong>      ['i', 'h', 'g']</strong></pre>
<ol start="10">
<li>Search for an item in the deque:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; 'h' in d </strong><br/><strong>      True</strong></pre>
<ol start="11">
<li>Add multiple items to the deque at the same time:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; d.extend('jkl') </strong><br/><strong>      &gt;&gt;&gt; d</strong><br/><strong>      deque(['g', 'h', 'i', 'j', 'k', 'l'])&lt;</strong></pre>
<ol start="12">
<li>Rotate the contents of the deque back and forth:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; d.rotate(1) # right rotation</strong><br/><strong>      &gt;&gt;&gt; d</strong><br/><strong>      deque(['l', 'g', 'h', 'i', 'j', 'k'])</strong><br/><strong>      &gt;&gt;&gt; d.rotate(-1) # left rotation</strong><br/><strong>      &gt;&gt;&gt; d</strong><br/><strong>      deque(['g', 'h', 'i', 'j', 'k', 'l'])</strong></pre>
<ol start="13">
<li>Make a new, reversed <kbd>deque</kbd> object:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; deque(reversed(d)) </strong><br/><strong>      deque(['l', 'k', 'j', 'i', 'h', 'g'])</strong></pre>
<ol start="14">
<li>Delete the contents of the deque and show that operations can no longer be performed on it:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; d.clear() # empty the deque</strong><br/><strong>      &gt;&gt;&gt; d.pop() # cannot pop from an empty deque</strong><br/><strong>      Traceback (most recent call last):</strong><br/><strong>          File "&lt;pyshell#6&gt;", line 1, in -toplevel-</strong><br/><strong>              d.pop()</strong><br/><strong>          IndexError: pop from an empty deque</strong></pre>
<ol start="15">
<li>Add new items to the front of the deque (the result is in reverse order of input):</li>
</ol>
<pre><strong>      &gt;&gt;&gt; d.extendleft('abc') </strong><br/><strong>      &gt;&gt;&gt; d</strong><br/><strong>      deque(['c', 'b', 'a'])</strong></pre>
<ol start="16">
<li>If a deque object has&#160;<kbd>maxlength</kbd> assigned, it can function like <kbd>tail</kbd> in *NIX operating systems:</li>
</ol>
<pre><strong>      def tail(filename, n=10):</strong><br/><strong>          'Return the last n lines of a file'</strong><br/><strong>          with open(filename) as f:</strong><br/><strong>              return deque(f, n)</strong></pre>
<ol start="17">
<li>Create a <strong>FIFO</strong> (<strong>first-in, first-out</strong>) container. Input is appended on the right side of the <kbd>deque</kbd> object and output is popped from the left side:</li>
</ol>
<pre>       from collections import deque<br/>       import itertools<br/><br/>       def moving_average(iterable, n=3):<br/>            # moving_average([40, 30, 50, 46, 39, 44]) –&gt; <br/>                              40.0 42.0 45.0 43.0<br/>            # http://en.wikipedia.org/wiki/Moving_average<br/>            it = iter(iterable) <br/>            # create an iterable object from input argument<br/>            d = deque(itertools.islice(it, n-1))  <br/>            # create deque object by slicing iterable<br/>            d.appendleft(0)<br/>            s = sum(d)<br/>            for elem in it:<br/>                s += elem - d.popleft()<br/>                d.append(elem)<br/>                yield s / n  <br/>                # yield is like "return" but is used with generators</pre>
<ol start="18">
<li>Make a pure Python code version of <kbd>del d[n]</kbd>&#160;(<kbd>del</kbd> is actually a compiled C file when used by Python):</li>
</ol>
<pre>        def delete_nth(d, n):<br/>            d.rotate(-n)<br/>            d.popleft()<br/>            d.rotate(n)</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing ChainMap</h1>
                </header>
            
            <article>
                
<p>ChainMap is a dictionary-like class, used to create a single view of multiple mappings. It allows for quick linking between multiple mappings so they can all be considered as a single unit, which is useful when simulating nested scopes and when templating. This can be faster than creating a new dictionary and running <kbd>update()</kbd> calls repeatedly.</p>
<p>The command to create a <kbd>ChainMap</kbd> is as follows:</p>
<div class="float float-listings">
<pre>collections.ChainMap(*maps)</pre>
</div>
<p>As usual, the <kbd>*maps</kbd> is simply a number of dictionaries or other map objects passed in to be combined into a single, updateable view. If no mappings are passed in, then an empty dictionary is created so the new chain has at least one mapping available to it.</p>
<p>The mappings themselves are contained, behind the scenes, within a list. The list is a public object and it can be accessed or updated via the <kbd>maps</kbd> attribute. When looking for a key, the search occurs over the mapping list until the key is found. However, modifications to the list occur only on the first mapping.</p>
<p>To keep memory requirements low, <kbd>ChainMap</kbd> doesn't make a copy of all the mappings, but simply uses the mappings via reference. Thus, if an underlying mapping is modified, it is immediately available to the <kbd>ChainMap</kbd> object.</p>
<p>All normal dictionary methods are available, as well as the following special <kbd>ChainMap</kbd> methods:</p>
<ul>
<li><kbd>maps</kbd>: It is referred to earlier; this is a user-accessible list of mappings. The list is based on search order, that is, first-searched-to-last-searched. This list can be modified to change the mappings that are searched.</li>
<li><kbd>new_child(m=None)</kbd>: It returns a new <kbd>ChainMap</kbd> that has a new map, followed by all the maps of the current instance. If a value for <kbd>m</kbd> is passed in, it becomes the first map at the front of the list. If not provided, an empty dictionary is used. This method can be used to create subcontexts that can be updated without modifying parent mapping values.</li>
<li><kbd>parents</kbd>: It returns a new <kbd>ChainMap</kbd> that holds all the maps in the current instance except for the first one. This is useful to skip the first map when searching.</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li><kbd>chainmap_import.py</kbd>&#160;is a basic example of how a <kbd>ChainMap</kbd> actually operates in use. First, <kbd>ChainMap</kbd> is imported, then two dictionaries are created. A <kbd>ChainMap</kbd> object is created from the two dictionaries. Finally, the key:value pairs from the <kbd>ChainMap</kbd> are printed:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img style="font-size: 1em;color: black;width:36.08em;height:23.83em;" src="images/a837b3b1-0f8e-4f2f-b707-0dc48552a41d.png"/></div>
<p style="padding-left: 60px"><span>Notice how the ordering of the dictionaries impacts the results that are printed if two keys are the same, since the first mapping is the object that will be searched through first for the desired key.</span></p>
<ol start="2">
<li>The following examples come from the Python documentation at <a href="https://docs.python.org/3/library/collections.html#collections.ChainMap">https://docs.python.org/3/library/collections.html#collections.ChainMap</a>. <kbd>chainmap_builtins.py</kbd> simulates how Python looks for references to objects: <kbd>locals</kbd> is searched first, then <kbd>globals</kbd>, and finally the Python <kbd>builtins</kbd>:</li>
</ol>
<pre>       import builtins<br/>        pylookup = ChainMap(locals(), globals(), vars(builtins))</pre>
<ol start="3">
<li><kbd>chainmap_combined.py</kbd>&#160;shows how to allow user-specified arguments override environment variables which, in turn, override default values:</li>
</ol>
<pre>       from collections import ChainMap<br/>        import os, argparse<br/><br/>        defaults = {'color': 'red', 'user': 'guest'} <br/><br/>        parser = argparse.ArgumentParser()<br/>        parser.add_argument('-u', '–user')<br/>        parser.add_argument('-c', '–color')<br/>        namespace = parser.parse_args()<br/>        command_line_args = {k:v for k, v in vars(namespace).items() if v}<br/><br/>        combined = ChainMap(command_line_args, os.environ, defaults)<br/>        print(combined['color'])<br/>        print(combined['user'])</pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>Libraries are imported and default values are applied to a dictionary.</li>
<li>User input capture is coded using <kbd>argparse</kbd><span>, specifically looking for the user and color arguments.</span></li>
<li>A dictionary of command-line arguments are generated from user input.</li>
<li>The command-line arguments, operating system environment values, and default values are all combined into a <kbd>ChainMap</kbd>.</li>
<li>Finally, the selected color and user are printed to the screen. They would be, in order, the specified default values, the OS environment values, or command-line input values, depending on whether the environment values exist for color and user, or whether the user provided arguments to the Python command.</li>
<li>When ran, this code simply prints the following:</li>
</ul>
</li>
</ul>
<pre style="color: black"><strong>                      red</strong><br/><strong>                      guest</strong></pre>
<ol start="4">
<li>Context managers allow for proper management of resources. For example, <kbd>file_open.py</kbd>&#160;is a common method to open a file:</li>
</ol>
<pre>       with open('file.txt', 'r') as infile:<br/>            for line in infile:<br/>                print('{}'.format(line))</pre>
<p style="padding-left: 60px">The preceding example uses a context manager to read the file and automatically closes it when it is no longer in use. <kbd>chainmap_nested_context.py</kbd>&#160;simulates nested contexts:</p>
<pre>       c = ChainMap()  # Create root context<br/>        d = c.new_child()  # Create nested child context<br/>        e = c.new_child()  # Child of c, independent from d<br/>        e.maps[0]  # Current context dictionary – like Python's locals()<br/>        e.maps[-1]  # Root context – like Python's globals()<br/>        e.parents  # Enclosing context chain – like Python's nonlocals<br/>        d['x']  # Get first key in the chain of contexts<br/>        d['x'] = 1  # Set value in current context<br/>        del d['x']  # Delete from current context<br/>        list(d)  # All nested values<br/>        k in d  # Check all nested values<br/>        len(d)  # Number of nested values<br/>        d.items()  # All nested items<br/>        dict(d) # Flatten into a regular dictionary</pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>&#160;First, the <kbd>ChainMap</kbd> is created, along with two subclasses (remember, <kbd>ChainMap</kbd> is a class, even though it acts like a dictionary object)</li>
<li><kbd>e.maps[0]</kbd> basically says: "Get the context of the local scope"</li>
<li><kbd>e.maps[-1]</kbd> goes backwards in the context, that is, up one level in the scope tree, and gets the global scope (if you went up another level, you would be at the Python <kbd>builtins</kbd> scope)</li>
<li><kbd>e.parents</kbd> acts like the Python <kbd>nonlocal</kbd> statement, which allows binding to variables outside of the local scope, but are not global, that is, binding of encapsulated code to the enclosing code</li>
<li>After the variables are set, the first dictionary key in the chain is set and assigned a value, then deleted</li>
<li>Next, all the items in the nested structure are listed (keys), checked, counted, and listed (pairs)</li>
<li>Finally, the nested child is converted to a regular dictionary</li>
</ul>
</li>
</ul>
<ol start="5">
<li>Since the default action of <kbd>ChainMap</kbd> is to peruse the entire chain for lookups, but to only modify the first mapping listed in the chain, to modify mappings further down the chain, a subclass can be made that updates keys beyond the first mapping (<kbd>deep_chainmap.py</kbd>):</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img style="color: black;font-size: 1em;width:40.42em;height:33.00em;" src="images/05bdae67-403f-4e3a-bfa2-c6be0cec4012.png"/></div>
<p style="padding-left: 60px">&#160;This class defines two methods:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li><kbd>__setitem__()</kbd>, accepts a key and value as arguments. Each mapping object within the <kbd>ChainMap</kbd> is checked to see whether the key exists. If so, a value is assigned to that particular mapping's key. If the key doesn't exist, then a new pair is added to the first mapping object.</li>
<li><kbd>__delitem__()</kbd><span>, takes a key as its argument. Again, the mappings are cycled through to find a match to the key argument. If a match is found, the item pair is removed from the mapping. If no match is found, an error is generated.</span></li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing Counters</h1>
                </header>
            
            <article>
                
<p>The <kbd>Counter</kbd> collection is another dictionary-like object that counts hashable objects. Like dictionaries, Counters are unordered mappings of elements (stored as keys) and their respective quantities (stored as values). Value counts are stored as integer values, but can be any value, including zero and negative numbers.</p>
<p>Technically, Counter is a subclass of the dictionary class, so it has access to all the traditional dictionary methods. In addition, it has the following special methods available to it:</p>
<ul>
<li>
<p><kbd>elements()</kbd>: It returns an iterator object over the key elements, repeating each key until its quantity value is reached. Elements are printed in random order and, if an element's count is less than one, it will not be printed.</p>
</li>
<li>
<p><kbd>most_common([n])</kbd>: It returns a list of the most common elements and their counts from most common to least. If <kbd>n</kbd> is provided, only that number of elements are returned, otherwise all elements are returned.</p>
</li>
<li>
<p><kbd>subtract([iterable or mapping])</kbd>: It subtracts the number elements in the provided argument from another iterable or mapping. Both inputs and outputs can be less than one.</p>
</li>
<li>
<p><kbd>fromkeys(iterable)</kbd>: This method, common to normal dictionaries, is not available to Counter objects.</p>
</li>
<li>
<p><kbd>update([iterable or mapping])</kbd>: Elements are added to an existing iterable or mapping. When adding to an iterable, just the sequence of elements is expected, rather than key:value pairs.</p>
</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Here is how to create a new <kbd>Counter</kbd> object, as demonstrated from <a href="https://docs.python.org/3/library/collections.html#collections.Counter">https://docs.python.org/3/library/collections.html#collections.Counter</a>:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; from collections import Counter<br/>      &gt;&gt;&gt; c = Counter() # a new, empty counter</strong><br/><strong>      &gt;&gt;&gt; c = Counter('gallahad') # a new counter from an iterable</strong><br/><strong>      &gt;&gt;&gt; c = Counter({'red': 4, 'blue': 2}) # a new counter from a mapping</strong><br/><strong>      &gt;&gt;&gt; c = Counter(cats=4, dogs=8) # a new counter from keyword args</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>The first object is simply an empty counter, much like creating an empty dictionary.<br/>
The second <kbd>Counter</kbd> creates a mapping of a text string, summing the count of each unique letter, is as follows:</li>
</ul>
</li>
</ul>
<pre><strong>                   &gt;&gt;&gt; c<br/></strong><strong>                   Counter({'a': 3, 'l': 2, 'g': 1, 'h': 1, 'd': 1})</strong><strong><br/></strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>The third <kbd>Counter</kbd> object is a direct creation from a dictionary, with the quantity of each key provided by the user.</li>
<li>The final object is similar to the previous, except keyword arguments rather than a dictionary mapping.</li>
</ul>
</li>
</ul>
<ol start="2">
<li>Interaction with a <kbd>Counter</kbd> is the same as with dictionaries, except they have been optimized to return a value of <kbd>0</kbd> if an item doesn't exist within the <kbd>Counter</kbd>, rather than raising an error:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; count = Counter(["spam", "eggs", "bacon"])</strong><br/><strong>      &gt;&gt;&gt; count["toast"]</strong><br/><strong>      0</strong><br/><strong>      &gt;&gt;&gt; count</strong><br/><strong>      Counter({'spam': 1, 'eggs': 1, 'bacon': 1})</strong></pre>
<ol start="3">
<li>The <kbd>del</kbd> statement must be used to remove an element from a <kbd>Counter</kbd>. Simply changing its value to zero only changes the value while leaving the element within the <kbd>Counter</kbd>:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; count["bacon"] = 0 # assigning a value of 0 to "bacon"</strong><br/><strong>      &gt;&gt;&gt; count</strong><br/><strong>      Counter({'spam': 1, 'eggs': 1, 'bacon': 0})</strong><br/><strong>      &gt;&gt;&gt; del count["bacon"] # del must be used to actually remove "bacon"</strong><br/><strong>      &gt;&gt;&gt; count</strong><br/><strong>      Counter({'spam': 1, 'eggs': 1})</strong></pre>
<ol start="4">
<li>This is how to iterate over the <kbd>Counter</kbd> elements:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; count.elements()  # iterators create an object in memory</strong><br/><strong>      &lt;itertools.chain object at 0x7f210f769a90&gt;</strong><br/><strong>      &gt;&gt;&gt; sorted(count.elements())  <br/>      # use another function to actually print the iterated values</strong><br/><strong>      ['eggs', 'spam']</strong></pre>
<ol start="5">
<li>This is how to retrieve the most common elements in a <kbd>Counter</kbd> object:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; c = Counter('gallahad')</strong><br/><strong>      &gt;&gt;&gt; c.most_common()  # return all values</strong><br/><strong>      [('a', 3), ('l', 2), ('g', 1), ('h', 1), ('d', 1)]</strong><br/><strong>      &gt;&gt;&gt; c.most_common(3)  # return top three</strong><br/><strong>      [('a', 3), ('l', 2), ('g', 1)]</strong></pre>
<ol start="6">
<li>This is how to subtract values from elements:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; c = Counter(a=4, b=2, c=0, d=-2)</strong><br/><strong>      &gt;&gt;&gt; d = Counter(a=1, b=2, c=3, d=4)</strong><br/><strong>      &gt;&gt;&gt; c.subtract(d)</strong><br/><strong>      &gt;&gt;&gt; c</strong><br/><strong>      Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6})</strong></pre>
<ol start="7">
<li>As noted in the Python documentation (<a href="https://docs.python.org/3/library/collections.html#collections.Counter">https://docs.python.org/3/library/collections.html#collections.Counter</a>), there are a number of common operations when working with Counters, that are listed below. Some may be obvious, as Counters are a type of dictionary; others are unique to Counters due to their number-centric behavior:</li>
</ol>
<pre>        sum(c.values()) # total of all counts<br/>        c.clear() # reset all counts<br/>        list(c) # list unique elements<br/>        set(c) # convert to a set<br/>        dict(c) # convert to a regular dictionary<br/>        c.items() # convert to a list of (elem, cnt) pairs<br/>        Counter(dict(list_of_pairs)) <br/>        # convert from a list of (elem, cnt) pairs<br/>        c.most_common()[:-n-1:-1] # n least common elements<br/>        +c # remove zero and negative counts</pre>
<ol start="8">
<li>Because Counters are unique dictionaries, there are some math operations available to Counters to allow the combining of <kbd>Counter</kbd> objects into multisets (Counters that have counts greater than zero). Some of these are basic arithmetic, while others are similar to what <em>sets</em> has available.</li>
</ol>
<p style="padding-left: 60px">Addition and subtraction add/subtract the elements of different <kbd>Counter</kbd> objects. Intersection and union return the minimum and maximum elements from their <kbd>Counter</kbd> objects. While signed integers are used as input, any values that would have an output value of zero or less are ignored and not returned. If negative values or zero are used as inputs, only outputs with positive values are returned:</p>
<div class="float float-listings">
<pre><strong>      &gt;&gt;&gt; c = Counter(a=3, b=1)
      &gt;&gt;&gt; d = Counter(a=1, b=2)
      &gt;&gt;&gt; c + d           #  add two counters  together:  c[x] + d[x]
      Counter({'a': 4, 'b': 3})
      &gt;&gt;&gt; c - d           #  subtract (keeping only positive counts)
      Counter({'a': 2})
      &gt;&gt;&gt; c &amp; d           #  intersection:  min(c[x], d[x]) 
      Counter({'a': 1, 'b': 1})
      &gt;&gt;&gt; c | d           #  union:  max(c[x], d[x])
      Counter({'a': 3, 'b': 2})</strong></pre>
</div>
<ol start="9">
<li>As noted in step 7 earlier, unary shortcuts are available for adding an empty <kbd>Counter</kbd> or subtracting from an empty <kbd>Counter</kbd>:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; c = Counter(a=2, b=-4)</strong><br/><strong>      &gt;&gt;&gt; +c # removes negative and zero values</strong><br/><strong>      Counter({'a': 2})</strong><br/><strong>      &gt;&gt;&gt; -c # inverts signs; negative values are ignored</strong><br/><strong>      Counter({'b': 4})</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>As evident from zero and negative numbers not being returned, Counters are designed for use with positive integers, primarily in terms of maintaining running counts. However, this doesn't mean that negative values or other types cannot be used.</p>
<p>As a subclass of the dictionary class, Counters actually do not have any restrictions on keys or values. While the values are supposed to be used to represent increasing or decreasing counts, any Python object can be stored within a value field. For in-place operations, such as incrementing a value, the value type only needs to support addition and subtraction. As such, fractions, decimals, and float types can be used instead of integers and negative values are supported. This also applies to <kbd>update()</kbd> and <kbd>subtract()</kbd> methods; negative and zero values can be used as inputs or outputs.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing OrderedDict</h1>
                </header>
            
            <article>
                
<p>Like <kbd>Counter</kbd>, the <kbd>OrderedDict</kbd> is a dictionary subclass the doesn't randomize the order of dictionary items. As items are added to the <kbd>OrderedDict</kbd>, it remembers the order that the keys were inserted and maintains that order. Even if a new entry overwrites an existing key, the position within the dictionary doesn't change. However, if an entry is deleted, re-inserting it will place it at the end of the dictionary.</p>
<p><kbd>OrderedDict</kbd>, being a subclasses of <kbd>dict</kbd>, inherit all the methods available to dictionaries. There are also three special methods available to <kbd>OrderedDict</kbd>:</p>
<ul>
<li>
<p><kbd>popitem(last=True)</kbd>: It returns and removes the key:value pair at the end of the dictionary. If <kbd>last</kbd> is not provided or manually set to <kbd>True</kbd>, then the popped value is <strong>LIFO</strong> (<strong>last in, first out</strong>). If <kbd>last</kbd> is set to <kbd>False</kbd>, then the popped value is FIFO.</p>
</li>
<li>
<p><kbd>move_to_end(key, last=True)</kbd>: It moves the provided key to the end of the dictionary. If <kbd>last</kbd> is set to <kbd>True</kbd>, then the key moves to the right. If <kbd>last</kbd> is set to <kbd>False</kbd>, the key is sent to the front. If the key does not exist, an error is generated.</p>
</li>
<li>
<p><kbd>reversed()</kbd>: Since <kbd>OrderedDict</kbd> objects are in order, they can be manipulated like an iterable object; in this case, reverse iteration can be performed on an <kbd>OrderedDict</kbd>.</p>
</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>The following examples come from <a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict">https://docs.python.org/3/library/collections.html#collections.OrderedDict.</a>&#160;<kbd>ordereddict_use.py</kbd>, below, shows how to use <kbd>OrderedDict</kbd> to create a sorted dictionary:<a href="https://docs.python.org/3/library/collections.html#collections.OrderedDict"><br/></a></li>
</ol>
<pre><strong>      &gt;&gt;&gt; from collections import OrderedDict<br/>      &gt;&gt;&gt; d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2}  <br/>          # regular unsorted dictionary</strong><br/><strong>      &gt;&gt;&gt; OrderedDict(sorted(d.items(), key=lambda t: t[0]))  <br/>          # dictionary sorted by key</strong><br/><strong>      OrderedDict([('apple', 4), ('banana', 3), ('orange', 2), <br/>                   ('pear', 1)])</strong><br/><strong>      &gt;&gt;&gt; OrderedDict(sorted(d.items(), key=lambda t: t[1]))  <br/>          # dictionary sorted by value</strong><br/><strong>      OrderedDict([('pear', 1), ('orange', 2), ('banana', 3), <br/>                   ('apple', 4)])</strong><br/><strong>      &gt;&gt;&gt; OrderedDict(sorted(d.items(), key=lambda t: len(t[0])))  <br/>          # dictionary sorted by length of the key string</strong><br/><strong>      OrderedDict([('pear', 1), ('apple', 4), <br/>                   ('orange', 2), ('banana', 3)])</strong></pre>
<p style="padding-left: 90px">While <kbd>d</kbd> is a normal dictionary, sorting it in place and then passing it into <kbd>OrderedDict</kbd> creates a dictionary that is not only sorted, like a list, but maintains that ordered arrangement when entries are deleted. However, adding new keys puts them at the end of the dictionary, thus breaking the sort.</p>
<div class="packt_infobox">Note that the second argument to <kbd>OrderedDict</kbd> is a key that is generated by a lambda function.&#160;Lambda functions are simply anonymous functions: functions that don't require a complete <kbd>def</kbd> statement to be created. They allow a function to operate where a variable or argument could be used, as they return a value like a normal function when processed.</div>
<p style="padding-left: 90px" class="standard">In this case, in the first <kbd>OrderedDict</kbd>, the key is the value returned when the lambda function extracts the key from the dictionary. The second <kbd>OrderedDict</kbd> passes in the value of each dictionary item. The third <kbd>OrderedDict</kbd> uses a value equal to the length of each dictionary key.</p>
<ol start="2">
<li>The following example shows how to use <kbd>move_to_end()</kbd>:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; d = OrderedDict.fromkeys('abcde')</strong><br/><strong>      &gt;&gt;&gt; d.move_to_end('b')</strong><br/><strong>      &gt;&gt;&gt; ''.join(d.keys())</strong><br/><strong>      'acdeb'</strong><br/><strong>      &gt;&gt;&gt; d.move_to_end('b', last=False)</strong><br/><strong>      &gt;&gt;&gt; ''.join(d.keys())</strong><br/><strong>      'bacde'</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>First, an <kbd>OrderedDict</kbd> object is created, using a short string that is parsed to generate the keys for the dictionary.</li>
<li>The key <kbd>b</kbd> is moved to the end of the <kbd>OrderedDict</kbd>.</li>
<li>The <kbd>join()</kbd>&#160;method is used to convert the list of strings that are the keys to a single string, otherwise you would get the following:</li>
</ul>
</li>
</ul>
<pre><strong>                   &gt;&gt;&gt; d.keys()</strong><br/><strong>                   odict_keys(['a', 'c', 'd', 'e', 'b'])</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>The next move takes the key <em>b</em> and moves it to the front. The final value is joined and printed to verify that the move worked correctly.</li>
</ul>
</li>
</ul>
<ol start="3">
<li><kbd>ordereddict_stor_keys.py</kbd>, below, creates a class that retains the stored items in the order of keys that were added last:</li>
</ol>
<pre>       class LastUpdatedOrderedDict(OrderedDict):<br/>           'Store items in the order the keys were last added'<br/>           def __setitem__(self, key, value):<br/>               if key in self:<br/>                   del self[key]<br/>               OrderedDict.__setitem__(self, key, value)</pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>This class has a single method that sets the key:value pair in the dictionary. The method is actually recursive; the act of calling itself is what allows the <em>memory</em> of remembering the order the keys were last inserted.</li>
<li>If the key argument already exists, the original entry is deleted and the insertion point is moved to the end of the dictionary.</li>
</ul>
</li>
</ul>
<ol start="4">
<li><kbd>ordereddict_counter.py</kbd>, below, demonstrates using <kbd>OrderedDict</kbd> with <kbd>Counter</kbd> so the <kbd>Counter</kbd> can remember the order the elements are first encountered:</li>
</ol>
<pre>        class OrderedCounter(Counter, OrderedDict):<br/>            'Counter that remembers the order elements are first <br/>             encountered'<br/><br/>            def __repr__(self):<br/>                return '%s(%r)' % (self.__class__.__name__, <br/>                                   OrderedDict(self))<br/><br/>            def __reduce__(self):<br/>                return self.__class__, (OrderedDict(self),)</pre>
<ol start="5">
<li style="list-style-type: none">
<ul>
<li>This class is somewhat unique as it inherits from two parent classes. Some people on the internet frown upon multiple inheritance because it can make code management difficult. Personally, this author considers whether the project really needs multiple inheritance or whether it could be accomplished with something else, such a decorator. This is not to say that multiple inheritance doesn't have its place, just that there should be a good reason for it.</li>
</ul>
</li>
</ol>
<p style="padding-left: 120px">In this case, since we are making a unique class that combines the features of <kbd>Counter</kbd> and <kbd>OrderedDict</kbd>, there really isn't any other way to generate the solution without inheriting from those classes.</p>
<ol start="5">
<li style="list-style-type: none">
<ul>
<li>Two methods are defined in this class. Both methods use <em>name mangling</em> (double underscores) to create <kbd>private</kbd> instance methods without clashing with other methods of the same name. Name mangling essentially converts the method name to <kbd>classname__methodname</kbd>, so the underscored method is only associated with a particular class.</li>
<li><kbd>__repr__</kbd> generates a string representation of the class; otherwise, when attempting to print the class directly, all that would be shown would be the memory address of the class object. The string that is returned in this method is just the class name and the dictionary object.</li>
<li>The <kbd>__reduce__</kbd> method performs two things.&#160;<a href="https://docs.python.org/3.6/library/pickle.html#object">https://docs.python.org/3.6/library/pickle.html#object</a>. <kbd>__reduce__</kbd> indicates that the method is used by <kbd>pickle</kbd> to create a tuple of a callable object (in this instance, the class itself) and a tuple of arguments for the callable object, that is, the dictionary. In addition, the <kbd>copy</kbd> protocol implements <kbd>__reduce__</kbd> to ensure copying objects works correctly.</li>
</ul>
</li>
<li>As mentioned in the <em>pickle</em> documentation, using <kbd>__reduce__</kbd> directly in a class can lead to errors and higher-level interfaces should be used. <kbd>ordereddict_reduce.py</kbd>, below, is an example of when using it can help, as it actually does play a part in copying <kbd>OrderedCounter</kbd> objects:</li>
</ol>
<pre style="padding-left: 30px" class="listings"><strong>      &gt;&gt;&gt; class OrderedCounter(Counter, OrderedDict): 
      ...      'Counter that remembers the order elements are first seen' 
      ...      def __repr__(self): 
      ...          return '%s(%r)' % (self.__class__.__name__, 
      ...                             OrderedDict(self)) 
      ...      def __reduce__(self): 
      ...          return self.__class__, (OrderedDict(self),) 
      ... 
      &gt;&gt;&gt; oc = OrderedCounter('abracadabra') 
      &gt;&gt;&gt; import copy 
      &gt;&gt;&gt; copy.copy(oc) 
      OrderedCounter(OrderedDict([('a', 5), ('b', 2), ('r', 2), ('c', 1), ('d', 1)]))</strong> </pre>
<p style="padding-left: 30px">Now, take away the&#160;<kbd>__reduce__</kbd> method:</p>
<pre style="padding-left: 30px" class="listings"><strong>     &gt;&gt;&gt; del OrderedCounter.__reduce__ 
     &gt;&gt;&gt; copy.copy(oc) 
     OrderedCounter(OrderedDict([('b', 2), ('a', 5), ('c', 1), ('r', 2), ('d', 1)]))</strong> </pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing defaultdict</h1>
                </header>
            
            <article>
                
<p>Another dictionary subclass, <kbd>defaultdict</kbd> calls a factory function to provide missing values; basically, it creates any items that you try to access, but only if they don't currently exist. This way, you don't get <kbd>KeyError</kbd> when trying to access a non-existent key.</p>
<p>All the standard dictionary methods are available, as well as the following:</p>
<ul class="itemize">
<li>
<p><kbd>__missing__(key)</kbd>: This method is used by the <kbd>dict</kbd> class <kbd>__getitem__()</kbd> method when the requested key is not found. Whatever key it returns (or an exception if no key is present) is passed to <kbd>__getitem__()</kbd>, which processes it accordingly.</p>
<p>Assuming the <kbd>default_factory</kbd> is not <kbd>None</kbd>, this method calls the factory to receive a default value for <kbd>key</kbd>, which is then placed in the dictionary as the <kbd>key</kbd>, and then returns back to the caller. If the factory value is <kbd>None</kbd>, then an exception is thrown with the <kbd>key</kbd> as the argument. If the <kbd>default_factory</kbd> raises an exception on its own, then the exception is passed along unaltered.</p>
<p>The <kbd>__missing__()</kbd> method is only used with <kbd>__getitem__()</kbd>; all other dictionary methods are ignored. Thus, the <kbd>default_factory</kbd> can only be accessed via this method.</p>
</li>
</ul>
<ul class="itemize">
<li>
<p><kbd>default_factory</kbd>: While not a method, it is used as an attribute for the <kbd>__missing__()</kbd> method, it is initialized by the first argument to the dictionary constructor, if available; defaults to <kbd>None</kbd> if no argument is provided.</p>
</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The following examples are taken from the Python documentation at <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict">https://docs.python.org/3/library/collections.html#collections.defaultdict</a>:</p>
<ol>
<li>A list is a common source for&#160;<kbd>default_factory</kbd>, as it makes it easy to group a sequence of key:value pairs into a dictionary of lists, as follows:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; from collections import defaultdict<br/>      &gt;&gt;&gt; s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]<br/></strong><strong>      &gt;&gt;&gt; d = defaultdict(list)</strong><strong>      <br/>      &gt;&gt;&gt; for k, v in s:<br/></strong><strong>      ...     d[k].append(v)<br/></strong><strong>      ...<br/></strong><strong>      &gt;&gt;&gt; sorted(d.items())<br/></strong><strong>      [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>First, a list of tuples is created. The tuples match a string with an integer.</li>
<li>A <kbd>defaultdict</kbd> is created using an empty list as the factory argument.</li>
<li>The list of tuples is iterated through, assigning the tuple key:value pairs to the <kbd>defaultdict</kbd> list's factory.</li>
<li>When the sorted dictionary is printed, it shows that the <kbd>defaultdict</kbd> created a new key for each new item from the tuple's list. If a key was already present in the dictionary, then the tuple's value was added to the key's value as a new item in a list via the <kbd>append</kbd> <span>function. Basically, the tuple's list was shorted to a key:value pairing that identified all the values related to a particular key.</span></li>
</ul>
</li>
</ul>
<ol start="2">
<li>Another way to perform the previous operation is to use the <kbd>dict</kbd> class <kbd>setdefault()</kbd> method. However, <kbd>setdefault()</kbd> can be slower and more complex than using a <kbd>defaultdict</kbd>:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; d = {}<br/></strong><strong>      &gt;&gt;&gt; for k, v in s:<br/></strong><strong>      ...     d.setdefault(k, []).append(v)<br/></strong><strong>      ...<br/></strong><strong>      &gt;&gt;&gt; sorted(d.items())<br/></strong><strong>      [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>In this case, an empty dictionary is created (the same tuple's list is used in this example).</li>
<li>Next, the tuples are split into keys and values. The <kbd>setdefault()</kbd> <span>method is used to assign a key with a blank value to the dictionary, then the value is added to the key's empty list (or appended to an existing value).</span></li>
<li>While the processing time for <kbd>setdefault()</kbd> <span>may be very close to</span> <kbd>defaultdict</kbd> <span>for a small script such as this, it can add up for larger projects. In addition, using</span> <kbd>setdefault()</kbd> <span>doesn't look as intuitive as the</span> <kbd>defaultdict</kbd> <span>code.</span></li>
</ul>
</li>
</ul>
<ol start="3">
<li>If the factory is set to an integer, the <kbd>defaultdict</kbd> can be used for counting:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; s = 'mississippi'</strong><br/><strong>      &gt;&gt;&gt; d = defaultdict(int)</strong><br/><strong>      &gt;&gt;&gt; for k in s:</strong><br/><strong>      ...     d[k] += 1</strong><br/><strong>      ...</strong><br/><strong>      &gt;&gt;&gt; sorted(d.items())</strong><br/><strong>      [('i', 4), ('m', 1), ('p', 2), ('s', 4)]</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>In this example, a string is set, followed by a <kbd>defaultdict</kbd> using an integer as the <kbd>default_factory</kbd>.</li>
<li>Next, for each character in the string, an incrementer is created to count each character as the string is iterated through. As each character is looked at, it is checked to see whether it already exists in the dictionary. If not, the factory calls the <kbd>int()</kbd> <span>function to generate a default count equal to zero. Then, as the rest of the string is walked through, new values receive a count of zero while</span> existing<span>&#160;values are incremented.</span></li>
<li>The final dictionary is sorted and the contents displayed. In this case, the quantity of each character in the initial string is printed to the screen.</li>
</ul>
</li>
</ul>
<ol start="4">
<li>An alternative to the previous example is to use lambda functions. Because <kbd>int()</kbd> always returns zero, generating an alternate starting value (which could be type, not just an integer) can be accomplished with a (functionally) empty lambda:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; def constant_factory(value):<br/></strong><strong>      ...     return lambda: value<br/></strong><strong>      &gt;&gt;&gt; d = defaultdict(constant_factory('&lt;missing&gt;'))<br/></strong><strong>      &gt;&gt;&gt; d.update(name='John', action='ran')<br/></strong><strong>      &gt;&gt;&gt; '%(name)s %(action)s to %(object)s' % d<br/></strong><strong>      'John ran to &lt;missing&gt;'</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>In this example, the <kbd>constant_factory</kbd> function accepts a value and then returns that value to the caller.</li>
<li>The <kbd>defaultdict</kbd> <span>uses</span> <kbd>constant_factory</kbd> <span><span>to generate whatever value is passed in; in this case, it is a string.</span></span></li>
<li>The <kbd>defaultdict</kbd> is updated to pass in key arguments.</li>
<li>The values mapped to the dictionary keys are processed. Since an object is missing from the key arguments that were passed in, the lambda function provides it via the string that was passed to it.</li>
</ul>
</li>
</ul>
<ol start="5">
<li>If the <kbd>default_factory</kbd> is giving the <kbd>set</kbd> type as an argument, the <kbd>defaultdict</kbd> can be used to create a dictionary of sets:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; s = [("apple", 1), ("banana", 2), ("carrot", 3), ("banana", 4), ("carrot", 1), ("banana", 4)]<br/></strong>      <strong>&gt;&gt;&gt; d = defaultdict(set)<br/></strong>      <strong>&gt;&gt;&gt; for k, v in s:<br/></strong>      <strong>...     d[k].add(v)<br/></strong>      <strong>...<br/></strong>      <strong>&gt;&gt;&gt; sorted(d.items())<br/></strong>      <strong>[('apple', {1}), ('banana', {2, 4}), ('carrot', {1, 3})]</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>Here, a list of tuples is created. The <kbd>defaultdict</kbd> is provided with an empty <kbd>set</kbd> as the factory argument.</li>
<li>The tuple's list is iterated through, generating the keys and values for the dictionary from the tuples. The values are added to the sets associated with the keys.</li>
<li>Printing the dictionary items shows how the various, duplicate tuples in the list have been combined into two dictionary mappings.</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing UserDict</h1>
                </header>
            
            <article>
                
<p>UserDict is a wrapper for dictionaries that makes it easier to subclass the <kbd>dict</kbd> class. It has been largely replaced by the ability to subclass <kbd>dict</kbd> directly, but it does make it easier to work with as it allows the underlying dictionary to be accessible as an attribute. Its primary use is for backwards-compatibility, that is, versions older then Python 2.2, so if you don't need the compatibility, it is generally better to just subclass <kbd>dict</kbd><em>.</em></p>
<p>The only special thing the <kbd>UserDict</kbd> has beyond the normal dictionary operations is a single attribute:</p>
<ul>
<li>
<p><kbd>data</kbd>: A real dictionary to hold the contents of the <kbd>UserDict</kbd> class</p>
</li>
</ul>
<p>When a <kbd>UserDict</kbd> is created, it accepts an optional argument of the initial data it is to hold; this initial data is accessible by the <kbd>data</kbd> attribute.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li><kbd>UserDict</kbd> is very simple to use. Create an instance of a <kbd>UserDict</kbd> and provide a mapping to it:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; from collections import UserDict</strong><br/><strong>      &gt;&gt;&gt; a = UserDict(a=1)</strong><br/><strong>      &gt;&gt;&gt; d = dict(d=3)  # regular dictionary for comparison</strong></pre>
<ol start="2">
<li>If you call the instance directly, it functions just like a normal dictionary, as expected:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img style="font-size: 1em;text-align: center;color: black;width:36.75em;height:8.75em;" src="images/146b2128-a9c5-48ad-8716-68f07a0ed4b4.png"/></div>
<ol start="3">
<li>If you use the <kbd>data</kbd> attribute, you get the same results with the <kbd>UserDict</kbd> instance. However, because normal dictionaries don't support this attribute, you get an error, as follows:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; a.data</strong><br/><strong>      {'a': 1}</strong><br/><strong>      &gt;&gt;&gt; d.data</strong><br/><strong>      Traceback (most recent call last):</strong><br/><strong>          File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong><br/><strong>      AttributeError: 'dict' object has no attribute 'data'</strong></pre>
<ol start="4">
<li>To get to the items in the dictionary, you have to either iterate over them or call <kbd>items()</kbd>. While the <kbd>UserDict</kbd> instance supports the same methods, the view returned by <kbd>items()</kbd> is noticeably different:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; for k in d:</strong><br/><strong>      ...     print(k, d[k])</strong><br/><strong>      ... </strong><br/><strong>      d 3</strong><br/><strong>      &gt;&gt;&gt; d.items()</strong><br/><strong>      dict_items([('d', 3)])</strong><br/><strong>      &gt;&gt;&gt; for k in a:</strong><br/><strong>      ...     print(k, a[k])</strong><br/><strong>      ... </strong><br/><strong>      a 1</strong><br/><strong>      &gt;&gt;&gt; a.items()</strong><br/><strong>      ItemsView({'a': 1})</strong></pre>
<div class="standard packt_infobox">Notice that the dictionary object returns a tuple of key/values. The <kbd>UserDict</kbd> returns an actual dictionary object. Depending on what you are doing, this difference can be important, as is the ability to use the <kbd>data</kbd> attribute to access the dictionary.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing UserList</h1>
                </header>
            
            <article>
                
<p>This wrapper is similar to <kbd>UserDict</kbd>, except it applies to lists rather than dictionaries. Its main use is for creating a base class for list-like subclasses that allow for inheritance and method overriding or new methods. This allows for new functionality within lists.</p>
<p>Again, like <kbd>UserDict</kbd>, <kbd>UserList</kbd> has been largely superseded by the ability to subclass directly from <kbd>list</kbd>. But, again, it may be easier to use <kbd>UserList</kbd> than a <kbd>list</kbd> subclass. While <kbd>UserList</kbd> has the methods and capabilities of normal lists, it adds the <kbd>data</kbd> attribute to hold the underlying <kbd>list</kbd> object contents.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li><kbd>userlist_import.py</kbd> shows how to use <kbd>UserList</kbd> as a superclass for a new list-like object. In this case, we are going to create a class that allows a list to be added by simply assigning values to it, rather than having to call the <kbd>append()</kbd> function:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="images/ed9c0077-7bed-4eb7-9b0f-a1462b42064d.png" style="width:39.92em;height:43.00em;"/></div>
<ul>
<li style="list-style-type: none">
<ul>
<li>First, in <em>line 11</em>, <kbd>UserList</kbd> must be imported from the <em>collections</em> module.</li>
<li>Next, the <kbd>ExtendList</kbd> class is created in <em>line 12</em> as a subclass of <kbd>UserList</kbd>. This provides list functionality to any <kbd>ExtendList</kbd> instance.&#160;A setter method is created, accepting an integer and a value. If the integer provided equals the length of the list, then the value argument is appended to the list. Otherwise, the value at index <kbd>i</kbd> is replaced with a new value.</li>
<li>An instance of the class is created in <em>line 13</em> and populated with a range of numbers in <em>line 14</em>.</li>
<li>Printing the instance (<em>line 15</em>) shows that the range of numbers was accepted via assignment, rather than using <kbd>append()</kbd>.</li>
<li>Manually extending the list (<em>line 16</em>) is allowed by simply assigning a value to the given index position.</li>
<li>Replacing a value of a given index position is available as well, as shown in <em>line 18</em>.</li>
<li>Finally, <em>line 20</em> shows that, like a normal list, if attempting to access an index value outside the existing range of the list, an error is received.</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>When subclassing <kbd>UserList</kbd>, the subclass is expected to provide a constructor that can be called with either no arguments or one argument. If a list operation is expected to return a new sequence, it attempts to create an instance of the actual implementation class. Thus, it expects the constructor to provide the ability to be called with a single parameter, that is, the sequence object that serves as the source of data.</p>
<p>It is possible to create a class that doesn't follow this requirement, but all the special methods of the derived class must be overridden, as functionality using the default methods cannot be guaranteed.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing UserString</h1>
                </header>
            
            <article>
                
<p>Just like <kbd>UserDict</kbd> and <kbd>UserList</kbd>, <kbd>UserString</kbd> is a string wrapper that allows easier subclassing of strings due to providing the underlying string as an attribute. The preferred way to do this is to subclass <kbd>string</kbd> directly; this class is provided mainly due to backwards-compatibility or simple cases where subclassing <kbd>string</kbd> is overkill for functionality.</p>
<p>While all string methods are available, such as&#160;<kbd>UserDict</kbd> and <kbd>UserList</kbd>, <kbd>UserString</kbd> adds the <kbd>data</kbd> attribute for easy access to the underlying string object. The contents of <kbd>UserString</kbd> are initially set to a copy of some type of sequence; the sequence can be bytes, a string, another <kbd>UserString</kbd> or subclass, or any other sequence object that can be converted to a string.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li><kbd>userstring_import.py</kbd> is simple in that it shows how to create a method to append a sequence to a string, much like adding more items to a list:</li>
</ol>
<pre style="color: black" class="standard"><strong>      &gt;&gt;&gt; from collections import UserString</strong><br/><strong>      &gt;&gt;&gt; class AppendString(UserString):</strong><br/><strong>      ...     def append(self, s):</strong><br/><strong>      ...         self.data = self.data + s</strong><br/><strong>      ... </strong><br/><strong>      &gt;&gt;&gt; s = AppendString("abracadabra")</strong><br/><strong>      &gt;&gt;&gt; s.append("spam and bananas")</strong><br/><strong>      &gt;&gt;&gt; print(s)</strong><br/><strong>      abracadabraspam and bananas</strong><br/><strong>      &gt;&gt;&gt; l = "banana" <br/>      # show that regular strings don't have an append method</strong><br/><strong>      &gt;&gt;&gt; l.append("apple")</strong><br/><strong>      Traceback (most recent call last):</strong><br/><strong>          File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong><br/><strong>      AttributeError: 'str' object has no attribute 'append'</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>The first step, as always, is to import the <kbd>UserString</kbd> class from the <kbd>collections</kbd> module.</li>
<li>Next, a simple subclass of <kbd>AppendString</kbd> is created. The only method for it is <kbd>append()</kbd><span><span>, which takes a single sequence as its argument and returns the instance data concatenated with whatever sequence has been provided.</span></span></li>
<li>An instance of the <kbd>AppendString</kbd> class is created, with a simple string passed in as its argument.</li>
<li>The class's method is tested by adding another string, and the final contents of the instance is printed. The printed string shows that the new string has been added to the end of the original argument.</li>
<li>Next, we demonstrate that regular strings don't have the ability to concatenate strings using an <kbd>append()</kbd> <span>method. A string is created and then a separate string is attempted to be appended to it. As the</span> <kbd>str</kbd> <span>class doesn't have an</span> <kbd>append()</kbd> <span>method, an error is generated.</span></li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Improving Python collections</h1>
                </header>
            
            <article>
                
<p>This section is designed to showcase different ways to improve your coding methodology by using the various Python collections available to you. Not every collections datatype is represented, but some interesting use cases are explored for certain containers.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The following examples are separated by the particular collection they utilize. iPython will be used to interactively create these examples.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Default dictionaries</h1>
                </header>
            
            <article>
                
<ol>
<li>For this example (<kbd>book_catalog.py</kbd>), we will create a simplified ordering scheme for book categories; the <kbd>default_factory</kbd> will be an anonymous function that returns a string:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="images/a1277e87-dbec-41c1-90d1-a16a8468525d.png" style="width:40.33em;height:37.33em;"/></div>
<ol>
<li style="list-style-type: none">
<ul>
<li>The <em>line 1</em> simply imports the <kbd>collections</kbd> module, allowing access to the <kbd>defaultdict</kbd> class.</li>
<li>The <em>line 2</em> creates an instance of <kbd>defaultdict</kbd>. The argument for the factory is a simple string indicating that the selected item doesn't exist.</li>
<li>The <em>lines 3</em> – <em>line 6</em> create items for the dictionary.</li>
<li>The <em>line 7</em> prints the default representation of the dictionary.</li>
<li>The <em>line 8</em> is a more human-readable representation of the dictionary. This just makes it easier to see the key:value mappings.</li>
<li>The <em>line 9</em> calls for a non-existent entry. Since it hasn't been added to the dictionary yet, a response is provided indicating that it is not available.</li>
<li>The <em>line 10</em> is another printing of the mappings in the dictionary. However, in this instance, it shows that the key <kbd>z</kbd> has been added to the dictionary, with the default value ascribed to it.</li>
</ul>
</li>
<li>A common programming requirement is to group list elements based on particular criteria. One approach is to create a dictionary that is indexed by the criteria. For example, a class is created that gets a person's age and returns a string representation (<kbd>class_adult.py</kbd>):</li>
</ol>
<pre><strong>       In [1]: class Adult():</strong><br/><strong>       ...:     def __init__(self, age):</strong><br/><strong>       ...:         self.age = age</strong><br/><strong>       ...:     def __repr__(self):</strong><br/><strong>       ...:         return "{}".format(self.age)</strong><br/><strong>       ...:</strong> </pre>
<p style="padding-left: 60px" class="standard">This creates the class <kbd>Adult</kbd>. Two methods are defined; <kbd>__init__()</kbd> simply populates the <kbd>age</kbd> variable when an instance is created. The <kbd>__repr__()</kbd> allows us to print a string representation of the value contained in the <kbd>age</kbd> variable without having the instance print its memory address instead.</p>
<ol start="3">
<li>To populate instances for this class, we will assign ages manually in <kbd>adult_list_comp.py</kbd>, as we want to see how to group the same values together:</li>
</ol>
<pre><strong>      In [2]: people = [Adult(age) for age in (40, 18, 40, 42, 18, 25, 23, 80, 67, 18)]</strong> </pre>
<p style="padding-left: 60px" class="standard">In this case, a list comprehension is used to easily and quickly create all the instances of the <kbd>Adult</kbd> class, rather than setting up a <kbd>for</kbd> loop.</p>
<ol start="4">
<li>One way to group these individuals by age is by iterating through the instances, populating a dictionary, and then grouping them via lists, as shown below in <kbd>age_groups.py</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="images/56ae5955-c2c0-4dd7-9c64-6667efb3adbf.png" style="width:39.08em;height:36.17em;"/></div>
<ul>
<li style="list-style-type: none">
<ul>
<li>In <em>line 3</em> creates an empty dictionary.</li>
<li>In <em>line 4</em> is a <kbd>for</kbd> loop that iterates through all the instances of <kbd>Adult</kbd> in the <kbd>persons</kbd> list. For each instance, the variable <kbd>age</kbd> is set to the instance's <kbd>age</kbd> value. If that value is already present in the dictionary, then a new item is appended to the list within the dictionary. If the age value isn't already in the dictionary, then a new entry is created.</li>
<li>In <em>line 5</em> shows the different age groups within the dictionary. In this case, out of ten entries, only seven groups have been created.</li>
<li>In <em>line 6</em> prints all the key:value pairs in the dictionary; this shows us greater detail of how the dictionary is generated. Looking closely, we can see that each unique age in the <kbd>persons</kbd> list has its own key. The values associated with each key are all individual values in <kbd>persons</kbd> that match the key. In other words, all duplicate values are placed in the same group.</li>
<li>In <em>line 7</em> is an alternative way to show the dictionary items. This makes it easier to see how the duplicate entries are actually tied to their respective keys.</li>
</ul>
</li>
</ul>
<ol start="5">
<li>An alternative way to do this, and a much cleaner way, is to use a<span>&#160;</span><kbd>defaultdict</kbd>, as follows in <kbd>defaultdict_age_groups.py</kbd>:</li>
</ol>
<pre><strong>      In [8]: from collections import defaultdict</strong><br/><strong>      In [9]: age_groups = defaultdict(list)</strong><br/><strong>      In [10]: for person in people:</strong><br/><strong>      ...:     age_groups[person.age].append(person)</strong><br/><strong>      ...: </strong><br/><strong>      In [11]: for k in age_groups:</strong><br/><strong>      ...:     print(k, age_groups[k])</strong><br/><strong>      ...: </strong><br/><strong>      40 [40, 40]</strong><br/><strong>      18 [18, 18, 18]</strong><br/><strong>      42 [42]</strong><br/><strong>      25 [25]</strong><br/><strong>      23 [23]</strong><br/><strong>      80 [80]</strong><br/><strong>      67 [67]</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>The <em>line 8</em> imports <kbd>defaultdict</kbd> from the <kbd>collections</kbd> module.</li>
<li>The <em>line 9</em> creates a <kbd>defaultdict</kbd> instance that accepts an empty list that will create values for the dictionary if a key is missing. Thus, each new key will have a list automatically generated for it.</li>
<li>The <em>line 10</em> is a simplified version of line 4, eliminating a lot of the busy work code.</li>
<li>The <em>line 11</em> is another printing of the dictionary, showing that the same results are achieved using a <kbd>defaultdict</kbd> rather than the more brute-force approach previously.</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Named tuples</h1>
                </header>
            
            <article>
                
<ol>
<li><kbd>namedtuples_sales.py</kbd>, below, will create a restaurant receipt, indicating the store ID, sales date, amount, and number of guests:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="images/b148cd53-e90a-4063-ac7b-559d336720f8.png" style="width:39.42em;height:24.67em;"/></div>
<ul>
<li style="list-style-type: none">
<ul>
<li>The <em>line 9</em> shows the creation of the named tuple. The first argument to the named tuple is the name of the tuple subclass. The remaining arguments are the fields for the tuple.</li>
<li>The <em>lines 10</em> and 11 create two different restaurants, showing receipts for the same day.</li>
<li>The <em>line 12</em> and <em>line 13</em> show how to access the individual fields within the different tuples using the field names rather than the indexes.</li>
<li>The <em>line 14</em> shows that these restaurant instances are, indeed, actual tuples. They can be iterated over like regular sequences, using an integer to identify each field's index.</li>
</ul>
</li>
</ul>
<ol start="2">
<li>One usual way to create named tuples without having to create each one individually is to simply convert an iterable object to a<span>&#160;</span><kbd>namedtuple</kbd><span>&#160;</span>using<span>&#160;</span><kbd>_make</kbd>. The input iterable can be a list, tuple, or dictionary. In <kbd>receipts_make.py</kbd>, we take a list, with values that meet the requirements for the<span>&#160;</span><kbd>namedtuple</kbd><span>&#160;</span>fields, and convert it directly to a named tuple:</li>
</ol>
<pre><strong>      In [18]: my_list = [27, "11-13-2017", 84.98, 5]</strong><br/><strong>      In [19]: store27 = salesReceipt._make(my_list)</strong><br/><strong>      In [20]: print(store27)</strong><br/><strong>      salesReceipt(storeID=27, saleDate='11-13-2017', saleAmount=84.98, totalGuests=5)</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>The <em>line 18</em> creates the list used for the conversion.</li>
<li><span>The&#160;</span><em>line 19</em>&#160;uses the <kbd>_make</kbd> method to convert the list to a <kbd>namedtuple</kbd> object.</li>
<li><span>The&#160;</span><em>line<span>&#160;20</span></em> prints out the new <kbd>namedtuple</kbd> instance, showing that the data in the converted <kbd>namedtuple</kbd> is no different than making the <kbd>namedtuple</kbd> manually.</li>
</ul>
</li>
</ul>
<ol start="3">
<li>If you just want to see what the field names are in a named tuple object, you can use the<span>&#160;</span><kbd>_fields</kbd><span>&#160;</span>identifier:</li>
</ol>
<pre><strong>      In [21]: print(store15._fields)</strong><br/><strong>      ('storeID', 'saleDate', 'saleAmount', 'totalGuests')</strong></pre>
<ol start="4">
<li>The final example shows how named tuples can be used when working with CSV files, allowing data access via names rather than indexes. This way, the data is easier to work with, as there is meaning ascribed to each field, rather than trying to figure out which index value applies to the desired field.</li>
</ol>
<p style="color: black;padding-left: 60px" class="standard">Of course, you have to have a CSV file available to use this example. <kbd>sales_csv.py</kbd> shows that the structure is easy, as all you have to have are four entries per line, signifying the store ID, the sales date, the sales amount, and the total number of guests:</p>
<div style="color: black;font-size: 1em" class="float float-listings">
<pre><strong>      In [22]: from csv import reader
 
      In [23]: with open("sales_record.csv", "r") as input_file:
      ...:     csv_fields = reader(input_file)
      ...:     for field_list in csv_fields:
      ...:         store_record = salesReceipt._make(field_list)
      ...:         total_sales += float(store_record.saleAmount)
      ...:         

      In [24]: print("Total sales = ", total_sales)
      Total sales =  105.97</strong></pre>
</div>
<ul>
<li style="list-style-type: none">
<ul>
<li>In <em>line 22</em>, we import the <kbd>reader</kbd> method from the <kbd>csv</kbd> module.</li>
<li>The <em>line 23</em> shows one way to import the CSV file. The traditional <em>with open...</em> <span>methodology is used to ensure that the file is automatically closed when it is no longer being used.</span></li>
</ul>
</li>
</ul>
<p style="padding-left: 150px">Each field in the CSV file is read into a variable, which is then iterated over. The CSV fields are converted to a named tuple via the <kbd>_make</kbd> method.</p>
<p style="padding-left: 150px">Finally, the total amount of sales for all the entries in the CSV file are summed and put into a variable. Note that the values are cast to a <kbd>float</kbd> prior to being summed, to ensure no errors are generated due to mismatching types.</p>
<ul>
<li style="list-style-type: none">
<ul>
<li><span>In</span> <em>line 24</em><span>, the total sales are printed out, showing that the records in the CSV file were properly retrieved and converted.</span></li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Ordered dictionaries</h1>
                </header>
            
            <article>
                
<ol>
<li>Ordered dictionaries are an ideal tool for ranking problems, such as student grades or competitions. The following example looks at student grades, where the dictionary contains a key equal to the student's name and its value is a test grade. The problem is to sort the students by test score, as shown in <kbd>student_grades.py</kbd>:</li>
</ol>
<pre><strong>        In [30]: student_grades = {}</strong><br/><strong>        In [31]: student_grades["Jeffrey"] = 98</strong><br/><strong>        In [32]: student_grades["Sarah"] = 85</strong><br/><strong>        In [33]: student_grades["Kim"] = 92</strong><br/><strong>        In [34]: student_grades["Carl"] = 87</strong><br/><strong>        In [35]: student_grades["Mindy"] = 98</strong><br/><strong>        In [36]: student_grades</strong><br/><strong>        Out[36]: {'Carl': 87, 'Jeffrey': 98, 'Kim': 92, 'Mindy': 98, 'Sarah': 85}</strong><br/><strong>        In [37]: sorted(student_grades.items(), key=lambda t: t[0])</strong><br/><strong>        Out[37]: [('Carl', 87), ('Jeffrey', 98), ('Kim', 92), ('Mindy', 98), ('Sarah', 85)]</strong><br/><strong>        In [38]: sorted(student_grades.items(), key = lambda t: t[1])</strong><br/><strong>        Out[38]: [('Sarah', 85), ('Carl', 87), ('Kim', 92), ('Jeffrey', 98), ('Mindy', 98)]</strong><br/><strong>        In [39]: sorted(student_grades.items(), key = lambda t: -t[1])</strong><br/><strong>        Out[39]: [('Jeffrey', 98), ('Mindy', 98), ('Kim', 92), ('Carl', 87), ('Sarah', 85)]</strong><br/><strong>        In [40]: rankings = collections.OrderedDict(sorted(student_grades.items(), key = lambda t: -t[1]))</strong><br/><strong>        In [41]: rankings</strong><br/><strong>        Out[41]: </strong><br/><strong>            OrderedDict([('Jeffrey', 98),</strong><br/><strong>                         ('Mindy', 98),</strong><br/><strong>                         ('Kim', 92),</strong><br/><strong>                         ('Carl', 87),</strong><br/><strong>                         ('Sarah', 85)])</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>We create a blank dictionary in <em>line 30</em> and then populate it with the items in <em>lines 31</em> – <em>line 35</em>.</li>
<li>The <em>line 36</em> is just a print out of the normal, randomized dictionary item ordering.</li>
<li>In <em>line 37</em>, a traditional sort is performed, that is, sorting the entries based on key. Since the keys are strings, they are sorted alphabetically.</li>
<li>An alternate sorting is performed in <em>line 38</em>: sort by value. In this case, the sorting is from lowest value to highest value.</li>
<li>To get a sorting of grades from highest to lowest, we use an inverted sorting-by-value in <em>line 39</em>.</li>
<li>In <em>line 40</em>, we take the inverted sorting from <em>line 39</em> and use it to populate an <kbd>OrderedDict</kbd>.</li>
<li>Printing out the <kbd>OrderedDict</kbd> instance in <em>line 41</em> shows that the dictionary has maintained the ordering of input values, rather than randomizing them, like in <em>line 36</em>.</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Looking at the collections – extended module</h1>
                </header>
            
            <article>
                
<p>If you search PyPI, you will find the <span class="packt_screen">collections-extended</span> module (<a href="https://pypi.python.org/pypi/collections-extended/1.0.0">https://pypi.python.org/pypi/collections-extended/1.0.0</a>). Collections-extended expands the number of collections types available.</p>
<p>The following classes are included:</p>
<ul>
<li><kbd>bag</kbd>:&#160;It is equivalent to a multiset, bags build upon the default <em>set</em> container by allowing multiple instances of the bag's elements.</li>
</ul>
<p style="padding-left: 60px">A <kbd>bag</kbd> (also called a multiset in other languages) generalizes the concept of a set so that it allows multiple instances of elements. For example, <em>{a, a, b}</em>, and <em>{a, b}</em> are different bags, but part of the same set. Only hashable elements can be used in a <kbd>bag</kbd>.&#160;An important point about bags is the multiplicity of elements. Multiplicity is the the number of instances of an element in a specific bag, that is, how many duplicate values exist in a bag.</p>
<ul class="itemize">
<li><kbd>setlist</kbd>: This creates an ordered, indexed collection with unique elements. <kbd>setlist</kbd> is used to<span>&#160;create an object that is similar to an</span> <em>ordered set</em><span>, except that its elements are accessible by index, not just a linked set. Two classes of</span> <kbd>setlist</kbd> <span>are provided:</span> <kbd>setlist</kbd> <span>and</span> <kbd>frozensetlist</kbd><span>.&#160;</span><span>Comparing two</span> <kbd>setlist</kbd> <span>object</span><span>&#160;won't work; while equality testing is fine, other comparisons (such as s1 &gt; s2) won't work as there is no way to specify whether to compare by order or by set comparison.</span></li>
<li><kbd>bijection</kbd>: It is a function that maps keys to unique values onto functions.&#160;<span>A <kbd>bijection</kbd> is a function between two sets, where each element in one set is paired to exactly one element in the other set and vice versa. All elements are paired and no elements are unpaired. An easy way to picture this assigned seating: each individual has a single seat, each seat has a person assigned, no person is assigned to more than one seat, and no seat has more than one person sitting in it.</span></li>
<li><kbd>RangeMap</kbd>: This maps ranges to values.&#160;<span>A <kbd>RangeMap</kbd> maps ranges to values; in other words, ranges become keys that are mapped to values. All keys must be hashable and comparable to other keys, but don't have to be the same type.&#160;</span><span>When creating a <kbd>RangeMap</kbd> instance, a mapping can be provided, or the instance can start out empty. Each item is assumed to be the start of a range and its associated value. The end of the range is the next largest key in the mapping, so if a range is left open-ended, it will automatically be closed if a larger range starting value is provided.</span></li>
</ul>
<p>In addition to the preceding classes, hashable versions of bags and setlists are also included.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Collections-extended is available for installation from PyPI using <kbd>pip</kbd>:</p>
<div class="float float-listings">
<pre><strong>pip install collections-extended</strong></pre>
</div>
<p>Normal usage is like other modules:</p>
<div class="float float-listings">
<pre><strong>from collections_extended import [bag, frozenbag, setlist, frozensetlist, bijection, RangeMap]</strong></pre>
</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will talk about each collection class separately in the following examples. These examples are from <a href="http://collections-extended.lenzm.net">http://collections-extended.lenzm.net.</a></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">setlist</h1>
                </header>
            
            <article>
                
<ol>
<li><kbd>ext_collections_setlist.py</kbd> demonstrates how to use <kbd>setlist</kbd><em>:</em></li>
</ol>
<pre><strong>      &gt;&gt;&gt; from collections_extended import setlist</strong><br/><strong>      &gt;&gt;&gt; import string</strong><br/><strong>      &gt;&gt;&gt; sl = setlist(string.ascii_lowercase)</strong><br/><strong>      &gt;&gt;&gt; sl</strong><br/><strong>      setlist(('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'))</strong><br/><strong>      &gt;&gt;&gt; sl[3]</strong><br/><strong>      'd'</strong><br/><strong>      &gt;&gt;&gt; sl[-1]</strong><br/><strong>      'z'</strong><br/><strong>      True</strong><br/><strong>      &gt;&gt;&gt; sl.index('m')  # so is finding the index of an element</strong><br/><strong>      12</strong><br/><strong>      &gt;&gt;&gt; sl.insert(1, 'd')  # inserting an element already in raises a ValueError</strong><br/><strong>      Traceback (most recent call last):</strong><br/><strong>      ...</strong><br/><strong>         raise ValueError</strong><br/><strong>      ValueError</strong><br/><strong>      &gt;&gt;&gt; sl.index('d')</strong><br/><strong>      3</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>First, <kbd>setlist</kbd> has to be imported. We also import the <kbd>string</kbd> class to provide access to its public module variables.</li>
<li>A <kbd>setlist</kbd> instance is created, using the <kbd>string</kbd> class <kbd>ascii_lowercase</kbd> variable, which provides a string of all ASCII characters in lowercase.</li>
<li>The instance is printed, just to demonstrate what it contains.</li>
<li>Several indexing operations are shown, demonstrating that <kbd>setlist</kbd> works like a list in terms of accessing items by index. Note that <em>reverse indexing</em> is available, that is, rather than accessing a variable via its index position, searching for a value returns its index position.</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">bags</h1>
                </header>
            
            <article>
                
<ol>
<li>Bags can be compared to sets, including other bags. Following, we see how bags are evaluated compared to sets:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; from collections_extended import bag</strong><br/><strong>      &gt;&gt;&gt; bag() == set()</strong><br/><strong>      True</strong><br/><strong>      &gt;&gt;&gt; bag('a') == set('a')</strong><br/><strong>      True</strong><br/><strong>      &gt;&gt;&gt; bag('ab') == set('a')</strong><br/><strong>      False</strong><br/><strong>      &gt;&gt;&gt; bag('a') == set('ab')</strong><br/><strong>      False</strong><br/><strong>      &gt;&gt;&gt; bag('aa') == set('a')</strong><br/><strong>      False</strong><br/><strong>      &gt;&gt;&gt; bag('aa') == set('ab')</strong><br/><strong>      False</strong><br/><strong>      &gt;&gt;&gt; bag('ac') == set('ab')</strong><br/><strong>      False</strong><br/><strong>      &gt;&gt;&gt; bag('ac') &lt;= set('ab')</strong><br/><strong>      False</strong><br/><strong>      &gt;&gt;&gt; bag('ac') &gt;= set('ab')</strong><br/><strong>      False</strong><br/><strong>      &gt;&gt;&gt; bag('a') &lt;= bag('a') &lt; bag('aa')</strong><br/><strong>      True</strong><br/><strong>      &gt;&gt;&gt; bag('aa') &lt;= bag('a')</strong><br/><strong>      False</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>First, comparison shows that an empty bag is equal to an empty set.</li>
<li>Next, the same, single element in both shows that they are still comparatively equal.</li>
<li>Adding a new element to a bag upsets the balance with a single-element set, as expected. The same thing happens when an extra element is added to the set and compared to a single-element bag.</li>
<li>A bag with duplicate elements (multiplicity = 2) is not equal to a set with a single element, even if it is the same value.</li>
<li>Jumping ahead, a bag with two different elements cannot be adequately compared to a set with different elements. While testing for equality is expected to fail, both greater than and less than comparisons fail as well.</li>
<li>Testing bags against each other may prove successful, depending on the comparisons. A single-element bag is obviously equal to itself, and is less than a bag with the element multiplicity <kbd>&gt; 1</kbd>.</li>
<li>Conversely, multiplicity <kbd>&gt; 1</kbd> will not be less than or equal to a multiplicity of 1.</li>
</ul>
</li>
</ul>
<ol start="2">
<li>Bags are roughly related to<span>&#160;</span><kbd>Counter</kbd><span>&#160;</span>collections, but provide different functionality. <kbd>ext_collections_bag_compare.py</kbd> shows how bags and Counters deal with adding and removing elements:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; from collections import Counter<br/>      &gt;&gt;&gt; c = Counter()</strong><br/><strong>      &gt;&gt;&gt; c['a'] += 1</strong><br/><strong>      &gt;&gt;&gt; c['a'] -= 1</strong><br/><strong>      &gt;&gt;&gt; 'a' in c</strong><br/><strong>      True</strong><br/><strong>      &gt;&gt;&gt; b = bag()</strong><br/><strong>      &gt;&gt;&gt; b.add('a')</strong><br/><strong>      &gt;&gt;&gt; 'a' in b</strong><br/><strong>      True</strong><br/><strong>      &gt;&gt;&gt; b.remove('a')</strong><br/><strong>      &gt;&gt;&gt; 'a' in b</strong><br/><strong>      False</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>A <kbd>Counter</kbd> instance is created and populated with an element.</li>
<li>When the element is removed via subtraction, it is still active in memory, as it hasn't actually been deleted from the <kbd>Counter</kbd>&#160;(to actually remove a <kbd>Counter</kbd> element, the <kbd>del</kbd> function must be used).</li>
<li>When a bag instance is created and an element added to it, the existence of the element is evident. However, when the <kbd>remove()</kbd> function is used on a bag element, that element is, in fact, removed.</li>
</ul>
</li>
</ul>
<ol start="3">
<li>The following example demonstrates how Counters and bags deal with object length as elements are added, removed, and duplicated:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; c = Counter()</strong><br/><strong>      &gt;&gt;&gt; c['a'] += 1</strong><br/><strong>      &gt;&gt;&gt; len(c)</strong><br/><strong>      1</strong><br/><strong>      &gt;&gt;&gt; c['a'] -= 1</strong><br/><strong>      &gt;&gt;&gt; len(c)</strong><br/><strong>      1</strong><br/><strong>      &gt;&gt;&gt; c['a'] += 2</strong><br/><strong>      &gt;&gt;&gt; len(c)</strong><br/><strong>      1</strong><br/><strong>      &gt;&gt;&gt; len(Counter('aaabbc'))</strong><br/><strong>      3</strong><br/><strong>      &gt;&gt;&gt; b = bag()</strong><br/><strong>      &gt;&gt;&gt; b.add('a')</strong><br/><strong>      &gt;&gt;&gt; len(b)</strong><br/><strong>      1</strong><br/><strong>      &gt;&gt;&gt; b.remove('a')</strong><br/><strong>      &gt;&gt;&gt; len(b)</strong><br/><strong>      0</strong><br/><strong>      &gt;&gt;&gt; len(bag('aaabbc'))</strong><br/><strong>      6</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>A <kbd>Counter</kbd> instance is created and populated.</li>
<li>With only one element added, the length of the instance is 1.</li>
<li>When the element is subtracted from the <kbd>Counter</kbd>, the length is still 1, as the element hasn't actually been removed from the <kbd>Counter</kbd>.</li>
<li>Adding multiple copies of an element to the <kbd>Counter</kbd> doesn't extend the length. The <kbd>Counter</kbd> simply tracks how many elements of the same value have been added, but doesn't append those values to its actual length.</li>
<li>Adding and removing elements to a bag, regardless of whether they are duplicates, actually affects the length of the bag object.</li>
</ul>
</li>
</ul>
<ol start="4">
<li>When iterating, bags again behave differently to Counters:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; for item in Counter('aaa'): print(item)</strong><br/><strong>      a</strong><br/><strong>      &gt;&gt;&gt; for item in bag('aaa'): print(item)</strong><br/><strong>      a</strong><br/><strong>      a</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>While a <kbd>Counter</kbd> prints only the element it contains (as the element is a key, with its value equal to the quantity of that key), a bag actually has all the elements contained in it, so it will print each and every element.</li>
</ul>
</li>
</ul>
<ol start="5">
<li>Several new methods are provided for bags:</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li><kbd>num_unique_elements</kbd>: It returns the number of unique elements in the bag.</li>
<li><kbd>unique_elements()</kbd>: It returns a set of all the unique elements in the bag.</li>
<li><kbd>nlargest(n=None)</kbd>: It returns the<span>&#160;</span><kbd>n</kbd><span>&#160;</span>most common elements and their quantities, from most common to least common. If<span>&#160;</span><kbd>n</kbd><span>&#160;</span>is not provided, then all elements are returned.</li>
<li><kbd>copy()</kbd>: It returns a shallow copy of the bag.</li>
<li><kbd>isdisjoint(other: Iterable)</kbd>: It tests whether the bag is disjoint with the provided<span>&#160;</span><kbd>Iterable</kbd>.</li>
<li><kbd>from_mapping(map: Mapping)</kbd>: A class method to create a bag from the provided<span>&#160;</span><kbd>Mapping</kbd>; maps the elements to counts.</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">RangeMap</h1>
                </header>
            
            <article>
                
<ol>
<li>Below, we create an empty <kbd>RangeMap</kbd>&#160;and&#160;then manually populate it with the date ranges of US presidents:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; from collections_extended import RangeMap</strong><br/><strong>      &gt;&gt;&gt; from datetime import date</strong><br/><strong>      &gt;&gt;&gt; us_presidents = RangeMap()</strong><br/><strong>      &gt;&gt;&gt; us_presidents[date(1993, 1, 20):date(2001, 1, 20)] = 'Bill Clinton'</strong><br/><strong>      &gt;&gt;&gt; us_presidents[date(2001, 1, 20):date(2009, 1, 20)] = 'George W. Bush'</strong><br/><strong>      &gt;&gt;&gt; us_presidents[date(2009, 1, 20):] = 'Barack Obama'</strong><br/><strong>      &gt;&gt;&gt; us_presidents[date(2001, 1, 19)]</strong><br/><strong>      'Bill Clinton'</strong><br/><strong>      &gt;&gt;&gt; us_presidents[date(2001, 1, 20)]</strong><br/><strong>      'George W. Bush'</strong><br/><strong>      &gt;&gt;&gt; us_presidents[date(2021, 3, 1)]</strong><br/><strong>      'Barack Obama'</strong><br/><strong>      &gt;&gt;&gt; us_presidents[date(2017, 1, 20):] = 'Someone New'</strong><br/><strong>      &gt;&gt;&gt; us_presidents[date(2021, 3, 1)]</strong><br/><strong>      'Someone New'</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li><kbd>RangeMap</kbd> is imported from the <kbd>collections-extended</kbd> module, <kbd>date</kbd> is imported from <kbd>datetime</kbd>, and a new <kbd>RangeMap</kbd> instance is created.</li>
<li>A date range is provided as the key to two US presidents, while an open ended range is given to a third.</li>
<li>Like a dictionary, providing the appropriate key to the <kbd>RangeMap</kbd> instance returns its value.</li>
<li>If a range is entered that overlaps a previous entry, the new entry becomes the end of the overlapped range key and starts a new open-ended range. Thus, the <kbd>Someone New</kbd>&#160;value is ascribed to the year 2021, rather than <kbd>Barack Obama</kbd>, which was the value to the previous open-ended range.</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Bijection</h1>
                </header>
            
            <article>
                
<ol>
<li>Bijective functions are commonly found in a variety of mathematical areas, such as in the definitions of isomorphism, homeomorphism, diffeomorphism, permutation group, and projective maps. The following example only demonstrates how a <kbd>bijection</kbd> object is created and checked, but doesn't go into extensive detail on implementation:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; from collections_extended import bijection</strong><br/><strong>      &gt;&gt;&gt; bij = bijection({'a': 1, 'b': 2, 'c': 3})</strong><br/><strong>      &gt;&gt;&gt; bij.inverse[2]</strong><br/><strong>      'b'</strong><br/><strong>      &gt;&gt;&gt; bij['a'] = 2</strong><br/><strong>      &gt;&gt;&gt; bij == bijection({'a': 2, 'c': 3})</strong><br/><strong>      True</strong><br/><strong>      &gt;&gt;&gt; bij.inverse[1] = 'a'</strong><br/><strong>      &gt;&gt;&gt; bij == bijection({'a': 1, 'c': 3})</strong><br/><strong>      True</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>As usual, the class is imported from the module and an instance is created. The instance argument is a simple dictionary, mapping a string to an integer.</li>
<li>Using the <kbd>inverse</kbd> function, the key to a value is printed. Providing the key, like a normal dictionary, displays its corresponding value.</li>
<li>A truth test shows that the instance is equal to an abbreviated version of that instance. Note that this isn't comparing whether the two bijection instances have the exact same mappings, just that they do, indeed, map a single key to a single value.</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>
</body>
</html>