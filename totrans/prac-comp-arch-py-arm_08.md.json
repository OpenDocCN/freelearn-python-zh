["```py\n\nx = input('Please enter your age')\n```", "```py\n\nx = input('Enter the constant ')\ny = int(x)                        # For a decimal constant\ny = int(x,2)                      # For a binary constant\ny = int(x,16)                     # For a hexadecimal constant\n```", "```py\n\ninst        = input('Enter operation: >>').replace(',',' ')\np           = inst.split(' ')\nt1,t2,t3,t4 = p[0],int(p[1][1:]),int(p[2][1:]),int(p[3][1:],16)\n```", "```py\na = p\n```", "```py\nb = q\n```", "```py\nc = r\n```", "```py\n\ninst = input('Enter operation: >>').replace(',',' ')\nprint('inst',inst)\np = inst.split(' ')\nprint ('p',p)\nt1,t2,t3,t4 = p[0],int(p[1][1:]),int(p[2][1:]),int(p[3][1:],16)\nprint(‚t1,t2,t3,t4',t1,t2,t3,t4)\n```", "```py\n\nEnter operation: >>add r1,r2,$FACE\ninst add r1 r2 $FACE\np ['add', 'r1', 'r2', '$FACE']\nt1,t2,t3,t4 add 1 2 64206\n```", "```py\n\nprint(listing[pcOld])          # Listing contains a list of string instructions\n```", "```py\n\nprint(\"{:<23}\".format(listing[pcOld]))\n```", "```py\n\nz = 0x4ace          # The hex data to print\nprint(\"%06x\" %z)    # Printing it in 6 chars with leading zeros\n```", "```py\n004ace\n```", "```py\n\na = 42\nb = 'Test'\n```", "```py\nprint('a is the integer\\t',a,'\\nb is the string','\\t',b)\n```", "```py\na is the integer              42\n```", "```py\nb is the string               Test\n```", "```py\n\nprint('This is a\\ttab\\ttest'.expandtabs(6))\nThis is a   tab   test\n```", "```py\n\nprint(R'test\\n one', 'test\\n two')\n```", "```py\n\ntest\\n one test\n two\n```", "```py\n\n>>> x = 12345\n>>> y = hex(x)\n>>> print(y)\n0x3039\n>>> z = y + 1\nTypeError: can only concatenate str (not \"int\") to str\n>>> z = int(y,16) + 1\n>>> print (z)\n12346\n>>> print(hex(z))\n0x303a\n```", "```py\n\np = 1022\nq = \"{0:b}\".format(p)\nprint('p in decimal is',p, \"and in binary, it's\",q)\n```", "```py\np in decimal is 1022 and in binary, it's 1111111110\n```", "```py\n\np1, p2 = 26, 2033\nq1 = \"{0:16b}\".format(p1)\nq2 = \"{0:16b}\".format(p2)\n```", "```py\nprint('p1 is',q1, '\\nand p2 is',q2)\n```", "```py\np1 is            11010\n```", "```py\np2 is      11111110001\n```", "```py\n\np1, p2 = 26, 2033\nq1 = \"{0:016b}\".format(p1)\nq2 = \"{0:016b}\".format(p2)\nprint('p1 is',q1, '\\nand p2 is',q2)\n```", "```py\np1 is 0000000000011010\n```", "```py\np2 is 0000011111110001\n```", "```py\n\np1, p2 = 30, 64123\nq1 = \"{0:8x}\".format(p1)\nq2 = \"{0:8x}\".format(p2)\nq3 = \"{0:08x}\".format(p1)\nq4 = \"{0:08x}\".format(p2)\nprint('\\n', q1, '\\n', q3, '\\n', q2, '\\n', q4)\n```", "```py\n       1e\n```", "```py\n 0000001e\n```", "```py\n     fa7b\n```", "```py\n 0000fa7b\n```", "```py\n\nx, y = 1037, 325\nxBin = \"{0:016b}\".format(x)\nyHex = \"{0:04x}\".format(y)\nprint(\"x is\",xBin,\"y is\",yHex)\n```", "```py\nprint(\"x is\",\"0b\" + xBin,\"y is\",\"0x\" + yHex)\n```", "```py\nx is 0000010000001101 y is 0145\n```", "```py\nx is 0b0000010000001101 y is 0x0145\n```", "```py\n\nfor x in range (1,7):\n    print(\"Table of powers {0:2d}{1:3d}{2:4d}{3:6d}\".format(x,x**2,x**3,x**4))\n```", "```py\nTable of powers  1   1    1      1\n```", "```py\nTable of powers  2   4    8     16\n```", "```py\nTable of powers  3   9   27     81\n```", "```py\nTable of powers  4  16   64    256\n```", "```py\nTable of powers  5  25  125    625\n```", "```py\nTable of powers  6  36  216   1296\n```", "```py\n\nfor x in range (1,10):\n    print('Table of powers {0:2d} binary {1:10b} {2:4d} \\\n    hex {3:6x}'.format(x, x*x, x*x*x, x*x*x*x))\n```", "```py\n\nTable of powers  1 binary          1    1 hex      1\nTable of powers  2 binary        100    8 hex     10\nTable of powers  3 binary       1001   27 hex     51\nTable of powers  4 binary      10000   64 hex    100\nTable of powers  5 binary      11001  125 hex    271\nTable of powers  6 binary     100100  216 hex    510\nTable of powers  7 binary     110001  343 hex    961\nTable of powers  8 binary    1000000  512 hex   1000\nTable of powers  9 binary    1010001  729 hex   19a1\n```", "```py\n\nfor x in range (1,10):\n    print('Powers {:2d} binary {:8b}{:4d} hex{:6x}'.format(x,x**2, x**3, x**4))\nPowers  1 binary        1    1 hex      1\nPowers  2 binary      100    8 hex     10\nPowers  3 binary     1001   27 hex     51\nPowers  4 binary    10000   64 hex    100\nPowers  5 binary    11001  125 hex    271\nPowers  6 binary   100100  216 hex    510\nPowers  7 binary   110001  343 hex    961\nPowers  8 binary  1000000  512 hex   1000\nPowers  9 binary  1010001  729 hex   19a1\n```", "```py\n\nx = 123\nprint('{:<10d}'.format(x))\nprint('{:>10d}'.format(x))\nprint('{:^10d}'.format(x))\nprint('{:<10b}'.format(x))\nprint('{:>10b}'.format(x))\n```", "```py\nprint('{:^10b}'.format(x))\n```", "```py\n123                                   Left-justified\n```", "```py\n       123                            Right-justified\n```", "```py\n   123                                Centered\n```", "```py\n1111011                               Left-justified\n```", "```py\n   1111011                            Right-justified\n```", "```py\n 1111011                              Centered\n```", "```py\n\nx = 123\ny = 0xABCD\np = 13.141592\nq ='This is a test'\nprint(\"Hex example: %03x\" %y, \"%05d\" %x, 'Alan', \"%12.3f\" %p, '%-20.14s' %q)\n```", "```py\nHex example: abcd 00123 Alan       13.142 This is a test\n```", "```py\n\nR = [0xabcd,2,3,0x123,5,0x11010,7,124]\nprint('Registers =',\" \".join(\"%04x\" % b for b in R))\n```", "```py\nRegisters = abcd 0002 0003 0123 0005 11010 0007 007c\n```", "```py\n\n>>> x = 44350                              Here's a decimal number\n>>> print(hex(x))                          Can I see that in hex?\n0xad3e                                     Thanks. But I like uppercase hex\n>>> print(hex(x).upper())                  OK. We just use the .upper() method on the string.\n0XAD3E                                     Nice one. But I don't like 0X at the front.\n>>> print(hex(x).upper()[2:])              OK, OK, just use slice notation [2:] to strip 0X.\nAD3E                                       Great. Can I have that with fries?\n```", "```py\n\nif jj not in codes: error = 1\n```", "```py\n\nform = codes.get(y[0])   # Read the 4-bit format code\n```", "```py\n\nopType = form[0]                                           # Get operand info\nif   opType == 0:                  totalOperands = 1       # Just a mnemonic\nelif opType == 8  or opType == 1:  totalOperands = 2       # Mnemonic + 1 operand\nelif opType == 12 or opType == 9:  totalOperands = 3       # Mnemonic + 2 operands\nelif opType == 14 or opType == 13: totalOperands = 4       # Mnemonic + 3\nelif opType == 15:                 totalOperands = 5       # Mnemonic + 4 (not used)\n```", "```py\n\n    totalTokens = len(y)                     # Get the number of tokens in this instruction y\n    if totalTokens < totalOperands:          # Are there enough tokens?\n        error = 2                            # Error 2: Too few operands\n        continue\n    if totalTokens > totalOperands:          # Are there too many tokens?\n        error = 3                            # Error 3: Too many operands \n```", "```py\n        continue\n```", "```py\n\n    if opType & 0b1000 == 0b1000:             # If the destination register bit is set\n        rDname = y[1]                         # Get the register name (second item in string)\n        error,q = syntaxTest(rDname)          # Call syntax test to look for errors\n```", "```py\n\ndef syntaxTest(token):                         # Test register for validity (R0 to R7)\n    if token[0] != 'R': return(4,0)            # Fail on missing initial R. Return error 4\n    if not token[1:].isnumeric(): return(5,0)  # Fail on missing register number. Return 5\n    if int(token[1:]) > 7: return(6,0)         # Fail on register number not in 0-7\\. Return 6\n    return(0,int(token[1:]))                   # OK so return with error 0 and reg number\n```", "```py\n\nrun = 1\nerror = 0\nwhile run == 1:\n    if error != 0: printError(error)\n       .\n       .\n       <test for error 1>\n    if error != 0: continue\n        <test for error 2>\n    if error != 0: continue\n       .\n       <test for error n>\n    if error != 0: continue\n```", "```py\n\n# Testing Python parsing # 22 Aug 2020 Version of 29 July 2021\nimport sys                                    # System library used to exit program\ncodes = {'NOP':(0,0), 'STOP': (0,1),'BEQ':(1,4), 'INC':(8,2), \\\n         'MOVE':(12,23), 'LDRL':(9,13), 'ADD':(14,12),'ADDL':(13,12)}\ndef syntaxTest(token):               # Test the format of a register operand for validity (R0 to R7)\n    if token[0] != 'R': return(4,0)           # Fail on missing initial R. Return error 2\n    if not token[1:].isnumeric(): return(5,0) # Fail on missing register number. Return error 3\n    if int(token[1:]) > 7: return(6,0)  # Fail on register number not in range 0-7\\. Return error 4\n    return(0,int(token[1:]))            # Success return with error code 0 and register number\ndef printError(error):\n    if error != 0:\n        if error == 1: print(\"Error 1: Non-valid operation\")\n        if error == 2: print(\"Error 2: Too few operands\")\n        if error == 3: print(\"Error 3: Too many operands\")\n        if error == 4: print(\"Error 4: Register operand error- no 'R'\")\n        if error == 5: print(\"Error 5: Register operand error - no valid num\")\n        if error == 6: print(\"Error 6: Register operand error - not in range\")\nrun = 1\nerror = 0\nwhile run == 1:\n    if error != 0: printError(error)    # if error not zero, print message\n    x = input(\"\\nEnter instruction >> \")# Type an instruction (for testing)\n    x =  x.upper()                      # Convert lowercase into uppercase\n    x = x.replace(',',' ')              # Replace comma with space to allow add r1,r2 or add r1 r2\n    y = x.split(' ')                    # Split into tokens. y is the tokenized instruction\n    if len(y) > 0:                      # z is the predicate (or null if no operands)\n        z = y[1:]\n    else: z  = ''\n    print(\"Inst =\",y, 'First token',y[0])\n    if y[0] not in codes:               # Check for valid opcode\n        error = 1                       # Error 1: instruction not valid\n        print(\"Illegal instruction\", y[0])\n        continue\n    form = codes.get(y[0])              # Get the code's format information\n    print('Format', form)\n    if form[1] == 1:                    # Detect STOP, opcode value 1,and terminate\n        print(\"\\nProgram terminated on STOP\")  # Say \"Goodbye\"\n        sys.exit()                      # Call OS function to leave\n    opType = form[0]\n    if   opType == 0:                                  totalOperands = 1\n    elif opType == 8  or opType == 4  or opType == 1:  totalOperands = 2\n    elif opType == 12 or opType == 9:                  totalOperands = 3\n    elif opType == 14 or opType == 13:                 totalOperands = 4\n    totalTokens = len(y)                # Compare tokens we have with those we need\n    if totalTokens < totalOperands:\n        error = 2                       # Error 2: Too few operands\n        continue\n    if totalTokens > totalOperands:\n        error = 3                       # Error 3: Too many operands\n        continue\n    if opType & 0b1000 == 0b1000:\n        rDname = y[1]\n        error,q = syntaxTest(rDname)\n        if error != 0: continue\n    if opType & 0b0100 == 0b0100:\n        rS1name = y[2]\n        error,q = syntaxTest(rS1name)\n        if error != 0: continue\n    if opType & 0b0010 == 0b0010:\n        rS2name = y[3]\n        error,q = syntaxTest(rS2name)\n        if error != 0: continue\n    if opType & 0b0001 == 0b0001:\n        if not y[-1].isnumeric():\n            error == 7\n            print(\"Error 7: Literal error\")\n    if error == 0:\n       print(\"Instruction\", x, \"Total operands\", totalOperands,\"Predicate\", z)\n```", "```py\n\nregSet = {'R0':0, 'R1':1, 'R2':2, 'R3':3, 'R4':4, 'R5':5, 'R6':6, 'R7':7}\n```", "```py\n\ndef regTest(tokNam,token):           # Test format of a register operand for validity (R0 to R7)\n    if token in regSet:              # Is it in the register set?\n        return (0,regSet.get(token)) # If it's there, return 0 and token value\n    else:                            # If not there, return error code 4 and the token's name\n        print(\"Error in register \",tokNam)\n        return (4,0)\n```", "```py\n\n    mnemonic = y[0]                    # Get the mnemonic\n    if mnemonic not in codes:          # Check for a valid opcode\n        error = 1                      # If none found, set error code\n        continue                       # and jump to the end of the loop\n    opData  = codes.get(mnemonic)      # Read codes to get the data for this instruction\n    opForm  =  opData[0]               # Get each of this instruction's parameters\n    opStyle =  opData[1]\n    opCode  =  opData[2]\n    opLen   =  opData[3]\n    if opCode == 1:                    # If the op_Code is 1, then it's \"STOP\", so exit the program\n        print(\"\\nProgram terminated on STOP\")\n        sys.exit()\n    totalTokens = len(y)               # How many tokens do we have?\n    if totalTokens < opLen:            # Compare with the expected number\n        error = 2                      # Error 2: Too few operands\n        continue\n    if totalTokens > opLen:\n        error = 3                      # Error 3: Too many operands\n        continue\n```", "```py\n\n# Input error checking - using dictionaries Modified 30 July 2021\n# Instruction dictionary 'mnemonic':(format, style, op_code, length)\n# Style definition and example of the instruction format\n# 0 NOP            mnemonic only\n# 1 BEQ L          mnemonic + literal\n# 2 INC R1         mnemonic + rD\n# 3 MOVE R1,R2     mnemonic + rD1 + rS1\n# 4 LDRL R1,L      mnemonic + rD1 + literal\n# 5 ADD R1 R2 R3   mnemonic + rD + rS1 + rS2\n# 6 ADDL R1 R2 L   mnemonic + rD + rS1 + literal\n# 7 LDRI R1 (R2 L) mnemonic + rD + rS1 + literal (same as 6)\nimport sys                                     # System library used to exit program\n             # Dictionary of instructions (format, style, op_code, length)\ncodes = {'NOP': (0b0000,0,0,1),'STOP':(0b0000,0,1,1),'BEQ': (0b0001,1,2,2), \\\n         'INC': (0b1000,2,3,2),'MOVE':(0b1100,3,4,3),'LDRL':(0b1001,4,6,3), \\\n         'LDRI':(0b1101,7,7,4),'ADD': (0b1110,5,8,4),'ADDL':(0b1101,6,9,4)}\nregSet = {'R0':0,'R1':1,'R2':2,'R3':3,'R4':4,'R5':5,'R6':6,'R7':7} # Registers\ndef regTest(token):                            # Test register operand for R0 to R7\n    if token in regSet: return (0)             # Return with error 0 if legal name\n    else:               return (4)             # Return with error 4 if illegal register name\ndef printError(error):                         # This function prints the error message\n    if error != 0:\n        if error == 1: print(\"Error 1: Non-valid operation\")\n        if error == 2: print(\"Error 2: Too few operands\")\n        if error == 3: print(\"Error 3: Too many operands\")\n        if error == 4: print(\"Error 4: Register name error\")\n        if error == 5: print(\"Error 5: Failure in pointer-based expression\")\n        if error == 6: print(\"Error 6: Invalid literal\")\ndef litCheck(n):                          # Check for invalid literal format (this is just a demo)\n    if n.isnumeric():    error = 0             # Decimal numeric OK\n    elif n[0] == '-':    error = 0             # Negative number OK\n    elif n[0] == '%':    error = 0             # Binary number OK\n    elif n[0:2] == '0X': error = 0             # Hex number OK\n    else:                error = 6             # Anything else is an error\n    return(error)                              # Return with error number\n```", "```py\n\nerror = 0\nwhile True:             # Infinite loop\n    if error != 0: printError(error)\n    error = 0\n    x = input(\">> \").upper()             # Read instruction and provide limited processing\n    if len(x) == 0: continue             # Ignore empty lines and continue\n    x = x.replace(',',' ')               # remove commas\n    x = x.replace('(','')                # remove (\n    x = x.replace(')','')                # remove )\n    y = x.split(' ')                     # Create list of tokens (mnemonic + predicate)\n    mnemonic = y[0]                      # Get the mnemonic (first token)\n    if mnemonic not in codes:            # Check for validity\n        error = 1                        # If not valid, set error code and drop out\n        continue\n    opData = codes.get(mnemonic)         # Read the four parameters for this instruction\n    opForm  =  opData[0]                 # opcode format (rDS,rS1,rS2,L)\n    opStyle =  opData[1]                 # Instruction style (0 to 7)\n    opCode  =  opData[2]                 # Numeric opcode\n    opLen   =  opData[3]                 # Length (total mnemonic + operands in range 1 to 4)\n    if opLen > 1: predicate = y[1:]      # Get predicate if this is one\n    else:         predicate = ''         # If single token, return null\n    print(\"Mnemonic =\",mnemonic, \"Predicate\", predicate, \\\n          \"Format =\", bin(opForm),\"Style =\",opStyle,\"Code =\",opCode, \\\n          \"Length =\",opLen)\n    if opCode == 1:                      # Used to terminate this program\n        print(\"\\nProgram ends on STOP\")\n        sys.exit()\n    totalTokens = len(y)\n    if totalTokens < opLen:\n        error = 2                        # Error 2: Too few operands\n        continue\n    if totalTokens > opLen:\n        error = 3                        # Error 3: Too many operands\n        continue\n    if opStyle == 0:                     # e.g., NOP or STOP so nothing else to do\n        continue\n    elif opStyle == 1:                   # e.g., BEQ 5 just check for literal\n        literal = predicate[0]\n        error = litCheck(literal)\n        continue\n    elif opStyle == 2:                   # e.g., INC r6 check for single register\n        error = regTest(predicate[0])\n        continue\n    elif opStyle == 3:                   # e.g., MOVE r1,r2 check for two registers\n        e1 = regTest(predicate[0])\n        e2 = regTest(predicate[1])\n        if e1 != 0 or e2 != 0:\n            error = 4\n        continue\n    elif opStyle == 4:                   # e.g., LDRL r1,12 Check register then literal\n        error = regTest(predicate[0])\n        if error != 0: continue\n        literal = predicate[1]\n        error = litCheck(literal)\n        continue\n    elif opStyle == 5:                   # e.g., ADD r1,r2,r3 Check for three register names\n        e1 = regTest(predicate[0])\n        e2 = regTest(predicate[1])\n        e3 = regTest(predicate[2])\n        if e1 != 0 or e2 != 0 or e3 !=0:\n            error = 4\n        continue\n    elif opStyle == 6:                   # e.g., ADDL R1,R2,4 Check for two registers and literal\n        e1 = regTest(predicate[0])\n        e2 = regTest(predicate[1])\n        literal = predicate[2]\n        e3 = litCheck(literal)\n        if e1 != 0 or e2 != 0:\n            error = 4\n        if e1==0 and e2==0 and e3 !=0:   # If registers are OK but not literal\n            error = 6                    # report literal error\n        continue\n    elif opStyle == 7:                   # e.g., LDRI r4,r0,23 or LDRI r4,(r0,23)\n        e1 = regTest(predicate[0])\n        e2 = regTest(predicate[1])\n        literal = predicate[2]\n        e3 = litCheck(literal)\n        if e1 != 0 or e2 != 0:\n            error = 4\n        if e1==0 and e2==0 and e3 !=0:   # If registers are OK but not literal\n            error = 6                    # report literal error\n        continue\n```", "```py\n\ntrace = 1                                    # Trace mode active when trace = 1\nrun = 1# run = 1 to execute program\npc = 0# Initialize program counter\nwhile run == 1:# Main program loop\n    read instruction\n    execute instruction\n    if trace == 1: displayData()             # When in trace mode, print results\n```", "```py\n\ndef display():                                   # Display processor status\n    if oldPC in breakTab: print('Breakpoint at %03x' %oldPC)   # if pc in the table\n    print(\"PC = %03x\" %oldPC,  ' Op-code = %s' %instruction)\n    return()\nopCodes = ['nop', 'test', 'test1', 'stop']       # Op-code set\ntraceCodes = []                                  # List of codes to be traced (initially empty)\nmem = ['nop'] * 32                               # Initialize memory to NOPs\nmem[10] = 'test'                                 # Dummy operation at 10\nmem[20] = 'test'                                 # Dummy operation at 20\nmem[25] = 'test1'                                # Dummy operation at 25\nr = [0] * 4                                      # Set up 4 registers (not used)\npc = 0                                           # Initialize program counter\noldPC = 0                                        # Initialize previous program counter\nrun = 1                                          # Set run to 1 to go\ntrace = 1                                        # Set trace to 1 to single-step\ncount = 0                                     # Count is the number of cycles not displayed\nbreakTab = []                                    # Create table for breakpoints\nwhile run == 1:                                  # PROGRAM LOOP\n    instruction = mem[pc]                        # read instruction\n    oldPC = pc                                   # Save current PC for display\n    pc = pc + 1                                  # Increment PC\n    # Do processing here                         # For experimentation (add stuff here)\n    if pc == 32 or instruction == 'stop': run = 0 # End on stop instruction or max PC\n    if trace == 0 and count != 0:                # Test for single-step mode\n        count = count - 1                        # If not single-step, decrement counter\n        if count == 0:                           # If count zero, return to single step mode\n            trace = 1                            # Exit silent mode\n            continue                             # Now drop to bottom of the loop\n    if trace == 0 and pc in breakTab:            # If not single-step, check for breakpoint\n        print('Breakpoint\\n')                    # Print status at the breakpoint\n        display()\n    if trace == 0 and instruction in traceCodes: # If not single-step and opcode in table\n        print('Trace Code')                      # Print status info\n        display()\n    if trace == 1:# If single-step with trace on\n        display()                                # Display the status\n        c = input('>> ')                         # Wait for keyboard input\n        if c == '': continue                     # If it's just a return, continue\n        elif c[0]== 't' and len(c) > 2 and c[2:].isdigit():\n                                                 # Test for 't' and number\n            count = int(c[2:])                   # Set the count for silent mode\n            trace = 0                            # Turn off single-step\n        elif c[0] == 'b' and len(c) > 2 and c[2:].isdigit():\n                                                 # Test for b (set breakpoint)\n            breakPoint = int(c[2:])              # Get breakpoint address and add to table\n            breakTab.append(breakPoint)\n        elif c == 'd':                           # Test for d to display breakpoint info\n            print('Display status: breakpoints =', breakTab, \\\n                  'traced codes =',traceCodes)\n        elif c in opCodes: traceCodes.append(c)  # Test for a valid opcode and add to list\nprint('\\nProgram terminated')\n```", "```py\n\n    if trace == 1:                               # If single-step with trace on\n        display()                                # Display the status\n        c = input('>> ')                         # Wait for input from user\n        if c == '': continue                     # If it's just a return, continue\n```", "```py\n\nIf PC > 200 or PC < 300 and instruction = 'ADD'\n```", "```py\n\nPC = 000  Op-code = nop           # Hit enter key and trace first instruction\n>>\nPC = 001  Op-code = nop\n>>\nPC = 002  Op-code = nop\n>> t 4                            # Type t 4 to execute but skip printing 4 instructions\nPC = 007  Op-code = nop           # Note how PC jumps from 2 to 7\n>>\nPC = 008  Op-code = nop\n>>\nPC = 009  Op-code = nop\n>> b 12                           # Type b 12 to insert breakpoint at PC = 12\nPC = 00a  Op-code = nop\n>> t 6                            # Type t 6 to execute 6 instructions without display\nBreakpoint\nBreakpoint at 00c                 # No display continues until PC = 12 (0xC)\nPC = 00c  Op-code = nop           # Processor printed for PC = 12\nPC = 011  Op-code = nop           # Execution continues until PC = 17 (0x11)\n>> test1                          # Type 'test1' to make instruction test1 a breakpoint\nPC = 012  Op-code = nop\n>> t 15                           # Type t 15 to execute but skip printing 15 instructions\nTrace Code\nPC = 019  Op-code = test1         # Execution continues until 'test1' encountered at PC = 25 (0x19)\nProgram terminated\n```", "```py\n\ntemp ← mem[r[i]]                    # Save first number. Assume ri is the pointer register\nif mem[r[i] + 1] > temp             # If the second number is greater than the first\n   mem[r[i]]   ← mem[r[i]+1]        # then put the second number in the first location\n   mem[r[i]+1] ← temp               # and the first number in the second location\n```", "```py\n elif opCode == 0b1110000:           # Test for 'ORD' ( 112 in decimal and in 1110000 binary)\n```", "```py\n\ntemp = mem[r[dest]]                          # dest is the destination register\nif mem[r[dest] + 1] > temp:\n    mem[r[dest]] = mem[r[dest]+1]\n    mem[r[dest] + 1] = temp\n```", "```py\n\nimport random                                # System library to generate random numbers\nmem = [0] * 32                               # Set up memory\nr   = [0] * 8                                # Set up registers\nfor i in range(32): mem[i] = random.randint(0,256) # Fill memory with random numbers\nfor i in range(32): print(i, mem[i])\ndef ord(reg,rD,memory):                      # Pass registers, memory, and register number\n    temp = memory[reg[rD]]                   # rD is the destination register\n    if memory[reg[rD] + 1] > temp:\n        memory[reg[rD]] = memory[reg[rD]+1]\n        memory[reg[rD] + 1] = temp\n    return()\ngo = True\nr  = [0] * 8\nrD = 0\nwhile go:\n    x = input('Type address of first: ')\n    r[rD] = int(x)\n    if r[rD] > 30:                           # Exit on memory address 31 or higher\n        print('End of run')\n        break\n    else:\n        print('Before: mem[x] = ',mem[r[rD]], 'next = ',mem[r[rD] + 1])\n        ord(r,0,mem)\n```", "```py\n        print('After:  mem[x] = ',mem[r[rD]], 'next = ',mem[r[rD] + 1])\n```", "```py\n\ndef reverseBits(op1):                      # Reverse the bits of register op1\n    reversed = 0                           # The reversed value is initialized\n    toShift  = r[op1]                      # Read the register contents\n    for i in range(0,16):                  # Repeat for all 16 bits\n        bitOut   = toShift & 0x8000        # Get msb of word to reverse\n        toShift  = toShift << 1            # Shift source word one place left\n        reversed = reversed >> 1           # Shift result one place right\n        reversed = reversed | bitOut       # Use OR to insert bit in lsb of result\n    return(reversed)\n```", "```py\n    elif 'code ' == 0b1110001: r[op0] = reverseBits(op0)\n    ```", "```py\nelif 'code' == 0b1110010: R[dest] = reverseBits(op1)\n```", "```py\n\n    if mnemonic == \"CMPT\":\n        z = 0\n        if (r[rD] == r[rS1]) or (r[rD] == r[rS1] + 1): z = 1\n```", "```py\n\n# 31 Aug 2020 TESTING a variable format instruction set V1\nx = input(\"Enter three width for: rD,rS1,rS2 (e.g., 2,2,3) >> \")\nx = x.replace(' ',',')\nx = x.split(\",\")                          # Get register sizes and convert list into tokens\nx1 = int(x[0])                            # First register size rD\nx2 = int(x[1])                            # Second register size rS1\nx3 = int(x[2])                            # Third register size rS2\ny = (x1,x2,x3)                            # Convert data size elements into a tuple\nz = input(\"Enter three register operands for: rD,rS1,rS2 (e.g. R1,R3,R2)>> \")\nopCode = 0b1111110                        # Dummy 7-bit binary opcode\nz = z.replace(' ',',')\nz = z.split(\",\")\nt1,t2,t3 = 0,0,0                          # t1,t2,t3 are up to three tokens in the predicate\nt1 = int(z[0][1:])                        # Extract three parameters\nt2 = int(z[1][1:])\nt3 = int(z[2][1:])\nprint ('Register widths: rD = ',t1, 'rS1 = ',t2,'rS2 = ',t3)   # Print the registers\nopCode = opCode << x1 | t1                # Insert the rD field\nopCode = opCode << x2 | t2                # Insert the rS1 field\nopCode = opCode << x3 | t3                # Insert the rS2 field\nintLen = 32 - 7 - x1 - x2 - x3            # Calculate the length of the literal field\nopCode = opCode << intLen                 # Shift left by literal size to create 16-bit instruction\n```", "```py\nprint(\"opCode\",bin(opCode))               # Print the result\n```", "```py\n\nEnter three width for: rD,rS1,rS2 (e.g., 2,2,3) >> 3,4,5\nEnter register operands for: rD,rS1,rS2 (e.g.,R1,R3,R2)>> R4,R6,R30\nRegister widths: rD =  4 rS1 =  6 rS2 =  30\nopCode 0b1111110 1000110111100000000000000\n```", "```py\n\nprint ('Demonstrating multiple length instructions. Version 3 December 8 2022 \\n')\n```", "```py\nmem     = [0] * 128\n```", "```py\n\nlookUp  = {0b00001:'nop',0b00010:'stop',0b01000:'inc',0b01001:'dec',  \\\n           0b01010:'bra',0b01011:'beq',0b01100:'bne',0b10000:'mov',   \\\n           0b10001:'cmpl',0b10010:'cmp',0b10011:'ld',0b10100:'st',    \\\n           0b11000:'add',0b11001:'sub'}\nallOps  = {'nop':(1,1),'stop':(1,2),'inc':(2,8),'dec':(2,9),'bra':(2,10),   \\\n           'beq':(2,11),'bne':(2,12),'mov':(3,16),'ld':(3,19),              \\\n           'cmpl':(3,17),'cmp':(3,18),'add':(4,24),'sub':(4,25),'test':(0,0)}\n# NOTE that progS is the actual program to be executed. It is embedded into the program\nprogS   = ['this: equ 26','ld this:,7','that: equ 28','ld 27,2', \\\n           'ld that:,1','loop: add 28,28,26', 'dec 26','bne loop:','stop']\nsymTab  = {}                                          # Label symbol table\nprog    = []                                          # progS is prog without equates\nfor i in range (0,len(progS)):                        # Process source code for equates\n    thisLine = progS[i].split()                       # Split source code on spaces\n    if len(thisLine) > 1 and thisLine[1] == 'equ':    # Is this line an equate?\n         symTab.update({thisLine[0][0:]:thisLine[2]}) # Store label in symbol table. \n    else: prog.append(progS[i])                  # Append line to prog unless it's an equate\n```", "```py\n\nfor i in range (0,len(prog)):             # Process source code (now without equates)\n    prog[i] = prog[i].replace(',',' ')    # Remove commas\n    prog[i] = prog[i].split(' ')          # Tokenize\n    token1 = prog[i][0]                   # Get first token of instruction\n    if token1[-1] == ':':                 # If it ends in :, it's a label\n        j = str(i)                        # Note: we have to store i as a string not an integer\n        symTab.update({token1:j})         # Add label and instruction number to symbol table\n        prog[i].pop(0)                    # Remove label from this line. NOTE \"pop\"\nprint('Symbol table: ', symTab)\nmap = [0] * 64                            # Map instruction number to byte address\n```", "```py\n\nmC  = 0                                 # Memory counter (store code from 0)\nfor iC in range (0,len(prog)):          # Step through the program\n    instruction = prog[iC]              # Read an instruction. iC = instruction counter\n    mCold = mC                          # Remember old memory counter (address of first byte)\n    map[iC] = mC                        # Map byte address to instruction address\n    mnemonic = instruction[0]           # The first token is the mnemonic\n    mem[mC] = allOps[mnemonic][1]       # Store opcode in memory\n```", "```py\n    mC = mC + 1                         # Point to next free memory location\n    numOperands = allOps[mnemonic][0] - 1    # Get the number of operands from dictionary\n    if numOperands > 0:                 # If one or more operands\n        if instruction[1] in symTab:    # See if operand is in symbol table\n            instruction[1] = symTab[instruction[1]]   # If it is, convert into as string\n        mem[mC] = int(instruction[1])   # Store address in memory as integer\n        mC = mC + 1                     # Bump up byte counter\n    if numOperands > 1:                 # Do the same for two operands\n        if instruction[2] in symTab:    # See if operand is in symbol table\n            instruction[2] = symTab[instruction[2]]    # Convert to address as string\n        mem[mC] = int(instruction[2])\n        mC = mC + 1\n    if numOperands > 2:                 # Now deal with 3-operand instructions\n        if instruction[3] in symTab:    # See if operand is in symbol table\n            instruction[3] = symTab[instruction[3]]   # If it is, convert to string\n        mem[mC] = int(instruction[3])\n        mC = mC + 1\n    instPrint =  ' {0:<15}'.format( (' ').join(instruction)) # reformat instruction\n    print('iC=', iC,'\\t', 'Op =', mnemonic, '\\tNumber of operands =',  \\\n           numOperands, '\\t mC =', mCold, '\\tInstruction =',           \\\n           instPrint, 'memory =', mem[mCold:mC])\nprint('Memory (in bytes) =', mem[0:40], '\\n')\n                                               # EXECUTE THE CODE\nprint('\\nCode execution: press enter \\n')\npc, iC, z = 0, 0, 0                            # Initialize program and instruction counters\n```", "```py\n\nrun = True\nwhile run:                                       # Instruction execution loop\n    pcOld  = pc                                  # Remember pc at start of this cycle\n    opCode = mem[pc]                             # Read opcode\n    opLen  = (opCode >> 3) + 1                   # Get instruction length from opcode\n    if opCode == 0b00010:                        # Test for stop\n        run = False                              # Terminate on stop instruction\n        print('Execution terminated on stop')    # Say 'Goodbye'\n        break                                    # and exit the loop\n    operand1, operand2, operand3 = '', '', ''    # Dummy operands (null strings)\n    if opLen > 1: operand1 = mem[pc + 1]\n    if opLen > 2: operand2 = mem[pc + 2]\n    if opLen > 3: operand3 = mem[pc + 3]\n    pc = pc + opLen\n    iC = iC + 1\n```", "```py\n    mnemonic = lookUp[opCode]\n```", "```py\n\n    if   mnemonic == 'nop': pass\n    elif mnemonic == 'inc': mem[operand1] = mem[operand1] + 1\n    elif mnemonic == 'dec':\n        z = 0\n        mem[operand1] = mem[operand1] - 1\n        if mem[operand1] == 0: z = 1\n    elif mnemonic == 'bra':  pc = map[operand1] # Map instruction address to byte address\n    elif mnemonic == 'beq' and z == 1: pc = map[operand1]\n                                                 # Map instruction address to byte address\n    elif mnemonic == 'bne' and z == 0: pc = map[operand1]\n                                                 # Map instruction address to byte address\n    elif mnemonic == 'ld':  mem[operand1] = operand2\n    elif mnemonic == 'mov': mem[operand1] = mem[operand2]\n```", "```py\n\n    elif mnemonic == 'cmp':\n        diff = mem[operand1] - mem[operand2]\n        z = 0\n        if diff == 0: z = 1\n    elif mnemonic == 'cmpl':\n        diff = mem[operand1] - operand2\n        z = 0\n        if diff == 0: z = 1\n    elif mnemonic == 'add': mem[operand1] = mem[operand2] + mem[operand3]\n    elif mnemonic == 'sub':\n        mem[operand1] = mem[operand2] - mem[operand3]\n        z = 0\n        if mem[operand1] == 0: z = 1\n```", "```py\n\n    x = input('... ')\n    xxxx =  mnemonic + ' ' + str(operand1) + ' ' + str(operand2) \\\n    + ' ' + str(operand3)\n    instPrint =  ' {0:<15}'.format(xxxx)                   # re-format the instruction\n    print ('iC=',iC-1,'\\tpc=',pcOld,'\\tOp=',mnemonic,'z=',z,      \\\n```", "```py\n           '\\tmem 24-35=',mem[24:36],'\\tInstruction = ', instPrint)\n```"]