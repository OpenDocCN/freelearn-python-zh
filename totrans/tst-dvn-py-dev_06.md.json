["```py\nmodule\n|\n+- file\n+- file\n+- tests\n   |\n   + test_file\n   + test_file\n```", "```py\nroot\n|\n+- module\n|  |\n|  +- file\n|  +- file\n|\n+- tests\n   |\n   + test_file\n   + test_file\n```", "```py\nroot\n|\n+- src\n|  |\n|  +- module1\n|     |\n|     +- file\n|     +- file\n|\n+- tests\n   |\n   +- module1\n      |\n      + test_file\n      + test_file\n```", "```py\npython3 -m unittest discover\n\n```", "```py\npython3 -m unittest discover -p *_test.py\n\n```", "```py\n    def get_closing_price_list(self, on_date, num_days):\n        closing_price_list = []\n        for i in range(num_days):\n            chk = on_date.date() - timedelta(i)\n            for price_event in reversed(self.series):\n                if price_event.timestamp.date() > chk:\n                    pass\n                if price_event.timestamp.date() == chk:\n                    closing_price_list.insert(0, price_event)\n                    break\n                if price_event.timestamp.date() < chk:\n                    closing_price_list.insert(0, price_event)\n                    break\n        return closing_price_list\n```", "```py\nclass TimeSeriesTest(unittest.TestCase):\n    def test_closing_price_list_before_series_start_date(self):\n        series = TimeSeries()\n        series.update(datetime(2014, 3, 10), 5)\n        on_date = datetime(2014, 3, 9)\n        self.assertEqual([], series.get_closing_price_list(on_date, 1))\n```", "```py\n    def test_closing_price_list_before_series_start_date(self):\n        \"\"\"\n        Empty list is returned if on_date is before the start of the\n        series\n        The moving average calculation might be done before any data\n        has been added to the stock. We return an empty list so that\n        the calculation can still proceed as usual.\n        \"\"\"\n        series = TimeSeries()\n        series.update(datetime(2014, 3, 10), 5)\n        on_date = datetime(2014, 3, 9)\n        self.assertEqual([], series.get_closing_price_list(on_date, 1))\n```", "```py\nclass SomeTest(unittest.TestCase):\n    def setUp(self):\n        connect_to_database()\n        connect_to_server()\n\n    def tearDown(self):\n        disconnect_from_database()\n        disconnect_from_server()\n```", "```py\nclass SomeTest2(unittest.TestCase):\n    def setUp(self):\n        connect_to_database()\n        self.addCleanup(self.disconnect_database)\n        connect_to_server()\n        self.addCleanup(self.disconnect_server)\n\n    def disconnect_database(self):\n        disconnect_from_database()\n\n    def disconnect_server(self):\n        disconnect_from_server()\n```", "```py\n@mock.patch.object(smtplib, \"SMTP\")\nclass EmailActionTest(unittest.TestCase):\n    def setUp(self):\n        self.action = EmailAction(to=\"siddharta@silverstripesoftware.com\")\n\n    def test_connection_closed_after_sending_mail(self, mock_smtp_class):\n        mock_smtp = mock_smtp_class.return_value\n        self.action.execute(\"MSFT has crossed $10 price level\")\n        mock_smtp.send_message.assert_called_with(mock.ANY)\n        self.assertTrue(mock_smtp.quit.called)\n        mock_smtp.assert_has_calls([\n            mock.call.send_message(mock.ANY),\n            mock.call.quit()])\n```", "```py\n    def setUp(self):\n        patcher = mock.patch(\"smtplib.SMTP\")\n        self.addCleanup(patcher.stop)\n        self.mock_smtp_class = patcher.start()\n        self.mock_smtp = self.mock_smtp_class.return_value\n        self.action = EmailAction(to=\"siddharta@silverstripesoftware.com\")\n```", "```py\n    def test_connection_closed_after_sending_mail(self):\n        self.action.execute(\"MSFT has crossed $10 price level\")\n        self.mock_smtp.send_message.assert_called_with(mock.ANY)\n        self.assertTrue(self.mock_smtp.quit.called)\n        self.mock_smtp.assert_has_calls([\n            mock.call.send_message(mock.ANY),\n            mock.call.quit()])\n```", "```py\nclass MyTestCase(unittest.TestCase):\n    def create_start_object(self, value):\n        do_something(value)\n\nclass SomeTest(MyTestCase):\n    def test_1(self):\n        create_start_object(\"value 1\")\n\nclass SomeTest2(MyTestCase):\n    def test_2(self):\n        create_start_object(\"value 2\")\n\n    def test_3(self):\n        create_start_object(\"value 3\")\n```", "```py\n    def test_increasing_trend_is_false_if_price_decreases(self):\n        timestamps = [datetime(2014, 2, 11), datetime(2014, 2, 12),\n                      datetime(2014, 2, 13)]\n        prices = [8, 12, 10]\n        for timestamp, price in zip(timestamps, prices):\n            self.goog.update(timestamp, price)\n        self.assertFalse(self.goog.is_increasing_trend())\n\n    def test_increasing_trend_is_false_if_price_equal(self):\n        timestamps = [datetime(2014, 2, 11), datetime(2014, 2, 12),\n                      datetime(2014, 2, 13)]\n        prices = [8, 10, 10]\n        for timestamp, price in zip(timestamps, prices):\n            self.goog.update(timestamp, price)\n        self.assertFalse(self.goog.is_increasing_trend())\n```", "```py\n    def given_a_series_of_prices(self, prices):\n        timestamps = [datetime(2014, 2, 10), datetime(2014, 2, 11),\n                      datetime(2014, 2, 12), datetime(2014, 2, 13)]\n        for timestamp, price in zip(timestamps, prices):\n        self.goog.update(timestamp, price)\n```", "```py\n    def test_increasing_trend_is_false_if_price_decreases(self):\n        self.given_a_series_of_prices([8, 12, 10])\n        self.assertFalse(self.goog.is_increasing_trend())\n\n    def test_increasing_trend_is_false_if_price_equal(self):\n        self.given_a_series_of_prices([8, 10, 10])\n        self.assertFalse(self.goog.is_increasing_trend())\n```", "```py\nclass TimeSeriesEqualityTest(unittest.TestCase):\n    def test_timeseries_price_history(self):\n        series = TimeSeries()\n        series.update(datetime(2014, 3, 10), 5)\n        series.update(datetime(2014, 3, 11), 15)\n        self.assertEqual(5, series[0].value)\n        self.assertEqual(15, series[1].value)\n```", "```py\nclass TimeSeriesTestCase(unittest.TestCase):\n    def assert_has_price_history(self, price_list, series):\n        for index, expected_price in enumerate(price_list):\n            actual_price = series[index].value\n            if actual_price != expected_price:\n                raise self.failureException(\"[%d]: %d != %d\".format(index, expected_price, actual_price))\n\nclass TimeSeriesEqualityTest(TimeSeriesTestCase):\n    def test_timeseries_price_history(self):\n        series = TimeSeries()\n        series.update(datetime(2014, 3, 10), 5)\n        series.update(datetime(2014, 3, 11), 15)\n        self.assert_has_price_history([5, 15], series)\n```", "```py\n>>> import unittest\n>>> testcase = unittest.TestCase()\n>>> testcase.assertEqual(1, 2)\nTraceback (most recent call last):\n ...\nAssertionError: 1 != 2\n\n```", "```py\n>>> import unittest\n>>> testcase = unittest.TestCase()\n>>> testcase.assertEqual([1, 2], [1, 3])\nTraceback (most recent call last):\n ...\nAssertionError: Lists differ: [1, 2] != [1, 3]\n\nFirst differing element 1:\n2\n3\n\n- [1, 2]\n?     ^\n\n+ [1, 3]\n?     ^\n\n```", "```py\n>>> import unittest\n>>> from stock_alerter.stock import Stock\n>>> test_case = unittest.TestCase()\n>>> stock_1 = Stock(\"GOOG\")\n>>> stock_2 = Stock(\"GOOG\")\n>>> test_case.assertEqual(stock_1, stock_2)\nTraceback (most recent call last):\n ...\nAssertionError: <stock_alerter.stock.Stock object at 0x000000000336EDD8> != <stock_alerter.stock.Stock object at 0x00000000033E9588>\n\n```", "```py\n>>> test_case.addTypeEqualityFunc(Stock, lambda stock_1, stock_2, msg: stock_1.symbol == stock_2.symbol)\n>>> test_case.assertEqual(stock_1, stock_2)\n>>> print(test_case.assertEqual(stock_1, stock_2))\nNone\n>>>\n\n```", "```py\nclass MessageMatcher:\n    def __init__(self, expected):\n        self.expected = expected\n\n    def __eq__(self, other):\n        return self.expected[\"Subject\"] == other[\"Subject\"] and \\\n            self.expected[\"From\"] == other[\"From\"] and \\\n            self.expected[\"To\"] == other[\"To\"] and \\\n            self.expected[\"Message\"] == other._payload\n```", "```py\nclass AlertMessageMatcher:\n    def __init__(self, expected):\n        self.expected = expected\n\n    def __eq__(self, other):\n        return self.expected[\"Subject\"] == \"New Stock Alert\" and \\\n            self.expected[\"From\"] == other[\"From\"] and \\\n            self.expected[\"To\"] == other[\"To\"] and \\\n            self.expected[\"Message\"] == other._payload\n```"]