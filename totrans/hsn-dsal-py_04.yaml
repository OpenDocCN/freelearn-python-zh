- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linked Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python’s list implementation is quite powerful and can encompass several different
    use cases. We have discussed the built-in data structures of **lists** in Python
    in *Chapter 1*, *Python Data Types and Structures*. Most of the time, Python’s
    built-in implementation of a list data structure is used to store data using a
    linked list. In this chapter, we will understand how linked lists work along with
    their internals.
  prefs: []
  type: TYPE_NORMAL
- en: A linked list is a data structure where the data elements are stored in a linear
    order. Linked lists provide efficient storage of data in linear order through
    pointer structures. Pointers are used to store the memory address of data items.
    They store the data and location, and the location stores the position of the
    next data item in the memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The focus of this chapter will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singly linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doubly linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circular lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical applications of linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before discussing linked lists, let us first discuss an array, which is one
    of the most elementary data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array is a collection of data items of the same type, whereas a linked list
    is a collection of the same data type stored sequentially and connected through
    pointers. In the case of lists, the data elements are stored in different memory
    locations, whereas the array elements are stored in contiguous memory locations.
  prefs: []
  type: TYPE_NORMAL
- en: An array stores the data of the same data type and each data element in the
    array is stored in contiguous memory locations. Storing multiple data values of
    the same type makes it easier and faster to compute the position of any element
    in the array using **offset** and **base address**. The term *base address* refers
    to the address of memory location where the first element is stored, and offset
    refers to an integer indicating the displacement between the first element and
    a given element.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4.1* demonstrates an array holding a sequence of seven integer values
    that are stored sequentially in contiguous memory locations. The first element
    (data value 3) is stored at index 0, the second element at index position 1, and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Representation of a one-dimensional array'
  prefs: []
  type: TYPE_NORMAL
- en: To store, traverse, and access array elements is very fast as compared to lists
    since elements can be accessed randomly using their index positions, whereas in
    the case of a linked list, the elements are accessed sequentially. Therefore,
    if the data to be stored in the array is large and the system has low memory,
    the array data structure will not be a good choice to store the data because it
    is difficult to allot a large block of memory locations. The array data structure
    has further limitations in that it has a static size that has to be declared at
    the time of creation.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the insertion and deletion operations in array data structures
    are slow as compared to linked lists. This is because it is difficult to insert
    an element in an array at a given location since all data elements after that
    desired position must be shifted and then new elements inserted in between. Thus,
    array data structures are suitable when we want to do a lot of accessing of elements
    and fewer insertion and deletion operations, whereas linked lists are suitable
    in applications where the size of the list is not fixed, and a lot of insertion
    and deletion operations will be required.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The linked list is an important and popular data structure with the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The data elements are stored in memory in different locations that are connected
    through pointers. A pointer is an object that can store the memory address of
    a variable, and each data element points to the next data element and so on until
    the last element, which points to `None`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The length of the list can increase or decrease during the execution of the
    program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Contrary to arrays, linked lists store data items sequentially in different
    locations in memory, wherein each data item is stored separately and linked to
    other data items using pointers. Each of these data items is called a node. More
    specifically, a node stores the actual data and a pointer. In *Figure 4.2*, nodes
    A and B store the data independently, and node A is connected to node B.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: A linked list with two nodes'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the nodes can have links to other nodes based differently on how we
    want to store the data, and on which basis we will learn various kinds of data
    structures, such as singular linked lists, doubly linked lists, circular link
    lists, and trees.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes and pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A node is a key component of several data structures such as linked lists. A
    node is a container of data, together with one or more links to other nodes where
    a link is a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, let us consider an example of creating a linked list of two nodes
    that contains data (for example, strings). For this, we first declare the variable
    that stores the data along with pointers that point to the next variable. Consider
    the example in the following *Figure 4.3*, in which there are two nodes. The first
    node has a pointer to the string (**eggs**), and another node pointing to the
    **ham** string.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the first node that points to the **eggs** string has a link to
    another node. Pointers are used to store the address of a variable, and since
    the string is not actually stored in the node, rather, the address of the string
    is stored in the node.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17217_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: A sample linked list of two nodes'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we can also add a new third node to this existing linked list that
    stores spam as a data value, while a second node points to the third node, as
    shown in *Figure 4.4*. Hence, *Figure 4.3* demonstrates the structure of three
    nodes having data strings, in other words, **eggs**, **ham**, and **spam**, which
    are stored sequentially in a linked list.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: A sample linked list of three nodes'
  prefs: []
  type: TYPE_NORMAL
- en: So, we have created three nodes—one containing **eggs**, one **ham**, and another
    **spam**. The **eggs** node points to the **ham** node, which in turn points to
    the **spam** node. But what does the **spam** node point to? Since this is the
    last element in the list, we need to make sure its next member has a value that
    makes this clear. If we make the last element point to nothing, then we make this
    fact clear. In Python, we will use the special value **None** to denote nothing.
    Consider *Figure 4.5*. Node **B** is the last element in the list, and thus it
    is pointing to **None**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17217_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: A linked list with two nodes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first learn about the implementation of the node, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, the **next** pointer is initialized to `None`, meaning that unless we
    change the value of **next**, the node is going to be an endpoint, meaning that
    initially, any node that is attached to the list will be independent.
  prefs: []
  type: TYPE_NORMAL
- en: You can also add any other data items to the node class if required. If your
    node is going to contain customer data, then create a `Customer` class and place
    all the data there.
  prefs: []
  type: TYPE_NORMAL
- en: There are three kinds of list—a singly linked list, a doubly linked list, and
    a circular linked list. First of all, let’s discuss singly linked lists.
  prefs: []
  type: TYPE_NORMAL
- en: We need to learn the following operations in order to use any linked lists in
    real-time applications.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inserting a data item in the list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a new data item (node) at the beginning
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a new data item (node) at the end of the list
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a new data item (node) in the middle/or at any given position in the
    list
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deleting an item from the list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting the first node
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting the last node
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a node in the middle/or at any given position in the list
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be discussing these important operations on different types of linked
    lists in subsequent subsections, along with their implementations, using Python.
    Let us start with singly linked lists.
  prefs: []
  type: TYPE_NORMAL
- en: Singly linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A linked list (also called a singly linked list) contains a number of nodes
    in which each node contains data and a pointer that links to the next node. The
    link of the last node in the list is `None`, which indicates the end of the list.
    Refer to the following linked list in *Figure 4.6*, in which a sequence of integers
    is stored.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: An example of a singly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discuss how to create a singly linked list, and how to traverse it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and traversing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to implement the singly linked list, we can use the node class that
    we created in the previous section. For example, we create three nodes, `n1`,
    `n2`, and `n3`, that store three strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we link the nodes sequentially to form the linked list. For example,
    in the following code, node `n1` is pointing to node `n2`, node `n2` is pointing
    to node `n3`, and node `n3` is the last node, and is pointing to **None**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Traversal of the linked lists means visiting all the nodes of the list, from
    the starting node to the last node. The process of traversing the singly linked
    list begins with the first node, displaying the data of the current node, following
    the pointers, and finally stopping when we reach the last node.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the traversal of the linked list, we start by setting the `current`
    variable to the first item (starting node) in the list, and then we traverse the
    complete list through a loop, traversing each node as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the loop, we print out the current element after which we set `current`
    to point to the next element in the list. We keep doing this until we reach the
    end of the list. The output of the preceding code for this example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are, however, several problems with this simplistic list implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: It requires too much manual work by the programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Too much of the inner workings of the list is exposed to the programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let us discuss a better and more efficient way of traversing the linked
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Improving list creation and traversal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you will notice in the earlier example of the list traversal, we are exposing
    the node class to the client/user. However, the client node should not interact
    with the node object. We need to use `node.data` to get the contents of the node,
    and `node.next` to get the next node. We can access the data by creating a method
    that returns a generator, which can be done using the `yield` keyword in Python.
    The updated code snippet for list traversal is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `yield` keyword is used to return from a function while saving the
    states of its local variables to enable the function to resume from where it left
    off. Whenever the function is called again, the execution starts from the last
    yield statement. Any function that contains a yield keyword is termed a **generator**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, list traversal is much simpler. We can completely ignore the fact that
    there is anything called a node outside of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice that since the `iter()` method yields the data member of the node, our
    client code doesn’t need to worry about that at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'A singly linked list can be created using a simple class to hold the list.
    We start with a constructor that holds a reference to the very first node in the
    list (that is `head` in the following code). Since this list is initially empty,
    we will start by setting this reference to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we start with an empty list that points to `None`. Now,
    new data elements can be appended/added to this list.
  prefs: []
  type: TYPE_NORMAL
- en: Appending items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first operation that we need to perform is to `append` items to the list.
    This operation is also called an `insertion` operation. Here we get a chance to
    hide the `Node` class away. The user of the list class should never have to interact
    with `Node` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Appending items to the end of a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s have a look at the Python code for creating a linked list where we append
    new elements to the list using the `append()` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first shot at an `append()` method may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, in this code, we encapsulate data in a node so that it has the next pointer
    attribute. From here, we check if there are any existing nodes in the list (that
    is, whether `self.head` points to a `Node`). If there is `None`, this means that
    initially, the list is empty and the new node will be the first node. So, we make
    the new node the first node of the list; otherwise, we find the insertion point
    by traversing the list to the last node and updating the next pointer of the last
    node to the new node. This working is depicted in *Figure 4.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Inserting a node at the end of the list in a singly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example code to append three nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'List traversal will work as we discussed before. You will get the first element
    of the list from the list itself, and then traverse the list through the `next`
    pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Still, this implementation is not very efficient, and there is a drawback with
    the append method. In this, we have to traverse the entire list to find the insertion
    point. This may not be a problem when there are just a few items in the list,
    but it will be very inefficient when the list is long, as it will have to traverse
    the whole list to add an item every time. Let us discuss a better implementation
    of the `append` method.
  prefs: []
  type: TYPE_NORMAL
- en: For this, the idea is that we not only have a reference to the first node in
    the list but also have one more variable in the node that references the last
    node of the list. That way, we can quickly append a new node at the end of the
    list. The worst-case running time of the append operation can be reduced from
    `O(n)` to `O(1)` using this method. We must ensure that the previous last node
    points to the new node that is to be appended to the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our updated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Take note of the convention being used. The point at which we append new nodes
    is through `self.tail`. The `self.head` variable points to the first node in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: In this code, a new node can be appended in the end through a `tail` pointer
    by making a link from the last node to the new node. *Figure 4.8* shows the workings
    of the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Illustrating the insertion of a node at the end of a linked list'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4.8*, *step 1* shows the addition of the new node at the end, and
    *step 2* shows when the list is empty. In that case, `head` is made the new node,
    with `tail` pointing to that node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, the following code snippet shows the workings of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Appending items at intermediate positions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To append or insert an element in an existing linked list at a given position,
    firstly, we have to traverse the list to reach the desired position where we want
    to insert an element. An element can be inserted in between two successive nodes
    using two pointers (`prev` and `current`).
  prefs: []
  type: TYPE_NORMAL
- en: A new node can easily be inserted in between two existing nodes by updating
    these links, as shown in *Figure 4.9*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Insertion of a node between two successive nodes in a linked list'
  prefs: []
  type: TYPE_NORMAL
- en: When we want to insert a node in between two existing nodes, all we have to
    do is update two links. The previous node points to the new node, and the new
    node should point to the successor of the previous node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the complete code below to add a new element at a given index
    position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we start from the first node and move the current pointer
    to reach the index position where we want to add a new element, and then we update
    the node pointers accordingly. In the `if` condition, firstly, we check whether
    the index position is `1`. In that case, we have to update the nodes as we are
    adding the new node at the start of the list. Therefore, we have to make the new
    node a `head` node. Next, in the `else` part, we check whether we have reached
    the required index position by comparing the value of `count` and `index`. If
    both values are equal, we add a new node in between nodes indicated by `prev`
    and `current` and update the pointers accordingly. Finally, we print an appropriate
    message if the required index position is greater than the length of the linked
    list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that the condition where we may want to insert a new
    element can change depending upon the requirement, so let’s say we want to insert
    a new element just before an element that has the same data value. In that case,
    the code to `append_at_a_position` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the preceding code to insert a new node at an intermediate position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The worst-case time complexity of the `insert` operation is `O(1)` when we have
    an additional pointer that points to the last node. Otherwise, when we do not
    have the link to the last node, the time complexity will be `O(n)` since we have
    to traverse the list to reach the desired position and in the worst case, we may
    have to traverse all the *n* nodes in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Querying a list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the list is created, we may require some quick information about the linked
    list, such as the size of the list, and occasionally to establish whether a given
    data item is present in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Searching an element in a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We may also need to check whether a list contains a given item. This can be
    implemented using the `iter()` method, which we have already seen in the previous
    section while traversing the linked list. Using that, we write the search method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, each pass of the loop compares the data to be searched with
    each data item in the list one by one. If a match is found, `True` is returned,
    otherwise `False` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the following code for searching a given data item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Getting the size of the list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is important to get the size of the list by counting the number of nodes.
    One way to do it is by traversing the entire list and increasing the counter as
    we go along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The above code is very similar to what we did while traversing the linked list.
    Similarly, in this code, we traverse the nodes of the list one by one and increase
    the `count` variable. However, list traversal is potentially an expensive operation
    that we should avoid wherever we can.
  prefs: []
  type: TYPE_NORMAL
- en: 'So instead, we can opt for another method in which we can add a size member
    to the `SinglyLinkedList` class, initializing it to `0` in the constructor, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Because we are now only reading the size attribute of the node object, and not
    using a loop to count the number of nodes in the list, we reduce the worst-case
    running time from `O(n)` to `O(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another common operation on a linked list is to delete nodes. There are three
    possibilities that we may encounter in order to delete a node from the singly
    linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting the node at the beginning of the singly linked list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Deleting a node from the beginning is quite easy. It involves updating the
    `head` pointer to the second node in the list. This can be done in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A temporary pointer (`current` pointer) is created that points to the first
    node (`head` node), as shown in *Figure 4.10*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17217_04_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Illustration of the deletion of the first node from the linked
    list'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `current` node pointer is moved to the next node and assigned to the
    `head` node. Now, the second node becomes the `head` node that is pointed to by
    the `head` pointer, as shown in *Figure 4.11*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17217_04_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: After deleting the first node, the head pointer now points to
    the new starting element'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be implemented using the following Python code. In this code, initially,
    three data elements are added as we have done previously, and then the first node
    of the list is deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above code, we initially check if there is no item to delete from the
    list, and we print the appropriate message. Next, if there is some data item in
    the list, we assign the `head` pointer to the temporary pointer current as per
    *step 1*, and then the `head` pointer is now pointing to the next node, assuming
    that we already have a linked list of three data items – “eggs”, “ham”, and “spam”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Deleting the node at the end in the singly linked list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To delete the last node from the list, we have to first traverse the list to
    reach the last node. At that time, we also need an extra pointer that points to
    just one node before the last node, so that after deleting the last node, the
    second last node can be marked as the last node. It can be implemented in the
    following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we have two pointers, in other words, a `current` pointer that will
    point to the last node, and a `prev` pointer that will point to the node previous
    to the last node (second last node). Initially, we will have three pointers (`current`,
    `prev`, and `head`) pointing to the first node, as shown in *Figure 4.12*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17217_04_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Illustration of the deletion of the end node from the linked list'
  prefs: []
  type: TYPE_NORMAL
- en: To reach the last node, we move the `current` and `prev` pointers in such a
    way that the `current` pointer should point to the last node and the `prev` pointer
    should point to the second last node. So, we stop when the `current` pointer reaches
    the last node. This is shown in *Figure 4.13*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17217_04_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: Traversal of the linked list to reach the end of the list'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we mark the `prev` pointer to point to the second last node, which
    is rendered as the last node of the list by pointing this node to `None`, as shown
    in *Figure 4.14*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17217_04_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: Deletion of the last node from the linked list'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation in Python for deleting a node from the end of the list is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, firstly, the `current` and `prev` pointers are assigned
    the `head` pointer as per *step 1*. Then, in the `while` loop, we check whether
    we reached the end of the list using the `current.next is None` condition. Once
    we reach the end of the list, we make the second last node, which is indicated
    by the `prev` pointer, the last node. We also decrement the size of the list.
    If we do not reach the end of the list, we increment the `prev` and `current`
    pointers in the `while` loop in the last two lines of code. Next, let us discuss
    how to delete any intermediate node in a singly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting any intermediate node in a singly linked list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We first have to decide how to select a node for deletion. Identifying the intermediate
    node to be deleted can be determined by the index number or by the data the node
    contains. Let us understand this concept by deleting a node depending on the data
    it contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete any intermediary node, we need two pointers similar to the case when
    we learned to delete the last node; in other words, the `current` pointer and
    the `prev` pointer. Once we reach the node that is to be deleted, the desired
    node can be deleted by making the previous node point to the next node of the
    node that is to be deleted. The process is provided in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4.15* shows when an intermediate node is deleted from the given linked
    list. In this, we can see that the initial pointers point to the first node.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17217_04_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: Illustration of the deletion of an intermediate node from the
    linked list'
  prefs: []
  type: TYPE_NORMAL
- en: Once the node is identified, the `prev` pointer is updated to delete the node,
    as shown in *Figure 4.16*. The node to be deleted is shown along with the link
    to those to be updated in *Figure 4.16*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17217_04_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: Traversing to reach the intermediate node that is to be deleted
    in the linked list'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the list after deleting the node is shown in *Figure 4.17*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17217_04_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: Deletion of an intermediate node from the linked list'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we want to delete a data element that has the given value. For this
    given condition, we can first search the node to be deleted and then delete the
    node as per the steps discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the implementation of the `delete()` method may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that we already have a linked list of three items – “eggs”, “ham”,
    and “spam”, the following code is for executing the delete operation, that is,
    deleting a data element with the value “ham” from the given linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The worst-case time complexity of the `delete` operation is `O(n)` since we
    have to traverse the list to reach the desired position and, in the worst-case
    scenario, we may have to traverse all the *n* nodes in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We may need to clear a list quickly, and there is a very simple way to do this.
    We can clear a list by simply clearing the pointer head and tail by setting them
    to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we can clear the list by assigning `None` to the `tail` and
    `head` pointers.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed different operations for a singly linked list, and now we
    will discuss the concept of doubly linked list and learn how different operations
    can be implemented in a doubly linked list in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A doubly linked list is quite similar to the singly linked list in the sense
    that we use the same fundamental concept of nodes along with how we can store
    data and links together, as we did in a singly linked list. The only difference
    between a singly linked list and a doubly linked list is that in a singly linked
    list, there is only one link between each successive node, whereas, in a doubly
    linked list, we have two pointers—a pointer to the next node and a pointer to
    the previous node. See the following *Figure 4.18* of a node; there is a pointer
    to the next node and the previous node, which are set to `None` as there is no
    node attached to this node.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18: Represents a doubly linked list with a single node'
  prefs: []
  type: TYPE_NORMAL
- en: A node in a singly linked list can only determine the next node associated with
    it. However, there is no link to go back from this referenced node. The direction
    of flow is only one way. In a doubly linked list, we solve this issue and include
    the ability not only to reference the next node, but also to reference the previous
    node. Consider the following *Figure 4.19* to understand the nature of the linkages
    between two successive nodes. Here, node **A** is referencing node **B**; in addition,
    there is also a link back to node **A**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.19: Doubly linked list with two nodes'
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked lists can be traversed in any direction. A node in a doubly linked
    list can be easily referred to by its previous node whenever required without
    having a variable to keep track of that node.
  prefs: []
  type: TYPE_NORMAL
- en: However, in a singly linked list, it may be difficult to move back to the start
    or beginning of the list to make some changes at the start of the list, which
    is very easy now in the case of a doubly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and traversing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python code to create a doubly linked list node includes its initializing
    methods, the `prev` pointer, the `next` pointer, and the `data` instance variables.
    When a node is newly created, all these variables default to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `prev` variable has a reference to the previous node, while the `next` variable
    keeps the reference to the next node, and the `data` variable stores the data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s create a doubly linked list class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The doubly linked list class has two pointers, `head` and `tail`, that will
    point to the start and end of the doubly linked list, respectively. In addition,
    for the size of the list, we set the count instance variable to `0`. It can be
    used to keep track of the number of items in the linked list. Consider the following
    Python code for creating a doubly linked list class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, `self.head` points to the beginner node of the list, and `self.tail` points
    to the last node. However, there are no fixed rules as to the naming of the head
    and tail node pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked lists also require functionalities that return the size of the
    list, insert items into the list, and delete nodes from the list. Next, we discuss
    different operations that can be applied to the doubly linked list. Let’s start
    with the append operation.
  prefs: []
  type: TYPE_NORMAL
- en: Appending items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `append` operation is used to add an element at the end of a list. An element
    can be appended or inserted into a doubly linked list in the following instances.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a node at beginning of the list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Firstly, it is important to check whether the `head` node of the list is `None`.
    If it is `None`, this means that the list is empty, otherwise the list has some
    nodes, and a new node can be appended to the list. If a new node is to be added
    to the empty list, it should have the `head` pointer pointing to the newly created
    node, and the tail of the list should also point to this newly created node.
  prefs: []
  type: TYPE_NORMAL
- en: The following *Figure 4.20* illustrates the `head` and `tail` pointers of the
    doubly linked list when a new node is added to an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.20: Illustration of inserting a node in an empty doubly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can insert or append a new node at the beginning of an existing
    doubly linked list, as shown in *Figure 4.21*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.21: Illustration of inserting an element in a doubly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: The new node should be made as a new starting node of the list and that should
    now point to the previous `head` node.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be done by updating the three links, which are also shown with dotted
    lines in *Figure 4.22* and described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the `next` pointer of a new node should point to the `head` node of
    the existing list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `prev` pointer of the `head` node of the existing list should point to the
    new node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, mark the new node as the `head` node in the list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17217_04_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.22: Inserting a node at the beginning of the doubly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is used to append/insert an item at the beginning when the
    list is initially empty and with an existing doubly linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, firstly, the `self.head` condition is checked irrespective
    of whether the list is empty. If it is empty, then the head and tail pointers
    point to the newly created node. In this case, the new node becomes the `head`
    node. Next, if the condition is not true, this means the list is not empty, and
    a new node has to be added at the beginning of the list. For this, three links
    are updated as shown in *Figure 4.22*, and also shown in the code in bold font.
    After updating these three links, finally, the size of the list is increased by
    `1`. Furthermore, let us understand how to insert an element at the end of the
    doubly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, the following code snippet shows how we can create a double link list
    and append a new node at the starting of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the output, we can see that the new data item “`book`" is added in the starting
    of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a node at the end of the list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To append/insert a new element at the end of the doubly linked list, we will
    need to traverse through the list to reach the end of the list if we do not have
    a separate pointer pointing to the end of the list. Here, we have a `tail` pointer
    that points to the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: A visual representation of the append operation to an existing list is shown
    in the following *Figure 4.23*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.23: Inserting a node at the end of the list in a doubly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new node at the end, we update two links as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the `prev` pointer of the new node point to the previous `tail` node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the previous `tail` node point to the new node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, update the `tail` pointer so that the `tail` pointer now points to
    the new node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code is used to append an item at the end of the doubly linked
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above code, the `if` part of the preceding program is for adding a node
    to the empty list; the `else` part of the preceding program will be executed if
    the list is not empty. If the new node is to be added to a list, the new node’s
    previous variable is to be set to the tail of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The tail’s next pointer (or variable) has to be set to the new node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we update the tail pointer to point to the new node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Since an append operation increases the number of nodes by one, we increase
    the counter by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet can be used to append a node at the end of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The worst-case time complexity of appending an element to the doubly linked
    list is `O(1)` since we already have the tail pointer that points to the end of
    the list, and we can directly add a new element. Next, we will discuss how to
    insert a node at an intermediate position of the doubly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a node at an intermediate position in the list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inserting a new node at any given position in a doubly linked list is similar
    to what we discussed in a singly linked list. Let us take an example in which
    we insert a new element just before the element that has the same data value as
    the given data.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we traverse to the position where we want to insert a new element in
    that situation. The `current` pointer points to the target node, while the `prev`
    pointer just points to the previous node of the target node, as shown in *Figure
    4.24*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.24: Illustration of pointers for inserting a node at an intermediate
    position in a doubly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: 'After reaching the correct position, a few pointers have to be added in order
    to add a new node. The details of these links that need to be updated (also shown
    in *Figure 4.25*) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `next` pointer of the new node points to the current node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `prev` pointer of the new node should point to the previous node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `next` pointer of the previous node should point to the new node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `prev` pointer of the current node should point to the new node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17217_04_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.25: Demonstration of links that need to be updated in order to add
    a new node at any intermediate position in the list'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the implementation of the `append_at_a_location()` method may
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, firstly, the `current` and `prev` pointers are initialized
    by pointing to the `head` node. Then, in the `while` loop, we first reach the
    desired position by checking the condition. In this example, we check the data
    value of the current node against the data value provided by the user. Once we
    reach the desired position, we update four links as discussed, which are also
    shown in *Figure 4.25*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Appending at the start and end positions in a doubly linked list will have a
    worst-case running time complexity of `O(1)` since we can directly append the
    new node, and the worst-case time complexity for appending a new node at any intermediate
    position will be `O(n)` since we may have to traverse the list of *n* items.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us learn how to search a given item if that is present in the doubly
    linked list or not.
  prefs: []
  type: TYPE_NORMAL
- en: Querying a list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The search for an item in a doubly linked list is similar to the way we did
    it in the singly linked list. We use the `iter()` method to check the data in
    all the nodes. As we run a loop through all the data in the list, each node is
    matched with the data passed in the `contain` method. If we find the item in the
    list, `True` is returned, denoting that the item is found, otherwise `False` is
    returned, which means the item was not found in the list. The Python code for
    this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code can be used to search if a data item is present in the existing
    doubly linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The search operation in a doubly linked list has a running time complexity of
    `O(n)` since we have to traverse the list in order to reach the desired element
    and, in the worst case, we may have to traverse the whole list of *n* items.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The deletion operation is easier in the doubly linked list compared to the singly
    linked list. Unlike in a singly linked list, where we need to traverse the linked
    list to reach the desired position, and we also need one more pointer to keep
    track of the previous node of the target node, in a doubly linked list, we don’t
    have to do that because we can traverse in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `delete` operation in a doubly linked list can have four scenarios, which
    are discussed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The item to be deleted is located at the start of the list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The item to be deleted is found at the tail end of the list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The item to be deleted is located anywhere at an intermediate position in the
    list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The item to be deleted is not found in the list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The node to be deleted is identified by matching the data instance variable
    with the data that is passed to the method. If the data matches the data variable
    of a node, that matching node will be deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: For the first scenario, when we have found the item to be deleted at the first
    position, we will have to simply update the `head` pointer to the next node. It
    is shown in *Figure 4.26*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17217_04_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.26: Illustration of the deletion of the first node in a doubly linked
    list'
  prefs: []
  type: TYPE_NORMAL
- en: For the second scenario, when we found the item to be deleted at the last position
    in the list, we will have to simply update the `tail` pointer to the second last
    node. It is shown in *Figure 4.27*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17217_04_27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.27: Illustration of the deletion of the last node in a doubly linked
    list'
  prefs: []
  type: TYPE_NORMAL
- en: For the third scenario, we found the data item to be deleted at any intermediate
    position. To better understand this, consider the example shown in *Figure 4.28*.
    In this, there are three nodes, **A**, **B**, and **C**. To delete node **B**
    in the middle of the list, we will essentially make **A** point to node **C**
    as its next node, while making **C** point to **A** as its previous node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17217_04_28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.28: Illustration of the deletion of the intermediate node B from the
    doubly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete implementation to delete a node from the doubly linked list in
    Python is as follows. We’ll discuss each part of this code step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Initially, we create a `node_deleted` variable to denote the deleted node in
    the list and this is initialized to `False`. The `node_deleted` variable is set
    to `True` if a matching node is found and subsequently removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `delete` method, the `current` variable is initially set to the `head`
    node of the list (that is, it points to the `self.head` node of the list). This
    is shown in the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Next, we use a set of `if...else` statements to search various parts of the
    list to ascertain the node with the specified data that is to be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we search for the data to be deleted at the `head` node, and
    if the data is matched at the `head` node, this node would be deleted. Since `current`
    is pointing at `head`, if `current` is `None`, this means that the list is empty
    and has no nodes to find the node to be deleted. The following is its code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if `current` (which now points to `head`) contains the data being
    searched for, this means that we found the data to be deleted at the `head` node,
    and `self.head` is then marked to point to the `current.next` node. Since there
    is now no node behind `head`, `self.head.prev` is set to `None`. Consider the
    following code snippet for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if the node that is to be deleted is found at the `tail` end of
    the list, we delete the last node by setting its previous node pointing to `None`.
    `self.tail` is set to point to `self.tail.prev`, and `self.tail.next` is set to
    `None` as there is no node afterward. Consider the following code fragment for
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we search for the node to be deleted by looping through the entire list
    of nodes. If the data that is to be deleted is matched with a node, that node
    will be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete a node, we make the previous node of the `current` node point to
    the next node using the `current.prev.next = current.next` code. After that step,
    we make the current’s next node point to the previous node of the `current` node
    using `current.next.prev = current.prev`. Furthermore, if we traverse the complete
    list, and the desired item is not found, we print the appropriate message. Consider
    the following code snippet for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `node_delete` variable is then checked to ascertain whether a
    node is actually deleted. If any node is deleted, then we decrease the count variable
    by `1`, and this keeps track of the total number of nodes in the list. See the
    following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This decrements the count variable by `1` in case any node is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take an example to see how the delete operation works with the same example
    of adding three strings – “egg”, “ham”, and “spam”, and then a node with the value
    “ham” is deleted from the list. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The worst-case running time complexity of the delete operation is `O(n)` since
    we may have to traverse the list of *n* items to search for the item to be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn different operations on a circular linked
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Circular lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A circular linked list is a special case of a linked list. In a circular linked
    list, the endpoints are connected, which means that the last node in the list
    points back to the first node. In other words, we can say that in circular linked
    lists, all the nodes point to the next node (and the previous node in the case
    of a doubly linked list) and there is no end node, meaning no node will point
    to `None`.
  prefs: []
  type: TYPE_NORMAL
- en: The circular linked lists can be based on both singly and doubly linked lists.
    Consider *Figure 4.29* for the circular linked list based on a singly linked list
    where the last node, **C**, is again connected to the first node **A**, thus making
    a circular list.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.29: Example of a circular list based on a singly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a doubly linked circular list, the first node points to the last
    node, and the last node points back to the first node. *Figure 4.30* shows the
    concept of the circular linked list based on a doubly linked list where the last
    node **C** is again connected to the first node **A** through the `next` pointer.
    Node **A** is also connected to node **C** through the `previous` pointer, thus
    making a circular list.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.30: Example of a circular list based on a doubly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to look at an implementation of a singly linked circular list.
    It is very straightforward to implement a doubly linked circular list once we
    understand the basic concepts of singly and doubly linked lists.
  prefs: []
  type: TYPE_NORMAL
- en: Almost everything is similar except that we should be careful in managing the
    link of the last node to the first node.
  prefs: []
  type: TYPE_NORMAL
- en: We can reuse the node class that we created in the singly linked lists subsection.
    We can reuse most parts of the `SinglyLinkedList` class as well. So, we are going
    to focus on where the circular list implementation differs from the normal singly
    linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and traversing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The circular linked list class can be created using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, initially in the circular linked list class, we have two
    pointers; `self.tail` is used to point to the last node, and `self.head` is used
    to point to the first node of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Appending items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we want to add a node at the end of a circular linked list, as shown in
    *Figure 4.31*, in which we have four nodes, wherein the head is pointing to the
    starting node and the tail is pointing to the last node.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.31: Example of a circular linked list for adding a node at the end'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4.32* shows how a node is added to a circular linked list.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_04_32.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.32: Inserting a node at the end of the singly circular list'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a node at the end, we will update three links:'
  prefs: []
  type: TYPE_NORMAL
- en: The `next` pointer of the last node to point to a new node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `next` pointer of a new node to point to the `head` node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `tail` pointer to point to the new node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The implementation of the circular linked list to append an element at the
    end of the circular list based on a singly linked list is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, firstly, we check whether the list is empty. If the list
    is empty, we go to the `else` part of the above code. In this case, the new node
    will be the first node of the list, and both the `head` and `tail` pointers will
    point to the new node, while the `next` pointer of the new node will again point
    to the new node.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, if the list is not empty, we go to the `if` part of the preceding
    code. In this case, we update the three pointers as shown in *Figure 4.32*. This
    is similar to what we did in the case of the single linked list. Only one link
    is additionally added in this case, which is shown in bold font in the preceding
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, we can use `iter()` method traverse all the elements of the list,
    The `iter()` method described below should be defined in `CircularList` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The below code can be used to create a singly circular linked list, and then
    print all the data elements of the list, and then we stop when the counter becomes
    3 which is the length of the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Appending any element at an intermediate position in a circular list is exactly
    to its implementation in a singly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Querying a list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Traversing a circular linked list is very convenient as we don’t need to look
    for the starting point. We can start anywhere, and we just need to carefully stop
    traversing when we reach the same node again. We can use the same `iter()` method,
    which we discussed at the start of this chapter. This will also be the case for
    the circular list; the only difference is that we have to mention an exit condition
    when we are iterating through the circular list, otherwise the program will get
    stuck in a loop, and it will run indefinitely. We can make any exit condition
    dependent upon our requirements; for example, we can use a counter variable. Consider
    the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we add three strings of data to the circular linked list,
    and then we print the data values iterating through the list 100 times.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let us understand how the `delete` operation works in a
    circular linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an element in a circular list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To delete a node in a circular list, it looks like we can do it similarly to
    how we did in the case of the append operation—simply make sure that the last
    node through the `tail` pointer points back to the starting node of the list through
    the `head` pointer. We have the following three scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the item to be deleted is the `head` node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this scenario, we have to ensure that we make the second node of the list
    the new `head` node (shown as *step 1* in *Figure 4.33*), and the last node should
    be pointing back to the new head (shown as *step 2* in *Figure 4.33*).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B17217_04_33.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.33: Deletion of a starting node in a singly circular list'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When the item to be deleted is the `last` node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this scenario, we have to ensure that we make the second last node the new
    tail node (shown as *step 1* in *Figure 4.34*), while the new tail node should
    be pointing back to the new head (shown as *step 2* in *Figure 4.34*).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B17217_04_34.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.34: Deletion of the last node in a singly circular list'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When the item to be deleted is an intermediate node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is very similar to what we did in the singly linked list. We have to make
    a link from the previous node of the target node to the next node of the target
    node, as shown in *Figure 4.35*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B17217_04_35.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.35: Deletion of any intermediate node in a singly circular list'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The implementation of the `delete` operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, firstly, iterate over all the elements to search the
    desired element to be deleted. Here, it is important to note the stopping condition.
    If we simply check the `current` pointer to be equal to `None` (which we did in
    the singly linked list), the program will go into an indefinite loop since the
    current node will never point to `None` in the case of circular linked lists.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we cannot check whether `current` has reached `tail` because then
    it will never check the last node. So, the stopping criterion in the circular
    list is the fact that the `prev` and `current` pointers point to the same node.
    It will work fine except on one occasion when the first loop iteration, at that
    time, `current` and `prev`, will point to the same node, in other words, the `head`
    node.
  prefs: []
  type: TYPE_NORMAL
- en: Once, we enter the loop, we check the data value of the current pointer with
    the given data value to get the node to be deleted. We check whether the node
    to be deleted is the `head` node, tail node, or intermediate node, and then update
    the appropriate links shown in *Figures 4.33*, *4.34*, and *4.35*.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have discussed the different scenarios while deleting any node in singly
    circular linked list, similarly, the doubly linked list based circular linked
    list can be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be used to create a circular linked list, and apply
    different delete operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The worst-case time complexity of inserting an element at a given location in
    the circular linked list is `O(n)` since we have to traverse the list to the desired
    location. The complexity of insertion at the first and last locations of the circular
    list will be `O(1)`. Similarly, the worst-case time complexity to delete an element
    at a given location is `O(n)`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have discussed the different scenarios while deleting any node in
    a singly circular linked list. Similarly, the doubly linked list can be implemented
    based on a circular linked list.
  prefs: []
  type: TYPE_NORMAL
- en: In a singly linked list, the traversal of nodes can be done in one direction,
    whereas, in a doubly linked list, it is possible to traverse in both directions
    (forward and backward). In both cases, the complexity of the insertion and deletion
    operations at a given location is `O(n)` whenever we have to traverse the list
    in order to reach the desired location where we want to insert or delete any element.
    Similarly, the worst-case time complexity of the insertion or deletion of a node
    for a given desired location is `O(n)`. Whenever we need to save memory space,
    we should use a singly linked list since it only needs one pointer, whereas a
    doubly linked list takes more memory space to store double pointers. When a search
    operation is important, we should use a doubly linked list since it is possible
    to search in both directions. Furthermore, the circular linked list should be
    used when we have an application when we need to iterate over the nodes in the
    list. Let us now see more real-world applications of linked lists.
  prefs: []
  type: TYPE_NORMAL
- en: Practical applications of linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of now, we have discussed singly linked lists, circular linked lists, and
    doubly linked lists. Depending upon what kind of operations (insertion, deletion,
    updating, and so on) will be required in different applications, these data structures
    are used accordingly. Let’s see a few real-time applications where these data
    structures are being used.
  prefs: []
  type: TYPE_NORMAL
- en: Singly linked lists can be used to represent any sparse matrix. Another important
    application is to represent and manipulate polynomials by accumulating constants
    in the node of linked lists.
  prefs: []
  type: TYPE_NORMAL
- en: It can also be used in implementing a dynamic memory management scheme that
    allows the user to allocate and deallocate the memory as per requirements during
    the execution of programs.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, doubly linked lists are used by the thread schedular in the
    operating system to maintain the list of processes running at that time. These
    lists are also used in the implementation of **MRU** (most recently used) and
    **LRU** (least recently used) cache in the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked lists can also be used by various applications to implement **Undo**
    and **Redo** functionality. The browsers can use these lists to implement backward
    and forward navigation of the web pages visited.
  prefs: []
  type: TYPE_NORMAL
- en: A circular linked list can be used by operating systems to implement a round-robin
    scheduling mechanism. Another application of circular linked lists is to implement
    **Undo** functionality in Photoshop or Word software and use it in implementing
    a browser cache that allows you to hit the **BACK** button. Besides that, it is
    also used to implement advanced data structures such as the Fibonacci heap. Multiplayer
    games also use a circular linked list to swap between players in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied the concepts that underlie lists, such as nodes
    and pointers to other nodes. We have discussed singly linked lists, doubly linked
    lists, and circular linked lists. We have seen various operations that can be
    applied to these data structures and their implementations using Python.
  prefs: []
  type: TYPE_NORMAL
- en: These types of data structures have certain advantages over arrays. In the case
    of arrays, insertion and deletion are quite time-consuming as these operations
    require the shifting of elements downward and upward, respectively, due to contiguous
    memory allocations. On the other hand, in the case of linked lists, these operations
    require only changes in pointers. Another advantage of linked lists over arrays
    is the allowance of a dynamic memory management scheme that allocates memory during
    the runtime as and when needed, while the array is based on a static memory allocation
    scheme.
  prefs: []
  type: TYPE_NORMAL
- en: The singly linked list can traverse in a forward direction only, while traversal
    in doubly linked lists is bidirectional, hence the reason why the deletion of
    a node in a doubly linked list is easy compared to a singly linked list. Similarly,
    circular linked lists save time while accessing the first node from the last node
    as compared to the singly linked list. Thus, each list has its advantages and
    disadvantages. We should use them as per the requirements of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to look at two other data structures that
    are usually implemented using lists—stacks and queues.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What will be the time complexity when inserting a data element after an element
    that is being pointed to by a pointer in a linked list?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What will be the time complexity when ascertaining the length of the given linked
    list?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What will be the worst-case time complexity for searching a given element in
    a singly linked list of length n?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a given linked list, assuming it has only one `head` pointer that points
    to the starting point of the list, what will be the time complexity for the following
    operations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insertion at the front of the linked list
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Insertion at the end of the linked list
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Deletion of the front node of the linked list
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Deletion of the last node of the linked list
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the n^(th) node from the end of a linked list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you establish whether there is a loop (or circle) in a given linked
    list?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you ascertain the middle element of the linked list?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1421249772551223062.png)'
  prefs: []
  type: TYPE_IMG
