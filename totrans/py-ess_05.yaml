- en: Chapter 5. Logic, Comparisons, and Conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our exploration of the Python language started with expression statements and
    the assignment statement. We can view output using the `print()` function as a
    simple statement. We can gather input using the `input()` function in an assignment
    statement. In order to process data conditionally, we need the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to look at the `if` statement, we''ll need to look at Boolean data
    and Boolean operators. The `and`, `or`, `not`, and `if-else` Boolean operators
    have a "short-circuit" behavior: if the result is defined by just the left-hand
    operand, the right-hand side is not evaluated. This is an important feature of
    these logic operators. (The `if-else` operator is formally called the **Boolean
    expression**, but it behaves like the Boolean operators.)'
  prefs: []
  type: TYPE_NORMAL
- en: We'll also look at the comparison operators. A comparison is a common way to
    create the Boolean values used to choose between suites of statements within an
    `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: We'll introduce the `pass` statement here. This statement does nothing. It's
    a place-holder to use when an empty suite of statements is all we need.
  prefs: []
  type: TYPE_NORMAL
- en: The `assert` statement can be used to demonstrate that a particular logical
    condition is true at some point in the program's execution. This can clarify a
    potentially confusing algorithm. It can also serve as a handy debugging tool to
    make a program crash when something has gone awry.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean data and the bool() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All objects can have a mapping to the Boolean domain of values: `True` and
    `False`. All of the built-in classes have this mapping defined. When we define
    our own classes, we need to consider this Boolean mapping as a design feature.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in classes operate on a simple principle: if there''s clearly no
    data, the object should map to `False`. Otherwise, it should map to `True`. Here
    are some detailed examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The `None` object maps to `False`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all of the various kinds of numbers, a zero value maps to `False`. All non-zero
    values are `True`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all of the collections (including `str`, `bytes`, `tuple`, `list`, `dict`,
    `set`, and so on) an empty collection is `False`. A non-empty collection is `True`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the `bool()` function to see this mapping between object and a Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We've created a simple sequence, a `tuple` of three values, and assigned it
    to the `red_violet` variable. Since this is non-empty, it maps to `True`. On the
    other hand, the empty tuple, assigned to the `empty` variable, maps to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important consequence of this built-in mapping is that any object can be
    used in a Boolean construct. Looking ahead, we''ll often see programs with constructs
    that echo this idiomatic pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Some details of this example will have to wait for [Chapter 10](ch10.html "Chapter 10. Files,
    Databases, Networks, and Contexts"), *Files, Databases, Networks, and Contexts*.
    What's important about this example is that we can read a line from a file, strip
    whitespace with the `strip()` method, and use a simple Boolean expression to see
    if the result is an empty string. If it is an empty string, we can easily ignore
    it by using the `continue` statement.
  prefs: []
  type: TYPE_NORMAL
- en: This construct works because strings map to Boolean values. An empty string
    maps to `False`, allowing us to check for the absence of content with a very simple
    and elegant expression.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.html "Chapter 2. Simple Data Types"), *Simple Data Types*,
    we looked at the six essential comparison operators: `<`, `>`, `==`, `!=`, `<=`,
    and `>=`. The minimum of `==` and `!=` are defined by default for all classes,
    so that we can always compare objects for simple equality. For the numeric types,
    the ordering operators are also defined. Furthermore, Python''s type coercion
    rules are implemented by the numeric types so that the expression `2 < 3.0` will
    have the `int` coerced to `float`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For sequences, including `str`, `bytes`, `tuple`, and `list`, the two operands
    are compared item-by-item. This tends to put strings into alphabetical order.
    This works well for words. It also usually puts tuples into the expected order.
    However, for number-like strings, the sorting may seem a little odd. Here''s the
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The strings `"11"` and `"2"` are not numbers. They're only characters. It's
    a common confusion to imagine these values as numbers and hope that `"11"` comes
    after `"2"`. If this is the desired behavior, we'll need to convert these number-like
    strings to proper numbers using the `int()` function.
  prefs: []
  type: TYPE_NORMAL
- en: For `set` objects, the comparison operators map to the superset and subset relationships.
    Python's `<` operator is implemented as the proper subset relationship. The `<=`
    operator is implemented as the subset relationship. We'll look at this in detail
    in [Chapter 6](ch06.html "Chapter 6. More Complex Data Types"), *More Complex
    Data Types*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For other types, comparisons become less meaningful. Orderings between mappings
    is not a simple concept. How do we order two mappings: do we compare keys only,
    values only, or some combination of both? If we try to compare both keys and values,
    what are the rules for missing keys? Since there''s no simple answer, Python doesn''t
    define the ordering operators for mappings.'
  prefs: []
  type: TYPE_NORMAL
- en: For types outside the numeric tower, there are no coercion rules. The equality
    comparisons simply compare the object IDs to see if the two operands are references
    to same object.
  prefs: []
  type: TYPE_NORMAL
- en: In general, ordering operators are not implemented by default and will raise
    `TypeError` exceptions. This is a common expectation for many classes.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to compare two file objects, what attribute of the file should we
    be comparing? Size? Creation date? Rather than create confusion, comparison operators
    are simply not implemented for many classes.
  prefs: []
  type: TYPE_NORMAL
- en: Combining comparisons to simplify the logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, we may need to see if a value lies within a given range. One
    handy syntax simplification is to combine ordering comparisons into a simplified
    expression. We can meaningfully write expressions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this kind of expression, Python interprets the combined operators to mean
    `5 > a` and `a >= 0`. We aren't forced to repeat the middle expression, `a`, to
    decompose the ordering test into two binary comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: Testing float values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One important feature of float values is that they are only approximations.
    We can easily write calculations which seem mathematically exact, but produce
    odd-looking results. Specific examples vary a bit from implementation to implementation.
    Here''s one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In an abstract mathematical sense, `(a/105)*3*5*7`, must equal the original
    value of the `a` variable. We can see, however, that the floating-point approximation
    created by the true division operator has a small error. In this case, the error
    value is approximately `2.22e-16`, which is `2**-52`: the least significant bit
    of a 52-bit value is incorrect after this chain of floating-point operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Because of the presence of these small error terms, we should avoid trivial
    `==` tests with floating-point values. A simple equality test can often turn out
    to be false when the two values differ by a tiny amount.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, we should use `abs(a-b) < ε` instead of `a == b`. We can set the
    `ε` value to be small enough to detect what is equal. If, for example, we're going
    to display a value with three decimal places, there's little reason to compute
    anything past the 5th decimal place. In that case, `ε=10e-5` can be used to define
    the acceptable tolerance for floating-point equality.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid `float == float` comparisons; use `abs(float-float) < ε` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing object IDs with the is operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To determine if two variables are actually referencing the same object, we
    have a special comparison operator: `is`. This is different from the somewhat
    more complex equality test. The `is` operator is a very simple test comparing
    the internal identifiers for two objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `a is b`, then `a == b` must also be true, as the two variables refer to
    the same underlying object. However, if `a == b`, then `a is b` may not necessarily
    be true. Two distinct objects can have the same value. Here''s an example using
    floating-point values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This example works nicely for floating-point objects. We can see that two seemingly-equal
    objects are actually distinct instances which represent the same numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example like this doesn''t work for small integer values, however. For a
    narrow range of integer values, Python tends to reuse a small pool of internal
    objects. This avoids the proliferation of copies of ubiquitous values. If we try
    to set `a=1` and `b=1`, we''ll see that `a is b`: Python reused the same object.'
  prefs: []
  type: TYPE_NORMAL
- en: With a little experimentation, we can see that the reuse of small integers is
    true for numbers between -5 and 256\. Implementation details will vary. What's
    important is that some immutable objects are implicitly allocated from a pool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Object identity is revealed with the `id()` function. This shows the unique,
    internal object identifier. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can see that these are two distinct objects which happen to be equal in value.
  prefs: []
  type: TYPE_NORMAL
- en: Equality and object hash values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important part of equality comparison in Python is the hash value comparison.
    A hash is a small integer value that summarizes a larger, more complex value.
    A hash should not change; mutable objects should not provide a hash value.
  prefs: []
  type: TYPE_NORMAL
- en: Any object that we're going to collect into a set or use as a key to a mapping
    must provide both a hash value and a proper equality comparison. All of the built-in
    immutable types we've seen—numbers, `tuple`, `str`, and `bytes`—offer the necessary
    implementations of these methods. The built-in mutable types that we'll look at
    in [Chapter 6](ch06.html "Chapter 6. More Complex Data Types"), *More Complex
    Data Types*, such as `list`, `set`, and `dict`, don't provide a hash value and
    can't be used as keys in a mapping.
  prefs: []
  type: TYPE_NORMAL
- en: A hash function reduces a complex value to a small number. In Python, hash values
    generally use 61 bits. For a complex object, the hash value summarizes the object
    as a whole. It might be a sum of all the individual bytes, computed ![Equality
    and object hash values](img/B03671_05_01.jpg). It might be a sum of hash values
    for other internal objects. Comparing hash values makes for significantly less
    work than comparing each individual item in a complex object.
  prefs: []
  type: TYPE_NORMAL
- en: For immutable objects, the hash value is computed once and will be as immutable
    as the object itself. For mutable objects, a hash value could be computed. However,
    if the hash value changes, then the object won't behave well as an item in a set
    or as a key to a mapping. A changing hash value for a mutable object is not a
    very good idea.
  prefs: []
  type: TYPE_NORMAL
- en: When putting items into a set, for example, Python does a quick equality check
    using the hash values. If the hash values are different, the underlying objects
    must be different, and no more comparison needs to be done. If the hash values
    match, however, then the detailed equality test must be used to see if the objects
    really are equal or only happen to have the same hash value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some implementations of Python, you can use this kind of test to see if
    two different numbers happen to have the same hash value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Implementations vary; this was Mac OS X, v3.3.4:7ff62415e426, your results may
    be different.
  prefs: []
  type: TYPE_NORMAL
- en: If we tried to put these two values into a set, Python would do a hash check
    to see that they are *potentially* equal, followed by a detailed comparison to
    see that they're not equal.
  prefs: []
  type: TYPE_NORMAL
- en: Logic operators – and, or, not, if-else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python offers us four logical operators: `and`, `or`, `not`, and `if-else`.
    These work with Boolean values to create Boolean results. They''re entirely distinct
    from the bit-wise operators of `&`, `|`, `^`, and `~`, that we looked at in [Chapter
    2](ch02.html "Chapter 2. Simple Data Types"), *Simple Data Types*.'
  prefs: []
  type: TYPE_NORMAL
- en: The `and`, `or`, and `not` operators are common in all programming languages.
    They fit the widely-used definitions from Boolean algebra.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if-else` Boolean expression has three operands. In the middle, it uses
    a Boolean condition, but the other two operands can be objects of any types. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `if-else` operator has a Boolean condition in the middle. In this example,
    it's the comparison, `wind < 15`. If the condition is `True`, then the left-most
    expression is the result, the string `"yankee"`. If the condition is `False`,
    then the right-most expression is the result; here, it's `"stays'l"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logical operators implicitly apply the `bool()` function to their operands.
    This means that we can do things like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `and` expression involves two Boolean operands. When Python implicitly evaluates
    `bool(line)`, a non-empty line will be `True`; a zero-length line will be `False`.
    The `valid` variable will be `False` for empty lines; it will also be `False`
    for non-empty lines where `line[0]` is not the `"#"` character.
  prefs: []
  type: TYPE_NORMAL
- en: 'This implicit use of `bool()` also means this is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The value of `not 12` is evaluated as `not bool(12)`. The `bool()` value of
    a non-zero numeric value is `True`; the final result of this expression is therefore
    `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Short-circuit (or non-strict) evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What just happened? Or, more precisely, what didn't happen? Why doesn't this
    raise a `ZeroDivisionError` exception? The first two assignment statements are
    unsurprising; they assign zero to two variables, `total` and `count`. The logical
    expression, however, has a number of interesting features. Firstly, Python evaluates
    expressions left-to-right. This means that the `total != 0` subexpression is evaluated
    first. The result of this comparison is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, and perhaps more importantly, the `and` operator breaks the strict
    evaluation rules. If the left side value is equivalent to `False`, the overall
    result is `False`. The right side is not evaluated at all. If the left side value
    is equivalent to `True`, the result is simply the right side value.
  prefs: []
  type: TYPE_NORMAL
- en: This is sometimes called a short-circuit evaluation rule. There's no reason
    to evaluate the right side if the result is known from the left side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is not necessarily a Boolean; it''s simply one of the operands given
    to the `and` operator. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, `0` is equivalent to `False`, and that object is the entire
    result of the `and` operator. In the second example, the empty tuple, `()`, is
    equivalent to `False`; it is the result of the operator.
  prefs: []
  type: TYPE_NORMAL
- en: In the third example, the left hand side, `12`, is non-zero, and therefore,
    equivalent to `True`. This means that the right side must be evaluated. The right
    side is the result of the `and` operator; in this case, it is an empty tuple,
    `()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `or` operator is similar; if the left side is equivalent to `True`, there's
    no reason to evaluate the right side. We can use this feature to apply default
    values.
  prefs: []
  type: TYPE_NORMAL
- en: We can write expressions like the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If the value of the `parameter` variable is a `True` value, the value of the
    `or` operator will be that equivalent-to-true value. If the value of the `parameter`
    variable is not a `True` value (for example, it might be `None`), then the result
    will be the literal value 42.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, of course, also use the `if-else` operator for this. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If the value of the `parameter` variable is the `None` object, the left side
    operand—the literal 42—is the result. If the value of the `parameter` variable
    is not the `None` object, then the right side operator—the value of the `parameter`
    variable—is the result.
  prefs: []
  type: TYPE_NORMAL
- en: The if-elif-else statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our central tool for conditional processing is the `if` statement. This is a
    compound statement which is built from a number of clauses. The initial clause
    starts with the `if` keyword. Any number of `elif` (short for "else if") clauses
    can be used. Each of these clauses has a conditional expression and an indented
    suite of statements. We can also add a single catch-all `else` clause at the end;
    this doesn't have a condition, but does have a suite of statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The minimal `if` statement, with a single clause, might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement contains a single expression. If the expression is `True`,
    the suite of statements is executed. In this case, the suite is a single expression
    statement, using the `print()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `else` clause can be used in simple `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have two conditions. We've formally stated the `count == 0`
    condition for one `print()` function. We have an unstated condition for the other
    `print()` function. It's relatively easy—in this simple case—to deduce the implied
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: Adding elif clauses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, we can decompose complex situations into a list of cases. For
    example, we might have some conditions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve written a rather complex chain of logic here. We''ve specified four
    distinct conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`y` is a multiple of 400, in which case, the `leap` variable will be set to
    `True`. For example, the year 2000 was a leap year.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y` is a multiple of 100 (and not a multiple of 400), in which case, the `leap`
    variable will be set to `False`. The year 2100 will not be a leap year.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y` is a multiple of 4 (and neither a multiple of 100 nor of 400), which sets
    the `leap` variable to `True`. The year 2016 will be a leap year.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y` is not a multiple of 4, 100, or 400, the `leap` variable is set to `False`.
    The year 2015 is not a leap year.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Python evaluates the clauses in a strict order, each `elif` clause has
    an implicit "and not any of the previous clauses". This means that the conditions
    in each `elif` can be written very succinctly, but they also need the previous
    clauses as part of their context.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the number of `elif` clauses grows, the possibility of introducing a subtle
    logic bug also grows. This can create the situation where the implied condition
    for the `else` clause is very hard to deduce correctly. Consequently, some programs
    include logic that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This example shows each implied condition written out fully. It also shows the
    `else` clause used to raise an exception in the unlikely case that a condition
    was overlooked or misstated. Some developers argue that this is simply a waste
    of time. Others recognize that anything which is merely implied is a possible
    source of errors, and prefer to state conditions explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: For simple sets of conditions, this may be needless over-engineering. In other
    cases, this long-winded variation is more reliable because it removes all assumptions
    and implicit conditions.
  prefs: []
  type: TYPE_NORMAL
- en: The pass statement as a placeholder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some algorithms, an `else` clause may be more important than an `if` clause.
    This happens when an algorithm is designed to handle a certain set of conditions—the
    happy path—by default. All of the other non-happy-path conditions require some
    exceptional processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the default condition is relatively clear and easy to write, but there''s
    no processing required for the condition, we have a syntax issue in Python. The
    interesting processing belongs to an `else` clause, but we have no real code for
    the initial `if` clause. Here''s a typical pattern shown with invalid syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `happy_path()` condition confirms that the default processing will work.
    There's no actual processing do be done when this is true. Since we don't want
    to do anything, what do we write in the `if` clause?
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is invalid Python. We can't have an empty suite in the `if`
    clause. Since we can't write the code that's shown, we have to find alternative
    syntax that works.
  prefs: []
  type: TYPE_NORMAL
- en: One obvious choice is to negate the logic of the `happy_path()` condition. We
    can simply use the `not` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This has the desired effect. However, the `not` operator may be hard to see.
    When the `happy_path()` condition is a complex logic expression, the extra `not`
    can be confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the Python `pass` statement might be clearer than the `not` operator.
    It would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We've filled the syntactic void in the `if` clause with a "do nothing" statement.
    We have used `pass` to create a proper suite in the `if` clause. We left the comment
    in place because that kind of information might be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few other uses for the `pass` statement. We'll look at them in [Chapter
    11](ch11.html "Chapter 11. Class Definitions"), *Class Definitions*.
  prefs: []
  type: TYPE_NORMAL
- en: The assert statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `assert` statement is a highly specialized form of `if` statement. This
    statement confirms that a given condition is true. If the condition is not true,
    the `assert` statement raises an exception. In the simplest case, the script stops
    running because the exception is not handled in our programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have used an `assert` statement to provide documentation of a relationship
    between variables that must be true at a given point in our Python script, function,
    or method. If the condition, `a > b >= 0`, is false, then the `AssertionError`
    exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can customize the exception which is raised by providing a second argument
    to the `assert` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We've provided a string which includes information about the assertion. This
    string will be an argument to the exception object which is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'An exception has two interesting features. Firstly, it''s an object with arguments
    that we can set when we raise it. Secondly, and more importantly, it interrupts
    the normal sequential execution of statements. A `try`/`except` statement can
    be written to handle exceptions: the execution stops in the `try` clause and begins
    in an `except` clause that matches the exception. Without a `try` statement that
    matches the exception, raising an exception stops the program. We''ll look at
    exceptions in detail in [Chapter 9](ch09.html "Chapter 9. Exceptions"), *Exceptions*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `assert` statement can be disabled. When we run Python3 with the
    `-O`, optimize, command-line option, then the `assert` statements are not included
    in the internal Python byte code.
  prefs: []
  type: TYPE_NORMAL
- en: The logic of the None object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Simple Data Types"), *Simple Data Types*,
    we introduced the `None` object. It is a unique, immutable object, often used
    to indicate that a parameter should have a default value or that an input is not
    available. Some languages have a special null object or null pointer that have
    similar semantics to the Python `None` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `None` object has no arithmetic operators defined. It's equivalent to `False`.
    The `==` and `!=` operators are generally defined for `None`. However, these operators
    aren't always appropriate because other objects might exhibit similar behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, we'll use the `is` comparison when trying to determine if a variable
    is set to `None`. The `==` test can be redefined by a class that implements the
    `__eq__` special method; the `is` test cannot be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because `==` can be reimplemented, always use `is None` instead of `== None`.
  prefs: []
  type: TYPE_NORMAL
- en: Since `bool(None) == False`, we can use a variable which may be `None` in an
    `if` condition. Nevertheless, we should generally use `is None` or `is not None`
    to be clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This relies on the way Python implicitly evaluates `bool(a)` to see if the
    value of the `a` variable is equivalent to `True`. It''s often better to be perfectly
    explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This shows that we're matching the value of the `a` variable against the `None`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve looked closely at Python''s Boolean data type, which only has two values
    (`True` and `False`) and four operators: `and`, `or`, `not`, and `if-else`. The
    Boolean operators and the `if` statement will both implicitly coerce values to
    a Boolean. This means that non-empty strings will behave in the same as the `True`
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: We've looked at the comparison operators. These work with other objects and
    create Boolean results.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of numeric comparisons, the numeric coercion rules are used to allow
    us to compare `float` against `int` values without having to write explicit conversions.
    For string or tuple values, we've seen that items are compared in order.
  prefs: []
  type: TYPE_NORMAL
- en: We've also seen how the logical operators of `or` and `and` are not strict about
    evaluating their operands. If the left-hand side of `and` is `False`, the right-hand
    side isn't evaluated. Similarly, if the left-hand side of `or` is `True`, the
    right-hand side isn't evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at several kinds of Python statements, including the `if-elif-else`
    statement, the `pass` statement, and the `assert` statement. These statements
    allow us to write somewhat more sophisticated scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. More Complex Data Types"), *More Complex
    Data Types*, we'll look at the `list`, `set`, and `dict` collections. We'll see
    how we can use the `for` statement to process all items in a given collection.
    This will give us the ability to write scripts of considerable sophistication.
  prefs: []
  type: TYPE_NORMAL
