- en: Chapter 5. Logic, Comparisons, and Conditions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：逻辑、比较和条件
- en: Our exploration of the Python language started with expression statements and
    the assignment statement. We can view output using the `print()` function as a
    simple statement. We can gather input using the `input()` function in an assignment
    statement. In order to process data conditionally, we need the `if` statement.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Python语言的探索始于表达式语句和赋值语句。我们可以使用`print()`函数将输出视为一个简单语句。我们可以使用`input()`函数在赋值语句中收集输入。为了有条件地处理数据，我们需要`if`语句。
- en: 'In order to look at the `if` statement, we''ll need to look at Boolean data
    and Boolean operators. The `and`, `or`, `not`, and `if-else` Boolean operators
    have a "short-circuit" behavior: if the result is defined by just the left-hand
    operand, the right-hand side is not evaluated. This is an important feature of
    these logic operators. (The `if-else` operator is formally called the **Boolean
    expression**, but it behaves like the Boolean operators.)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看`if`语句，我们需要查看布尔数据和布尔运算符。`and`、`or`、`not`和`if-else`布尔运算符具有“短路”行为：如果结果仅由左操作数定义，则不会评估右侧。这是这些逻辑运算符的一个重要特性。（`if-else`运算符正式称为**布尔表达式**，但它的行为像布尔运算符。）
- en: We'll also look at the comparison operators. A comparison is a common way to
    create the Boolean values used to choose between suites of statements within an
    `if` statement.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将查看比较运算符。比较是创建在`if`语句中用于选择语句组的布尔值的一种常见方式。
- en: We'll introduce the `pass` statement here. This statement does nothing. It's
    a place-holder to use when an empty suite of statements is all we need.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里介绍`pass`语句。这个语句什么都不做。它是一个占位符，当我们只需要一个空的语句组时使用。
- en: The `assert` statement can be used to demonstrate that a particular logical
    condition is true at some point in the program's execution. This can clarify a
    potentially confusing algorithm. It can also serve as a handy debugging tool to
    make a program crash when something has gone awry.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert`语句可以用来证明在程序执行过程中的某个点上特定的逻辑条件是正确的。这可以澄清一个可能令人困惑的算法。它还可以作为一个方便的调试工具，当出现问题时使程序崩溃。'
- en: Boolean data and the bool() function
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔数据和`bool()`函数
- en: 'All objects can have a mapping to the Boolean domain of values: `True` and
    `False`. All of the built-in classes have this mapping defined. When we define
    our own classes, we need to consider this Boolean mapping as a design feature.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对象都可以映射到布尔值域：`True`和`False`。所有内置类都有这种映射定义。当我们定义自己的类时，我们需要考虑这个布尔映射作为一个设计特性。
- en: 'The built-in classes operate on a simple principle: if there''s clearly no
    data, the object should map to `False`. Otherwise, it should map to `True`. Here
    are some detailed examples:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 内置类基于一个简单的原则：如果没有明显的数据，对象应该映射到`False`。否则，它应该映射到`True`。以下是一些详细的示例：
- en: The `None` object maps to `False`.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`对象映射到`False`。'
- en: For all of the various kinds of numbers, a zero value maps to `False`. All non-zero
    values are `True`.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有各种类型的数字，零值映射到`False`。所有非零值都是`True`。
- en: For all of the collections (including `str`, `bytes`, `tuple`, `list`, `dict`,
    `set`, and so on) an empty collection is `False`. A non-empty collection is `True`.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有集合（包括`str`、`bytes`、`tuple`、`list`、`dict`、`set`等），空集合是`False`。非空集合是`True`。
- en: 'We can use the `bool()` function to see this mapping between object and a Boolean:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`bool()`函数来查看对象和布尔值之间的映射：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We've created a simple sequence, a `tuple` of three values, and assigned it
    to the `red_violet` variable. Since this is non-empty, it maps to `True`. On the
    other hand, the empty tuple, assigned to the `empty` variable, maps to `False`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的序列，一个包含三个值的`tuple`，并将其赋值给`red_violet`变量。由于这是非空的，它映射到`True`。另一方面，赋值给`empty`变量的空`tuple`映射到`False`。
- en: 'One important consequence of this built-in mapping is that any object can be
    used in a Boolean construct. Looking ahead, we''ll often see programs with constructs
    that echo this idiomatic pattern:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个内置映射的一个重要后果是，任何对象都可以用在布尔构造中。展望未来，我们经常会看到具有这种习惯性模式的程序：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Some details of this example will have to wait for [Chapter 10](ch10.html "Chapter 10. Files,
    Databases, Networks, and Contexts"), *Files, Databases, Networks, and Contexts*.
    What's important about this example is that we can read a line from a file, strip
    whitespace with the `strip()` method, and use a simple Boolean expression to see
    if the result is an empty string. If it is an empty string, we can easily ignore
    it by using the `continue` statement.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的一些细节将不得不等到 [第 10 章](ch10.html "第 10 章。文件、数据库、网络和上下文") *文件、数据库、网络和上下文* 中再讨论。这个例子的重要之处在于我们可以从文件中读取一行，使用
    `strip()` 方法去除空白，并使用简单的布尔表达式来检查结果是否为空字符串。如果是空字符串，我们可以通过使用 `continue` 语句轻松忽略它。
- en: This construct works because strings map to Boolean values. An empty string
    maps to `False`, allowing us to check for the absence of content with a very simple
    and elegant expression.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构之所以有效，是因为字符串映射到布尔值。空字符串映射到 `False`，这使得我们可以用非常简单而优雅的表达式来检查内容是否存在。
- en: Comparison operators
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较运算符
- en: 'In [Chapter 2](ch02.html "Chapter 2. Simple Data Types"), *Simple Data Types*,
    we looked at the six essential comparison operators: `<`, `>`, `==`, `!=`, `<=`,
    and `>=`. The minimum of `==` and `!=` are defined by default for all classes,
    so that we can always compare objects for simple equality. For the numeric types,
    the ordering operators are also defined. Furthermore, Python''s type coercion
    rules are implemented by the numeric types so that the expression `2 < 3.0` will
    have the `int` coerced to `float`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](ch02.html "第 2 章。简单数据类型") *简单数据类型* 中，我们探讨了六个基本比较运算符：`<`、`>`、`==`、`!=`、`<=`
    和 `>=`。`==` 和 `!=` 的最小值对于所有类都是默认定义的，这样我们就可以始终比较对象进行简单相等性比较。对于数值类型，排序运算符也是定义好的。此外，Python
    的类型强制规则由数值类型实现，因此表达式 `2 < 3.0` 将会将 `int` 强制转换为 `float`。
- en: 'For sequences, including `str`, `bytes`, `tuple`, and `list`, the two operands
    are compared item-by-item. This tends to put strings into alphabetical order.
    This works well for words. It also usually puts tuples into the expected order.
    However, for number-like strings, the sorting may seem a little odd. Here''s the
    example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于序列，包括 `str`、`bytes`、`tuple` 和 `list`，两个操作数是逐项比较的。这通常会将字符串按字母顺序排序。这对于单词来说效果很好。它通常也会将元组按预期顺序排序。然而，对于类似数字的字符串，排序可能看起来有点奇怪。以下是一个例子：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The strings `"11"` and `"2"` are not numbers. They're only characters. It's
    a common confusion to imagine these values as numbers and hope that `"11"` comes
    after `"2"`. If this is the desired behavior, we'll need to convert these number-like
    strings to proper numbers using the `int()` function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 `"11"` 和 `"2"` 不是数字。它们只是字符。将这两个值想象成数字并希望 `"11"` 在 `"2"` 之后是一种常见的误解。如果这是期望的行为，我们需要使用
    `int()` 函数将这些类似数字的字符串转换为正确的数字。
- en: For `set` objects, the comparison operators map to the superset and subset relationships.
    Python's `<` operator is implemented as the proper subset relationship. The `<=`
    operator is implemented as the subset relationship. We'll look at this in detail
    in [Chapter 6](ch06.html "Chapter 6. More Complex Data Types"), *More Complex
    Data Types*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `set` 对象，比较运算符映射到超集和子集关系。Python 的 `<` 运算符实现为真子集关系。`<=` 运算符实现为子集关系。我们将在 [第
    6 章](ch06.html "第 6 章。更复杂的数据类型") *更复杂的数据类型* 中详细探讨这一点。
- en: 'For other types, comparisons become less meaningful. Orderings between mappings
    is not a simple concept. How do we order two mappings: do we compare keys only,
    values only, or some combination of both? If we try to compare both keys and values,
    what are the rules for missing keys? Since there''s no simple answer, Python doesn''t
    define the ordering operators for mappings.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他类型，比较变得不那么有意义。映射之间的排序不是一个简单概念。我们如何对两个映射进行排序：是只比较键，只比较值，还是两者的组合？如果我们尝试同时比较键和值，缺失键的规则是什么？由于没有简单的答案，Python
    没有为映射定义排序运算符。
- en: For types outside the numeric tower, there are no coercion rules. The equality
    comparisons simply compare the object IDs to see if the two operands are references
    to same object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数值塔外的类型，没有强制规则。相等性比较只是比较对象的 ID，以查看两个操作数是否引用了同一个对象。
- en: In general, ordering operators are not implemented by default and will raise
    `TypeError` exceptions. This is a common expectation for many classes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，排序运算符不是默认实现的，并且会引发 `TypeError` 异常。这对于许多类来说是一个常见的期望。
- en: If we try to compare two file objects, what attribute of the file should we
    be comparing? Size? Creation date? Rather than create confusion, comparison operators
    are simply not implemented for many classes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试比较两个文件对象，我们应该比较哪个属性？大小？创建日期？为了避免混淆，比较运算符对于许多类并没有实现。
- en: Combining comparisons to simplify the logic
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合比较以简化逻辑
- en: 'In some cases, we may need to see if a value lies within a given range. One
    handy syntax simplification is to combine ordering comparisons into a simplified
    expression. We can meaningfully write expressions like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要检查一个值是否在给定的范围内。一种方便的语法简化是将排序比较组合成一个简化的表达式。我们可以有意义地写出这样的表达式：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this kind of expression, Python interprets the combined operators to mean
    `5 > a` and `a >= 0`. We aren't forced to repeat the middle expression, `a`, to
    decompose the ordering test into two binary comparisons.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种类型的表达式中，Python 解释器将组合运算符解释为 `5 > a` 和 `a >= 0`。我们不必重复中间表达式 `a` 来将排序测试分解为两个二进制比较。
- en: Testing float values
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试浮点值
- en: 'One important feature of float values is that they are only approximations.
    We can easily write calculations which seem mathematically exact, but produce
    odd-looking results. Specific examples vary a bit from implementation to implementation.
    Here''s one example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点值的一个重要特性是它们只是近似值。我们可以轻松编写看似数学上精确的计算，但会产生看起来很奇怪的结果。具体例子可能因实现而异。以下是一个例子：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In an abstract mathematical sense, `(a/105)*3*5*7`, must equal the original
    value of the `a` variable. We can see, however, that the floating-point approximation
    created by the true division operator has a small error. In this case, the error
    value is approximately `2.22e-16`, which is `2**-52`: the least significant bit
    of a 52-bit value is incorrect after this chain of floating-point operations.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在抽象数学意义上，`(a/105)*3*5*7` 必须等于 `a` 变量的原始值。然而，我们可以看到，由真正的除法运算符创建的浮点近似值有一个小的误差。在这种情况下，误差值大约是
    `2.22e-16`，即 `2**-52`：在这次浮点操作链之后，52 位值的最不重要位是不正确的。
- en: Because of the presence of these small error terms, we should avoid trivial
    `==` tests with floating-point values. A simple equality test can often turn out
    to be false when the two values differ by a tiny amount.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在这些小的误差项，我们应该避免对浮点值进行简单的 `==` 测试。当两个值相差很小时，简单的相等测试往往会出现错误。
- en: Generally, we should use `abs(a-b) < ε` instead of `a == b`. We can set the
    `ε` value to be small enough to detect what is equal. If, for example, we're going
    to display a value with three decimal places, there's little reason to compute
    anything past the 5th decimal place. In that case, `ε=10e-5` can be used to define
    the acceptable tolerance for floating-point equality.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们应该使用 `abs(a-b) < ε` 而不是 `a == b`。我们可以将 `ε` 值设置得足够小，以便检测相等性。例如，如果我们打算显示一个有三位小数的值，就没有必要计算超过第
    5 位小数。在这种情况下，`ε=10e-5` 可以用来定义浮点相等性的可接受公差。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Avoid `float == float` comparisons; use `abs(float-float) < ε` instead.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用 `float == float` 比较；使用 `abs(float-float) < ε` 代替。
- en: Comparing object IDs with the is operator
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 is 运算符比较对象 ID
- en: 'To determine if two variables are actually referencing the same object, we
    have a special comparison operator: `is`. This is different from the somewhat
    more complex equality test. The `is` operator is a very simple test comparing
    the internal identifiers for two objects.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定两个变量是否实际上引用的是同一个对象，我们有一个特殊的比较运算符：`is`。这与稍微复杂一些的相等性测试不同。`is` 运算符是一个非常简单的测试，比较两个对象的内部标识符。
- en: 'If `a is b`, then `a == b` must also be true, as the two variables refer to
    the same underlying object. However, if `a == b`, then `a is b` may not necessarily
    be true. Two distinct objects can have the same value. Here''s an example using
    floating-point values:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `a is b`，那么 `a == b` 也必须为真，因为这两个变量引用的是同一个底层对象。然而，如果 `a == b`，那么 `a is b`
    可能不一定为真。两个不同的对象可以具有相同的值。以下是一个使用浮点值的例子：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example works nicely for floating-point objects. We can see that two seemingly-equal
    objects are actually distinct instances which represent the same numeric value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子对于浮点对象来说工作得很好。我们可以看到，两个看似相等的对象实际上是不同的实例，它们代表相同的数值。
- en: 'An example like this doesn''t work for small integer values, however. For a
    narrow range of integer values, Python tends to reuse a small pool of internal
    objects. This avoids the proliferation of copies of ubiquitous values. If we try
    to set `a=1` and `b=1`, we''ll see that `a is b`: Python reused the same object.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样的例子对于小整数值不起作用。对于狭窄范围的整数值，Python倾向于重用一小批内部对象。这避免了普遍值的副本的激增。如果我们尝试设置`a=1`和`b=1`，我们会看到`a
    is b`：Python重用了相同的对象。
- en: With a little experimentation, we can see that the reuse of small integers is
    true for numbers between -5 and 256\. Implementation details will vary. What's
    important is that some immutable objects are implicitly allocated from a pool.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一点实验，我们可以看到，-5和256之间的数字确实重用了小整数。实现细节可能会有所不同。重要的是，一些不可变对象是从池中隐式分配的。
- en: 'Object identity is revealed with the `id()` function. This shows the unique,
    internal object identifier. For example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`id()`函数可以揭示对象身份。这显示了唯一的、内部的对象标识符。例如：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can see that these are two distinct objects which happen to be equal in value.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这两个对象在值上恰好相等，但却是两个不同的对象。
- en: Equality and object hash values
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相等性和对象哈希值
- en: An important part of equality comparison in Python is the hash value comparison.
    A hash is a small integer value that summarizes a larger, more complex value.
    A hash should not change; mutable objects should not provide a hash value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，相等性比较的一个重要部分是哈希值比较。哈希是一个总结更大、更复杂值的小整数。哈希值不应改变；可变对象不应提供哈希值。
- en: Any object that we're going to collect into a set or use as a key to a mapping
    must provide both a hash value and a proper equality comparison. All of the built-in
    immutable types we've seen—numbers, `tuple`, `str`, and `bytes`—offer the necessary
    implementations of these methods. The built-in mutable types that we'll look at
    in [Chapter 6](ch06.html "Chapter 6. More Complex Data Types"), *More Complex
    Data Types*, such as `list`, `set`, and `dict`, don't provide a hash value and
    can't be used as keys in a mapping.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算收集到集合中或用作映射键的任何对象都必须提供哈希值和适当的相等性比较。我们之前看到的所有内置不可变类型——数字、`tuple`、`str`和`bytes`——都提供了这些方法的必要实现。我们将在[第6章](ch06.html
    "第6章。更复杂的数据类型")“更复杂的数据类型”中查看的内置可变类型，如`list`、`set`和`dict`，不提供哈希值，不能用作映射的键。
- en: A hash function reduces a complex value to a small number. In Python, hash values
    generally use 61 bits. For a complex object, the hash value summarizes the object
    as a whole. It might be a sum of all the individual bytes, computed ![Equality
    and object hash values](img/B03671_05_01.jpg). It might be a sum of hash values
    for other internal objects. Comparing hash values makes for significantly less
    work than comparing each individual item in a complex object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数将复杂值简化为小数。在Python中，哈希值通常使用61位。对于复杂对象，哈希值总结了整个对象。它可能是所有单个字节的和，计算![相等性和对象哈希值](img/B03671_05_01.jpg)。它也可能是其他内部对象哈希值的和。比较哈希值比比较复杂对象中的每个单独项目要少得多。
- en: For immutable objects, the hash value is computed once and will be as immutable
    as the object itself. For mutable objects, a hash value could be computed. However,
    if the hash value changes, then the object won't behave well as an item in a set
    or as a key to a mapping. A changing hash value for a mutable object is not a
    very good idea.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不可变对象，哈希值只计算一次，将与对象本身一样不可变。对于可变对象，可以计算哈希值。但是，如果哈希值发生变化，则对象在集合中的行为或作为映射的键将不会很好。对于可变对象，变化的哈希值不是一个很好的主意。
- en: When putting items into a set, for example, Python does a quick equality check
    using the hash values. If the hash values are different, the underlying objects
    must be different, and no more comparison needs to be done. If the hash values
    match, however, then the detailed equality test must be used to see if the objects
    really are equal or only happen to have the same hash value.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当将项目放入集合中时，例如，Python会使用哈希值进行快速相等性检查。如果哈希值不同，则底层对象必须不同，无需进行更多比较。然而，如果哈希值匹配，则必须使用详细的相等性测试来确定对象是否确实相等或只是偶然具有相同的哈希值。
- en: 'In some implementations of Python, you can use this kind of test to see if
    two different numbers happen to have the same hash value:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的一些实现中，你可以使用这种测试来查看两个不同的数字是否恰好具有相同的哈希值：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Implementations vary; this was Mac OS X, v3.3.4:7ff62415e426, your results may
    be different.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可能会有所不同；这是Mac OS X，v3.3.4:7ff62415e426，你的结果可能会有所不同。
- en: If we tried to put these two values into a set, Python would do a hash check
    to see that they are *potentially* equal, followed by a detailed comparison to
    see that they're not equal.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试将这些两个值放入一个集合中，Python将执行哈希检查以查看它们是否*可能*相等，然后进行详细比较以查看它们是否不相等。
- en: Logic operators – and, or, not, if-else
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑运算符 - and、or、not、if-else
- en: 'Python offers us four logical operators: `and`, `or`, `not`, and `if-else`.
    These work with Boolean values to create Boolean results. They''re entirely distinct
    from the bit-wise operators of `&`, `|`, `^`, and `~`, that we looked at in [Chapter
    2](ch02.html "Chapter 2. Simple Data Types"), *Simple Data Types*.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了四个逻辑运算符：`and`、`or`、`not` 和 `if-else`。这些运算符与布尔值一起使用以创建布尔结果。它们与我们在[第2章](ch02.html
    "第2章。简单数据类型")中讨论的位运算符 `&`、`|`、`^` 和 `~` 完全不同，*简单数据类型*。
- en: The `and`, `or`, and `not` operators are common in all programming languages.
    They fit the widely-used definitions from Boolean algebra.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`and`、`or` 和 `not` 运算符在所有编程语言中都很常见。它们符合布尔代数中广泛使用的定义。'
- en: 'The `if-else` Boolean expression has three operands. In the middle, it uses
    a Boolean condition, but the other two operands can be objects of any types. Here''s
    an example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-else` 布尔表达式有三个操作数。在中间，它使用布尔条件，但其他两个操作数可以是任何类型的对象。以下是一个示例：'
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `if-else` operator has a Boolean condition in the middle. In this example,
    it's the comparison, `wind < 15`. If the condition is `True`, then the left-most
    expression is the result, the string `"yankee"`. If the condition is `False`,
    then the right-most expression is the result; here, it's `"stays'l"`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-else` 运算符在中间有一个布尔条件。在这个例子中，它是比较 `wind < 15`。如果条件为 `True`，则最左侧的表达式是结果，字符串
    `"yankee"`。如果条件为 `False`，则最右侧的表达式是结果；这里，它是 `"stays''l"`。'
- en: 'The logical operators implicitly apply the `bool()` function to their operands.
    This means that we can do things like the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符隐式地将 `bool()` 函数应用于其操作数。这意味着我们可以做如下事情：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `and` expression involves two Boolean operands. When Python implicitly evaluates
    `bool(line)`, a non-empty line will be `True`; a zero-length line will be `False`.
    The `valid` variable will be `False` for empty lines; it will also be `False`
    for non-empty lines where `line[0]` is not the `"#"` character.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`and` 表达式涉及两个布尔操作数。当Python隐式评估 `bool(line)` 时，非空行将是 `True`；空行将是 `False`。对于空行，`valid`
    变量将是 `False`；如果 `line[0]` 不是 `"#"` 字符，则对于非空行，它也将是 `False`。'
- en: 'This implicit use of `bool()` also means this is true:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种隐式使用 `bool()` 也意味着这是正确的：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The value of `not 12` is evaluated as `not bool(12)`. The `bool()` value of
    a non-zero numeric value is `True`; the final result of this expression is therefore
    `False`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`not 12` 的值被评估为 `not bool(12)`。非零数值的 `bool()` 值是 `True`；因此，这个表达式的最终结果是 `False`。'
- en: Short-circuit (or non-strict) evaluation
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 短路（或非严格）评估
- en: 'Consider the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What just happened? Or, more precisely, what didn't happen? Why doesn't this
    raise a `ZeroDivisionError` exception? The first two assignment statements are
    unsurprising; they assign zero to two variables, `total` and `count`. The logical
    expression, however, has a number of interesting features. Firstly, Python evaluates
    expressions left-to-right. This means that the `total != 0` subexpression is evaluated
    first. The result of this comparison is `False`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？或者，更准确地说，没有发生什么？为什么这不会引发 `ZeroDivisionError` 异常？前两个赋值语句并不令人惊讶；它们将零赋值给两个变量，`total`
    和 `count`。然而，逻辑表达式有几个有趣的特点。首先，Python按从左到右的顺序评估表达式。这意味着 `total != 0` 子表达式首先被评估。这个比较的结果是
    `False`。
- en: Secondly, and perhaps more importantly, the `and` operator breaks the strict
    evaluation rules. If the left side value is equivalent to `False`, the overall
    result is `False`. The right side is not evaluated at all. If the left side value
    is equivalent to `True`, the result is simply the right side value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，也许更重要的是，`and` 运算符打破了严格的评估规则。如果左侧值等同于 `False`，则整体结果为 `False`。右侧根本不会进行评估。如果左侧值等同于
    `True`，则结果简单地是右侧值。
- en: This is sometimes called a short-circuit evaluation rule. There's no reason
    to evaluate the right side if the result is known from the left side.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时被称为短路评估规则。如果从左侧已知结果，就没有必要评估右侧。
- en: 'The result is not necessarily a Boolean; it''s simply one of the operands given
    to the `and` operator. Here are some examples:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 结果不一定是布尔值；它只是 `and` 运算符给出的操作数之一。以下是一些示例：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the first example, `0` is equivalent to `False`, and that object is the entire
    result of the `and` operator. In the second example, the empty tuple, `()`, is
    equivalent to `False`; it is the result of the operator.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，`0` 等同于 `False`，并且该对象是 `and` 操作符的整个结果。在第二个例子中，空元组 `()` 等同于 `False`；它是操作符的结果。
- en: In the third example, the left hand side, `12`, is non-zero, and therefore,
    equivalent to `True`. This means that the right side must be evaluated. The right
    side is the result of the `and` operator; in this case, it is an empty tuple,
    `()`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个例子中，左侧，`12`，是非零的，因此，等同于 `True`。这意味着右侧必须被评估。右侧是 `and` 操作符的结果；在这种情况下，它是一个空元组，`()`。
- en: The `or` operator is similar; if the left side is equivalent to `True`, there's
    no reason to evaluate the right side. We can use this feature to apply default
    values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`or` 操作符类似；如果左侧等同于 `True`，就没有理由评估右侧。我们可以使用这个特性来应用默认值。'
- en: We can write expressions like the following.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写如下表达式。
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the value of the `parameter` variable is a `True` value, the value of the
    `or` operator will be that equivalent-to-true value. If the value of the `parameter`
    variable is not a `True` value (for example, it might be `None`), then the result
    will be the literal value 42.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `parameter` 变量的值是一个 `True` 值，则 `or` 操作符的值将是等效于 `True` 的值。如果 `parameter` 变量的值不是一个
    `True` 值（例如，它可能是 `None`），那么结果将是字面值42。
- en: 'We can, of course, also use the `if-else` operator for this. Here''s an example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然也可以使用 `if-else` 操作符来做这件事。这里有一个例子：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the value of the `parameter` variable is the `None` object, the left side
    operand—the literal 42—is the result. If the value of the `parameter` variable
    is not the `None` object, then the right side operator—the value of the `parameter`
    variable—is the result.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `parameter` 变量的值是 `None` 对象，则左侧操作数——字面值42——是结果。如果 `parameter` 变量的值不是 `None`
    对象，那么右侧操作符——`parameter` 变量的值——是结果。
- en: The if-elif-else statement
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if-elif-else 语句
- en: Our central tool for conditional processing is the `if` statement. This is a
    compound statement which is built from a number of clauses. The initial clause
    starts with the `if` keyword. Any number of `elif` (short for "else if") clauses
    can be used. Each of these clauses has a conditional expression and an indented
    suite of statements. We can also add a single catch-all `else` clause at the end;
    this doesn't have a condition, but does have a suite of statements.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行条件处理的中心工具是 `if` 语句。这是一个由多个子句组成的复合语句。初始子句以 `if` 关键字开始。可以使用任意数量的 `elif`（代表“else
    if”）子句。每个这些子句都有一个条件表达式和一个缩进的语句序列。我们还可以在末尾添加一个单一的通配符 `else` 子句；它没有条件，但有一个语句序列。
- en: 'The minimal `if` statement, with a single clause, might look like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的 `if` 语句，只有一个子句，可能看起来像这样：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `if` statement contains a single expression. If the expression is `True`,
    the suite of statements is executed. In this case, the suite is a single expression
    statement, using the `print()` function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句包含一个单独的表达式。如果表达式为 `True`，则执行语句序列。在这种情况下，语句序列是一个单独的表达式语句，使用 `print()`
    函数。'
- en: The `else` clause can be used in simple `if` statements.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`else` 子句可以用于简单的 `if` 语句。'
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, we have two conditions. We've formally stated the `count == 0`
    condition for one `print()` function. We have an unstated condition for the other
    `print()` function. It's relatively easy—in this simple case—to deduce the implied
    condition.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有两个条件。我们正式声明了 `count == 0` 条件用于一个 `print()` 函数。对于另一个 `print()` 函数，我们有一个未声明的条件。在这个简单的情况下，推断出隐含的条件相对容易。
- en: Adding elif clauses
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 elif 子句
- en: 'In some cases, we can decompose complex situations into a list of cases. For
    example, we might have some conditions like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可以将复杂的情况分解成一系列的情况。例如，我们可能有一些这样的条件：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We''ve written a rather complex chain of logic here. We''ve specified four
    distinct conditions:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里写了一个相当复杂的逻辑链。我们指定了四个不同的条件：
- en: '`y` is a multiple of 400, in which case, the `leap` variable will be set to
    `True`. For example, the year 2000 was a leap year.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y` 是400的倍数，在这种情况下，`leap` 变量将被设置为 `True`。例如，公元2000年是闰年。'
- en: '`y` is a multiple of 100 (and not a multiple of 400), in which case, the `leap`
    variable will be set to `False`. The year 2100 will not be a leap year.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y` 是100的倍数（但不是400的倍数），在这种情况下，`leap` 变量将被设置为 `False`。公元2100年将不是闰年。'
- en: '`y` is a multiple of 4 (and neither a multiple of 100 nor of 400), which sets
    the `leap` variable to `True`. The year 2016 will be a leap year.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`y`是4的倍数（并且不是100或400的倍数），则将`leap`变量设置为`True`。2016年将是闰年。
- en: '`y` is not a multiple of 4, 100, or 400, the `leap` variable is set to `False`.
    The year 2015 is not a leap year.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`y`不是4、100或400的倍数，则将`leap`变量设置为`False`。2015年不是闰年。
- en: Since Python evaluates the clauses in a strict order, each `elif` clause has
    an implicit "and not any of the previous clauses". This means that the conditions
    in each `elif` can be written very succinctly, but they also need the previous
    clauses as part of their context.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python以严格的顺序评估子句，每个`elif`子句都有一个隐含的“并且不是之前的任何子句”。这意味着每个`elif`中的条件可以非常简洁地编写，但它们也需要之前的子句作为其上下文的一部分。
- en: 'As the number of `elif` clauses grows, the possibility of introducing a subtle
    logic bug also grows. This can create the situation where the implied condition
    for the `else` clause is very hard to deduce correctly. Consequently, some programs
    include logic that looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 随着elif子句数量的增加，引入微妙逻辑错误的可能性也增加。这可能导致`else`子句的隐含条件很难正确推断。因此，一些程序包含类似以下逻辑：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This example shows each implied condition written out fully. It also shows the
    `else` clause used to raise an exception in the unlikely case that a condition
    was overlooked or misstated. Some developers argue that this is simply a waste
    of time. Others recognize that anything which is merely implied is a possible
    source of errors, and prefer to state conditions explicitly.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例显示了每个隐含条件都完全写出。它还显示了使用`else`子句在不太可能的情况下引发异常，即条件被忽略或表述错误。一些开发者认为这纯粹是浪费时间。其他人认为，任何仅仅是暗示的东西都可能是错误的一个来源，并更喜欢明确地陈述条件。
- en: For simple sets of conditions, this may be needless over-engineering. In other
    cases, this long-winded variation is more reliable because it removes all assumptions
    and implicit conditions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的条件集，这可能是一种不必要的过度设计。在其他情况下，这种冗长的变化可能更可靠，因为它消除了所有假设和隐含条件。
- en: The pass statement as a placeholder
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将`pass`语句用作占位符
- en: In some algorithms, an `else` clause may be more important than an `if` clause.
    This happens when an algorithm is designed to handle a certain set of conditions—the
    happy path—by default. All of the other non-happy-path conditions require some
    exceptional processing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些算法中，`else`子句可能比`if`子句更重要。这种情况发生在算法默认设计为处理一组特定的条件——即“快乐路径”时。所有其他非“快乐路径”的条件都需要一些特殊处理。
- en: 'When the default condition is relatively clear and easy to write, but there''s
    no processing required for the condition, we have a syntax issue in Python. The
    interesting processing belongs to an `else` clause, but we have no real code for
    the initial `if` clause. Here''s a typical pattern shown with invalid syntax:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当默认条件相对清晰且易于编写，但不需要对该条件进行处理时，Python中就存在一个语法问题。有趣的处理属于`else`子句，但我们没有为初始的`if`子句编写真正的代码。以下是一个典型的模式，展示了无效的语法：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `happy_path()` condition confirms that the default processing will work.
    There's no actual processing do be done when this is true. Since we don't want
    to do anything, what do we write in the `if` clause?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`happy_path()`条件确认默认处理将正常工作。当这是真的时，实际上不需要执行任何处理。由于我们不希望做任何事情，我们在`if`子句中写什么？'
- en: The preceding code is invalid Python. We can't have an empty suite in the `if`
    clause. Since we can't write the code that's shown, we have to find alternative
    syntax that works.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是无效的Python代码。我们无法在`if`子句中有一个空代码块。由于我们无法编写上述代码，我们必须找到可以工作的替代语法。
- en: One obvious choice is to negate the logic of the `happy_path()` condition. We
    can simply use the `not` operator.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的选择是取反`happy_path()`条件的逻辑。我们可以简单地使用`not`运算符。
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This has the desired effect. However, the `not` operator may be hard to see.
    When the `happy_path()` condition is a complex logic expression, the extra `not`
    can be confusing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生预期的效果。然而，`not`运算符可能难以察觉。当`happy_path()`条件是一个复杂的逻辑表达式时，额外的`not`可能会令人困惑。
- en: 'This is where the Python `pass` statement might be clearer than the `not` operator.
    It would look like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Python的`pass`语句可能比`not`运算符更清晰的地方。它看起来会是这样：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We've filled the syntactic void in the `if` clause with a "do nothing" statement.
    We have used `pass` to create a proper suite in the `if` clause. We left the comment
    in place because that kind of information might be helpful.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`if`子句中的语法空缺处填充了一个“什么也不做”的语句。我们使用`pass`在`if`子句中创建了一个合适的代码块。我们保留了注释，因为这种信息可能是有帮助的。
- en: There are a few other uses for the `pass` statement. We'll look at them in [Chapter
    11](ch11.html "Chapter 11. Class Definitions"), *Class Definitions*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`pass`语句还有一些其他用途。我们将在[第11章](ch11.html "第11章。类定义")*类定义*中探讨它们。'
- en: The assert statement
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言语句
- en: The `assert` statement is a highly specialized form of `if` statement. This
    statement confirms that a given condition is true. If the condition is not true,
    the `assert` statement raises an exception. In the simplest case, the script stops
    running because the exception is not handled in our programming.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert`语句是`if`语句的一种高度专业化的形式。这个语句确认一个给定的条件是真实的。如果条件不是真实的，`assert`语句将抛出一个异常。在最简单的情况下，脚本停止运行，因为异常没有被我们的编程处理。'
- en: 'It looks like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来是这样的：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have used an `assert` statement to provide documentation of a relationship
    between variables that must be true at a given point in our Python script, function,
    or method. If the condition, `a > b >= 0`, is false, then the `AssertionError`
    exception is raised.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`assert`语句来提供在Python脚本、函数或方法中某个特定点必须为真的变量之间关系的文档。如果条件`a > b >= 0`为假，则抛出`AssertionError`异常。
- en: 'We can customize the exception which is raised by providing a second argument
    to the `assert` statement:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向`assert`语句提供第二个参数来自定义抛出的异常：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We've provided a string which includes information about the assertion. This
    string will be an argument to the exception object which is created.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个包含关于断言信息的字符串。这个字符串将是创建的异常对象的参数。
- en: 'An exception has two interesting features. Firstly, it''s an object with arguments
    that we can set when we raise it. Secondly, and more importantly, it interrupts
    the normal sequential execution of statements. A `try`/`except` statement can
    be written to handle exceptions: the execution stops in the `try` clause and begins
    in an `except` clause that matches the exception. Without a `try` statement that
    matches the exception, raising an exception stops the program. We''ll look at
    exceptions in detail in [Chapter 9](ch09.html "Chapter 9. Exceptions"), *Exceptions*.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 异常有两个有趣的特点。首先，它是一个带有我们可以设置的参数的对象。其次，更重要的是，它中断了语句的正常顺序执行。可以编写`try`/`except`语句来处理异常：执行在`try`子句中停止，并在匹配异常的`except`子句中开始。如果没有匹配异常的`try`语句，抛出异常将停止程序。我们将在[第9章](ch09.html
    "第9章。异常")*异常*中详细探讨异常。
- en: Note that the `assert` statement can be disabled. When we run Python3 with the
    `-O`, optimize, command-line option, then the `assert` statements are not included
    in the internal Python byte code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`assert`语句可以被禁用。当我们使用带有`-O`，优化命令行选项运行Python3时，`assert`语句不会包含在内置的Python字节码中。
- en: The logic of the None object
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`None`对象逻辑'
- en: In [Chapter 2](ch02.html "Chapter 2. Simple Data Types"), *Simple Data Types*,
    we introduced the `None` object. It is a unique, immutable object, often used
    to indicate that a parameter should have a default value or that an input is not
    available. Some languages have a special null object or null pointer that have
    similar semantics to the Python `None` object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。简单数据类型")*简单数据类型*中，我们介绍了`None`对象。它是一个独特的不变对象，通常用于表示一个参数应该有一个默认值或输入不可用。一些语言有一个特殊的空对象或空指针，其语义与Python的`None`对象类似。
- en: The `None` object has no arithmetic operators defined. It's equivalent to `False`.
    The `==` and `!=` operators are generally defined for `None`. However, these operators
    aren't always appropriate because other objects might exhibit similar behavior.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`对象没有定义算术运算符。它等同于`False`。`==`和`!=`运算符通常为`None`定义。然而，这些运算符并不总是合适的，因为其他对象可能表现出类似的行为。'
- en: Generally, we'll use the `is` comparison when trying to determine if a variable
    is set to `None`. The `==` test can be redefined by a class that implements the
    `__eq__` special method; the `is` test cannot be overridden.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们试图确定一个变量是否设置为`None`时，我们会使用`is`比较。`==`测试可以被实现`__eq__`特殊方法的类重新定义；`is`测试不能被覆盖。
- en: Tip
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Because `==` can be reimplemented, always use `is None` instead of `== None`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`==`可以被重新实现，所以始终使用`is None`而不是`== None`。
- en: Since `bool(None) == False`, we can use a variable which may be `None` in an
    `if` condition. Nevertheless, we should generally use `is None` or `is not None`
    to be clearer.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `bool(None) == False`，我们可以在 `if` 条件中使用可能为 `None` 的变量。尽管如此，我们通常应该使用 `is None`
    或 `is not None` 来更清晰地表达。
- en: 'Here''s an example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This relies on the way Python implicitly evaluates `bool(a)` to see if the
    value of the `a` variable is equivalent to `True`. It''s often better to be perfectly
    explicit:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这依赖于 Python 隐式评估 `bool(a)` 的方式，以查看变量 `a` 的值是否等同于 `True`。通常最好是非常明确的：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This shows that we're matching the value of the `a` variable against the `None`
    object.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们正在将变量 `a` 的值与 `None` 对象进行匹配。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'We''ve looked closely at Python''s Boolean data type, which only has two values
    (`True` and `False`) and four operators: `and`, `or`, `not`, and `if-else`. The
    Boolean operators and the `if` statement will both implicitly coerce values to
    a Boolean. This means that non-empty strings will behave in the same as the `True`
    value.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经仔细研究了 Python 的布尔数据类型，它只有两个值（`True` 和 `False`）和四个运算符：`and`、`or`、`not` 和 `if-else`。布尔运算符和
    `if` 语句都会隐式地将值转换为布尔值。这意味着非空字符串的行为与 `True` 值相同。
- en: We've looked at the comparison operators. These work with other objects and
    create Boolean results.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了比较运算符。这些运算符与其他对象一起工作，并创建布尔结果。
- en: In the case of numeric comparisons, the numeric coercion rules are used to allow
    us to compare `float` against `int` values without having to write explicit conversions.
    For string or tuple values, we've seen that items are compared in order.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在数值比较的情况下，数值转换规则被用来允许我们比较 `float` 与 `int` 值，而无需编写显式的转换。对于字符串或元组值，我们已经看到项目是按顺序比较的。
- en: We've also seen how the logical operators of `or` and `and` are not strict about
    evaluating their operands. If the left-hand side of `and` is `False`, the right-hand
    side isn't evaluated. Similarly, if the left-hand side of `or` is `True`, the
    right-hand side isn't evaluated.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了逻辑运算符 `or` 和 `and` 在评估它们的操作数方面并不严格。如果 `and` 的左侧是 `False`，则不会评估右侧。同样，如果
    `or` 的左侧是 `True`，则不会评估右侧。
- en: We looked at several kinds of Python statements, including the `if-elif-else`
    statement, the `pass` statement, and the `assert` statement. These statements
    allow us to write somewhat more sophisticated scripts.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了多种 Python 语句，包括 `if-elif-else` 语句、`pass` 语句和 `assert` 语句。这些语句允许我们编写更复杂的脚本。
- en: In [Chapter 6](ch06.html "Chapter 6. More Complex Data Types"), *More Complex
    Data Types*, we'll look at the `list`, `set`, and `dict` collections. We'll see
    how we can use the `for` statement to process all items in a given collection.
    This will give us the ability to write scripts of considerable sophistication.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](ch06.html "第 6 章。更复杂的数据类型")，*更复杂的数据类型* 中，我们将探讨 `list`、`set` 和 `dict`
    集合。我们将看到如何使用 `for` 语句处理给定集合中的所有项目。这将使我们能够编写相当复杂的脚本。
