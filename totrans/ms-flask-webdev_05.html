<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Advanced Application Structure</h1>
                </header>
            
            <article>
                
<p>Our application has gone from a very simple example to an extendable foundation on which powerful features can easily be built. However, having our application entirely reside in one file needlessly clutters our code. This is one of the advantages of Flask; you can write a small REST service or web application on a single file, or a full-blown enterprise application. The framework won't get in your way and won't impose any project layout.</p>
<p>To make the application code clearer and more comprehensible, we will transform the entire code into a Python module and each feature into a module by itself. This modular approach enables you to scale easily and in a predictable way, so new features will have an obvious place and structure. In this chapter, you will learn the best practices for the following:</p>
<ul>
<li>Creating a modular application that easily scales</li>
<li>Application factory pattern</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modular application</h1>
                </header>
            
            <article>
                
<p>Currently, your folder structure should look like the following (take a look at the code <span>provided</span><span> </span><span>for the previous chapter):</span></p>
<pre>./ 
  config.py 
  database.db 
  main.py 
  manage.py 
  env/ 
  migrations/ 
    versions/ 
  templates/ 
    blog/ </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>To convert our code into a more modular application, our files will be structured as follows:</p>
<pre>./ 
  manage.py<br/>  main.py<br/>  config.py 
 database.db 
  webapp/ 
    __init__.py
    blog/
      __init__.py 
      controllers.py<br/>      forms.py<br/>      models.py<br/>    main/<br/>      __init__.py<br/>      controllers.py
    templates/ 
      blog/ 
  migrations/ 
    versions/ </pre>
<p>The first change to make is to create a folder in your application that will hold the module. In this example, it will be called <kbd>webapp</kbd>.</p>
<p>Next, for each module in our application, we will create a respective Python module. If the module is a classic web application using web templates and forms, we would create the following files:</p>
<pre><strong>./&lt;MODULE_NAME&gt;<br/> </strong> __init__.py -&gt; Declare a python module<br/>  controllers.py -&gt; where our blueprint definition and views are<br/>  models.py -&gt; The module database models definitions<br/>  forms.py -&gt; All the module's web Forms </pre>
<p>The idea is to have separation of concerns, so each module will contain all the necessary views (declared and contained inside a Flask blueprint), web forms, and modules. This modular structure will translate into predictable namespaces for URIs, templates, and Python modules. Continuing to reason with an abstract approach, each module will have the following:</p>
<ul>
<li>Python module (folder with <kbd>__init__.py</kbd>) using its name: <kbd>MODULE_NAME</kbd>. Inside the module is a <kbd>controllers</kbd> Python module that declares a blueprint named <kbd>&lt;MODULE_NAME&gt;_blueprint</kbd> attached <span>to a URL,</span> <kbd>prefix /&lt;MODULE_NAME&gt;</kbd>.</li>
</ul>
<ul>
<li>Template folder inside <kbd>templates</kbd> named <kbd>&lt;MODULE_NAME&gt;</kbd>.</li>
</ul>
<p class="mce-root"/>
<p>This pattern will make the code very predictable to other team members, and very easy to change and extend. If you want to create a brand new feature, just create a new module using the proposed structure, and all team members will immediately guess the new feature's URI namespace, where all views are declared, and where the database models <span>are</span><span> </span><span>defined for this feature. If some bug is identified, you can easily identify where to look for it, and have a much more restricted code base to worry about.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refactoring the code</h1>
                </header>
            
            <article>
                
<p>At first, it looks like a lot has changed but you will see that, taking into account the previously explained structure, the changes are simple and natural.</p>
<p>First, we have moved our SQLAlchemy code to the <kbd>models.py</kbd><span> file inside the <kbd>blog module</kbd> folder. We just want to move the model definitions, not any database initialization code. All initialization code will be kept in the main application module, <kbd>webapp</kbd>, inside <kbd>__init__.py</kbd>. The import section and database-related object creation appear as follows:</span></p>
<pre><span>from </span>flask <span>import </span>Flask<span>, </span>render_template<br/><span>from </span>flask_sqlalchemy <span>import </span>SQLAlchemy<br/><span>from </span>flask_migrate <span>import </span>Migrate<br/><br/><strong>db = SQLAlchemy()</strong><br/><strong>migrate = Migrate()</strong><br/><br/><br/><span>def </span><span>page_not_found</span>(<span>error</span>):<br/>    <span>return </span>render_template(<span>'404.html'</span>)<span>, </span><span>404<br/></span><span><br/>def create_app(config):<br/>...</span></pre>
<p>The main application module will be responsible for creating the Flask application (factory pattern, explained in the next section) and initializing SQLAlchemy.</p>
<p>The <kbd>blog/models.py</kbd><span> file will import the initialized <kbd>db</kbd> object:</span></p>
<pre><strong><span>from </span>.. <span>import </span>db</strong><br/><br/>...<br/>class User(db.Model):<br/>...<br/>class Post(db.Model):<br/>...<br/>class Comment(db.Model):<br/>...<br/>class Tag(db.Model):<br/>...</pre>
<p>Next, the <kbd>CommentForm</kbd> object, along with all the WTForms imports, should be moved to the <kbd>blog/forms.py</kbd> file. The <kbd>forms.py</kbd> file will hold all the WTForms objects related to the blog feature.</p>
<p>The <kbd>forms.py</kbd> file should look like this:</p>
<pre>from flask_wtf import Form 
from wtforms import StringField, TextAreaField 
from wtforms.validators import DataRequired, Length <br/><br/>class CommentForm(Form): 
  ... </pre>
<p>The <kbd>blog_blueprint</kbd> object, all its routes, and the <kbd>sidebar_data</kbd> data function need to be moved to the <kbd>blog/controllers.py</kbd> file in the <kbd>controllers</kbd> folder.</p>
<p>The <kbd>blog/controllers.py</kbd> file should now look like this:</p>
<pre><span>from </span>sqlalchemy <span>import </span>func<br/><span>from </span>flask <span>import </span>render_template<span>, </span>Blueprint<span>, </span>flash<span>, </span>redirect<span>, </span>url_for<br/><span>from </span>.models <span>import </span>db<span>, </span>Post<span>, </span>Tag<span>, </span>Comment<span>, </span>User<span>, </span>tags<br/><span>from </span>.forms <span>import </span>CommentForm<br/><br/>blog_blueprint = Blueprint(<br/>    <span>'blog'</span><span>,<br/></span><span>    </span>__name__<span>,<br/></span><span>    </span><span>template_folder</span>=<span>'../templates/blog'</span><span>,<br/></span><span>    </span><span>url_prefix</span>=<span>"/blog"<br/></span>)<br/><br/><br/><span>def </span><span>sidebar_data</span>():<br/>...</pre>
<p>So, whenever a new feature is needed that is big enough to be a candidate for an application module, a new Python module (folder with an <kbd>__init__.py</kbd><span> file) </span>with the name of the feature is needed with the previously described files. We will be breaking down the application code into logical groups.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Then, we need to import the new feature blueprint into the main <kbd>__init__.py</kbd><span> file and register it in Flask:</span></p>
<pre><span>from </span>.blog.controllers <span>import </span>blog_blueprint<br/><span>from </span>.main.controllers <span>import </span>main_blueprint<br/><br/>...<br/>app.register_blueprint(main_blueprint)<br/>app.register_blueprint(blog_blueprint)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application factories</h1>
                </header>
            
            <article>
                
<p>Now that we are using blueprints in a modular manner, there is another improvement we can make to our abstraction, which creates a <strong>factory</strong> for our application. The concept of a factory comes from the <strong>object-oriented programming</strong> (<strong>OOP</strong>) world, and it simply means a function or an object that creates another object. Our application factory will take one of our <kbd>config</kbd> objects, which we created at the beginning of the book, and return a Flask application object.</p>
<div class="packt_infobox">The object factory design was popularized by the now famous book, <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>, by the Gang of Four. To learn more about these design patterns and how they can help simplify a project's code, look at <a href="https://en.wikipedia.org/wiki/Structural_pattern"><span class="URLPACKT">https://en.wikipedia.org/wiki/Structural_pattern</span></a>.</div>
<p>Creating a factory function for our application object has several benefits. First, it allows the context of the environment to change the configuration of the application. When your server creates the application object to serve, it can take into account any changes in the server that are necessary, and change the configuration object given to the app accordingly. Second, it makes testing much easier because it allows differently configured applications to be tested quickly. Third, multiple instances of the same application using the same configuration can be created very easily. This is useful for situations where web traffic is balanced across several different servers.</p>
<p>Now that the benefits of application factories are clear, let's modify our <kbd>__init__.py</kbd> file to implement one:</p>
<pre><span>from </span>flask <span>import </span>Flask<span>, </span>render_template<br/><span>from </span>flask_sqlalchemy <span>import </span>SQLAlchemy<br/><span>from </span>flask_migrate <span>import </span>Migrate<br/><br/>db = SQLAlchemy()<br/>migrate = Migrate()<br/><br/><br/><span>def </span><span>page_not_found</span>(<span>error</span>):<br/>    <span>return </span>render_template(<span>'404.html'</span>)<span>, </span><span>404<br/></span><span><br/></span><span><br/></span><span>def </span><span>create_app</span>(object_name):<span><br/></span><span>    </span><span>from </span>.blog.controllers <span>import </span>blog_blueprint<br/>    <span>from </span>.main.controllers <span>import </span>main_blueprint<br/><br/>    app = Flask(__name__)<br/>    app.config.from_object(object_name)<br/><br/>    db.init_app(app)<br/>    migrate.init_app(app<span>, </span>db)<br/>    app.register_blueprint(main_blueprint)<br/>    app.register_blueprint(blog_blueprint)<br/>    app.register_error_handler(<span>404</span><span>, </span>page_not_found)<br/>    <span>return </span>app</pre>
<p>The change to the file is very simple: we contained our code in a function that takes a <kbd>config</kbd> object and returns an application object. To start our application using the right configuration from an environment variable, we need to change <kbd>main.py</kbd><span>:</span></p>
<pre><span>import </span>os<br/><span>from </span>webapp <span>import </span>create_app<br/><br/>env = os.environ.get(<span>'WEBAPP_ENV'</span><span>, </span><span>'dev'</span>)<br/>app = create_app(<span>'config.%sConfig' </span>% env.capitalize())<br/><br/><span>if </span>__name__ == <span>'__main__'</span>:<br/>    app.run()</pre>
<p>We also need to modify our <kbd>manage.py</kbd> file in order to work with the <kbd>create_app</kbd> function as follows:</p>
<pre><span>import </span>os<br/><span>from </span>webapp <span>import </span>db<span>, </span>migrate<span>, </span>create_app<br/><span>from </span>webapp.blog.models <span>import </span>User<span>, </span>Post<span>, </span>Tag<br/><br/>env = os.environ.get(<span>'WEBAPP_ENV'</span><span>, </span><span>'dev'</span>)<br/>app = create_app(<span>'config.%sConfig' </span>% env.capitalize())<br/><br/>@<span>app.shell_context_processor<br/></span><span>def </span><span>make_shell_context</span>():<br/>    <span>return </span><span>dict</span>(<span>app</span>=app<span>, </span><span>db</span>=db<span>, </span><span>User</span>=User<span>, </span><span>Post</span>=Post<span>, </span><span>Tag</span>=Tag<span>, </span><span>migrate</span>=migrate)</pre>
<p>When we created our configuration objects, it was mentioned that the environment that the application is running in could change the configuration of the application. This code has a very simple example of that functionality, where an environment variable is loaded and determines which <kbd>config</kbd> object to give to the <kbd>create_app</kbd> function. Environment variables are dynamic name values that are part of a process environment. These environments can be shared by multiple processes, system-wide, user-wide, or for a single process. They can be set in Bash with the following syntax:</p>
<pre>    <strong>$ export WEBAPP_ENV="dev"</strong></pre>
<p>Use this to read a variable:</p>
<pre>    <strong>$ echo $WEBAPP_ENV</strong>
    dev</pre>
<p>You can also delete the variable easily, as follows:</p>
<pre>    <strong>$ unset $WEBAPP_ENV</strong>
    <strong>$ echo $WEBAPP_ENV</strong></pre>
<p>On your production server, you would set <kbd>WEBAPP_ENV</kbd> to <kbd>prod</kbd>. The true power of this setup will become clearer once you deploy to production in <a href="380101ac-fb85-4e2e-b664-8d6de77928f4.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 13</span></a>, <em>Deploying Flask Apps</em>, and when we get to <a href="9ffdc8da-2c26-4e97-8738-eebc7629535c.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 12</span></a>, <em>Testing Flask Apps</em>, which covers testing our project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We have transformed our application into a much more manageable and scalable structure, which will save us a lot of headaches as we move further through the book and add more advanced features. In the next chapter, we will add a login and registration system to our application, and other features to make our site more secure.</p>


            </article>

            
        </section>
    </body></html>