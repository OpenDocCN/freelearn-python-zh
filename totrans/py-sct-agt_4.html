<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Drops, Hideouts, Meetups, and Lairs"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Drops, Hideouts, Meetups, and Lairs</h1></div></div></div><p>We'll extend some of the techniques introduced in <a class="link" href="ch02.html" title="Chapter 2. Acquiring Intelligence Data">Chapter 2</a>, <span class="emphasis"><em>Acquiring Intelligence Data</em></span>, to make RESTful web service requests for geocoding. This will allow us to pinpoint various kinds of secret locations. This will also build on image location processing from <a class="link" href="ch03.html" title="Chapter 3. Encoding Secret Messages with Steganography">Chapter 3</a>, <span class="emphasis"><em>Encoding Secret Messages with Steganography</em></span>.</p><p>We will look at some online datasets that will lead us to more techniques in data gathering. In order to work with a wide variety of data, we will need to add an HTML parser to our toolkit. We'll download BeautifulSoup, since it's very good at tracking down the information buried in HTML pages.</p><p>In this chapter, we'll also look at some more sophisticated Python algorithms. We'll start with geocoding services to translate address and latitude-longitude coordinates.</p><p>We'll look at the <span class="strong"><strong>haversine</strong></span> formula<a id="id457" class="indexterm"/> to compute distances between locations. This will mean using the <code class="literal">math</code> library to access trigonometric functions.</p><p>We'll learn about the various kinds of grid coding schemes, which will help us reduce the complexity of latitude and longitude. These coding schemes will show us a number of data representation techniques. This chapter will show ways to compress numbers via a change in representation.</p><p>We'll see ways to parse HTML <code class="literal">&lt;table&gt;</code> tags and create Python collections that we can work with. We'll also look at online data sources that provide clean data in the JSON format. This can be easier to gather and work with.</p><p>Our goal is to use Python to combine multiple online services. This will allow us to integrate geocoding and data analysis. With that information, we can locate the best place to meet our contacts without traveling too far from our secret base of operations.</p><div class="section" title="Background briefing – latitude, longitude, and GPS"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Background briefing – latitude, longitude, and GPS</h1></div></div></div><p>Before we can get geographic information, we'll need to review some essential terminology. One powerful piece of modern technology that helps civilians as well as secret agents is the <span class="strong"><strong>Global Positioning System</strong></span> (<span class="strong"><strong>GPS</strong></span>), a satellite-based system to determine location. The GPS allows a terrestrial device to pinpoint its location in both space and time.</p><p>The idea underlying GPS<a id="id458" class="indexterm"/> is quite elegant. Each satellite produces a stream of data that includes position and super accurate timestamps. A receiver with multiple streams of data can plug the positions and timestamps into a matrix of simultaneous equations to determine the receiver's position with respect to the various satellites. Given enough satellites, a receiver can precisely calculate latitude, longitude, elevation, and even the current time.</p><p>For more information see <a class="ulink" href="http://en.wikipedia.org/wiki/Global_Positioning_System#Navigation_equations">http://en.wikipedia.org/wiki/Global_Positioning_System#Navigation_equations</a>.</p><p>A position's latitude is<a id="id459" class="indexterm"/> an angle measured relative to the equator and poles. We must provide the direction for this angle: N or S for latitude. For example, 36°50′40.12″N is given in degrees (°), minutes (′), and seconds (″) with the all-important N to show which side of the equator the position is on.</p><p>We can also state latitude as 36°50.6687′N using degrees and minutes; or, we could use 36.844478, known as using decimal degrees. Directions toward the north are written in positive angles. Directions to the south are negative. The underlying <code class="literal">math</code> library works in radians, but radians are not widely used to display positions to humans.</p><p>Longitude is an<a id="id460" class="indexterm"/> angle east of the<a id="id461" class="indexterm"/> <span class="strong"><strong>prime meridian</strong></span> or<a id="id462" class="indexterm"/> the <span class="strong"><strong>Greenwich meridian</strong></span>. Angles to the west of Greenwich are stated as negative numbers. Consequently, 76°17′35.21″W can also be stated as -76.293114.</p><p>When we look at a globe, we notice that the latitude lines are all parallel with the equator. Each degree of latitude is about 60 nautical miles in the north-south direction.</p><p>The longitude lines, however, all intersect at the north and south pole. Those north-south lines are not parallel. On a map or a nautical chart, however, a distortion (actually known as a <span class="strong"><strong>projection</strong></span>) is used<a id="id463" class="indexterm"/> so that the longitude lines are parallel to each other. With our usual experience of driving short distances on land, the distortion doesn't matter much, since we're often constrained to driving on highways that wander around rivers and mountains. What's important is that the rectangular grid of a map is handy, but misleading. Simple analytical plane geometry isn't appropriate. Hence, we have to switch to spherical geometry.</p><div class="section" title="Coping with GPS device limitations"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec68"/>Coping with GPS device limitations</h2></div></div></div><p>A GPS receiver needs to receive data from a number of satellites concurrently; a minimum of three satellites can be used for triangulation. There may be interference with microwave signals indoors, and even outdoors in urban environments, making it difficult (or impossible) to get enough data to properly compute the receiver's location. Tall buildings and other obstructions such as walls, prevent the direct signal access needed for accuracy. It may take a long time to acquire enough high-quality satellite signals to compute a position.</p><p>A common workaround<a id="id464" class="indexterm"/> to the satellite visibility problem is to rely on cellular telephone towers as a way to compute a position very quickly even without GPS satellite data. A phone which is in contact with several cell towers can have the position triangulated based on the overlapping transmission patterns. In many telephone devices, the GPS calculation requires local cellphone towers before it can calculate a GPS position.</p><p>There are many non-phone GPS devices that can be directly connected to a computer to get accurate GPS fixes without relying on cellular data. Navigation computers (mariners call them <span class="strong"><strong>chart plotters</strong></span>) work <a id="id465" class="indexterm"/>without the need to connect to a cellular network. In many cases, we can use modules such as <code class="literal">pyserial</code> to extract data from these devices.</p><p>See <a class="ulink" href="http://pyserial.sourceforge.net">http://pyserial.sourceforge.net</a> for more information on<a id="id466" class="indexterm"/> the pySerial project and how we can use this read data from a GPS device via a serial to a USB adapter.</p></div><div class="section" title="Handling politics – borders, precincts, jurisdictions, and neighborhoods"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec69"/>Handling politics – borders, precincts, jurisdictions, and neighborhoods</h2></div></div></div><p>Borders create <a id="id467" class="indexterm"/>endless problems—some profound, some subtle. The entire sweep of human history seems to center on borders and wars. The edges of neighborhoods <a id="id468" class="indexterm"/>are often subjective. In an urban environment, a block or two may not matter much when discussing the difference between Los Feliz and East Hollywood. On the other hand, this kind of knowledge is what defines the <span class="emphasis"><em>local</em></span> restaurants as recognized by people who live there.</p><p>When it comes to more formal definitions—such as election districts at city, state, and federal levels—the side of the street may have profound implications. In some cities, this political division information is readily available via RESTful web service requests. In other locales, this information is buried in a drawer somewhere, or published in some kind of hard-to-process PDF document.</p><p>Some media companies provide neighborhood information. The LA Times Data Desk, for example, has a fairly rigorous definition of the various neighborhoods around the greater Los Angeles area. For excellent background information on how to work with this kind of information, see <a class="ulink" href="http://www.latimes.com/local/datadesk/">http://www.latimes.com/local/datadesk/</a>.</p></div></div></div>
<div class="section" title="Finding out where we are with geocoding services"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Finding out where we are with geocoding services</h1></div></div></div><p>We'll use some geocoding services to get answers to the following questions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What's the latitude and longitude of a given street address? This is called address geocoding or simply geocoding.</li><li class="listitem" style="list-style-type: disc">Which street address is closest to a given latitude and longitude? This is called reverse geocoding.</li></ul></div><p>There are, of course, many more questions we could ask. We might want to know a route to navigate between two addresses. We might want to know what public transportation choices we have to get from one place to another. For now, we'll limit ourselves to these two essential geocoding questions.</p><p>There are many geocoding services available on the World wide web (WWW). There are a number of terms related to geocoding, including geomarketing, geo targeting, geolocation, and geotagging. They're all essentially similar; they depict location-based information. It can take a fair amount of espionage to track down a service with the features we want.</p><p>The following link gives <a id="id469" class="indexterm"/>a list of services:</p><p>
<a class="ulink" href="http://geoservices.tamu.edu/Services/Geocode/OtherGeocoders/">http://geoservices.tamu.edu/Services/Geocode/OtherGeocoders/</a>
</p><p>This list is far from definitive. Some of the services listed here don't work very well. Some large companies aren't listed; for example, MapQuest appears to be missing. See <a class="ulink" href="http://mapquest.com">http://mapquest.com</a> for more information.</p><p>Most geocoding services want to track usage. For large batches of requests, they want to be paid for the services they offer. Consequently, they issue credentials (a key) that must be part of every request. The procedure to get a key varies from service to service.</p><p>We'll look closely at the services offered by Google. They offer a limited service without the overhead of requesting credentials. Instead of asking us to get a key, they'll throttle our requests if we make too much use of their service.</p><div class="section" title="Geocoding an address"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec70"/>Geocoding an address</h2></div></div></div><p>The forward geocoding service from address<a id="id470" class="indexterm"/> to latitude and longitude can be accessed via Python's <code class="literal">urllib.request</code> module. For a quick review, see the <span class="emphasis"><em>Using a REST API in Python</em></span> section of <a class="link" href="ch02.html" title="Chapter 2. Acquiring Intelligence Data">Chapter 2</a>, <span class="emphasis"><em>Acquiring Intelligence Data</em></span>. This is usually a three-step process.</p><p>Define the parts of the URL. It helps to separate the static portions from the dynamic query portion. We need to use the <code class="literal">urllib.parse.urlencode()</code> function to encode the query string.</p><p>Open the URL using a <code class="literal">with</code> statement context. This will send the request and get the response. The JSON document must be parsed in this <code class="literal">with</code> context.</p><p>Process the object that was<a id="id471" class="indexterm"/> received. This is done outside the <code class="literal">with</code> context. Here's what it looks like:</p><div class="informalexample"><pre class="programlisting">import urllib.request
import urllib.parse
import json

# 1. Build the URL.
form = {
    "address": "333 waterside drive, norfolk, va, 23510",
    "sensor": "false",
    #"key": Provide the API Key here if you're registered,
}
query = urllib.parse.urlencode(form, safe=",")
scheme_netloc_path = "https://maps.googleapis.com/maps/api/geocode/json"
print(scheme_netloc_path+"?"+query)

# 2. Send the request; get the response.
with urllib.request.urlopen(scheme_netloc_path+"?"+query) as geocode:
    print(geocode.info())
    response= json.loads( geocode.read().decode("UTF-8") )

# 3. Process the response object.
print(response)</pre></div><p>We have created a dictionary with the two required fields: <code class="literal">address</code> and <code class="literal">sensor</code>. If you want to sign up with Google for additional support and higher-volume requests, you can get an API key. It will become a third field in the request dictionary. We used a <code class="literal">#</code> comment to include a reminder about the use of the key item.</p><p>An HTML web page form is essentially this kind of dictionary with names and values. When the browser makes a request, the form is encoded before it is transmitted to the web server. Our Python program does this using <code class="literal">urllib.parse.urlencode()</code> to encode the form data into something that a web server can use.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>Google requires us to use the <code class="literal">safe=","</code> parameter. This assures us that the <code class="literal">","</code> characters in the address will be <a id="id472" class="indexterm"/>preserved instead of being rewritten as <code class="literal">"%2C"</code>.</p></div></div><p>A complete URL has a scheme, location, path, and an optional query. The scheme, location, and path tend to remain fixed. We assembled a complete URL from the fixed portions and the dynamic query content, printed it, and also used it as an argument to the <code class="literal">urllib.request.urlopen()</code> function.</p><p>In the <code class="literal">with</code> statement, we created a processing context. This will send the request and read the response. Inside the <code class="literal">with</code> context, we printed the headers to confirm that the request worked. More<a id="id473" class="indexterm"/> importantly, we loaded the JSON response, which will create a Python object. We saved that object in the <code class="literal">response</code> variable.</p><p>After creating the Python object, we can release the resources tied up in making the geocoding request. Leaving the indented block of the <code class="literal">with</code> statement assures that all the resources are released and the file-like response is closed.</p><p>After the <code class="literal">with</code> context, we can work with the response. In this case, we merely print the object. Later, we'll do more with the response.</p><p>We'll see three things, as shown in the following snippet—the URL that we built, headers from the HTTP response, and finally the geocoding output as a JSON-formatted document:</p><div class="informalexample"><pre class="programlisting">https://maps.googleapis.com/maps/api/geocode/json?sensor=false&amp;address=333+waterside+drive,+norfolk,+va,+23510

Content-Type: application/json; charset=UTF-8
Date: Sun, 13 Jul 2014 11:49:48 GMT
Expires: Mon, 14 Jul 2014 11:49:48 GMT
Cache-Control: public, max-age=86400
Vary: Accept-Language
Access-Control-Allow-Origin: *
Server: mafe
X-XSS-Protection: 1; mode=block
X-Frame-Options: SAMEORIGIN
Alternate-Protocol: 443:quic
Connection: close

{'results': [{'address_components': [{'long_name': '333',
                                      'short_name': '333',
                                      'types': ['street_number']},
                                     {'long_name': 'Waterside Festival Marketplace',
                                      'short_name': 'Waterside Festival Marketplace',
                                      'types': ['establishment']},
                                     {'long_name': 'Waterside Drive',
                                      'short_name': 'Waterside Dr',
                                      'types': ['route']},
                                     {'long_name': 'Norfolk',
                                      'short_name': 'Norfolk',
                                      'types': ['locality', 'political']},
                                     {'long_name': 'Virginia',
                                      'short_name': 'VA',
                                      'types': ['administrative_area_level_1',
                                                'political']},
                                     {'long_name': 'United States',
                                      'short_name': 'US',
                                      'types': ['country', 'political']},
                                     {'long_name': '23510',
                                      'short_name': '23510',
                                      'types': ['postal_code']}],
              'formatted_address': '333 Waterside Drive, Waterside Festival Marketplace, Norfolk, VA 23510, USA',
              'geometry': {'location': {'lat': 36.844305,
                                        'lng': -76.29111999999999},
                           'location_type': 'ROOFTOP',
                           'viewport': {'northeast': {'lat': 36.84565398029149,
                                                      'lng': -76.28977101970848},
                                        'southwest': {'lat': 36.8429560197085,
                                                      'lng': -76.29246898029149}}},
              'types': ['street_address']}],
 'status': 'OK'}
{'lng': -76.29111999999999, 'lat': 36.844305}</pre></div><p>The JSON document can be loaded using the <code class="literal">json</code> module. This will create a dictionary with two keys: <code class="literal">results</code> and <code class="literal">status</code>. In our example, we loaded the dictionary into a variable named <code class="literal">response</code>. The <a id="id474" class="indexterm"/>value of <code class="literal">response['results']</code> is a list of dictionaries. Since we only requested one address, we only expect one element in this list. Most of what we want, then, is in <code class="literal">response['results'][0]</code>.</p><p>When we examine that structure, we find a subdictionary with four keys. Of those, the <code class="literal">'geometry'</code> key has the geocoding latitude and longitude information.</p><p>We can extend this script to access the location details using the following code:</p><div class="informalexample"><pre class="programlisting">print( response['results'][0]['geometry']['location'])</pre></div><p>This provides us with a small dictionary that looks like this:</p><div class="informalexample"><pre class="programlisting">{'lat': 36.844305, 'lng': -76.29111999999999}</pre></div><p>This is what we wanted to know about the street address.</p><p>Also, as a purely<a id="id475" class="indexterm"/> technical note on the Python language, we included <code class="literal">#</code> comments to show the important steps in our algorithm. A comment starts with <code class="literal">#</code> and goes to the end of the line. In this example, the comments are on the lines by themselves. In general, they can be placed at the end of any line of code.</p><p>Specifically, we called this out with a comment:</p><div class="informalexample"><pre class="programlisting">form = {
    "address": "333 waterside drive, norfolk, va, 23510",
    "sensor": "false",
    #"key": Provide the API Key here if you're registered,
}</pre></div><p>The form dictionary has two keys. A third key can be added by removing the <code class="literal">#</code> comment indicator and filling in the API key that Google has supplied.</p></div><div class="section" title="Reverse geocoding a latitude-longitude point"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec71"/>Reverse geocoding a latitude-longitude point</h2></div></div></div><p>The reverse geocoding service locates nearby addresses from a latitude and longitude position. This kind of query involves a certain amount of inherent ambiguity. A point that's midway between two<a id="id476" class="indexterm"/> large buildings, for example, could<a id="id477" class="indexterm"/> be associated with either or both buildings. Also, we might be interested in different levels of details: rather than a street address, we may only wish to know the state or country for a particular position.</p><p>Here's what this web service request looks like:</p><div class="informalexample"><pre class="programlisting">import urllib.request
import urllib.parse
import json

# 1. Build the URL.
form = {
    "latlng": "36.844305,-76.29112",
    "sensor": "false",
    #"key": Provide the API Key here if you're registered ,
}
query = urllib.parse.urlencode(form, safe=",")
scheme_netloc_path = "https://maps.googleapis.com/maps/api/geocode/json"
print(scheme_netloc_path+"?"+query)

# 2.  Send the request; get the response
with urllib.request.urlopen(scheme_netloc_path+"?"+query) as geocode:
    print(geocode.info())
    response= json.loads( geocode.read().decode("UTF-8") )

# 3. Process the response object.
for alt in response['results']:
    print(alt['types'], alt['formatted_address'])</pre></div><p>The form has two required fields: <code class="literal">latlng</code> and <code class="literal">sensor</code>.</p><p>Signing up with Google for additional support and higher-volume requests requires an API key. It would <a id="id478" class="indexterm"/>become a third field in the request form; we have left a <code class="literal">#</code> comment in the code as a reminder.</p><p>We encoded the form data and assigned it to the <code class="literal">query</code> variable. The <code class="literal">safe=","</code> parameter assures us that the <code class="literal">","</code> characters in the latitude-longitude pair will be preserved instead of being rewritten into a <code class="literal">%2C</code> escape code.</p><p>We assembled a complete<a id="id479" class="indexterm"/> address from the fixed portions of the URL (the scheme, net location, and path) plus the dynamic query content. The scheme, location, and path are generally fixed. The query is encoded from the form data.</p><p>In the <code class="literal">with</code> statement, we created a processing context to send the request and read the response. Inside the <code class="literal">with</code> context, we displayed the headers and loaded the resulting JSON document, creating a Python object. Once we have the Python object, we can exit the processing context and release the resources.</p><p>The response is a Python dictionary. There are two keys: <code class="literal">'results'</code> and <code class="literal">'status'</code>. The value of <code class="literal">response['results']</code> is a list of dictionaries. There are a number of alternative addresses in the <code class="literal">results</code> list. Each result is a dictionary with two interesting keys: the <code class="literal">'types'</code> key, which shows the type of address and the <code class="literal">'formatted_address'</code> key, which is a well-formatted address close to the given location.</p><p>The output looks like this:</p><div class="informalexample"><pre class="programlisting">['street_address'] 333 Waterside Drive, Waterside Festival Marketplace, Norfolk, VA 23510, USA
['postal_code'] Norfolk, VA 23510, USA
['locality', 'political'] Norfolk, VA, USA
['administrative_area_level_1', 'political'] Virginia, USA
['country', 'political'] United States</pre></div><p>Each of the alternatives<a id="id480" class="indexterm"/> shows a hierarchy of nested political<a id="id481" class="indexterm"/> containers for the address: postal code, locality, state (called <code class="literal">administrative_area_level_1</code>), and country.</p></div></div>
<div class="section" title="How close? What direction?"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>How close? What direction?</h1></div></div></div><p>In order to calculate the distance between two points, we'll need to use some spherical geometry calculations. The problem we will have to overcome is that our charts and maps are flat. But the actual planet is <a id="id482" class="indexterm"/>very close to being spherical. While the spherical geometry may be a bit advanced, the programming is pretty simple. It will show us several features of the Python <code class="literal">math</code> library.</p><p>The distance between two latitude and longitude points on a sphere is defined as follows:</p><div class="mediaobject"><img src="graphics/0420OS_04_01.jpg" alt="How close? What direction?"/></div><p>This formula determines the cosine between the two positions; the angle with that cosine is multiplied by the radius of the earth, R, to get the distance along the surface. We can use R = 3,440 NM, R = 3,959 mi, or R = 6,371 km; we get reasonably accurate distances in nautical miles, statute miles, or kilometers.</p><p>This formula doesn't work well with small distances. The haversine formula is preferred to compute distances more accurately. Here is<a id="id483" class="indexterm"/> some background information <a class="ulink" href="http://en.wikipedia.org/wiki/Haversine_formula">http://en.wikipedia.org/wiki/Haversine_formula</a>.</p><p>According to the OED, the term "haversine" was coined in 1835 by Prof. James Inman. The term refers to the way the sine function is used.</p><p>The haversine calculation<a id="id484" class="indexterm"/> is often shown as a sequence of five steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><div class="mediaobject"><img src="graphics/0420OS_04_02.jpg" alt="How close? What direction?"/></div></li><li class="listitem"><div class="mediaobject"><img src="graphics/0420OS_04_03.jpg" alt="How close? What direction?"/></div></li><li class="listitem"><div class="mediaobject"><img src="graphics/0420OS_04_04.jpg" alt="How close? What direction?"/></div></li><li class="listitem"><div class="mediaobject"><img src="graphics/0420OS_04_05.jpg" alt="How close? What direction?"/></div></li><li class="listitem"><div class="mediaobject"><img src="graphics/0420OS_04_06.jpg" alt="How close? What direction?"/></div></li></ol></div><p>The required sine, cosine, and square root portions of this are part of Python's <code class="literal">math</code> library. When we look at the<a id="id485" class="indexterm"/> definitions of sine and cosine, we see that they work in radians. We'll need to convert our latitude and longitude values from degrees to radians. The rule is simple (<span class="inlinemediaobject"><img src="graphics/0420OS_04_07.jpg" alt="How close? What direction?"/></span>), but the <code class="literal">math</code> library includes a function, <code class="literal">radians()</code>, which will do this for us.</p><p>We can look at <a class="ulink" href="http://rosettacode.org/wiki/Haversine_formula#Python">http://rosettacode.org/wiki/Haversine_formula#Python</a> to learn from the example already there.</p><p>We'll use this as the distance between two points:</p><div class="informalexample"><pre class="programlisting">from math import radians, sin, cos, sqrt, asin

MI= 3959
NM= 3440
KM= 6371

def haversine( point1, point2, R=MI ):
    """Distance between points.
    point1 and point2 are two-tuples of latitude and longitude.
    R is radius, R=MI computes in miles.
    """
    lat_1, lon_1 = point1
    lat_2, lon_2 = point2

    Δ_lat = radians(lat_2 - lat_1)
    Δ_lon = radians(lon_2 - lon_1)
    lat_1 = radians(lat_1)
    lat_2 = radians(lat_2)

    a = sin(Δ_lat/2)**2 + cos(lat_1)*cos(lat_2)*sin(Δ_lon/2)**2
    c = 2*asin(sqrt(a))

    return R * c</pre></div><p>We've imported the five functions from the <code class="literal">math</code> library that we require for this calculation.</p><p>We've defined three constants with the <a id="id486" class="indexterm"/>earth's radius in various units. We can plug any of these into our <code class="literal">haversine()</code> function as the <code class="literal">R</code> parameter to compute distances in different units. These values are approximations, but they'll work to determine how far apart two points are. We can plug in more accurate values if we want more precise answers. Since the earth isn't perfectly spherical, we have to be sure to use mean radius values.</p><p>The <code class="literal">haversine()</code> function<a id="id487" class="indexterm"/> will accept two required positional parameters and an optional parameter. The two positional parameters will be two-tuples of latitude and longitude. We'd like to use a syntax like <code class="literal">(36.12, -86.67)</code> to keep the two coordinates bound in a single Python value. The <code class="literal">R</code> parameter is optional because we've provided a default value for it. We can use this function to get distances in kilometers instead of in miles: <code class="literal">haversine( (36.12, -86.67), (33.94, -118.40), R=KM)</code>.</p><p>The body of our function breaks down the two-tuples into their component latitude and longitude values. We compute the <code class="literal">Δ_lat</code> variable by subtracting and converting the result to radians. Similarly, we compute the <code class="literal">Δ_lon</code> variable by subtracting and converting the result to radians. And yes variable names which begin with the Greek Δ character are perfectly valid in Python. After this, we can also convert the other two latitudes to radians. We can then plug these values to other formulae to compute <code class="literal">a</code>, <code class="literal">c</code>, and finally the distance.</p><p>We have a test case based on the example from the Rosetta Code website:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; from ch_4_ex_3 import haversine
&gt;&gt;&gt; round(haversine((36.12, -86.67), (33.94, -118.40), R=6372.8), 5)
2887.25995</pre></div><p>Note that we rounded the answer to five decimal places. Floating-point numbers are an approximation; it's possible to see some variations between hardware and OS in precisely how floating-point numbers work. By limiting ourselves to five decimal places, we're confident that variations in hardware won't upset the test case.</p><p>We can use this <code class="literal">haversine()</code> function with our geocode results to compute distances between locations; this will help us find the closest locations.</p><div class="section" title="Combining geocoding and haversine"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec72"/>Combining geocoding and haversine</h2></div></div></div><p>Between geocoding and the <code class="literal">haversine()</code> function, we have the tools to compute the approximate distance between addresses.</p><p>Let's take 333 Waterside, Norfolk, Virginia, as our current base of operations. Let's say our informant wants to<a id="id488" class="indexterm"/> meet either at 456 Granby or 111 W Tazewell. Which one is closer?</p><p>First, we'll need to<a id="id489" class="indexterm"/> clean up our geocoding script to make it a usable function. Rather than simply printing a result, we'll need to get the values out of the results dictionary to make a sequence of the two-tuples of the latitude and longitude responses.</p><p>Here's what we'll need to add:</p><div class="informalexample"><pre class="programlisting">    def geocode( address ):
    ...  The previous processing ... 
    loc_dict= [r['geometry']['location'] for r in response['results']]
    loc_pairs= [(l['lat'],l['lng']) for l in loc_dict]
    return loc_pairs</pre></div><p>We've used two generator expressions to dismantle the results. The first generator expression took the location information from each alternative in the <code class="literal">response['results']</code> sequence. For geocoding, there should only be one expression, but it's simpler if we pretend we'll get multiple responses.</p><p>The second generator expression turned the <code class="literal">'lat'</code> and <code class="literal">'lng'</code> elements of the location dictionary into a two-tuple. Having latitude and longitude two-tuples will play well with our <code class="literal">havesine()</code> function.</p><p>Here's how we can get three latitude-longitude pairs:</p><div class="informalexample"><pre class="programlisting">base = geocode( "333 Waterside, Norfolk, VA, 23510" )[0]
loc1 = geocode( "456 Granby St, Norfolk, VA" )[0]
loc2 = geocode( "111 W Tazewell, Norfolk, VA" )[0]</pre></div><p>We've applied our <code class="literal">geocode()</code> function to get a list of two-tuples and then used <code class="literal">[0]</code> to pick the first element from each response list.</p><p>Here's how we can report the distances from the base to each location:</p><div class="informalexample"><pre class="programlisting">print("Base", base)
print("Loc1", loc1, haversine(base, loc1))
print("Loc2", loc2, haversine(base, loc2))</pre></div><p>We applied our <code class="literal">haversine()</code> function to compute distances. By default, the distances are in miles, not that the units matter to carry out a relative comparison of closer versus further away.</p><p>Here are the results:</p><div class="informalexample"><pre class="programlisting">Base (36.8443027, -76.2910835)
Loc1 (36.8525159, -76.2890381) 0.578671972401055
Loc2 (36.8493341, -76.291527) 0.3485214316218753</pre></div><p>We can see that the second location (<code class="literal">Loc2</code>), the Tazewell address, is much closer to our base than the Granby street address.</p><p>Also, we can see<a id="id490" class="indexterm"/> that we need to format these numbers to make them look better. Since we're only working with an approximate <a id="id491" class="indexterm"/>mean earth radius in miles, most of those decimal places are just visual noise.</p></div></div>
<div class="section" title="Compressing data to make grid codes"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Compressing data to make grid codes</h1></div></div></div><p>Latitudes and longitudes are bulky to transmit. They have a lot of digits and some peculiar punctuation. Over the years, some alternatives have risen that abbreviate a location using a simpler notation. The essential idea is to convert latitude and longitude numbers from their degree-minute-second numbers into a sequence of letters and digits that represent the same information.</p><p>We'll look at three<a id="id492" class="indexterm"/> compression schemes: the GeoRef system, the Maindenhead Locator, and NAC. Each of these encodings involves doing some arithmetic calculations to convert numbers from decimal (base 10) to another base. We'll also use a number of string operations to translate numbers to characters and characters to numbers.</p><p>Another interesting programming issue is that these encodings don't work directly with latitudes and longitudes. The problem with simply using latitudes and longitudes is that they're signed numbers: -90 (S) to +90 (N) and -180 (W) to +180 (E). Also, longitudes have a bigger range (360 values), whereas latitudes have a smaller range (180 values). To simplify the encoding, we'll apply a common programming hack: we'll offset and scale the values. We'll see a number of ways to apply this clever technique.</p><p>In effect, the scaling and offsetting moves the map's (0, 0) origin to somewhere in Antarctica: at the south pole and right on 180° longitude. The center of these grid maps is somewhere off the coast of West Africa, and the upper-right corner will wind up in the Bering Sea, right at the north pole and next to the 180° longitude.</p><div class="section" title="Creating GeoRef codes"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec73"/>Creating GeoRef codes</h2></div></div></div><p>The GeoRef system<a id="id493" class="indexterm"/> compresses a latitude-longitude position using four letters and as many as eight digits. This<a id="id494" class="indexterm"/> system can also be used to encode descriptions of regions as well as altitudes. We'll stick with locations on the surface.</p><p>For some background <a id="id495" class="indexterm"/>information, see <a class="ulink" href="http://en.wikipedia.org/wiki/Georef">http://en.wikipedia.org/wiki/Georef</a>.</p><p>This system encodes decimal numbers using 24-letter codes chosen from A to Z, omitting I and O. This means that we can't simply rely on a handy copy of the alphabet such as <code class="literal">string.ascii_uppercase</code> to provide the letter codes. We'll have to define our own GeoRef letters. We can compute the letters with an expression as follows:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; string.ascii_uppercase.replace("O","").replace("I","")
'ABCDEFGHJKLMNPQRSTUVWXYZ'</pre></div><p>The GeoRef codes slice the world map into a 12 x 24 grid of 15° x 15° quadrangles. The latitude is measured in<a id="id496" class="indexterm"/> positive numbers from the South Pole. The longitude is measured in positive numbers from the International Date Line. When we divide 180° of latitude into 15° steps, we can encode a part of this three-digit number using 12 letters from A to M (omitting I). When we divide 360° of longitude into 15° steps, we can encode a part of this<a id="id497" class="indexterm"/> three-digit number using 24 letters from A to Z (omitting I and O).</p><p>We can then divide each 15° quadrangles into 15 bands using letters A to Q (again, skipping I and O). This creates a four- character code for the entire degrees portion of a latitude and longitude position.</p><p>If we had a latitude of 38°17′10″N, we'd offset this to be 128° north of the south pole and divide it by 15°:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; divmod(38+90,15)
(8, 8)</pre></div><p>These values are encoded as J and J.</p><p>A longitude of 76°24′42″W is encoded as shown in the following code. This is -76.41167°, which we offset by 180° before using <code class="literal">divmod</code> to calculate the two characters:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; divmod( -76+180, 15 )
(6, 14)</pre></div><p>This gives us letters G and P. We interleave longitude and latitude characters so that the whole string is GJPJ. We've encoded six digits of latitude and longitude into four characters.</p><p>The leftover minutes and seconds can be encoded as two, three, or four digits. For the latitude, 17′10″ can be encoded as 17.16 minutes. This is 17, an intermediate 171, or a detailed 1716.</p><p>Here's the entire encoder the for GeoRef codes:</p><div class="informalexample"><pre class="programlisting">def ll_2_georef( lat, lon ):
    f_lat, f_lon = lat+90, lon+180
    lat_0, lat_1 = divmod( int(f_lat), 15 )
    lon_0, lon_1 = divmod( int(f_lon), 15 )
    lat_m, lon_m = 6000*(f_lat-int(f_lat)), 6000*(f_lon-int(f_lon))
    return "{lon_0}{lat_0}{lon_1}{lat_1}{lon_m:04d}{lat_m:04d}".format(
        lon_0= georef_uppercase[lon_0],
        lat_0= georef_uppercase[lat_0],
        lon_1= georef_uppercase[lon_1],
        lat_1= georef_uppercase[lat_1],
        lon_m= int(lon_m),
        lat_m= int(lat_m),
    ) </pre></div><p>We offset the latitudes and longitudes so that we don't have to deal with signed numbers. We used the <code class="literal">divmod()</code> function to divide by 15° and get both a quotient and a remainder. We can then use our <code class="literal">georef_uppercase</code> letters to translate the numeric quotients and remainders into expected character codes.</p><p>The fractional <a id="id498" class="indexterm"/>values, for example, <code class="literal">f_lat-int(f_lat)</code>, are scaled by 6000 to create a number between 0000 and 5999, which is simply the number of minutes in 100ths.</p><p>We've used the string <code class="literal">format()</code> method to assemble the four-character codes and four-digit numeric <a id="id499" class="indexterm"/>codes into a single string. The first two letters are longitude and latitude to provide a position to the nearest 15°. The next two letters have more longitude and latitude details to refine this to the nearest 1°. The digits are in two blocks of four to provide the detailed minutes.</p><p>Here's a more complete example of the output. We'll encode 36°50.63′N 076°17.49′W:</p><div class="informalexample"><pre class="programlisting">lat, lon = 36+50.63/60, -(76+17.49/60)
print(lat, lon)
print(ll_2_georef(lat, lon))</pre></div><p>We've converted degrees and minutes to degrees. Then, we applied our GeoRef conversion to the values in degrees. Here's what the output looks like:</p><div class="informalexample"><pre class="programlisting">36.843833333333336 -76.2915
GJPG42515063</pre></div><p>The code <code class="literal">GJPG</code> is an approximation of the given location; it could be off by almost 80 nautical miles at the equator. The error gets smaller toward the poles. The code <code class="literal">GJPG4250</code> uses the two-digit encoding of whole minutes to get within a few miles of the coordinates.</p></div></div>
<div class="section" title="Decoding a GeoRef code"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Decoding a GeoRef code</h1></div></div></div><p>When we decode a GeoRef code, we have<a id="id500" class="indexterm"/> to separate the two parts: the four characters at the beginning and the numeric details at the end. Once we've split off the first four characters, we can divide the number of remaining characters in half. One half of the digits will be longitude and the rest will be latitude.</p><p>The first four characters must be looked up in our special GeoRef alphabet. We'll find each character's position in the <code class="literal">ABCDEFGHJKLMNPQRSTUVWXYZ</code> string to get a numeric value. An expression such as <code class="literal">georef_uppercase.find('Q')</code> gives us 14: the position of Q in that alphabet. We can then multiply one position by 15° and add the other position number to<a id="id501" class="indexterm"/> translate two characters to the degrees portion of GeoRef.</p><p>The remaining digits are simply minutes, which are 1/60 of a degree. During conversion there is a matter of creating a number and possibly dividing it by 10 or 100. The final step is to take out the offsets that were used to avoid signed arithmetic.</p><p>The whole thing looks like this:</p><div class="informalexample"><pre class="programlisting">def georef_2_ll( grid ):
    lon_0, lat_0, lon_1, lat_1= grid[:4]
    rest= grid[4:]
    pos= len(rest)//2
    if pos:
        scale= { 4: 100, 3: 10, 2: 1 }[pos]
        lon_frac, lat_frac = float(rest[:pos])/scale, float(rest[pos:])/scale
    else:
        lon_frac, lat_frac = 0, 0
    lat= georef_uppercase.find(lat_0)*15+georef_uppercase.find(lat_1)+lat_frac/60
    lon= georef_uppercase.find(lon_0)*15+georef_uppercase.find(lon_1)+lon_frac/60
    return lat-90, lon-180</pre></div><p>This works by separating the first four positions of the code into four longitude and latitude characters. Note that the positions are interleaved: longitude first, latitude second.</p><p>The rest of the string is divided in half. If there are any characters in the second half, then the first half (two, three, or four characters) will be longitude minutes; the second half will be latitude minutes.</p><p>We've used a simple literal mapping from the length (two, three, or four) to the scaling values (1, 10, and 100). We defined a dictionary with the mapping from the position to scale factor and applied the number of positions, <code class="literal">pos</code>, to that dictionary. We could have done this using an arithmetic calculation, too: <code class="literal">10**(pos-1)</code>; this calculation also works to convert <code class="literal">pos</code> to a power of 10.</p><p>We will take the string of characters, convert them to float and then scale them to create a proper value for minutes. Here is an example of what the scaling looks like:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; float("5063")/100
50.63</pre></div><p>The <code class="literal">else</code> condition handles the case where there are only four positions in the grid code. If this is true, then<a id="id502" class="indexterm"/> the letters are all we have and the minutes will be zero.</p><p>We can calculate the offset values using one letter scaled by 15°, the next letter scaled by 1°, and the minutes by the 60th of a degree. The final step, of course, is to remove the offsets to create the expected signed numbers.</p><p>Consider that we use this:</p><div class="informalexample"><pre class="programlisting">print( georef_2_ll( "GJPG425506" ) )</pre></div><p>We'll see an output like this:</p><div class="informalexample"><pre class="programlisting">(36.843333333333334, -76.29166666666667)</pre></div><p>We chopped the longer GeoRef down to a 10-digit code. This has two 3-digit encodings of the minutes. We have elected to lose some accuracy, but this can also simplify the transmission of secret information.</p><div class="section" title="Creating Maidenhead grid codes"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec74"/>Creating Maidenhead grid codes</h2></div></div></div><p>As compared<a id="id503" class="indexterm"/> to relatively simple grid codes covered previously, we have an alternative notation called the <span class="strong"><strong>Maidenhead system</strong></span>. This is used by Ham <a id="id504" class="indexterm"/>radio operators to exchange information about the locations of their stations. Maidenhead is a town in England; the Maidenhead code is <span class="strong"><strong>IO91PM</strong></span>. </p><p>For more<a id="id505" class="indexterm"/> information, see <a class="ulink" href="http://en.wikipedia.org/wiki/Maidenhead_Locator_System">http://en.wikipedia.org/wiki/Maidenhead_Locator_System</a>.</p><p>The Maidenhead algorithms involve somewhat more sophisticated math based on creating a base 240 representation of the latitude and longitude numbers. We can encode each <span class="emphasis"><em>digit</em></span> of a base 240 number using a letter-digit combination. We'll show a common technique to convert a floating-point number to an integer using a series of steps.</p><p>The Maidenhead system slices the world map into a 180 × 180 grid of quadrangles; each quadrangle has 1° in the N-S direction and 2° in the E-W direction. We can encode these quadrangles using a base 240 numbering system where a letter and digit are used to denote each of the digits of the base 240 system. Since the grid is only 180×180, we don't need the full range of our base 240 numbers.</p><p>To specify a position more accurately, we can slice each cell of the grid into 240 x 240 smaller cells. This means that an eight-position code gets us within .25 nautical miles in the N-S direction and .5 nautical miles in the E-W direction. For Ham radio purposes, this may be sufficient. For our address-level geocoding, we'll need more accuracy.</p><p>We can apply the same letter-number operation a third time, dividing each tiny rectangle into 240 even <a id="id506" class="indexterm"/>smaller pieces. This gets us more than the accuracy we need.</p><p>We are creating a three-digit number in a 240-number system where <a id="id507" class="indexterm"/>each base 240 digit is represented by a letter-number pair. We're performing the following calculation to create the three digits <span class="inlinemediaobject"><img src="graphics/0420OS_04_08.jpg" alt="Creating Maidenhead grid codes"/></span> that encode a number, <span class="inlinemediaobject"><img src="graphics/0420OS_04_09.jpg" alt="Creating Maidenhead grid codes"/></span>:</p><div class="mediaobject"><img src="graphics/0420OS_04_10.jpg" alt="Creating Maidenhead grid codes"/></div><p>Here's the whole process:</p><div class="informalexample"><pre class="programlisting">def ll_2_mh( lat, lon ):
    def let_num( v ):
        l, n = divmod( int(v), 10 )
        return string.ascii_uppercase[l], string.digits[n]
    f_lat= lat+90
    f_lon= (lon+180)/2
    y0, y1 = let_num( f_lat )
    x0, x1 = let_num( f_lon )
    f_lat= 240*(f_lat-int(f_lat))
    f_lon= 240*(f_lon-int(f_lon))
    y2, y3 = let_num( f_lat )
    x2, x3 = let_num( f_lon )
    f_lat= 240*(f_lat-int(f_lat))
    f_lon= 240*(f_lon-int(f_lon))
    y4, y5 = let_num( f_lat )
    x4, x5 = let_num( f_lon )
    return "".join( [
        x0, y0, x1, y1, x2, y2, x3, y3, x4, y4, x5, y5 ] )</pre></div><p>We've defined an internal function, <code class="literal">let_num()</code>, inside our <code class="literal">ll_2_mh()</code> function. The internal <code class="literal">let_num()</code> function<a id="id508" class="indexterm"/> translates a number in the 0 to 240 range into a letter and a digit. It uses the<a id="id509" class="indexterm"/> <code class="literal">divmod()</code> function to decompose the number into a quotient from 0 to 24 and a remainder from 0 to 9. This function then uses these two numeric values as indices in the <code class="literal">string.ascii_uppercase</code> and <code class="literal">string.digits</code> strings to return two characters. Each letter-number pair is a representation for a single digit of the base 240 number system. Rather than invent 240-digit symbols, we've repurposed a letter-digit pair to write the 240 distinct values.</p><p>The first real step is to convert the raw, signed latitude and longitude to our maidenhead grid version. The <code class="literal">f_lat</code> variable is the original latitude with an offset of 90 to make it strictly positive, in the range 0 to 180. The <code class="literal">f_lon</code> variable is the original longitude offset by 180 and divided<a id="id510" class="indexterm"/> by 2 to make it strictly positive, in the range 0 to 180. We created the initial letter-number pairs from these initial values of degrees: <code class="literal">f_lat</code> and <code class="literal">f_lon</code>.</p><p>This works nicely<a id="id511" class="indexterm"/> for degrees. What about the fractions of a degree? Here's a common technique to work with representations of floating-point values.</p><p>If we use something like <code class="literal">lat-int(lat)</code>, we'll compute the fractional portion of the latitude. If we scale that by 240, we'll get a number that we can use with <code class="literal">divmod()</code> to get one of the 240-letter positions and a digit. The expression <code class="literal">240*(f_lat-int(f_lat))</code> will expand the fractional part of <code class="literal">f_lat</code> to a scale of 0 to 240. Here's an example of how this scaling works:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; f_lat= 36.84383
&gt;&gt;&gt; 240*(f_lat-int(f_lat))
202.51919999999927
&gt;&gt;&gt; 240*.84383
202.51919999999998</pre></div><p>The original latitude is <code class="literal">36.84383</code>. The value of <code class="literal">f_lat-int(f_lat)</code> will be the fractional portion of that value, which is <code class="literal">.84383</code>. We multiply this by <code class="literal">240</code> to get the value, with an approximate result of <code class="literal">202.5192</code>.</p><p>We used the <code class="literal">let_num()</code> function to create a letter-and-digit pair. The remaining fractional value (<code class="literal">0.5192</code>) can be scaled again by 240 to get yet another letter-and-digit pair.</p><p>At this point, the details have reached the limit of relevance. 1/240/240 of a degree is about 6 feet. Most civilian GPS instruments are only accurate to about 16 feet.</p><p>The final step is to interleave longitude and latitude characters. We've done this by creating a list of characters in the desired order. The <code class="literal">string.join()</code> method uses the given string as a separator when assembling a list of strings. It's common to use <code class="literal">", ".join(some_list)</code> to create comma-separated items. We have used <code class="literal">"".join()</code> to assemble the final string with no separator characters.</p><p>Here's a more complete example of the output. We'll encode 36°50.63′N 076°17.49′W:</p><div class="informalexample"><pre class="programlisting">lat, lon = 36+50.63/60, -(76+17.49/60)
print( lat, lon )
print( ll_2_mh( lat, lon ) )</pre></div><p>We converted degrees and minutes to degrees. Then, we applied our Maidenhead conversion to the values in degrees. The output looks like this:</p><div class="informalexample"><pre class="programlisting">36.843833333333336 -76.28333333333333
FM16UU52AM44</pre></div><p>We can use<a id="id512" class="indexterm"/> portions of this to encode with varying <a id="id513" class="indexterm"/>degrees of accuracy. <code class="literal">FM16</code> is pretty coarse, whereas <code class="literal">FM16UU</code> is more accurate.</p></div><div class="section" title="Decoding the Maidenhead grid codes"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec75"/>Decoding the Maidenhead grid codes</h2></div></div></div><p>To decode the Maidenhead codes, we need to reverse the procedure we used to create the codes from latitudes <a id="id514" class="indexterm"/>and longitudes. We'll need to take all the even positions as a sequence of digits to create the longitude and all the<a id="id515" class="indexterm"/> odd positions as a sequence of digits to create the latitude. By looking up against <code class="literal">string.ascii_uppercase</code> and <code class="literal">string.digits</code>, we can transform characters into numbers.</p><p>Once we have a sequence of numbers, we can apply a sequence of weighing factors and add up the results. The whole thing looks like this:</p><div class="informalexample"><pre class="programlisting">def mh_2_ll( grid ):
    lon= grid[0::2] # even positions
    lat= grid[1::2] # odd positions
    assert len(lon) == len(lat)
    # Lookups will alternate letters and digits
    decode = [ string.ascii_uppercase, string.digits,
              string.ascii_uppercase, string.digits,
              string.ascii_uppercase, string.digits,
              ]
    lons= [ lookup.find(char.upper()) for char, lookup in zip( lon, decode ) ]
    lats= [ lookup.find(char.upper()) for char, lookup in zip( lat, decode ) ]
    weights = [ 10.0, 1.0,
               1/24, 1/240,
               1/240/24, 1/240/240, ]
    lon = sum( w*d for w,d in zip(lons, weights) )
    lat = sum( w*d for w,d in zip(lats, weights) )
    return lat-90, 2*lon-180</pre></div><p>We used Python's very elegant slice notation to take the string apart into even and odd positions. The expression <code class="literal">grid[0::2]</code> specifies a slice of the <code class="literal">grid</code> string. The <code class="literal">[0::2]</code> slice starts at position <code class="literal">0</code>, extends to the very end, and increments by <code class="literal">2</code>. The <code class="literal">[1::2]</code> slice starts at position <code class="literal">1</code>, extends to the very end, and also increments by <code class="literal">2</code>.</p><p>The <code class="literal">decode</code> list contains six strings that will be used to translate each character into a numeric value. The first character will be found in <code class="literal">string.ascii_uppercase</code> and the second character will be found in <code class="literal">string.digits</code>. The positions at which the characters are found in these strings will become the numeric values that we can use to compute latitudes and longitudes.</p><p>For example, the value of <code class="literal">'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.find('M')</code> is <code class="literal">12</code>.</p><p>We've used a generator expression and the <code class="literal">zip()</code> function to do the real work of the translation. The <code class="literal">zip()</code> function<a id="id516" class="indexterm"/> will produce a sequence of pairs; each pair will have one character chosen from the input grid code and one lookup string chosen from the <code class="literal">decode</code> lists. We can then use <code class="literal">lookup.find(char.upper())</code> to locate the given character in the given lookup string. The result <a id="id517" class="indexterm"/>will be a sequence of integer positions.</p><p>Once we have a sequence of the numeric values, we can apply the sequence of weightings to <a id="id518" class="indexterm"/>convert each position to a degree or a fraction of a degree. Again, we used <code class="literal">zip()</code> to create two-tuples from the digits and the weights. The generator then multiplied the numeric value by the weight. The built-in <code class="literal">sum()</code> function created the final value from the numbers and weights.</p><p>For example, we might have a value in the <code class="literal">lons</code> variable of <code class="literal">[5, 1, 20, 6, 0, 0]</code>. The weights are <code class="literal">[10.0, 1.0, 0.0416, 0.00416, 0.00017361, 1.7361e-05]</code>. When we use <code class="literal">zip()</code> to zip these two sequences, we'll get pairs like this:</p><div class="informalexample"><pre class="programlisting">[(5, 10.0), (1, 1.0), (20, 0.0416), 
(6, 0.00416), (0, 0.00017361), 
(0, 1.7361e-05)]</pre></div><p>The products look like this:</p><div class="informalexample"><pre class="programlisting">[50.0, 1.0, 0.832, 0.024959999999999996, 0.0, 0.0]</pre></div><p>The sum is <code class="literal">51.85696</code>.</p><p>The final step is to undo the offsets we used to force the latitudes to be positive and the longitudes to have values between 0 and 180 instead of -180 to +180. The intermediate longitude result <code class="literal">51.85696</code> becomes <code class="literal">-76.28608</code>.</p><p>Consider that we evaluate this:</p><div class="informalexample"><pre class="programlisting">print( mh_2_ll( "FM16UU62" ) )</pre></div><p>We get the following decoded positions:</p><div class="informalexample"><pre class="programlisting">(36.84166666666667, -76.28333333333333)</pre></div><p>This nicely decodes the values we encoded in the previous section.</p></div></div>
<div class="section" title="Creating natural area codes"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Creating natural area codes</h1></div></div></div><p>The <span class="strong"><strong>Natural Area Code</strong></span> (<span class="strong"><strong>NAC</strong></span>) is yet another way to encode geographic position information into a short<a id="id519" class="indexterm"/> character string. The whole NAC system can include altitude information along with the surface position. We'll focus on the latitude and longitude conversions for NAC.</p><p>See <a class="ulink" href="http://www.nacgeo.com/nacsite/documents/nac.asp">http://www.nacgeo.com/nacsite/documents/nac.asp</a>, for more information</p><p>This uses base 30 instead of base 240; we can use most of the alphabets plus some digits to represent a single base<a id="id520" class="indexterm"/> 30 digit. This implementation will show a different approach to convert floating-point numbers to an integer approximation. This will combine multiple calculation steps into longer expressions.</p><p>NAC uses a 30-character encoding that employs digits and consonants. The string used for encoding and decoding is this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; nac_uppercase= "0123456789BCDFGHJKLMNPQRSTVWXZ"
&gt;&gt;&gt; len(nac_uppercase)
30
&gt;&gt;&gt; nac_uppercase[10]
'B'
&gt;&gt;&gt; nac_uppercase.find('B')
10</pre></div><p>We can take a longitude (-180 to +180), and add an offset to put it in the range of 0 to 360. If we scale this by <code class="literal">(30**4)/360</code>, we'll get a number in the range 0 to 810000. This can be converted to a four-digit base 30 number.</p><p>Similarly, we can take a latitude (-90 to +90), and add an offset to put it in the range of 0 to 180. If we scale this by <code class="literal">(30**4)/180</code>, similarly, we'll get a number that can be converted to a four-digit base 30 number. The big win here is that we've replaced long strings of base 10 digits with shorter strings of base 30 digits.</p><p>The suggested algorithm to encode this is:</p><div class="informalexample"><pre class="programlisting">def ll_2_nac( lat, lon ):
    f_lon= (lon+180)/360
    x0 = int(   f_lon*30)
    x1 = int((  f_lon*30-x0)*30)
    x2 = int((( f_lon*30-x0)*30-x1)*30)
    x3 = int(.5+(((f_lon*30-x0)*30-x1)*30-x2)*30)

    f_lat= (lat+90)/180
    y0 = int(   f_lat*30 )
    y1 = int((  f_lat*30-y0)*30)
    y2 = int((( f_lat*30-y0)*30-y1)*30)
    y3 = int(0.5+(((f_lat*30-y0)*30-y1)*30-y2)*30)

    print( x0, x1, x2, x3, y0, y1, y2, y3 )
    return "".join( [
        nac_uppercase[x0], nac_uppercase[x1], 
        nac_uppercase[x2], nac_uppercase[x3],
        " ",
        nac_uppercase[y0], nac_uppercase[y1], 
        nac_uppercase[y2], nac_uppercase[y3],
    ])</pre></div><p>We've scaled the longitude by adding an offset and dividing it by 360. This creates a number between <code class="literal">0</code> and <code class="literal">1.0</code>. We can then encode this into base 30 using a large number of multiplications<a id="id521" class="indexterm"/> and subtractions. There are a number of ways to optimize this.</p><p>Each step follows a similar pattern. We'll step through the longitude calculation. Here's the first character calculation:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; lon= -151.3947
&gt;&gt;&gt; f_lon= (lon+180)/360
&gt;&gt;&gt; f_lon
0.07945916666666666
&gt;&gt;&gt; x0 = int(f_lon*30)  
&gt;&gt;&gt; x0
2</pre></div><p>The first step computes <code class="literal">f_lon</code>, the fraction of 360 for this longitude (151.3947W). When we multiply <code class="literal">f_lon</code> by <code class="literal">30</code>, we get <code class="literal">2.383775</code>. The integer portion, <code class="literal">2</code>, will become the first character. The fraction will be encoded in the remaining three characters.</p><p>Here's the next character, based on the first:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; x1 = int((f_lon*30-x0)*30)
&gt;&gt;&gt; x1
11</pre></div><p>The calculation of <code class="literal">(f_lon*30-x0)</code> computes the fraction, <code class="literal">.383775</code>. We then scale this by <code class="literal">30</code> to get <code class="literal">11.51325</code>. The integer portion, <code class="literal">11</code>, will become the second character. The fraction will be encoded in the remaining two characters.</p><p>At each step, we take all of the previous digits to compute the remaining fractional components. Here are the last two characters:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; x2 = int((( f_lon*30-x0)*30-x1)*30)
&gt;&gt;&gt; x2
15
&gt;&gt;&gt; x3 = int(0.5+(((f_lon*30-x0)*30-x1)*30-x2)*30)
&gt;&gt;&gt; x3
12 </pre></div><p>Each of these character, takes the difference between the original number (<code class="literal">f_lon</code>) and the previously computed digits to get the remaining fraction. The final step involves a lot of multiplication. Previously, in the <span class="emphasis"><em>Creating Maidenhead grid codes</em></span> section, we showed a variation on this theme that didn't use quite so many multiplication operations.</p><p>As an example, we may perform the following:</p><div class="informalexample"><pre class="programlisting">    lat, lon = 43.6508, -151.3947
    print( ll_2_nac( lat, lon ) )</pre></div><p>The output of this is:</p><div class="informalexample"><pre class="programlisting">    2CHD Q87M</pre></div><p>This is a pretty tidy summary of a<a id="id522" class="indexterm"/> latitude and longitude.</p><div class="section" title="Decoding natural area codes"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec76"/>Decoding natural area codes</h2></div></div></div><p>Decoding natural area codes is actually a conversion from a base 30 number to a value between 0 and 810,000. This<a id="id523" class="indexterm"/> is then scaled into a proper latitude or longitude value. Although base 30 numbers don't seem simple, the programming is actually pretty succinct. Here's the suggested algorithm:</p><div class="informalexample"><pre class="programlisting">def nac_2_ll( grid ):
    X, Y = grid[:4], grid[5:]
    x = [nac_uppercase.find(c) for c in X]
    y = [nac_uppercase.find(c) for c in Y]
    lon = (x[0]/30+x[1]/30**2+x[2]/30**3+x[3]/30**4)*360-180
    lat = (y[0]/30+y[1]/30**2+y[2]/30**3+y[3]/30**4)*180-90
    return lat, lon</pre></div><p>We've decomposed each part of the nine-character NAC grid code into a longitude substring and a latitude substring. We used a generator function to lookup each character in our <code class="literal">nac_uppercase</code> alphabet. This will map each character to a numeric position between 0 and 29.</p><p>Once we have the sequence of the four base 30 digits, we can compute a number from the digits. The following expression does the essential work:</p><div class="informalexample"><pre class="programlisting">(x[0]/30+x[1]/30**2+x[2]/30**3+x[3]/30**4)</pre></div><p>The preceding expression is an optimization of the polynomial, <span class="inlinemediaobject"><img src="graphics/0420OS_04_11.jpg" alt="Decoding natural area codes"/></span>. The Python code simplifies the constants in each term—rather than computing <code class="literal">x[0]*30**3/30**4</code>; this is reduced to <code class="literal">x[0]/30</code>.</p><p>The intermediate results are scaled by 360 or 180 and offset to get the expected signed values for the <a id="id524" class="indexterm"/>final result.</p><p>Consider that we evaluate the following:</p><div class="informalexample"><pre class="programlisting">print( nac_2_ll( "2CHD Q87M" ) )</pre></div><p>We get the following as a result:</p><div class="informalexample"><pre class="programlisting">(43.650888888888886, -151.39466666666667)</pre></div><p>This shows how we decode an NAC to recover the latitude and longitude of a position.</p></div></div>
<div class="section" title="Solving problems &#x2013; closest good restaurant"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Solving problems – closest good restaurant</h1></div></div></div><p>We want to meet our secret informant at a good restaurant that's a reasonable distance from our base. In order<a id="id525" class="indexterm"/> to locate a good restaurant, we need to gather some additional information. In this case, good means a passing grade from the health inspectors.</p><p>Before we can even have a meeting, we'll need to use basic espionage skills to locate the health code survey results for local restaurants.</p><p>We'll create a Python application to combine many things to sort through the results. We'll perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start with the restaurant health score information.</li><li class="listitem">We need to geocode the restaurant addresses if it hasn't been done already. In some cases, geocoding is done for us. In other cases, we'll be using a web service for this.</li><li class="listitem">We need to filter and organize restaurants by good scores. We'll also need to use our <code class="literal">haversine()</code> function to compute the distance from our base.</li><li class="listitem">Finally, we need to communicate this to our network, ideally using a short NAC code embedded within an image that we post to a social media site. See <a class="link" href="ch03.html" title="Chapter 3. Encoding Secret Messages with Steganography">Chapter 3</a>, <span class="emphasis"><em>Encoding Secret Messages with Steganography</em></span>, for details on this final step.</li></ol></div><p>In many cities, the health code data is available online. A careful search will reveal a useful dataset. In other cities, the health inspection data isn't readily available online. We might have to dig considerably deep to track down even a few restaurants near our base of operations.</p><p>Some cities use <span class="strong"><strong>Yelp</strong></span> to publicize restaurant health code inspection data. We can read about the YELP API to <a id="id526" class="indexterm"/>search for restaurants on the following link:</p><p>
<a class="ulink" href="http://www.yelp.com/developers/documentation">http://www.yelp.com/developers/documentation</a></p><p>We might also find some useful data on<a id="id527" class="indexterm"/> InfoChimps at <a class="ulink" href="http://www.infochimps.com/tags/restaurant">http://www.infochimps.com/tags/restaurant</a>.</p><p>One complexity we often encounter is the use of HTML-based APIs for this kind of information. This is not intentional obfuscation, but the use of HTML complicates analysis of the data. Parsing HTML to extract meaningful information isn't easy; we'll need an extra library to handle this.</p><p>We'll look at two approaches: good, clean data and more complex HTML data parsing. In both cases, we need to create a Python object that acts as a container for a collection of attributes. First, we'll divert to look at the <code class="literal">SimpleNamespace</code> class. Then, we'll use this to collect information.</p><div class="section" title="Creating simple Python objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec77"/>Creating simple Python objects</h2></div></div></div><p>We have a wide variety of ways to define our own Python objects. We can use the central built-in types such as dict to<a id="id528" class="indexterm"/> define an object that has a collection of<a id="id529" class="indexterm"/> attribute values. When looking at information for a restaurant, we could use something like this:</p><div class="informalexample"><pre class="programlisting">some_place = { 'name': 'Secret Base', 'address': '333 Waterside Drive' }</pre></div><p>Since this is a mutable object, we can add attribute values and change the values of the existing attributes. The syntax is a bit <span class="emphasis"><em>clunky</em></span>, though. Here's what an update to this object looks like:</p><div class="informalexample"><pre class="programlisting">some_place['lat']= 36.844305
some_place['lng']= -76.29112</pre></div><p>The extra <code class="literal">[]</code> brackets and <code class="literal">''</code> characters seem needless. We'd like to have a notation that's a little cleaner than this very general key-value syntax used for dictionaries.</p><p>One common solution is to use a proper class definition. The syntax looks like this:</p><div class="informalexample"><pre class="programlisting">class Restaurant:
    def __init__(self, name, address):
        self.name= name
        self.address= address</pre></div><p>We've defined a class with an initialization method, <code class="literal">__init__()</code>. The name of the initialization method is special, and only this name can be used. When the object is built, the initialization method is evaluated to assign initial values to the attributes of the object.</p><p>This allows us to create an object more succinctly:</p><div class="informalexample"><pre class="programlisting">some_place= Restaurant( name='Secret Base', address='333 Waterside Drive' )</pre></div><p>We've used explicit keyword arguments. The use of <code class="literal">name=</code> and <code class="literal">address=</code> isn't <span class="emphasis"><em>required</em></span>. However, as class definitions become more complex, it's often more flexible and more clear to use keyword argument values.</p><p>We can update the object nicely too, as follows:</p><div class="informalexample"><pre class="programlisting">some_place.lat= 36.844305
some_place.lng= -76.29112</pre></div><p>This works out best when we have a lot of unique processing that is bound to each object. In this case, we don't actually have any processing to associate with the attributes; we just want to collect those<a id="id530" class="indexterm"/> attributes in a tidy capsule. The formal class definition is too much overhead for such a simple problem.</p><p>Python also gives us a very flexible structure <a id="id531" class="indexterm"/>called a <span class="strong"><strong>namespace</strong></span>. This is a mutable object that we can access using simple attribute names, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">from types import SimpleNamespace
some_place= SimpleNamespace( name='Secret Base', address='333 Waterside Drive' )</pre></div><p>The syntax to create a namespace <span class="emphasis"><em>must</em></span> use keyword arguments (<code class="literal">name='The Name'</code>). Once we've created this object, we can update it using a pleasant attribute access, as shown in the following snippet:</p><div class="informalexample"><pre class="programlisting">some_place.lat= 36.844305
some_place.lng= -76.29112</pre></div><p>The <code class="literal">SimpleNamespace</code> class gives us a way to build an object that contains a number of individual attribute values.</p><p>We can also create a namespace from a dictionary using Python's <code class="literal">**</code> notation. Here's an example:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; SimpleNamespace( **{'name': 'Secret Base', 'address': '333 Waterside Drive'} )
namespace(address='333 Waterside Drive', name='Secret Base')</pre></div><p>The <code class="literal">**</code> notation<a id="id532" class="indexterm"/> tells Python that a dictionary object contains keyword arguments for the function. The dictionary keys are the parameter names. This allows us to build a dictionary object and then use it as the arguments to a function.</p><p>Recall that JSON tends to encode complex data structures as a dictionary. Using this <code class="literal">**</code> technique, we can transform a JSON dictionary into <code class="literal">SimpleNamespace</code>, and replace the clunky <code class="literal">object['key']</code> notation with a cleaner <code class="literal">object.key</code> notation.</p></div><div class="section" title="Working with HTML web services – tools"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec78"/>Working with HTML web services – tools</h2></div></div></div><p>In some cases, the data we<a id="id533" class="indexterm"/> want is tied up in HTML websites. The City <a id="id534" class="indexterm"/>of Norfolk, for example, relies on the State of Virginia's VDH health portal to store its restaurant health code inspection data.</p><p>In order to make sense of the intelligence encoded in the HTML notation on the WWW, we need to be able to parse the HTML markup that surrounds the data. Our job is greatly simplified by the use<a id="id535" class="indexterm"/> of special higher-powered weaponry; in this case, BeautifulSoup.</p><p>Start with <a class="ulink" href="https://pypi.python.org/pypi/beautifulsoup4/4.3.2">https://pypi.python.org/pypi/beautifulsoup4/4.3.2</a> or <a class="ulink" href="http://www.crummy.com/software/BeautifulSoup/">http://www.crummy.com/software/BeautifulSoup/</a>.</p><p>If we have <a id="id536" class="indexterm"/>Easy Install (or PIP), we can use these tools to install BeautifulSoup. Back in <a class="link" href="ch01.html" title="Chapter 1. Our Espionage Toolkit">Chapter 1</a>, <span class="emphasis"><em>Our Espionage Toolkit</em></span>, we should have installed one (or both) of these tools to install more tools.</p><p>We can use Easy Install to<a id="id537" class="indexterm"/> install BeautifulSoup like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo easy_install-3.3 beautifulsoup4 </strong></span>
</pre></div><p>Mac OS X and GNU/Linux users will need to use the <code class="literal">sudo</code> command. Windows users won't use the <code class="literal">sudo</code> command.</p><p>Once we have <a id="id538" class="indexterm"/>BeautifulSoup, we can use it to parse the HTML code looking for specific facts buried in an otherwise cryptic jumble of HTML tags.</p><p>Before we can go on, you'll need to read the quickstart documentation and bring yourself up to speed on BeautifulSoup. Once you've done that, we'll move to extracting data from HTML web pages.</p><p>Start with <a class="ulink" href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/ #quick-start">http://www.crummy.com/software/BeautifulSoup/bs4/doc/#quick-start</a>.</p><p>An<a id="id539" class="indexterm"/> alternative tool is <span class="strong"><strong>scrapy</strong></span>. For<a id="id540" class="indexterm"/> information see <a class="ulink" href="http://scrapy.org">http://scrapy.org</a>. Also, read <span class="emphasis"><em>Instant Scrapy Web Mining and Scraping</em></span>, <span class="emphasis"><em>Travis Briggs</em></span>, <span class="emphasis"><em>Packt Publishing</em></span>, for details on using this tool. Unfortunately, as of this writing, scrapy is focused on Python 2, not Python 3.</p></div><div class="section" title="Working with HTML web services – getting the page"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec79"/>Working with HTML web services – getting the page</h2></div></div></div><p>In the case of VDH health <a id="id541" class="indexterm"/>data for the City of Norfolk, the HTML scraping is reasonably simple. We can leverage the strengths of BeautifulSoup to dig into the HTML page very nicely.</p><p>Once we've created a<a id="id542" class="indexterm"/> BeautifulSoup object from the HTML page, we will have an elegant technique to navigate down through the hierarchy of the HTML tags. Each<a id="id543" class="indexterm"/> HTML tag name (<code class="literal">html</code>, <code class="literal">body</code>, and so on) is also a BeautifulSoup query that locates the first instance of that tag.</p><p>An expression such as <code class="literal">soup.html.body.table</code> can locate the first <code class="literal">&lt;table&gt;</code> in the HTML <code class="literal">&lt;body&gt;</code> tag. In the case of the VDH restaurant data, that's precisely the data we want.</p><p>Once we've found the table, we need to extract the rows. The HTML tag for each row is <code class="literal">&lt;tr&gt;</code> and we can use the BeautifulSoup <code class="literal">table.find_all("tr")</code> expression to locate all rows within a given <code class="literal">&lt;table&gt;</code> tag. Each tag's text is an attribute, <code class="literal">.text</code>. If the tag has attributes, we can treat the tag as if it's a dictionary to extract the attribute values.</p><p>We'll break down the<a id="id544" class="indexterm"/> processing of the VDH restaurant data into two parts: the web services query that builds Soup from HTML and the HTML<a id="id545" class="indexterm"/> parsing to gather restaurant information.</p><p>Here's the first part, which is getting the raw BeautifulSoup object:</p><div class="informalexample"><pre class="programlisting">scheme_host= "http://healthspace.com"
def get_food_list_by_name():
    path= "/Clients/VDH/Norfolk/Norolk_Website.nsf/Food-List-ByName"
    form = {
        "OpenView": "",
        "RestrictToCategory": "FAA4E68B1BBBB48F008D02BF09DD656F",
        "count": "400",
        "start": "1",
    }
    query= urllib.parse.urlencode( form )
    with urllib.request.urlopen(scheme_host + path + "?" + query) as data:
        soup= BeautifulSoup( data.read() )
    return soup</pre></div><p>This repeats the web services queries we've seen before. We've separated three things here: the <code class="literal">scheme_host</code> string, the <code class="literal">path</code> string, and <code class="literal">query</code>. The reason for this is that our overall script will be using the <code class="literal">scheme_host</code> with other paths. And we'll be plugging in lots of different query data.</p><p>For this basic <code class="literal">food_list_by_name</code> query, we've built a form that will get 400 restaurant inspections. The <code class="literal">RestrictToCategory</code> field in the form has a magical key that we must provide to get the Norfolk restaurants. We found this via a basic web espionage technique: we poked around on the website and checked the URLs used when we clicked on each of the links. We also used the Developer mode of Safari to explore the page source.</p><p>In the long run, we want all of the inspections. To get started, we've limited ourselves to 400 so that we don't spend<a id="id546" class="indexterm"/> too long waiting to run a test of our script.</p><p>The response object was used by BeautifulSoup to create an internal representation of the web page. We assigned this to the <code class="literal">soup</code> variable and returned it as the result of the function.</p><p>In addition to<a id="id547" class="indexterm"/> returning the <code class="literal">soup</code> object, it can also be instructive to print it. It's quite a big pile of HTML. We'll need to parse this to get the interesting details away from the markup.</p></div><div class="section" title="Working with HTML web services – parsing a table"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec80"/>Working with HTML web services – parsing a table</h2></div></div></div><p>Once we have a page of HTML information parsed into a BeautifulSoup object, we can examine the details<a id="id548" class="indexterm"/> of that page. Here's a function that will locate the table of restaurant inspection details buried inside the page.</p><p>We'll use<a id="id549" class="indexterm"/> a generator function to<a id="id550" class="indexterm"/> yield each individual row of the table, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">def food_table_iter( soup ):
    """Columns are 'Name', '', 'Facility Location', 'Last Inspection', 
    Plus an unnamed column with a RestrictToCategory key
    """
    table= soup.html.body.table
    for row in table.find_all("tr"):
        columns = [ td.text.strip() for td in row.find_all("td") ]
        for td in row.find_all("td"):
            if td.a:
                url= urllib.parse.urlparse( td.a["href"] )
                form= urllib.parse.parse_qs( url.query )
                columns.append( form['RestrictToCategory'][0] )
        yield columns</pre></div><p>Notice that this function begins with a triple-quoted string. This is a <span class="emphasis"><em>docstring</em></span> and it provides documentation about the function. Good Python style insists on a docstring in every function. The Python help system will display the docstrings for functions, modules, and classes. We've omitted them to save space. Here, we included it because the results of this particular iterator can be quite confusing.</p><p>This function requires a parsed Soup object. The function uses simple tag navigation to locate the first <code class="literal">&lt;table&gt;</code> tag in the HTML <code class="literal">&lt;body&gt;</code> tag. It then uses the table's <code class="literal">find_all()</code> method to locate all of the rows within that table.</p><p>For each row, there are two pieces of processing. First, a generator expression is used to find all the <code class="literal">&lt;td&gt;</code> tags within that row. Each <code class="literal">&lt;td&gt;</code> tag's text is stripped of excess white space and the collection<a id="id551" class="indexterm"/> forms a list of cell values. In some cases, this kind of processing is sufficient.</p><p>In this case, however, we also need to decode an HTML <code class="literal">&lt;a&gt;</code> tag, which has a reference to the details for a given restaurant. We use a second <code class="literal">find_all("td")</code> expression to examine each column again. Within each column, we check for the presence of an <code class="literal">&lt;a&gt;</code> tag using a simple <code class="literal">if td.a:</code> loop. If there is an <code class="literal">&lt;a&gt;</code> tag, we can get the value of the <code class="literal">href</code> attribute on that tag. When<a id="id552" class="indexterm"/> looking at the source HTML, this is the value inside the quotes of <code class="literal">&lt;a href=""&gt;</code>.</p><p>This value<a id="id553" class="indexterm"/> of an HTML <code class="literal">href</code> attribute is a URL. We don't actually need the whole URL. We only need the query string within the URL. We've used the <code class="literal">urllib.parse.urlparse()</code> function to extract the various bits and pieces of the URL. The value of the <code class="literal">url.query</code> attribute is just the query string, after the <code class="literal">?</code>.</p><p>It turns out, we don't even want the entire query string; we only want the value for the key <code class="literal">RestrictToCategory</code>. We can parse the query string with <code class="literal">urllib.parse.parse_qs()</code> to get a form-like dictionary, which we assigned to the variable <code class="literal">form</code>. This function is the inverse of <code class="literal">urllib.parse.urlencode()</code>. The dictionary built by the <code class="literal">parse_qs()</code> function associates each key with a list of values. We only want the first value, so we use <code class="literal">form['RestrictToCategory'][0]</code> to get the key required for a restaurant.</p><p>Since this <code class="literal">food_table_iter ()</code> function is a generator, it must be used with a <code class="literal">for</code> statement or another generator function. We can use this function with a <code class="literal">for</code> statement as follows:</p><div class="informalexample"><pre class="programlisting">for row in  food_table_iter(get_food_list_by_name()):
    print(row)</pre></div><p>This prints each row of data from the HTML table. It starts like this:</p><div class="informalexample"><pre class="programlisting">['Name', '', 'Facility Location', 'Last Inspection']
["Todd's Refresher", '', '150 W. Main St #100', '6-May-2014', '43F6BE8576FFC376852574CF005E3FC0']
["'Chick-fil-A", '', '1205 N Military Highway', '13-Jun-2014', '5BDECD68B879FA8C8525784E005B9926']</pre></div><p>This goes on for 400 locations.</p><p>The results are unsatisfying because each row is a flat list of attributes. The name is in <code class="literal">row[0]</code> and the address in <code class="literal">row[2]</code>. This kind of reference to columns by position can be obscure. It would be<a id="id554" class="indexterm"/> much nicer to have named attributes. If we convert the results to a <code class="literal">SimpleNamespace</code> object, we can then use the <code class="literal">row.name</code> and <code class="literal">row.address</code> syntax.</p></div><div class="section" title="Making a simple Python object from columns of data"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec81"/>Making a simple Python object from columns of data</h2></div></div></div><p>We really want<a id="id555" class="indexterm"/> to work with an object that has easy-to-remember attribute names and not a sequence of anonymous<a id="id556" class="indexterm"/> column names. Here's a generator function that will build a <code class="literal">SimpleNamespace</code> object from a sequence of values produced by a function such as the <code class="literal">food_table_iter()</code> function:</p><div class="informalexample"><pre class="programlisting">def food_row_iter( table_iter ):
    heading= next(table_iter)
    assert ['Name', '', 'Facility Location', 'Last Inspection'] == heading
    for row in table_iter:
        yield SimpleNamespace(
            name= row[0], address= row[2], last_inspection= row[3],
            category= row[4]
        ) </pre></div><p>This function's argument must be an iterator like <code class="literal">food_table_iter(get_food_list_by_name())</code>. The function uses <code class="literal">next(table_iter)</code> to grab the first row, since that's only going to be a bunch of column titles. We'll assert that the column titles really are the standard column titles in the VDH data. If the assertion ever fails, it's a hint that VDH web data has changed.</p><p>For every row <a id="id557" class="indexterm"/>after the first row, we build a <code class="literal">SimpleNamespace</code> object by taking the specific columns from each row and assigning them nice names.</p><p>We can use this function as follows:</p><div class="informalexample"><pre class="programlisting">soup= get_food_list_by_name()
raw_columns=  food_table_iter(soup)
for business in food_row_iter( raw_column ):
    print( business.name, business.address )</pre></div><p>The processing can now use nice attribute names, for example, <code class="literal">business.name</code>, to refer to the data we extracted from the HTML page. This makes the rest of the programming meaningful and clear.</p><p>What's also important is that we've combined two generator functions. The <code class="literal">food_table_iter()</code> function will yield small lists built from HTML table rows. The <code class="literal">food_row_iter()</code> function expects a sequence of lists that can be iterated, and will build <code class="literal">SimpleNamespace</code> objects from that sequence of lists. This defines a kind of composite processing pipeline built from smaller steps. Each row of the HTML table that starts in <code class="literal">food_table_iter()</code> is touched by <code class="literal">food_row_iter()</code> and winds up being processed by the <code class="literal">print()</code> function.</p></div><div class="section" title="Enriching Python objects with geocodes"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec82"/>Enriching Python objects with geocodes</h2></div></div></div><p>The Norfolk data <a id="id558" class="indexterm"/>we've gotten so far is only a list of restaurants. We still neither have inspection scores, nor do<a id="id559" class="indexterm"/> we have useful geocodes. We need to add these details to each business that we found in the initial list. This means<a id="id560" class="indexterm"/> making two more RESTful web services requests for each individual business.</p><p>The geocoding is relatively easy. We can use a simple request and update the <code class="literal">SimpleNamespace</code> object that we're using to model each business. The function looks like this:</p><div class="informalexample"><pre class="programlisting">def geocode_detail( business ):
    scheme_netloc_path = "https://maps.googleapis.com/maps/api/geocode/json"
    form = {
        "address": business.address + ", Norfolk, VA",
        "sensor": "false",
        #"key": An API Key, if you signed up for one,
    }
    query = urllib.parse.urlencode( form, safe="," )
    with urllib.request.urlopen( scheme_netloc_path+"?"+query ) as geocode:
        response= json.loads( geocode.read().decode("UTF-8") )
    lat_lon = response['results'][0]['geometry']['location']
    business.latitude= lat_lon['lat']
    business.longitude= lat_lon['lng']
    return business</pre></div><p>We're using the Google geocoding API that we used earlier. We've made a few modifications. First, the data in the <code class="literal">form</code> variable has the <code class="literal">business.address</code> attribute from the <code class="literal">SimpleNamespace</code> object. We've had to add the city and state information, since that's not provided in the VDH address.</p><p>As with previous <a id="id561" class="indexterm"/>examples, we took only the first location of the response list with <code class="literal">response['results'][0]['geometry']['location']</code>, which is a small dictionary object with two keys: <code class="literal">lat</code> and <code class="literal">lon</code>. We've updated the namespace that represents our business by<a id="id562" class="indexterm"/> setting two more attributes, <code class="literal">business.latitude</code> and <code class="literal">business.longitude</code> from the values in this small dictionary.</p><p>The namespace object is mutable, so this function will update the object referred to by the variable <code class="literal">business</code>. We also returned the object. The <code class="literal">return</code> statement is not necessary, but sometimes it's handy because it allows us to create a fluent API for a sequence of functions.</p></div><div class="section" title="Enriching Python objects with health scores"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec83"/>Enriching Python objects with health scores</h2></div></div></div><p>The bad news is that getting health scoring details requires yet more HTML parsing. The good news is that<a id="id563" class="indexterm"/> the details are placed in an easy-to-locate HTML <code class="literal">&lt;table&gt;</code> tag. We'll break this process into two functions: a web<a id="id564" class="indexterm"/> service request to get the BeautifulSoup object and more HTML parsing to explore that Soup.</p><p>Here's the URL request. This requires the category key that we parsed from the <code class="literal">&lt;a&gt;</code> tag in the <code class="literal">food_table_iter()</code> function shown previously:</p><div class="informalexample"><pre class="programlisting">def get_food_facility_history( category_key ):
    url_detail= "/Clients/VDH/Norfolk/Norolk_Website.nsf/Food-FacilityHistory"
    form = {
        "OpenView": "",
        "RestrictToCategory": category_key
    }
    query= urllib.parse.urlencode( form )
    with urllib.request.urlopen(scheme_host + url_detail + "?" + query) as data:
        soup= BeautifulSoup( data.read() )
    return soup</pre></div><p>This request, like other HTML requests, builds a query string, opens the URL response object, and parses it to create a <code class="literal">BeautifulSoup</code> object. We're only interested in the <code class="literal">soup</code> instance. We return this value for use with HTML processing.</p><p>Also, note that part of the path, <code class="literal">Norolk_Website.nsf</code>, has a spelling error. Secret agents in the field are<a id="id565" class="indexterm"/> responsible for finding information in spite of these kind of problems.</p><p>We'll use this in a function that updates the <code class="literal">SimpleNamespace</code> object that we're using to model each business. The data extraction function looks like this:</p><div class="informalexample"><pre class="programlisting">def inspection_detail( business ):
    soup= get_food_facility_history( business.category )
    business.name2= soup.body.h2.text.strip()
    table= soup.body.table
    for row in table.find_all("tr"):
        column = list( row.find_all( "td" ) )
        name= column[0].text.strip()
        value= column[1].text.strip()
        <span class="strong"><strong>setattr( business, vdh_detail_translate[name], value )</strong></span>
    return business</pre></div><p>This function gets the <code class="literal">BeautifulSoup</code> object for a specific business. Given that Soup, it navigates to the first <code class="literal">&lt;h2&gt;</code> tag within the <code class="literal">&lt;body&gt;</code> tag. This should repeat the business name. We've updated the <code class="literal">business</code> object with this second copy of the name.</p><p>This function also navigates to the first <code class="literal">&lt;table&gt;</code> tag within the <code class="literal">&lt;body&gt;</code> tag via the <code class="literal">soup.body.table</code> expression. The HTML table has two columns: the left column contains a label and the right column contains the value.</p><p>To parse this kind of table, we stepped through each row using <code class="literal">table.find_all("tr")</code>. For each row, we built a list from <code class="literal">row.find_all( "td" )</code>. The first item in this list is the <code class="literal">&lt;td&gt;</code> tag that contains a name. The second item is the <code class="literal">&lt;td&gt;</code> tag that contains a value.</p><p>We can use a dictionary, <code class="literal">vdh_detail_translate</code>, to translate the names in the left column to a better looking Python attribute name, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">vdh_detail_translate = {
    'Phone Number:': 'phone_number',
    'Facility Type:': 'facility_type',     '# of Priority Foundation Items on Last Inspection:':
        'priority_foundation_items',
    '# of Priority Items on Last Inspection:': 'priority_items',
    '# of Core Items on Last Inspection:': 'core_items',
    '# of Critical Violations on Last Inspection:': 'critical_items',
    '# of Non-Critical Violations on Last Inspection:': 'non_critical_items',
}</pre></div><p>Using a dictionary like this allows us to use the expression <code class="literal">vdh_detail_translate[name]</code> to locate a pleasant attribute name (such as <code class="literal">core_item</code>) instead of the long string that's displayed in the original HTML.</p><p>We need to look closely at the use of the <a id="id566" class="indexterm"/>
<code class="literal">setattr()</code> function that's used to update the <code class="literal">business</code> namespace:</p><div class="informalexample"><pre class="programlisting">setattr( business, vdh_detail_translate[name], value )</pre></div><p>In other functions, we've used a simple assignment statement such as <code class="literal">business.attribute= value</code> to set an attribute of the namespace object. Implicitly, the simple assignment statement actually means <code class="literal">setattr( business, 'attribute', value )</code>. We can <a id="id567" class="indexterm"/>think of <code class="literal">setattr(object, attribute_string, value)</code> as the reason why Python implements the simple <code class="literal">variable.attribute= value</code> assignment statement.</p><p>In this function, we can't use a simple assignment statement, because the attribute name is a string that's looked up via a translation. We can use the <code class="literal">setattr()</code> function to update the business object using the attribute name string computed from <code class="literal">vdh_detail_translate[name]</code>.</p></div><div class="section" title="Combining the pieces and parts"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec84"/>Combining the pieces and parts</h2></div></div></div><p>We can now look at the real question: finding high-quality restaurants. We can build a composite function that<a id="id568" class="indexterm"/> combines our previous functions. This can become a generator function that yields all of the details in a sequence of namespace objects, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">def choice_iter():
    base= SimpleNamespace( address= '333 Waterside Drive' )
    geocode_detail( base )
    print( base ) # latitude= 36.844305, longitude= -76.29111999999999 )
    soup= get_food_list_by_name()
    for row in food_row_iter( food_table_iter( soup ) ):
        geocode_detail( row )
        inspection_detail( row )
        row.distance= haversine(
            (row.latitude, row.longitude),
            (base.latitude, base.longitude) )
        yield row</pre></div><p>This will build a small object, <code class="literal">base</code>, to describe our base. The object will start with just the <code class="literal">address</code> attribute. After we apply the <code class="literal">geocode_detail()</code> function, it will also have a latitude and longitude.</p><p>The <code class="literal">print()</code> function will produce a line that looks like this:</p><div class="informalexample"><pre class="programlisting">namespace(address='333 Waterside Drive', latitude=36.844305, longitude=-76.29111999999999)</pre></div><p>The <code class="literal">get_food_list_by_name()</code> function will get a batch of restaurants. We use <code class="literal">food_table_iter()</code> to get the HTML table, and <code class="literal">food_row_iter()</code> to build individual <code class="literal">SimpleNamespace</code> objects from the HTML table. We then do some updates on each of those <code class="literal">SimpleNamespace</code> objects to provide restaurant inspection results and geocode information. We update the object yet again to add the distance from our base to the restaurant.</p><p>Finally, we yield the richly detailed namespace object that represents everything we need to know about a business.</p><p>Given this sequence of objects, we can apply some filters to exclude places over .75 miles away or with more than one problem reported:</p><div class="informalexample"><pre class="programlisting">for business in choice_iter():
    if business.distance &gt; .75: continue
    if business.priority_foundation_items &gt; 1: continue
    if business.priority_items &gt; 1: continue
    if business.core_items &gt; 1: continue
    print( business )</pre></div><p>This script will apply four different filters to each response. If the business, for example, is too far away, the <code class="literal">continue</code> statement will end the processing of this item: the <code class="literal">for</code> statement will advance to the next. If the business has too many items, the <code class="literal">continue</code> statements will reject this business and advance to the next item. Only a business that passes all four tests will be printed.</p><p>Note that we've inefficiently processed each business through the <code class="literal">geocode_detail()</code> and <code class="literal">inspection_detail()</code> functions. A more efficient algorithm would apply the distance filter early in the processing. If we immediately reject places that are too far away, we will only need to get detailed restaurant health data for places that are close enough.</p><p>The important thing about this<a id="id569" class="indexterm"/> sequence of examples is that we integrated data from two different web services and folded them in our own value-added intelligence processing.</p></div><div class="section" title="Working with clean data portals"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec85"/>Working with clean data portals</h2></div></div></div><p>A good example <a id="id570" class="indexterm"/>of a clean data portal is the City of Chicago. We can get the restaurant inspection data with a simple URL:</p><p>
<a class="ulink" href="https://data.cityofchicago.org/api/views/4ijn-s7e5/rows.json?accessType=DOWNLOAD">https://data.cityofchicago.org/api/views/4ijn-s7e5/rows.json?accessType=DOWNLOAD</a></p><p>This will download all the restaurant inspection information in a tidy, easy-to-parse, JSON document. The only<a id="id571" class="indexterm"/> problem is the size. It has over 83,000 inspections and takes a very long time to download. If we<a id="id572" class="indexterm"/> apply a filter (for instance, only inspects done this year), we can cut the document down to a manageable size. More details on the various kinds of filters supported can be found at <a class="ulink" href="http://dev.socrata.com/docs/queries.html">http://dev.socrata.com/docs/queries.html</a>.</p><p>There's a lot of sophistication available. We'll define a simple filter based on the inspection<a id="id573" class="indexterm"/> date to limit ourselves to a subset of the available restaurant inspections.</p><p>A function to get the data looks like this:</p><div class="informalexample"><pre class="programlisting">def get_chicago_json():
    scheme_netloc_path= "https://data.cityofchicago.org/api/views/4ijn-s7e5/rows.json"
    form = {
        "accessType": "DOWNLOAD",
        "$where": "inspection_date&gt;2014-01-01",
    }
    query= urllib.parse.urlencode(form)
    with urllib.request.urlopen( scheme_netloc_path+"?"+query ) as data:
        with open("chicago_data.json","w") as output:
            output.write( data.read() )</pre></div><p>The <code class="literal">schem_netloc_path</code> variable includes two interesting details in path. <code class="literal">4ijn-s7e5</code> is the internal identity of the dataset we're looking for and <code class="literal">rows.json</code> specifies the format we want the data in.</p><p>The form we built includes a <code class="literal">$where</code> clause that will cut down on the volume of data to just the recent inspection reports. The Socrata API pages show us that we have a great deal of flexibility here.</p><p>As with other web services requests, we created a query and made the request using the <code class="literal">urllib.request.urlopen()</code> function. We opened an output file named <code class="literal">chicago_data.json</code> and wrote the document to that file for further processing. This saves us from having to retrieve the data repeatedly since it doesn't change too quickly.</p><p>We've done the processing via nested <code class="literal">with</code> statements to be assured that the files are closed and the network resources are properly released.</p></div><div class="section" title="Making a simple Python object from a JSON document"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec86"/>Making a simple Python object from a JSON document</h2></div></div></div><p>The JSON document contains lots of individual dict objects. While a dict is a handy general-purpose structure, the<a id="id574" class="indexterm"/> syntax is a bit clunky. Having to use <code class="literal">object['some_key']</code> is awkward. It's nicer to work with <code class="literal">SimpleNamespace</code> objects and use pleasant<a id="id575" class="indexterm"/> attribute names. Using <code class="literal">object.some_key</code> is nicer.</p><p>Here's a function that <a id="id576" class="indexterm"/>will iterate through the massive JSON document with all of the inspection details:</p><div class="informalexample"><pre class="programlisting">def food_row_iter():
    with open( "chicago_data.json", encoding="UTF-8" ) as data_file:
        inspections = json.load( data_file )
    headings = [item['fieldName']
        for item in inspections["meta"]["view"]["columns"] ]
    print( headings )
    for row in inspections["data"]:
        data= SimpleNamespace(
            **dict( zip( headings, row ) )
        )
        yield data</pre></div><p>We've built a <code class="literal">SimpleNamespace</code> object from each individual row that was in the source data. The JSON document's data, in <code class="literal">inspections["data"]</code>, is a list of lists. It's rather hard to interpret because we need to know the position of each relevant field.</p><p>We created a list of headings based on the field names we found in <code class="literal">inspections["meta"]["view"]["columns"]</code>. The field names seem to all be valid Python variable names and will make good Python attribute names in a <code class="literal">SimpleNamespace</code> object.</p><p>Given this list of headings, we<a id="id577" class="indexterm"/> can then use the <code class="literal">zip()</code> function to interleave headings and data from each row that we find. This sequence of two-tuples can be used to create a dictionary by employing <code class="literal">dict( zip( headings, row ) )</code>. The dictionary can then be used to build the <code class="literal">SimpleNamespace</code> object.</p><p>The <code class="literal">**</code> syntax specifies<a id="id578" class="indexterm"/> that the items in the dictionary will become individual keyword parameters for <code class="literal">SimpleNamespace</code>. This will elegantly transform a dictionary such as <code class="literal">{'zip': '60608', 'results': 'Fail', 'city': 'CHICAGO', ... }</code> to a <code class="literal">SimpleNamespace</code> object as if we had written <code class="literal">SimpleNamespace( zip='60608', results='Fail', city='CHICAGO', ... )</code>.</p><p>Once we have a sequence of <code class="literal">SimpleNamespace</code> objects, we can do some minor updates to make them easier to work with. Here's a function that makes a few tweaks to each object:</p><div class="informalexample"><pre class="programlisting">def parse_details( business ):
    business.latitude= float(business.latitude)
    business.longitude= float(business.longitude)
    if business.violations is None:
        business.details = []
    else:
        business.details = [ v.strip() for v in business.violations.split("|") ]
    return business</pre></div><p>We've converted the longitude and latitude values from strings to float numbers. We need to do this in order to properly use the <code class="literal">haversine()</code> function to compute distance from our secret base. We've <a id="id579" class="indexterm"/>also split the <code class="literal">business.violations</code> value to a list of individual detailed violations. It's<a id="id580" class="indexterm"/> not clear what we'd do with this, but it might be helpful in understanding the <code class="literal">business.res</code>
<code class="literal">ults</code> value.</p></div><div class="section" title="Combining different pieces and parts"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec87"/>Combining different pieces and parts</h2></div></div></div><p>We can combine the processing into a function that's very similar to the <code class="literal">choice_iter()</code> function<a id="id581" class="indexterm"/> shown previously in the <span class="emphasis"><em>Combining the pieces and parts</em></span> section. The idea is to create code that looks similar but starts with different source data.</p><p>This will iterate through the restaurant choices, depending on having <code class="literal">SimpleNamespace</code> objects that have been updated:</p><div class="informalexample"><pre class="programlisting">def choice_iter():
    base= SimpleNamespace( address="3420 W GRACE ST",
        city= "CHICAGO", state="IL", zip="60618",
        latitude=41.9503, longitude=-87.7138)
    for row in food_row_iter():
        try:
            parse_details( row )
            row.distance= haversine(
                (row.latitude, row.longitude),
                (base.latitude, base.longitude) )
            yield row
        except TypeError:
            pass
            # print( "problems with", row.dba_name, row.address )</pre></div><p>This function defines our secret base at 3420 W Grace St. We've already worked out the latitude and longitude, and don't need to make a geocoding request for the location.</p><p>For each row produced by <code class="literal">food_row_iter()</code>, we've used <a id="id582" class="indexterm"/>
<code class="literal">parse_details()</code> to update the row. We needed to use a <code class="literal">try:</code> block because some of the rows have invalid (or missing) latitude and longitude information. When we try to compute <code class="literal">float(None)</code>, we get a <code class="literal">TypeError</code> exception. We just skipped those locations. We can geocode them separately, but this is Chicago: there's another restaurant down the block that's probably better.</p><p>The result of this function is a sequence of objects that include the distance from our base and health code inspection details. We might, for example, apply some filters to exclude places over .25 miles away or those that got a status of <code class="literal">Fail</code>:</p><div class="informalexample"><pre class="programlisting">for business in choice_iter():
    if business.distance &gt; .25: continue
    if business.results == "Fail": continue
    print( business.dba_name,
        business.address, business.results,
        len(business.details) ) </pre></div><p>The important thing about this sequence of examples is that we leveraged data from a web source, adding value to<a id="id583" class="indexterm"/> the raw data by doing our own intelligence processing. We also combined several individual steps into a more sophisticated composite function.</p></div><div class="section" title="Final steps"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec88"/>Final steps</h2></div></div></div><p>Now that we've located places where we can meet, we have two more things to do. First, we need to create a proper grid code for our chosen locations. The NAC codes are pretty terse. We simply need to<a id="id584" class="indexterm"/> agree with our informant about what code we're going to use.</p><p>Second, we need to use our steganography script from <a class="link" href="ch03.html" title="Chapter 3. Encoding Secret Messages with Steganography">Chapter 3</a>, <span class="emphasis"><em>Encoding Secret Messages with Steganography</em></span>, to conceal the message in an image. Again, we'll need to be sure that our informant can locate the encoded message in the image.</p><p>We'll leave the design of these final processing steps as a mission for you to tackle on your own.</p></div><div class="section" title="Understanding the data – schema and metadata"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec89"/>Understanding the data – schema and metadata</h2></div></div></div><p>Data is described by <a id="id585" class="indexterm"/>additional data<a id="id586" class="indexterm"/> that we often call metadata. A basic datum might be 6371. Without some metadata, we have no idea what this means. Minimally, metadata has to include the unit of measurement (kilometers in this case) as well as the<a id="id587" class="indexterm"/> thing being measured (mean radius of the earth).</p><p>In the case of less<a id="id588" class="indexterm"/> objective data, there may be no units, but rather a domain of possible values. For restaurants, it may be an A-B-C score or a pass-fail outcome. It's important to track down the metadata in order to interpret the actual data.</p><p>An additional consideration is the<a id="id589" class="indexterm"/> schema problem. A set of data should consist of multiple instances of some essential entity. In our case, the entity is the recent health inspection results for a given restaurant. If each instance has a consistent collection of attributes, we <a id="id590" class="indexterm"/>can call that set of attributes the schema for the set of data.</p><p>In some cases, the data isn't consistent. Perhaps there are multiple schemata or perhaps the schema is quite complex with options and alternatives. If there's good metadata, it should explain the schema.</p><p>The City of Chicago <a id="id591" class="indexterm"/>data has a very tidy and complete metadata description for the restaurant health inspection information. We can read it at <a class="ulink" href="https://data.cityofchicago.org/api/assets/BAD5301B-681A-4202-9D25-51B2CAE672FF?download=true">https://data.cityofchicago.org/api/assets/BAD5301B-681A-4202-9D25-51B2CAE672FF?download=true</a>. It explains the risk category assigned to the facility and the ultimate result (pass, pass with conditions, fail). Note the long ugly URL; opaque paths like this are often a bad idea.</p><p>The Virginia Department of Health data isn't quite so tidy or complete. We can eventually work out what the data appears to mean. To be completely sure, we'd need to contact the curator of the data to find out precisely what each attribute means. This would involve an e-mail exchange with the department of health at the state level. A field agent might find this extra effort necessary in the case of ambiguous data names.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Summary</h1></div></div></div><p>In this chapter, we learned how to use web services to perform geocoding and reverse geocoding. We also used web services to get large sets of publicly available information.</p><p>We used the <code class="literal">math</code> library to implement the haversine formula to compute distances between locations. We saw some sophisticated processing, encoding, and decoding techniques and used them to abbreviate grid locations.</p><p>We saw more techniques in data gathering using the BeautifulSoup HTML parser. We combined multiple web services to create really sophisticated applications that integrate geocoding and data analysis.</p><p>In the next chapter, we'll turn up the sensitivity by performing more sophisticated data analysis using deeper statistical techniques. We'll compute means, modes, and medians and look at correlations among data items.</p></div></body></html>