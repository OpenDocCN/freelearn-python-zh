- en: Chapter 9. Connecting to the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cloud modules may seem like the most daunting type of Salt module, because
    of how many functions are required to present a cohesive tool for a cloud provider.
    Fortunately, connecting to most cloud providers is easy, once you know how. In
    this chapter, we''ll discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how cloud components fit together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning which functions are required, and how they are used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing Libcloud-based modules with direct REST modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a generic cloud module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting cloud modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding cloud components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The word *cloud* has suffered from an unfortunate bout of overuse and misuse
    in recent years, so before we talk about what the components look like, we need
    to define what we're actually talking about in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Salt Cloud is designed to operate with *compute cloud* providers. This means
    that they offer computing resources, often in the form of virtual machines. A
    number of cloud providers also offer other resources, such as storage space, DNS,
    and load balancing. While Salt Cloud isn't explicitly designed to manage these
    resources, it is possible to add support for them.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, we will discuss creating cloud drivers with a focus on managing
    virtual machines. Some of the techniques can be used for adding other resources,
    so if you're planning on going in that direction, this chapter will still be useful
    to you.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the puzzle pieces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary goal of Salt Cloud is to easily create virtual machines on a cloud
    provider, install a Salt Minion onto that machine, and then automatically accept
    that Minion's keys on the Master. When you dig down, you will find that a number
    of pieces fit together to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Connection mechanism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most cloud providers offer an API to manage the resources in your account. This
    API comprises an authentication scheme, and a collection of URLs that are used
    in similar ways. Almost every cloud provider supports URLs based on both `GET`
    and `POST` methods, but some support other methods such as `PATCH` and `DELETE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quite frequently, these URLs will include up to four components:'
  prefs: []
  type: TYPE_NORMAL
- en: A resource name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action to be performed on that resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ID of the resource to be managed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguments that define how the resource is managed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These components can be combined with the authentication scheme to create a
    single tool that is used to perform all of the management features that are available.
  prefs: []
  type: TYPE_NORMAL
- en: Listing resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most resources have a way to list them from the API. These include both options
    that are defined by the cloud provider and resources that belong to your account
    and can be managed by you. Some of the resources that can usually be listed from
    the API are:'
  prefs: []
  type: TYPE_NORMAL
- en: Operating system images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sizes of virtual machines that can be created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Existing virtual machines in a user's account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details about specific virtual machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-compute resources that are managed by the account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Salt Cloud module should provide a few different ways to list resources, both
    for creating new virtual machines and for managing existing virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: Creating virtual machines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most complex component of most cloud modules is the `create()` function,
    which orchestrates the tasks of requesting a virtual machine, waiting for it to
    become available, logging in to it and installing Salt, and accepting that virtual
    machine's Minion keys on the Master. Many of these tasks have been abstracted
    into helper functions that can be called from cloud modules, which greatly simplifies
    the development of the `create()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Managing other resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the preceding components have been put together, creating other functions
    to create, list, modify, and delete other resources will usually not take much
    effort.
  prefs: []
  type: TYPE_NORMAL
- en: Libcloud versus SDK versus direct REST API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three types of cloud modules that ship with Salt. The first and original
    type of module uses a library called Libcloud to communicate with cloud providers.
    Using this kind of library has some distinct advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Libcloud supports a huge amount of cloud providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libcloud provides a standard and reasonably consistent interface across providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Salt Cloud has a number of functions built in specifically for Libcloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libcloud is actively developed, with frequent releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some disadvantages to using Libcloud:'
  prefs: []
  type: TYPE_NORMAL
- en: Not every feature in every cloud is supported by Libcloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New cloud providers may not yet be supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Old, obscure, and proprietary drivers may not ever be supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some cloud providers also provide their own libraries for connecting to their
    infrastructure. This may prove the fastest, easiest, or most reliable way to connect
    to them. Some advantages to using a provider''s own SDK are:'
  prefs: []
  type: TYPE_NORMAL
- en: The developers are likely to have the most complete knowledge of the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When new features are released, the SDK is often the first library to support
    them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some disadvantages are:'
  prefs: []
  type: TYPE_NORMAL
- en: Some SDKs still don't support all of the features for that cloud provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some SDKs can be difficult to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another option for communicating with a cloud provider is to communicate directly
    with their REST API. Some advantages to this are:'
  prefs: []
  type: TYPE_NORMAL
- en: You control how the module is maintained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can make your own additions without waiting for new versions of a library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But there are some definite disadvantages to using a direct REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: You have to maintain the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to add any new features yourself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You aren't likely to have as many resources to use the driver as the cloud provider
    has
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are going to need to decide which of these options is most appropriate for
    your situation. Fortunately, once you have set up a connection mechanism to use
    (whether you write it yourself or use somebody else's), there aren't really any
    differences between the functions that make use of those connections.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a generic cloud module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to set up a very generic module that uses a direct REST API to communicate
    with a cloud provider. If you spend a lot of time with different APIs, you'll
    find the style used here to be very common.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for required configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use a cloud provider, you will need a `__virtual__()` function
    to check for required configuration, and if necessary, any dependencies. You will
    also need a function called `get_configured_provider()`, which checks to make
    sure that the configuration that is required to connect to your cloud provider
    (usually authentication at the very least, and sometimes other connection parameters)
    have been specified. We will also need to define `__virtualname__`, which contains
    the name of the driver as Salt Cloud will know it. Let''s go ahead and start our
    cloud module with these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We've started out with a `docstring` that contains information about the required
    configuration for our driver. We're going to stick with a simple authentication
    scheme, which uses an API key as part of the URL, and an HTTP username and password.
  prefs: []
  type: TYPE_NORMAL
- en: The `__virtual__()` function should first make sure that any required libraries
    are installed. In our case, we don't need anything special, so we'll skip that
    part. We then call `get_configured_provider()` to make sure that any required
    configurations are in place, and if all is good, we return `__virtualname__`.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_configured_provider()` function will never change, outside of the list
    of parameters that are absolutely required in order for the module to work. If
    you are going to accept any optional parameters, do not include them in this function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `get_configured_provider()` function mentions another built-in variable
    called `__active_provider_name__`. This contains a combination of the name that
    the user sets for this module in their provider config (such as `my-cloud-config`)
    and the name of the actual driver itself (in our case, `generic`), separated by
    a colon (`:`). If you were to use the sample configuration in our docstring, then
    `__active_provider_name__` would be set to `my-cloud-config:generic`.
  prefs: []
  type: TYPE_NORMAL
- en: Using http.query()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Salt comes with its own library for communicating over HTTP. This library is
    not a connection library itself; rather, it allows you to use `urllib2` (which
    ships with Python), Tornado (which is a dependency of Salt itself), or `requests`
    (which is a very popular and powerful HTTP library for Python). Like Libcloud,
    Salt's HTTP library strives to provide a consistent interface across available
    libraries. You can specify which library is to be used, if you need to use specific
    features in that library, but by default Tornado is used.
  prefs: []
  type: TYPE_NORMAL
- en: This library lives in `salt.utils` and contains a number of HTTP-related functions.
    The one that is most commonly used is called `query()`. It not only supports all
    three backend libraries but also includes mechanisms to automatically translate
    return data from either JSON or XML into a Python dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'A call to `http.query()` usually looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A common REST API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we connect to a REST API, we need to know what it looks like. The structure
    of the URL often contains the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Technically, the URL scheme can be HTTP, but if that's your only option, I would
    recommend switching to another cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: The hostname usually contains some hint that it belongs to the API, such as
    `api.example.com`. The documentation for your cloud provider will tell you which
    hostname to use here. The hostname may also include information about which data
    center you are communicating with, such as `eu-north.api.example.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Most providers also require you to specify which version of their API you are
    using. This may be in the URL, or in the `POST` data, or even in the client request
    headers. You should always use the latest version unless you have a very good
    reason not to, but cloud providers will often support old versions as well, if
    only temporarily.
  prefs: []
  type: TYPE_NORMAL
- en: The resource refers to what you are actually monitoring. This may be something
    like `instance` or `nodes` for virtual machines, `storage` or `volumes` to refer
    to disks, or `images` to refer to prebuilt operating system images or templates.
    I wish I could be more specific here, but this will depend on your cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: The action may or may not appear in the URL. Some cloud providers will include
    actions such as `create`, `list`, `modify`, `delete`, and so on, followed by the
    ID of the resource to be managed, where necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it''s becoming increasingly common for the action to be determined
    by the HTTP method that is used to make the call. The following methods are commonly
    used by REST APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is used for calls that will only display, but never change resources. If
    an ID is not given, then a list of resources is usually given. If an ID is used,
    then the details about that specific resource will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: POST
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is often used for calls that create data, and frequently for those that
    modify data. If an ID is not declared, then a new resource will usually be created.
    If an ID is given, then an existing resource will be modified.
  prefs: []
  type: TYPE_NORMAL
- en: PATCH
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method was recently added for modifying existing resources. If a cloud
    provider makes use of this method, then they are unlikely to allow `POST` to modify
    existing data. Instead, `POST` will only be used to apply new data, and `PATCH`
    will be used to update existing data.
  prefs: []
  type: TYPE_NORMAL
- en: DELETE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Calls using a `DELETE` method will generally include both a resource type, and
    the ID of the resource to be removed. This method is never used to create or modify
    data; only remove it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a _query() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know what the API will look like, let''s create a function to communicate
    with it. We will make use of `http.query()` to talk to it, but we also need to
    wrap a few other items in there as well. We''ll start with a function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have made this function private. There is no reason to allow
    this function to be called directly from the command line, so we need to hide
    it. We have allowed any of the arguments to remain unspecified, because we won't
    always need all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and set our `_query()` function, and then go over each of the
    components in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We start off by collecting the connection parameters that are required for our
    cloud provider. The `salt.config` library includes a function called `get_cloud_config_value()`
    that searches through the cloud configuration for the requested value. It can
    search through the main cloud configuration (usually at `/etc/salt/cloud`) as
    well as through any provider or profile configuration. In this case, all of the
    configuration should be found in the provider configuration, as specified in our
    docstring.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have collected the `user`, `password`, and `api_key`, we turn our attention
    to `location`. You may recall that many cloud providers use the hostname to differentiate
    different data centers. Many also have a default data center. In the case of our
    generic driver, we'll assume that `eu-north` is the default, and create a URL
    using that. Our URL also contains a version, as we mentioned before.
  prefs: []
  type: TYPE_NORMAL
- en: We then look at the resource that will be used, and any actions that will be
    performed on it. If found, these will be appended to the URL path. With those
    in place, we look at any parameters that will be added to the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `params` variable refers to `<name>=<value>` pairs that will be added to
    the URL. These will start with a question mark (`?`) and then be separated with
    an ampersand (`&`), for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Instead of appending these to the URL by ourselves, we'll let the `http.query()`
    function take care of it for us. It will properly encode this data if specified
    and append it to the end of the URL for us.
  prefs: []
  type: TYPE_NORMAL
- en: If used, `params` need to be specified as a dictionary. We know that `api_key`
    will be one `params`, so we add it after doing a type check.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to look at any data that is going to be `POST`ed to the cloud
    provider. Many providers require `POST` data to be sent as a JSON string, rather
    than as URL-encoded data, so if any data is given, we'll convert it to JSON before
    sending it over.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have everything prepared, we use `http.query()` (as `salt.utils.http.query()`)
    to actually make the call. You can see `url`, `method` (as specified in the function
    declaration), `params`, and `data`. We've also set `decode` to `True` and `decode_type`
    to `json`, so that the return data from the cloud provider will automatically
    be converted to a dictionary for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve also passed through a list of fields to hide from any logging that may
    occur inside the `http.query()` function. This will keep data such as our `api_key`
    private, in the event that any logs are generated. Rather than logging a URL such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A sanitized URL will be logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we pass through a copy of `__opts__`, so that `http.query()` has access
    to any variables that it needs from the `master` or `minion` configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: The `http.query()` function will return a dictionary, including an item called
    `dict`, which contains the return data from the cloud provider, converted into
    a dictionary. This is what we will pass back to any functions calling our `_query()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Getting profile details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have the ability to connect to a cloud provider, we need to be able
    to collect information that can be used to create a VM on that provider. That
    almost always includes a list of VM images and VM sizes. If a cloud provider has
    multiple data centers (and most of them do), then you will also need a function
    that returns a list of them.
  prefs: []
  type: TYPE_NORMAL
- en: These three functions are called `avail_images()`, `avail_sizes()`, and `avail_locations()`.
    They are accessed from the `salt-cloud` command using the `--list-images`, `--list-sizes`,
    and `--list-locations` options, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Listing images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Images refer to a prebuilt root VM volume. With Windows images, this will be
    the `C:\` disk volume. In other operating systems, it will be the `/` volume.
    Very commonly, a cloud provider will give access to a number of different operating
    systems, and a number of different versions of each of those.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a cloud provider may offer a single image each for Ubuntu 14.04,
    Ubuntu 14.10, Ubuntu 15.04, and so on, or they may provide each of those bundled
    with WordPress, MediaWiki, MariaDB, or another popular software package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of our generic cloud provider, a list of images can be returned
    simply by requesting the `images` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In a profile configuration, an image is specified using the `image` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Listing sizes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sizes are a concept that is unique to cloud providers, and indeed not every
    cloud provider even supports them. Depending on the provider, size usually refers
    to a combination of the number of processors, processor speed, amount of RAM,
    disk space, type of disk (platter versus SSD), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, our generic cloud provider will return a list of sizes under the
    `sizes` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In a profile configuration, a size is specified using the `size` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Listing locations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on the cloud provider, a location may refer to a specific data center,
    a region in some part of the world, or even a specific data center inside a region
    that contains multiple data centers.
  prefs: []
  type: TYPE_NORMAL
- en: As we said before, the location is often prepended to the URL used to talk to
    the API. In the case of our generic cloud provider, locations are queried using
    the `regions` resource.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In a profile configuration, a location is specified using the `location` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Listing nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next thing to do is display the nodes that currently exist inside the account
    for that cloud provider. There are three `salt-cloud` arguments to display node
    data: `-Q` or `--query`, `-F` or `--full-query`, and `-S` or `--select-query`.
    Each of these options will query every configured cloud provider, and return all
    of the information at once.'
  prefs: []
  type: TYPE_NORMAL
- en: Querying standard node data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are six pieces of information that should always be provided for each
    node. This data is displayed when the `-Q` argument is used with `salt-cloud`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: The ID of this VM, as used by the cloud provider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image`: The image used to create this VM. If this data is not available, it
    should be set to `None`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size`: The size used to create this VM. If this data is not available, it
    should be set to `None`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state`: The current running state of this VM. This is usually `RUNNING`, `STOPPED`,
    `PENDING` (the VM is still booting), or `TERMINATED` (the VM has been destroyed,
    but not yet cleaned up). If this data is not available, it should be set to None.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private_ips`: Any private IP addresses that are used on a cloud provider''s
    internal network. These should be returned as a list. If this data is not available,
    the list should be empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public_ips`: Any public IP addresses that are available for this VM. Any IPv6
    addresses should be included here. These IPs should be returned as a list. If
    this data is not available, the list should be empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Users should have access to all of these variables, even if they are empty
    or set to None. This is also the only data that should be returned by the `-Q`
    argument. To return this data, we use a function called `list_nodes()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Querying full node data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'VMs usually contain quite a bit more information than is returned with `-Q`.
    If you want to view all of the information that a cloud provider is willing and
    able to display to you, you use the `-F` flag. This corresponds to a function
    called `list_nodes_full()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, you are only interested in a very specific set of data. For instance,
    you may only want to display a VM''s ID, public IPs, and state. The `-S` option
    allows you to perform a query that returns only a selection of the fields that
    are available with a full query. The selection itself is defined as a list in
    the main cloud configuration file (usually `/etc/salt/cloud`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The query itself is performed by a function called `list_nodes_select()`. Some
    providers may require something special to be done to separate out this data,
    but most of the time you can just use the `list_nodes_select()` function that
    ships with the `salt.utils.cloud` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating a VM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most complex part of any cloud module has traditionally been the `create()`
    function. That''s because this function doesn''t just spin up a VM. Its tasks
    can generally be split up into these components:'
  prefs: []
  type: TYPE_NORMAL
- en: Request that the cloud provider create a VM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wait for that VM to become available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log in to that VM and install Salt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept that's VM's Minion keys on the Master
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some more complex cloud providers may include additional steps, such as requesting
    different types of VMs based on the profile configuration, or attaching volumes
    to the VM. In addition, the `create()` function should fire events along Salt's
    event bus, to let the Master know how far along it is with the creation process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into the `create()` function, we should put together another
    function called `request_instance()`. This function will do two things for us:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be called directly from `create()`, which will simplify the `create()`
    function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be called outside of `create()`, when a non-Salt VM is needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This function doesn''t need to do much. As the name implies, it need only request
    that the cloud provider create a VM. But it will need to collect together some
    information to build the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You've probably noticed the call to `salt.utils.cloud.fire_event()` in this
    function. Every time you do something major in the `create()` function (or in
    functions that are called by `create()`), you should fire an event that gives
    some information about what you're about to do. Those events will be picked up
    by the event reactor, allowing the Master to keep track of progress and perform
    additional tasks if configured to do so, at the right time.
  prefs: []
  type: TYPE_NORMAL
- en: We're also going to create a function called `query_instance()`. This function
    will watch a newly requested VM, and wait for an IP address to become available.
    This IP address will be used to log in to the VM and provision it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This function makes use of another function that ships with Salt called `salt.utils.cloud.wait_for_ip()`.
    That function takes a callback, which we're defining as a nested function called
    `_query_ip_address()`. That nested function checks to see if an IP address exists.
    If it does, then `salt.utils.cloud.wait_for_ip()` will stop waiting and move on.
    If it does not yet exist, then it will keep waiting.
  prefs: []
  type: TYPE_NORMAL
- en: There are three more arguments that we're passing in as well. `timeout` defines
    how long to wait for an IP address to show up at all (in our case, ten minutes);
    `interval` tells Salt Cloud how long to wait between queries (our default is ten
    seconds).
  prefs: []
  type: TYPE_NORMAL
- en: You may be tempted to use a much shorter interval, but many cloud providers
    will throttle requests if an account seems to be abusing its privileges. On that
    note, `interval_multiplier` will increase `interval` after each request. For instance,
    if `interval` was set to 1 and `interval_multiplier` was set to 2, then requests
    would be spaced out at 1 second, then 2, 4, 8, 16, 32, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'With those two functions in place, we can finally set up our `create()` function.
    It requires one argument, which is a dictionary containing a combination of the
    profile, provider, and main cloud configuration data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We begin our function by firing an event stating that a creation process is
    being started. We then allow `request_instance()` and `query_instance()` to do
    their work, pull the name of an SSH key filename from the profile data, and then
    scrape an IP address to use to log in to the box from the VM data.
  prefs: []
  type: TYPE_NORMAL
- en: The next step involves waiting for the VM to become available, and then logging
    in and provisioning it. But since that part of the process is the same across
    cloud providers, it's all been rolled into another helper function inside `salt.utils.cloud`
    called `bootstrap()`. The `bootstrap()` function will even fire additional events
    for us, keeping the event reactor apprised of its own status.
  prefs: []
  type: TYPE_NORMAL
- en: When all is said and done, we fire one last event stating the information about
    the VM, and return the VM's data to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that the events that we fire all include a tag starting
    with `salt/cloud/`, then the VM's name, then a short name for the step that we
    are currently performing. If you are working with a more complex cloud provider
    and wish to fire other events that are specific to them, keep the tag looking
    the same way, with as simple a descriptor as possible. This will help your users
    keep track of all of your cloud tags.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying VMs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s just as important to be able to destroy a VM as it is to be able to create
    one, but the process is thankfully much easier. Keep in mind that events should
    also be fired when destroying: once before it happens, and once after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We've done one more important thing in this function. Salt Cloud has the ability
    to maintain a cache of information about VMs. We didn't see this before, because
    the `bootstrap()` function handles populating the cache when a VM is created.
    However, since there is no generic method for destroying machines, we need to
    handle this manually.
  prefs: []
  type: TYPE_NORMAL
- en: Using actions and functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, all of the functions that we've written are called directly using a
    special command-line argument (such as `--query` or `--provision`). However, there
    are other operations that cloud providers may be able to perform that are not
    necessarily as standard as the ones that we've seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, most cloud providers have API methods for `start`, `stop`, and
    `restart`. But some providers don't support all of those; `start` and `stop` may
    be available, but not `restart`. Or `start` and `restart`, but not `stop`. Other
    operations, such as listing SSH keys, may be available on one cloud provider,
    but not another.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes down to it, there are two types of operations that can be performed
    against a cloud provider. Operations that are specific to a VM (`stop`, `start`,
    `restart`, and so on) are known in Salt Cloud as **actions**. Operations that
    interact with a component of the cloud provider, that are not specific to a VM
    (listing SSH keys, modifying users, and so on), are known in Salt Cloud as **functions**.
  prefs: []
  type: TYPE_NORMAL
- en: Using actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Actions are called using the `--action` argument with the `salt-cloud` command.
    Because they operate on a specific VM, the first argument passed to them is a
    name. If other arguments are passed in from the command line, they will show up
    in a dictionary called `kwargs`. There is one more argument, called `call`, which
    tells a function whether it was called with `--action` or `--function`. You can
    use this to inform users when they have called an action or function incorrectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Even if you do not plan to issue a warning to users, you must accept the `call`
    argument; it will be passed to it regardless, and an error will be raised if it
    isn't there.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, I've sprung another surprise on you. Since this action will be renaming
    a VM, we need to notify Salt as well. If we don't, then the Master will be unable
    to contact the Minion. As usual, there is a helper function (`salt.utils.cloud.rename_key()`)
    that does the work for us.
  prefs: []
  type: TYPE_NORMAL
- en: Using functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because functions do not operate on a specific VM, they do not require a name
    argument. However, they do require the `kwargs` and `call` arguments, even if
    you don't intend to use them for anything.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you add the call argument to various functions throughout your module, you
    will be able to call them directly using the `--action` or `--function` arguments.
    This can be very useful for, say, the `list_nodes()` functions, when you want
    to look at VMs for only one cloud provider at a time, rather than all of them
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: The only public function that cannot be called this way is the `create()` function.
    `destroy()` can be called using the `--action` argument, and almost everything
    else that we've added so far can be called using the `–-function` argument. We'll
    go ahead and add those in for our final cloud module.
  prefs: []
  type: TYPE_NORMAL
- en: The final cloud module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we have finished, the final cloud module will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Troubleshooting cloud modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud modules may seem daunting because there are so many components that are
    required to make a cohesive piece of code. But if you work on the module with
    bite-sized chunks, it will be a lot easier to handle.
  prefs: []
  type: TYPE_NORMAL
- en: Write avail_sizes() or avail_images() first
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever I write a new cloud module, the first thing I do is get some sample
    code working that makes a small query. Because images and sizes are critical to
    the creation of a VM, and because those calls tend to be very simple, they are
    usually the easiest to get working.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have one of those functions working, break it out into a `_query()`
    function (if you didn't start that way) and a function that calls it. Then write
    another function that calls it. You may find yourself tweaking `_query()` for
    each of the first few functions, but then it will stabilize and require few, if
    any, changes.
  prefs: []
  type: TYPE_NORMAL
- en: Use shortcuts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I cannot tell you how many hours I have spent waiting for VMs to spin up, just
    to test one piece of code. If you break out the `create()` function into a lot
    of smaller functions, then you can temporarily hardcode VM data as needed, and
    skip over operations that would otherwise waste too much time. Just be sure to
    take out the shortcuts when you finish!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Salt Cloud is designed to handle compute resources, though additional cloud
    functionality can be added as needed. A cloud module can be written using Libcloud,
    an SDK, or the direct REST API; each method has its pros and cons. Modern REST
    APIs tend to be very similar and easy to work with. There are several functions
    that are required for a cohesive cloud module, but most are not complex. Actions
    are performed against individual VMs while functions are performed against cloud
    providers themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve gone over cloud modules, it''s time to start monitoring our
    resources. Next up: beacons.'
  prefs: []
  type: TYPE_NORMAL
