- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Behavioral Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为设计模式
- en: In the previous chapter, we covered structural patterns and **object-oriented
    programming** (**OOP**) patterns that help us create clean, maintainable, and
    scalable code. The next category of design patterns is **behavioral design patterns**.
    Behavioral patterns deal with object interconnection and algorithms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了结构化模式以及帮助我们创建干净、可维护和可扩展代码的**面向对象编程**（**OOP**）模式。下一个设计模式类别是**行为设计模式**。行为模式处理对象之间的连接和算法。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The Chain of Responsibility pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链模式
- en: The Command pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式
- en: The Observer pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The State pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态模式
- en: The Interpreter pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器模式
- en: The Strategy pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式
- en: The Memento pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录模式
- en: The Iterator pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器模式
- en: The Template pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板模式
- en: Other behavioral design patterns
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他行为设计模式
- en: At the end of this chapter, you will know how to improve your software project
    designs using behavioral patterns.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将了解如何使用行为模式来改进你的软件项目设计。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'See the requirements presented in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017).
    The additional technical requirements for the code discussed in this chapter are
    the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅在[*第一章*](B21896_01.xhtml#_idTextAnchor017)中提出的各项要求。本章讨论的代码的附加技术要求如下：
- en: 'For the State pattern section, install the `state_machine` module, using the
    command: `python -m pip` `install` `state_machine`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于状态模式部分，请使用以下命令安装`state_machine`模块：`python -m pip install state_machine`。
- en: 'For the Interpreter pattern section, install the `pyparsing` module, using
    the command: `python –m pip` `install pyparsing`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于解释器模式部分，请使用以下命令安装`pyparsing`模块：`python –m pip install pyparsing`。
- en: 'For the Template pattern section, install the `cowpy` module, using the command:
    `python -m pip` `install cowpy`.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于模板模式部分，请使用以下命令安装`cowpy`模块：`python -m pip install cowpy`。
- en: The Chain of Responsibility pattern
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链模式
- en: The Chain of Responsibility pattern offers an elegant way to handle requests
    by passing them through a chain of handlers. Each handler in the chain has the
    autonomy to decide whether it can process the request or if it should delegate
    it further along the chain. This pattern shines when dealing with operations that
    involve multiple handlers but don’t necessarily require all of them to be involved.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链模式提供了一种优雅的方式来处理请求，通过将它们传递给一系列处理者。链中的每个处理者都有自主权来决定它是否可以处理请求，或者是否应该将其委托给链中的其他处理者。当处理涉及多个处理者但不必所有处理者都参与的操作时，此模式特别有用。
- en: In practice, this pattern encourages us to focus on objects and the flow of
    a request within an application. Notably, the client code remains blissfully unaware
    of the entire chain of handlers. Instead, it only interacts with the first processing
    element in the chain. Similarly, each processing element knows only about its
    immediate successor, forming a one-way relationship similar to a singly linked
    list. This structure is purposefully designed to achieve decoupling between the
    sender (client) and the receivers (processing elements).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，此模式鼓励我们关注对象以及请求在应用程序中的流动。值得注意的是，客户端代码对整个处理者链一无所知。相反，它只与链中的第一个处理元素交互。同样，每个处理元素只知道其直接的后继者，形成一个类似于单链表的单向关系。这种结构是故意设计的，旨在在发送者（客户端）和接收者（处理元素）之间实现解耦。
- en: Real-world examples
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: 'ATMs and, in general, any kind of machine that accepts/returns banknotes or
    coins (for example, a snack-vending machine) use the Chain of Responsibility pattern.
    There is always a single slot for all banknotes, as shown in the following diagram,
    courtesy of [www.sourcemaking.com](http://www.sourcemaking.com):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 自动柜员机（ATM）以及任何接受/退还纸币或硬币的机器（例如，零食自动售货机）都使用责任链模式。所有纸币都有一个单独的槽位，如下面的图所示，由[www.sourcemaking.com](http://www.sourcemaking.com)提供：
- en: '![Figure 5.1 – Chain of Responsibility example: the ATM](img/B21896_05_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 责任链模式示例：ATM](img/B21896_05_01.jpg)'
- en: 'Figure 5.1 – Chain of Responsibility example: the ATM'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 责任链模式示例：ATM
- en: When a banknote is dropped, it is routed to the appropriate receptacle. When
    it is returned, it is taken from the appropriate receptacle. We can think of the
    single slot as the shared communication medium and the different receptacles as
    the processing elements. The result contains cash from one or more receptacles.
    For example, in the preceding diagram, we see what happens when we request $175
    from the ATM.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当纸币被投入时，它会被路由到相应的容器。当它被退回时，它会被从相应的容器中取出。我们可以将单个槽位视为共享通信介质，而不同的容器则视为处理元素。结果包含来自一个或多个容器的现金。例如，在前面的图中，我们看到当我们从ATM请求175美元时会发生什么。
- en: In some web frameworks, filters or middleware are pieces of code that are executed
    before an HTTP request arrives at a target. There is a chain of filters. Each
    filter performs a different action (user authentication, logging, data compression,
    and so forth), and either forwards the request to the next filter until the chain
    is exhausted, or it breaks the flow if there is an error—for example, the authentication
    failed three consecutive times.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些Web框架中，过滤器或中间件是在HTTP请求到达目标之前执行的代码片段。存在一个过滤器链。每个过滤器执行不同的操作（用户认证、日志记录、数据压缩等），要么将请求转发到下一个过滤器，直到链被耗尽，要么在出现错误时（例如，认证失败三次）中断流程。
- en: Use cases for the Chain of Responsibility pattern
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 责任链模式的用例
- en: By using the Chain of Responsibility pattern, we provide a chance for a number
    of different objects to satisfy a specific request. This is useful when we don’t
    know in advance which object should satisfy a given request. An example of this
    is a **purchase system**. In purchase systems, there are many approval authorities.
    One approval authority might be able to approve orders up to a certain value,
    let’s say $100\. If the order is for more than $100, the order is sent to the
    next approval authority in the chain, which can approve orders up to $200, and
    so forth.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用责任链模式，我们为多个不同的对象提供了一个满足特定请求的机会。当我们事先不知道哪个对象应该满足给定的请求时，这非常有用。一个例子是**采购系统**。在采购系统中，有许多审批权限。一个审批权限可能能够批准价值达到一定数额的订单，比如说100美元。如果订单价值超过100美元，订单就会被发送到链中的下一个审批权限，它可以批准价值达到200美元的订单，以此类推。
- en: Another case where the Chain of Responsibility is useful is when we know that
    more than one object might need to process a single request. This is what happens
    in event-based programming. A single event, such as a left-mouse click, can be
    caught by more than one listener.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链模式在另一种情况下也很有用，即我们知道可能需要多个对象来处理单个请求。这就是基于事件编程中发生的情况。一个事件，比如左键点击，可以被多个监听器捕获。
- en: It is important to note that the Chain of Responsibility pattern is not very
    useful if all the requests can be taken care of by a single processing element
    unless we really don’t know which element that is. The value of this pattern is
    the decoupling that it offers, as we have seen in the *Loose coupling* section
    of [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017), *Foundational Design Principles*.
    Instead of having a many-to-many relationship between a client and all processing
    elements (and the same is true regarding the relationship between a processing
    element and all other processing elements), a client only needs to know how to
    communicate with the start (head) of the chain.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，如果所有请求都可以由单个处理元素处理，除非我们真的不知道是哪个元素，否则责任链模式并不是非常有用。这种模式的价值在于它提供的解耦，正如我们在[*第一章*](B21896_01.xhtml#_idTextAnchor017)的*松耦合*部分中看到的，*基础设计原则*。与客户端和所有处理元素之间以及处理元素和所有其他处理元素之间的一对多关系相比，客户端只需要知道如何与链的起始（头部）进行通信。
- en: Implementing the Chain of Responsibility pattern
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现责任链模式
- en: There are many ways to implement a Chain of Responsibility in Python, but my
    favorite implementation is the one by Vespe Savikko ([https://legacy.python.org/workshops/1997-10/proceedings/savikko.html](https://legacy.python.org/workshops/1997-10/proceedings/savikko.html)).
    Vespe’s implementation uses dynamic dispatching in a Pythonic style to handle
    requests.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中实现责任链模式有许多方法，但我最喜欢的实现是Vespe Savikko的版本（[https://legacy.python.org/workshops/1997-10/proceedings/savikko.html](https://legacy.python.org/workshops/1997-10/proceedings/savikko.html)）。Vespe的实现使用Python风格的动态分派来处理请求。
- en: 'Let’s implement a simple, event-based system using Vespe’s implementation as
    a guide. The following is the UML class diagram of the system:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Vespe的实现为指导，实现一个简单的基于事件的系统。以下是该系统的UML类图：
- en: '![Figure 5.2 – UML class diagram of an event-based window system](img/B21896_05_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 基于事件的窗口系统的UML类图](img/B21896_05_02.jpg)'
- en: Figure 5.2 – UML class diagram of an event-based window system
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 基于事件的窗口系统的UML类图
- en: 'The `Event` class describes an event. We’ll keep it simple, so, in our case,
    an event has only `name`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event`类描述了一个事件。我们将保持简单，因此，在我们的例子中，一个事件只有一个`name`：'
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Widget` class is the core class of the application. The `parent` object,
    which, by convention, we assume is a `Widget` instance. Note, however, that according
    to the rules of inheritance, an instance of any of the subclasses of `Widget`
    (for example, an instance of `MsgText`) is also an instance of `Widget`. The class
    has a `handle()` method, which uses dynamic dispatching through `hasattr()` and
    `getattr()` to decide who the handler of a specific request (event) is. If the
    widget that is asked to handle an event does not support it, there are two fallback
    mechanisms. If the widget has a parent, then the `handle()` method of the parent
    is executed. If the widget has no parent but a `handle_default()` method, `handle_default()`
    is executed. The code is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Widget`类是应用程序的核心类。按照惯例，我们假设`parent`对象是一个`Widget`实例。然而，请注意，根据继承规则，`Widget`的任何子类（例如，`MsgText`的实例）也是一个`Widget`实例。该类有一个`handle()`方法，它通过`hasattr()`和`getattr()`进行动态分发来决定特定请求（事件）的处理者。如果请求处理事件的窗口不支持该事件，有两种回退机制。如果窗口有父窗口，则执行父窗口的`handle()`方法。如果没有父窗口但有`handle_default()`方法，则执行`handle_default()`。代码如下：'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At this point, you might have realized why the `Widget` and `Event` classes
    are only associated (no aggregation or composition relationships) in the UML class
    diagram. The association is used to show that the `Widget` class knows about the
    `Event` class but does not have any strict reference to it, since an event needs
    to be passed only as a parameter to `handle()`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经意识到为什么在UML类图中`Widget`和`Event`类只是关联（没有聚合或组合关系）。这种关联用于表示`Widget`类知道`Event`类，但没有对其有严格的引用，因为事件只需要作为参数传递给`handle()`。
- en: '`MainWIndow`, `MsgText`, and `SendDialog` are all widgets with different behaviors.
    Not all these three widgets are expected to be able to handle the same events,
    and even if they can handle the same event, they might behave differently. `MainWindow`
    can handle only the close and default events:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWIndow`、`MsgText`和`SendDialog`都是具有不同行为的窗口。并不期望这三个窗口都能处理相同的事件，即使它们可以处理相同的事件，它们的行为也可能不同。`MainWindow`只能处理关闭和默认事件：'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`SendDialog` can handle only the `paint` event:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendDialog`只能处理`paint`事件：'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, `MsgText` can handle only the `down` event:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`MsgText`只能处理`down`事件：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `main()` function shows how we can create a few widgets and events, and
    how the widgets react to those events. All events are sent to all the widgets.
    Note the parent relationship of each widget—the `sd` object (an instance of `SendDialog`)
    has as its parent the `mw` object (an instance of `MainWindow`). However, not
    all objects need to have a parent that is an instance of `MainWindow`. For example,
    the `msg` object (an instance of `MsgText`) has the `sd` object as a parent:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数展示了如何创建一些窗口和事件，以及窗口如何对这些事件做出反应。所有事件都发送到所有窗口。注意每个窗口的父关系——`sd`对象（`SendDialog`的实例）的父对象是`mw`对象（`MainWindow`的实例）。然而，并非所有对象都需要有一个是`MainWindow`实例的父对象。例如，`msg`对象（`MsgText`的实例）的父对象是`sd`对象：'
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s recapitulate the complete code (see file `ch05/chain.py`) of the implementation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下实现的全代码（见文件`ch05/chain.py`）：
- en: We define the `Event` class, followed by the `Widget` class.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了`Event`类，然后是`Widget`类。
- en: We define the specialized widget classes, `MainWindow`, `SendDialog`, and `MsgText`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了专门的窗口类，`MainWindow`、`SendDialog`和`MsgText`。
- en: Finally, we add the code for the `main()` function; we make sure it can be called
    thanks to the usual trick at the end.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加了`main()`函数的代码；我们确保它可以通过常规技巧在末尾被调用。
- en: 'Executing the `python ch05/chain.py` command gives us the following output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`python ch05/chain.py`命令会得到以下输出：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Command pattern
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式
- en: Most applications nowadays have an undo operation. It is hard to imagine, but
    undo did not exist in any software for many years. Undo was introduced in 1974,
    but Fortran and Lisp, two programming languages that are still widely used, were
    created in 1957 and 1958, respectively! I wouldn’t like to have been an application
    user during those years. Making a mistake meant that the user had no easy way
    to fix it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大多数应用程序都有撤销操作。这很难想象，但在许多年之前，没有任何软件有撤销功能。撤销功能是在1974年引入的，但Fortran和Lisp这两种至今仍被广泛使用的编程语言分别在1957年和1958年创建！我不愿意在那几年成为应用程序用户。犯错意味着用户没有简单的方法来修复它。
- en: 'Enough with the history. We want to know how we can implement the undo functionality
    in our applications. Since you have read the title of this chapter, you already
    know which design pattern is recommended to implement undo: the Command pattern.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的历史了。我们想知道如何在我们的应用程序中实现撤销功能。既然你已经阅读了本章的标题，你就已经知道推荐使用哪种设计模式来实现撤销：命令模式。
- en: 'The Command design pattern helps us encapsulate an operation (undo, redo, copy,
    paste, and so forth) as an object. What this simply means is that we create a
    class that contains all the logic and the methods required to implement the operation.
    The advantages of doing this are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 命令设计模式帮助我们封装一个操作（撤销、重做、复制、粘贴等等）作为一个对象。这意味着我们创建一个包含所有逻辑和实现操作所需的方法的类。这样做的好处如下：
- en: We don’t have to execute a command directly. It can be executed at will.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不必直接执行命令。它可以在任何时候执行。
- en: The object that invokes the command is decoupled from the object that knows
    how to perform it. The invoker does not need to know any implementation details
    about the command.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用命令的对象与知道如何执行它的对象解耦。调用者不需要了解命令的任何实现细节。
- en: If it makes sense, multiple commands can be grouped to allow the invoker to
    execute them in order. This is useful, for instance, when implementing a multilevel
    undo command.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有道理，可以将多个命令分组，以便调用者可以按顺序执行它们。这在实现多级撤销命令时很有用。
- en: Real-world examples
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界的例子
- en: When we go to a restaurant for dinner, we give the order to the waiter. The
    check (usually paper) that they use to write the order is an example of a command.
    After writing the order, the waiter places it in the check queue that is executed
    by the cook. Each check is independent and can be used to execute many different
    commands, for example, one command for each item that will be cooked.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们去餐馆吃晚餐时，我们会向服务员下单。他们用来写下订单的账单（通常是纸张）是一个命令的例子。写下订单后，服务员将其放入由厨师执行的账单队列中。每一张账单都是独立的，可以用来执行许多不同的命令，例如，为每一项将要烹饪的菜品执行一个命令。
- en: 'As you would expect, we also have several examples in the software. Here are
    two I can think of:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期的那样，我们也在软件中找到了几个例子。以下是我能想到的两个：
- en: PyQt is the Python binding of the QT toolkit. PyQt contains a `QAction` class
    that models an action as a command. Extra optional information is supported for
    every action, such as description, tooltip, and shortcut.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyQt是QT工具包的Python绑定。PyQt包含一个`QAction`类，它将操作建模为命令。每个动作都支持额外的可选信息，例如描述、工具提示和快捷键。
- en: Git Cola, a Git GUI written in Python, uses the command pattern to modify the
    model, amend a commit, apply a different election, check out, and so forth.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git Cola，一个用Python编写的Git GUI，使用命令模式来修改模型、修正提交、应用不同的选举、检出等等。
- en: Use cases for the Command pattern
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令模式的用例
- en: 'Many developers use the undo example as the only use case of the Command pattern.
    The truth is that undo is the killer feature of the Command pattern. However,
    the Command pattern can actually do much more:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者将撤销示例作为命令模式的唯一用例。事实是，撤销是命令模式的杀手级功能。然而，命令模式实际上可以做更多：
- en: '**GUI buttons and menu items**: The PyQt example that was already mentioned
    uses the Command pattern to implement actions on buttons and menu items.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GUI按钮和菜单项**：之前提到的PyQt示例使用命令模式来实现按钮和菜单项上的操作。'
- en: '**Other operations**: Apart from undo, commands can be used to implement any
    operation. A few examples are *cut*, *copy*, *paste*, *redo*, and *capitalize
    text*.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他操作**：除了撤销之外，命令还可以用来实现任何操作。一些例子包括*剪切*、*复制*、*粘贴*、*重做*和*首字母大写文本*。'
- en: '**Transactional behavior and logging**: Transactional behavior and logging
    are important to keep a persistent log of changes. They are used by operating
    systems to recover from system crashes, relational databases to implement transactions,
    filesystems to implement snapshots, and installers (wizards) to revert canceled
    installations.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务行为和日志记录**：事务行为和日志记录对于保持更改的持久日志非常重要。操作系统使用它们从系统崩溃中恢复，关系数据库使用它们实现事务，文件系统使用它们实现快照，安装程序（向导）使用它们撤销已取消的安装。'
- en: '**Macros**: By macros, in this case, we mean a sequence of actions that can
    be recorded and executed on demand at any point in time. Popular editors such
    as Emacs and Vim support macros.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宏**：在这里，我们指的是可以记录并在任何时间点按需执行的动作序列。流行的编辑器，如Emacs和Vim，支持宏。'
- en: Implementing the Command pattern
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现命令模式
- en: 'Let’s use the Command pattern to implement the following basic file utilities:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用命令模式来实现以下基本文件实用工具：
- en: Creating a file and, optionally, adding text to it
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建文件，可选地添加文本到其中
- en: Reading the contents of a file
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件的内容
- en: Renaming a file
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名文件
- en: We are not going to implement these utilities from scratch since Python already
    offers good implementations for them in the `os` module. What we want to do is
    to add an extra abstraction level on top of them so that they can be treated as
    commands. By doing this, we get all the advantages offered by commands.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会从头开始实现这些实用工具，因为Python已经在`os`模块中提供了良好的实现。我们想要做的是在这些实用工具之上添加一个额外的抽象层，使它们可以被当作命令处理。通过这样做，我们获得了命令提供的所有优势。
- en: 'Each command has two parts:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令都有两个部分：
- en: '`__init__()` method and contains all the information required by the command
    to be able to do something useful (the path of a file, the contents that will
    be written to the file, and so forth).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`方法包含命令执行有用操作所需的所有信息（文件的路径、将要写入文件的内容等等）。'
- en: '`execute()` method. We call that method when we want to run a command. This
    is not necessarily right after initializing it.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute()`方法。当我们想要运行一个命令时，我们会调用该方法。这并不一定是在初始化之后立即进行的。'
- en: Let’s start with the rename utility, which we implement using the `RenameFile`
    class. The class is initialized using the source and destination file paths. We
    add the `execute()` method, which does the actual renaming using `os.rename()`.
    To provide support for the undo operation, we add the `undo()` method, where we
    use `os.rename()` again to revert the name of the file to its original value.
    Note that we also use logging to improve the output.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从重命名实用工具开始，我们使用`RenameFile`类来实现它。该类使用源文件路径和目标文件路径进行初始化。我们添加了`execute()`方法，它使用`os.rename()`执行实际的重命名操作。为了提供撤销操作的支持，我们添加了`undo()`方法，在其中我们再次使用`os.rename()`将文件的名称恢复到原始值。请注意，我们还使用了日志记录来改进输出。
- en: 'The beginning of the code, the imports we need, and the `RenameFile` class,
    are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的开始部分，我们需要导入的内容，以及`RenameFile`类如下所示：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, we add a `CreateFile` class for the command used to create a file. The
    initialization method for that class accepts the familiar `path` parameter and
    a `txt` parameter for the content that will be written to the file. If nothing
    is passed as content, the default “hello world” text is written to the file. Normally,
    the sane default behavior is to create an empty file, but for the needs of this
    example, I decided to write a default string in it. Then, we add an `execute()`
    method, in which we use Python’s `open()` function to open the file in `write()`
    function to write the `txt` string to it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为用于创建文件的命令添加一个`CreateFile`类。该类的初始化方法接受熟悉的`path`参数和一个`txt`参数，用于将要写入文件的内容。如果没有传递内容，则默认写入“hello
    world”文本。通常，合理的默认行为是创建一个空文件，但为了本例的需求，我决定在其中写入一个默认字符串。然后，我们添加一个`execute()`方法，在其中我们使用Python的`open()`函数以`write()`模式打开文件，并将`txt`字符串写入其中。
- en: The undo for the operation of creating a file is to delete that file. Thus,
    the `undo()` method is added to the class, where we use the `os.remove()` function
    to do the job.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件操作的撤销是删除该文件。因此，我们在类中添加了`undo()`方法，其中我们使用`os.remove()`函数来完成这项工作。
- en: 'The definition for the `CreateFile` class is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateFile`类的定义如下所示：'
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The last utility gives us the ability to read the contents of a file. The `execute()`
    method of the `ReadFile` class uses `open()` again, this time in read mode, and
    just prints the content of the file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个实用工具使我们能够读取文件的内容。`ReadFile`类的`execute()`方法再次使用`open()`，这次是在读取模式下，并仅打印文件的内容。
- en: 'The `ReadFile` class is defined as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadFile` 类定义如下：'
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `main()` function makes use of the utilities we have defined. The `orig_name`
    and `new_name` parameters are the original and new name of the file that is created
    and renamed. A commands list is used to add (and configure) all the commands that
    we want to execute at a later point. The code is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数使用了我们定义的实用工具。`orig_name` 和 `new_name` 参数是创建并重命名文件的原始名称和新名称。使用命令列表来添加（并配置）我们希望在以后执行的命令。代码如下：'
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we ask the users whether they want to undo the executed commands or not.
    The user selects whether the commands will be undone or not. If they choose to
    undo them, `undo()` is executed for all commands in the commands list. However,
    since not all commands support undo, exception handling is used to catch (and
    log) the `AttributeError` exception generated when the `undo()` method is missing.
    That part of the code would look like the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们询问用户是否想要撤销已执行的命令。用户选择是否撤销命令。如果他们选择撤销，则对命令列表中的所有命令执行 `undo()`。然而，由于并非所有命令都支持撤销，因此使用异常处理来捕获（并记录）当
    `undo()` 方法缺失时生成的 `AttributeError` 异常。这部分代码如下：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s recapitulate the complete code (in the `ch05/command.py` file) of the
    implementation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下完整的实现代码（在 `ch05/command.py` 文件中）：
- en: We import `logging` and `os` modules.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入 `logging` 和 `os` 模块。
- en: We do the usual logging configuration.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们进行常规的日志配置。
- en: We define the `RenameFile` class.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了 `RenameFile` 类。
- en: We define the `CreateFile` class.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了 `CreateFile` 类。
- en: We define the `ReadFile` class.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了 `ReadFile` 类。
- en: We add a `main()` function, and call it as usual, to test our design.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个 `main()` 函数，并像往常一样调用它来测试我们的设计。
- en: 'Executing the `python ch05/command.py` command gives us the following output,
    if we accept to reverse the commands:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `python ch05/command.py` 命令会给出以下输出，如果我们接受撤销命令：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, if we do not accept to reverse the commands, the output is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们不接受撤销命令，输出如下：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'class Observer:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Observer:'
- en: 'def update(self, temperature, humidity, pressure):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(self, temperature, humidity, pressure):'
- en: pass
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'class WeatherStation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'class WeatherStation:'
- en: 'def __init__(self):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: self.observers = []
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: self.observers = []
- en: 'def add_observer(self, observer):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'def add_observer(self, observer):'
- en: self.observers.append(observer)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: self.observers.append(observer)
- en: 'def remove_observer(self, observer):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'def remove_observer(self, observer):'
- en: self.observers.remove(observer)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: self.observers.remove(observer)
- en: 'def set_weather_data(self, temperature, humidity, pressure):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'def set_weather_data(self, temperature, humidity, pressure):'
- en: 'for observer in self.observers:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 'for observer in self.observers:'
- en: observer.update(temperature, humidity, pressure)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: observer.update(temperature, humidity, pressure)
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'class DisplayDevice(Observer):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'class DisplayDevice(Observer):'
- en: 'def __init__(self, name):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name):'
- en: self.name = name
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: self.name = name
- en: 'def update(self, temperature, humidity, pressure):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(self, temperature, humidity, pressure):'
- en: print(f"{self.name} Display")
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"{self.name} 显示屏")
- en: print(
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: print(
- en: 'f" - Temperature: {temperature}°C, Humidity: {humidity}%, Pressure: {pressure}hPa"'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: f" - 温度：{temperature}°C, 湿度：{humidity}%, 气压：{pressure}hPa"
- en: )
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'class WeatherApp(Observer):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'class WeatherApp(Observer):'
- en: 'def __init__(self, name):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name):'
- en: self.name = name
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: self.name = name
- en: 'def update(self, temperature, humidity, pressure):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(self, temperature, humidity, pressure):'
- en: print(f"{self.name} App - Weather Update")
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"{self.name} 应用 - 天气更新")
- en: print(
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: print(
- en: 'f" - Temperature: {temperature}°C, Humidity: {humidity}%, Pressure: {pressure}hPa"'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: f" - 温度：{temperature}°C, 湿度：{humidity}%, 气压：{pressure}hPa"
- en: )
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'def main():'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# Create the WeatherStation'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建天气站'
- en: weather_station = WeatherStation()
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: weather_station = WeatherStation()
- en: '# Create and register observers'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建并注册观察者'
- en: display1 = DisplayDevice("Living Room")
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: display1 = DisplayDevice("Living Room")
- en: display2 = DisplayDevice("Bedroom")
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: display2 = DisplayDevice("Bedroom")
- en: app1 = WeatherApp("Mobile App")
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: app1 = WeatherApp("Mobile App")
- en: weather_station.add_observer(display1)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: weather_station.add_observer(display1)
- en: weather_station.add_observer(display2)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: weather_station.add_observer(display2)
- en: weather_station.add_observer(app1)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: weather_station.add_observer(app1)
- en: '# Simulate weather data changes'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '# 模拟天气数据变化'
- en: weather_station.set_weather_data(25.5, 60, 1013.2)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: weather_station.set_weather_data(25.5, 60, 1013.2)
- en: weather_station.set_weather_data(26.0, 58, 1012.8)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: weather_station.set_weather_data(26.0, 58, 1012.8)
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Living Room Display
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 客厅显示屏
- en: '- Temperature: 25.5°C, Humidity: 60%, Pressure: 1013.2hPa'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '- 温度：25.5°C，湿度：60%，气压：1013.2hPa'
- en: Bedroom Display
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 卧室显示屏
- en: '- Temperature: 25.5°C, Humidity: 60%, Pressure: 1013.2hPa'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '- 温度：25.5°C，湿度：60%，气压：1013.2hPa'
- en: Mobile App App - Weather Update
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用应用 - 天气更新
- en: '- Temperature: 25.5°C, Humidity: 60%, Pressure: 1013.2hPa'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '- 温度：25.5°C，湿度：60%，气压：1013.2hPa'
- en: Living Room Display
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 客厅显示屏
- en: '- Temperature: 26.0°C, Humidity: 58%, Pressure: 1012.8hPa'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Bedroom Display
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '- Temperature: 26.0°C, Humidity: 58%, Pressure: 1012.8hPa'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Mobile App App - Weather Update
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '- Temperature: 26.0°C, Humidity: 58%, Pressure: 1012.8hPa'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: weather_station.remove_observer(display2)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: weather_station.set_weather_data(27.2, 55, 1012.5)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '@acts_as_state_machine'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'class Process:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: created = State(initial=True)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: waiting = State()
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: running = State()
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: terminated = State()
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: blocked = State()
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: swapped_out_waiting = State()
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: swapped_out_blocked = State()
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: wait = Event(
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: from_states=(
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: created,
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: running,
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: blocked,
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: swapped_out_waiting,
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: ),
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: to_state=waiting,
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: run = Event(
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: from_states=waiting, to_state=running
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: terminate = Event(
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: from_states=running, to_state=terminated
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: block = Event(
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: from_states=(
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: running,
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: swapped_out_blocked,
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: ),
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: to_state=blocked,
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: swap_wait = Event(
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: from_states=waiting,
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: to_state=swapped_out_waiting,
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: swap_block = Event(
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: from_states=blocked,
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: to_state=swapped_out_blocked,
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'def __init__(self, name):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '@after("wait")'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'def wait_info(self):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: print(f"{self.name} entered waiting mode")
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '@after("run")'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'def run_info(self):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: print(f"{self.name} is running")
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '@before("terminate")'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'def terminate_info(self):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: print(f"{self.name} terminated")
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '@after("block")'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'def block_info(self):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: print(f"{self.name} is blocked")
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '@after("swap_wait")'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'def swap_wait_info(self):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: print(
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: f"{self.name} is swapped out and waiting"
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '@after("swap_block")'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'def swap_block_info(self):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: print(
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: f"{self.name} is swapped out and blocked"
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'def transition(proc, event, event_name):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: event()
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'except InvalidStateTransition:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: msg = (
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: f"Transition of {proc.name} from {proc.current_state} "
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: f"to {event_name} failed"
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: print(msg)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'def state_info(proc):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: print(
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'f"state of {proc.name}: {proc.current_state}"'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'def main():'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: RUNNING = "running"
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: WAITING = "waiting"
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: BLOCKED = "blocked"
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: TERMINATED = "terminated"
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: p1, p2 = Process("process1"), Process(
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '"process2"'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[state_info(p) for p in (p1, p2)]'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: print()
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: transition(p1, p1.wait, WAITING)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: transition(p2, p2.terminate, TERMINATED)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[state_info(p) for p in (p1, p2)]'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: print()
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: transition(p1, p1.run, RUNNING)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: transition(p2, p2.wait, WAITING)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[state_info(p) for p in (p1, p2)]'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: print()
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: transition(p2, p2.run, RUNNING)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[state_info(p) for p in (p1, p2)]'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: print()
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '['
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: transition(p, p.block, BLOCKED)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: for p in (p1, p2)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[state_info(p) for p in (p1, p2)]'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: print()
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '['
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: transition(p, p.terminate, TERMINATED)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: for p in (p1, p2)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[state_info(p) for p in (p1, p2)]'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'state of process1: created'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process2: created'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: process1 entered waiting mode
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Transition of process2 from created to terminated failed
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process1: waiting'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process2: created'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: process1 is running
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: process2 entered waiting mode
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process1: running'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process2: waiting'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: process2 is running
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process1: running'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process2: running'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: process1 is blocked
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: process2 is blocked
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process1: blocked'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process2: blocked'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Transition of process1 from blocked to terminated failed
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Transition of process2 from blocked to terminated failed
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: process2从阻塞到终止的转换失败
- en: 'state of process1: blocked'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: process1的状态：阻塞
- en: 'state of process2: blocked'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: process2的状态：阻塞
- en: '[PRE30]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: open -> gate
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: open -> gate
- en: '[PRE31]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: increase -> boiler temperature -> 3 degrees
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: increase -> boiler temperature -> 3 degrees
- en: '[PRE32]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: event ::= command token receiver token arguments
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: event ::= command token receiver token arguments
- en: command ::= word+
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: command ::= word+
- en: word ::= a collection of one or more alphanumeric characters
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: word ::= 一组一个或多个字母数字字符
- en: token ::= ->
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: token ::= ->
- en: receiver ::= word+
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: receiver ::= word+
- en: arguments ::= word+
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: arguments ::= word+
- en: '[PRE33]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: word = Word(alphanums)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: word = Word(alphanums)
- en: command = Group(OneOrMore(word))
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: command = Group(OneOrMore(word))
- en: token = Suppre"s("->")
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: token = Suppre"s("->")
- en: device = Group(OneOrMore(word))
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: device = Group(OneOrMore(word))
- en: argument = Group(OneOrMore(word))
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: argument = Group(OneOrMore(word))
- en: event = command + token + device + Optional(token + argument)
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: event = command + token + device + Optional(token + argument)
- en: '[PRE34]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'class Boiler:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Boiler:'
- en: 'def __init__(self):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: self.temperature = 83  # in celsius
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: self.temperature = 83  # in celsius
- en: 'def __str__(self):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __str__(self):'
- en: 'return f"boiler temperature: {self.temperature}"'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: return f"锅炉温度：{self.temperature}"
- en: 'def increase_temperature(self, amount):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 'def increase_temperature(self, amount):'
- en: print(f"increasing the boiler's temperature by {amount} degrees")
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"提高锅炉的温度{amount}度")
- en: self.temperature += amount
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: self.temperature += amount
- en: 'def decrease_temperature(self, amount):'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 'def decrease_temperature(self, amount):'
- en: print(f"decreasing the boiler's temperature by {amount} degrees")
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"降低锅炉的温度{amount}度")
- en: self.temperature -= amount
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: self.temperature -= amount
- en: '[PRE35]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: word = Word(alphanums)
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: word = Word(alphanums)
- en: command = Group(OneOrMore(word))
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: command = Group(OneOrMore(word))
- en: token = Suppress("->")
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: token = Suppress("->")
- en: device = Group(OneOrMore(word))
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: device = Group(OneOrMore(word))
- en: argument = Group(OneOrMore(word))
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: argument = Group(OneOrMore(word))
- en: event = command + token + device + Optional(token + argument)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: event = command + token + device + Optional(token + argument)
- en: boiler = Boiler()
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: boiler = Boiler()
- en: '[PRE36]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: test = "increase -> boiler temperature -> 3 degrees"
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: test = "increase -> boiler temperature -> 3 degrees"
- en: cmd, dev, arg = event.parseString(test)
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: cmd, dev, arg = event.parseString(test)
- en: cmd_str = " ".join(cmd)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: cmd_str = " ".join(cmd)
- en: dev_str = " ".join(dev)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: dev_str = " ".join(dev)
- en: 'if "increase" in cmd_str and "boiler" in dev_str:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 'if "increase" in cmd_str and "boiler" in dev_str:'
- en: boiler.increase_temperature(int(arg[0]))
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: boiler.increase_temperature(int(arg[0]))
- en: print(boiler)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: print(boiler)
- en: '[PRE37]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: increasing the boiler's temperature by 3 degrees
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 将锅炉的温度提高3度
- en: 'ch05/interpreter/interpreter.py file) is not very different from what I just
    described. It is just extended to support more events and devices. Let’s summarize
    the steps here:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ch05/interpreter/interpreter.py文件)与我所描述的并没有太大区别。它只是扩展以支持更多的事件和设备。以下是对步骤的总结：
- en: First, we import all we need from `pyparsing`.
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从`pyparsing`导入所有需要的。
- en: 'We define the following classes: `Gate`, `Aircondition`, `Heating`, `Boiler`
    (already presented), and `Fridge`.'
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义以下类：`Gate`、`Aircondition`、`Heating`、`Boiler`（已介绍）和`Fridge`。
- en: 'Next, we have our main function:'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的主函数：
- en: 'We prepare the parameters for the tests we will be performing, using the following
    variables: `tests`, `open_actions`, and `close_actions`.'
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下变量`tests`、`open_actions`和`close_actions`为将要执行的测试准备参数。
- en: We execute the test actions.
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们执行测试动作。
- en: 'Executing the `python ch05/interpreter/interpreter.py` command gives the following
    output:'
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行`python ch05/interpreter/interpreter.py`命令会得到以下输出：
- en: '[PRE38]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'def pairs(seq):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 'def pairs(seq):'
- en: n = len(seq)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: n = len(seq)
- en: 'for i in range(n):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: yield seq[i], seq[(i + 1) % n]
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: yield seq[i], seq[(i + 1) % n]
- en: '[PRE39]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: SLOW = 3  # in seconds
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: SLOW = 3  # in seconds
- en: LIMIT = 5  # in characters
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: LIMIT = 5  # in characters
- en: WARNING"= "too bad, you picked the slow algorithm":("
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: WARNING"= "太糟糕了，你选择了慢算法":("
- en: 'def allUniqueSort(s):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 'def allUniqueSort(s):'
- en: 'if len(s) > LIMIT:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 'if len(s) > LIMIT:'
- en: print(WARNING)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: print(WARNING)
- en: time.sleep(SLOW)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: time.sleep(SLOW)
- en: srtStr = sorted(s)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: srtStr = sorted(s)
- en: 'for c1, c2 in pairs(srtStr):'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 'for c1, c2 in pairs(srtStr):'
- en: 'if c1 == c2:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 'if c1 == c2:'
- en: return False
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: return False
- en: return True
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: return True
- en: '[PRE40]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'def allUniqueSet(s):'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 'def allUniqueSet(s):'
- en: 'if len(s) < LIMIT:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 'if len(s) < LIMIT:'
- en: print(WARNING)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: print(WARNING)
- en: time.sleep(SLOW)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: time.sleep(SLOW)
- en: return True if len(set(s)) == len(s) else False
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: return True if len(set(s)) == len(s) else False
- en: '[PRE41]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'def main():'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: WORD_IN_DESC = "Insert word (type quit to exit)> "
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: WORD_IN_DESC = "插入单词（输入quit退出）> "
- en: 'STRAT_IN_DESC = "Choose strategy: [1] Use a set, [2] Sort and pair> "'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: STRAT_IN_DESC = "选择策略：[1] 使用集合，[2] 排序并配对> "
- en: 'while True:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: word = None
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: word = None
- en: 'while not word:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 'while not word:'
- en: word = input(WORD_IN_DESC)
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: word = input(WORD_IN_DESC)
- en: 'if word == "quit":'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 'if word == "quit":'
- en: print("bye")
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: print("bye")
- en: return
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: strategy_picked = None
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: strategy_picked = None
- en: 'strategies = {"1": allUniqueSet, "2": allUniqueSort}'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 'strategies = {"1": allUniqueSet, "2": allUniqueSort}'
- en: 'while strategy_picked not in strategies.keys():'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 'while strategy_picked not in strategies.keys():'
- en: strategy_picked = input(STRAT_IN_DESC)
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: strategy_picked = input(STRAT_IN_DESC)
- en: 'try:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: strategy = strategies[strategy_picked]
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: result = allUnique(word, strategy)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'print(f"allUnique({word}): {result}")'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'except KeyError:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'print(f"Incorrect option: {strategy_picked}")'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Insert word (type quit to exit)> balloon
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose strategy: [1] Use a set, [2] Sort and pair> 1'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'allUnique(balloon): False'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Insert word (type quit to exit)> balloon
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose strategy: [1] Use a set, [2] Sort and pair> 2'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: too bad, you picked the slow algorithm :(
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'allUnique(balloon): False'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Insert word (type quit to exit)> bye
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose strategy: [1] Use a set, [2] Sort and pair> 1'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: too bad, you picked the slow algorithm :(
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'allUnique(bye): True'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Insert word (type quit to exit)> bye
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose strategy: [1] Use a set, [2] Sort and pair> 2'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'allUnique(bye): True'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: balloon, has more than five characters and not all of them are unique. In this
    case, both algorithms return the correct result, False, but allUniqueSort() is
    slower and the user is warned.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: The second word, `bye`, has less than five characters and all characters are
    unique. Again, both algorithms return the expected result, `True`, but this time,
    `allUniqueSet()` is slower and the user is warned once more.
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Normally, the strategy that we want to use should not be picked by the user.
    The point of the strategy pattern is that it makes it possible to use different
    algorithms transparently. Change the code so that the faster algorithm is always
    picked.
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: There are two usual users of our code. One is the end user, who should be unaware
    of what’s happening in the code, and to achieve that we can follow the tips given
    in the previous paragraph. Another possible category of users is the other developers.
    Assume that we want to create an API that will be used by the other developers.
    How can we keep them unaware of the Strategy pattern? A tip is to think of encapsulating
    the two functions in a common class, for example, `AllUnique`. In this case, the
    other developers will just need to create an instance of that class and execute
    a single method, for instance, `test()`. What needs to be done in this method?
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The Memento pattern
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In many situations, we need a way to easily take a snapshot of the internal
    state of an object, so that we can restore the object with it when needed. Memento
    is a design pattern that can help us implement a solution for such situations.
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Memento design pattern has three key components:'
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Memento**: A simple object that contains basic state storage and retrieval
    capabilities'
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Originator**: An object that gets and sets values of Memento instances'
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caretaker**: An object that can store and retrieve all previously created
    Memento instances'
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Memento shares many similarities with the Command pattern.
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Real-world examples
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The Memento pattern can be seen in many situations in real life.
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: An example could be found in the dictionary we use for a language, such as English
    or French. The dictionary is regularly updated through the work of academic experts,
    with new words being added and other words becoming obsolete. Spoken and written
    languages evolve, and the official dictionary has to reflect that. From time to
    time, we revisit a previous edition to get an understanding of how the language
    was used at some point in the past. This could also be needed simply because information
    can be lost after a long period of time, and to find it, you may need to look
    into old editions. This can be useful for understanding something in a particular
    field. Someone doing research could use an old dictionary or go to the archives
    to find information about some words and expressions.
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，我们可以在一个语言（如英语或法语）的字典中找到这样的例子。该字典通过学术专家的工作定期更新，新词被添加，其他词变得过时。口语和书面语言都在不断发展，官方字典必须反映这一点。有时，我们会回顾以前的版本，以了解语言在某个过去时刻的使用情况。这也可以是因为信息在长时间后可能丢失，为了找到它，你可能需要查看旧版本。这有助于理解某个特定领域的知识。进行研究的某人可以使用旧字典或去档案馆查找有关某些单词和表达式的信息。
- en: This example can be extended to other written material, such as books and newspapers.
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此示例可以扩展到其他书面材料，如书籍和报纸。
- en: '**Zope** ([http://www.zope.org](http://www.zope.org)), with its integrated
    object database called **Zope Object Database** (**ZODB**), offers a good software
    example of the Memento pattern. It is famous for its **Through-The-Web** object
    management interface, with undo support, for website administrators. ZODB is an
    object database for Python and is in heavy use in the Pyramid and Plone stacks
    among others.'
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Zope** ([http://www.zope.org](http://www.zope.org))，其集成的对象数据库称为**Zope对象数据库**（**ZODB**），提供了一个很好的软件示例，展示了备忘录模式。它以其**通过Web**的对象管理界面而闻名，为网站管理员提供了撤销支持。ZODB是Python的对象数据库，在Pyramid和Plone等框架中被广泛使用。'
- en: Use cases for the Memento pattern
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 备忘录模式的用例
- en: Memento is usually used when you need to provide some sort of undo and redo
    capability for your users.
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 备忘录通常用于为用户提供某种撤销和重做功能。
- en: Another usage is the implementation of a UI dialog with OK/Cancel buttons, where
    we would store the state of the object on load, and if the user chooses to cancel,
    we would restore the initial state of the object.
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一种用法是实现带有OK/Cancel按钮的UI对话框，在加载对象时存储对象的状态，如果用户选择取消，我们将恢复对象的初始状态。
- en: Implementing the Memento pattern
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现备忘录模式
- en: We will approach the implementation of Memento, in a simplified way, and by
    doing things in a natural way for the Python language. This means we do not necessarily
    need several classes.
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将以简化的方式实现备忘录，并按照Python语言的自然方式来进行。这意味着我们不一定需要多个类。
- en: One thing we will use is Python’s `pickle` module. What is `pickle` used for?
    According to the module’s documentation ([https://docs.python.org/3/library/pickle.html](https://docs.python.org/3/library/pickle.html)),
    the `pickle` module can transform a complex object into a byte stream, and it
    can transform the byte stream into an object with the same internal structure.
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用Python的`pickle`模块。`pickle`模块有什么用？根据模块的文档（[https://docs.python.org/3/library/pickle.html](https://docs.python.org/3/library/pickle.html)），`pickle`模块可以将复杂对象转换为字节流，也可以将字节流转换回具有相同内部结构的对象。
- en: Warning
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 警告
- en: The `pickle` module is used here for the sake of our demonstration, but you
    should know that it is not secure for generic usage.
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用`pickle`模块是为了演示，但你应该知道它对于通用用途来说并不安全。
- en: 'Let’s take a `Quote` class, with the `text` and `author` attributes. To create
    memento, we will use a method on that class, `save_state()`, which as the name
    suggests will dump the state of the object, using the `pickle.dumps()` function.
    This creates memento:'
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们以一个`Quote`类为例，它具有`text`和`author`属性。为了创建备忘录，我们将使用该类的一个方法，`save_state()`，正如其名称所暗示的，它将使用`pickle.dumps()`函数转储对象的状态。这创建了备忘录：
- en: '[PRE43]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'That state can be restored later. For that, we add the `restore_state()` method,
    making use of the `pickle.loads()` function:'
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该状态可以稍后恢复。为此，我们添加了`restore_state()`方法，利用`pickle.loads()`函数：
- en: '[PRE44]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let’s also add the `__str__` method:'
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们再添加一个`__str__`方法：
- en: '[PRE45]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, in the main function, we can take care of things and test our implementation,
    as usual:'
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，在主函数中，我们可以像往常一样处理事情并测试我们的实现：
- en: '[PRE46]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here’s the recapitulation of the steps in the example (the `ch05/memento.py`
    file):'
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是示例中步骤的总结（`ch05/memento.py`文件）：
- en: We import the `pickle` module.
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入`pickle`模块。
- en: We define the `Quote` class.
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了`Quote`类。
- en: Finally, we add the main function where we test the implementation.
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加主函数来测试实现。
- en: 'Let’s view a sample execution using the `python` `ch05/memento.py` command:'
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们通过使用`python` `ch05/memento.py`命令查看一个示例执行：
- en: '[PRE47]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The Iterator pattern
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 迭代器模式
- en: 'In programming, we use sequences or collections of objects a lot, particularly
    in algorithms and when writing programs that manipulate data. One can think of
    automation scripts, APIs, data-driven apps, and other domains. In this chapter,
    we are going to see a pattern that is useful whenever we must handle collections
    of objects: the Iterator pattern.'
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在编程中，我们经常使用序列或对象集合，尤其是在算法和编写操作数据的程序时。我们可以将自动化脚本、API、数据驱动应用程序和其他领域考虑在内。在本章中，我们将看到一个在必须处理对象集合时非常有用的模式：迭代器模式。
- en: Note, according to the definition given by Wikipedia
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，根据维基百科给出的定义
- en: '*Iterator is a design pattern in which an iterator is used to traverse a container
    and access the container’s elements. The iterator pattern decouples algorithms
    from containers; in some cases, algorithms are necessarily container-specific
    and thus cannot* *be decoupled.*'
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*迭代器模式是一种设计模式，其中使用迭代器遍历容器并访问容器的元素。迭代器模式将算法与容器解耦；在某些情况下，算法必然是容器特定的，因此不能* *解耦*
    *。*'
- en: The Iterator pattern is extensively used in the Python context. As we will see,
    this translates into Iterator being a language feature. It is so useful that the
    language developers decided to make it a feature.
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 迭代器模式在Python环境中被广泛使用。正如我们将看到的，这导致迭代器成为语言特性。它如此有用，以至于语言开发者决定将其作为一个特性。
- en: Use cases for the Iterator pattern
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 迭代器模式的用例
- en: 'It is a good idea to use the Iterator pattern whenever you want one or several
    of the following behaviors:'
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你想要以下行为之一或多个时，使用迭代器模式是个好主意：
- en: Make it easy to navigate through a collection
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使导航集合变得容易
- en: Get the next object in the collection at any point
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何时刻获取集合中的下一个对象
- en: Stop when you are done traversing through the collection
  id: totrans-472
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成遍历集合后停止
- en: Implementing the Iterator pattern
  id: totrans-473
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现迭代器模式
- en: Iterator is implemented in Python for us, within for loops, list comprehensions,
    and so on. Iterator in Python is simply an object that can be iterated upon; an
    object that will return data, one element at a time.
  id: totrans-474
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 迭代器在Python中为我们实现，在for循环、列表推导式等中。Python中的迭代器简单地说是一个可以迭代的对象；一个一次返回一个数据元素的对象。
- en: 'We can do our own implementation for special cases, using the Iterator protocol,
    meaning that our iterator object must implement two special methods: `__iter__()`
    and `__next__()`.'
  id: totrans-475
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用迭代器协议为自己的特殊情况进行实现，这意味着我们的迭代器对象必须实现两个特殊方法：`__iter__()`和`__next__()`。
- en: An object is called iterable if we can get an iterator from it. Most of the
    built-in containers in Python (list, tuple, set, string, and so on) are iterable.
    The `iter()` function (which in turn calls the `__iter__()` method) returns an
    iterator from them.
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们可以从一个对象中获得迭代器，则该对象被称为可迭代的。Python中的大多数内置容器（列表、元组、集合、字符串等）都是可迭代的。`iter()`函数（它反过来调用`__iter__()`方法）从它们返回迭代器。
- en: Let’s consider a football team we want to implement with the help of the `FootballTeam`
    class. If we want to make an iterator out of it, we have to implement the Iterator
    protocol, since it is not a built-in container type such as the list type. Basically,
    built-in `iter()` and `next()` functions would not work on it unless they are
    added to the implementation.
  id: totrans-477
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们考虑一个我们想要使用`FootballTeam`类实现的足球队。如果我们想要将其转换为迭代器，我们必须实现迭代器协议，因为它不是一个内置容器类型，如列表类型。基本上，内置的`iter()`和`next()`函数不会对其起作用，除非它们被添加到实现中。
- en: 'First, we define the class of the iterator, `FootballTeamIterator`, that will
    be used to iterate through the football team object. The `members` attribute allows
    us to initialize the iterator object with our container object (which will be
    a `FootballTeam` instance). We add a `__iter__()` method to it, which would return
    the object itself, and a `__next__()` method to return the next person from the
    team at each call until we reach the last person. These will allow looping over
    the members of the football team via the iterator. The whole code for the `FootballTeamIterator`
    class is as follows:'
  id: totrans-478
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'So, now for the `FootballTeam` class itself; the next thing  to do is add a
    `__iter__()` method to it, which will initialize the iterator object that it needs
    (thus using `FootballTeamIterator(self.members)`) and return it:'
  id: totrans-480
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We add a small main function to test our implementation. Once we have a `FootballTeam`
    instance, we call the `iter()` function on it to create the iterator, and we loop
    through it using a `while` loop:'
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here is a recap of the steps in our example (the `ch05/iterator.py` file):'
  id: totrans-484
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We define the class for the iterator.
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the container class.
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define our main function followed by the snippet to call it.
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the output we get when executing the `python` `ch05/iterator.py` command:'
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'def generate_banner(msg, style):'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: print("-- start of banner --")
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: print(style(msg))
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: print("-- end of banner --nn")
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'def dots_style(msg):'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: msg = msg.capitalize()
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: ten_dots = "." * 10
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: msg = f"{ten_dots}{msg}{ten_dots}"
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: return msg
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'def admire_style(msg):'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: msg = msg.upper()
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: return "!".join(msg)
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'def cow_style(msg):'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: msg = cow.milk_random_cow(msg)
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: return msg
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'def main():'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: styles = (dots_style, admire_style, cow_style)
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: msg = "happy coding"
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '[generate_banner(msg, style) for style in styles]'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Part 3: Beyond the Gang of Four'
  id: totrans-516
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part goes beyond the classic design patterns to help you address special
    software design needs such as microservices, cloud-based applications, and performance
    optimization. It also discusses patterns for testing and specific Python anti-patterns
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21896_06.xhtml#_idTextAnchor163), *Architectural Design Patterns*'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21896_07.xhtml#_idTextAnchor191), *Concurrency and Asynchronous
    Patterns*'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21896_08.xhtml#_idTextAnchor216), *Performance Patterns*'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21896_09.xhtml#_idTextAnchor233), *Distributed Systems Patterns*'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B21896_10.xhtml#_idTextAnchor256), *Patterns for Testing*'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21896_11.xhtml#_idTextAnchor273), *Python Anti-Patterns*'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
