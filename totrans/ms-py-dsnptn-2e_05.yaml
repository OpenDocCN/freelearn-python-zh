- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behavioral Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered structural patterns and **object-oriented
    programming** (**OOP**) patterns that help us create clean, maintainable, and
    scalable code. The next category of design patterns is **behavioral design patterns**.
    Behavioral patterns deal with object interconnection and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Chain of Responsibility pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Command pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The State pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Interpreter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Memento pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Iterator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Template pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other behavioral design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter, you will know how to improve your software project
    designs using behavioral patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'See the requirements presented in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017).
    The additional technical requirements for the code discussed in this chapter are
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the State pattern section, install the `state_machine` module, using the
    command: `python -m pip` `install` `state_machine`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the Interpreter pattern section, install the `pyparsing` module, using
    the command: `python –m pip` `install pyparsing`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the Template pattern section, install the `cowpy` module, using the command:
    `python -m pip` `install cowpy`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chain of Responsibility pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Chain of Responsibility pattern offers an elegant way to handle requests
    by passing them through a chain of handlers. Each handler in the chain has the
    autonomy to decide whether it can process the request or if it should delegate
    it further along the chain. This pattern shines when dealing with operations that
    involve multiple handlers but don’t necessarily require all of them to be involved.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this pattern encourages us to focus on objects and the flow of
    a request within an application. Notably, the client code remains blissfully unaware
    of the entire chain of handlers. Instead, it only interacts with the first processing
    element in the chain. Similarly, each processing element knows only about its
    immediate successor, forming a one-way relationship similar to a singly linked
    list. This structure is purposefully designed to achieve decoupling between the
    sender (client) and the receivers (processing elements).
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ATMs and, in general, any kind of machine that accepts/returns banknotes or
    coins (for example, a snack-vending machine) use the Chain of Responsibility pattern.
    There is always a single slot for all banknotes, as shown in the following diagram,
    courtesy of [www.sourcemaking.com](http://www.sourcemaking.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Chain of Responsibility example: the ATM](img/B21896_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1 – Chain of Responsibility example: the ATM'
  prefs: []
  type: TYPE_NORMAL
- en: When a banknote is dropped, it is routed to the appropriate receptacle. When
    it is returned, it is taken from the appropriate receptacle. We can think of the
    single slot as the shared communication medium and the different receptacles as
    the processing elements. The result contains cash from one or more receptacles.
    For example, in the preceding diagram, we see what happens when we request $175
    from the ATM.
  prefs: []
  type: TYPE_NORMAL
- en: In some web frameworks, filters or middleware are pieces of code that are executed
    before an HTTP request arrives at a target. There is a chain of filters. Each
    filter performs a different action (user authentication, logging, data compression,
    and so forth), and either forwards the request to the next filter until the chain
    is exhausted, or it breaks the flow if there is an error—for example, the authentication
    failed three consecutive times.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for the Chain of Responsibility pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using the Chain of Responsibility pattern, we provide a chance for a number
    of different objects to satisfy a specific request. This is useful when we don’t
    know in advance which object should satisfy a given request. An example of this
    is a **purchase system**. In purchase systems, there are many approval authorities.
    One approval authority might be able to approve orders up to a certain value,
    let’s say $100\. If the order is for more than $100, the order is sent to the
    next approval authority in the chain, which can approve orders up to $200, and
    so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Another case where the Chain of Responsibility is useful is when we know that
    more than one object might need to process a single request. This is what happens
    in event-based programming. A single event, such as a left-mouse click, can be
    caught by more than one listener.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the Chain of Responsibility pattern is not very
    useful if all the requests can be taken care of by a single processing element
    unless we really don’t know which element that is. The value of this pattern is
    the decoupling that it offers, as we have seen in the *Loose coupling* section
    of [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017), *Foundational Design Principles*.
    Instead of having a many-to-many relationship between a client and all processing
    elements (and the same is true regarding the relationship between a processing
    element and all other processing elements), a client only needs to know how to
    communicate with the start (head) of the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Chain of Responsibility pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to implement a Chain of Responsibility in Python, but my
    favorite implementation is the one by Vespe Savikko ([https://legacy.python.org/workshops/1997-10/proceedings/savikko.html](https://legacy.python.org/workshops/1997-10/proceedings/savikko.html)).
    Vespe’s implementation uses dynamic dispatching in a Pythonic style to handle
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement a simple, event-based system using Vespe’s implementation as
    a guide. The following is the UML class diagram of the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – UML class diagram of an event-based window system](img/B21896_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – UML class diagram of an event-based window system
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Event` class describes an event. We’ll keep it simple, so, in our case,
    an event has only `name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Widget` class is the core class of the application. The `parent` object,
    which, by convention, we assume is a `Widget` instance. Note, however, that according
    to the rules of inheritance, an instance of any of the subclasses of `Widget`
    (for example, an instance of `MsgText`) is also an instance of `Widget`. The class
    has a `handle()` method, which uses dynamic dispatching through `hasattr()` and
    `getattr()` to decide who the handler of a specific request (event) is. If the
    widget that is asked to handle an event does not support it, there are two fallback
    mechanisms. If the widget has a parent, then the `handle()` method of the parent
    is executed. If the widget has no parent but a `handle_default()` method, `handle_default()`
    is executed. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you might have realized why the `Widget` and `Event` classes
    are only associated (no aggregation or composition relationships) in the UML class
    diagram. The association is used to show that the `Widget` class knows about the
    `Event` class but does not have any strict reference to it, since an event needs
    to be passed only as a parameter to `handle()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`MainWIndow`, `MsgText`, and `SendDialog` are all widgets with different behaviors.
    Not all these three widgets are expected to be able to handle the same events,
    and even if they can handle the same event, they might behave differently. `MainWindow`
    can handle only the close and default events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`SendDialog` can handle only the `paint` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `MsgText` can handle only the `down` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main()` function shows how we can create a few widgets and events, and
    how the widgets react to those events. All events are sent to all the widgets.
    Note the parent relationship of each widget—the `sd` object (an instance of `SendDialog`)
    has as its parent the `mw` object (an instance of `MainWindow`). However, not
    all objects need to have a parent that is an instance of `MainWindow`. For example,
    the `msg` object (an instance of `MsgText`) has the `sd` object as a parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s recapitulate the complete code (see file `ch05/chain.py`) of the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: We define the `Event` class, followed by the `Widget` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the specialized widget classes, `MainWindow`, `SendDialog`, and `MsgText`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add the code for the `main()` function; we make sure it can be called
    thanks to the usual trick at the end.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Executing the `python ch05/chain.py` command gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Command pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications nowadays have an undo operation. It is hard to imagine, but
    undo did not exist in any software for many years. Undo was introduced in 1974,
    but Fortran and Lisp, two programming languages that are still widely used, were
    created in 1957 and 1958, respectively! I wouldn’t like to have been an application
    user during those years. Making a mistake meant that the user had no easy way
    to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enough with the history. We want to know how we can implement the undo functionality
    in our applications. Since you have read the title of this chapter, you already
    know which design pattern is recommended to implement undo: the Command pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Command design pattern helps us encapsulate an operation (undo, redo, copy,
    paste, and so forth) as an object. What this simply means is that we create a
    class that contains all the logic and the methods required to implement the operation.
    The advantages of doing this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t have to execute a command directly. It can be executed at will.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object that invokes the command is decoupled from the object that knows
    how to perform it. The invoker does not need to know any implementation details
    about the command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it makes sense, multiple commands can be grouped to allow the invoker to
    execute them in order. This is useful, for instance, when implementing a multilevel
    undo command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we go to a restaurant for dinner, we give the order to the waiter. The
    check (usually paper) that they use to write the order is an example of a command.
    After writing the order, the waiter places it in the check queue that is executed
    by the cook. Each check is independent and can be used to execute many different
    commands, for example, one command for each item that will be cooked.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you would expect, we also have several examples in the software. Here are
    two I can think of:'
  prefs: []
  type: TYPE_NORMAL
- en: PyQt is the Python binding of the QT toolkit. PyQt contains a `QAction` class
    that models an action as a command. Extra optional information is supported for
    every action, such as description, tooltip, and shortcut.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git Cola, a Git GUI written in Python, uses the command pattern to modify the
    model, amend a commit, apply a different election, check out, and so forth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases for the Command pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many developers use the undo example as the only use case of the Command pattern.
    The truth is that undo is the killer feature of the Command pattern. However,
    the Command pattern can actually do much more:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GUI buttons and menu items**: The PyQt example that was already mentioned
    uses the Command pattern to implement actions on buttons and menu items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other operations**: Apart from undo, commands can be used to implement any
    operation. A few examples are *cut*, *copy*, *paste*, *redo*, and *capitalize
    text*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transactional behavior and logging**: Transactional behavior and logging
    are important to keep a persistent log of changes. They are used by operating
    systems to recover from system crashes, relational databases to implement transactions,
    filesystems to implement snapshots, and installers (wizards) to revert canceled
    installations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Macros**: By macros, in this case, we mean a sequence of actions that can
    be recorded and executed on demand at any point in time. Popular editors such
    as Emacs and Vim support macros.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Command pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s use the Command pattern to implement the following basic file utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a file and, optionally, adding text to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the contents of a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renaming a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are not going to implement these utilities from scratch since Python already
    offers good implementations for them in the `os` module. What we want to do is
    to add an extra abstraction level on top of them so that they can be treated as
    commands. By doing this, we get all the advantages offered by commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each command has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__()` method and contains all the information required by the command
    to be able to do something useful (the path of a file, the contents that will
    be written to the file, and so forth).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execute()` method. We call that method when we want to run a command. This
    is not necessarily right after initializing it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with the rename utility, which we implement using the `RenameFile`
    class. The class is initialized using the source and destination file paths. We
    add the `execute()` method, which does the actual renaming using `os.rename()`.
    To provide support for the undo operation, we add the `undo()` method, where we
    use `os.rename()` again to revert the name of the file to its original value.
    Note that we also use logging to improve the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The beginning of the code, the imports we need, and the `RenameFile` class,
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next, we add a `CreateFile` class for the command used to create a file. The
    initialization method for that class accepts the familiar `path` parameter and
    a `txt` parameter for the content that will be written to the file. If nothing
    is passed as content, the default “hello world” text is written to the file. Normally,
    the sane default behavior is to create an empty file, but for the needs of this
    example, I decided to write a default string in it. Then, we add an `execute()`
    method, in which we use Python’s `open()` function to open the file in `write()`
    function to write the `txt` string to it.
  prefs: []
  type: TYPE_NORMAL
- en: The undo for the operation of creating a file is to delete that file. Thus,
    the `undo()` method is added to the class, where we use the `os.remove()` function
    to do the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition for the `CreateFile` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The last utility gives us the ability to read the contents of a file. The `execute()`
    method of the `ReadFile` class uses `open()` again, this time in read mode, and
    just prints the content of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ReadFile` class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main()` function makes use of the utilities we have defined. The `orig_name`
    and `new_name` parameters are the original and new name of the file that is created
    and renamed. A commands list is used to add (and configure) all the commands that
    we want to execute at a later point. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we ask the users whether they want to undo the executed commands or not.
    The user selects whether the commands will be undone or not. If they choose to
    undo them, `undo()` is executed for all commands in the commands list. However,
    since not all commands support undo, exception handling is used to catch (and
    log) the `AttributeError` exception generated when the `undo()` method is missing.
    That part of the code would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s recapitulate the complete code (in the `ch05/command.py` file) of the
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: We import `logging` and `os` modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do the usual logging configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the `RenameFile` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the `CreateFile` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the `ReadFile` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add a `main()` function, and call it as usual, to test our design.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Executing the `python ch05/command.py` command gives us the following output,
    if we accept to reverse the commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we do not accept to reverse the commands, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'class Observer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self, temperature, humidity, pressure):'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'class WeatherStation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.observers = []
  prefs: []
  type: TYPE_NORMAL
- en: 'def add_observer(self, observer):'
  prefs: []
  type: TYPE_NORMAL
- en: self.observers.append(observer)
  prefs: []
  type: TYPE_NORMAL
- en: 'def remove_observer(self, observer):'
  prefs: []
  type: TYPE_NORMAL
- en: self.observers.remove(observer)
  prefs: []
  type: TYPE_NORMAL
- en: 'def set_weather_data(self, temperature, humidity, pressure):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for observer in self.observers:'
  prefs: []
  type: TYPE_NORMAL
- en: observer.update(temperature, humidity, pressure)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'class DisplayDevice(Observer):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self, temperature, humidity, pressure):'
  prefs: []
  type: TYPE_NORMAL
- en: print(f"{self.name} Display")
  prefs: []
  type: TYPE_NORMAL
- en: print(
  prefs: []
  type: TYPE_NORMAL
- en: 'f" - Temperature: {temperature}°C, Humidity: {humidity}%, Pressure: {pressure}hPa"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'class WeatherApp(Observer):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, name):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self, temperature, humidity, pressure):'
  prefs: []
  type: TYPE_NORMAL
- en: print(f"{self.name} App - Weather Update")
  prefs: []
  type: TYPE_NORMAL
- en: print(
  prefs: []
  type: TYPE_NORMAL
- en: 'f" - Temperature: {temperature}°C, Humidity: {humidity}%, Pressure: {pressure}hPa"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: '# Create the WeatherStation'
  prefs: []
  type: TYPE_NORMAL
- en: weather_station = WeatherStation()
  prefs: []
  type: TYPE_NORMAL
- en: '# Create and register observers'
  prefs: []
  type: TYPE_NORMAL
- en: display1 = DisplayDevice("Living Room")
  prefs: []
  type: TYPE_NORMAL
- en: display2 = DisplayDevice("Bedroom")
  prefs: []
  type: TYPE_NORMAL
- en: app1 = WeatherApp("Mobile App")
  prefs: []
  type: TYPE_NORMAL
- en: weather_station.add_observer(display1)
  prefs: []
  type: TYPE_NORMAL
- en: weather_station.add_observer(display2)
  prefs: []
  type: TYPE_NORMAL
- en: weather_station.add_observer(app1)
  prefs: []
  type: TYPE_NORMAL
- en: '# Simulate weather data changes'
  prefs: []
  type: TYPE_NORMAL
- en: weather_station.set_weather_data(25.5, 60, 1013.2)
  prefs: []
  type: TYPE_NORMAL
- en: weather_station.set_weather_data(26.0, 58, 1012.8)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Living Room Display
  prefs: []
  type: TYPE_NORMAL
- en: '- Temperature: 25.5°C, Humidity: 60%, Pressure: 1013.2hPa'
  prefs: []
  type: TYPE_NORMAL
- en: Bedroom Display
  prefs: []
  type: TYPE_NORMAL
- en: '- Temperature: 25.5°C, Humidity: 60%, Pressure: 1013.2hPa'
  prefs: []
  type: TYPE_NORMAL
- en: Mobile App App - Weather Update
  prefs: []
  type: TYPE_NORMAL
- en: '- Temperature: 25.5°C, Humidity: 60%, Pressure: 1013.2hPa'
  prefs: []
  type: TYPE_NORMAL
- en: Living Room Display
  prefs: []
  type: TYPE_NORMAL
- en: '- Temperature: 26.0°C, Humidity: 58%, Pressure: 1012.8hPa'
  prefs: []
  type: TYPE_NORMAL
- en: Bedroom Display
  prefs: []
  type: TYPE_NORMAL
- en: '- Temperature: 26.0°C, Humidity: 58%, Pressure: 1012.8hPa'
  prefs: []
  type: TYPE_NORMAL
- en: Mobile App App - Weather Update
  prefs: []
  type: TYPE_NORMAL
- en: '- Temperature: 26.0°C, Humidity: 58%, Pressure: 1012.8hPa'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: weather_station.remove_observer(display2)
  prefs: []
  type: TYPE_NORMAL
- en: weather_station.set_weather_data(27.2, 55, 1012.5)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '@acts_as_state_machine'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Process:'
  prefs: []
  type: TYPE_NORMAL
- en: created = State(initial=True)
  prefs: []
  type: TYPE_NORMAL
- en: waiting = State()
  prefs: []
  type: TYPE_NORMAL
- en: running = State()
  prefs: []
  type: TYPE_NORMAL
- en: terminated = State()
  prefs: []
  type: TYPE_NORMAL
- en: blocked = State()
  prefs: []
  type: TYPE_NORMAL
- en: swapped_out_waiting = State()
  prefs: []
  type: TYPE_NORMAL
- en: swapped_out_blocked = State()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: wait = Event(
  prefs: []
  type: TYPE_NORMAL
- en: from_states=(
  prefs: []
  type: TYPE_NORMAL
- en: created,
  prefs: []
  type: TYPE_NORMAL
- en: running,
  prefs: []
  type: TYPE_NORMAL
- en: blocked,
  prefs: []
  type: TYPE_NORMAL
- en: swapped_out_waiting,
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: to_state=waiting,
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: run = Event(
  prefs: []
  type: TYPE_NORMAL
- en: from_states=waiting, to_state=running
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: terminate = Event(
  prefs: []
  type: TYPE_NORMAL
- en: from_states=running, to_state=terminated
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: block = Event(
  prefs: []
  type: TYPE_NORMAL
- en: from_states=(
  prefs: []
  type: TYPE_NORMAL
- en: running,
  prefs: []
  type: TYPE_NORMAL
- en: swapped_out_blocked,
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: to_state=blocked,
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: swap_wait = Event(
  prefs: []
  type: TYPE_NORMAL
- en: from_states=waiting,
  prefs: []
  type: TYPE_NORMAL
- en: to_state=swapped_out_waiting,
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: swap_block = Event(
  prefs: []
  type: TYPE_NORMAL
- en: from_states=blocked,
  prefs: []
  type: TYPE_NORMAL
- en: to_state=swapped_out_blocked,
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'def __init__(self, name):'
  prefs: []
  type: TYPE_NORMAL
- en: self.name = name
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '@after("wait")'
  prefs: []
  type: TYPE_NORMAL
- en: 'def wait_info(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print(f"{self.name} entered waiting mode")
  prefs: []
  type: TYPE_NORMAL
- en: '@after("run")'
  prefs: []
  type: TYPE_NORMAL
- en: 'def run_info(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print(f"{self.name} is running")
  prefs: []
  type: TYPE_NORMAL
- en: '@before("terminate")'
  prefs: []
  type: TYPE_NORMAL
- en: 'def terminate_info(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print(f"{self.name} terminated")
  prefs: []
  type: TYPE_NORMAL
- en: '@after("block")'
  prefs: []
  type: TYPE_NORMAL
- en: 'def block_info(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print(f"{self.name} is blocked")
  prefs: []
  type: TYPE_NORMAL
- en: '@after("swap_wait")'
  prefs: []
  type: TYPE_NORMAL
- en: 'def swap_wait_info(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print(
  prefs: []
  type: TYPE_NORMAL
- en: f"{self.name} is swapped out and waiting"
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '@after("swap_block")'
  prefs: []
  type: TYPE_NORMAL
- en: 'def swap_block_info(self):'
  prefs: []
  type: TYPE_NORMAL
- en: print(
  prefs: []
  type: TYPE_NORMAL
- en: f"{self.name} is swapped out and blocked"
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'def transition(proc, event, event_name):'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: event()
  prefs: []
  type: TYPE_NORMAL
- en: 'except InvalidStateTransition:'
  prefs: []
  type: TYPE_NORMAL
- en: msg = (
  prefs: []
  type: TYPE_NORMAL
- en: f"Transition of {proc.name} from {proc.current_state} "
  prefs: []
  type: TYPE_NORMAL
- en: f"to {event_name} failed"
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: print(msg)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'def state_info(proc):'
  prefs: []
  type: TYPE_NORMAL
- en: print(
  prefs: []
  type: TYPE_NORMAL
- en: 'f"state of {proc.name}: {proc.current_state}"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: RUNNING = "running"
  prefs: []
  type: TYPE_NORMAL
- en: WAITING = "waiting"
  prefs: []
  type: TYPE_NORMAL
- en: BLOCKED = "blocked"
  prefs: []
  type: TYPE_NORMAL
- en: TERMINATED = "terminated"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: p1, p2 = Process("process1"), Process(
  prefs: []
  type: TYPE_NORMAL
- en: '"process2"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '[state_info(p) for p in (p1, p2)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: transition(p1, p1.wait, WAITING)
  prefs: []
  type: TYPE_NORMAL
- en: transition(p2, p2.terminate, TERMINATED)
  prefs: []
  type: TYPE_NORMAL
- en: '[state_info(p) for p in (p1, p2)]'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: transition(p1, p1.run, RUNNING)
  prefs: []
  type: TYPE_NORMAL
- en: transition(p2, p2.wait, WAITING)
  prefs: []
  type: TYPE_NORMAL
- en: '[state_info(p) for p in (p1, p2)]'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: transition(p2, p2.run, RUNNING)
  prefs: []
  type: TYPE_NORMAL
- en: '[state_info(p) for p in (p1, p2)]'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: transition(p, p.block, BLOCKED)
  prefs: []
  type: TYPE_NORMAL
- en: for p in (p1, p2)
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[state_info(p) for p in (p1, p2)]'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: transition(p, p.terminate, TERMINATED)
  prefs: []
  type: TYPE_NORMAL
- en: for p in (p1, p2)
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[state_info(p) for p in (p1, p2)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'state of process1: created'
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process2: created'
  prefs: []
  type: TYPE_NORMAL
- en: process1 entered waiting mode
  prefs: []
  type: TYPE_NORMAL
- en: Transition of process2 from created to terminated failed
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process1: waiting'
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process2: created'
  prefs: []
  type: TYPE_NORMAL
- en: process1 is running
  prefs: []
  type: TYPE_NORMAL
- en: process2 entered waiting mode
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process1: running'
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process2: waiting'
  prefs: []
  type: TYPE_NORMAL
- en: process2 is running
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process1: running'
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process2: running'
  prefs: []
  type: TYPE_NORMAL
- en: process1 is blocked
  prefs: []
  type: TYPE_NORMAL
- en: process2 is blocked
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process1: blocked'
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process2: blocked'
  prefs: []
  type: TYPE_NORMAL
- en: Transition of process1 from blocked to terminated failed
  prefs: []
  type: TYPE_NORMAL
- en: Transition of process2 from blocked to terminated failed
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process1: blocked'
  prefs: []
  type: TYPE_NORMAL
- en: 'state of process2: blocked'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: open -> gate
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: increase -> boiler temperature -> 3 degrees
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: event ::= command token receiver token arguments
  prefs: []
  type: TYPE_NORMAL
- en: command ::= word+
  prefs: []
  type: TYPE_NORMAL
- en: word ::= a collection of one or more alphanumeric characters
  prefs: []
  type: TYPE_NORMAL
- en: token ::= ->
  prefs: []
  type: TYPE_NORMAL
- en: receiver ::= word+
  prefs: []
  type: TYPE_NORMAL
- en: arguments ::= word+
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: word = Word(alphanums)
  prefs: []
  type: TYPE_NORMAL
- en: command = Group(OneOrMore(word))
  prefs: []
  type: TYPE_NORMAL
- en: token = Suppre"s("->")
  prefs: []
  type: TYPE_NORMAL
- en: device = Group(OneOrMore(word))
  prefs: []
  type: TYPE_NORMAL
- en: argument = Group(OneOrMore(word))
  prefs: []
  type: TYPE_NORMAL
- en: event = command + token + device + Optional(token + argument)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'class Boiler:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.temperature = 83  # in celsius
  prefs: []
  type: TYPE_NORMAL
- en: 'def __str__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'return f"boiler temperature: {self.temperature}"'
  prefs: []
  type: TYPE_NORMAL
- en: 'def increase_temperature(self, amount):'
  prefs: []
  type: TYPE_NORMAL
- en: print(f"increasing the boiler's temperature by {amount} degrees")
  prefs: []
  type: TYPE_NORMAL
- en: self.temperature += amount
  prefs: []
  type: TYPE_NORMAL
- en: 'def decrease_temperature(self, amount):'
  prefs: []
  type: TYPE_NORMAL
- en: print(f"decreasing the boiler's temperature by {amount} degrees")
  prefs: []
  type: TYPE_NORMAL
- en: self.temperature -= amount
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: word = Word(alphanums)
  prefs: []
  type: TYPE_NORMAL
- en: command = Group(OneOrMore(word))
  prefs: []
  type: TYPE_NORMAL
- en: token = Suppress("->")
  prefs: []
  type: TYPE_NORMAL
- en: device = Group(OneOrMore(word))
  prefs: []
  type: TYPE_NORMAL
- en: argument = Group(OneOrMore(word))
  prefs: []
  type: TYPE_NORMAL
- en: event = command + token + device + Optional(token + argument)
  prefs: []
  type: TYPE_NORMAL
- en: boiler = Boiler()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: test = "increase -> boiler temperature -> 3 degrees"
  prefs: []
  type: TYPE_NORMAL
- en: cmd, dev, arg = event.parseString(test)
  prefs: []
  type: TYPE_NORMAL
- en: cmd_str = " ".join(cmd)
  prefs: []
  type: TYPE_NORMAL
- en: dev_str = " ".join(dev)
  prefs: []
  type: TYPE_NORMAL
- en: 'if "increase" in cmd_str and "boiler" in dev_str:'
  prefs: []
  type: TYPE_NORMAL
- en: boiler.increase_temperature(int(arg[0]))
  prefs: []
  type: TYPE_NORMAL
- en: print(boiler)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: increasing the boiler's temperature by 3 degrees
  prefs: []
  type: TYPE_NORMAL
- en: 'ch05/interpreter/interpreter.py file) is not very different from what I just
    described. It is just extended to support more events and devices. Let’s summarize
    the steps here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we import all we need from `pyparsing`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We define the following classes: `Gate`, `Aircondition`, `Heating`, `Boiler`
    (already presented), and `Fridge`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we have our main function:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We prepare the parameters for the tests we will be performing, using the following
    variables: `tests`, `open_actions`, and `close_actions`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We execute the test actions.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Executing the `python ch05/interpreter/interpreter.py` command gives the following
    output:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'def pairs(seq):'
  prefs: []
  type: TYPE_NORMAL
- en: n = len(seq)
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  prefs: []
  type: TYPE_NORMAL
- en: yield seq[i], seq[(i + 1) % n]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: SLOW = 3  # in seconds
  prefs: []
  type: TYPE_NORMAL
- en: LIMIT = 5  # in characters
  prefs: []
  type: TYPE_NORMAL
- en: WARNING"= "too bad, you picked the slow algorithm":("
  prefs: []
  type: TYPE_NORMAL
- en: 'def allUniqueSort(s):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(s) > LIMIT:'
  prefs: []
  type: TYPE_NORMAL
- en: print(WARNING)
  prefs: []
  type: TYPE_NORMAL
- en: time.sleep(SLOW)
  prefs: []
  type: TYPE_NORMAL
- en: srtStr = sorted(s)
  prefs: []
  type: TYPE_NORMAL
- en: 'for c1, c2 in pairs(srtStr):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if c1 == c2:'
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: return True
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'def allUniqueSet(s):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(s) < LIMIT:'
  prefs: []
  type: TYPE_NORMAL
- en: print(WARNING)
  prefs: []
  type: TYPE_NORMAL
- en: time.sleep(SLOW)
  prefs: []
  type: TYPE_NORMAL
- en: return True if len(set(s)) == len(s) else False
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: WORD_IN_DESC = "Insert word (type quit to exit)> "
  prefs: []
  type: TYPE_NORMAL
- en: 'STRAT_IN_DESC = "Choose strategy: [1] Use a set, [2] Sort and pair> "'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: word = None
  prefs: []
  type: TYPE_NORMAL
- en: 'while not word:'
  prefs: []
  type: TYPE_NORMAL
- en: word = input(WORD_IN_DESC)
  prefs: []
  type: TYPE_NORMAL
- en: 'if word == "quit":'
  prefs: []
  type: TYPE_NORMAL
- en: print("bye")
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: strategy_picked = None
  prefs: []
  type: TYPE_NORMAL
- en: 'strategies = {"1": allUniqueSet, "2": allUniqueSort}'
  prefs: []
  type: TYPE_NORMAL
- en: 'while strategy_picked not in strategies.keys():'
  prefs: []
  type: TYPE_NORMAL
- en: strategy_picked = input(STRAT_IN_DESC)
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: strategy = strategies[strategy_picked]
  prefs: []
  type: TYPE_NORMAL
- en: result = allUnique(word, strategy)
  prefs: []
  type: TYPE_NORMAL
- en: 'print(f"allUnique({word}): {result}")'
  prefs: []
  type: TYPE_NORMAL
- en: 'except KeyError:'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(f"Incorrect option: {strategy_picked}")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Insert word (type quit to exit)> balloon
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose strategy: [1] Use a set, [2] Sort and pair> 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'allUnique(balloon): False'
  prefs: []
  type: TYPE_NORMAL
- en: Insert word (type quit to exit)> balloon
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose strategy: [1] Use a set, [2] Sort and pair> 2'
  prefs: []
  type: TYPE_NORMAL
- en: too bad, you picked the slow algorithm :(
  prefs: []
  type: TYPE_NORMAL
- en: 'allUnique(balloon): False'
  prefs: []
  type: TYPE_NORMAL
- en: Insert word (type quit to exit)> bye
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose strategy: [1] Use a set, [2] Sort and pair> 1'
  prefs: []
  type: TYPE_NORMAL
- en: too bad, you picked the slow algorithm :(
  prefs: []
  type: TYPE_NORMAL
- en: 'allUnique(bye): True'
  prefs: []
  type: TYPE_NORMAL
- en: Insert word (type quit to exit)> bye
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose strategy: [1] Use a set, [2] Sort and pair> 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'allUnique(bye): True'
  prefs: []
  type: TYPE_NORMAL
- en: balloon, has more than five characters and not all of them are unique. In this
    case, both algorithms return the correct result, False, but allUniqueSort() is
    slower and the user is warned.
  prefs: []
  type: TYPE_NORMAL
- en: The second word, `bye`, has less than five characters and all characters are
    unique. Again, both algorithms return the expected result, `True`, but this time,
    `allUniqueSet()` is slower and the user is warned once more.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Normally, the strategy that we want to use should not be picked by the user.
    The point of the strategy pattern is that it makes it possible to use different
    algorithms transparently. Change the code so that the faster algorithm is always
    picked.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: There are two usual users of our code. One is the end user, who should be unaware
    of what’s happening in the code, and to achieve that we can follow the tips given
    in the previous paragraph. Another possible category of users is the other developers.
    Assume that we want to create an API that will be used by the other developers.
    How can we keep them unaware of the Strategy pattern? A tip is to think of encapsulating
    the two functions in a common class, for example, `AllUnique`. In this case, the
    other developers will just need to create an instance of that class and execute
    a single method, for instance, `test()`. What needs to be done in this method?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The Memento pattern
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In many situations, we need a way to easily take a snapshot of the internal
    state of an object, so that we can restore the object with it when needed. Memento
    is a design pattern that can help us implement a solution for such situations.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Memento design pattern has three key components:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Memento**: A simple object that contains basic state storage and retrieval
    capabilities'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Originator**: An object that gets and sets values of Memento instances'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caretaker**: An object that can store and retrieve all previously created
    Memento instances'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Memento shares many similarities with the Command pattern.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The Memento pattern can be seen in many situations in real life.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: An example could be found in the dictionary we use for a language, such as English
    or French. The dictionary is regularly updated through the work of academic experts,
    with new words being added and other words becoming obsolete. Spoken and written
    languages evolve, and the official dictionary has to reflect that. From time to
    time, we revisit a previous edition to get an understanding of how the language
    was used at some point in the past. This could also be needed simply because information
    can be lost after a long period of time, and to find it, you may need to look
    into old editions. This can be useful for understanding something in a particular
    field. Someone doing research could use an old dictionary or go to the archives
    to find information about some words and expressions.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This example can be extended to other written material, such as books and newspapers.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Zope** ([http://www.zope.org](http://www.zope.org)), with its integrated
    object database called **Zope Object Database** (**ZODB**), offers a good software
    example of the Memento pattern. It is famous for its **Through-The-Web** object
    management interface, with undo support, for website administrators. ZODB is an
    object database for Python and is in heavy use in the Pyramid and Plone stacks
    among others.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Use cases for the Memento pattern
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Memento is usually used when you need to provide some sort of undo and redo
    capability for your users.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Another usage is the implementation of a UI dialog with OK/Cancel buttons, where
    we would store the state of the object on load, and if the user chooses to cancel,
    we would restore the initial state of the object.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing the Memento pattern
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We will approach the implementation of Memento, in a simplified way, and by
    doing things in a natural way for the Python language. This means we do not necessarily
    need several classes.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: One thing we will use is Python’s `pickle` module. What is `pickle` used for?
    According to the module’s documentation ([https://docs.python.org/3/library/pickle.html](https://docs.python.org/3/library/pickle.html)),
    the `pickle` module can transform a complex object into a byte stream, and it
    can transform the byte stream into an object with the same internal structure.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The `pickle` module is used here for the sake of our demonstration, but you
    should know that it is not secure for generic usage.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s take a `Quote` class, with the `text` and `author` attributes. To create
    memento, we will use a method on that class, `save_state()`, which as the name
    suggests will dump the state of the object, using the `pickle.dumps()` function.
    This creates memento:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'That state can be restored later. For that, we add the `restore_state()` method,
    making use of the `pickle.loads()` function:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s also add the `__str__` method:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the main function, we can take care of things and test our implementation,
    as usual:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the recapitulation of the steps in the example (the `ch05/memento.py`
    file):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We import the `pickle` module.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the `Quote` class.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add the main function where we test the implementation.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s view a sample execution using the `python` `ch05/memento.py` command:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The Iterator pattern
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In programming, we use sequences or collections of objects a lot, particularly
    in algorithms and when writing programs that manipulate data. One can think of
    automation scripts, APIs, data-driven apps, and other domains. In this chapter,
    we are going to see a pattern that is useful whenever we must handle collections
    of objects: the Iterator pattern.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Note, according to the definition given by Wikipedia
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Iterator is a design pattern in which an iterator is used to traverse a container
    and access the container’s elements. The iterator pattern decouples algorithms
    from containers; in some cases, algorithms are necessarily container-specific
    and thus cannot* *be decoupled.*'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The Iterator pattern is extensively used in the Python context. As we will see,
    this translates into Iterator being a language feature. It is so useful that the
    language developers decided to make it a feature.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Use cases for the Iterator pattern
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It is a good idea to use the Iterator pattern whenever you want one or several
    of the following behaviors:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Make it easy to navigate through a collection
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the next object in the collection at any point
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop when you are done traversing through the collection
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Iterator pattern
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Iterator is implemented in Python for us, within for loops, list comprehensions,
    and so on. Iterator in Python is simply an object that can be iterated upon; an
    object that will return data, one element at a time.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can do our own implementation for special cases, using the Iterator protocol,
    meaning that our iterator object must implement two special methods: `__iter__()`
    and `__next__()`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: An object is called iterable if we can get an iterator from it. Most of the
    built-in containers in Python (list, tuple, set, string, and so on) are iterable.
    The `iter()` function (which in turn calls the `__iter__()` method) returns an
    iterator from them.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s consider a football team we want to implement with the help of the `FootballTeam`
    class. If we want to make an iterator out of it, we have to implement the Iterator
    protocol, since it is not a built-in container type such as the list type. Basically,
    built-in `iter()` and `next()` functions would not work on it unless they are
    added to the implementation.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we define the class of the iterator, `FootballTeamIterator`, that will
    be used to iterate through the football team object. The `members` attribute allows
    us to initialize the iterator object with our container object (which will be
    a `FootballTeam` instance). We add a `__iter__()` method to it, which would return
    the object itself, and a `__next__()` method to return the next person from the
    team at each call until we reach the last person. These will allow looping over
    the members of the football team via the iterator. The whole code for the `FootballTeamIterator`
    class is as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now for the `FootballTeam` class itself; the next thing  to do is add a
    `__iter__()` method to it, which will initialize the iterator object that it needs
    (thus using `FootballTeamIterator(self.members)`) and return it:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a small main function to test our implementation. Once we have a `FootballTeam`
    instance, we call the `iter()` function on it to create the iterator, and we loop
    through it using a `while` loop:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a recap of the steps in our example (the `ch05/iterator.py` file):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We define the class for the iterator.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the container class.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define our main function followed by the snippet to call it.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the output we get when executing the `python` `ch05/iterator.py` command:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'def generate_banner(msg, style):'
  prefs: []
  type: TYPE_NORMAL
- en: print("-- start of banner --")
  prefs: []
  type: TYPE_NORMAL
- en: print(style(msg))
  prefs: []
  type: TYPE_NORMAL
- en: print("-- end of banner --nn")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'def dots_style(msg):'
  prefs: []
  type: TYPE_NORMAL
- en: msg = msg.capitalize()
  prefs: []
  type: TYPE_NORMAL
- en: ten_dots = "." * 10
  prefs: []
  type: TYPE_NORMAL
- en: msg = f"{ten_dots}{msg}{ten_dots}"
  prefs: []
  type: TYPE_NORMAL
- en: return msg
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'def admire_style(msg):'
  prefs: []
  type: TYPE_NORMAL
- en: msg = msg.upper()
  prefs: []
  type: TYPE_NORMAL
- en: return "!".join(msg)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'def cow_style(msg):'
  prefs: []
  type: TYPE_NORMAL
- en: msg = cow.milk_random_cow(msg)
  prefs: []
  type: TYPE_NORMAL
- en: return msg
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: styles = (dots_style, admire_style, cow_style)
  prefs: []
  type: TYPE_NORMAL
- en: msg = "happy coding"
  prefs: []
  type: TYPE_NORMAL
- en: '[generate_banner(msg, style) for style in styles]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Part 3: Beyond the Gang of Four'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part goes beyond the classic design patterns to help you address special
    software design needs such as microservices, cloud-based applications, and performance
    optimization. It also discusses patterns for testing and specific Python anti-patterns
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21896_06.xhtml#_idTextAnchor163), *Architectural Design Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21896_07.xhtml#_idTextAnchor191), *Concurrency and Asynchronous
    Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21896_08.xhtml#_idTextAnchor216), *Performance Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21896_09.xhtml#_idTextAnchor233), *Distributed Systems Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B21896_10.xhtml#_idTextAnchor256), *Patterns for Testing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21896_11.xhtml#_idTextAnchor273), *Python Anti-Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
