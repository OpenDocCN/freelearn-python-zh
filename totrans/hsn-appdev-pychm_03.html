<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-53"><a id="_idTextAnchor052"/>3</h1>
<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Customizing Interpreters and Virtual Environments</h1>
<p>The last chapter focused on configuration options. Configuration options are designed to help you customize your working environment to fit the project and also allow for customization to fit your personal tastes. These options are one of the many reasons that PyCharm is a great tool. Another great feature that makes PyCharm useful is the customization of interpreters and virtual environments.</p>
<p> This chapter will cover the following topics:</p>
<ul>
<li>The importance of working with virtual environments in Python</li>
<li>How to create a virtual environment manually using <code>virtualenv</code></li>
<li>How to create a virtual environment using PyCharm</li>
<li>How to work with an existing virtual environment in PyCharm</li>
<li>How to add and remove third-party libraries using PyCharm</li>
<li>How to import projects created outside PyCharm</li>
<li>How to work with virtual environment settings within run configurations</li>
</ul>
<p>At this point, many of you will have at least one installation of a Python interpreter installed. It either came with your system, as is the case with macOS or Linux, or you installed it, as is the case with Windows. Python is an <strong class="bold">interpreted language</strong>—this means the written code is not truly evaluated until it is run. Let’s take a moment to describe what this means by comparing Python to a few other languages and how they are executed.</p>
<p>There are three common ways to execute written code on your computer, as follows:</p>
<ul>
<li>Compilation</li>
<li>Interpretation</li>
<li>Intermediate compilation with a runtime</li>
</ul>
<p>Before we dig into these, let’s take a short trip back through time. I know it is history but stick with me. In the year 1522, the predominant religion throughout most of Western Europe was Roman Catholicism. This was a time of great turmoil in that church’s history, but we will put that aside for a moment. Instead, we will focus on a German priest named Martin Luther. In those days, the German people were completely reliant on the clerical establishment for their spiritual needs. The Bible, in 1522, was only available in Greek and Latin. Luther, who was imprisoned at the time, translated the  Old Testament from Greek into the German Vulgate. This was a game changer for the Germans. Printers of the day snatched it up and printed hundreds of copies so that every family could read it. I’m going to use this as an analogy.</p>
<p>The first method of executing written code is <em class="italic">compilation</em>. This is similar to Martin Luther’s translation from Greek into German. Most people who cannot code will see a programming language and scratch their heads and think to themselves: “This is Greek to me!” The same thing is happening with computers because the computer can’t understand your code language either. Computers don’t “speak” C or C++ or Java. Instead, a programmer has written something in a language that is simple and easy to translate as compared to human language. Compilation refers to a process where your textual code files are translated once into a binary format that is understood by the computer. Examples of compiled languages include C and C++. The code files are run through a compiler, which translates the code into a separate and new format only one time. The process produces a new file, separate from the code, which is useful only to the computer. To finalize our analogy, after translating Greek into German, the printed books became the result of the compilation step. The ability to read the Bible was useful to the Germans.</p>
<p>Contrast that with the second form of code execution: the <em class="italic">interpreted language</em>. Prior to Luther’s translation, the Bible was translated on the fly in church. A priest would open the Bible and translate the text into German as he read it aloud. This is what happens with interpreted languages, including Python. The <code>python main.py</code>, the Python interpreter opens the code file, reads the code, translates (compiles) that code, and executes the instructions as it reads them line by line.</p>
<p>This might be an oversimplification for those of you deeply familiar with compiler theory, but for most of us, the analogy holds. Python does some extra work during the process by way of caching and optimizing some of the translation so that it can be used again. By and large, each run of the program presents a new interpretation. Examples of interpreted languages include Python, JavaScript, and Lua.</p>
<p>The last category of code execution involves a middle ground between the other two. Languages such as C# and Java use a <em class="italic">compilation</em> step. Unlike regular compilers, the result isn’t a file that runs by itself on the bare metal of your computer. Instead, it produces an intermediate format that can be read by a <strong class="bold">runtime</strong>.</p>
<p>Think back to when you were in school. A common practice is for a professor or teacher to lecture the class and for the class to take notes. A good student can reproduce the lecture’s content from the notes. Those notes are an abbreviated form of the lecture. In this analogy, the teacher is the programmer and the student is the intermediate compiler. The output of the compiler, hopefully, is a stellar set of notes that will allow the student to get a good grade on the test. Your code files (the lecture) are translated into a compact, binary version of the code (your notes). When that intermediate file is executed, a runtime essentially “looks at the notes” and enables that code to run on the computer. The upside to this method is that the intermediate compilation can run on a variety of platforms without having to be recompiled. Programs written in C will run on a variety of platforms, ranging from Intel and ARM to old platforms such as mainframes. To accomplish this, however, you must recompile the program on that platform. The executables only run on the platform that compiles them. In the runtime system, the runtime is translated and made to run on different platforms. The intermediate compilation then runs on any platform that supports the runtime. You can compile once and distribute anywhere.</p>
<p>Python, for our purposes, is an interpreted language, and we need an interpreter. Furthermore, PyCharm needs to know a little bit about the interpreter. This chapter is all about the means by which you can make introductions. PyCharm, meet interpreter. Interpreter, meet PyCharm.</p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/>Technical requirements</h1>
<p>In order to proceed through this chapter, and indeed the rest of the book, you will need the following:</p>
<ul>
<li>An installed and working Python interpreter. I’ll be using the latest from <a href="https://python.org">https://python.org</a>.</li>
<li>Installed copies of <code>pip</code> and <code>virtualenv</code>. You get these automatically when you install Python on Windows, and macOS has them included on every system. If you are using Linux, you need to install package managers, such as <code>pip</code>, and virtual environment tools, such as <code>virtualenv</code>, separately. Our examples will use <code>pip</code> and <code>virtualenv</code>.</li>
<li>An installed and working copy of PyCharm. Installation was covered in <a href="B19644_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">Installation and Configuration</em>, in case you are jumping into the middle of the book.</li>
<li>This book’s sample source code from GitHub. We covered cloning the code in <a href="B19644_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">Installation and Configuration</em>. You’ll find this chapter’s relevant code at <a href="https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-03">https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-03</a>.</li>
</ul>
<p>There are several flavors of Python. I have used and referenced Python 3 from <a href="https://www.python.org">https://www.python.org</a>. Remember—because it is an open source project, it is possible to create an alternative version of Python. This has been done many times with varying degrees of success. Some of these variants include the following:</p>
<ul>
<li><code>numpy</code>, <code>matplotlib</code>, and <code>pandas</code> included in the installation. The downside is the amount of space on your drives consumed by this bigger installation, but given the price of storage these days, it is likely not much of a consideration. These libraries are probably the most important variant to consider if you intend to do data science work.</li>
<li><strong class="bold">IronPython</strong>—This is a variant of Python designed to run in the Microsoft .NET runtime. The implications of that <a id="_idIndexMarker192"/>are beyond the scope of this book. However, IronPython is interesting because, in addition to running in a .NET environment, this<a id="_idIndexMarker193"/> implementation isn’t hobbled by a <strong class="bold">global interpreter lock</strong> (<strong class="bold">GIL</strong>). GILs prevent efficient multithreading in your code. If you’re not aware of this limitation in Python, I’ll leave a link in the <em class="italic">Further reading</em> section of this chapter.</li>
<li><strong class="bold">Jython</strong>—This variant allows <a id="_idIndexMarker194"/>your Python code to <a id="_idIndexMarker195"/>execute within a <strong class="bold">Java Virtual </strong><strong class="bold">Machine</strong> (<strong class="bold">JVM</strong>).</li>
<li><strong class="bold">MicroPython</strong>—This variant is used to run Python<a id="_idIndexMarker196"/> code with microcontrollers <a id="_idIndexMarker197"/>for use in the <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) and potentially embedded projects.</li>
<li><strong class="bold">ActiveState ActivePython</strong>—This is a <a id="_idIndexMarker198"/>commercially supported implementation of Python, with special attention paid to Windows compatibility and execution. Traditionally, Python was designed with the assumption that it would be running in Unix or Linux environments. If you intend to run your Python code in production on a Windows server, you might consider this variant.</li>
</ul>
<p>You’ll find these documented officially at <a href="https://www.python.org/download/alternatives/">https://www.python.org/download/alternatives/</a>. While any of these variants should work in PyCharm, most developers using the IDE are working in vanilla Python (the one from <a href="http://python.org">python.org</a>) or Anaconda. As you work with virtual environments in Python, you will undoubtedly see different options for these alternative implementations. In general, I always use the vanilla version of Python 3.</p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Virtual environments</h1>
<p>We oriented ourselves with respect to project creation in <a href="B19644_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">Installation and Configuration</em>; however, we glossed over the details around creating or setting up a <code>matplotlib</code>, only runs in Python 3.6 on your Mac, but in Windows, it’s stable at Python 3.9. While that project is going on, another project starts that requires Python 3.10.</p>
<p>If you were strictly working <a id="_idIndexMarker200"/>with the global or system-wide installations of Python, it would be very hard to switch back and forth between those two projects. You would have to futz with environment variables and fix your computer’s <code>PATH</code> environment variable. Then, you would have to try to remember which third-party libraries are installed globally and hope there isn’t a clash between those library requirements for the separate projects. Yuck.</p>
<p>Virtual environments allow you to manage these problems easily. While using them is purely optional, it is considered a best practice to create a virtual environment for every project. Before we dive back into PyCharm, I thought it would be fun to create a virtual environment manually. You can skip this if you’d like, but if you haven’t done this before, I think it will give you an appreciation for some of the work PyCharm takes off your plate at the onset of a new project.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Creating a virtual environment by hand</h2>
<p>Open up your computer’s terminal and<a id="_idIndexMarker201"/> find a spot on your drive where you can do a little temporary work. We won’t be keeping this for later; we’re just going to go through the process. We will then switch to PyCharm so that we can see a more automated version of the same workflow.</p>
<p>I’m running Windows, and I have a place in my home folder where I keep my projects; a folder simply called <em class="italic">Projects</em>. Having opened my computer’s terminal program, which in this case is <strong class="bold">Windows Terminal</strong> running <strong class="bold">PowerShell</strong>, I can type the commands for this experiment. You do not have to use Windows, nor do you have to use PowerShell. The normal <strong class="bold">zshell</strong> (<strong class="bold">zsh</strong>) terminal <a id="_idIndexMarker202"/>prompt in macOS or the <strong class="bold">Bourne Again Shell </strong>(<strong class="bold">Bash</strong>) prompt in<a id="_idIndexMarker203"/> Linux works the same. Most of the commands are identical in all terminals and operating systems. I’ll start by creating a new folder, as follows:</p>
<pre class="source-code">
<code>mkdir python-environment-demo</code></pre> <p>This creates a new folder called <code>python-environment-demo</code>. Next, I need to change directory (<code>cd</code>) into it, like so:</p>
<pre class="source-code">
cd python-environment-demo</pre> <p>Now I’m inside that folder, I’ll create my virtual environment. If you are using macOS or Linux, there’s a good chance you have both Python 2 and 3 installed, and we want to be sure to make a virtual environment based on Python 3. In order to differentiate, you need to type the following:</p>
<pre class="source-code">
python3 -m venv venv</pre> <p>If you’re on Windows, you<a id="_idIndexMarker204"/> probably only have Python 3 installed, so the command is this:</p>
<pre class="source-code">
python -m venv venv</pre> <p>Here, we’re running the <code>python3</code> command, and we’re passing a switch (<code>-m</code>) that will execute the <code>venv</code> package to create a new virtual environment based on Python 3 within a new folder called <code>venv</code>. Once the command finishes, I can make sure it worked on Windows with this:</p>
<pre class="source-code">
dir</pre> <p>Or on macOS/Linux, I can use this:</p>
<pre class="source-code">
ls -a</pre> <p>You should see your system’s output. I’m using Windows, so mine appears as seen in <em class="italic">Figure 3</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 3.1: Terminal output checking whether my virtual environment creation was successful" src="img/B19644_03_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: Terminal output checking whether my virtual environment creation was successful</p>
<p>It isn’t necessary for your virtual environment to be in the same folder as the rest of your project, but I usually organize things this way to make the virtual environment easy to find later.</p>
<p>If I intend to use Git or <a id="_idIndexMarker205"/>some other revision control system, it would be appropriate for me to have the revision control system ignore this folder. You should <em class="italic">not</em> check this folder into your repository.</p>
<p>The final step in working with a virtual environment is to activate it. The command is a little different in Windows compared to macOS and Linux. The command to activate a virtual environment in Windows is this:</p>
<pre class="source-code">
.\venv\Scripts\activate</pre> <p>While in macOS and Linux, it would be this:</p>
<pre class="source-code">
source ./venv/bin/activate</pre> <p>If you successfully activated your virtual environment, the prompt should have changed to display the name of the virtual environment that is currently active. Bear in mind that if you have customized your terminal to prevent this, it might not work. You can see in <em class="italic">Figure 3</em><em class="italic">.2</em> that everything worked for me, as indicated by <code>(venv)</code> appearing at the front of my prompt. The top example shows activation in Windows 11, while the lower example shows the activation <a id="_idIndexMarker206"/>command in Linux, which is the same as it would be in macOS:</p>
<div><div><img alt="Figure 3.2: My virtual environment has been activated" src="img/B19644_03_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2: My virtual environment has been activated</p>
<p>When I’m ready to stop working in my virtual environment, I can deactivate it by typing the following command in the terminal:</p>
<pre class="source-code">
deactivate</pre> <p>That was a little bit of work. If you’ve been doing this for a while, it isn’t too bad—maybe just a few minutes. However, if you do not do this very often, you will have to look everything up, and this may take time. You really only do this at the beginning of a new project. Some people might only do this a few times per year. Now, let’s go back to PyCharm and see how this step is integrated into the new project creation workflow.</p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Creating a project in PyCharm (revisited)</h1>
<p>If we go back to<a id="_idIndexMarker207"/> PyCharm and create a new pure Python project, you’ll see where the <a id="_idIndexMarker208"/>process of creating a virtual environment happens. In PyCharm, let’s create a new project by clicking <strong class="bold">File</strong> | <strong class="bold">New Project…</strong>, as seen in <em class="italic">Figure 3</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 3.3: Creating a new project in PyCharm" src="img/B19644_03_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: Creating a new project in PyCharm</p>
<p>This will be a pure Python project. The Professional edition is not necessary to follow along. The new project dialog<a id="_idIndexMarker209"/> is something we saw before in <a href="B19644_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">Installation and Configuration</em>, but this time <a id="_idIndexMarker210"/>we will focus on some of the details we skipped. <em class="italic">Figure 3</em><em class="italic">.4</em> shows the Professional edition of PyCharm’s new project window on the left. PyCharm Community lacks the project type menu since it can only create “pure Python” projects:</p>
<div><div><img alt="Figure 3.4: A side-by-side comparison of the New Project window for the Professional edition (left) and the Community edition (right)" src="img/B19644_03_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4: A side-by-side comparison of the New Project window for the Professional edition (left) and the Community edition (right)</p>
<p>The section of the <strong class="bold">New Project</strong> dialog I’d like <a id="_idIndexMarker211"/>you to focus on is highlighted in <em class="italic">Figure 3</em><em class="italic">.5</em>. It is this section of the screen that allows you to set up your virtual <a id="_idIndexMarker212"/>environment. In <a href="B19644_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">Installation and Configuration</em>, we breezed right past this and just accepted the defaults. As it happens, the defaults nearly match the manual process we completed in the last section:</p>
<div><div><img alt="Figure 3.5: The virtual environment settings from PyCharm enumerated for explanation" src="img/B19644_03_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5: The virtual environment settings from PyCharm enumerated for explanation</p>
<p>Let’s consider the<a id="_idIndexMarker213"/> numbered labels in <em class="italic">Figure 3</em><em class="italic">.5</em>:</p>
<ol>
<li>This is the Python interpreter settings section of the <strong class="bold">New Project</strong> window. You can hide it if you like by twirling the triangle next to the section label, though if we did that, we wouldn't be able to continue talking about what comes next.</li>
<li>There are two <a id="_idIndexMarker214"/>options at play here. You can either create a new virtual environment or point to one you’ve already created. Let’s focus on creating a new one. The <code>virtualenv</code> virtual environment feature. Changing the mechanism using the dropdown will change the contents of the screen to match the settings for the virtual environment script you pick. For now, let’s leave it on <strong class="bold">Virtualenv </strong>since that is the oldest and likely the most widely used.</li>
<li>The <code>venv</code> within the folder for the project. You can set the location anywhere on your computer; it doesn’t have to be in the project folder. If you have several projects that share a virtual environment because they share<a id="_idIndexMarker215"/> dependencies, it makes sense to create a central location to hold the environment. Most of the time, I prefer to keep the virtual<a id="_idIndexMarker216"/> environment in the same folder as the project so that there is no question as to its location.</li>
<li>The <strong class="bold">Base interpreter</strong> field lets you choose which Python installation will be used to create the virtual environment. If you have more than one Python installation on your computer, PyCharm was probably able to find it automatically. The selection is presented as a drop-down list of the locations where PyCharm found a Python installation. If it somehow missed one, you can click the ellipsis button (<strong class="bold">…</strong>) and navigate to the Python installation you’re interested in using. If you do this, you need to navigate all the way to the Python executable and double-click it.</li>
<li>The <strong class="bold">Inherit global site-packages</strong> checkbox deals with any third-party libraries you might have installed globally. Checking this box will copy those into your virtual environment so that they are available locally in your project.</li>
<li>The <strong class="bold">Make available to all projects</strong> checkbox allows you to easily find and reuse this virtual environment in other projects.</li>
</ol>
<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>Using an existing virtual environment</h1>
<p>Sometimes, you need to make <a id="_idIndexMarker217"/>a project with the exact same requirements used in another project. You can share or reuse a virtual environment easily in PyCharm. <em class="italic">Figure 3</em><em class="italic">.5</em> shows the <strong class="bold">New Project</strong> dialog in PyCharm.</p>
<p>To use an existing virtual environment, you’d need to change the default setting from <strong class="bold">New environment </strong>using to <strong class="bold">Previously configured interpreter</strong>, as seen in <em class="italic">Figure 3</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 3.6: You can point your project to an existing virtual environment by changing the setting for the project" src="img/B19644_03_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6: You can point your project to an existing virtual environment by changing the setting for the project</p>
<p>Once you do that, your options for selecting an existing environment become active. There is a drop-down list available to pick the interpreter. It works the same as the <strong class="bold">Base interpreter</strong> dropdown we saw earlier when creating a new virtual environment. If you created the existing<a id="_idIndexMarker218"/> environment in PyCharm, the IDE would remember it. In this case, I previously created a virtual environment using PyCharm when I created the demo project code for <a href="B19644_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to PyCharm – The Most Popular IDE for Python</em>. PyCharm will remember virtual environments created using PyCharm and will offer them in the list.</p>
<p>If you used a manual method or some other tool, you’ll need to add the interpreter to the list using the <strong class="bold">Add Interpreter</strong> button. When you click the button, you’ll notice some possibilities, as seen in <em class="italic">Figure 3</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 3.7: When you click Add Interpreter, you have a myriad of options for the origin of the environment you might want to add" src="img/B19644_03_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7: When you click Add Interpreter, you have a myriad of options for the origin of the environment you might want to add</p>
<p>So far, we’re strictly limiting <a id="_idIndexMarker219"/>our discussion to adding a virtual environment that exists on your local computer. It is possible to add an environment on a<a id="_idIndexMarker220"/> remote computer, <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>), <strong class="bold">Windows Subsystem for Linux</strong> (<strong class="bold">WSL</strong>, which is a VM), or a <strong class="bold">Docker</strong> container. We’re going to talk about those options much later in the book.</p>
<p>Once you select <code>bin</code> folder containing the Python executable. In Windows, the virtual environment has a <code>Scripts</code> folder that will contain a file that points to the Python executable. Your goal in any case is to select the executable:</p>
<div><div><img alt="Figure 3.8: You need to select the Python executable within the virtual environment folder you’d like to use" src="img/B19644_03_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8: You need to select the Python executable within the virtual environment folder you’d like to use</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Changing the interpreter for a project</h1>
<p>One trick I employ when I’m <a id="_idIndexMarker221"/>working on a project that’s been ongoing for 6 months or longer is to create a new virtual environment with fully updated packages. This way, I can test the program with updated dependencies without corrupting my production-ready virtual environment. We’ll cover package management a little later in this chapter. For now, I want to show you where the setting for your project’s interpreter exists independently of the project creation process. I find this to be a little bit non-intuitive. It’s in <strong class="bold">Settings</strong>. The same <strong class="bold">Settings</strong> option you use to configure the IDE globally across all projects is used to set project-specific settings such as the interpreter settings.</p>
<p>Regardless of your reason, it is possible to change the interpreter, and by extension the virtual environment used in your project. You’ll find the project settings by clicking the gear icon in the top-left corner of the UI, as seen in <em class="italic">Figure 3</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 3.9: You’ll find global and project settings by clicking the gear" src="img/B19644_03_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9: You’ll find global and project settings by clicking the gear</p>
<p>Once you select <strong class="bold">Settings</strong>, you’ll be taken to<a id="_idIndexMarker222"/> the global settings screen we studied in <a href="B19644_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">Installation and Configuration</em>. Project properties are also stored here, as shown in <em class="italic">Figure 3</em><em class="italic">.10</em>:</p>
<div><div><img alt="Figure 3.10: The project settings are in the middle of the list" src="img/B19644_03_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10: The project settings are in the middle of the list</p>
<p>Select the interpreter settings<a id="_idIndexMarker223"/> on the left side of the screen and change the interpreter using the same mechanism we used when we set the virtual environment the first time. You can create a new environment or browse to a new one. Don’t forget that when you browse to a new environment, you need to select the Python executable and not the folder where the Python installation is located. I forget this sometimes, and I’m left wondering why the selection dialog won’t go away. It’s looking for a file, which is the Python executable, not a folder.</p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor060"/>Activating virtualenv</h1>
<p>In our manual exercise earlier in this<a id="_idIndexMarker224"/> chapter, we created a virtual environment from scratch using <code>virtualenv</code>. Once the environment is created, you must activate it in order to use it. An obvious question might be “<em class="italic">How do I activate the environment?</em>” Here’s the beautiful answer: you don’t have to. While you are in the IDE, the <a id="_idIndexMarker225"/>environment settings are always there and are always honored. When you add new third-party packages from the <strong class="bold">Python Package Index</strong> (<strong class="bold">PyPI</strong>), which we’ll cover shortly, they automatically go to the right place per your environment settings.</p>
<p>When we run our program, we can override the <strong class="bold">run configuration</strong>, but by default, it uses the project’s environment setting. Frankly, it’s rare that the override in the run configuration is useful. With<a id="_idIndexMarker226"/> that said, I’ll show you how to override the run configuration later in this chapter.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Using the integrated terminal</h2>
<p>Another place to worry about the virtual environment being active is within the <strong class="bold">terminal</strong>. It’s true PyCharm can’t help you with your system terminal. However, PyCharm does have its own <a id="_idIndexMarker227"/>terminal window tab. If you use PyCharm’s terminal, the project’s interpreter settings are automatically applied. You will not have to manually activate anything. Since we are talking about it, let’s look at the integrated terminal in PyCharm. You can find the menu item for showing the terminal in the <strong class="bold">View</strong> menu, as seen in <em class="italic">Figure 3</em><em class="italic">.11</em>. Personally, I spend a lot of time in the terminal, so I have committed the keyboard shortcut to muscle memory:</p>
<div><div><img alt="Figure 3.11: PyCharm’s integrated terminal can be found buried within the View menu" src="img/B19644_03_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11: PyCharm’s integrated terminal can be found buried within the View menu</p>
<p>Invoking the menu option brings up the terminal and, as promised, you can see in <em class="italic">Figure 3</em><em class="italic">.12</em> it honors our project’s virtual environment setting:</p>
<div><div><img alt="Figure 3.12: You can see the terminal comes up with your virtual environment already active" src="img/B19644_03_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12: You can see the terminal comes up with your virtual environment already active</p>
<p>If the presence of <code>(venv)</code> in the <a id="_idIndexMarker228"/>prompt isn’t proof enough that it worked, I provided more in <em class="italic">Figure 3</em><em class="italic">.12</em>. If you use macOS or Linux, you can use the <code>which</code> command to find the path to any executable. Sorry, Windows users: there isn’t an equivalent command on your OS. The result of the <code>which</code> command is that it shows when I run <code>python3</code> it is using the one at the indicated path, rather than the system-wide installation, which is usually at <code>/usr/bin/python3</code>.</p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Working with the REPL in the console window</h2>
<p>One final tool in PyCharm that <a id="_idIndexMarker229"/>might cause you to wonder whether or not your environment settings are being honored is the <code>python3</code> by itself. PyCharm gives you an integrated tool so that you don’t have to. To get to the console, use the same menu you used to get to the terminal. I’ve shown it to you in <em class="italic">Figure 3</em><em class="italic">.13</em>:</p>
<div><div><img alt="Figure 3.13: The Python console can be invoked via the View menu" src="img/B19644_03_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13: The Python console can be invoked via the View menu</p>
<p>Your console is not only<a id="_idIndexMarker232"/> aware of your interpreter settings, but it is also aware of the contents of your project. You can import and test anything in your project directly in the console. I find this useful when I’m tracking down the dreaded “<em class="italic">Module not found? Whaddya mean it’s not found?! It’s right there! I’m looking right at it!</em>” issues we sometimes face. It is also useful for experimenting with some of the terser<a id="_idIndexMarker233"/> syntax we find in Python, such as <strong class="bold">regular expressions</strong> (<strong class="bold">regexes</strong>) or list comprehensions. There’s a small example in <em class="italic">Figure 3</em><em class="italic">.14</em>:</p>
<div><div><img alt="Figure 3.14: The console window in use to test a simple regex" src="img/B19644_03_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14: The console window in use to test a simple regex</p>
<p>The code I’m trying out in <em class="italic">Figure 3</em><em class="italic">.14</em> isn’t going to impress anyone in my big Python interview with Google:</p>
<pre class="source-code">
import re
title = "Hands on Application Development with PyCharm"
test = re.search("Hands", title)</pre> <p>I type each line into the console. Remember—this is a live coding view, not a file that you execute. Every time I press <em class="italic">Enter</em>, the expression I just typed is evaluated, and the results appear in the <a id="_idIndexMarker234"/>debug-like window on the right side when appropriate. Think of it like a debugging session where you have a watch window on the right, and everything you type in next to the <code>&gt;&gt;&gt;</code> prompt becomes an instant breakpoint.</p>
<p>Having pressed <em class="italic">Enter</em> to evaluate the third line, I can see that the <code>test</code> variable has a <code>re.Match</code> object as its value. Stare at the window a little longer, and you can see the characters were found at position (0, 5), or characters 0 through 5 represented in a single tuple (<code>regs</code>).</p>
<p>Trying out complicated bits of code in the console saves a little bit of time versus the usual process comprised of running the program, reading <code>print</code> statements, making a change, and trying again, which eats up most of our days as developers. Then, you forget to take out the print statements, and you should because they can seriously slow down a long-running script.</p>
<p>The console executes everything instantly and feeds the results back to you. It is far more detailed than a print <a id="_idIndexMarker235"/>statement because you can see the internals of any object using the debug-like window, rather than just seeing a string. After some tinkering in the console window, you can go back to your code and just use what worked.</p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/>Working with third-party package libraries</h1>
<p>Python is famous for<a id="_idIndexMarker236"/> its “batteries included” philosophy, which is at odds with many other languages. Python’s creator, Guido van Rossum, believes a robust and complete standard library is important and that the language ought to be able to complete nearly any task without using any third-party dependencies.</p>
<p>By third-party dependencies, I mean libraries external to Python designed to perform a specialized functionality that is not implemented in Python “out of the box.” In other words, Python sets for itself a very lofty goal. It should be able to do literally anything all by itself using what is called the Python standard library.</p>
<p>Naturally, this goal can never be fully realized. The Python standard library is very complete. Eventually, though, you’ll find something the standard library either can’t do or the standard library’s implementation isn’t as easy to use as it could be. Let’s look at a couple of quick examples of third-party libraries that are widely used, and talk about why you might want to use them.</p>
<p>Let’s start with the <code>requests</code> library. This is a third-party library you’ll find on PyPI at <a href="https://pypi.org/project/requests/">https://pypi.org/project/requests/</a>. Every modern language has something similar. JavaScript has<a id="_idIndexMarker237"/> the <strong class="bold">Node Package Manager</strong> (<strong class="bold">NPM</strong>) at <a href="https://npmjs.com">https://npmjs.com</a>. <strong class="bold">PHP</strong> uses <strong class="bold">Composer</strong> to install packages from <a href="https://packagist.org/">https://packagist.org/</a>. The .NET languages use <strong class="bold">NuGet</strong> with packages registered at <a href="https://nuget.org">https://nuget.org</a>. Python has <a href="https://pypi.org">https://pypi.org</a>. It is a centralized listing of third-party modules and libraries you can add to your project, often free of charge. Metaphorically speaking, the idea is to prevent us from having to reinvent the wheel every time we want to <a id="_idIndexMarker238"/>build a new car. Since I work on a <strong class="bold">software-as-a-service</strong> (<strong class="bold">SaaS</strong>) project as my <a id="_idIndexMarker239"/>day job, I find myself needing an easy way to make <strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) requests. The ability for my Python scripts to be able to make a call to some web service and process the results is crucial, and it is a very common task.</p>
<p>Python’s standard library has a few options for accomplishing this. I think the most obvious is <code>urllib</code> from the standard library. Here is some example code from the <code>urllib2</code> documentation at <a href="https://docs.python.org/3/howto/urllib2.html">https://docs.python.org/3/howto/urllib2.html</a>:</p>
<pre class="source-code">
import urllib.parse
import urllib.request
url = 'http://www.someserver.com/cgi-bin/register.cgi'
values = {'name' : 'Michael Ford',
     'location' : 'Northampton',
     'language' : 'Python' }
data = urllib.parse.urlencode(values)
data = data.encode('ascii') # data should be bytes
req = urllib.request.Request(url, data)
with urllib.request.urlopen(req) as response:
  the_page = response.read()</pre> <p>First, we import two parts of the <code>urllib</code> package, remembering that is really <code>urllib2</code>. Next, we create a <code>url</code> variable. If you’re wondering what the references to <code>cgi</code> are in the sample, that’s a <code>cgi-bin</code> within the address. This style of development was supplanted long ago by the likes of <strong class="bold">PHP</strong>, classic <strong class="bold">Active Server Pages</strong> (<strong class="bold">ASP</strong>), <strong class="bold">Java ServerPages</strong> (<strong class="bold">JSP</strong>), and <a id="_idIndexMarker242"/>ColdFusion. Even those have since evolved into modern systems that use more sophisticated yet easier-to-code implementations of routing libraries that are very flexible. We’ll cover these later in the book when we talk about the web application development features in PyCharm Professional.</p>
<p>Once we have our <code>url</code> variable established, we need some data. In this example, we are using HTTP <code>POST</code> to send data to our web server for processing. This is done with the <code>values</code> variable, which contains a dictionary that <a id="_idIndexMarker243"/>mimics the fields and values you might find in a <strong class="bold">Hypertext Markup Language</strong> (<strong class="bold">HTML</strong>) form.</p>
<p>Once we’ve set that up, we must parse that dictionary into a format suitable for transmission. That is done with <code>urllib.parse.urlencode</code>. Next, we need to further encode the data as <strong class="bold">American Standard Code for Information Interchange</strong> (<strong class="bold">ASCII</strong>). This is another anachronism in the documentation. Modern systems use the 8-bit universal text format (UTF-8) since ASCII only encodes letters from Romance languages such as <a id="_idIndexMarker244"/>English, French, German, Italian, or Portuguese. The rest of the world is out of luck. UTF-8 handles every alphabet in common global use today; this way, only the ancient Egyptians are snubbed, since UTF-8 doesn’t support hieroglyphics —at least, not that I know of.</p>
<p>After we encode the text, we need to create a <code>request</code> object. We pass in our <code>url</code> variable and data to the constructor for <code>urllib.request.Request</code>. Only then are we ready to send the request in the last two lines of the sample.</p>
<p>We’ve established there is a way to make a <code>POST</code> request in Python’s standard library. So far, though, we’ve only handled a very basic requirement. What if I need to present a request that is authenticated? How would I deal with sessions or cookies? Could we make this even simpler? We can with the <code>requests</code> library. Here is some sample code:</p>
<pre class="source-code">
import requests
requests.post('https://httpbin.org/post', data={'key':'value'})</pre> <p>Our previous code from <code>urllib</code> could be expressed as a one-liner using <code>requests</code>! More advanced requirements such as sessions, cookies, and so on are equally easy. The documentation is modern and contains useful examples. Popular PyPI libraries such as <code>requests</code> are very well documented, with tutorials on sites such as <a href="https://realpython.com">https://realpython.com</a>. I borrowed the preceding sample from <a href="https://realpython.com/python-requests/">https://realpython.com/python-requests/</a>, which is part of a large and very complete tutorial on using this powerful library.</p>
<p>The point of all this is to point out that a system of third-party code libraries is necessary, or at least useful, in the context of Python—a language that strives to include everything you could ever need, but never will. The standard library may come close, but it will never include everything I could ever want.</p>
<p>Another important example of necessary third-party libraries is with respect to scientific and financial work. The standard math capabilities in Python are about the same as you would find in any other<a id="_idIndexMarker245"/> language. Most languages are not incredibly precise at handling floating-point calculations. They are also not very nuanced at handling matrices of numeric data, which represents a common requirement. Thankfully, third-party libraries such as <code>numpy</code> and <code>pandas</code> exist to fill this void. These libraries open new possibilities to Python developers and are one of the main reasons Python continues to attract new users.</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Adding third-party libraries in PyCharm</h2>
<p>PyCharm includes a <a id="_idIndexMarker246"/>UI screen that allows you to manage the packages in your current project. However, if an IDE were not in use, you could use a package manager to do it manually. For example, to install <code>numpy</code> into your project, you could use the <code>pip</code> package manager with a command such as this:</p>
<pre class="source-code">
pip install numpy</pre> <p>You should make sure you have activated the virtual environment for the project in order for this to work correctly. Otherwise, <code>numpy</code> will be installed globally. The <code>pip</code> installer isn’t the only installer available. There’s <code>easy_install</code>, <code>pipenv</code>, <code>poetry</code>, and of course, <code>conda</code>. I’m not going to debate the relative merits of each since this is a matter of preference. PyCharm supports them all.</p>
<p>PyCharm’s package manager invokes the package manager set in your environment settings. It presents a graphical interface where you can search for packages, view their descriptions, and install, update, and uninstall any package in your project. Let’s take a look.</p>
<p>Going back to PyCharm, let’s return to our project settings. Click on <strong class="bold">Python Interpreter</strong>, as shown in <em class="italic">Figure 3</em><em class="italic">.15</em>:</p>
<div><div><img alt="Figure 3.15: The interpreter settings show not only your interpreter but also a list of packages available to that interpreter" src="img/B19644_03_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15: The interpreter settings show not only your interpreter but also a list of packages available to that interpreter</p>
<p>The screen shows the interpreter in use for the current project. We saw earlier that we can change this environment at any time. Now, we are going to focus on the empty package list that takes up <a id="_idIndexMarker247"/>most of the screen. This is where you will be able to work with packages once we’ve installed them.</p>
<p>Let’s install the <code>numpy</code> package. Start by clicking the <code>numpy</code>. As you type, you will see a list of packages from PyPI that satisfy your search. Click on the <code>numpy</code> entry and view the description. It is a good idea to scrutinize the description since if you misspell your search term, you might wind up with the wrong packages. This is definitely the <code>numpy</code> library, so I’ll install it by clicking the <strong class="bold">Install Package</strong> button at the bottom of the dialog. After a short wait, I’ll see a message, shown in <em class="italic">Figure 3</em><em class="italic">.16</em> (just above the grayed-out <strong class="bold">Install Package</strong> button), stating the package was<a id="_idIndexMarker248"/> successfully installed:</p>
<div><div><img alt="Figure 3.16: The display at the bottom indicates the package was installed successfully" src="img/B19644_03_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16: The display at the bottom indicates the package was installed successfully</p>
<p>Go ahead and close the dialog box to go back to the project settings.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Removing third-party libraries in PyCharm</h2>
<p>Next to the <code>numpy</code> package, we see a few more buttons near the arrow in <em class="italic">Figure 3</em><em class="italic">.17</em>:</p>
<div><div><img alt="Figure 3.17: Tools for managing your package installations" src="img/B19644_03_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17: Tools for managing your package installations</p>
<p>You can likely guess what they do. The <code>pip</code> can be upgraded to version 23.0.1. Clicking the up arrow will accomplish this. The eye button will show you pre-release package versions should you want to try out the bleeding-edge versions of the packages.</p>
<p>Now that we understand what the UI for package management does, I’d like to digress for a moment and talk about something that it does not do well. The present release of PyCharm does not have a good way, in my opinion, to work with a <code>requirements.txt</code> file.</p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Using a requirements.txt file</h2>
<p>A best practice in<a id="_idIndexMarker250"/> using Python projects is to use a file named <code>requirements.txt</code> to list the third-party library dependencies for your project. If you’re starting your project from scratch, you can generate a <code>requirements.txt</code> file using <code>pip</code> in your terminal with this command:</p>
<pre class="source-code">
<code>pip freeze &gt; requirements.txt</code></pre> <p><em class="italic">Figure 3</em><em class="italic">.18</em> shows an example of the contents of the <code>requirements.txt</code> file we just generated. You might have to look hard to see it since it is only one line long. You can see the package name as well as the version requirements for <code>numpy==1.24.2</code>. If you are using a different package <a id="_idIndexMarker251"/>manager, review the specific process for generating your <code>requirements.txt</code> file:</p>
<div><div><img alt="Figure 3.18: The contents of a sample requirements.txt file showing the third-party dependencies for our project" src="img/B19644_03_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.18: The contents of a sample requirements.txt file showing the third-party dependencies for our project</p>
<p>If you have cloned an existing project and it has a <code>requirements.txt</code> file, PyCharm will recognize it when you open the project and offer to install the contents to your virtual environment. PyCharm will also monitor your project as you work. If you add new dependencies, either through the GUI we’ve discussed or manually from the terminal, PyCharm will offer to add those dependencies to your <code>requirements.txt</code> file automatically.</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>The new Python Packages window</h2>
<p>New to the latest releases of PyCharm which uses the new UI is a <strong class="bold">Python Packages</strong> window. It adds similar functionality<a id="_idIndexMarker252"/> to the interpreter settings window in a different location and layout. Clearly, they were reading over my shoulder when I wrote earlier about how the Python environment settings being inside the general settings window is unintuitive. I doubt I’ll get credit for pointing it out, though. You’ll find the new <strong class="bold">Python Packages</strong> window in the <strong class="bold">More Tool Windows</strong> ellipsis, indicated in <em class="italic">Figure 3</em><em class="italic">.19</em>:</p>
<div><div><img alt="Figure 3.19: The More Tools menu contains the new Python Packages window" src="img/B19644_03_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.19: The More Tools menu contains the new Python Packages window</p>
<p>When you click the <strong class="bold">Python Packages</strong> icon, a new <a id="_idIndexMarker253"/>window will appear, as seen in <em class="italic">Figure 3</em><em class="italic">.20</em>:</p>
<div><div><img alt="Figure 3.20: The new Python Packages window in PyCharm" src="img/B19644_03_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.20: The new Python Packages window in PyCharm</p>
<p>As with the <strong class="bold">Environment Settings</strong> window, the <strong class="bold">Python Packages</strong> window shows a list of packages installed in the virtual environment, along with the accompanying version number. There is an <strong class="bold">Add Package</strong> button that allows you to add a package from PyPI or from a repository. You can search for packages using the search dialog, which shows a list of matching packages. Clicking one will show the documentation for that package. This is a step up from the <strong class="bold">Environment Settings</strong> window since this one displays the project’s<a id="_idIndexMarker254"/> markdown documentation. You can see an example in <em class="italic">Figure 3</em><em class="italic">.21</em>:</p>
<div><div><img alt="Figure 3.21: Searching for the numpy package in the new Python Package window" src="img/B19644_03_21.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.21: Searching for the numpy package in the new Python Package window</p>
<p>As you can see, I’ve searched for a package that was found on PyPI with 184 matches. I’ve selected the <code>numpy</code> package, and PyCharm displays the documentation for the project. There’s a nice big <strong class="bold">Install package</strong> button and a selector to pick the version I’d like to install.</p>
<p>I can delete an installed package by clicking an installed package in the list. The version number is displayed along with the packages’ documentation. Beneath the ellipsis next to the installed version number is a <strong class="bold">Delete Package</strong> button, as seen in <em class="italic">Figure 3</em><em class="italic">.22</em>:</p>
<div><div><img alt="Figure 3.22: Deleting a package can be done using the menu option beneath the ellipsis next to the version number in the Python Package window" src="img/B19644_03_22.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.22: Deleting a package can be done using the menu option beneath the ellipsis next to the version number in the Python Package window</p>
<p>This feature is so new as I write this that it almost didn’t make it into the chapter. I happened to notice it while at work the other day. It presents, in my opinion, a less confusing and more<a id="_idIndexMarker255"/> convenient way to work with Python packages.</p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Professional features important to virtual environments</h1>
<p>One major feature of the <a id="_idIndexMarker256"/>Professional edition of PyCharm is the ease of project creation compared to the more manual approach. Consider the Professional edition’s new project window, which has a set of project types, as seen in <em class="italic">Figure 3</em><em class="italic">.23</em>:</p>
<div><div><img alt="Figure 3.23: The Professional edition lists many project templates in the New Project dialog" src="img/B19644_03_23.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.23: The Professional edition lists many project templates in the New Project dialog</p>
<p>The Community edition of Python does not have any of these project options. You can only create pure Python projects, but to be fair, you can still create a Flask project or any of the other project <a id="_idIndexMarker257"/>types listed using the Community edition. However, the IDE isn’t going to help you do it.</p>
<p>Let’s look at the steps to create a Flask project. Flask is a library that allows us to easily create a dynamic web application. We’ll cover it extensively in <a href="B19644_08.xhtml#_idTextAnchor203"><em class="italic">Chapter 8</em></a>, <em class="italic">Building a Dynamic Web Application in Flask</em>. For now, we’re going to compare the level of work needed to do this without the Professional edition (that is, with no IDE at all).</p>
<p>These are the steps to manually set up the project:</p>
<ol>
<li>Create a new folder for your project.</li>
<li>Create a new virtual environment for your project.</li>
<li>Activate the virtual environment.</li>
<li>Use your favorite package manager to install the Flask library along with its dependencies.</li>
<li>Create a Python file to hold your starting code.</li>
<li>Research the web and find an example of a simple “Hello world” sample and put that in your Python file.</li>
<li>Create a script that can set any necessary environment variables such as <code>PYTHONPATH</code>, then run your program.</li>
</ol>
<p>I’ll bet many of you can do this in about 20-30 minutes, tops. Here’s my problem with that: when are you most fired up about your new project idea? It’s at the beginning of the project! You are ready to roll but then must stop and spend 30 minutes doing this tedious setup. It isn’t a lot of time, but it is an interruption. There is a chance of hitting some unexpected snags, which can zap your enthusiasm. In extreme cases, sometimes, unexpected snags delay you hours or days. PyCharm automates the entire process. You step through a couple <a id="_idIndexMarker258"/>of dialog screens, usually accepting the defaults, and your project is ready in fewer than 30 seconds. You can immediately start banging out your idea in code by modifying the starting boilerplate generated by the IDE.</p>
<p>The Professional edition will help you generate more complicated projects with very little effort on your part. The IDE will create your folder structure, a basic set of files with edit prompts to get started, and a virtual environment. PyCharm will even install the requirements for you.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Importing projects into PyCharm</h1>
<p>Perhaps it goes<a id="_idIndexMarker259"/> without saying, but I’m going to say it anyway. You can import existing projects created either manually or with another IDE into PyCharm. This seems obvious because, after all, it is just a matter of opening a folder on your computer. The import process really is as simple as opening a folder in PyCharm. However, there’s more to the story than that. PyCharm is your intelligent ally when it comes to working on getting a project running on your machine that was started, or entirely authored, on another without PyCharm involved. Let’s see this in action.</p>
<p>Within this book’s source code we cloned at the end of <a href="B19644_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">Installation and Configuration</em>, and within the <code>chapter-03</code> folder, there is a project that I created entirely from the command<a id="_idIndexMarker260"/> line. You can see the process I used in <em class="italic">Figure 3</em><em class="italic">.24</em>:</p>
<div><div><img alt="Figure 3.24: The terminal window I used to create a Python project entirely outside of PyCharm" src="img/B19644_03_24.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.24: The terminal window I used to create a Python project entirely outside of PyCharm</p>
<p>The process I followed is clearly shown, as described here:</p>
<ol>
<li>Within a new project folder called <code>manually-created</code>, I created a new virtual environment with the <code>python3 -m venv </code><code>venv</code> command.</li>
<li>I activated the virtual environment with the <code>source venv/bin/activate</code> command. In this case, I am working in Linux. This same command will work on a Mac. If I were using Windows, it would be <code>.\venv\Scripts\activate</code>.</li>
<li>Next, I installed a third-party module called <code>tqdm</code>. You can find out more at <a href="https://pypi.org/project/tqdm/">https://pypi.org/project/tqdm/</a>. The short version of this module is used to easily format the terminal output of a program to include a nice-looking progress bar. You can see the blocky progress bar a little further down in <em class="italic">Figure 3</em><em class="italic">.24</em> after I run the program. I’m getting ahead of myself.</li>
<li>I used <code>nano</code> to add some code to a new file called <code>main.py</code>. I’ll show you the contents in a moment, but all I did was copy and paste an example from the <code>tqdm</code> documentation on the <a href="https://pypi.org">https://pypi.org</a> page I linked earlier. If you’re wondering what the <code>-l</code> switch does, it displays line numbers in the <code>nano</code> editor, which makes <code>nano</code> a quick, easy-to-use code editor.</li>
<li>I ran the program<a id="_idIndexMarker261"/> using the <code>python </code><code>main.py</code> command.</li>
<li>Having verified that it all worked, I created a <code>requirements.txt</code> file to document my program’s dependence on the <code>tqdm</code> module. The <code>pip freeze</code> command will output a dependency graph to the screen. In order to turn that into a text file I can include in my Git repository, I piped the output with <code>&gt; requirements.txt</code>, making the full command look like this:<pre class="source-code">
pip freeze &gt; requirements.txt.</pre></li> </ol>
<p>This kind of command-line setup work is beneath us. In fact, I recommend you celebrate this by buying yourself a new pair of cargo pants and carrying yourself with a new air of swagger! If you identify as a non-cargo-pants-wearing sentient being, I hope you’ll use your imagination to translate my intent. On second thoughts, at the risk of generalizing, you probably should take neither wardrobe nor social behavior advice from me. Traditionally, <em class="italic">wardrobe advice</em> is not my <em class="italic">strong suit</em>.</p>
<p class="callout-heading">Warning</p>
<p class="callout">If this is the first of my books you are reading, one ground rule I keep is that all puns are intended.</p>
<p>Thankfully, working with projects created outside of PyCharm is a strong suit of PyCharm. Since the project has already been created outside of PyCharm, let’s see what PyCharm makes of it. Let’s open the <code>chapter-03/manually-created</code> folder in PyCharm. To make <a id="_idIndexMarker262"/>things crystal clear, I’m showing you the project’s open dialog in <em class="italic">Figure 3</em><em class="italic">.25</em>:</p>
<div><div><img alt="Figure 3.25: Opening the manually-created project that was created outside of PyCharm" src="img/B19644_03_25.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.25: Opening the manually-created project that was created outside of PyCharm</p>
<p>For this project, I did something I would not usually do. The virtual environment (<code>venv</code>) folder is included in the git repository. Normally, it shouldn’t be, but it needs to be there for you to see the next little bit of magic.</p>
<p>Open the project folder and watch what happens. If you’re looking for a big display of software-empowered awesomeness, it might seem a little underwhelming. It isn’t even worthy of a screenshot. The project opened, and it’s just sitting there. That’s the cool part. PyCharm can see your virtual environment folder, so it automatically sets up your project for you. You can verify all this in your project settings, as seen in <em class="italic">Figure 3</em><em class="italic">.26</em>:</p>
<div><div><img alt="Figure 3.26: The imported project has the correct interpreter settings with no effort on our part" src="img/B19644_03_26.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.26: The imported project has the correct interpreter settings with no effort on our part</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Importing a project cloned from a repository</h2>
<p>Our previous example showed importing a project I created manually on my computer. It is more likely you will import a project you’ve cloned from GitHub or some other repository. These projects when cloned will not have the virtual environment folder present. As such, you have to do a little more work to set up the project.</p>
<p>I’m going to reuse the same project, but I’m going to delete a few files so that PyCharm won’t remember anything about the project.</p>
<p>First, close the project in PyCharm, as seen in <em class="italic">Figure 3</em><em class="italic">.27</em>:</p>
<div><div><img alt="Figure 3.27: Closing the project" src="img/B19644_03_27.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.27: Closing the project</p>
<p>Next, use your operating<a id="_idIndexMarker263"/> system to delete the folders shown in <em class="italic">Figure 3</em><em class="italic">.28</em>:</p>
<div><div><img alt="Figure 3.28: Deleting the venv and .idea folders to simulate a project you might have cloned from a version control system (VCS)" src="img/B19644_03_28.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.28: Deleting the venv and .idea folders to simulate a project you might have cloned from a version control system (VCS)</p>
<p>We are getting rid of the <code>venv</code> folder and the <code>.idea</code> folder. The latter will be hidden on macOS and Linux systems, so make sure you turn on the ability to view hidden folders. The <code>.idea</code> folder is the PyCharm project folder, which was automatically created when you opened the project folder. With those two folders gone, PyCharm is now virtually ignorant of having <a id="_idIndexMarker264"/>ever opened the project. The folder will still show up in your <strong class="bold">Recent</strong> projects folder, but that is OK. Open the folder again with PyCharm. The result of opening the project in PyCharm is shown in <em class="italic">Figure 3</em><em class="italic">.29</em>:</p>
<div><div><img alt="Figure 3.29: Importing a project created outside of PyCharm prompts to create a virtual environment" src="img/B19644_03_29.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.29: Importing a project created outside of PyCharm prompts to create a virtual environment</p>
<p>PyCharm sees the <code>requirements.txt</code> file but it can’t find a suitable virtual environment because there isn’t a subfolder in the project containing a Python executable. PyCharm will prompt you to create an environment for your project. In my case, the default is to a local folder called <code>venv</code>. It is going to use the Python 3.10 executable it found at <code>/usr/bin/python3.10</code> as the base for the virtual environment, and it sees the <code>requirements.txt</code> file. If I hit <strong class="bold">OK</strong>, PyCharm will set up a virtual environment and then install my dependencies for me.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Dealing with invalid interpreters</h2>
<p>No IDE is perfect. Sometimes, PyCharm can get confused about which virtual environment to use. This really only happens when you set up a new project with code not created in PyCharm. This is a <a id="_idIndexMarker265"/>corner case, but sooner or later, you’re going to see it, so I want to spend a minute talking about this scenario. Maybe you’re preparing to write a book on PyCharm. OK—that probably mostly happens to me. Say you’re preparing a demo. Maybe you are setting up a training session and you’ve fiddled around with things a little too much or a few too many times. If you are like me, you like things to be perfect. You’ve worked toward setting up a project, and you see listings for invalid environments such as the one in <em class="italic">Figure 3</em><em class="italic">.30</em>:</p>
<div><div><img alt="Figure 3.30: Invalid interpreter errors happen to the best of us" src="img/B19644_03_30.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.30: Invalid interpreter errors happen to the best of us</p>
<p>Gross! There’s an ugly red message saying the base interpreter is invalid. We need to fix this. The good news is you know what to do! First, let’s solve your immediate problem. You need to set the base interpreter so that PyCharm can finish importing your project. The first thing to try is the drop-down list for the base interpreter. In all likelihood, your global Python installation will appear in the list. If it does, pick it then click <strong class="bold">OK</strong>, and PyCharm will do its thing.</p>
<p>If you can’t find one, you can still make a valid environment. You just need to create a virtual environment the same way we did when we were creating our project from scratch. You’d need to cancel out of the dialog you’re seeing in <em class="italic">Figure 3</em><em class="italic">.32</em> and use the project settings to add a new environment.</p>
<p>Click <strong class="bold">File</strong> | <strong class="bold">Settings</strong> to get into the <strong class="bold">Settings</strong> dialog and find the project settings, as shown in <em class="italic">Figure 3</em><em class="italic">.31</em>:</p>
<div><div><img alt="Figure 3.31: The worst-case scenario﻿ (it doesn’t happen often, but it does happen﻿)" src="img/B19644_03_31.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.31: The worst-case scenario (it doesn’t happen often, but it does happen)</p>
<p>This is the worst-case <a id="_idIndexMarker266"/>scenario! The list doesn’t show the base interpreter, and the only option is our invalid virtual environment. Admittedly, you must work hard to get PyCharm to do this, but this usually happens exactly 5 minutes before you need PyCharm to work in front of a lot of people. I’m here for you.</p>
<p>At the bottom of the drop-down list is the <strong class="bold">Show All…</strong> option. This will allow us to fix everything! Click it! You’ll see a very useful dialog, shown in <em class="italic">Figure 3</em><em class="italic">.32</em>:</p>
<div><div><img alt="Figure 3.32: The Python interpreters dialog allows you to manage all your Python environments in one place" src="img/B19644_03_32.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.32: The Python interpreters dialog allows you to manage all your Python environments in one place</p>
<p>Note the arrow in <em class="italic">Figure 3</em><em class="italic">.32</em>. You can use the <strong class="bold">+</strong> and <strong class="bold">–</strong> icons to add and remove environments. You can select your invalid environment and remove it with the <strong class="bold">–</strong> icon. Next, you can add a <a id="_idIndexMarker267"/>new, valid environment with the <strong class="bold">+</strong> icon. The workflow for adding a new interpreter is the same as it was when we created one from scratch with a new project. We’ve covered the process already, so I won’t go through it again.</p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Working with run configurations</h1>
<p>Run configurations in<a id="_idIndexMarker268"/> PyCharm allow you to set up different ways to run your programs from the IDE. The heart of the run configurations is a cluster of blue buttons toward the top of the main window. Follow the arrow in <em class="italic">Figure 3</em><em class="italic">.33</em>:</p>
<div><div><img alt="Figure 3.33: There are several run buttons at the top of the screen along with a drop-down list that allows you to work with various run configurations" src="img/B19644_03_33.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.33: There are several run buttons at the top of the screen along with a drop-down list that allows you to work with various run configurations</p>
<p>Since we have the <code>manually-created</code> project already open from earlier, why don’t we continue exploring using that project? That cluster of buttons I pointed to in <em class="italic">Figure 3</em><em class="italic">.33</em> consists of a <strong class="bold">Run</strong> button, a <strong class="bold">Debug</strong> button, and a dropdown that lets you set and manage your run configurations. When we imported the project, it generated a run configuration called <strong class="bold">Current File</strong>.</p>
<p>With this set in the <a id="_idIndexMarker269"/>drop-down menu, the file in the <strong class="bold">Focused</strong> tab will be executed when you click either the run or debug button:</p>
<ol>
<li>This is the regular <code>main.py</code> script because that is in the currently focused tab.</li>
<li>This is the <strong class="bold">Run</strong> (debug) button. Clicking this will run your selected run configuration with an attached debugger. We’ll see this in action in <a href="B19644_06.xhtml#_idTextAnchor145"><em class="italic">Chapter 6</em></a>, <em class="italic">Seamless Testing, Debugging, </em><em class="italic">and Profiling</em>.</li>
<li>The ellipsis button contains more options for running a profiler and checking your test coverage. We’ll cover these in later chapters.</li>
<li>The <strong class="bold">Run configuration</strong> dropdown lets you select a run configuration. There is an option to create and edit existing configurations as well as create new ones.</li>
</ol>
<p>For now, let’s focus on the run configurations themselves since these have their own environment settings independent from the rest of the project.</p>
<p>Click the drop-down menu where it says <strong class="bold">Current File</strong> and click <strong class="bold">Edit Configurations…</strong>, as shown in <em class="italic">Figure 3</em><em class="italic">.34</em>. This brings up a dialog for managing your run configurations. You<a id="_idIndexMarker270"/> can add, edit, and delete your configurations here. Note the Professional edition will have more tooling available in this window than will the Community edition. I will focus on the Professional edition:</p>
<div><div><img alt="Figure 3.34: Adding a new run configuration for our manually-created project" src="img/B19644_03_34.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.34: Adding a new run configuration for our manually-created project</p>
<p>There are plenty of prompts in<a id="_idIndexMarker271"/> the dialog that allow you to create a new run configuration. Let’s ignore those because once you add one, those options will go away. Click the <strong class="bold">+</strong> icon at the top of the dialog, as shown in <em class="italic">Figure 3</em><em class="italic">.35</em>:</p>
<div><div><img alt="Figure 3.35: Clicking the + button to add a new run configuration﻿ (the list shown is for the Professional edition, and you’ll need to scroll down to find the Python item shown﻿)" src="img/B19644_03_35.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.35: Clicking the + button to add a new run configuration (the list shown is for the Professional edition, and you’ll need to scroll down to find the Python item shown)</p>
<p>If you are running the Professional edition, you’ll see a long list of options, as in <em class="italic">Figure 3</em><em class="italic">.35</em>. The Community edition list is considerably shorter since it only has tooling for pure Python projects.</p>
<p>I’m going to pick the Pure Python project type since that’s one we can all use. Each option may present <a id="_idIndexMarker272"/>a different dialog box with different settings based on what is appropriate for your selection. The Pure Python options look like what is shown in <em class="italic">Figure 3</em><em class="italic">.36</em>:</p>
<div><div><img alt="Figure 3.36: The options for a run configuration using the Pure Python template" src="img/B19644_03_36.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.36: The options for a run configuration using the Pure Python template</p>
<p>There are a lot of settings here. Let’s review the most important settings by the numbers provided in <em class="italic">Figure 3</em><em class="italic">.36</em>:</p>
<ol>
<li>You should give the run configuration a name. If you don’t, it will default to the name of the script. You can use a human-friendly name here; it doesn’t have to relate to the running file in any way.</li>
<li>This setting is probably the most obvious. It lets you select the script you’d like to run. You can browse to it or type the path. You can also change this from a script file to a module name by clicking the triangle next to the script path text entry box. If you change the setting to run a module, the folder <strong class="bold">Browse</strong> button will change to an<a id="_idIndexMarker273"/> ellipsis, and you’ll be able to browse the modules in your program to find the one you’d like to run.</li>
<li>The <code>argparse</code>, you can pass them here. This textbox is fairly interactive. Note the <strong class="bold">+</strong> icon. Clicking this allows you to invoke some macros available in the tool. For example, if you need the path for the current directory, you’ll find an option for that in the macro list.</li>
<li>These are the environment settings. The default uses the project settings. You can set a different virtual environment for your run configurations than for your project if you need to test-run your software in different environments. You can also set environment variables here without jumping out to your operating system. This is handy if you rely on environment variables for your program settings. If you use OS-level environment variables for sensitive data such as passwords or connection strings, I recommend against setting them here. These settings can wind up in the project configuration files, which means they could make it into your source repository. There’s nothing worse than realizing your hackathon project files contain your personal password or access tokens for your favorite cloud provider. <code>SuperH4xr1337@some-evil-hacker-org.darkweb.net</code> (<em class="italic">note</em>: hopefully not a real address) loves it when you do this. There are bots that troll GitHub looking for this stuff, so be careful. Personally, I use configuration files for this using one of the many <code>env</code> libraries. I’ll put a link in the <em class="italic">Further reading</em> section if you’re interested in this.</li>
<li>You can set a working directory should any part of your script rely on relative file paths.</li>
<li>This checkbox controls whether the content roots from your project are injected into the <code>PYTHONPATH</code> environment variable when you run your program. The <code>PYTHONPATH</code> environment variable controls where the Python interpreter searches for modules. Content roots refer to project structure settings where you define content folders. This is<a id="_idIndexMarker274"/> generally only used with web projects. A content folder might contain images or other static content. The <code>PYTHONPATH</code> environment variable. I’ve worked on microservice architecture projects where this was useful. Sometimes, you might have a module in another project that you need to leverage, but it belongs in its own separate project rather than being directly managed in the current project. You can set your source roots to include other projects with dependencies, and checking this box will make those available to your running program.</li>
</ol>
<p>As you can see, there are a lot of options and ways you can customize the way a program is run using PyCharm. If your application has several executable scripts, you can set each one up with its own run configuration.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>PyCharm’s project files</h1>
<p>Most IDEs have some sort of project file designed<a id="_idIndexMarker275"/> to contain project-level settings. If you’ve ever used any of Microsoft’s IDEs, you might remember folders such as <code>.vscode</code> for Visual Studio Code and <code>.vs</code> in a Visual Studio project. Java IDEs such as NetBeans and Eclipse also use a set of files to contain their project settings. PyCharm too has a set of files stored in a folder within each project, called <code>.idea</code>. This might seem like a strange name until you remember that JetBrains began with only one IDE project, IntelliJ IDEA. IntelliJ IDEA garnered a reputation for being the best IDE for Java development, bar none. It is so good that Google contracted with JetBrains to create Android Studio; a natural fit given Android applications are written entirely in Java. All the IDEs from JetBrains have the same lineage. They are all descendants of IntelliJ IDEA, and that’s why the project folder is called <code>.idea</code>. Remember—Windows users will plainly see this folder, while on Linux and Mac, any folder name beginning with a dot (<code>.</code>) is hidden.</p>
<p>By default, there isn’t <a id="_idIndexMarker276"/>anything particularly interesting inside these folders should you ever be tempted to try to edit them. In fact, if you were to delete them, PyCharm would simply recreate them when you reopen the project.</p>
<p>That said, there are options in PyCharm that let you store your run configurations within these files, as shown in <em class="italic">Figure 3</em><em class="italic">.37</em>:</p>
<div><div><img alt="Figure 3.37: You can opt to store run configurations as part of the project files in the .idea folder" src="img/B19644_03_37.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.37: You can opt to store run configurations as part of the project files in the .idea folder</p>
<p>If you opt to do this, you have the capability to check the <code>.idea</code> files into your VCS repository and share them<a id="_idIndexMarker277"/> with your team. This means everybody will have the same configurations, so you might want to have a meeting and standardize your project structure so that you’re not stepping on each other.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Summary</h1>
<p>This chapter was all about setting up your virtual environment for a Python project. Each project typically has its own virtual environment. We use virtual environments to insulate our projects from the requirements of other projects and to keep our global Python installation from becoming polluted with lots of global packages that were used for only one project.</p>
<p>A virtual environment is a copy of a Python interpreter along with all supporting tools such as a package manager and third-party libraries needed for your project. PyCharm has features built in for creating and managing virtual environments.</p>
<p>We first see these tools during the creation of a new project. PyCharm prompts us to create a new virtual environment every time. We can also select an existing environment if that is appropriate. PyCharm gives us the ability to change the virtual environment for the project at any time.</p>
<p>Our virtual environments also house all the third-party libraries needed for our project. You can find thousands of ready-made modules at <a href="https://pypi.org">https://pypi.org</a>. These modules can be installed and used in your projects by means of a package manager. The most common package manager is <code>pip</code>, but others exist, such as <code>conda</code>, <code>pipenv</code>, and <code>poetry</code>. PyCharm supports all of these tools, and you are afforded the opportunity to select your tool of choice when you create your virtual environment.</p>
<p>Having selected your package manager, PyCharm has a GUI that allows you to see, add, remove, and update your library dependencies from PyPI. You’ll find this GUI within your project settings, which are bundled inside the general settings for PyCharm itself.</p>
<p>PyCharm can easily import projects created outside of PyCharm. All you need to do is open the folder where the code resides. PyCharm creates a set of project files within that folder called <code>.idea</code>, then prompts you to set an interpreter if it couldn’t find one within the project folder. PyCharm will also look for a <code>requirements.txt</code> file and offer to install your dependencies for you.</p>
<p>When you are ready to run some code within the IDE, PyCharm offers a powerful run system that uses run configurations created in the GUI. PyCharm Professional ships with many project types, and each one has its own run configuration settings. We covered the extensive settings found in a pure Python project since that is available to Community edition users. The run configuration can manage—and in some cases mimic—a wide gamut of settings you would normally have to set manually at the operating system level.</p>
<p>All totaled, PyCharm gives you a very complete set of tools for managing virtual environments for development and running your code. In the next chapter, we’ll switch our focus to the primary tools you’ll use every day to manage, write, and edit your code.</p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>Questions</h1>
<ol>
<li>What are virtual environments and why are they important?</li>
<li>What are the tools used by the Python community to create virtual environments?</li>
<li>Which virtual environment tools are supported in PyCharm?</li>
<li>Can a run configuration use a different virtual environment from the main project? How might this be useful?</li>
<li>Where does PyCharm keep its project configuration files?</li>
</ol>
<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Further reading</h1>
<ul>
<li><em class="italic">Alternative Python </em><em class="italic">Implementations</em>: <a href="https://www.python.org/download/alternatives/">https://www.python.org/download/alternatives/</a></li>
<li><code>The env</code> library: <a href="https://pypi.org/project/env/">https://pypi.org/project/env/</a></li>
<li><em class="italic">Ajitsaria</em>, <em class="italic">A.</em> <em class="italic">What is the Python Global Interpreter Lock (</em><em class="italic">GIL)?</em>: <a href="https://realpython.com/python-gil/">https://realpython.com/python-gil/</a></li>
<li>Be sure to check out the companion website for the book at <a href="https://www.pycharm-book.com.">https://www.pycharm-book.com.</a></li>
</ul>
</div>
</body></html>