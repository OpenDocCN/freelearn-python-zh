- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating FastAPI with NoSQL Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the integration of **FastAPI** with **NoSQL**
    databases. By crafting the backend of a music streaming platform application,
    you will learn how to set up and use **MongoDB**, a popular NoSQL database, with
    FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: You will also learn how to perform **create, read, update and delete** (**CRUD**)
    operations, work with indexes for performance optimization, and handle relationships
    in NoSQL databases. Additionally, you will learn how to integrate FastAPI with
    **Elasticsearch** for powerful search capabilities, secure sensitive data, and
    implement caching using **Redis**.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of how to effectively
    use NoSQL databases with FastAPI to improve the performance and functionality
    of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up MongoDB with FastAPI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CRUD operations in MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling relationships in NoSQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with indexes in MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing sensitive data from NoSQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating FastAPI with Elasticsearch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Redis for caching in FastAPI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the recipes of the chapter, ensure your setup includes
    the following essentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**: A version 3.7 or higher should be installed on your computer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fastapi` package in your working environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asyncio`: Be familiar with the `asyncio` framework and `async`/`await` syntax
    since we will use it all along the recipes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code used in the chapter is hosted on GitHub at this address: [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter07](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: You can create a virtual environment for the project within the project root
    folder to manage dependencies efficiently and maintain project isolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within your virtual environment, you can install all the dependencies at once
    by using `requirements.txt`, which is provided on the GitHub repository in the
    project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: General knowledge of the external tools we are going to use for each recipe
    can be beneficial, although not mandatory. Each recipe will provide you with a
    minimal explanation of the used tool.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up MongoDB with FastAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to set up MongoDB, a popular document-oriented
    NoSQL database, with FastAPI. You will learn how to manage Python packages to
    interact with MongoDB, create a database, and connect it to a FastAPI application.
    By the end of this recipe, you will have a solid understanding of how to integrate
    MongoDB with FastAPI to store and retrieve data for your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To follow along with this recipe, you need Python and `fastapi package` installed
    in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, for this recipe, make sure you have a MongoDB instance running and reachable,
    and if not, set up a local one. Depending on your operating system and your personal
    preference, you can set up a local MongoDB instance in several ways. Feel free
    to consult the official documentation on how to install the community edition
    of MongoDB on your local machine at the following link: [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community).'
  prefs: []
  type: TYPE_NORMAL
- en: For the recipe and throughout the chapter, we will consider a local instance
    of MongoDB running on http://localhost:27017\. If you run the MongoDB instance
    on a remote machine, or simply use a different port, adjust the URL reference
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need the `motor` package installed in your environment. If you haven’t
    installed the packages with `requirements.txt`, you can install `motor` in your
    environment from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`asyncio` library.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the MongoDB instance running and reachable and the `motor` package
    installed in your environment, we can proceed with the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by creating a project root folder called `streaming_platform` with
    an `app` subfolder. In `app`, we create a module called `db_connection.py`, which
    will contain the information on the connection with MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will set up the connection through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `db_connecion.py` module, let’s define the MongoDB client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will use the `mongo_client` object each time we need to interact with the
    MongoDB instance that is running at http://localhost:27017.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `db_connection.py` module, we will create a function to ping the MongoDB
    instance to ensure it is running. But first, we retrieve the `uvicorn` logger,
    used by the FastAPI server, to print messages to the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s create the function to ping the MongoDB as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function will ping the server, and if it doesn’t receive any response, it
    will propagate an error that will stop the code from running.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we need to run the `ping_mongo_db_server` function when starting the
    FastAPI server. In the `app` folder, let’s create a `main.py` module with a context
    manager that will be used for the startup and shutdown of our FastAPI server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `lifespan` context manager has to be passed as an argument to the `FastAPI`
    object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The server is wrapped in the `lifespan` context manager to execute the database
    check at startup.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test it, make sure your MongoDB instance is already running and as usual,
    let’s spin up the server from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following log messages on the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This message confirms that our application correctly communicates with the MongoDB
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve just set up the connection between a FastAPI application and a MongoDB
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can see more on the Motor asynchronous driver on the MongoDB official documentation
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Motor Async Driver* *Setup*: https://www.mongodb.com/docs/drivers/motor/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For startups and shutdown events of the FastAPI server, you can find more on
    this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*FastAPI Lifespan* *Events*: [https://fastapi.tiangolo.com/advanced/events/](https://fastapi.tiangolo.com/advanced/events/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CRUD operations in MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CRUD operations form the cornerstone of data manipulation in databases, enabling
    users to create, read, update, and delete data entities with efficiency, flexibility,
    and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will demonstrate how to create endpoints in FastAPI for creating,
    reading, updating, and deleting a document from a MongoDB database for the backbone
    of our streaming platform.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To follow along with the recipe, you need a database connection with MongoDB
    already in place with your application, otherwise, go to the previous recipe,
    *Setting up MongoDB with FastAPI*, which will show you in detail how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before creating the endpoints for the CRUD operations, we have to initialize
    a database on the MongoDB instance for our streaming application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do it in a dedicated module in the `app` directory called `database.py`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We’ve defined a database called `beat_streaming`, which will contain all the
    collections of our application.
  prefs: []
  type: TYPE_NORMAL
- en: On the MongoDB server side, we don’t need any action to do since the `motor`
    library will automatically check for the existence of a database named `beat_streaming`
    and the eventual collections, and it will create them if they don’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same module, we can create the function to return the database that
    will be used as a dependency in the endpoints for code maintainability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can define our endpoints in `main.py` for each of the CRUD operations
    through the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating the endpoint to add a song to the `songs` collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The endpoint takes a general JSON in the body and returns the ID affected from
    the database. The `ENCONDERS_BY_TYPE[ObjectID] = str` line specifies to the FastAPI
    server that the `song["_id"]` document ID has to be decoded as a `string`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One of the reasons to choose a NoSQL database is the freedom from SQL schema,
    which allows for more flexibility in managing data. However, it can be helpful
    to provide an example to follow in the documentation. This is achieved by using
    the `Body` object class with the example parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The endpoint to retrieve a song will be quite straightforward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The application will search for a song with the specified ID and return a `404`
    error if none is found.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To update a song, the endpoint will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The endpoint will return a `404` error if the song id does not exist, otherwise
    it will update only the fields specified in the body request.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, the `delete` operation endpoint can be done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have just created the endpoints to interact with a MongoDB database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, spin up the server from the command line and test the endpoints you just
    created from the interactive documentation at http://localhost:8000/docs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you follow along with the GitHub repository, you can also prefill the database
    with the script `fill_mongo_db_database.py` at the link: [https://github.com/PacktPublishing/FastAPI-Cookbook/blob/main/Chapter07/streaming_platform/fill_mongo_db_database.py](https://github.com/PacktPublishing/FastAPI-Cookbook/blob/main/Chapter07/streaming_platform/fill_mongo_db_database.py)'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you download also the `songs_info.py` in the same folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then run the script from the terminal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you call the endpoint `GET /songs` you will have a long list of songs pre
    filled to test your API.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can investigate the operations provided by `motor` to interact with a MongoDB
    instance further at the official documentation link:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Motor MongoDB Aynscio* *Tutorial*: [https://motor.readthedocs.io/en/stable/tutorial-asyncio.xhtml](https://motor.readthedocs.io/en/stable/tutorial-asyncio.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling relationships in NoSQL databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike relational databases, NoSQL databases do not support joins or foreign
    keys for defining relationships between collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Schema-less databases, such as MongoDB, do not enforce relationships like traditional
    relational databases. Instead, two primary approaches can be used for handling
    relationships: **embedding** and **referencing**.'
  prefs: []
  type: TYPE_NORMAL
- en: Embedding involves storing related data within a single document. This approach
    is suitable for all types of relationships, provided that the embedded data is
    closely tied to the parent document. This technique is good for read performance
    for frequently accessed data and atomic updates with a single document. However,
    it can easily lead to size limitation problems with data duplication and potential
    inconsistencies if the embedded data changes frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing involves storing references to related documents using their object
    ID or other unique identifiers. This approach is suitable for many-to-one and
    many-to-many relationships where the related data is huge and is shared across
    multiple documents.
  prefs: []
  type: TYPE_NORMAL
- en: This technique reduces data duplication and improves flexibility to update related
    data independently, but, on the other hand, increases the complexity of reading
    operations due to multiple queries leading to slower performances when fetching
    related data.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll explore both techniques for handling relationships between
    data entities in MongoDB by adding new collections to our streaming platform and
    making them interact.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will continue building our streaming platform. Make sure you have followed
    all the previous recipes in this chapter, or you can apply the steps to an existing
    application that interacts with a NoSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s see how to implement relationships for both embedding and referencing
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A suitable candidate to showcase embedded relationships for songs is a collection
    of albums. Album information does not change often, if not never, once it is published.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `album` document will embedded into the `song` document with a nested field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When using MongoDB, we can retrieve information about an album and a song using
    the same endpoint. This means that when we create a new song, we can directly
    add information about the album it belongs to. We specify the way we want the
    document song to be stored, and MongoDB takes care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Spin up the server and test the `POST /song` endpoint. In the JSON body, include
    information about the album. Take note of the ID retrieved and use it to call
    the `GET /song` endpoint. Since we haven’t defined any response schema restriction
    in the response model, the endpoint will return all the document information retrieved
    from the database including the album.
  prefs: []
  type: TYPE_NORMAL
- en: For this use case example, there is nothing to worry about, but for some applications,
    you might not want to disclose a field to the end user. You can either define
    a response model (see [*Chapter 1*](B21025_01.xhtml#_idTextAnchor020), *First
    Steps with FastAPI*, in the *Defining and using request and response models* recipe)
    or drop the field from the `dict` object before it is returned.
  prefs: []
  type: TYPE_NORMAL
- en: You have just defined a many-to-one relationship with the embedding strategy
    that relates songs to albums.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A typical use case for referencing relationships can be the creation of a playlist.
    A playlist contains multiple songs, and each song can appear in different playlists.
    Furthermore, playlists are often changed or updated, so it respond to the need
    for a referencing strategy to manage relationships.
  prefs: []
  type: TYPE_NORMAL
- en: On the database side, we don’t need any action so we will directly proceed to
    create the endpoint to create the playlist and the one to retrieve the playlist
    with all song information.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define the endpoint to create a playlist in the `main.py` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The endpoint requires a JSON body specifying the playlist name and the list
    of song IDs to include, and it returns the playlist ID.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The endpoint to retrieve the playlist will take as an argument the playlist
    ID. You can code it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the song IDs in the playlist collection are stored as strings, not
    `ObjectId`, which means that they have to be converted when queried.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Also, to receive the list of songs for the playlist, we had to make two queries:
    one for the playlist and one to retrieve the songs based on their IDs.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that you build the endpoints to create and retrieve playlists, spin up
    the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '@app.get("/songs/year")'
  prefs: []
  type: TYPE_NORMAL
- en: async def get_songs_by_released_year(
  prefs: []
  type: TYPE_NORMAL
- en: 'year: int,'
  prefs: []
  type: TYPE_NORMAL
- en: db=Depends(mongo_database),
  prefs: []
  type: TYPE_NORMAL
- en: '):'
  prefs: []
  type: TYPE_NORMAL
- en: 'query = db.songs.find({"album.release_year": year})'
  prefs: []
  type: TYPE_NORMAL
- en: songs = await query.to_list(None)
  prefs: []
  type: TYPE_NORMAL
- en: return songs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '@asynccontextmanager'
  prefs: []
  type: TYPE_NORMAL
- en: 'async def lifespan(app: FastAPI):'
  prefs: []
  type: TYPE_NORMAL
- en: await ping_mongo_db_server(),
  prefs: []
  type: TYPE_NORMAL
- en: db = mongo_database()
  prefs: []
  type: TYPE_NORMAL
- en: 'await db.songs.create_index({"album.release_year": -1})'
  prefs: []
  type: TYPE_NORMAL
- en: yield
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '@app.get("/songs/year")'
  prefs: []
  type: TYPE_NORMAL
- en: async def get_songs_by_released_year(
  prefs: []
  type: TYPE_NORMAL
- en: 'year: int,'
  prefs: []
  type: TYPE_NORMAL
- en: db=Depends(mongo_database),
  prefs: []
  type: TYPE_NORMAL
- en: '):'
  prefs: []
  type: TYPE_NORMAL
- en: 'query = db.songs.find({"album.release_year": year})'
  prefs: []
  type: TYPE_NORMAL
- en: explained_query = await query.explain()
  prefs: []
  type: TYPE_NORMAL
- en: logger.info(
  prefs: []
  type: TYPE_NORMAL
- en: '"Index used: %s",'
  prefs: []
  type: TYPE_NORMAL
- en: explained_query.get("queryPlanner", {})
  prefs: []
  type: TYPE_NORMAL
- en: .get("winningPlan", {})
  prefs: []
  type: TYPE_NORMAL
- en: .get("inputStage", {})
  prefs: []
  type: TYPE_NORMAL
- en: .get("indexName", "No index used"),
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: songs = await query.to_list(None)
  prefs: []
  type: TYPE_NORMAL
- en: return songs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'INFO:    Index used: album.release_year_-1'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '@asynccontextmanager'
  prefs: []
  type: TYPE_NORMAL
- en: 'async def lifespan(app: FastAPI):'
  prefs: []
  type: TYPE_NORMAL
- en: await ping_mongodb_server(),
  prefs: []
  type: TYPE_NORMAL
- en: db = mongo_database()
  prefs: []
  type: TYPE_NORMAL
- en: await db.songs.drop_indexes()
  prefs: []
  type: TYPE_NORMAL
- en: 'await db.songs.create_index({"release_year": -1})'
  prefs: []
  type: TYPE_NORMAL
- en: 'await db.songs.create_index({"artist": "text"})'
  prefs: []
  type: TYPE_NORMAL
- en: yield
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '@app.get("/songs/artist")'
  prefs: []
  type: TYPE_NORMAL
- en: async def get_songs_by_artist(
  prefs: []
  type: TYPE_NORMAL
- en: 'artist: str,'
  prefs: []
  type: TYPE_NORMAL
- en: db=Depends(mongo_database),
  prefs: []
  type: TYPE_NORMAL
- en: '):'
  prefs: []
  type: TYPE_NORMAL
- en: query = db.songs.find(
  prefs: []
  type: TYPE_NORMAL
- en: '{"$text": {"$search": artist}}'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: explained_query = await query.explain()
  prefs: []
  type: TYPE_NORMAL
- en: logger.info(
  prefs: []
  type: TYPE_NORMAL
- en: '"Index used: %s",'
  prefs: []
  type: TYPE_NORMAL
- en: explained_query.get("queryPlanner", {})
  prefs: []
  type: TYPE_NORMAL
- en: .get("winningPlan", {})
  prefs: []
  type: TYPE_NORMAL
- en: .get("indexName", "No index used"),
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: songs = await query.to_list(None)
  prefs: []
  type: TYPE_NORMAL
- en: return songs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: $ uvicorn app.main:app
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: http://localhost:8000/songs/artist?artist=mars
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"_id": "667038acde3a00e55e764cf7",'
  prefs: []
  type: TYPE_NORMAL
- en: '"title": "Uptown Funk",'
  prefs: []
  type: TYPE_NORMAL
- en: '"artist": "Mark Ronson ft. Bruno Mars",'
  prefs: []
  type: TYPE_NORMAL
- en: '"genre": "Funk/pop",'
  prefs: []
  type: TYPE_NORMAL
- en: '"album": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"title": "Uptown Special",'
  prefs: []
  type: TYPE_NORMAL
- en: '"release_year": 2014'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'INFO:    Index used: artist_text'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"name": "John Doe",'
  prefs: []
  type: TYPE_NORMAL
- en: '"email": "johndoe@email.com",'
  prefs: []
  type: TYPE_NORMAL
- en: '"year_of_birth": 1990,'
  prefs: []
  type: TYPE_NORMAL
- en: '"country": "USA",'
  prefs: []
  type: TYPE_NORMAL
- en: '"consent_to_share_data": True,'
  prefs: []
  type: TYPE_NORMAL
- en: '"actions": ['
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"action": "basic subscription",'
  prefs: []
  type: TYPE_NORMAL
- en: '"date": "2021-01-01",'
  prefs: []
  type: TYPE_NORMAL
- en: '"amount": 10,'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"action": "unscription",'
  prefs: []
  type: TYPE_NORMAL
- en: '"date": "2021-05-01",'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '],'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: $ python fill_users_in_mongo.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: from pymongo import MongoClient
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: client = MongoClient("mongodb://localhost:27017/")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: pipeline_redact = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"$redact": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"$cond": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"if": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"$eq": ['
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"$consent_to_share_data", True'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"then": "$$KEEP",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"else": "$$PRUNE",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: pipeline_remove_email_and_name = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"$unset": ["email", "name"]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: obfuscate_day_of_date = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"$concat": ['
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"$substrCP": ['
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"$$action.date",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 0,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 7,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"-XX",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: rebuild_actions_elements = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"input": "$actions",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"as": "action",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"in": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"$mergeObjects": ['
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"$$action",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{"date": obfuscate_day_of_date},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: pipeline_set_actions = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"$set": {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"actions": {"$map": rebuild_actions_elements},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: pipeline = [
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pipeline_redact,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pipeline_remove_email_and_name,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pipeline_set_actions,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'if __name__ == "__main__":'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: client["beat_streaming"].drop_collection(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"users_data_view"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: client["beat_streaming"].create_collection(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"users_data_view",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: viewOn="users",
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pipeline=pipeline,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: users_data_view view will be created in our beat_streaming database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: from fastapi import APIRouter, Depends
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from app.database import mongo_database
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: router = APIRouter(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: prefix="/thirdparty",
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tags=["third party"],
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@router.get("/users/actions")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: async def get_users_with_actions(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: db=Depends(mongo_database),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: users = [
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: user
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: async for user in db.users_data_view.find(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{}, {"_id": 0}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return users
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: from app import third_party_endpoint
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rest of the main.py code
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: app = FastAPI(lifespan=lifespan)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.include_router(third_party_endpoint.router)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rest of the main.py code
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: http://localhost:8000/docs, you can check that the newly created endpoint is
    present and call it to retrieve all the users from the created view without any
    sensible information.
  prefs: []
  type: TYPE_NORMAL
- en: You have just created an endpoint that securely exposes users data. An additional
    layer of security can be added by implementing **role-based access control** (**RBAC**)
    on the endpoint as we have done, for example, in [*Chapter 4*](B21025_04.xhtml#_idTextAnchor122),
    *Authentication and Authorization*, in the recipe *Setting* *up RBAC*.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional layers are often added to secure your data’s application, besides
    data masking. The most important ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encryption** **at rest**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encryption** **in transit**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RBAC**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three services are provided as ready-to-use solutions in enterprise versions
    of MongoDB. The choice of using it or not is at the discretion of software architects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encryption at rest** involves encrypting the data stored in your MongoDB
    database to prevent unauthorized access to sensitive information. The enterprise
    version of MongoDB provides built-in encryption capabilities through the use of
    a dedicated storage engine. By enabling encryption at rest, you can ensure that
    your data is encrypted on disk, making it unreadable to anyone without the proper
    encryption keys.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encryption in transit** ensures that data transmitted between your application
    and the MongoDB server is encrypted to prevent eavesdropping and tampering. MongoDB
    supports encryption in transit using **Transport Layer Security** (**TLS**), which
    encrypts data sent over the network between your application and the MongoDB server.'
  prefs: []
  type: TYPE_NORMAL
- en: '**RBAC** is essential for restricting access to sensitive data in MongoDB databases.
    MongoDB provides robust authentication and authorization mechanisms to control
    access to databases, collections, and documents. You can create user accounts
    with different roles and privileges to ensure that only authorized users can access
    and manipulate sensitive data.'
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB supports RBAC, allowing you to assign specific roles to users based
    on their responsibilities and restrict access to sensitive data accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'In the recipe, we had a quick look at how to create aggregations and views
    in MongoDB. Feel free to look into this more on the official documentation pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MongoDB Aggregations* *Quickstart*: [https://www.mongodb.com/developer/languages/python/python-quickstart-aggregation/](https://www.mongodb.com/developer/languages/python/python-quickstart-aggregation/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*MongoDB Views* *Documentation*: [https://www.mongodb.com/docs/manual/core/views/](https://www.mongodb.com/docs/manual/core/views/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A good example of pushing data masking forward through database aggregations
    in MongoDB can be found at this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '*MongoDB Data Masking* *Example*: [https://github.com/pkdone/mongo-data-masking?tab=readme-ov-file](https://github.com/pkdone/mongo-data-masking?tab=readme-ov-file)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see more about the commands of the aggregation framework on the official
    documentation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Aggregation* *Stage*: [https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/](https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, a comprehensive book on MongoDB aggregations, free to consult, is available
    at this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Practical MongoDB Aggregation* *Book*: [https://www.practical-mongodb-aggregations.com](https://www.practical-mongodb-aggregations.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating FastAPI with Elasticsearch
  prefs: []
  type: TYPE_NORMAL
- en: '**Elasticsearch** is a powerful search engine that provides fast and efficient
    full-text search, real-time analytics, and more. By integrating Elasticsearch
    with FastAPI, you can enable advanced search functionality, including keyword
    search, filtering, and aggregation. We’ll walk through the process of integrating
    Elasticsearch, indexing data, executing search queries, and handling search results
    within a FastAPI application.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a specific endpoint for our streaming platform
    to enable analytics and enhance search capabilities in your web applications.
    Specifically, we will retrieve the top ten artists based on views from a specified
    country.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this recipe, you’ll be equipped with the knowledge and tools to
    leverage Elasticsearch for robust search functionality in your FastAPI projects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs: []
  type: TYPE_NORMAL
- en: To follow along with the recipe, you need a running application or to keep on
    working on our streaming platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, you need an Elasticsearch instance running and reachable at this
    address: `http://localhost:9200`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also install Elasticsearch on your machine by following the official
    guide: [https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.xhtml](https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, if you haven’t installed the packages with `requirements.txt`, you need
    to install the Elasticsearch Python client with the `aiohttp` package in your
    environment. You can do this with `pip` from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: A basic knowledge of **Domain Specific Language** (**DSL**) in Elasticsearch
    can be beneficial to get a deeper understanding of the queries we are going to
    implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the official documentation at this link: [https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.xhtml](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have Elasticsearch installed and running, we can proceed to integrate
    it into our application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs: []
  type: TYPE_NORMAL
- en: 'We break down the process into the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up Elasticsearch in our FastAPI application to allow our API to communicate
    with the Elasticsearch instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Elasticsearch index so that our songs can be indexed and queried by
    Elasticsearch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the query to query our songs index.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the FastAPI endpoint to expose our analytics endpoint to the API users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s look at each of these steps in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Set up Elasticsearch in our FastAPI application
  prefs: []
  type: TYPE_NORMAL
- en: 'To interact with the Elasticsearch server, we need to define the client in
    our Python code. In the `db_connection.py` module, where we already define parameters
    for MongoDB, let’s define the Elasticsearch asynchronous client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a function to check the connection with Elasticsearch in the
    same module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The function will ping the Elasticsearch server and propagate an error if the
    ping fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can call the function at the FastAPI server startup in the `lifetime`
    context manager in the `main.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that the application checks the connection with the Elasticsearch
    server at the startup, and it will propagate an error if the Elasticsearch server
    does not respond.
  prefs: []
  type: TYPE_NORMAL
- en: Create an Elasticsearch index
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we should start by filling our Elasticsearch instance with a collection
    of song documents. In Elasticsearch, a collection is referred to as an *index*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The song document should contain an additional field that tracks information
    about the views per country. For example, a new document song will look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find a list of sampling songs in the file `songs_info.py` in the project
    GitHub repository. If you use the file, you can also define a function to fill
    in the index as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: To group our songs based on the country’s views, we will need to fetch data
    based on the `views_per_country` field, and for the top ten artists, we will group
    based on the `artist` field.
  prefs: []
  type: TYPE_NORMAL
- en: This information should be provided to the indexing process so that Elasticsearch
    understands how to index documents within the index for running queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new module called `fill_elasticsearch_index.py`, we can store this information
    in a `python` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mapping` object will be passed as an argument to the Elasticsearch client
    when creating the index. We can define a function to create our `songs_index`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the function in into a grouping `main()` one, and use the `__main__`
    section of the module to run as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then run the script from the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now that the index is created, we just have to add the songs to the index. You
    can do this by creating a separate script or by running `fill_elasticsearch_index.py`,
    which is provided in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: We have just set up our index filled with documents on our Elasticsearch index.
    Let’s see how to build the query.
  prefs: []
  type: TYPE_NORMAL
- en: Build the query
  prefs: []
  type: TYPE_NORMAL
- en: We will build a function to return the query based on the specified country.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do it in a separate module in the `app` folder called `es_queries.py`.
    The query should fetch all the documents containing the `views_per_country` map
    index for the country and sort the results in descending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we filter the fields that we want in the response as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we return the query in the form of a dictionary by specifying the
    size of the list we will expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We now have the function that will construct the query to retrieve the top ten
    artists for a specified country, and we will utilize it in our endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Create the FastAPI endpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have set up the Elasticsearch connection and formulated the query,
    creating the endpoint is a straightforward process. Let’s define it in a new module
    called `main_search.py` under the `app` folder. Let’s start by defining the router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the endpoint will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The result of the query is further adjusted before being returned to extract
    only the values we are interested in, namely the artist and views.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to include the router in our `FastAPI` object to include the
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.py` module, we can add the router as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you spin up the server with the `uvicorn app.main:app` command and go
    to the interactive documentation at `http://localhost:8000/docs`, you will see
    the newly created endpoint to retrieve the top ten artists in a country based
    on the views of the songs.
  prefs: []
  type: TYPE_NORMAL
- en: You have just created a FastAPI endpoint that interacts with an Elasticsearch
    instance. Feel free to create new endpoints on your own. For example, you can
    create an endpoint to return the top ten songs for a country.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have used the Elasticsearch Python client, feel free to dig more into
    the official documentation pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Elasticsearch Python* *Client*: [https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/index.xhtml](https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/index.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Asyncio with* *Elasticsearch*: [https://elasticsearch-py.readthedocs.io/en/7.x/async.xhtml](https://elasticsearch-py.readthedocs.io/en/7.x/async.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To learn more about Elasticsearch indexes, have a look at the Elasticsearch
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Index* *API*: [https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.xhtml](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find a guide to mapping at this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mapping*: [https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.xhtml](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, you can dig into the search query language at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Query* *DSL*: [https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.xhtml](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Redis for caching in FastAPI
  prefs: []
  type: TYPE_NORMAL
- en: Redis is an in-memory data store that can be used as a cache to improve the
    performance and scalability of FastAPI applications. By caching frequently accessed
    data in Redis, you can reduce the load on your database and speed up response
    times for your API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll explore how to integrate Redis caching into our streaming
    platform application and we will cache an endpoint as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs: []
  type: TYPE_NORMAL
- en: To follow along with the recipe you need a running Redis instance reachable
    at the http://localhost:6379 address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on your machine and your preference, you have several ways to install
    it and run it. Have a look at the Redis documentation to see how to do it for
    your operating system: [https://redis.io/docs/install/install-redis/](https://redis.io/docs/install/install-redis/).'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you need a FastAPI application with an endpoint that is time consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, if you follow the streaming platform, make sure that you have
    created the top ten artists endpoint from the previous recipe, *Integrating FastAPI*
    *with Elasticsearch*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need the Redis client for Python in your environment. If you
    haven’t installed the packages with `requirements.txt`, you do it by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Once the installation is complete, we can proceed with the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Redis is running and reachable at `localhost:6379`, we can integrate the
    Redis client into our code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `db_connection.py` module, where we already defined the clients for
    Mongo and Elasticsearch, let’s add the client for Redis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  Similarly to the other databases, we can create a function that pings the
    Redis server at the application’s startup. The function can be defined as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '3.  Then, include it in the `lifespan` context manager in `main.py`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we can use the `redis_client` object to cache our endpoints. We will cache
    the `GET /search/top/ten/artists` endpoint used to query Elasticsearch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.  In `main_search.py`, we can define a function to retrieve the Redis client
    as a dependency:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '5.  Then, you can modify the endpoint as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '6.  At the beginning of the function, we retrieve the key to store the value
    and check whether the value is already stored in Redis:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '7.  Then, when we see that the data is not present, we continue by getting
    the data from Elasticsearch:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '8.  Once we retrieve the list, we store it in Redis so we can retrieve it at
    the following call:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 9.  We specified an expiring time, which is the time the record will stay in
    Redis in seconds. After that time, the record won’t be available anymore and the
    artists list will be recalled from Elasticsearch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, if you run the server with the `uvicorn app.main:app` command and try to
    call the endpoint for Italy, you will notice that the response time for the second
    call will be much less.
  prefs: []
  type: TYPE_NORMAL
- en: You have just implemented a cache for one of the endpoints of our application
    with Redis. With the same strategy, feel free to cache all the other endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, there is a promising library, `fastapi-cache`, which
    makes caching in FastAPI very easy. Check the GitHub repository: [https://github.com/long2ice/fastapi-cache](https://github.com/long2ice/fastapi-cache).'
  prefs: []
  type: TYPE_NORMAL
- en: The library supports several caching databases, including Redis and in-memory
    caching. With simple endpoint decorators, you can specify caching parameters such
    as time to live, encoder, and cache response header.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'Redis client for Python supports more advanced functionalities. Feel free to
    explore its potential in the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Redis Python* *Client*: [https://redis.io/docs/connect/clients/python/](https://redis.io/docs/connect/clients/python/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Redis Python Asynchronous* *Client*: [https://redis-py.readthedocs.io/en/stable/examples/asyncio_examples.xhtml](https://redis-py.readthedocs.io/en/stable/examples/asyncio_examples.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
