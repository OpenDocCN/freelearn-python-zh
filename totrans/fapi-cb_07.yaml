- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Integrating FastAPI with NoSQL Databases
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 FastAPI 与 NoSQL 数据库集成
- en: In this chapter, we will explore the integration of **FastAPI** with **NoSQL**
    databases. By crafting the backend of a music streaming platform application,
    you will learn how to set up and use **MongoDB**, a popular NoSQL database, with
    FastAPI.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 FastAPI 与 **NoSQL** 数据库的集成。通过构建音乐流媒体平台应用程序的后端，您将学习如何使用 FastAPI 设置和使用流行的
    NoSQL 数据库 **MongoDB**。
- en: You will also learn how to perform **create, read, update and delete** (**CRUD**)
    operations, work with indexes for performance optimization, and handle relationships
    in NoSQL databases. Additionally, you will learn how to integrate FastAPI with
    **Elasticsearch** for powerful search capabilities, secure sensitive data, and
    implement caching using **Redis**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将学习如何执行 **创建、读取、更新和删除** （**CRUD**） 操作，使用索引进行性能优化，以及处理 NoSQL 数据库中的关系。此外，您还将学习如何将
    FastAPI 与 **Elasticsearch** 集成以实现强大的搜索功能，保护敏感数据，并使用 **Redis** 实现缓存。
- en: By the end of this chapter, you will have a solid understanding of how to effectively
    use NoSQL databases with FastAPI to improve the performance and functionality
    of your applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将深入理解如何有效地使用 FastAPI 与 NoSQL 数据库结合，以提升应用程序的性能和功能。
- en: 'In this chapter, we’re going to cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Setting up MongoDB with FastAPI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 FastAPI 设置 MongoDB
- en: CRUD operations in MongoDB
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB 中的 CRUD 操作
- en: Handling relationships in NoSQL databases
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 NoSQL 数据库中的关系
- en: Working with indexes in MongoDB
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 MongoDB 中使用索引
- en: Exposing sensitive data from NoSQL databases
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 NoSQL 数据库中公开敏感数据
- en: Integrating FastAPI with Elasticsearch
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 FastAPI 与 Elasticsearch 集成
- en: Using Redis for caching in FastAPI
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 FastAPI 中使用 Redis 进行缓存
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the recipes of the chapter, ensure your setup includes
    the following essentials:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章的食谱，请确保您的设置包括以下基本要素：
- en: '**Python**: A version 3.7 or higher should be installed on your computer'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python**：应在您的计算机上安装版本 3.7 或更高版本'
- en: '`fastapi` package in your working environment'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的工作环境中的 `fastapi` 包
- en: '`asyncio`: Be familiar with the `asyncio` framework and `async`/`await` syntax
    since we will use it all along the recipes'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio`：熟悉 `asyncio` 框架和 `async`/`await` 语法，因为我们将贯穿整个食谱使用它们'
- en: 'The code used in the chapter is hosted on GitHub at this address: [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter07](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter07).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码托管在 GitHub 上，地址为：[https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter07](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter07)。
- en: You can create a virtual environment for the project within the project root
    folder to manage dependencies efficiently and maintain project isolation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在项目根目录内为项目创建一个虚拟环境，以高效管理依赖项并保持项目隔离。
- en: 'Within your virtual environment, you can install all the dependencies at once
    by using `requirements.txt`, which is provided on the GitHub repository in the
    project folder:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的虚拟环境中，您可以使用 `requirements.txt` 一次性安装所有依赖项，该文件位于 GitHub 仓库的项目文件夹中：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: General knowledge of the external tools we are going to use for each recipe
    can be beneficial, although not mandatory. Each recipe will provide you with a
    minimal explanation of the used tool.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个食谱中将要使用的工具的一般了解可能有益，尽管不是强制性的。每个食谱都将为您提供对所使用工具的最小解释。
- en: Setting up MongoDB with FastAPI
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 FastAPI 设置 MongoDB
- en: In this recipe, you will learn how to set up MongoDB, a popular document-oriented
    NoSQL database, with FastAPI. You will learn how to manage Python packages to
    interact with MongoDB, create a database, and connect it to a FastAPI application.
    By the end of this recipe, you will have a solid understanding of how to integrate
    MongoDB with FastAPI to store and retrieve data for your applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将学习如何使用 FastAPI 设置流行的文档型 NoSQL 数据库 **MongoDB**。您将学习如何管理 Python 包以与 MongoDB
    交互，创建数据库，并将其连接到 FastAPI 应用程序。到食谱结束时，您将深入理解如何将 MongoDB 与 FastAPI 集成以存储和检索应用程序数据。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow along with this recipe, you need Python and `fastapi package` installed
    in your environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随这个食谱，您需要在您的环境中安装 Python 和 `fastapi package`。
- en: 'Also, for this recipe, make sure you have a MongoDB instance running and reachable,
    and if not, set up a local one. Depending on your operating system and your personal
    preference, you can set up a local MongoDB instance in several ways. Feel free
    to consult the official documentation on how to install the community edition
    of MongoDB on your local machine at the following link: [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于这个配方，确保你有一个正在运行且可访问的 MongoDB 实例，如果没有，请设置一个本地的。根据你的操作系统和你的个人偏好，你可以通过以下几种方式设置本地的
    MongoDB 实例。请自由查阅以下链接上的官方文档，了解如何在你的本地机器上安装 MongoDB 社区版：[https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community)。
- en: For the recipe and throughout the chapter, we will consider a local instance
    of MongoDB running on http://localhost:27017\. If you run the MongoDB instance
    on a remote machine, or simply use a different port, adjust the URL reference
    accordingly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个章节中，我们将考虑运行在 http://localhost:27017 的 MongoDB 的本地实例。如果你在远程机器上运行 MongoDB 实例，或者使用不同的端口，请相应地调整
    URL 引用。
- en: 'You also need the `motor` package installed in your environment. If you haven’t
    installed the packages with `requirements.txt`, you can install `motor` in your
    environment from the command line:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在你的环境中安装 `motor` 包。如果你还没有使用 `requirements.txt` 安装包，你可以从命令行在你的环境中安装 `motor`：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`asyncio` library.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio` 库。'
- en: Once we have the MongoDB instance running and reachable and the `motor` package
    installed in your environment, we can proceed with the recipe.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了正在运行且可访问的 MongoDB 实例，并且你的环境中已安装了 `motor` 包，我们就可以继续进行配方。
- en: How to do it…
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let’s start by creating a project root folder called `streaming_platform` with
    an `app` subfolder. In `app`, we create a module called `db_connection.py`, which
    will contain the information on the connection with MongoDB.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个名为 `streaming_platform` 的项目根文件夹，其中包含一个 `app` 子文件夹。在 `app` 中，我们创建一个名为
    `db_connection.py` 的模块，其中将包含与 MongoDB 的连接信息。
- en: 'Now, we will set up the connection through the following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过以下步骤设置连接：
- en: 'In the `db_connecion.py` module, let’s define the MongoDB client:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `db_connecion.py` 模块中，让我们定义 MongoDB 客户端：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will use the `mongo_client` object each time we need to interact with the
    MongoDB instance that is running at http://localhost:27017.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将每次需要与运行在 http://localhost:27017 的 MongoDB 实例交互时使用 `mongo_client` 对象。
- en: 'In the `db_connection.py` module, we will create a function to ping the MongoDB
    instance to ensure it is running. But first, we retrieve the `uvicorn` logger,
    used by the FastAPI server, to print messages to the terminal:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `db_connection.py` 模块中，我们将创建一个函数来ping MongoDB 实例以确保它正在运行。但首先，我们检索 FastAPI
    服务器使用的 `uvicorn` 日志记录器，以便将消息打印到终端：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, let’s create the function to ping the MongoDB as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个函数来ping MongoDB，如下所示：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The function will ping the server, and if it doesn’t receive any response, it
    will propagate an error that will stop the code from running.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数将ping服务器，如果它没有收到任何响应，它将传播一个错误，这将停止代码的运行。
- en: 'Finally, we need to run the `ping_mongo_db_server` function when starting the
    FastAPI server. In the `app` folder, let’s create a `main.py` module with a context
    manager that will be used for the startup and shutdown of our FastAPI server:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要在启动 FastAPI 服务器时运行 `ping_mongo_db_server` 函数。在 `app` 文件夹中，让我们创建一个 `main.py`
    模块，其中包含用于启动和关闭我们的 FastAPI 服务器的上下文管理器：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `lifespan` context manager has to be passed as an argument to the `FastAPI`
    object:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`lifespan` 上下文管理器必须作为参数传递给 `FastAPI` 对象：'
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The server is wrapped in the `lifespan` context manager to execute the database
    check at startup.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 服务器被包装在 `lifespan` 上下文管理器中，以在启动时执行数据库检查。
- en: 'To test it, make sure your MongoDB instance is already running and as usual,
    let’s spin up the server from the command line:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，确保你的 MongoDB 实例已经运行，并且像往常一样，让我们从命令行启动服务器：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will see the following log messages on the output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在输出中看到以下日志消息：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This message confirms that our application correctly communicates with the MongoDB
    instance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此消息确认我们的应用程序正确地与 MongoDB 实例进行了通信。
- en: You’ve just set up the connection between a FastAPI application and a MongoDB
    instance.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚设置了 FastAPI 应用程序和 MongoDB 实例之间的连接。
- en: See also
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can see more on the Motor asynchronous driver on the MongoDB official documentation
    page:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 MongoDB 官方文档页面上了解更多关于 Motor 异步驱动程序的信息：
- en: '*Motor Async Driver* *Setup*: https://www.mongodb.com/docs/drivers/motor/'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Motor Async Driver* *设置*: https://www.mongodb.com/docs/drivers/motor/'
- en: 'For startups and shutdown events of the FastAPI server, you can find more on
    this page:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于FastAPI服务器的启动和关闭事件，您可以在本页面上找到更多信息：
- en: '*FastAPI Lifespan* *Events*: [https://fastapi.tiangolo.com/advanced/events/](https://fastapi.tiangolo.com/advanced/events/)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FastAPI生命周期* *事件*: [https://fastapi.tiangolo.com/advanced/events/](https://fastapi.tiangolo.com/advanced/events/)'
- en: CRUD operations in MongoDB
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB中的CRUD操作
- en: CRUD operations form the cornerstone of data manipulation in databases, enabling
    users to create, read, update, and delete data entities with efficiency, flexibility,
    and scalability.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD操作是数据库数据操作的基础，使用户能够以高效、灵活和可扩展的方式创建、读取、更新和删除数据实体。
- en: This recipe will demonstrate how to create endpoints in FastAPI for creating,
    reading, updating, and deleting a document from a MongoDB database for the backbone
    of our streaming platform.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将演示如何在FastAPI中创建端点，用于从MongoDB数据库创建、读取、更新和删除文档，这是我们流平台的核心。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow along with the recipe, you need a database connection with MongoDB
    already in place with your application, otherwise, go to the previous recipe,
    *Setting up MongoDB with FastAPI*, which will show you in detail how to do it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随这个食谱，您需要一个数据库连接，MongoDB已经与您的应用程序一起设置好了，否则，请回到之前的食谱，*使用FastAPI设置MongoDB*，它将详细展示如何进行设置。
- en: How to do it…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Before creating the endpoints for the CRUD operations, we have to initialize
    a database on the MongoDB instance for our streaming application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建CRUD操作的端点之前，我们必须在MongoDB实例上初始化一个数据库，用于我们的流应用程序。
- en: 'Let’s do it in a dedicated module in the `app` directory called `database.py`
    as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`app`目录下的一个名为`database.py`的专用模块中这样做，如下所示：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ve defined a database called `beat_streaming`, which will contain all the
    collections of our application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个名为`beat_streaming`的数据库，它将包含我们应用程序的所有集合。
- en: On the MongoDB server side, we don’t need any action to do since the `motor`
    library will automatically check for the existence of a database named `beat_streaming`
    and the eventual collections, and it will create them if they don’t exist.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB服务器端，我们不需要采取任何行动，因为`motor`库将自动检查名为`beat_streaming`的数据库以及最终集合的存在性，如果它们不存在，它将创建它们。
- en: 'In the same module, we can create the function to return the database that
    will be used as a dependency in the endpoints for code maintainability:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个模块中，我们可以创建一个函数来返回将作为端点依赖项使用的数据库，以提高代码的可维护性：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we can define our endpoints in `main.py` for each of the CRUD operations
    through the following steps.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`main.py`中定义我们的端点，用于每个CRUD操作，步骤如下。
- en: 'Let’s start by creating the endpoint to add a song to the `songs` collection:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建添加歌曲到`songs`集合的端点开始：
- en: '[PRE11]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The endpoint takes a general JSON in the body and returns the ID affected from
    the database. The `ENCONDERS_BY_TYPE[ObjectID] = str` line specifies to the FastAPI
    server that the `song["_id"]` document ID has to be decoded as a `string`.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该端点在体中接受一个通用的JSON，并从数据库返回受影响的ID。`ENCONDERS_BY_TYPE[ObjectID] = str`这一行指定FastAPI服务器，`song["_id"]`文档ID必须解码为`string`。
- en: One of the reasons to choose a NoSQL database is the freedom from SQL schema,
    which allows for more flexibility in managing data. However, it can be helpful
    to provide an example to follow in the documentation. This is achieved by using
    the `Body` object class with the example parameter.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择NoSQL数据库的一个原因是不受SQL模式限制，这允许在管理数据时具有更大的灵活性。然而，在文档中提供一个示例可能会有所帮助。这是通过使用带有示例参数的`Body`对象类来实现的。
- en: 'The endpoint to retrieve a song will be quite straightforward:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取歌曲的端点将非常直接：
- en: '[PRE12]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The application will search for a song with the specified ID and return a `404`
    error if none is found.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用程序将搜索具有指定ID的歌曲，如果找不到，则返回`404`错误。
- en: 'To update a song, the endpoint will look like this:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更新歌曲，端点将看起来像这样：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The endpoint will return a `404` error if the song id does not exist, otherwise
    it will update only the fields specified in the body request.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果歌曲ID不存在，端点将返回`404`错误，否则它将只更新请求体中指定的字段。
- en: 'Finally, the `delete` operation endpoint can be done as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`delete`操作端点可以如下完成：
- en: '[PRE14]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You have just created the endpoints to interact with a MongoDB database.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您刚刚创建了与MongoDB数据库交互的端点。
- en: Now, spin up the server from the command line and test the endpoints you just
    created from the interactive documentation at http://localhost:8000/docs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从命令行启动服务器并测试您刚刚在http://localhost:8000/docs的交互式文档中创建的端点。
- en: 'If you follow along with the GitHub repository, you can also prefill the database
    with the script `fill_mongo_db_database.py` at the link: [https://github.com/PacktPublishing/FastAPI-Cookbook/blob/main/Chapter07/streaming_platform/fill_mongo_db_database.py](https://github.com/PacktPublishing/FastAPI-Cookbook/blob/main/Chapter07/streaming_platform/fill_mongo_db_database.py)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您跟随GitHub存储库，您还可以使用链接中的脚本`fill_mongo_db_database.py`预先填充数据库：[https://github.com/PacktPublishing/FastAPI-Cookbook/blob/main/Chapter07/streaming_platform/fill_mongo_db_database.py](https://github.com/PacktPublishing/FastAPI-Cookbook/blob/main/Chapter07/streaming_platform/fill_mongo_db_database.py)
- en: Make sure you download also the `songs_info.py` in the same folder.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您还下载了同一文件夹中的`songs_info.py`。
- en: 'You can then run the script from the terminal as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从终端按照以下方式运行脚本：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you call the endpoint `GET /songs` you will have a long list of songs pre
    filled to test your API.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您调用端点`GET /songs`，您将有一个预先填充的长列表歌曲以测试您的API。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: 'You can investigate the operations provided by `motor` to interact with a MongoDB
    instance further at the official documentation link:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档链接中进一步调查`motor`提供的操作：
- en: '*Motor MongoDB Aynscio* *Tutorial*: [https://motor.readthedocs.io/en/stable/tutorial-asyncio.xhtml](https://motor.readthedocs.io/en/stable/tutorial-asyncio.xhtml)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Motor MongoDB Aynscio* *教程*: [https://motor.readthedocs.io/en/stable/tutorial-asyncio.xhtml](https://motor.readthedocs.io/en/stable/tutorial-asyncio.xhtml)'
- en: Handling relationships in NoSQL databases
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在NoSQL数据库中处理关系
- en: Unlike relational databases, NoSQL databases do not support joins or foreign
    keys for defining relationships between collections.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与关系型数据库不同，NoSQL数据库不支持连接或外键来定义集合之间的关系。
- en: 'Schema-less databases, such as MongoDB, do not enforce relationships like traditional
    relational databases. Instead, two primary approaches can be used for handling
    relationships: **embedding** and **referencing**.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无模式数据库，如MongoDB，不强制执行像传统关系型数据库那样的关系。相反，可以使用两种主要方法来处理关系：**嵌入**和**引用**。
- en: Embedding involves storing related data within a single document. This approach
    is suitable for all types of relationships, provided that the embedded data is
    closely tied to the parent document. This technique is good for read performance
    for frequently accessed data and atomic updates with a single document. However,
    it can easily lead to size limitation problems with data duplication and potential
    inconsistencies if the embedded data changes frequently.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入涉及在单个文档中存储相关数据。这种方法适用于所有类型的关联，前提是嵌入的数据与父文档紧密相关。这种技术对于频繁访问的数据和单个文档的原子更新来说，对读取性能很有好处。然而，如果嵌入的数据频繁更改，它很容易导致数据重复和潜在的不一致性，从而引发大小限制问题。
- en: Referencing involves storing references to related documents using their object
    ID or other unique identifiers. This approach is suitable for many-to-one and
    many-to-many relationships where the related data is huge and is shared across
    multiple documents.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**引用**涉及使用它们的对象ID或其他唯一标识符存储相关文档的引用。这种方法适用于多对一和多对多关系，其中相关数据很大，并且跨多个文档共享。'
- en: This technique reduces data duplication and improves flexibility to update related
    data independently, but, on the other hand, increases the complexity of reading
    operations due to multiple queries leading to slower performances when fetching
    related data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术减少了数据重复，提高了独立更新相关数据的灵活性，但另一方面，由于多个查询导致读取操作的复杂性增加，从而在检索相关数据时性能变慢。
- en: In this recipe, we’ll explore both techniques for handling relationships between
    data entities in MongoDB by adding new collections to our streaming platform and
    making them interact.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将通过向我们的流平台添加新的集合并使它们交互，来探索在MongoDB中处理数据实体之间关系的技术。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue building our streaming platform. Make sure you have followed
    all the previous recipes in this chapter, or you can apply the steps to an existing
    application that interacts with a NoSQL database.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续构建我们的流平台。请确保您已经遵循了本章中所有之前的食谱，或者您可以将这些步骤应用于与NoSQL数据库交互的现有应用程序。
- en: How to do it…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现它...
- en: Let’s see how to implement relationships for both embedding and referencing
    techniques.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现嵌入和引用技术的关系。
- en: Embedding
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌入
- en: A suitable candidate to showcase embedded relationships for songs is a collection
    of albums. Album information does not change often, if not never, once it is published.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 展示歌曲嵌入关系的合适候选者是专辑集合。一旦发布，专辑信息很少改变，甚至从不改变。
- en: 'The `album` document will embedded into the `song` document with a nested field:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`album`文档将嵌套字段嵌入到`song`文档中：'
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When using MongoDB, we can retrieve information about an album and a song using
    the same endpoint. This means that when we create a new song, we can directly
    add information about the album it belongs to. We specify the way we want the
    document song to be stored, and MongoDB takes care of the rest.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用MongoDB时，我们可以使用相同的端点检索有关专辑和歌曲的信息。这意味着当我们创建一首新歌时，我们可以直接添加它所属专辑的信息。我们指定文档song的存储方式，MongoDB负责其余部分。
- en: Spin up the server and test the `POST /song` endpoint. In the JSON body, include
    information about the album. Take note of the ID retrieved and use it to call
    the `GET /song` endpoint. Since we haven’t defined any response schema restriction
    in the response model, the endpoint will return all the document information retrieved
    from the database including the album.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务器并测试`POST /song`端点。在JSON体中包含有关专辑的信息。注意检索到的ID，并使用它来调用`GET /song`端点。由于我们尚未在响应模型中定义任何响应模式限制，端点将返回从数据库检索到的所有文档信息，包括专辑。
- en: For this use case example, there is nothing to worry about, but for some applications,
    you might not want to disclose a field to the end user. You can either define
    a response model (see [*Chapter 1*](B21025_01.xhtml#_idTextAnchor020), *First
    Steps with FastAPI*, in the *Defining and using request and response models* recipe)
    or drop the field from the `dict` object before it is returned.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个用例示例，没有必要担心，但对于某些应用程序，你可能不希望向最终用户披露一个字段。你可以定义一个响应模型（参见[*第1章*](B21025_01.xhtml#_idTextAnchor020)，*使用FastAPI的初步步骤*，在*定义和使用请求和响应模型*食谱中）或者在该字段从`dict`对象返回之前将其删除。
- en: You have just defined a many-to-one relationship with the embedding strategy
    that relates songs to albums.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚定义了一个使用嵌入策略的多对一关系，将歌曲与专辑相关联。
- en: Referencing
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用
- en: A typical use case for referencing relationships can be the creation of a playlist.
    A playlist contains multiple songs, and each song can appear in different playlists.
    Furthermore, playlists are often changed or updated, so it respond to the need
    for a referencing strategy to manage relationships.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 引用关系的典型用例可以是创建播放列表。播放列表包含多首歌曲，每首歌曲可以出现在不同的播放列表中。此外，播放列表通常会被更改或更新，因此需要一个引用策略来管理这些关系。
- en: On the database side, we don’t need any action so we will directly proceed to
    create the endpoint to create the playlist and the one to retrieve the playlist
    with all song information.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库方面，我们不需要采取任何行动，因此我们将直接创建创建播放列表和检索包含所有歌曲信息的播放列表的端点。
- en: 'You can define the endpoint to create a playlist in the `main.py` module:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在`main.py`模块中定义创建播放列表的端点：
- en: '[PRE17]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The endpoint requires a JSON body specifying the playlist name and the list
    of song IDs to include, and it returns the playlist ID.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该端点需要一个JSON体，指定播放列表名称和要包含的歌曲ID列表，并返回播放列表ID。
- en: 'The endpoint to retrieve the playlist will take as an argument the playlist
    ID. You can code it as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取播放列表的端点将接受播放列表ID作为参数。你可以这样编写代码：
- en: '[PRE18]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that the song IDs in the playlist collection are stored as strings, not
    `ObjectId`, which means that they have to be converted when queried.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，播放列表集合中的歌曲ID存储为字符串，而不是`ObjectId`，这意味着在查询时必须进行转换。
- en: 'Also, to receive the list of songs for the playlist, we had to make two queries:
    one for the playlist and one to retrieve the songs based on their IDs.'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，为了接收播放列表的歌曲列表，我们不得不进行两次查询：一次用于播放列表，一次用于根据ID检索歌曲。
- en: 'Now that you build the endpoints to create and retrieve playlists, spin up
    the server:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经构建了创建和检索播放列表的端点，启动服务器：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '@app.get("/songs/year")'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '@app.get("/songs/year")'
- en: async def get_songs_by_released_year(
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: async def get_songs_by_released_year(
- en: 'year: int,'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'year: int,'
- en: db=Depends(mongo_database),
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: db=Depends(mongo_database),
- en: '):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '):'
- en: 'query = db.songs.find({"album.release_year": year})'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'query = db.songs.find({"album.release_year": year})'
- en: songs = await query.to_list(None)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: songs = await query.to_list(None)
- en: return songs
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 返回songs
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '@asynccontextmanager'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '@asynccontextmanager'
- en: 'async def lifespan(app: FastAPI):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 'async def lifespan(app: FastAPI):'
- en: await ping_mongo_db_server(),
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 等待ping_mongo_db_server()，
- en: db = mongo_database()
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: db = mongo_database()
- en: 'await db.songs.create_index({"album.release_year": -1})'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'await db.songs.create_index({"album.release_year": -1})'
- en: yield
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: yield
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '@app.get("/songs/year")'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '@app.get("/songs/year")'
- en: async def get_songs_by_released_year(
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: async def get_songs_by_released_year(
- en: 'year: int,'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'year: int,'
- en: db=Depends(mongo_database),
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: db=Depends(mongo_database),
- en: '):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '):'
- en: 'query = db.songs.find({"album.release_year": year})'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'query = db.songs.find({"album.release_year": year})'
- en: explained_query = await query.explain()
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: explained_query = await query.explain()
- en: logger.info(
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: logger.info(
- en: '"Index used: %s",'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '"Index used: %s",'
- en: explained_query.get("queryPlanner", {})
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: explained_query.get("queryPlanner", {})
- en: .get("winningPlan", {})
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: .get("winningPlan", {})
- en: .get("inputStage", {})
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: .get("inputStage", {})
- en: .get("indexName", "No index used"),
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: .get("indexName", "No index used"),
- en: )
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: songs = await query.to_list(None)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: songs = await query.to_list(None)
- en: return songs
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: return songs
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'INFO:    Index used: album.release_year_-1'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 'INFO:    Index used: album.release_year_-1'
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '@asynccontextmanager'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '@asynccontextmanager'
- en: 'async def lifespan(app: FastAPI):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 'async def lifespan(app: FastAPI):'
- en: await ping_mongodb_server(),
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: await ping_mongodb_server(),
- en: db = mongo_database()
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: db = mongo_database()
- en: await db.songs.drop_indexes()
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: await db.songs.drop_indexes()
- en: 'await db.songs.create_index({"release_year": -1})'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'await db.songs.create_index({"release_year": -1})'
- en: 'await db.songs.create_index({"artist": "text"})'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'await db.songs.create_index({"artist": "text"})'
- en: yield
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: yield
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '@app.get("/songs/artist")'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '@app.get("/songs/artist")'
- en: async def get_songs_by_artist(
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: async def get_songs_by_artist(
- en: 'artist: str,'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 'artist: str,'
- en: db=Depends(mongo_database),
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: db=Depends(mongo_database),
- en: '):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '):'
- en: query = db.songs.find(
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: query = db.songs.find(
- en: '{"$text": {"$search": artist}}'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '{"$text": {"$search": artist}}'
- en: )
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: explained_query = await query.explain()
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: explained_query = await query.explain()
- en: logger.info(
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: logger.info(
- en: '"Index used: %s",'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '"Index used: %s",'
- en: explained_query.get("queryPlanner", {})
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: explained_query.get("queryPlanner", {})
- en: .get("winningPlan", {})
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: .get("winningPlan", {})
- en: .get("indexName", "No index used"),
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: .get("indexName", "No index used"),
- en: )
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: songs = await query.to_list(None)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: songs = await query.to_list(None)
- en: return songs
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: return songs
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: $ uvicorn app.main:app
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: $ uvicorn app.main:app
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: http://localhost:8000/songs/artist?artist=mars
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: http://localhost:8000/songs/artist?artist=mars
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '['
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '['
- en: '{'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"_id": "667038acde3a00e55e764cf7",'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '"_id": "667038acde3a00e55e764cf7",'
- en: '"title": "Uptown Funk",'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '"title": "Uptown Funk",'
- en: '"artist": "Mark Ronson ft. Bruno Mars",'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '"artist": "Mark Ronson ft. Bruno Mars",'
- en: '"genre": "Funk/pop",'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '"genre": "Funk/pop",'
- en: '"album": {'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '"album": {'
- en: '"title": "Uptown Special",'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '"title": "Uptown Special",'
- en: '"release_year": 2014'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '"release_year": 2014'
- en: '}'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ']'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'INFO:    Index used: artist_text'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'INFO:    Index used: artist_text'
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '{'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"name": "John Doe",'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "John Doe",'
- en: '"email": "johndoe@email.com",'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '"email": "johndoe@email.com",'
- en: '"year_of_birth": 1990,'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '"year_of_birth": 1990,'
- en: '"country": "USA",'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '"country": "USA",'
- en: '"consent_to_share_data": True,'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '"consent_to_share_data": True,'
- en: '"actions": ['
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '"actions": ['
- en: '{'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"action": "basic subscription",'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '"action": "basic subscription",'
- en: '"date": "2021-01-01",'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '"date": "2021-01-01",'
- en: '"amount": 10,'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '"amount": 10,'
- en: '},'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '{'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"action": "unscription",'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '"action": "unscription",'
- en: '"date": "2021-05-01",'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '"date": "2021-05-01",'
- en: '},'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '],'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '}'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: $ python fill_users_in_mongo.py
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: $ python fill_users_in_mongo.py
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: from pymongo import MongoClient
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from pymongo import MongoClient
- en: client = MongoClient("mongodb://localhost:27017/")
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: client = MongoClient("mongodb://localhost:27017/")
- en: '[PRE32]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: pipeline_redact = {
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pipeline_redact = {
- en: '"$redact": {'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"$redact": {'
- en: '"$cond": {'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"$cond": {'
- en: '"if": {'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"if": {'
- en: '"$eq": ['
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"$eq": ['
- en: '"$consent_to_share_data", True'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"$consent_to_share_data", True'
- en: ']'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: '},'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: '"then": "$$KEEP",'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"then": "$$KEEP",'
- en: '"else": "$$PRUNE",'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"else": "$$PRUNE",'
- en: '}'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE33]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: pipeline_remove_email_and_name = {
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pipeline_remove_email_and_name = {
- en: '"$unset": ["email", "name"]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"$unset": ["email", "name"]'
- en: '}'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE34]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: obfuscate_day_of_date = {
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: obfuscate_day_of_date = {
- en: '"$concat": ['
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"$concat": ['
- en: '{'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"$substrCP": ['
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"$substrCP": ['
- en: '"$$action.date",'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"$$action.date",'
- en: 0,
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 0,
- en: 7,
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 7,
- en: ']'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: '},'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: '"-XX",'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"-XX",'
- en: ']'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: '}'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE35]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: rebuild_actions_elements = {
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: rebuild_actions_elements = {
- en: '"input": "$actions",'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"input": "$actions",'
- en: '"as": "action",'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"as": "action",'
- en: '"in": {'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"in": {'
- en: '"$mergeObjects": ['
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"$mergeObjects": ['
- en: '"$$action",'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"$$action",'
- en: '{"date": obfuscate_day_of_date},'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{"date": obfuscate_day_of_date},'
- en: ']'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: '},'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: '}'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE36]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: pipeline_set_actions = {
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pipeline_set_actions = {
- en: '"$set": {'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"$set": {'
- en: '"actions": {"$map": rebuild_actions_elements},'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"actions": {"$map": rebuild_actions_elements},'
- en: '}'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE37]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: pipeline = [
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pipeline = [
- en: pipeline_redact,
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pipeline_redact,
- en: pipeline_remove_email_and_name,
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pipeline_remove_email_and_name,
- en: pipeline_set_actions,
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pipeline_set_actions,
- en: ']'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: '[PRE38]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'if __name__ == "__main__":'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: client["beat_streaming"].drop_collection(
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: client["beat_streaming"].drop_collection(
- en: '"users_data_view"'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"users_data_view"'
- en: )
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: client["beat_streaming"].create_collection(
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: client["beat_streaming"].create_collection(
- en: '"users_data_view",'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"users_data_view",'
- en: viewOn="users",
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: viewOn="users",
- en: pipeline=pipeline,
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pipeline=pipeline,
- en: )
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: users_data_view view will be created in our beat_streaming database.
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: users_data_view view will be created in our beat_streaming database.
- en: '[PRE39]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: from fastapi import APIRouter, Depends
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from fastapi import APIRouter, Depends
- en: from app.database import mongo_database
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from app.database import mongo_database
- en: router = APIRouter(
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: router = APIRouter(
- en: prefix="/thirdparty",
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: prefix="/thirdparty",
- en: tags=["third party"],
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: tags=["third party"],
- en: )
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: '[PRE40]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '@router.get("/users/actions")'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@router.get("/users/actions")'
- en: async def get_users_with_actions(
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: async def get_users_with_actions(
- en: db=Depends(mongo_database),
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: db=Depends(mongo_database),
- en: '):'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '):'
- en: users = [
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: users = [
- en: user
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: user
- en: async for user in db.users_data_view.find(
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: async for user in db.users_data_view.find(
- en: '{}, {"_id": 0}'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{}, {"_id": 0}'
- en: )
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: ']'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: return users
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return users
- en: '[PRE41]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: from app import third_party_endpoint
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from app import third_party_endpoint
- en: rest of the main.py code
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: rest of the main.py code
- en: app = FastAPI(lifespan=lifespan)
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: app = FastAPI(lifespan=lifespan)
- en: app.include_router(third_party_endpoint.router)
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: app.include_router(third_party_endpoint.router)
- en: rest of the main.py code
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: rest of the main.py code
- en: '[PRE42]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: http://localhost:8000/docs, you can check that the newly created endpoint is
    present and call it to retrieve all the users from the created view without any
    sensible information.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问http://localhost:8000/docs，您可以检查新创建的端点是否存在，并调用它以检索创建的视图中的所有用户，而无需任何敏感信息。
- en: You have just created an endpoint that securely exposes users data. An additional
    layer of security can be added by implementing **role-based access control** (**RBAC**)
    on the endpoint as we have done, for example, in [*Chapter 4*](B21025_04.xhtml#_idTextAnchor122),
    *Authentication and Authorization*, in the recipe *Setting* *up RBAC*.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚创建了一个安全地公开用户数据的端点。可以通过在端点上实现**基于角色的访问控制**（RBAC），例如在配方*设置* *RBAC*中的[第4章](B21025_04.xhtml#_idTextAnchor122)
    *身份验证和授权*中，添加一个额外的安全层。
- en: There’s more…
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Additional layers are often added to secure your data’s application, besides
    data masking. The most important ones are as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据脱敏之外，通常还会添加额外的层来保护您的数据应用。其中最重要的如下：
- en: '**Encryption** **at rest**'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态加密**'
- en: '**Encryption** **in transit**'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输加密**'
- en: '**RBAC**'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于角色的访问控制**（RBAC）'
- en: The three services are provided as ready-to-use solutions in enterprise versions
    of MongoDB. The choice of using it or not is at the discretion of software architects.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的企业版本提供了三个现成的服务解决方案。是否使用它们由软件架构师自行决定。
- en: '**Encryption at rest** involves encrypting the data stored in your MongoDB
    database to prevent unauthorized access to sensitive information. The enterprise
    version of MongoDB provides built-in encryption capabilities through the use of
    a dedicated storage engine. By enabling encryption at rest, you can ensure that
    your data is encrypted on disk, making it unreadable to anyone without the proper
    encryption keys.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态加密**涉及加密存储在MongoDB数据库中的数据，以防止未经授权访问敏感信息。MongoDB的企业版本通过使用专用存储引擎提供内置的加密功能。通过启用静态加密，您可以确保数据在磁盘上加密，使得没有适当加密密钥的人无法读取。'
- en: '**Encryption in transit** ensures that data transmitted between your application
    and the MongoDB server is encrypted to prevent eavesdropping and tampering. MongoDB
    supports encryption in transit using **Transport Layer Security** (**TLS**), which
    encrypts data sent over the network between your application and the MongoDB server.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输加密**确保在您的应用程序和MongoDB服务器之间传输的数据被加密，以防止窃听和篡改。MongoDB支持使用**传输层安全性**（**TLS**）进行传输加密，它加密在您的应用程序和MongoDB服务器之间通过网络发送的数据。'
- en: '**RBAC** is essential for restricting access to sensitive data in MongoDB databases.
    MongoDB provides robust authentication and authorization mechanisms to control
    access to databases, collections, and documents. You can create user accounts
    with different roles and privileges to ensure that only authorized users can access
    and manipulate sensitive data.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于角色的访问控制**（RBAC）对于限制MongoDB数据库中敏感数据的访问至关重要。MongoDB提供了强大的身份验证和授权机制来控制对数据库、集合和文档的访问。您可以根据不同的角色和权限创建用户账户，以确保只有授权用户可以访问和操作敏感数据。'
- en: MongoDB supports RBAC, allowing you to assign specific roles to users based
    on their responsibilities and restrict access to sensitive data accordingly.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB支持RBAC，允许您根据用户的责任分配特定的角色，并相应地限制对敏感数据的访问。
- en: See also
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: 'In the recipe, we had a quick look at how to create aggregations and views
    in MongoDB. Feel free to look into this more on the official documentation pages:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方中，我们简要地了解了如何在MongoDB中创建聚合和视图。您可以自由地查看官方文档页面上的更多内容：
- en: '*MongoDB Aggregations* *Quickstart*: [https://www.mongodb.com/developer/languages/python/python-quickstart-aggregation/](https://www.mongodb.com/developer/languages/python/python-quickstart-aggregation/)'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MongoDB聚合* *快速入门*: [https://www.mongodb.com/developer/languages/python/python-quickstart-aggregation/](https://www.mongodb.com/developer/languages/python/python-quickstart-aggregation/)'
- en: '*MongoDB Views* *Documentation*: [https://www.mongodb.com/docs/manual/core/views/](https://www.mongodb.com/docs/manual/core/views/)'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MongoDB视图* *文档*: [https://www.mongodb.com/docs/manual/core/views/](https://www.mongodb.com/docs/manual/core/views/)'
- en: 'A good example of pushing data masking forward through database aggregations
    in MongoDB can be found at this link:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在此链接中可以找到一个很好的例子，展示了如何在MongoDB中通过数据库聚合推进数据脱敏：
- en: '*MongoDB Data Masking* *Example*: [https://github.com/pkdone/mongo-data-masking?tab=readme-ov-file](https://github.com/pkdone/mongo-data-masking?tab=readme-ov-file)'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MongoDB数据脱敏* *示例*: [https://github.com/pkdone/mongo-data-masking?tab=readme-ov-file](https://github.com/pkdone/mongo-data-masking?tab=readme-ov-file)'
- en: 'You can see more about the commands of the aggregation framework on the official
    documentation page:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档页面上了解更多关于聚合框架命令的信息：
- en: '*Aggregation* *Stage*: [https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/](https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*聚合* 阶段：[https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/](https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/)'
- en: 'Also, a comprehensive book on MongoDB aggregations, free to consult, is available
    at this link:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一本关于 MongoDB 聚合的全面书籍，免费查阅，可在以下链接找到：
- en: '*Practical MongoDB Aggregation* *Book*: [https://www.practical-mongodb-aggregations.com](https://www.practical-mongodb-aggregations.com)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《实用 MongoDB 聚合》* 书籍：[https://www.practical-mongodb-aggregations.com](https://www.practical-mongodb-aggregations.com)'
- en: Integrating FastAPI with Elasticsearch
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 将 FastAPI 与 Elasticsearch 集成
- en: '**Elasticsearch** is a powerful search engine that provides fast and efficient
    full-text search, real-time analytics, and more. By integrating Elasticsearch
    with FastAPI, you can enable advanced search functionality, including keyword
    search, filtering, and aggregation. We’ll walk through the process of integrating
    Elasticsearch, indexing data, executing search queries, and handling search results
    within a FastAPI application.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**Elasticsearch** 是一个功能强大的搜索引擎，提供快速高效的全文本搜索、实时分析和更多功能。通过将 Elasticsearch 与 FastAPI
    集成，您可以启用高级搜索功能，包括关键字搜索、过滤和聚合。我们将逐步介绍在 FastAPI 应用程序中集成 Elasticsearch、索引数据、执行搜索查询和处理搜索结果的过程。'
- en: In this recipe, we will create a specific endpoint for our streaming platform
    to enable analytics and enhance search capabilities in your web applications.
    Specifically, we will retrieve the top ten artists based on views from a specified
    country.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将为我们的流媒体平台创建一个特定的端点，以启用分析和增强您的 Web 应用程序的搜索功能。具体来说，我们将根据指定国家的观看次数检索前十个艺术家。
- en: By the end of this recipe, you’ll be equipped with the knowledge and tools to
    leverage Elasticsearch for robust search functionality in your FastAPI projects.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 到本菜谱结束时，您将具备利用 Elasticsearch 在 FastAPI 项目中实现强大搜索功能的知识和工具。
- en: Getting ready
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow along with the recipe, you need a running application or to keep on
    working on our streaming platform.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本菜谱，您需要一个正在运行的应用程序或继续在我们的流媒体平台上工作。
- en: 'Furthermore, you need an Elasticsearch instance running and reachable at this
    address: `http://localhost:9200`.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您需要一个运行中的 Elasticsearch 实例，并且可以通过此地址访问：`http://localhost:9200`。
- en: 'You can also install Elasticsearch on your machine by following the official
    guide: [https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.xhtml](https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.xhtml).'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过遵循官方指南在您的机器上安装 Elasticsearch：[https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.xhtml](https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.xhtml)。
- en: 'Then, if you haven’t installed the packages with `requirements.txt`, you need
    to install the Elasticsearch Python client with the `aiohttp` package in your
    environment. You can do this with `pip` from the command line:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果您还没有使用 `requirements.txt` 安装包，您需要使用 `pip` 从命令行在您的环境中安装 Elasticsearch Python
    客户端和 `aiohttp` 包。您可以使用以下命令完成此操作：
- en: '[PRE43]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: A basic knowledge of **Domain Specific Language** (**DSL**) in Elasticsearch
    can be beneficial to get a deeper understanding of the queries we are going to
    implement.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Elasticsearch 的**领域特定语言**（**DSL**）有基本了解将有助于更深入地理解我们将要实施的查询。
- en: 'Have a look at the official documentation at this link: [https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.xhtml](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.xhtml).'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 查看此链接的官方文档：[https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.xhtml](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.xhtml)。
- en: Once you have Elasticsearch installed and running, we can proceed to integrate
    it into our application.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装并运行了 Elasticsearch，我们就可以将其集成到我们的应用程序中。
- en: How to do it…
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We break down the process into the following steps:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将整个过程分解为以下步骤：
- en: Set up Elasticsearch in our FastAPI application to allow our API to communicate
    with the Elasticsearch instance.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 FastAPI 应用程序中设置 Elasticsearch，以便我们的 API 可以与 Elasticsearch 实例通信。
- en: Create an Elasticsearch index so that our songs can be indexed and queried by
    Elasticsearch.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Elasticsearch 索引，以便我们的歌曲可以被索引并由 Elasticsearch 查询。
- en: Build the query to query our songs index.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建查询以查询我们的歌曲索引。
- en: Create the FastAPI endpoint to expose our analytics endpoint to the API users.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建FastAPI端点以向API用户公开我们的分析端点。
- en: Let’s look at each of these steps in detail.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细查看这些步骤。
- en: Set up Elasticsearch in our FastAPI application
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的FastAPI应用程序中设置Elasticsearch
- en: 'To interact with the Elasticsearch server, we need to define the client in
    our Python code. In the `db_connection.py` module, where we already define parameters
    for MongoDB, let’s define the Elasticsearch asynchronous client:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 要与Elasticsearch服务器交互，我们需要在我们的Python代码中定义客户端。在已经定义了MongoDB参数的`db_connection.py`模块中，让我们定义Elasticsearch异步客户端：
- en: '[PRE44]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can create a function to check the connection with Elasticsearch in the
    same module:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在同一模块中创建一个函数来检查与Elasticsearch的连接：
- en: '[PRE45]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The function will ping the Elasticsearch server and propagate an error if the
    ping fails.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果ping失败，函数将ping Elasticsearch服务器并传播错误。
- en: 'Then, we can call the function at the FastAPI server startup in the `lifetime`
    context manager in the `main.py` module:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在`main.py`模块的`lifetime`上下文管理器中调用该函数：
- en: '[PRE46]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will ensure that the application checks the connection with the Elasticsearch
    server at the startup, and it will propagate an error if the Elasticsearch server
    does not respond.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保应用程序在启动时检查与Elasticsearch服务器的连接，如果Elasticsearch服务器没有响应，它将传播错误。
- en: Create an Elasticsearch index
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Elasticsearch索引
- en: First of all, we should start by filling our Elasticsearch instance with a collection
    of song documents. In Elasticsearch, a collection is referred to as an *index*.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该开始用歌曲文档集合填充我们的Elasticsearch实例。在Elasticsearch中，集合被称为*索引*。
- en: 'The song document should contain an additional field that tracks information
    about the views per country. For example, a new document song will look like the
    following:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 歌曲文档应包含一个额外的字段，用于跟踪每个国家的观看信息。例如，新的文档歌曲将如下所示：
- en: '[PRE47]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can find a list of sampling songs in the file `songs_info.py` in the project
    GitHub repository. If you use the file, you can also define a function to fill
    in the index as:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在项目GitHub仓库中的`songs_info.py`文件中找到一个采样歌曲列表。如果你使用该文件，你还可以定义一个函数来填充索引，如下所示：
- en: '[PRE48]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To group our songs based on the country’s views, we will need to fetch data
    based on the `views_per_country` field, and for the top ten artists, we will group
    based on the `artist` field.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据国家的观看次数分组我们的歌曲，我们需要根据`views_per_country`字段获取数据，而对于前十位艺术家，我们将根据`artist`字段进行分组。
- en: This information should be provided to the indexing process so that Elasticsearch
    understands how to index documents within the index for running queries.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 应将这些信息提供给索引过程，以便Elasticsearch了解如何索引索引内的文档以运行查询。
- en: 'In a new module called `fill_elasticsearch_index.py`, we can store this information
    in a `python` dictionary:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为`fill_elasticsearch_index.py`的新模块中，我们可以将此信息存储在一个`python`字典中：
- en: '[PRE49]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `mapping` object will be passed as an argument to the Elasticsearch client
    when creating the index. We can define a function to create our `songs_index`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建索引时，`mapping`对象将作为参数传递给Elasticsearch客户端。我们可以定义一个函数来创建我们的`songs_index`：
- en: '[PRE50]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can run the function in into a grouping `main()` one, and use the `__main__`
    section of the module to run as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将该函数运行在`main()`分组中，并使用模块的`__main__`部分如下运行：
- en: '[PRE51]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can then run the script from the terminal:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以从终端运行脚本：
- en: '[PRE52]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now that the index is created, we just have to add the songs to the index. You
    can do this by creating a separate script or by running `fill_elasticsearch_index.py`,
    which is provided in the GitHub repository.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在索引已创建，我们只需将歌曲添加到索引中。你可以通过创建一个单独的脚本或运行GitHub仓库中提供的`fill_elasticsearch_index.py`来实现这一点。
- en: We have just set up our index filled with documents on our Elasticsearch index.
    Let’s see how to build the query.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在我们的Elasticsearch索引中设置了一个索引，填充了文档。让我们看看如何构建查询。
- en: Build the query
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 构建查询
- en: We will build a function to return the query based on the specified country.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个函数，根据指定的国家返回查询。
- en: 'We can do it in a separate module in the `app` folder called `es_queries.py`.
    The query should fetch all the documents containing the `views_per_country` map
    index for the country and sort the results in descending order:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`app`文件夹中的单独模块`es_queries.py`中这样做。查询应获取包含特定国家`views_per_country`映射索引的所有文档，并按降序排序：
- en: '[PRE53]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, we filter the fields that we want in the response as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们过滤出我们希望在响应中包含的字段，如下所示：
- en: '[PRE54]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, we return the query in the form of a dictionary by specifying the
    size of the list we will expect:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过指定我们期望的列表大小来以字典的形式返回查询：
- en: '[PRE55]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We now have the function that will construct the query to retrieve the top ten
    artists for a specified country, and we will utilize it in our endpoint.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了构建查询以检索指定国家前十个艺术家的函数，我们将在我们的端点中使用它。
- en: Create the FastAPI endpoint
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 创建FastAPI端点
- en: 'Once we have set up the Elasticsearch connection and formulated the query,
    creating the endpoint is a straightforward process. Let’s define it in a new module
    called `main_search.py` under the `app` folder. Let’s start by defining the router:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了Elasticsearch连接并制定了查询，创建端点就是一个简单的过程。让我们在`app`文件夹下的一个新模块`main_search.py`中定义它。让我们首先定义路由器：
- en: '[PRE56]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, the endpoint will be:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，端点将是：
- en: '[PRE57]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The result of the query is further adjusted before being returned to extract
    only the values we are interested in, namely the artist and views.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回之前，查询结果将进一步调整，以提取我们感兴趣的唯一值，即艺术家和观看次数。
- en: The last step is to include the router in our `FastAPI` object to include the
    endpoint.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将路由器包含到我们的`FastAPI`对象中，以包含端点。
- en: 'In the `main.py` module, we can add the router as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.py`模块中，我们可以添加路由器如下：
- en: '[PRE58]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now, if you spin up the server with the `uvicorn app.main:app` command and go
    to the interactive documentation at `http://localhost:8000/docs`, you will see
    the newly created endpoint to retrieve the top ten artists in a country based
    on the views of the songs.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您使用`uvicorn app.main:app`命令启动服务器并转到`http://localhost:8000/docs`的交互式文档，您将看到根据歌曲观看次数检索一个国家前十个艺术家的新创建的端点。
- en: You have just created a FastAPI endpoint that interacts with an Elasticsearch
    instance. Feel free to create new endpoints on your own. For example, you can
    create an endpoint to return the top ten songs for a country.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚创建了一个与Elasticsearch实例交互的FastAPI端点。您可以自由地创建自己的新端点。例如，您可以创建一个返回某个国家前十个歌曲的端点。
- en: See also
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: 'Since we have used the Elasticsearch Python client, feel free to dig more into
    the official documentation pages:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了Elasticsearch Python客户端，您可以自由地深入了解官方文档页面：
- en: '*Elasticsearch Python* *Client*: [https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/index.xhtml](https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/index.xhtml)'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Elasticsearch Python* *客户端*：[https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/index.xhtml](https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/index.xhtml)'
- en: '*Using Asyncio with* *Elasticsearch*: [https://elasticsearch-py.readthedocs.io/en/7.x/async.xhtml](https://elasticsearch-py.readthedocs.io/en/7.x/async.xhtml)'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Asyncio与* *Elasticsearch*：[https://elasticsearch-py.readthedocs.io/en/7.x/async.xhtml](https://elasticsearch-py.readthedocs.io/en/7.x/async.xhtml)'
- en: 'To learn more about Elasticsearch indexes, have a look at the Elasticsearch
    documentation:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Elasticsearch索引的信息，请查看Elasticsearch文档：
- en: '*Index* *API*: [https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.xhtml](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.xhtml)'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*索引* *API*：[https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.xhtml](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.xhtml)'
- en: 'You can find a guide to mapping at this link:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此链接中找到映射指南：
- en: '*Mapping*: [https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.xhtml](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.xhtml)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*映射*：[https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.xhtml](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.xhtml)'
- en: 'Finally, you can dig into the search query language at the following link:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以在以下链接中深入了解搜索查询语言：
- en: '*Query* *DSL*: [https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.xhtml](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.xhtml)'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查询* *DSL*：[https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.xhtml](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.xhtml)'
- en: Using Redis for caching in FastAPI
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在FastAPI中使用Redis进行缓存
- en: Redis is an in-memory data store that can be used as a cache to improve the
    performance and scalability of FastAPI applications. By caching frequently accessed
    data in Redis, you can reduce the load on your database and speed up response
    times for your API endpoints.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是一个内存数据存储，可以用作缓存来提高FastAPI应用程序的性能和可伸缩性。通过在Redis中缓存频繁访问的数据，您可以减少对数据库的负载并加快API端点的响应时间。
- en: In this recipe, we’ll explore how to integrate Redis caching into our streaming
    platform application and we will cache an endpoint as an example.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何将Redis缓存集成到我们的流平台应用程序中，并将缓存一个端点作为示例。
- en: Getting ready
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow along with the recipe you need a running Redis instance reachable
    at the http://localhost:6379 address.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随这个菜谱，您需要一个运行中的Redis实例，可通过http://localhost:6379地址访问。
- en: 'Depending on your machine and your preference, you have several ways to install
    it and run it. Have a look at the Redis documentation to see how to do it for
    your operating system: [https://redis.io/docs/install/install-redis/](https://redis.io/docs/install/install-redis/).'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的机器和偏好，您有多种安装和运行它的方法。查看Redis文档以了解如何在您的操作系统上执行此操作：[https://redis.io/docs/install/install-redis/](https://redis.io/docs/install/install-redis/)。
- en: In addition, you need a FastAPI application with an endpoint that is time consuming.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还需要一个具有耗时端点的FastAPI应用程序。
- en: Alternatively, if you follow the streaming platform, make sure that you have
    created the top ten artists endpoint from the previous recipe, *Integrating FastAPI*
    *with Elasticsearch*.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您遵循流平台，请确保您已经从之前的菜谱中创建了前十个艺术家的端点，*将FastAPI* *与Elasticsearch*集成。
- en: 'You will also need the Redis client for Python in your environment. If you
    haven’t installed the packages with `requirements.txt`, you do it by running the
    following command:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 您的环境还需要Python的Redis客户端。如果您还没有使用`requirements.txt`安装包，可以通过运行以下命令来完成：
- en: '[PRE59]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Once the installation is complete, we can proceed with the recipe.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以继续进行菜谱。
- en: How to do it…
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Once Redis is running and reachable at `localhost:6379`, we can integrate the
    Redis client into our code:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Redis运行并可通过`localhost:6379`访问，我们就可以将Redis客户端集成到我们的代码中：
- en: 'In the `db_connection.py` module, where we already defined the clients for
    Mongo and Elasticsearch, let’s add the client for Redis:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`db_connection.py`模块中，我们已经为Mongo和Elasticsearch定义了客户端，现在让我们添加Redis的客户端：
- en: '[PRE60]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '2.  Similarly to the other databases, we can create a function that pings the
    Redis server at the application’s startup. The function can be defined as follows:'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.  类似于其他数据库，我们可以在应用程序启动时创建一个ping Redis服务器的函数。该函数可以定义为以下内容：
- en: '[PRE61]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '3.  Then, include it in the `lifespan` context manager in `main.py`:'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.  然后，将其包含在`main.py`中的`lifespan`上下文管理器中：
- en: '[PRE62]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now, we can use the `redis_client` object to cache our endpoints. We will cache
    the `GET /search/top/ten/artists` endpoint used to query Elasticsearch.
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`redis_client`对象来缓存我们的端点。我们将缓存用于查询Elasticsearch的`GET /search/top/ten/artists`端点。
- en: '4.  In `main_search.py`, we can define a function to retrieve the Redis client
    as a dependency:'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4.  在`main_search.py`中，我们可以定义一个函数来检索Redis客户端作为依赖项：
- en: '[PRE63]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '5.  Then, you can modify the endpoint as follows:'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 5.  然后，您可以按如下方式修改端点：
- en: '[PRE64]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '6.  At the beginning of the function, we retrieve the key to store the value
    and check whether the value is already stored in Redis:'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 6.  在函数的开始处，我们检索存储值的键，并检查该值是否已经存储在Redis中：
- en: '[PRE65]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '7.  Then, when we see that the data is not present, we continue by getting
    the data from Elasticsearch:'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 7.  然后，当我们看到数据不存在时，我们继续从Elasticsearch获取数据：
- en: '[PRE66]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '8.  Once we retrieve the list, we store it in Redis so we can retrieve it at
    the following call:'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 8.  一旦我们检索到列表，我们将其存储在Redis中，以便在后续调用中检索：
- en: '[PRE67]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 9.  We specified an expiring time, which is the time the record will stay in
    Redis in seconds. After that time, the record won’t be available anymore and the
    artists list will be recalled from Elasticsearch.
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 9.  我们指定了一个过期时间，即记录将在Redis中停留的秒数。在此时间之后，记录将不再可用，艺术家列表将从Elasticsearch中重新调用。
- en: Now, if you run the server with the `uvicorn app.main:app` command and try to
    call the endpoint for Italy, you will notice that the response time for the second
    call will be much less.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您使用`uvicorn app.main:app`命令运行服务器并尝试调用意大利的端点，您将注意到第二次调用的响应时间将大大减少。
- en: You have just implemented a cache for one of the endpoints of our application
    with Redis. With the same strategy, feel free to cache all the other endpoints.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经使用Redis为我们的应用程序的一个端点实现了缓存。使用相同的策略，您可以自由地缓存所有其他端点。
- en: There’s more…
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'At the time of writing, there is a promising library, `fastapi-cache`, which
    makes caching in FastAPI very easy. Check the GitHub repository: [https://github.com/long2ice/fastapi-cache](https://github.com/long2ice/fastapi-cache).'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，有一个有希望的库，`fastapi-cache`，它使FastAPI中的缓存变得非常简单。请查看GitHub仓库：[https://github.com/long2ice/fastapi-cache](https://github.com/long2ice/fastapi-cache)。
- en: The library supports several caching databases, including Redis and in-memory
    caching. With simple endpoint decorators, you can specify caching parameters such
    as time to live, encoder, and cache response header.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 该库支持多个缓存数据库，包括 Redis 和内存缓存。通过简单的端点装饰器，您可以指定缓存参数，如存活时间、编码器和缓存响应头。
- en: See also
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: 'Redis client for Python supports more advanced functionalities. Feel free to
    explore its potential in the official documentation:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 的 Python 客户端支持更多高级功能。您可以在官方文档中自由探索其潜力：
- en: '*Redis Python* *Client*: [https://redis.io/docs/connect/clients/python/](https://redis.io/docs/connect/clients/python/)'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Redis Python* *客户端*: [https://redis.io/docs/connect/clients/python/](https://redis.io/docs/connect/clients/python/)'
- en: '*Redis Python Asynchronous* *Client*: [https://redis-py.readthedocs.io/en/stable/examples/asyncio_examples.xhtml](https://redis-py.readthedocs.io/en/stable/examples/asyncio_examples.xhtml)'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Redis Python 异步* *客户端*: [https://redis-py.readthedocs.io/en/stable/examples/asyncio_examples.xhtml](https://redis-py.readthedocs.io/en/stable/examples/asyncio_examples.xhtml)'
- en: '[PRE68]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
