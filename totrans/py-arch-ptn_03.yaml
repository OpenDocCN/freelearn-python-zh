- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: API Design
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API设计
- en: In this chapter, we will talk about the basic **application programming interface**
    (**API**)design principles. We will see how to start our design by defining useful
    abstractions that will create the foundation for the design.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论基本的**应用程序编程接口**（**API**）设计原则。我们将了解如何通过定义有用的抽象来开始我们的设计，这些抽象将为设计奠定基础。
- en: We will then present the principles for RESTful interfaces, covering both the
    strict, academic definition and a more practical definition to help when making
    designs. We will look at design approaches and techniques to help create a useful
    API based on standard practices. We will also spend some time talking about authentication,
    as this is a critical element for most APIs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将接着介绍RESTful接口的原则，涵盖严格的、学术性的定义以及更实用的定义，以帮助进行设计。我们将探讨设计方法和技巧，以帮助基于标准实践创建有用的API。我们还将花一些时间讨论认证，因为这是大多数API的关键元素。
- en: We will focus in this book on RESTful interfaces, as they are the most common
    right now. Before that, there were other alternatives, including **Remote Procedure
    Call** (**RPC**) in the 80s, a way to make a remote function call, or **Single
    Object Access Protocol** (**SOAP**) in the early 2000s, which standardized the
    format of the remote call. Current RESTful interfaces are easier to read and take
    advantage of the already established usage of HTTP more strongly, although, in
    essence, they could potentially be integrated via these older specifications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这本书中专注于RESTful接口，因为它们现在是最常见的。在此之前，还有其他替代方案，包括20世纪80年代的**远程过程调用**（**RPC**），一种进行远程函数调用的方法，或者21世纪初的**单一对象访问协议**（**SOAP**），它标准化了远程调用的格式。当前的RESTful接口更容易阅读，并且更强烈地利用了已经建立的HTTP使用，尽管本质上，它们可以通过这些较旧的规范进行集成。
- en: They are still available nowadays, although predominantly in older systems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现在主要存在于较老的系统上，但它们仍然可用。
- en: We will cover how to create a versioning system for the API, attending to the
    different use cases that can be affected.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍如何为API创建版本控制系统，考虑到可能受到影响的不同用例。
- en: We will see the difference between the frontend and the backend, and its interaction.
    Although the main objective of the chapter is to talk about API interfaces, we
    will also talk about HTML interfaces to see the differences and how they interact
    with other APIs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨前端和后端之间的区别，以及它们的交互。尽管本章的主要目标是讨论API接口，但我们也会讨论HTML接口，以了解它们之间的差异以及它们如何与其他API交互。
- en: Finally, we will describe the design for the example that we will use later
    in the book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将描述我们将在书中使用的示例的设计。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Abstractions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象
- en: RESTful interfaces
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful接口
- en: Authentication
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: Versioning the API
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API版本控制
- en: Frontend and backend
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端和后端
- en: HTML interfaces
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML界面
- en: Designing the API for the example
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为示例设计API
- en: Let's take a look at abstractions first.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看抽象。
- en: Abstractions
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象
- en: An API allows us to use a piece of software without totally understanding all
    the different steps that are involved. It presents a clear menu of actions that
    can be performed, enabling an external user, who doesn't necessarily understand
    the complexities of the operation, to perform them efficiently. It presents a
    simplification of the process.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个API允许我们使用一段软件，而无需完全理解其中涉及的所有不同步骤。它提供了一个清晰的动作菜单，允许外部用户（可能并不理解操作的复杂性）高效地执行这些操作。它简化了过程。
- en: These actions can be purely functional, where the output is only related to
    the input; for example, a mathematical function that calculates the barycenter
    of a planet and a star, given their orbits and masses.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动作可以是纯粹的功能性的，其中输出仅与输入相关；例如，一个计算行星和恒星质心的数学函数，给定它们的轨道和质量。
- en: Alternatively, they can deal with state, as the same action repeated twice may
    have different effects; for example, retrieving the time in the system. Perhaps
    even a call allows the time zone of the computer to be set, and two subsequent
    calls to retrieve the time may return very different results.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它们可以处理状态，因为相同的动作重复两次可能产生不同的效果；例如，检索系统中的时间。也许甚至一个调用允许设置计算机的时区，随后两次检索时间的调用可能返回非常不同的结果。
- en: In both cases, the APIs are defining **abstractions**. Retrieving the time of
    the system in a single operation is simple enough, but perhaps the details of
    doing so are not so easy. It may involve reading in a certain way some piece of
    hardware that keeps track of time.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，API 都在定义**抽象**。通过单个操作检索系统时间很简单，但也许执行此操作的细节并不那么容易。这可能涉及到以某种方式读取跟踪时间的某些硬件。
- en: Different hardware may report the time differently, but the result should always
    be translated in a standard format. Time zones and time savings need to be applied.
    All this complexity is handled by the developers of the module that exposes the
    API and provides a clear and understandable contract with any user. "Call this
    function, and the time in ISO format will be returned."
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的硬件可能以不同的方式报告时间，但结果应该始终以标准格式转换。需要应用时区和夏令时。所有这些复杂性都由公开 API 并为用户提供清晰、易懂契约的模块开发者处理。“调用这个函数，将以
    ISO 格式返回时间。”
- en: While we are mainly talking about APIs, and throughout the book we will describe
    mostly ones related to online services, the concept of abstractions really can
    be applied to anything. A web page to manage a user is an abstraction, as it defines
    the concept of "user account" and the associated parameters. Another omnipresent
    example is the "Shopping cart" for e-commerce. It's good to create a clear mental
    image, as it helps to create a clearer and more consistent interface for the user.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们主要在讨论 API，并且在整本书中我们将主要描述与在线服务相关的 API，但抽象的概念实际上可以应用于任何事物。一个用于管理用户的网页是一个抽象，因为它定义了“用户账户”及其相关参数的概念。另一个无处不在的例子是电子商务中的“购物车”。创建一个清晰的思维图像是很有好处的，因为它有助于为用户提供更清晰、更一致的界面。
- en: 'This is, of course, a simple example, but APIs can hide a tremendous amount
    of complexity under their interfaces. A good example to think about is a program
    like `curl`. Even when *just* sending an HTTP request to a URL and printing the
    returned headers, there is a huge amount of complexity associated with this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是一个简单的例子，但 API 可以在其界面下隐藏大量的复杂性。一个值得思考的好例子是像 `curl` 这样的程序。即使只是向 URL 发送 HTTP
    请求并打印返回的头部，这也与大量的复杂性相关：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This makes a call to `www.google.com` and displays the headers of the response
    using the `-I` flag. The `-L` flag is added to automatically redirect any request
    which is what is happening here.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用 `www.google.com` 并使用 `-I` 标志显示响应的头部。添加 `-L` 标志是为了自动重定向任何请求，这正是这里发生的情况。
- en: 'Making a remote connection to a server requires a lot of different moving parts:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器建立远程连接需要很多不同的部件：
- en: DNS access to translate the server address `www.google.com` to an actual IP
    address.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS 访问将服务器地址 `www.google.com` 转换为实际的 IP 地址。
- en: The communication between both servers, which involves using the TCP protocol
    to generate a persistent connection and guarantee the reception of the data.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个服务器之间的通信，这涉及到使用 TCP 协议来生成持久连接并保证数据的接收。
- en: Redirection based on the result from the first request, as the server returns
    a code pointing to another URL. This was done owing to the usage of the `-L` flag.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据第一次请求的结果进行重定向，因为服务器返回了一个指向另一个 URL 的代码。这是由于使用了 `-L` 标志。
- en: The redirection points to an HTTPS URL, which requires adding a verification
    and encryption layer on top of that.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向指向一个 HTTPS URL，这需要在上面添加一个验证和加密层。
- en: Each of these steps also makes use of other APIs to perform smaller actions,
    which could involve the functionality of the operating system or even calling
    remote servers such as the DNS one to obtain data from there.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些步骤也使用了其他 API 来执行更小的操作，这可能涉及到操作系统的功能，甚至调用远程服务器（如 DNS 服务器）以从那里获取数据。
- en: Here, the `curl` interface is used from the command line. While the strict definition
    of an API discard stipulates that the end user is a human, there's not really
    a big change. Good APIs should be easily testable by human users. Command-line
    interfaces can also be easily automated by bash scripts or other languages.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用命令行从 `curl` 界面进行操作。虽然 API 严格的定义规定最终用户是人类，但实际上并没有太大的变化。好的 API 应该很容易被人类用户测试。命令行界面也可以通过
    bash 脚本或其他语言轻松自动化。
- en: But, from the point of view of the user of `curl`, this is not very relevant.
    It is simplified to the point where a single command line with a few flags can
    perform a well-defined operation without worrying about the format to get data
    from the DNS or how to encrypt a request using SSL.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，从`curl`用户的观点来看，这并不太相关。它被简化到只需一个带有几个标志的单行命令行就可以执行一个定义良好的操作，无需担心从DNS获取数据的格式或如何使用SSL加密请求。
- en: Using the right abstractions
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用正确的抽象
- en: For a successful interface, the root is to create a series of abstractions and
    present them to the user so that they can perform actions. The most important
    question when designing a new API is, therefore, to decide which are the best
    abstractions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个成功的接口，其根本在于创建一系列抽象并将它们呈现给用户，以便他们可以执行操作。因此，在设计新的API时，最重要的一个问题就是决定哪些是最合适的抽象。
- en: When the process happens organically, the abstractions are decided mostly on
    the go. There is an initial idea, acknowledged as an understanding of the problem,
    that then gets tweaked.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个过程自然发生时，抽象主要是在过程中决定的。有一个最初的想法，被认可为对问题的理解，然后得到调整。
- en: For example, it's very common to start a user management system by adding different
    flags to the users. So, a user has permission to perform action A, and then a
    parameter to perform action B, and so on. By adding one flag at a time, come the
    tenth flag, the process becomes very confusing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以添加不同的标志到用户开始启动用户管理系统是非常常见的。因此，用户有权限执行操作A，然后有一个参数执行操作B，依此类推。通过一次添加一个标志，到第十个标志时，这个过程变得非常混乱。
- en: Then, a new abstraction can be used; roles and permissions. Certain kinds of
    users can perform different actions, such as admin roles. A user can have a role,
    and the role is the one that describes the related permissions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用一个新的抽象；角色和权限。某些类型的用户可以执行不同的操作，例如管理员角色。用户可以有一个角色，该角色描述了相关的权限。
- en: Note that this simplifies the problem, as it's easy to understand and manage.
    However, moving from "an individual collection of flags" to "several roles" can
    be a complicated process. There is a reduction in the number of possible options.
    Perhaps some existing users have a peculiar combination of flags. All this needs
    to be handled carefully.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这简化了问题，因为它易于理解和管理。然而，从“单个标志集合”到“多个角色”的转变可能是一个复杂的过程。可能减少了可能的选项数量。也许一些现有用户有一些独特的标志组合。所有这些都需要谨慎处理。
- en: While designing a new API, it is good to try to explicitly describe the inherent
    abstractions that the API uses to clarify them, at least at a high level. This
    also has the advantage of being able to think about that as a user of the API
    and see if things add up.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计新的API时，最好尝试明确描述API使用的固有抽象，至少在高级别上，以澄清它们。这也具有这样的优势，即作为API的用户思考这些问题，看看是否合理。
- en: One of the most useful viewpoints in the work of software developers is to detach
    yourself from your "internal view" and take the position of the actual user of
    the software. This is more difficult than it sounds, but it's certainly a skill
    worth developing. This will make you a better designer. Don't be afraid to ask
    a friend or coworker to detect blind spots in your design.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发者的工作中，最有用的观点之一是脱离你的“内部视角”，站在软件实际用户的立场上。这比听起来要难，但确实是一项值得培养的技能。这将使你成为一个更好的设计师。不要害怕请朋友或同事检测你设计中的盲点。
- en: However, every abstraction has its limits.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每个抽象都有其局限性。
- en: Leaking abstractions
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象泄露
- en: When an abstraction is leaking details from the implementation, and not presenting
    a perfectly opaque image, it's called a leaky abstraction.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个抽象从实现中泄露细节，而不是呈现一个完美的不透明图像时，它被称为泄露的抽象。
- en: While a good API should try to avoid this, sometimes it happens. This can be
    caused by underlying bugs in the code serving the API, or sometimes directly from
    the way the code operates in certain operations.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一个好的API应该尽量避免这种情况，但有时它还是会发生。这可能是由服务于API的代码中的底层错误引起的，或者有时直接由代码在特定操作中的运行方式引起的。
- en: A common case for this is relational databases. SQL abstracts the process of
    searching data from how it is actually stored in the database. You can search
    with complex queries and get the result, and you don't need to know how the data
    is structured. But sometimes, you'll find out that a particular query is slow,
    and reorganizing the parameters of the query has a big impact on how this happens.
    This is a leaky abstraction.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的常见例子是关系型数据库。SQL 抽象了从数据库中实际存储方式搜索数据的过程。你可以使用复杂的查询进行搜索并获取结果，而不需要知道数据的结构。但有时，你会发现某个特定的查询速度很慢，重新组织查询参数会对这个过程产生重大影响。这是一个泄漏的抽象。
- en: This is very common, and the reason why there are significant tools to help
    ascertain what is going on when running a SQL query, which is very detached from
    the implementation. The main one is the `EXPLAIN` command.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常常见，这也是为什么有大量的工具可以帮助确定在运行 SQL 查询时发生了什么，而 SQL 查询与实现非常分离。其中最主要的是 `EXPLAIN` 命令。
- en: Operating systems are good examples of a system that generates good abstractions
    that don't leak the majority of the time. There are lots of examples. Not being
    able to read or write a file due to a lack of space (a less common problem now
    than three decades ago); breaking a connection with a remote server due to a network
    problem; or not being able to create a new connection due to reaching a limit
    in terms of the number of open file descriptors.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统是生成良好抽象且大多数情况下不会泄漏的系统的好例子。有很多例子。由于空间不足而无法读取或写入文件（现在比三十年前少见的难题）；由于网络问题而与远程服务器断开连接；或者由于达到打开文件描述符的数量限制而无法创建新的连接。
- en: Leaky abstractions are, to a certain degree, unavoidable. They are the result
    of not living in a perfect world. Software is fallible. Understanding and preparing
    for that is critical.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 泄漏的抽象在某种程度上是不可避免的。这是不生活在完美世界的结果。软件是会出错的。理解和准备这一点至关重要。
- en: '"All non-trivial abstractions, to some degree, are leaky."'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"所有非平凡的抽象，在某种程度上，都是泄漏的。"'
- en: ''
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Joel Spolsky's Law of Leaky Abstractions
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: – 乔尔·斯波尔斯基的泄漏抽象定律
- en: 'When designing an API, it is important to take this fact into account for several
    reasons:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计 API 时，考虑到以下几个原因，重要的是要考虑这个事实：
- en: '**To present clear errors and hints externally**. A good design will always
    include cases for things going wrong and try to present them clearly with proper
    error codes or error handling.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为了在外部清晰地展示错误和提示**。一个好的设计将始终包括出错的情况，并尝试用适当的错误代码或错误处理方式清晰地展示它们。'
- en: '**To deal with errors that could come from dependent services internally**.
    Dependent services can fail or have other kinds of problems. The API should abstract
    this to a certain degree, recovering from the problem if possible, failing gracefully
    if not, and returning a proper result if recovery is impossible.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为了内部处理可能来自依赖服务的错误**。依赖服务可能会失败或出现其他类型的问题。API 应该在一定程度上抽象这个问题，如果可能的话从问题中恢复，如果不能优雅地失败，并返回适当的结果。'
- en: The best design is the one that not only designs things when they work as expected,
    but also prepares for unexpected problems and is sure that they can be analyzed
    and corrected.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的设计不仅要在预期工作的情况下设计事物，还要为意外问题做好准备，并确信它们可以被分析和纠正。
- en: Resources and action abstractions
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源和操作抽象
- en: 'A very useful pattern to consider when designing an API is to produce a set
    of resources that can perform actions. This pattern uses two kinds of elements:
    **resources** and **actions**.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计 API 时考虑的一个非常有用的模式是生成一组可以执行操作的资源。这个模式使用两种类型的元素：**资源**和**操作**。
- en: Resources are passive elements that are referenced, while actions are performed
    on resources.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 资源是被引用的被动元素，而操作是在资源上执行的。
- en: For example, let's define a very simple interface to play a simple game guessing
    coin tosses. This is a game consisting of three guesses for three coin tosses,
    and the user wins if at least two of these guesses are correct.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们定义一个非常简单的接口来玩一个简单的猜硬币游戏。这是一个由三次硬币投掷组成的游戏，如果用户至少猜对其中两次，则获胜。
- en: 'The resource and actions may be as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 资源和操作可能如下所示：
- en: '| Resource | Actions | Details |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 资源 | 操作 | 详情 |'
- en: '| HEADS | None | A coin toss result. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| HEADS | None | 硬币投掷结果。 |'
- en: '| TAILS | None | A coin toss result. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| TAILS | None | 硬币投掷结果。 |'
- en: '| GAME | START | Start a new GAME. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| GAME | START | 开始一个新的游戏。 |'
- en: '|  | READ | Returns the current round (1 to 3) and the current correct guesses.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  | READ | 返回当前轮次（1到3）和当前正确猜测。 |'
- en: '| COIN_TOSS | TOSS | Toss the coin. If the GUESS hasn''t been produced, it
    returns an error. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| COIN_TOSS | 投掷 | 投掷硬币。如果GUESS尚未生成，则返回错误。 |'
- en: '|  | GUESS | Accepts HEADS or TAILS as the guess. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|  | 猜测 | 接受HEADS或TAILS作为猜测。 |'
- en: '|  | RESULT | It returns HEADS or TAILS and whether the GUESS was correct.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  | 结果 | 返回HEADS或TAILS以及猜测是否正确。 |'
- en: 'A possible sequence for a single game could be:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 单个游戏的可能顺序可以是：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note how each resource has its own set of actions that can be performed. Actions
    can be repeated if that's convenient, but it's not required. Resources can be
    combined into a hierarchical representation (like here, where `COIN_TOSS` depends
    on a higher `GAME` resource). Actions can require parameters that can be other
    resources.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个资源都有其自己的动作集，可以执行。如果方便，动作可以重复，但这不是必需的。资源可以组合成层次表示（如这里，`COIN_TOSS`依赖于更高的`GAME`资源）。动作可能需要参数，这些参数可以是其他资源。
- en: However, the abstractions are organized around having a consistent set of resources
    and actions. This way of explicitly organizing an API is useful as it clarifies
    what is passive and what's active in the system.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，抽象是围绕具有一致的资源集和动作集组织的。这种明确组织API的方式很有用，因为它阐明了系统中什么是被动的，什么是主动的。
- en: '**Object-oriented programming** (**OOP**) uses these abstractions, as everything
    is an object that can receive messages to perform some actions. Functional programming,
    on the other hand, doesn''t fit neatly into this structure, as "actions" can work
    like resources.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）使用这些抽象，因为一切都是可以接收消息以执行某些动作的对象。另一方面，函数式编程并不适合这种结构，因为“动作”可以像资源一样工作。'
- en: This is a common pattern, and it's used in RESTful interfaces, as we will see
    next.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的模式，它被用于RESTful接口，正如我们接下来将要看到的。
- en: RESTful interfaces
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful接口
- en: RESTful interfaces are incredibly common these days, and for good reason. They've
    become the de facto standard in web services that serve other applications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful接口在当今非常普遍，这是有充分理由的。它们已经成为服务其他应用程序的Web服务的既定标准。
- en: '**Representational State Transfer** (**REST**) was defined in 2000 in a Ph.D.
    dissertation by Roy Fielding, and it uses HTTP standards as a basis to create
    a definition of a software architecture style.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**表征状态转移**（**REST**）由Roy Fielding在2000年的一篇博士论文中定义，它使用HTTP标准作为基础来创建一种软件架构风格的定义。'
- en: 'For a system to be considered RESTful, it should follow certain rules:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要使一个系统被认为是RESTful的，它应该遵循某些规则：
- en: '**Client-server architecture**. It works through remote calling.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端-服务器架构**。它通过远程调用工作。'
- en: '**Stateless**. All the information related to a particular request should be
    contained in the request itself, making it independent from the specific server serving
    the request.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**。与特定请求相关的所有信息都应该包含在请求本身中，使其独立于特定服务器。'
- en: '**Cacheability**. The cacheability of the responses should be clear, either
    to say they are cacheable or not.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存性**。响应的缓存性应该是明确的，要么说明它们是可缓存的，要么不是。'
- en: '**Layered system**.The client cannot tell if they are connected to a final
    server or if there''s an intermediate server.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层系统**。客户端无法判断它们是否连接到最终服务器或是否存在中间服务器。'
- en: '**Uniform interface**, with four prerequisites:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一接口**，有四个先决条件：'
- en: '**Resource identification in requests**, meaning a resource is unequivocally
    represented, and its representation is independent'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求中的资源标识**，意味着资源被明确表示，其表示是独立的'
- en: '**Resource manipulation through representations**, allowing clients to have
    all the required information to make changes when they have the representation'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过表示进行资源操作**，允许客户端在拥有表示时拥有所有所需信息以进行更改'
- en: '**Self-descriptive messages**, meaningmessages are complete in themselves'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自描述消息**，意味着消息本身是完整的'
- en: '**Hypermedia as the Engine of Application State**, meaning the client can walk
    through the system using referenced hyperlinks'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超媒体作为应用状态引擎**，意味着客户端可以通过引用的超链接遍历系统'
- en: '**Code on demand**. This is an optional requirement, and it''s normally not
    used. Servers can submit code in response to help perform operations or improve
    the client; for example, submitting JavaScript to be executed in the browser.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按需代码**。这是一个可选要求，通常不使用。服务器可以提交代码以帮助执行操作或改进客户端；例如，提交要在浏览器中执行的JavaScript。'
- en: This is the most formal definition. As you can see, it's not necessarily based
    on HTTP requests. For more convenient usage, we need to limit the possibilities
    somewhat and set a common framework.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最正式的定义。如您所见，它不一定基于HTTP请求。为了更方便的使用，我们需要限制一些可能性并设定一个共同框架。
- en: A more practical definition
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更实用的定义
- en: When people talk colloquially about RESTful interfaces, normally they are understood
    as interfaces based on HTTP resources using JSON formatted requests. This is wholly
    compatible with the definition that we've seen before, but taking some key elements
    into consideration.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们非正式地谈论RESTful接口时，通常它们被理解为基于HTTP资源使用JSON格式请求的接口。这与我们之前看到的定义完全兼容，但考虑了一些关键元素。
- en: These key elements are sometimes ignored, leading to pseudo-RESTful interfaces,
    which don't have the same properties.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关键元素有时会被忽略，导致伪RESTful接口，它们不具有相同的属性。
- en: The main one is that **URIs (Uniform Resource Identifiers)** should describe
    clear resources, as well as HTTP methods and actions to perform on them, using
    the **CRUD (Create Retrieve Update Delete)** approach.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的一点是**URI（统一资源标识符）**应该描述清晰的资源，以及对其执行的操作的HTTP方法和动作，使用**CRUD（创建、检索、更新、删除）**方法。
- en: 'CRUD interfaces facilitate the performance of those actions: Create (save a
    new entry), Retrieve (read), Update (overwrite), and Delete entries. These are
    the basic operations for any persistent storage system.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD接口简化了这些动作的执行：创建（保存新条目）、检索（读取）、更新（覆盖）和删除条目。这些是任何持久存储系统的基本操作。
- en: 'There are two kinds of URIs, whether they describe a single resource or a collection
    of resources, as can be seen in the following table:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种URI，无论是描述单个资源还是资源集合，如下表所示：
- en: '| Resource | Example | Method | Description |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 资源 | 示例 | 方法 | 描述 |'
- en: '| Collection | `/books` | `GET` | List operation. Returns all the available
    elements of the collection, for example, all books. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | `/books` | `GET` | 列表操作。返回集合中所有可用的元素，例如，所有书籍。 |'
- en: '|  |  | `POST` | Create operation. Creates a new element of the collection.
    Returns the newly created resource. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `POST` | 创建操作。创建集合的新元素。返回新创建的资源。 |'
- en: '| Single | `/books/1` | `GET` | Retrieve operation. Returns the data from the
    resource, for example, the book with an ID of 1. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 单个 | `/books/1` | `GET` | 检索操作。返回资源的数据，例如，ID为1的书籍。 |'
- en: '|  |  | `PUT` | Set (Update) operation. Sends the new data for the resource.
    If it doesn''t exist, it will be created. If it does, it will be overwritten.
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `PUT` | 设置（更新）操作。发送资源的新数据。如果不存在，则创建。如果存在，则覆盖。'
- en: '|  |  | `PATCH` | Partial update operation. Overwrites only the partial values
    for the resource, for example, sends and writes only the email for the user object.
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `PATCH` | 部分更新操作。仅覆盖资源的部分值，例如，仅发送和写入用户对象的电子邮件。'
- en: '|  |  | `DELETE` | Delete operation. It deletes the resource. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `DELETE` | 删除操作。删除资源。 |'
- en: 'The key element of this design is the definition of everything as a resource,
    as we saw before. Resources are defined by their URIs, which contain a hierarchical
    view of the resources, for example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计的关键要素是将一切定义为资源，正如我们之前所看到的。资源通过其URI定义，其中包含资源的分层视图，例如：
- en: '`/books/1/cover` defines the resource of the cover image from the book with
    an ID of 1.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`/books/1/cover` 定义了ID为1的书的封面图片资源。'
- en: For simplicity, we will use integer IDs to identify the resources in this chapter.
    In real-world operations, this is not recommended. They have no meaning at all,
    and, even worse, they can sometimes leak information about the number of elements
    in the system or their internal order. For example, a competitor could estimate
    how many new entries are being added each week. To detach from whatever internal
    representation, try to always use a natural key externally, if available, such
    as the ISBN number for books, or create a random **Universally Unique Identifier**
    (**UUID**).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将在本章中使用整数ID来标识资源。在实际操作中，这并不推荐。它们没有任何意义，更糟糕的是，它们有时会泄露系统元素数量或其内部顺序的信息。例如，竞争对手可能会估计每周新增了多少条记录。为了摆脱任何内部表示，如果可能的话，尽量始终使用外部自然键，例如书的ISBN号码，或者创建一个随机的**通用唯一标识符**（**UUID**）。
- en: Another problem with sequential integers is that, at high rates, the system
    may struggle to create them correctly, as it won't be possible to create two at
    the same time. This can limit the growth of a system.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序整数的一个问题是，在高速率下，系统可能难以正确创建它们，因为它不可能同时创建两个。这可能会限制系统的发展。
- en: 'Most of the input and output of the resources will be represented in JSON format.
    For example, this could be an example of a request and response to retrieve a
    user:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的大部分输入和输出将以JSON格式表示。例如，这可能是一个请求和响应示例，用于检索用户：
- en: '[PRE2]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The response is formatted in JSON, as specified in `Content-Type`. This makes
    it easy to parse and analyze automatically. Note that the `avatar` field returns
    a hyperlink to another resource. This makes the interface walkable and reduces
    the amount of information that the client requires beforehand.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 响应格式为JSON，如`Content-Type`中指定。这使得自动解析和分析变得容易。请注意，`avatar`字段返回指向另一个资源的超链接。这使得接口易于导航，并减少了客户端事先需要的信息量。
- en: This is one of the most forgotten properties when designing RESTful interfaces.
    It is preferable to return full URIs to resources instead of indirect references,
    such as no-context IDs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设计RESTful接口时最容易被遗忘的特性之一。最好返回资源的完整URI，而不是间接引用，例如无上下文ID。
- en: For example, when creating a new resource, include the new URI in the response,
    in the `Location` header.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在创建新资源时，在`Location`头中包含新的URI。
- en: 'To send new values to overwrite, the same format should be used. Note that
    some elements may be read-only, such as `cover`, and aren''t required:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送新值以覆盖，应使用相同的格式。请注意，某些元素可能是只读的，例如`cover`，并且不是必需的：
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The **same representation should be used for input and output**, making it easy
    for the client to retrieve a resource, modify it, and then resubmit it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**相同的表示应用于输入和输出**，这使得客户端能够轻松检索资源、修改它，然后重新提交。'
- en: This is really handy and creates a level of consistency that's very much appreciated
    when implementing a client. While testing, try to ensure that retrieving a value
    and resubmitting it is valid and doesn't create a problem.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便，并在实现客户端时创建了一个非常受欢迎的一致性水平。在测试时，请确保检索值并重新提交是有效的，并且不会造成问题。
- en: 'When the resource will be directly represented by binary content, it can return
    the proper format, specified in the `Content-Type` header. For example, retrieving
    the avatar resource may return an image file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当资源将由二进制内容直接表示时，它可以返回在`Content-Type`头中指定的正确格式。例如，检索头像资源可能返回一个图像文件：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the same way, when creating or updating a new avatar, it should be sent in
    the proper format.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，在创建或更新新头像时，应使用适当的格式发送。
- en: While the original intention of RESTful interfaces was to make use of multiple
    formats, for example, accepting XML and JSON, this is not very common in practice.
    JSON is, by and large, the most standard format these days. Some systems may benefit
    from using multiple formats, though.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然RESTful接口的原始意图是利用多种格式，例如接受XML和JSON，但在实践中这并不常见。总的来说，JSON是目前最标准的格式。尽管如此，一些系统可能从使用多种格式中受益。
- en: Another important property is ensuring that some actions are **idempotent**,
    and others are not. Idempotent actions can be repeated multiple times, producing
    the same result, while repeating not-idempotent actions will generate different
    results. Evidently, the action should be identical.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的属性是确保某些操作是**幂等的**，而其他操作则不是。幂等操作可以多次重复，产生相同的结果，而重复非幂等操作将产生不同的结果。显然，操作应该是相同的。
- en: A clear case of this is the creation of a new element. If we submit two identical
    `POST` creations of a new element of a resource list, it will create two new elements.
    For example, submitting two books with the same name and author will create two
    identical books.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个明显例子是创建新元素。如果我们提交两个相同的`POST`创建资源列表中新元素的请求，它将创建两个新元素。例如，提交两个同名和同作者的书籍将创建两本相同的书籍。
- en: This is assuming that there's no limitation to the content of the resource.
    If they are, the second request will fail, which will produce a different result
    to the first in any case.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在假设资源内容没有限制的情况下。如果有，第二次请求将失败，在任何情况下都会产生与第一次不同的结果。
- en: On the other hand, two `GET` requests will produce the same result. The same
    is true for `PUT` or `DELETE`, as they'll overwrite or "delete again" the resource.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，两个`GET`请求将产生相同的结果。对于`PUT`或`DELETE`也是如此，因为它们将覆盖或“再次删除”资源。
- en: The fact that the only non-idempotent requests are `POST` actions simplifies
    significantly the design of measures to deal with problems when there's the question
    of whether it should be retried. Idempotent requests are safe to retry at any
    time, thereby simplifying the handling of errors such as network problems.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 事实表明，唯一非幂等请求是`POST`操作，这显著简化了处理问题时是否应该重试的设计措施。幂等请求可以在任何时候安全地重试，从而简化了处理如网络问题等错误。
- en: Headers and statuses
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头部和状态
- en: An important detail of the HTTP protocol that can sometimes be overlooked is
    the different headers and status codes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议的一个重要细节有时可能会被忽视的是不同的头部和状态码。
- en: 'Headers include metadata information about the request or response. Some of
    it is added automatically, like the size of the body of the request or response.
    Some interesting headers to consider are the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 头部包括关于请求或响应的元数据信息。其中一些是自动添加的，例如请求或响应体的尺寸。以下是一些值得考虑的有趣头部：
- en: '| Header | Type | Details |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 头部 | 类型 | 详情 |'
- en: '| `Authorization` | Standard | Credentials to authenticate the request. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `Authorization` | 标准 | 用于验证请求的凭证。 |'
- en: '| `Content-Type` | Standard | The type of the body of the request, like `application/json`
    or `text/html`. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `Content-Type` | 标准 | 请求体的类型，如`application/json`或`text/html`。 |'
- en: '| `Date` | Standard | When the message was created. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `Date` | 标准 | 消息创建的时间。 |'
- en: '| `If-Modified-Since` | Standard | The sender has a copy of the resource at
    this time. If it hasn''t changed since then, a `304 Not Modified` response (with
    an empty body) can be returned. This allows the caching of data and saves time
    and bandwidth by not returning duplicated info. This can be used in `GET` requests.
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `If-Modified-Since` | 标准 | 发送者此时拥有资源的副本。如果自那时起没有变化，可以返回一个`304 未修改`响应（带有空体）。这允许缓存数据，并通过不返回重复信息来节省时间和带宽。这可以在`GET`请求中使用。
    |'
- en: '| `X-Forwarded-From` | De facto standard | Stores the IP where the message
    was originated, and the different proxies it went through. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `X-Forwarded-From` | 实际标准 | 存储消息起源的IP地址以及它经过的不同代理。 |'
- en: '| `Forwarded` | Standard | Same as `X-Forwarded-From`. This is a newer header
    and less common still than `X-Forwarded-From`. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `Forwarded` | 标准 | 与`X-Forwarded-From`相同。这是一个较新的头部，比`X-Forwarded-From`更不常见。
    |'
- en: A well-designed API will make use of headers to communicate proper information,
    for example, setting `Content-Type` correctly or accepting cache parameters if
    possible.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的API将利用头部来传达适当的信息，例如正确设置`Content-Type`或如果可能接受缓存参数。
- en: A comprehensive list of headers can be found at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)找到完整的头部列表。
- en: Another important detail is to make good use of available status codes. Status
    codes provide significant information about what happened, and using the most
    detailed information possible for each situation will provide a better interface.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要细节是充分利用可用的状态码。状态码提供了关于发生情况的重要信息，并且尽可能为每种情况使用最详细的信息将提供更好的接口。
- en: '**Some common status codes are as follows:**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**以下是一些常见的状态码：**'
- en: '| Status code | Description |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 状态码 | 描述 |'
- en: '| `200 OK` | A successful resource access or modification. It should return
    a body; if it doesn''t, use `204 No Content`. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `200 OK` | 成功的资源访问或修改。它应该返回一个体；如果不返回，则使用`204 无内容`。 |'
- en: '| `201 Created` | A successful `POST` request that creates a new resource.
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `201 已创建` | 成功的`POST`请求，用于创建新资源。 |'
- en: '| `204 No Content` | A successful request that doesn''t return a body, for
    example, a successful `DELETE` request. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `204 无内容` | 一个成功但不返回体的请求，例如成功的`DELETE`请求。 |'
- en: '| `301 Moved Permanently` | The accessed resource is now permanently located
    in a different URI. It should return a `Location` header with the new URI. Most
    libraries will follow up automatically for `GET` accesses. For example, the API
    is only accessible in `HTTPS`, but it was accessed in `HTTP`. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `301 永久移动` | 访问的资源现在永久位于不同的URI。它应该返回一个包含新URI的`Location`头。大多数库将自动跟进`GET`访问。例如，API仅可通过`HTTPS`访问，但被访问的是`HTTP`。
    |'
- en: '| `302 Found` | The accessed resource is temporarily located in a different
    URI. A typical example is being redirected to a login page if authenticated. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `302 找到` | 访问的资源临时位于不同的URI。一个典型例子是在经过身份验证后重定向到登录页面。 |'
- en: '| `304 Not Modified` | A cached resource is still valid. The body should be
    empty. This status code is only returned if the client requested cached information,
    for example, using the `If-Modified-Since` header. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `304 未修改` | 缓存的资源仍然有效。正文应为空。只有在客户端请求缓存信息时，例如使用`If-Modified-Since`头，才会返回此状态码。|'
- en: '| `400 Bad Request` | A generic error in the request. This is the server saying,
    "something went wrong on your end." A more descriptive message should be added
    to the body. If a more descriptive status code is possible, it should be preferred.
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `400 错误请求` | 请求中存在一个通用错误。这是服务器在说：“你的端发生了错误。”应该在正文中添加一个更详细的错误信息。如果可能的话，应该使用更详细的错误状态码。|'
- en: '| `401 Unauthorized` | The request is not allowed, as the request is not properly
    authenticated. The request may lack valid headers for authentication. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `401 未授权` | 请求不允许，因为请求没有正确认证。请求可能缺少用于认证的有效头。|'
- en: '| `403 Forbidden` | The request is authenticated, but it can''t access this
    resource. This is different from the `401 Unauthorized` status in that the request
    is already correctly authenticated but doesn''t have access. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `403 禁止` | 请求已认证，但不能访问此资源。这与`401 未授权`状态不同，因为请求已经正确认证，但没有访问权限。|'
- en: '| `404 Not Found` | Probably the most famous status code! The resource described
    by the URI cannot be found. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `404 未找到` | 这可能是最著名的状态码！由URI描述的资源无法找到。|'
- en: '| `405 Method Not Allowed` | The requested method cannot be used; for example,
    the resource cannot be deleted. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `405 方法不允许` | 请求的方法不能使用；例如，资源不能被删除。|'
- en: '| `429 Too Many Requests` | The server should return this status code if there''s
    a limit to the number of requests the client can do. It should return a description
    or more info in the body, and ideally, a `Retry-After` header indicating the time
    in seconds to the next retry. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `429 请求过多` | 如果客户端可以进行的请求数量有限制，服务器应返回此状态码。应在正文中返回描述或更多信息，并且理想情况下，返回一个`Retry-After`头，指示下一次重试的时间（以秒为单位）。|'
- en: '| `500 Server Error` | A generic error in the server. This status should only
    be used if an unexpected error happened in the server. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `500 服务器错误` | 服务器中存在一个通用错误。只有在服务器发生意外错误时才应使用此状态。|'
- en: '| `502 Bad Gateway` | The server is redirecting the request to a different
    server, and the communication was incorrect. This error normally appears when
    some backend service is unavailable or incorrectly configured. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `502 网关错误` | 服务器正在将请求重定向到不同的服务器，并且通信不正确。此错误通常出现在某些后端服务不可用或配置不正确的情况下。|'
- en: '| `503 Service Unavailable` | The server is currently unable to handle requests.
    Normally, this is a temporary situation, such as a load problem. It could be used
    to mark maintenance downtime, but this is generally rare. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `503 服务不可用` | 服务器目前无法处理请求。这通常是一个临时情况，例如负载问题。它可以用来标记维护停机时间，但这通常很少见。|'
- en: '| `504 Gateway Timeout` | Similar to `502 Bad Gateway`, but in this case, the
    backend service didn''t respond, provoking a timeout. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `504 网关超时` | 与`502 网关错误`类似，但在此情况下，后端服务没有响应，导致超时。|'
- en: In general, non-descriptive error codes such as `400 Bad Request` and `500 Server
    Error` should be left for general situations. However, if there is a better, more
    descriptive status code, this should be used instead.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，非描述性错误代码，如`400 错误请求`和`500 服务器错误`，应保留用于通用情况。然而，如果有更好的、更详细的错误状态码，则应使用该状态码。
- en: For example, a `PATCH` request to overwrite a parameter should return `400 Bad
    Request` if the parameter is incorrect for any reason, but `404 Not Found` if
    the resource URI is not found.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果要对参数进行覆盖的`PATCH`请求，如果参数由于任何原因不正确，则应返回`400 错误请求`，但如果资源URI未找到，则返回`404 未找到`。
- en: 'There are other status codes. You can check a comprehensive list, including
    details on each one, here: [https://httpstatuses.com/](https://httpstatuses.com/).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他的状态码。您可以在以下位置查看一个包含每个状态码详细信息的综合列表：[https://httpstatuses.com/](https://httpstatuses.com/).
- en: In any error, please include some extra feedback to the user with a reason.
    A general descriptor can help the handling of unexpected cases and simplify debugging
    issues.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何错误中，请向用户提供一些额外的反馈，包括原因。一个通用的描述符可以帮助处理意外情况并简化问题调试。
- en: This is especially useful for `4XX` errors as they will help users of the API
    to fix their own bugs and iteratively improve their integration.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于`4XX`错误特别有用，因为它们将帮助API的用户修复自己的错误，并迭代地改进他们的集成。
- en: 'For example, the mentioned `PATCH` may return this body:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，提到的`PATCH`可能会返回以下正文：
- en: '[PRE5]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will give specific details about the problem. Other options include returning
    error codes, multiple messages in case there are multiple possible errors, and
    also duplicating the status code in the body.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出关于问题的具体细节。其他选项包括返回错误代码、在存在多个可能错误的情况下返回多条消息，以及在正文中重复状态代码。
- en: Designing resources
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计资源
- en: The available actions in a RESTful API are limited to CRUD operations. Therefore,
    resources are the basic construction blocks for the API.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API中可用的操作仅限于CRUD操作。因此，资源是API的基本构建块。
- en: Making everything a resource helps to create very explicit APIs and helps with
    the stateless requirement for RESTful interfaces.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将一切变成资源有助于创建非常明确的API，并有助于满足RESTful接口的无状态要求。
- en: A stateless service means that all the information required to fulfill a request
    is either provided by the caller or retrieved externally, normally from a database.
    This excludes other ways of keeping information, such as storing information locally
    in the same server's hard drive. This makes any server capable of handling every
    single request, and it's critical in achieving scalability.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态服务意味着满足请求所需的所有信息要么由调用者提供，要么从外部检索，通常是从数据库中检索。这排除了其他保持信息的方式，例如在相同服务器的硬盘上本地存储信息。这使得任何服务器都能处理每个单独的请求，这对于实现可扩展性至关重要。
- en: 'Elements that could be activated by creating different actions could be separated
    into different resources. For example, an interface simulating a pen could require
    the following elements:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过创建不同的动作激活的元素可以分离到不同的资源中。例如，模拟笔的接口可能需要以下元素：
- en: Opening and closing the pen.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开启和关闭笔。
- en: Writing something. Only an open pen can write.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写东西。只有开启的笔才能书写。
- en: 'In some APIs, like an object-oriented one, this could involve creating a pen
    object and changing its state:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些API中，如面向对象的API，这可能涉及创建笔对象并更改其状态：
- en: '[PRE6]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In a RESTful API, we need to create different resources for both the pen and
    its status:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在RESTful API中，我们需要为笔及其状态创建不同的资源：
- en: '[PRE7]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This may look a bit cumbersome, but RESTful APIs should aim to be higher level
    than the typical object-oriented one. Either create the text directly, or create
    a pen and then the text, without having to perform the open/close operation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点繁琐，但RESTful API应该旨在比典型的面向对象API更高层次。可以直接创建文本，或者创建笔然后创建文本，而不必执行开启/关闭操作。
- en: Keep in mind that RESTful APIs are used in the context of remote calls. This
    means that they can't be low level, as each call is a big investment compared
    with a local API, as the time per call will be a sensible part of the operation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，RESTful API是在远程调用上下文中使用的。这意味着它们不能是低级的，因为与本地API相比，每个调用都是一个大的投资，因为调用时间将是操作中一个合理的部分。
- en: Note also that every single aspect and step gets registered and has its own
    set of identifiers and is addressable. This is more explicit than the internal
    state that can be found in OOP. As we've seen, we want it to be stateless, while
    objects are very much stateful.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个方面和步骤都会被注册，并有自己的标识符集，是可寻址的。这比面向对象中可以找到的内部状态更明确。正如我们所看到的，我们希望它是无状态的，而对象则非常具有状态性。
- en: Keep in mind that a resource doesn't need to be translated directly into a database
    object. That's thinking backward, from the storage to the API. Remember that you
    are not limited to that, and can compose resources that obtain information from
    multiple sources or that don't fit into a direct translation. We will see examples
    in the next chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，资源不一定需要直接翻译成数据库对象。这是从存储到API的逆向思维。记住，你并不局限于这一点，可以组合从多个来源获取信息或不适合直接翻译的资源。我们将在下一章中看到示例。
- en: Dealing only with resources can require certain adaptations if coming from a
    more traditional OOP environment, but they are a pretty flexible tool and can
    allocate multiple ways of performing actions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果来自更传统的面向对象环境，仅处理资源可能需要某些适应，但它们是非常灵活的工具，可以分配多种执行动作的方式。
- en: Resources and parameters
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源和参数
- en: While everything is a resource, some elements make more sense as a parameter
    that interacts with the resource. This is very natural when modifying the resource.
    Any change needs to be submitted to update the resource. But, in other cases,
    some resources could be modified for other causes. The most common case is searches.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一切都是资源，但某些元素作为与资源交互的参数更有意义。这在修改资源时非常自然。任何更改都需要提交以更新资源。但是，在其他情况下，某些资源可能因其他原因而修改。最常见的情况是搜索。
- en: 'A typical search endpoint will define a `search` resource and retrieve its
    results. However, a search without parameters to filter is not really useful,
    so extra parameters will be required to define the search, for example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的搜索端点将定义一个 `search` 资源并检索其结果。然而，没有过滤参数的搜索实际上并不实用，因此需要额外的参数来定义搜索，例如：
- en: '[PRE8]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These parameters are stored in query parameters, which are natural extensions
    to retrieve them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数存储在查询参数中，这是检索它们的自然扩展。
- en: As a general rule, only `GET` requests should have query parameters. Other kinds
    of request methods should provide any parameters as part of the body.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，只有 `GET` 请求应该有查询参数。其他类型的请求方法应将任何参数作为正文的一部分提供。
- en: '`GET` requests are also easy to cache if including the query parameters. If
    the search is returning the same values for each request, given that that''s an
    idempotent request, the full URI, including the query parameters, can be cached
    even externally from the service.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包含查询参数，`GET` 请求也容易进行缓存。如果搜索返回每个请求相同的值，鉴于这是一个幂等请求，包括查询参数在内的完整 URI 可以在外部进行缓存。
- en: By convention, all logs that store `GET` requests will also store the query
    params, while any parameter sent as a header or in the body of the request won't
    be logged. This has security implications, as any sensible parameter, such as
    a password, shouldn't be sent as a query parameter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，存储 `GET` 请求的所有日志也将存储查询参数，而作为请求头或正文发送的任何参数都不会被记录。这具有安全影响，因为任何合理的参数，如密码，都不应该作为查询参数发送。
- en: Sometimes, that's the reason to create `POST` operations that typically would
    be a `GET` request, but prefer to set parameters in the body of the request instead
    of query parameters. While it is possible in the HTTP protocol to set the body
    in a `GET` request, it's definitely very unusual.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这是创建通常会是 `GET` 请求的 `POST` 操作的原因，但更倾向于在请求的正文而不是查询参数中设置参数。虽然在 HTTP 协议中可以在 `GET`
    请求中设置正文，但这绝对是非常不寻常的。
- en: An example of this could be searching by phone number, email, or other personal
    information, so a middle-man agent could intercept and learn about them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的例子可能是通过电话号码、电子邮件或其他个人信息进行搜索，因此中间人代理可以拦截并了解它们。
- en: Another reason to use `POST` requests is to allow a bigger space for parameters,
    as the full URL, including query parameters, is normally limited to 2K in size,
    while bodies are much less restricted in size.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `POST` 请求的另一个原因是允许更大的参数空间，因为包括查询参数在内的完整 URL 通常限制在 2K 大小，而正文的大小限制则小得多。
- en: Pagination
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分页
- en: In a RESTful interface, any `LIST` request that returns a sensible number of
    elements should be paginated.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RESTful 接口中，任何返回合理数量元素的 `LIST` 请求都应该进行分页。
- en: This means that the number of elements and pages can be tweaked from the request,
    returning only a specific page of elements. This limits the scope of the request
    and avoids very slow response times and waste transmission bytes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着可以从请求中调整元素和页面的数量，只返回特定页面的元素。这限制了请求的范围，避免了非常慢的响应时间和传输字节的浪费。
- en: 'An example could involve using the parameters `page` and `size`, for example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可能涉及使用 `page` 和 `size` 参数，例如：
- en: '[PRE9]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A well-constructed response will have a similar format to this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一个构建良好的响应将具有与此类似的格式：
- en: '[PRE10]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It contains a `result` field with the resulting list and `next` and `previous`
    fields that are hyperlinks to the next and previous page, with a value of `null`
    if it is not available. This makes it easy to walk through all the results.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含一个 `result` 字段，其中包含结果列表，以及 `next` 和 `previous` 字段，它们是到下一页和上一页的超链接，如果不可用，则值为
    `null`。这使得遍历所有结果变得容易。
- en: A `sort` parameter could also be useful to ensure consistency in pages.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `sort` 参数也可以用来确保页面的一致性。
- en: This technique also allows multiple pages to be retrieved in parallel, which
    can speed up the downloading of information, doing several small requests instead
    of one big one. The objective, though, is to provide sufficient filter parameters
    for generally returning not too much information, being able to retrieve only
    the relevant information.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术还允许并行检索多页，这可以加快信息的下载速度，通过进行几个小请求而不是一个大请求来实现。然而，目标是为通常返回不太多的信息提供足够的过滤参数，以便只检索相关信息。
- en: 'Pagination has a problem, which is that the data in the collection may change
    between multiple requests, especially if retrieving many pages. The problem is
    as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 分页有一个问题，即集合中的数据可能在多个请求之间发生变化，尤其是在检索多页时。问题如下：
- en: '[PRE11]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The second page now has a repeated element that used to be on the first page
    but has now moved to the second, and then there's one element that's not returned.
    Normally, the non-return of the new resource is not that much of a problem, as,
    after all, the retrieval of information started before its creation. However,
    the return of the same resource twice can be.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第二页现在有一个重复的元素，它曾经在一页上，但现在已移动到第二页，然后还有一个未返回的元素。通常，新资源的未返回并不是一个大问题，因为毕竟信息检索是在其创建之前开始的。然而，相同资源的重复返回可能会是。
- en: To avoid this kind of problem, there's the possibility of sorting by default
    the values by creation date or something analogous. This way, any new resource
    will be added at the end of pagination and will be consistently retrieved.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这类问题，默认按创建日期或类似方式排序值是有可能的。这样，任何新的资源都将添加到分页的末尾，并且可以一致地检索。
- en: For resources that return inherently "new" elements, like notifications or similar,
    add an `updated_since` parameter to retrieve only the new resources since the
    most recent access. This speeds up access in a practical way and retrieves only
    the relevant information.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于返回固有“新”元素的资源，如通知或类似资源，添加一个`updated_since`参数以检索自最近访问以来仅有的新资源。这以实际方式加快了访问速度，并检索了相关信息。
- en: Creating a flexible pagination system increases the usefulness of any API. Be
    sure that your pagination definition is consistent across any different resources.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个灵活的分页系统可以增加任何API的有用性。确保您的分页定义在所有不同资源中是一致的。
- en: Designing a RESTful API process
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计RESTful API的过程
- en: 'The best way to start designing a RESTful API is to clearly state the resources
    and then describe them, including the following details:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 设计RESTful API的最佳方式是明确声明资源，然后描述它们，包括以下细节：
- en: '*Description*: Description of the action'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*描述*：操作的描述'
- en: '*Resource URI*: Note that this may be shared for several actions, differentiated
    by the method (for example, GET to retrieve and DELETE to delete)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源URI*：请注意，这可以用于多个操作，通过方法区分（例如，GET用于检索和DELETE用于删除）'
- en: '*Methods applicable*: The HTTP method to use for the action defined in this
    endpoint'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*适用的方法*：在此端点定义的操作中使用的HTTP方法'
- en: '*(Only if relevant) Input body*: The input body of the request'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*(只有相关时) 输入体*：请求的输入体'
- en: '*Expected result in the body*: Result'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*预期结果在体中*：结果'
- en: '*Possible expected errors*: Returning status codes depending on specific errors'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可能预期的错误*：根据特定错误返回状态码'
- en: '*Description*: Description of the action'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*描述*：操作的描述'
- en: '*(Only if relevant) Input query parameters*: Query parameters to add to the
    URI for extra functionality'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*(只有相关时) 输入查询参数*：要添加到URI的查询参数以提供额外功能'
- en: '(*Only if relevant) Relevant headers*: Any supported header'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (*只有相关时) 相关头信息*：任何支持的头部
- en: '*(Only if relevant) Returning status codes out of the ordinary (200 and 201)*:
    Different from errors, in case there''s a status code that''s considered a success
    but it''s not the usual case; for example, a success returns a redirection'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*(只有相关时) 返回非普通状态码（200和201）*：与错误不同，如果存在被认为是成功但不是常规情况的状态码；例如，成功返回重定向'
- en: This will be enough to create a design document that can be understood by other
    engineers and allow them to work on the interface.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这将足够创建一个其他工程师可以理解的设计文档，并允许他们在此接口上工作。
- en: It is good practice, though, to start with a quick draft of the different URIs
    and methods, and to have a quick look at all the different resources that the
    system has without getting into too much detail, such as a body description or
    errors. This helps to detect missing resource gaps or other kinds of inconsistencies
    in the API.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，先快速草拟不同的URI和方法，并快速查看系统中的所有不同资源，而不深入细节，如正文描述或错误，是一种良好的实践。这有助于检测API中缺失的资源差距或其他不一致性。
- en: 'For example, the API described in this chapter has the following actions:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，本章中描述的API有以下操作：
- en: '[PRE12]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are a couple of details that can be tweaked and improved here:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些细节可以调整和改进：
- en: It looks like we forgot to add the action to remove a pen, once created
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看起来我们忘记添加删除笔的动作了，一旦创建
- en: There are a couple of `GET` actions for retrieving information about the created
    resource that should be added
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该添加几个`GET`操作来检索有关已创建资源的详细信息
- en: In the `PUT` action, it feels a bit redundant to have to add `/text`
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`PUT`操作中，添加`/text`感觉有点冗余
- en: 'With this feedback, we can again describe the API as follows (modifications
    have an arrow):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个反馈的基础上，我们再次如下描述API（修改处有箭头）：
- en: '[PRE13]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note how the organization in the hierarchical structure helps to take a good
    look at all the elements and find either gaps or relations that may not be obvious
    at first glance.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在分层结构中的组织如何有助于仔细查看所有元素，并找到可能一开始并不明显的空白或关系。
- en: 'After that, we can get into details. We can use the template described at the
    start of the section, or any other one that works for you. For example, we can
    define the endpoints to create a new pen and read a pen in the system:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以深入了解。我们可以使用本节开头描述的模板，或者任何适合你的其他模板。例如，我们可以定义创建一个新笔和读取系统中笔的端点：
- en: '**Creating a new pen:**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建一个新的笔：**'
- en: '*Description*: Creates a new pen, specifying the color.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*描述*：创建一个新的笔，指定颜色。'
- en: '*Resource URI*: `/pens`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源URI*： `/pens`'
- en: '*Method*: `POST`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*方法*： `POST`'
- en: '*Input body*:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*输入体*：'
- en: '[PRE14]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Errors*:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*错误*：'
- en: '[PRE15]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Error in the body, such as an unrecognized color, a duplicated name, or a bad
    format.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 主体中的错误，例如一个未识别的颜色、重复的名称或格式错误。
- en: '**Retrieving an existing pen:**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**检索现有的笔：**'
- en: '*Description*: Retrieves an existing pen.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*描述*：检索现有的笔。'
- en: '*Resource URI*: `/pens/<pen id>`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源URI*： `/pens/<pen id>`'
- en: '*Method*: `GET`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*方法*： `GET`'
- en: '*Return body*:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*返回体*：'
- en: '[PRE16]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Errors*:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*错误*：'
- en: '[PRE17]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The main objective is that these small templates are useful and to the point.
    Feel free to tweak them as expected, and don't worry about being too completist
    with the errors or details. The most important part is that they are **useful**;
    for example, adding a `405 Method Not Allowed` message could be redundant.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 主要目标是这些小模板既实用又简洁。请随意按预期调整它们，不必担心对错误或细节过于详尽。最重要的是它们是**实用**的；例如，添加一个`405 Method
    Not Allowed`消息可能是多余的。
- en: The API can also be designed using tools such as Postman ([www.postman.com](https://www.postman.com)),
    which is an API platform that can be used to either design or test/debug existing
    APIs. While useful, it is good to be able to design an API without external tools,
    in case that's required, and because it forces you to think about the design and
    not necessarily the tool itself. We will also see how to use Open API, which is
    based more on the definition, and not so much on providing a test environment.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: API也可以使用Postman ([www.postman.com](https://www.postman.com))等工具设计，这是一个API平台，可以用来设计或测试/调试现有的API。虽然很有用，但能够在不使用外部工具的情况下设计API是很好的，以防万一需要，并且因为它迫使你思考设计而不是工具本身。我们还将看到如何使用基于定义的Open
    API，而不是提供测试环境。
- en: Designing and defining an API can also enable it to be structured in a standard
    manner afterward to take advantage of tools.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 设计和定义一个API也可以使其在之后以标准方式结构化，以便利用工具。
- en: Using the Open API specification
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Open API规范
- en: A more structured alternative is to use a tool such as Open API ([https://www.openapis.org/](https://www.openapis.org/)).
    Open API is a specification for defining a RESTful API through a YAML or JSON
    document. This allows this definition to interact with other tools to generate
    automatic documentation for the API.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更结构化的替代方案是使用像Open API ([https://www.openapis.org/](https://www.openapis.org/))这样的工具。Open
    API是通过YAML或JSON文档定义RESTful API的规范。这允许这个定义与其他工具交互，为API生成自动文档。
- en: It allows the definition of different components that can be repeated, both
    as input and output. This makes it easy to build consistent reusable objects.
    There are also ways of inheriting or composing from one another, thereby creating
    a rich interface.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许定义可以重复的不同组件，无论是作为输入还是输出。这使得构建一致的可重复使用的对象变得容易。还有从彼此继承或组合的方法，从而创建一个丰富的接口。
- en: Describing the whole Open API specification in detail is beyond the scope of
    this book. Most common web frameworks allow integration with it, generating the
    YAML file automatically or the web documentation that we'll see later. It was
    previously called Swagger and its web page ([https://swagger.io/](https://swagger.io/))
    has a very useful editor and other resources.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 详细描述整个Open API规范超出了本书的范围。大多数常见的Web框架都允许与之集成，自动生成YAML文件或我们稍后看到的Web文档。它之前被称为Swagger，其网页([https://swagger.io/](https://swagger.io/))有一个非常有用的编辑器和其他资源。
- en: 'For example, this is a YAML file that describes the two endpoints described
    above. The file is available on GitHub: [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/pen_example.yaml](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/pen_example.yaml):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个描述上述两个端点的YAML文件。该文件可在GitHub上找到：[https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/pen_example.yaml](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/pen_example.yaml)
- en: '[PRE18]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the `components` part, the `Pen` object gets defined, and then is used in
    both endpoints. You can see how both endpoints, `POST /pens` and `GET /pens/{pen_id}`,
    are defined and describe the expected input and output, taking into account the
    different errors that can be produced.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在`components`部分，定义了`Pen`对象，然后在其两个端点中使用。您可以看到如何定义两个端点，`POST /pens`和`GET /pens/{pen_id}`，并描述预期的输入和输出，考虑到可能产生的不同错误。
- en: 'One of the most interesting aspects of Open API is the ability to automatically
    generate a documentation page with all the information to help any possible implementation.
    The generated documentation looks like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Open API最有趣的特点之一是能够自动生成包含所有信息的文档页面，以帮助任何可能的实现。生成的文档看起来像这样：
- en: '![Graphical user interface, text, application, email'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，文本，应用程序，电子邮件]'
- en: Description automatically generated](img/B17580_02_01.png)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_02_01.png)
- en: 'Figure 2.1: Swagger Pens documentation'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：Swagger Pens文档
- en: If the YAML file describes your interface correctly and fully, this can be really
    useful. In some cases, it could be advantageous to work from the YAML to the API.
    This first generates the YAML file and allows work in both directions from there,
    both in the frontend direction and the backend direction. For an API-first approach,
    it may make sense. It's even possible to automatically create skeletons of clients
    and servers in multiple languages, for example, servers in Python Flask or Spring,
    and clients in Java or Angular.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果YAML文件正确且完整地描述了您的界面，这将非常有用。在某些情况下，从YAML到API的工作可能更有优势。这首先生成YAML文件，并允许从那里双向工作，无论是前端方向还是后端方向。对于以API为先的方法，这可能是有意义的。甚至可以自动在多种语言中创建客户端和服务器的基本框架，例如，Python
    Flask或Spring中的服务器，以及Java或Angular中的客户端。
- en: Keep in mind that it's up to you to make the implementation match the definition
    closely. These skeletons will still require enough work to make them work correctly.
    Open API will simplify the process, but it won't magically solve all integration
    problems.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，确保实现与定义紧密匹配的责任在于您。这些基本框架仍然需要足够的工作才能正确运行。Open API将简化这个过程，但不会神奇地解决所有集成问题。
- en: 'Each of the endpoints contains further information and can even be tested in
    the same documentation, thereby significantly helping an external developer who
    wants to use the API, as we can see in the next graphic:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 每个端点都包含更多信息，甚至可以在同一文档中进行测试，从而极大地帮助希望使用API的外部开发者，正如我们可以在下一张图中看到：
- en: '![Graphical user interface, application'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，应用程序]'
- en: Description automatically generated](img/B17580_02_02.png)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_02_02.png)
- en: 'Figure 2.2: Swagger Pens expanded documentation'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：Swagger Pens扩展文档
- en: Given that it's very easy to ensure that the server can generate this automatic
    documentation, even if the design is not started from an Open API YAML file, it's
    a good idea to generate it so as to create self-generating documentation.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到即使设计不是从Open API YAML文件开始的，也很容易确保服务器可以生成这种自动文档，因此生成它是件好事，以便创建自生成文档。
- en: Authentication
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: A critical part of virtually any API is the ability to distinguish between authorized
    and unauthorized access. Being able to log the user properly is critical, and
    a headache from the point of view of security.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何API的关键部分都是能够区分授权和不授权的访问。能够正确记录用户至关重要，从安全角度来看，这是一个头疼的问题。
- en: Security is hard, so it's better to rely on standards to simplify the operation.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性很难，因此最好依赖于标准来简化操作。
- en: As we said before, these are just general tips, but in no way a comprehensive
    set of secure practices. This book is not focused on security. Please keep up
    with security issues and solutions, as this is a field that is always evolving.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，这些只是一些一般性的建议，但绝不是一套全面的网络安全实践。本书并不专注于安全。请关注安全问题及其解决方案，因为这是一个始终在发展的领域。
- en: The most important security issue regarding authentication is **to always use
    HTTPS endpoints** **in production**. This allows the channel to be protected against
    eavesdropping and makes communication private. Note that an HTTP website just
    means that the communication is private; you could be talking with the devil.
    But it's the bare minimum required to allow users of your API to send you passwords
    and other sensitive information without the fear that an external user is going
    to receive this information.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与认证相关的最重要的安全问题是在生产环境中始终使用HTTPS端点。这允许保护通道免受窃听，并使通信私密。请注意，一个HTTP网站仅仅意味着通信是私密的；你可能在和恶魔交谈。但它是最基本的要求，允许您的API用户发送密码和其他敏感信息，而不用担心外部用户会接收到这些信息。
- en: Normally, most architectures use HTTPS until the request reaches the data center
    or secure network, and then use HTTP internally. This permits a check on the data
    flowing internally but also protects data that is traveling across the internet.
    While less important these days, it also improves efficiency, as encoding requests
    in HTTPS require extra processing power.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，大多数架构在请求达到数据中心或安全网络之前使用HTTPS，然后内部使用HTTP。这允许检查内部流动的数据，同时也保护了跨互联网传输的数据。虽然现在这不太重要，但它也提高了效率，因为将请求编码为HTTPS需要额外的处理能力。
- en: HTTPS endpoints are valid for all access, but other details are specific depending
    on whether they are HTML interfaces or RESTful ones.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS端点对所有访问都有效，但其他细节取决于它们是HTML界面还是RESTful界面。
- en: Authenticating HTML interfaces
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证HTML界面
- en: 'In HTML web pages, normally, the flow to authenticate is as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML网页中，通常验证流程如下：
- en: A login screen gets presented to the user.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户界面会显示登录界面。
- en: The user enters their login and password and sends them to the server.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户输入他们的登录名和密码，并将它们发送到服务器。
- en: The server verifies the password. If correct, it returns a cookie with a session
    ID.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器验证密码。如果正确，它将返回一个包含会话ID的cookie。
- en: The browser receives the response and stores the cookie.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器接收到响应并存储cookie。
- en: All new requests will send the cookie. The server will verify the cookie and
    properly identify the user.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有新的请求都会发送cookie。服务器将验证cookie并正确识别用户。
- en: The user can log out, removing the cookie. If this is done explicitly, a request
    will be sent to the server to delete the session ID. Typically, the session ID
    will have an expiry time for cleaning itself. This expiry can renew itself on
    each access or force the user to log in again from time to time.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可以注销，删除cookie。如果这样做是明确的，则会向服务器发送请求以删除会话ID。通常，会话ID将有一个过期时间来自动清理。这个过期时间可以在每次访问时更新，或者强制用户时不时地重新登录。
- en: It's important to set up the cookie as `Secure`, `HttpOnly`, and `SameSite`.
    `Secure` ensures that the cookie is only sent to HTTPS endpoints, and not to HTTP
    ones. `HttpOnly` renders the cookie inaccessible by JavaScript, which makes it
    more difficult to obtain the cookie via malicious code. The cookie will be sent
    automatically to the host that sets it. `SameSite` ensures that cookies are only
    sent when the origin of the source is a page from the same host. It can be set
    to `Strict`, `Lax`, and `None`. `Lax` allows you to navigate to the page from
    a different site, thereby sending the cookie, while `Strict` doesn't allow it.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 将cookie设置为`Secure`、`HttpOnly`和`SameSite`非常重要。`Secure`确保cookie只发送到HTTPS端点，而不是HTTP端点。`HttpOnly`使cookie无法通过JavaScript访问，这使得通过恶意代码获取cookie更加困难。cookie将自动发送到设置它的主机。`SameSite`确保只有在源页面来自同一主机时才会发送cookie。它可以设置为`Strict`、`Lax`和`None`。`Lax`允许您从不同站点导航到页面，从而发送cookie，而`Strict`则不允许。
- en: 'You can obtain more information at the Mozilla SameSite Cookie page: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Mozilla SameSite Cookie页面获取更多信息：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)。
- en: Possible bad usage of the cookie is through XSS (cross-site scripting) attacks.
    A compromised script reads that cookie, and then forges bad requests authenticated
    as the user.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: cookie的潜在不良使用是通过XSS（跨站脚本）攻击。受损害的脚本读取该cookie，然后伪造出作为用户认证的恶意请求。
- en: Another important kind of security problem is **cross-site request forgery**
    (**CSRF**). In this case, the fact that the user is logged in on an external service
    is exploited by presenting a URL that will be automatically executed in a different,
    compromised website.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: For example, while accessing a forum, a URL from a common bank is called, presented
    as an image, for example. If the user is logged in to this bank, the operation
    will be executed.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The `SameSite` attribute greatly reduces the risk of CSRF, but in case the attribute
    is not understood by older browsers, operations presented to the user by the bank
    should present a random token, making the user send both the authenticated request
    with the cookie and a valid token. An external page won't know a valid random
    token, making this exploit much more difficult.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: The session ID that the cookie contains can either be stored in the database,
    being just a random unique identifier, or a rich token.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: A random identifier is just that, a random number that stores the related information
    in the database, mainly, who is accessing and when the session expires. With every
    access, this session ID is queried to the server and the related information is
    retrieved. On very big deployments, with many accesses, this can create problems
    as it's less scalable. The database where the session ID is stored needs to be
    accessed by all workers, which can create a bottleneck.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: One possible solution is to create a rich data token. This works by adding all
    the required information directly to the cookie; for example, storing the user
    ID, expiry, and so on, directly. This avoids database access, but makes the cookie
    possible to forge, as all information is in the open. To fix it, the cookie is
    signed.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The signature proves that the data was originated by a trusted login server
    and can be verified independently by any other server. This is more scalable and
    avoids bottlenecks. Optionally, the content can also be encrypted to avoid being
    read.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of this system is that the generation of the token can be
    independent of the general system. If the token can be validated independently,
    there's no need for the login server to be the same as the general server.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Even more so, a single token signer can issue tokens for multiple services.
    This is the basis for **SSO** (**Single Sign-On**): log in to an auth provider
    and then use the same account in several related services. This is very common
    in common services such as Google, Facebook or GitHub, to avoid having to create
    a specific login for some web pages.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: That operation mode, having a token authority, is the basis of the OAuth authorization
    framework.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating RESTful interfaces
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OAuth has become a common standard for authenticating access for APIs, and RESTful
    APIs in particular.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: There's a difference between authenticating and authorizing, and in essence,
    OAuth is an authorization system. Authenticating is determining who the user is,
    while authorizing is what the user is capable of doing. OAuth uses the concept
    of `scope` to return what the capabilities of a user are.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Most implementations of OAuth, such as OpenID Connect, also include the user
    information in the returning token to also authenticate the user, returning who
    the user is.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'It is based on the idea that there''s an authorizer who can check the identity
    of the user and provide them with a token with information allowing the user to
    log in. The service will receive this token and will log the user:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_02_03.png)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.3: Authentication flow'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The most common version at the moment is OAuth 2.0, which allows flexibility
    in terms of logging in and flow. Keep in mind that OAuth is not exactly a protocol,
    but provides certain ideas that can be tweaked to the specific use case.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: This means that there are different ways in which you can implement OAuth, and,
    crucially, that different authorizers will implement it differently. Please verify
    their documentation with care when implementing the integration.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Generally, authorizers use the OpenID Connect protocol, which is based on OAuth.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: There's an important difference in terms of whether the system accessing the
    API is the final user directly, or whether it accesses it on behalf of a user.
    An example of the latter could be a smartphone app to access a service like Twitter,
    or a service that needs to access the data stored for the user in GitHub, such
    as a code analysis tool. The app itself is not the one that performs the actions
    but transfers the actions of a user.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: This flow is called the Authorization Code grant. The main characteristic is
    that the auth provider will present a login page to the user and redirect them
    with the authentication token.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this could be the sequence of calls for the Authorization Code
    grant:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the system accessing the API is from the end user directly, the Client Credentials
    grant type flow can be used instead. In this case, the first call will send `client_id`
    (user ID) and `client_secret` (password) to retrieve the authentication token
    directly. This token will be set in new calls as a header, authenticating the
    request.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this skips a step, and is easier to automate:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: While OAuth allows you to use an external server to retrieve the access token,
    that's not strictly required. It can be the same server as the rest. This is useful
    for this last flow, where the ability to log in with an external provider such
    as Facebook or Google is not as useful. Our example system will use the Client
    Credentials flow.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Self-encoded tokens
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The returned tokens from the authorization server can contain sufficient information
    such that no external check with the authorizer is required.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: As we've seen, including the user information in the token is important to determine
    who the user is. If not, we will end with a request that is capable of doing the
    work, but without information on behalf of who.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: To do so, the token is typically encoded in a **JSON Web Token** (**JWT**).
    A JWT is a standard that encodes a JSON object in a URL-safe sequence of characters.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'A JWT has the following elements:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: A header. This contains information on how the token is encoded.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A payload. The body of the token. Some of the fields in this object, called
    claims, are standard, but it can allocate custom claims as well. Standard claims
    are not required and can describe elements such as the issuer (`iss`), or the
    expiration time of the token as Unix Epoch (`exp`).
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A signature. This verifies that the token was generated by the proper source.
    This uses different algorithms, based on the information in the header.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, a JWT is encoded, but it's not encrypted. A standard JWT library
    will decode its parts and verify that the signature is correct.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test the different fields and systems in the interactive tool: [https://jwt.io/](https://jwt.io/).'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to generate a token using `pyjwt` ([https://pypi.org/project/PyJWT/](https://pypi.org/project/PyJWT/)),
    you''ll need to install PyJWT using pip if not previously installed:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, while opening a Python interpreter, to create a token with a payload
    with a user ID and an HS256 algorithm to sign it with the `"secret"` secret, you
    use the following code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The JWT token can then be decoded and the payload extracted. If the secret
    is incorrect, it will produce an error:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The algorithm to be used is stored in the headers, but it''s a good idea, for
    reasons of security, to only validate the token with the expected algorithm and
    not rely on the header. In the past, there have been some security problems with
    certain JWT implementations and forgery of the tokens, as you can read here: [https://www.chosenplaintext.ca/2015/03/31/jwt-algorithm-confusion.html](https://www.chosenplaintext.ca/2015/03/31/jwt-algorithm-confusion.html).'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: The most interesting algorithms, though, are not symmetrical ones like `HS256`,
    where the same value is added for encoding and decoding, but public-private keys
    like RSA-256 (`RS256`). This allows the token to be encoded with the private key
    and verified with the public key.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: This schema is very common, as the public key can be distributed widely, but
    only the proper authorizer who has the private key can be the source of the tokens.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Including the payload information that can be used to identify the user allows
    authentication of the requests using just the information in the payload, once
    verified, as we discussed earlier.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Versioning the API
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are rarely created fully formed from scratch. They are constantly
    being tweaked, with new features added, and bugs or inconsistencies fixed. To
    better communicate these changes, it's useful to create some sort of versioning
    to transmit this information.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Why versioning?
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main advantage of versioning is to shape the conversation about what things
    are included when. This can be bug fixes, new features, or even newly introduced
    bugs.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: If we know that the current interface released is version `v1.2.3`, and we are
    about to release version `v1.2.4`, which fixes bug X, we can talk about it more
    easily, as well as creating release notes informing users of that fact.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Internal versus external versioning
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two kinds of versions that can get a bit confused. One is the internal
    version, which is something that makes sense for the developers of a project.
    This is normally related to the version of the software, usually with some help
    from version control, such as Git.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: This version is very detailed and can cover very small changes, including small
    bug fixes. The aim of it is to be able to detect even minimal changes between
    software to allow the detection of bugs or the introduction of code.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: The other is the external version. The external version is the version that
    people using the external service are going to be able to perceive. While this
    can be as detailed as the internal one, that is normally not that helpful to users
    and can provide a confusing message.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: This largely depends on the kind of system and who their expected users are.
    A highly technical user will appreciate the extra details, but a more casual one
    will not.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: For example, an internal version may distinguish between two different bug fixes,
    as this is useful to replicate. An externally communicated version can combine
    them both in "multiple bug fixes and improvements."
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Another good example of when it's useful to make a difference is when the interface
    changes massively. For example, a brand-new revamp of the look and feel of a site
    could use "Version 2 interface," but this can happen over multiple internal new
    versions, to be tested internally or by a selected group (for example, beta testers).
    Finally, when the "Version 2 interface" is ready, it can be activated for all
    users.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: One way of describing the external version could be to call it a "marketing
    version."
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Note that here we are avoiding the term "release version" as it could be misleading.
    This version is only used to communicate information externally.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: This version will be more dependent on marketing efforts than technical implementation.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common pattern for defining versions is to use semantic versioning. Semantic
    versioning describes a method with three increasing integers that carry different
    meanings, in descending order of incompatibility:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '`vX.Y.Z`'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: X is called the **major** version. Any change in the major version will mean
    backward-incompatible changes.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Y is the **minor** version. Minor changes may add new features, but any change
    will be backward compatible.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Z is the **patch** version. It will only make small changes such as bug fixes
    and security patches, but it doesn't change the interface itself.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: The `v` at the start is optional but helps to indicate that it's a version number.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: This means that software designed to work with `v1.2.15` will work with versions
    `v1.2.35` and `v1.3.5`, but it won't work with version `v2.1.3` or version `v1.1.4`.
    It may work with version `v1.2.14`, but it may have some bug that was corrected
    later.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, extra details can be added to describe interfaces that are not ready,
    for example, `v1.2.3-rc1` (release candidate) or `v1.2.3-dev0` (development version).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Normally, before the software is ready for release, the major number is set
    to zero (for example, `v0.1.3`), making version `v1.0.0` the first one to be publicly
    available.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'This semantic versioning is very easy to understand and gives good information
    about changes. It is widely used, but it has some problems in certain cases:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Strictly adopting the major version for systems that don't have clear backward
    compatibility can be difficult. This was the reason why the Linux kernel stopped
    using proper semantic versioning, because they will never update the major version,
    as every single release needed to be backward compatible. In that case, a major
    version can be frozen for years and years and stops being a useful reference.
    In the Linux kernel, that happened with version 2.6.X, which remained for 8 years
    until version 3.0 was released in 2011 without any backward-incompatible change.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semantic versioning requires a pretty strict definition of the interface. If
    the interface changes often with new features, as happens typically with online
    services, the minor version increases quickly, and the patch version is of almost
    no use.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For online services, the combination of both will make only a single number
    useful, which is not a great use of it. Semantic versioning works better for cases
    that require multiple API versions working at the same time, for example:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: The API is very stable and changes very rarely, though there are regular security
    updates. Every couple of years, there's a major update. A good example is databases,
    such as MySQL. Operative systems are another example.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API belongs to a software library that can be used by multiple supported
    environments; for example, a Python library compatible with Python 2 for version
    v4 and Python 3 for v5\. This can allow several versions to be kept alive if required.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the system effectively has a single version running at the same time, it
    is better to not add the extra effort to keep proper semantic versioning in place
    as the effort is not worth the reward in terms of the kind of investment required.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Simple versioning
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of doing strict semantic versioning, a simplified version can be done
    instead. This won't carry the same kind of meaning, but it will be a constantly
    increasing counter. This will work to coordinate teams, although it won't require
    the same kind of commitment.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: This is the same idea as the build number that can be created automatically
    by compilers, an increasing number to distinguish one version from another and
    work as a reference. However, a plain build number can be a bit dry to use.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'It is better to use a similar structure to semantic versioning, as it will
    be understandable by everyone; but instead of using it with specific rules, it
    is looser than that:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Normally, for a new version, increase the patch version.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If either the patch version gets too high (in other words, 100, 10, or another
    arbitrary number), increase the minor version and set the patch version to zero.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, if there's any special milestone for the project, as defined
    by the people working on it, increase the minor number earlier.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do the same with the major version number.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will allow the numbers to be increased in a consistent way without worrying
    too much about meaning.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: This structure works very well for things like online cloud services, which,
    in essence, require an increasing counter, as they have a single version deployed
    at the same time. In this case, the most important use of the version is internal
    usage and won't require the maintenance that strict semantic versioning requires.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Frontend and backend
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The usual way of dividing different services is by talking about the "frontend"
    and the "backend." They describe the layers of software, where the layer closer
    to the end user is the frontend, and the one behind is the backend.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, the frontend is the layer that takes care of the presentation
    layer, next to the user, and the backend is the data access layer, which serves
    the business logic. In a client-server architecture, the client is the frontend
    and the server is the backend:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_02_04.png)
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.4: Client-Server architecture'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: As architectures grow more complex, these terms become somewhat polysemic, and
    they are usually understood depending on the context. While *frontend* is almost
    always understood as the user interface directly, *backend* can be applied to
    multiple layers, meaning the next layer that gives support to whatever system
    is being discussed. For example, in a cloud application, the web application may
    use a database such as MySQL as the storage backend, or in-memory storage such
    as Redis as the cache backend.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: The general approach for the frontend and backend is quite different.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: The frontend focuses on the user experience, so the most important elements
    are usability, pleasing design, responsiveness, and so on. A lot of that requires
    an eye for the "final look" and how to make things easy to use. Frontend code
    is executed in the final user, so compatibility between different types of hardware
    can be important. At the same time, it distributes the load, so performance is
    most important from the point of view of the user interface.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: The backend focuses more on stability. Here, the hardware is under strict control,
    but the load is not distributed, making performance important in terms of controlling
    the total resources used. Modifying the backend is also easier, as changing it
    once changes it for all the users at the same time. But it's riskier, as a problem
    here may affect every single user. This environment primes more to focus on solid
    engineering practices and replicability.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: The term full stack engineer is commonly used to describe someone who is comfortable
    doing both kinds of work. While this can work in certain aspects, it's actually
    quite difficult to find someone who is equally comfortable or who is inclined
    to work on both elements in the longer term.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Most engineers will naturally tend toward one of the sides, and most companies
    will have different teams working on both aspects. In a certain way, the personality
    traits for each work are different, with frontend work requiring more of an eye
    for design, and backend users being comfortable with stability and reliability
    practices.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, some common technologies used for the frontend are as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: HTML and associated technologies such as CSS
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript and libraries or frameworks to add interactivity, such as jQuery
    or React
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design tools
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Backend technologies, as they are under more direct control, can be more varied,
    for example:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Multiple programming languages, either scripting languages such as Python, PHP,
    Ruby, or even JavaScript using Node.js, or compiled languages such as Java or
    C#. They can even be mixed, making different elements in different languages.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Databases, either relational databases such as MySQL or PostgreSQL, or non-relational
    ones such as MongoDB, Riak, or Cassandra.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web servers, such as Nginx or Apache.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability and high-availability tools, such as load balancers.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure and cloud technologies, such as AWS services.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container-related tech, like Docker or Kubernetes.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The frontend will make use of interfaces defined by the backend to present the
    actions in a user-friendly way. There can be several frontends for the same backend,
    a typical example being multiple smartphone interfaces for different platforms,
    but that use the same API to communicate with the backend.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that frontend and backend are conceptual divisions, but they don't
    necessarily need to be divided into different processes or repositories. A common
    case where the frontend and backend live together are web frameworks such as Ruby
    on Rails or Django, where you can define the frontend HTML interface at the same
    time as the backend controllers that handle the data access and business logic.
    In this case, the HTML code is served directly from the same process that performs
    access to the data. This process separates the concerns using the Model View Controller
    structure.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Model View Controller structure
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Model View Controller, or MVC, is a design that separates the logic of a
    program into three distinct components.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: The Model View Controller pattern started very early in the design of graphic
    user interfaces and has been used in that area since the first full graphic interactive
    interfaces in the 80s. In the 90s, it started being introduced as a way of handling
    web applications.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'This structure is really successful as it creates a clear separation of concepts:'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Model manages the data
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Controller accepts input from the user and transforms it into the manipulation
    of the model
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The View represents the information for the user to understand
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In essence, the Model is the core of the system, as it deals with the manipulation
    of the data. The Controller represents the input, and the View represents the
    output of the operations.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '![Shape'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_02_05.png)
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.5: The Model View Controller pattern'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: The MVC structure can be considered at different levels, and it can be regarded
    as fractal. If several elements interact, they can have their own MVC structure,
    and the model part of a system can talk to a backend that provides information.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: The MVC pattern can be implemented in different ways. For example, Django claims
    it is a Model View *Template*, as the controller is more the framework itself.
    However, these are minor details that don't contradict the general design.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: The Model is arguably the most important element of the three as it's the core
    part of it. It contains the data access, but also the business logic. A rich Model
    component works as a way of abstracting the logic of the application from the
    input and output.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Commonly, some of the barriers between controllers get a bit blurry. Different
    inputs may be dealt with in the Controller, producing different calls to the Model.
    At the same time, the output can be tweaked in the Controller before being passed
    to the view. While it's always difficult to enforce clear, strict boundaries,
    it's good to keep in mind what the main objective of each component is so as to
    provide clarity.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: HTML interfaces
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the strict definition of APIs works for interfaces that are designed to
    be accessed by other programs, it's good to spend a bit of time talking about
    the basics of how to create a successful human interface. For this purpose, we
    will talk mainly about HTML interfaces, aimed at being used by the end user in
    a browser.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Most of the concepts that we will deal with apply to other kinds of human interfaces,
    such as GUIs or mobile applications.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: HTML technologies are highly related to RESTful ones because they were developed
    in parallel during the early days of the internet. Typically, they are presented
    intertwined in modern web applications.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Traditional HTML interfaces
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way traditional web interfaces work is through HTTP requests, only using
    the `GET` and `POST` methods. `GET` retrieves a page from the server, while `POST`
    is paired with some form that submits data to the server.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: This was a prerequisite, as browsers only implemented these methods. While,
    nowadays, most modern browsers can use all HTTP methods in requests, it's still
    a common requirement to allow compatibility with older browsers.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: While this is certainly more restrictive than all the available options, it
    can work well for simple website interfaces.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: For example, a blog is read way more often than is written, so readers make
    use of a lot of `GET` requests to get the information, and perhaps some `POST`
    requests to send back some comments. The need to remove or change a comment was
    traditionally small, although it can be allocated with other URLs where `POST`
    is used.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Note that browsers will ask you before retrying a `POST` request as they are
    not idempotent.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: An HTML interface doesn't work in the same way as a RESTful interface because
    of these limitations, but it can also improve with a design that takes the abstractions
    and resources approach in mind.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, some common abstractions for a blog are as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Each post, with associated comments
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A main page with the latest posts
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A search page that can return posts that contain a certain word or tag
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is very similar to the interface in resources, where only the two resources
    of "comment" and "post,", which will be separated in a RESTful way, will be joined
    in the same concept.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: The main limitation of traditional HTML interfaces is that every change needs
    to refresh the whole page. For simple applications like a blog, this can work
    quite well, but more complex applications may require a more dynamic approach.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic pages
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add interactivity to the browser, we can add some JavaScript code that will
    perform actions to change the page directly on the browser representation; for
    example, selecting the color of the interface from a drop-down selector.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: This is called manipulating the **Document Object Model** (**DOM**), which contains
    the representation of the document as defined by the HTML and possibly the CSS.
    JavaScript can access this representation and change it by editing any parameters
    or even adding or removing elements.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: From JavaScript, independent HTTP requests can also be done, so we can use that
    to make specific calls to retrieve details that can be added to improve the experience
    of the user.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for a form to input an address, a dropdown may select the country.
    Once selected, a call to the server will retrieve the proper regions to incorporate
    the input. If the user selects **United States**, the list of all states will
    be retrieved and be available in the next dropdown. If the user selects **Canada**,
    the list of territories and provinces will be used instead:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_02_06.png)
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.5: Improving user experience with appropriate dropdowns'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Another example, that reverses the interface somewhat, could be to use the ZIP
    code to determine the state automatically.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: There is actually a service to retrieve this information called [https://zippopotam.us/](https://zippopotam.us/).
    It can be called and returns not only the state but further information, in JSON
    format.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'These kinds of calls are called **Asynchronous JavaScript And XML** (**AJAX**).
    Although the name mentions XML, it''s not required, and any format can be retrieved.
    At the moment, it is very common to use JSON or even plain text. One possibility
    is to use HTML, so an area of the page can be replaced with snippets that come
    from the server:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '![Shape, rectangle'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_02_07.png)
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.6: Using HTML to replace areas of the page'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Raw HTML, although somewhat inelegant, can be effective, so it's very common
    to use a RESTful API returning JSON to retrieve the expected data for these small
    elements and then modify the DOM with it through JavaScript code. Given that the
    objective of this API is not to replace the HTML interface in its entirety, but
    complement it, this RESTful API will likely be incomplete. It won't be possible
    to create a full experience using only these RESTful calls.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Other applications go directly to the point of creating an API-first approach
    and create the browser experience from there.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Single-page apps
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind a single-page app is easy. Let's open a single HTML page and
    change its content dynamically. If there's any new data to be required, it will
    be accessed through a specific (typically RESTful) API.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: This completely detaches the human interface, understood as the elements that
    have the responsibility of displaying the information to a human, from the service.
    The service serves a RESTful API exclusively, without worrying about the representation
    of the data.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: This kind of approach is sometimes called API-first as it designs a system from
    the API to the representation, instead of creating it the other way around, which
    is the natural way in which it is created in an organic service.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'Although there are specific frameworks and tools designed with this objective
    in mind, such as React or AngularJS, there are two main challenges with this kind
    of approach:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: The technical skill required to create a successful human interface on a single
    page is quite high, even with the help of tools. Any non-trivial representation
    of a valid interface will require keeping a lot of state and dealing with multiple
    calls. This is prone to have errors that compromise the stability of the page.
    The traditional approach for browser pages works with independent pages that limit
    the scope of each step, which is easier to handle.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that there are interface expectations carried by the browser that
    can be difficult to avoid or replace, for example, hitting the back button.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: The need to design and prepare the API beforehand can result in a slow start for
    the project. It requires more planification and upfront commitment, even if both
    sides are developed in parallel, which also has its challenges.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These issues ensure that this approach is not usually done for new applications
    starting from scratch. However, if the application started with another kind of
    user interface, like a smartphone application, it could leverage the already existing
    REST API to generate an HTML interface that replicates the functionality.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of this approach is detaching the application from the user
    interface. Where an application starts its development as a small project with
    a regular HTML interface, the risk is that any other user interface will tend
    to conform to the HTML interface. This can quickly add up to a lot of technical
    debt and compromise the design of the API, as the abstractions that are used will
    likely be derived from the existing interface, instead of the most adequate ones.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: A whole API-first approach greatly separates the interface, so creating a new
    interface is as easy to use as the already existing API. For applications that
    require multiple interfaces, such as an HTML interface, but also different smartphones
    applications for iOS and Android, that could be a good solution.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: A single-page application can also be quite innovative in terms of presenting
    a full interface. This can create rich and complex interfaces that deviate from
    what could be understood as a "web page," as in the case of a game or an interactive
    application.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid approach
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Going all-in with a single-page application, as we've seen, can be quite challenging.
    To a certain degree, it is using a browser to overwrite its usage.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: That's why normally the design doesn't go that far and creates a more traditional
    web interface. This interface is still recognizable as a web application but relies
    heavily on JavaScript to obtain information using a RESTful interface. This can
    happen as a natural step to migrating from a traditional HTML interface to a single-page
    app, but it may also be a conscious decision.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: This approach combines the previous two. On the one hand, it still requires
    an HTML interface for the general approach of the interface, with clear pages
    to navigate. On the other, it creates a RESTful API that fills most of the information
    and uses JavaScript to make use of this API.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: This approach is similar to the dynamic page one, but there is an important
    difference, which is the intention to create a coherent API that can be used without
    being totally tailored to the HTML interface. That changes the approach significantly.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this tends to create a less complete RESTful API, as some of the
    elements may be added directly to the HTML part of it. But, at the same time,
    it allows the iterative migration of elements into the API, starting with certain
    elements, but adding more as time goes by. This stage is very flexible.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Designing the API for the example
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we described in the first chapter, *General Overview of the Example*, we
    need to set the definition for the different interfaces that we will be working
    on in the example. Remember that the example is a microblogging application that
    will allow users to write their own text microposts so that they are available
    for others to read.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main interfaces in the example:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: An HTML interface for allowing users to interact with the service using a browser
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A RESTful interface for allowing the creation of other clients like a smartphone
    app
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will describe the design of the second interface. We will
    start with a description of the different basic definitions and resources that
    we will use:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '**User**: A representation of the user of the application. It will be defined
    by a username and a password to be able to login.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Micropost**: A small text of up to 255 characters posted by a *User*. A *Micropost*
    can be optionally addressed to a *User*. It has also the time it was created.'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection**: The display of *Microposts* from a *User*.'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Follower**: A *User* can follow another *User*.'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timeline**: An ordered list of the *Microposts* by the followed *Users*.'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search**: Allow a search by *User* or by text contained in *Microposts*.'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can define these elements as resources in a RESTful way, in the way introduced
    earlier in the chapter, first as a quick description of the URIs:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that we added `POST` and `DELETE` resources for `/token` to deal with login
    and logout.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Once this brief design is complete, we can flesh out the definition of each
    endpoint.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Endpoints
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will describe all the API endpoints in a bit more detail, following the template
    introduced previously in this chapter.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '**Login:**'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Using the proper authentication credentials, return a valid
    access token. The token needs to be included in the requests as the `Authorization`
    header.'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/api/token`'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `POST`'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Request body*:'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Return body*:'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Errors*:'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Logout:**'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Invalidate the bearer token. If successful, it will return a
    `204 No Content` error.'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/api/token`'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `DELETE`'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Errors*:'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Retrieve user:**'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Returns the username resource.'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/api/users/<username>`'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `GET`'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Query Parameters*:'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Return body*:'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Errors*:'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Retrieve user''s collection:**'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Returns the collection of all microposts from a user, in paginated
    form.'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/api/users/<username>/collection`'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `GET`'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Return body*:'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Errors*:'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Create new micropost:**'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Create a new micropost.'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource* *URI*: `/api/users/<username>/collection`'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `POST`'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Request body*:'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Errors*:'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Retrieve micropost:**'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Returns a single micropost.'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource* *URI*: `/api/users/<username>/collection/<micropost_id>`'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `GET`'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Return body*:'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Errors*:'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Update micropost:**'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Update the text for a micropost.'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource* *URI*: `/api/users/<username>/collection/<micropost_id>`'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `PUT, PATCH`'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Request body*:'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Errors*:'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Delete micropost:**'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Delete a micropost. If successful, it will return a `204 No
    Content` error.'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource* *URI*: `/api/users/<username>/collection/<micropost_id>`'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `DELETE`'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Errors*:'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Retrieve user''s timeline:**'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Returns the collection of all microposts from the timeline of
    a user, in paginated form. The microposts will be returned by timestamp order,
    with the oldest being returned first.'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource* *URI*: `/api/users/<username>/timeline`'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `GET`'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Return* *body*:'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Errors*:'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Retrieve the users a user is following:**'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Returns a collection of all users that the selected user is
    following.'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource* *URI*: `/api/users/<username>/following`'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `GET`'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Return* *body*:'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Errors*:'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Follow a user:**'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Causes the selected user to follow a different user.'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/api/users/<username>/following`'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `POST`'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Request body*:'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Errors*:'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Stop following a user:**'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Stops following a user. If successful, it will return a `204
    No Content` error.'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/api/users/<username>/following/<username>`'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `DELETE`'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Errors*:'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**Retrieve a user''s followers:**'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Returns, in paginated form, all followers of this user.'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/api/users/<username>/followers`'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `GET`'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*:`Authentication: Bearer: <token>`'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Return body*:'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Errors*:'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**Search microposts:**'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Returns, in paginated form, microposts that fulfill the search
    query.'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/api/search`'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `GET`'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Query parameters*:'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*Return body*:'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*Errors*:'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Review of the design and implementation
  id: totrans-615
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This two-step approach of presenting and designing a new API enables you to
    quickly see whether something is out of place as regards the design. Then, it
    can be iterated over until fixed. The next step is to start with the implementation,
    as we will see in forthcoming chapters.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-617
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described how the basics of API design are to create a set
    of useful abstractions that allow users to perform actions without having to care
    about the internal details. This led to describing how to define an API with resources
    and actions.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: This definition of an API has evolved to cover RESTful interfaces that follow
    certain properties that make them very interesting for web server design. We described
    a bunch of useful standards and techniques when designing RESTful interfaces to
    create consistent and complete interfaces, including the OpenAPI tools. We went
    through authentication details as it's a very important element for APIs.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: Remember that extra care should be advised when securing APIs that have external
    usage. We went through some general ideas and common strategies, but note that
    this book does not focus on security. This is a critical aspect of the design
    of any API and should be done carefully.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: We covered the ideas behind versioning and how to create a proper versioning
    schema that's tailored to the specific use case for the API. We also covered the
    differences between the frontend and the backend and how this can be generalized.
    We also covered the MVC pattern, which is a very common way to structure software.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: We described the different options for HTML interfaces to provide a complete
    overview of the different interfaces in web services. We covered different options
    in terms of how an HTML service can be constructed and interact with other APIs.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we presented the design for the RESTful interface for the example,
    while reviewing the general design and endpoints.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: Another critical element of design is the data structure. We will cover this
    next.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
