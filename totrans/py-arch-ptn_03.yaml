- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will talk about the basic **application programming interface**
    (**API**)design principles. We will see how to start our design by defining useful
    abstractions that will create the foundation for the design.
  prefs: []
  type: TYPE_NORMAL
- en: We will then present the principles for RESTful interfaces, covering both the
    strict, academic definition and a more practical definition to help when making
    designs. We will look at design approaches and techniques to help create a useful
    API based on standard practices. We will also spend some time talking about authentication,
    as this is a critical element for most APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We will focus in this book on RESTful interfaces, as they are the most common
    right now. Before that, there were other alternatives, including **Remote Procedure
    Call** (**RPC**) in the 80s, a way to make a remote function call, or **Single
    Object Access Protocol** (**SOAP**) in the early 2000s, which standardized the
    format of the remote call. Current RESTful interfaces are easier to read and take
    advantage of the already established usage of HTTP more strongly, although, in
    essence, they could potentially be integrated via these older specifications.
  prefs: []
  type: TYPE_NORMAL
- en: They are still available nowadays, although predominantly in older systems.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover how to create a versioning system for the API, attending to the
    different use cases that can be affected.
  prefs: []
  type: TYPE_NORMAL
- en: We will see the difference between the frontend and the backend, and its interaction.
    Although the main objective of the chapter is to talk about API interfaces, we
    will also talk about HTML interfaces to see the differences and how they interact
    with other APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will describe the design for the example that we will use later
    in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTful interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend and backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the API for the example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at abstractions first.
  prefs: []
  type: TYPE_NORMAL
- en: Abstractions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An API allows us to use a piece of software without totally understanding all
    the different steps that are involved. It presents a clear menu of actions that
    can be performed, enabling an external user, who doesn't necessarily understand
    the complexities of the operation, to perform them efficiently. It presents a
    simplification of the process.
  prefs: []
  type: TYPE_NORMAL
- en: These actions can be purely functional, where the output is only related to
    the input; for example, a mathematical function that calculates the barycenter
    of a planet and a star, given their orbits and masses.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, they can deal with state, as the same action repeated twice may
    have different effects; for example, retrieving the time in the system. Perhaps
    even a call allows the time zone of the computer to be set, and two subsequent
    calls to retrieve the time may return very different results.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the APIs are defining **abstractions**. Retrieving the time of
    the system in a single operation is simple enough, but perhaps the details of
    doing so are not so easy. It may involve reading in a certain way some piece of
    hardware that keeps track of time.
  prefs: []
  type: TYPE_NORMAL
- en: Different hardware may report the time differently, but the result should always
    be translated in a standard format. Time zones and time savings need to be applied.
    All this complexity is handled by the developers of the module that exposes the
    API and provides a clear and understandable contract with any user. "Call this
    function, and the time in ISO format will be returned."
  prefs: []
  type: TYPE_NORMAL
- en: While we are mainly talking about APIs, and throughout the book we will describe
    mostly ones related to online services, the concept of abstractions really can
    be applied to anything. A web page to manage a user is an abstraction, as it defines
    the concept of "user account" and the associated parameters. Another omnipresent
    example is the "Shopping cart" for e-commerce. It's good to create a clear mental
    image, as it helps to create a clearer and more consistent interface for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is, of course, a simple example, but APIs can hide a tremendous amount
    of complexity under their interfaces. A good example to think about is a program
    like `curl`. Even when *just* sending an HTTP request to a URL and printing the
    returned headers, there is a huge amount of complexity associated with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This makes a call to `www.google.com` and displays the headers of the response
    using the `-I` flag. The `-L` flag is added to automatically redirect any request
    which is what is happening here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making a remote connection to a server requires a lot of different moving parts:'
  prefs: []
  type: TYPE_NORMAL
- en: DNS access to translate the server address `www.google.com` to an actual IP
    address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The communication between both servers, which involves using the TCP protocol
    to generate a persistent connection and guarantee the reception of the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirection based on the result from the first request, as the server returns
    a code pointing to another URL. This was done owing to the usage of the `-L` flag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The redirection points to an HTTPS URL, which requires adding a verification
    and encryption layer on top of that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these steps also makes use of other APIs to perform smaller actions,
    which could involve the functionality of the operating system or even calling
    remote servers such as the DNS one to obtain data from there.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `curl` interface is used from the command line. While the strict definition
    of an API discard stipulates that the end user is a human, there's not really
    a big change. Good APIs should be easily testable by human users. Command-line
    interfaces can also be easily automated by bash scripts or other languages.
  prefs: []
  type: TYPE_NORMAL
- en: But, from the point of view of the user of `curl`, this is not very relevant.
    It is simplified to the point where a single command line with a few flags can
    perform a well-defined operation without worrying about the format to get data
    from the DNS or how to encrypt a request using SSL.
  prefs: []
  type: TYPE_NORMAL
- en: Using the right abstractions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a successful interface, the root is to create a series of abstractions and
    present them to the user so that they can perform actions. The most important
    question when designing a new API is, therefore, to decide which are the best
    abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: When the process happens organically, the abstractions are decided mostly on
    the go. There is an initial idea, acknowledged as an understanding of the problem,
    that then gets tweaked.
  prefs: []
  type: TYPE_NORMAL
- en: For example, it's very common to start a user management system by adding different
    flags to the users. So, a user has permission to perform action A, and then a
    parameter to perform action B, and so on. By adding one flag at a time, come the
    tenth flag, the process becomes very confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Then, a new abstraction can be used; roles and permissions. Certain kinds of
    users can perform different actions, such as admin roles. A user can have a role,
    and the role is the one that describes the related permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this simplifies the problem, as it's easy to understand and manage.
    However, moving from "an individual collection of flags" to "several roles" can
    be a complicated process. There is a reduction in the number of possible options.
    Perhaps some existing users have a peculiar combination of flags. All this needs
    to be handled carefully.
  prefs: []
  type: TYPE_NORMAL
- en: While designing a new API, it is good to try to explicitly describe the inherent
    abstractions that the API uses to clarify them, at least at a high level. This
    also has the advantage of being able to think about that as a user of the API
    and see if things add up.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most useful viewpoints in the work of software developers is to detach
    yourself from your "internal view" and take the position of the actual user of
    the software. This is more difficult than it sounds, but it's certainly a skill
    worth developing. This will make you a better designer. Don't be afraid to ask
    a friend or coworker to detect blind spots in your design.
  prefs: []
  type: TYPE_NORMAL
- en: However, every abstraction has its limits.
  prefs: []
  type: TYPE_NORMAL
- en: Leaking abstractions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an abstraction is leaking details from the implementation, and not presenting
    a perfectly opaque image, it's called a leaky abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: While a good API should try to avoid this, sometimes it happens. This can be
    caused by underlying bugs in the code serving the API, or sometimes directly from
    the way the code operates in certain operations.
  prefs: []
  type: TYPE_NORMAL
- en: A common case for this is relational databases. SQL abstracts the process of
    searching data from how it is actually stored in the database. You can search
    with complex queries and get the result, and you don't need to know how the data
    is structured. But sometimes, you'll find out that a particular query is slow,
    and reorganizing the parameters of the query has a big impact on how this happens.
    This is a leaky abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: This is very common, and the reason why there are significant tools to help
    ascertain what is going on when running a SQL query, which is very detached from
    the implementation. The main one is the `EXPLAIN` command.
  prefs: []
  type: TYPE_NORMAL
- en: Operating systems are good examples of a system that generates good abstractions
    that don't leak the majority of the time. There are lots of examples. Not being
    able to read or write a file due to a lack of space (a less common problem now
    than three decades ago); breaking a connection with a remote server due to a network
    problem; or not being able to create a new connection due to reaching a limit
    in terms of the number of open file descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: Leaky abstractions are, to a certain degree, unavoidable. They are the result
    of not living in a perfect world. Software is fallible. Understanding and preparing
    for that is critical.
  prefs: []
  type: TYPE_NORMAL
- en: '"All non-trivial abstractions, to some degree, are leaky."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Joel Spolsky's Law of Leaky Abstractions
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When designing an API, it is important to take this fact into account for several
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**To present clear errors and hints externally**. A good design will always
    include cases for things going wrong and try to present them clearly with proper
    error codes or error handling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To deal with errors that could come from dependent services internally**.
    Dependent services can fail or have other kinds of problems. The API should abstract
    this to a certain degree, recovering from the problem if possible, failing gracefully
    if not, and returning a proper result if recovery is impossible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best design is the one that not only designs things when they work as expected,
    but also prepares for unexpected problems and is sure that they can be analyzed
    and corrected.
  prefs: []
  type: TYPE_NORMAL
- en: Resources and action abstractions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A very useful pattern to consider when designing an API is to produce a set
    of resources that can perform actions. This pattern uses two kinds of elements:
    **resources** and **actions**.'
  prefs: []
  type: TYPE_NORMAL
- en: Resources are passive elements that are referenced, while actions are performed
    on resources.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's define a very simple interface to play a simple game guessing
    coin tosses. This is a game consisting of three guesses for three coin tosses,
    and the user wins if at least two of these guesses are correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resource and actions may be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Resource | Actions | Details |'
  prefs: []
  type: TYPE_TB
- en: '| HEADS | None | A coin toss result. |'
  prefs: []
  type: TYPE_TB
- en: '| TAILS | None | A coin toss result. |'
  prefs: []
  type: TYPE_TB
- en: '| GAME | START | Start a new GAME. |'
  prefs: []
  type: TYPE_TB
- en: '|  | READ | Returns the current round (1 to 3) and the current correct guesses.
    |'
  prefs: []
  type: TYPE_TB
- en: '| COIN_TOSS | TOSS | Toss the coin. If the GUESS hasn''t been produced, it
    returns an error. |'
  prefs: []
  type: TYPE_TB
- en: '|  | GUESS | Accepts HEADS or TAILS as the guess. |'
  prefs: []
  type: TYPE_TB
- en: '|  | RESULT | It returns HEADS or TAILS and whether the GUESS was correct.
    |'
  prefs: []
  type: TYPE_TB
- en: 'A possible sequence for a single game could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note how each resource has its own set of actions that can be performed. Actions
    can be repeated if that's convenient, but it's not required. Resources can be
    combined into a hierarchical representation (like here, where `COIN_TOSS` depends
    on a higher `GAME` resource). Actions can require parameters that can be other
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: However, the abstractions are organized around having a consistent set of resources
    and actions. This way of explicitly organizing an API is useful as it clarifies
    what is passive and what's active in the system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-oriented programming** (**OOP**) uses these abstractions, as everything
    is an object that can receive messages to perform some actions. Functional programming,
    on the other hand, doesn''t fit neatly into this structure, as "actions" can work
    like resources.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a common pattern, and it's used in RESTful interfaces, as we will see
    next.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RESTful interfaces are incredibly common these days, and for good reason. They've
    become the de facto standard in web services that serve other applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) was defined in 2000 in a Ph.D.
    dissertation by Roy Fielding, and it uses HTTP standards as a basis to create
    a definition of a software architecture style.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a system to be considered RESTful, it should follow certain rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-server architecture**. It works through remote calling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless**. All the information related to a particular request should be
    contained in the request itself, making it independent from the specific server serving
    the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cacheability**. The cacheability of the responses should be clear, either
    to say they are cacheable or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layered system**.The client cannot tell if they are connected to a final
    server or if there''s an intermediate server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform interface**, with four prerequisites:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource identification in requests**, meaning a resource is unequivocally
    represented, and its representation is independent'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource manipulation through representations**, allowing clients to have
    all the required information to make changes when they have the representation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-descriptive messages**, meaningmessages are complete in themselves'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hypermedia as the Engine of Application State**, meaning the client can walk
    through the system using referenced hyperlinks'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code on demand**. This is an optional requirement, and it''s normally not
    used. Servers can submit code in response to help perform operations or improve
    the client; for example, submitting JavaScript to be executed in the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the most formal definition. As you can see, it's not necessarily based
    on HTTP requests. For more convenient usage, we need to limit the possibilities
    somewhat and set a common framework.
  prefs: []
  type: TYPE_NORMAL
- en: A more practical definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When people talk colloquially about RESTful interfaces, normally they are understood
    as interfaces based on HTTP resources using JSON formatted requests. This is wholly
    compatible with the definition that we've seen before, but taking some key elements
    into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: These key elements are sometimes ignored, leading to pseudo-RESTful interfaces,
    which don't have the same properties.
  prefs: []
  type: TYPE_NORMAL
- en: The main one is that **URIs (Uniform Resource Identifiers)** should describe
    clear resources, as well as HTTP methods and actions to perform on them, using
    the **CRUD (Create Retrieve Update Delete)** approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'CRUD interfaces facilitate the performance of those actions: Create (save a
    new entry), Retrieve (read), Update (overwrite), and Delete entries. These are
    the basic operations for any persistent storage system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of URIs, whether they describe a single resource or a collection
    of resources, as can be seen in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Resource | Example | Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| Collection | `/books` | `GET` | List operation. Returns all the available
    elements of the collection, for example, all books. |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `POST` | Create operation. Creates a new element of the collection.
    Returns the newly created resource. |'
  prefs: []
  type: TYPE_TB
- en: '| Single | `/books/1` | `GET` | Retrieve operation. Returns the data from the
    resource, for example, the book with an ID of 1. |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `PUT` | Set (Update) operation. Sends the new data for the resource.
    If it doesn''t exist, it will be created. If it does, it will be overwritten.
    |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `PATCH` | Partial update operation. Overwrites only the partial values
    for the resource, for example, sends and writes only the email for the user object.
    |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `DELETE` | Delete operation. It deletes the resource. |'
  prefs: []
  type: TYPE_TB
- en: 'The key element of this design is the definition of everything as a resource,
    as we saw before. Resources are defined by their URIs, which contain a hierarchical
    view of the resources, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/books/1/cover` defines the resource of the cover image from the book with
    an ID of 1.'
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, we will use integer IDs to identify the resources in this chapter.
    In real-world operations, this is not recommended. They have no meaning at all,
    and, even worse, they can sometimes leak information about the number of elements
    in the system or their internal order. For example, a competitor could estimate
    how many new entries are being added each week. To detach from whatever internal
    representation, try to always use a natural key externally, if available, such
    as the ISBN number for books, or create a random **Universally Unique Identifier**
    (**UUID**).
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with sequential integers is that, at high rates, the system
    may struggle to create them correctly, as it won't be possible to create two at
    the same time. This can limit the growth of a system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the input and output of the resources will be represented in JSON format.
    For example, this could be an example of a request and response to retrieve a
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The response is formatted in JSON, as specified in `Content-Type`. This makes
    it easy to parse and analyze automatically. Note that the `avatar` field returns
    a hyperlink to another resource. This makes the interface walkable and reduces
    the amount of information that the client requires beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the most forgotten properties when designing RESTful interfaces.
    It is preferable to return full URIs to resources instead of indirect references,
    such as no-context IDs.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when creating a new resource, include the new URI in the response,
    in the `Location` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'To send new values to overwrite, the same format should be used. Note that
    some elements may be read-only, such as `cover`, and aren''t required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The **same representation should be used for input and output**, making it easy
    for the client to retrieve a resource, modify it, and then resubmit it.
  prefs: []
  type: TYPE_NORMAL
- en: This is really handy and creates a level of consistency that's very much appreciated
    when implementing a client. While testing, try to ensure that retrieving a value
    and resubmitting it is valid and doesn't create a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the resource will be directly represented by binary content, it can return
    the proper format, specified in the `Content-Type` header. For example, retrieving
    the avatar resource may return an image file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the same way, when creating or updating a new avatar, it should be sent in
    the proper format.
  prefs: []
  type: TYPE_NORMAL
- en: While the original intention of RESTful interfaces was to make use of multiple
    formats, for example, accepting XML and JSON, this is not very common in practice.
    JSON is, by and large, the most standard format these days. Some systems may benefit
    from using multiple formats, though.
  prefs: []
  type: TYPE_NORMAL
- en: Another important property is ensuring that some actions are **idempotent**,
    and others are not. Idempotent actions can be repeated multiple times, producing
    the same result, while repeating not-idempotent actions will generate different
    results. Evidently, the action should be identical.
  prefs: []
  type: TYPE_NORMAL
- en: A clear case of this is the creation of a new element. If we submit two identical
    `POST` creations of a new element of a resource list, it will create two new elements.
    For example, submitting two books with the same name and author will create two
    identical books.
  prefs: []
  type: TYPE_NORMAL
- en: This is assuming that there's no limitation to the content of the resource.
    If they are, the second request will fail, which will produce a different result
    to the first in any case.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, two `GET` requests will produce the same result. The same
    is true for `PUT` or `DELETE`, as they'll overwrite or "delete again" the resource.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the only non-idempotent requests are `POST` actions simplifies
    significantly the design of measures to deal with problems when there's the question
    of whether it should be retried. Idempotent requests are safe to retry at any
    time, thereby simplifying the handling of errors such as network problems.
  prefs: []
  type: TYPE_NORMAL
- en: Headers and statuses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important detail of the HTTP protocol that can sometimes be overlooked is
    the different headers and status codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Headers include metadata information about the request or response. Some of
    it is added automatically, like the size of the body of the request or response.
    Some interesting headers to consider are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Header | Type | Details |'
  prefs: []
  type: TYPE_TB
- en: '| `Authorization` | Standard | Credentials to authenticate the request. |'
  prefs: []
  type: TYPE_TB
- en: '| `Content-Type` | Standard | The type of the body of the request, like `application/json`
    or `text/html`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Date` | Standard | When the message was created. |'
  prefs: []
  type: TYPE_TB
- en: '| `If-Modified-Since` | Standard | The sender has a copy of the resource at
    this time. If it hasn''t changed since then, a `304 Not Modified` response (with
    an empty body) can be returned. This allows the caching of data and saves time
    and bandwidth by not returning duplicated info. This can be used in `GET` requests.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `X-Forwarded-From` | De facto standard | Stores the IP where the message
    was originated, and the different proxies it went through. |'
  prefs: []
  type: TYPE_TB
- en: '| `Forwarded` | Standard | Same as `X-Forwarded-From`. This is a newer header
    and less common still than `X-Forwarded-From`. |'
  prefs: []
  type: TYPE_TB
- en: A well-designed API will make use of headers to communicate proper information,
    for example, setting `Content-Type` correctly or accepting cache parameters if
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: A comprehensive list of headers can be found at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers).
  prefs: []
  type: TYPE_NORMAL
- en: Another important detail is to make good use of available status codes. Status
    codes provide significant information about what happened, and using the most
    detailed information possible for each situation will provide a better interface.
  prefs: []
  type: TYPE_NORMAL
- en: '**Some common status codes are as follows:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Status code | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `200 OK` | A successful resource access or modification. It should return
    a body; if it doesn''t, use `204 No Content`. |'
  prefs: []
  type: TYPE_TB
- en: '| `201 Created` | A successful `POST` request that creates a new resource.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `204 No Content` | A successful request that doesn''t return a body, for
    example, a successful `DELETE` request. |'
  prefs: []
  type: TYPE_TB
- en: '| `301 Moved Permanently` | The accessed resource is now permanently located
    in a different URI. It should return a `Location` header with the new URI. Most
    libraries will follow up automatically for `GET` accesses. For example, the API
    is only accessible in `HTTPS`, but it was accessed in `HTTP`. |'
  prefs: []
  type: TYPE_TB
- en: '| `302 Found` | The accessed resource is temporarily located in a different
    URI. A typical example is being redirected to a login page if authenticated. |'
  prefs: []
  type: TYPE_TB
- en: '| `304 Not Modified` | A cached resource is still valid. The body should be
    empty. This status code is only returned if the client requested cached information,
    for example, using the `If-Modified-Since` header. |'
  prefs: []
  type: TYPE_TB
- en: '| `400 Bad Request` | A generic error in the request. This is the server saying,
    "something went wrong on your end." A more descriptive message should be added
    to the body. If a more descriptive status code is possible, it should be preferred.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `401 Unauthorized` | The request is not allowed, as the request is not properly
    authenticated. The request may lack valid headers for authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| `403 Forbidden` | The request is authenticated, but it can''t access this
    resource. This is different from the `401 Unauthorized` status in that the request
    is already correctly authenticated but doesn''t have access. |'
  prefs: []
  type: TYPE_TB
- en: '| `404 Not Found` | Probably the most famous status code! The resource described
    by the URI cannot be found. |'
  prefs: []
  type: TYPE_TB
- en: '| `405 Method Not Allowed` | The requested method cannot be used; for example,
    the resource cannot be deleted. |'
  prefs: []
  type: TYPE_TB
- en: '| `429 Too Many Requests` | The server should return this status code if there''s
    a limit to the number of requests the client can do. It should return a description
    or more info in the body, and ideally, a `Retry-After` header indicating the time
    in seconds to the next retry. |'
  prefs: []
  type: TYPE_TB
- en: '| `500 Server Error` | A generic error in the server. This status should only
    be used if an unexpected error happened in the server. |'
  prefs: []
  type: TYPE_TB
- en: '| `502 Bad Gateway` | The server is redirecting the request to a different
    server, and the communication was incorrect. This error normally appears when
    some backend service is unavailable or incorrectly configured. |'
  prefs: []
  type: TYPE_TB
- en: '| `503 Service Unavailable` | The server is currently unable to handle requests.
    Normally, this is a temporary situation, such as a load problem. It could be used
    to mark maintenance downtime, but this is generally rare. |'
  prefs: []
  type: TYPE_TB
- en: '| `504 Gateway Timeout` | Similar to `502 Bad Gateway`, but in this case, the
    backend service didn''t respond, provoking a timeout. |'
  prefs: []
  type: TYPE_TB
- en: In general, non-descriptive error codes such as `400 Bad Request` and `500 Server
    Error` should be left for general situations. However, if there is a better, more
    descriptive status code, this should be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a `PATCH` request to overwrite a parameter should return `400 Bad
    Request` if the parameter is incorrect for any reason, but `404 Not Found` if
    the resource URI is not found.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other status codes. You can check a comprehensive list, including
    details on each one, here: [https://httpstatuses.com/](https://httpstatuses.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: In any error, please include some extra feedback to the user with a reason.
    A general descriptor can help the handling of unexpected cases and simplify debugging
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: This is especially useful for `4XX` errors as they will help users of the API
    to fix their own bugs and iteratively improve their integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the mentioned `PATCH` may return this body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will give specific details about the problem. Other options include returning
    error codes, multiple messages in case there are multiple possible errors, and
    also duplicating the status code in the body.
  prefs: []
  type: TYPE_NORMAL
- en: Designing resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The available actions in a RESTful API are limited to CRUD operations. Therefore,
    resources are the basic construction blocks for the API.
  prefs: []
  type: TYPE_NORMAL
- en: Making everything a resource helps to create very explicit APIs and helps with
    the stateless requirement for RESTful interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: A stateless service means that all the information required to fulfill a request
    is either provided by the caller or retrieved externally, normally from a database.
    This excludes other ways of keeping information, such as storing information locally
    in the same server's hard drive. This makes any server capable of handling every
    single request, and it's critical in achieving scalability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Elements that could be activated by creating different actions could be separated
    into different resources. For example, an interface simulating a pen could require
    the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Opening and closing the pen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing something. Only an open pen can write.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In some APIs, like an object-oriented one, this could involve creating a pen
    object and changing its state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In a RESTful API, we need to create different resources for both the pen and
    its status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This may look a bit cumbersome, but RESTful APIs should aim to be higher level
    than the typical object-oriented one. Either create the text directly, or create
    a pen and then the text, without having to perform the open/close operation.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that RESTful APIs are used in the context of remote calls. This
    means that they can't be low level, as each call is a big investment compared
    with a local API, as the time per call will be a sensible part of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Note also that every single aspect and step gets registered and has its own
    set of identifiers and is addressable. This is more explicit than the internal
    state that can be found in OOP. As we've seen, we want it to be stateless, while
    objects are very much stateful.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that a resource doesn't need to be translated directly into a database
    object. That's thinking backward, from the storage to the API. Remember that you
    are not limited to that, and can compose resources that obtain information from
    multiple sources or that don't fit into a direct translation. We will see examples
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing only with resources can require certain adaptations if coming from a
    more traditional OOP environment, but they are a pretty flexible tool and can
    allocate multiple ways of performing actions.
  prefs: []
  type: TYPE_NORMAL
- en: Resources and parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While everything is a resource, some elements make more sense as a parameter
    that interacts with the resource. This is very natural when modifying the resource.
    Any change needs to be submitted to update the resource. But, in other cases,
    some resources could be modified for other causes. The most common case is searches.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical search endpoint will define a `search` resource and retrieve its
    results. However, a search without parameters to filter is not really useful,
    so extra parameters will be required to define the search, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These parameters are stored in query parameters, which are natural extensions
    to retrieve them.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, only `GET` requests should have query parameters. Other kinds
    of request methods should provide any parameters as part of the body.
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` requests are also easy to cache if including the query parameters. If
    the search is returning the same values for each request, given that that''s an
    idempotent request, the full URI, including the query parameters, can be cached
    even externally from the service.'
  prefs: []
  type: TYPE_NORMAL
- en: By convention, all logs that store `GET` requests will also store the query
    params, while any parameter sent as a header or in the body of the request won't
    be logged. This has security implications, as any sensible parameter, such as
    a password, shouldn't be sent as a query parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, that's the reason to create `POST` operations that typically would
    be a `GET` request, but prefer to set parameters in the body of the request instead
    of query parameters. While it is possible in the HTTP protocol to set the body
    in a `GET` request, it's definitely very unusual.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this could be searching by phone number, email, or other personal
    information, so a middle-man agent could intercept and learn about them.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to use `POST` requests is to allow a bigger space for parameters,
    as the full URL, including query parameters, is normally limited to 2K in size,
    while bodies are much less restricted in size.
  prefs: []
  type: TYPE_NORMAL
- en: Pagination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a RESTful interface, any `LIST` request that returns a sensible number of
    elements should be paginated.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the number of elements and pages can be tweaked from the request,
    returning only a specific page of elements. This limits the scope of the request
    and avoids very slow response times and waste transmission bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example could involve using the parameters `page` and `size`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A well-constructed response will have a similar format to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It contains a `result` field with the resulting list and `next` and `previous`
    fields that are hyperlinks to the next and previous page, with a value of `null`
    if it is not available. This makes it easy to walk through all the results.
  prefs: []
  type: TYPE_NORMAL
- en: A `sort` parameter could also be useful to ensure consistency in pages.
  prefs: []
  type: TYPE_NORMAL
- en: This technique also allows multiple pages to be retrieved in parallel, which
    can speed up the downloading of information, doing several small requests instead
    of one big one. The objective, though, is to provide sufficient filter parameters
    for generally returning not too much information, being able to retrieve only
    the relevant information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pagination has a problem, which is that the data in the collection may change
    between multiple requests, especially if retrieving many pages. The problem is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The second page now has a repeated element that used to be on the first page
    but has now moved to the second, and then there's one element that's not returned.
    Normally, the non-return of the new resource is not that much of a problem, as,
    after all, the retrieval of information started before its creation. However,
    the return of the same resource twice can be.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this kind of problem, there's the possibility of sorting by default
    the values by creation date or something analogous. This way, any new resource
    will be added at the end of pagination and will be consistently retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: For resources that return inherently "new" elements, like notifications or similar,
    add an `updated_since` parameter to retrieve only the new resources since the
    most recent access. This speeds up access in a practical way and retrieves only
    the relevant information.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a flexible pagination system increases the usefulness of any API. Be
    sure that your pagination definition is consistent across any different resources.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a RESTful API process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best way to start designing a RESTful API is to clearly state the resources
    and then describe them, including the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Description of the action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: Note that this may be shared for several actions, differentiated
    by the method (for example, GET to retrieve and DELETE to delete)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Methods applicable*: The HTTP method to use for the action defined in this
    endpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*(Only if relevant) Input body*: The input body of the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Expected result in the body*: Result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Possible expected errors*: Returning status codes depending on specific errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Description*: Description of the action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*(Only if relevant) Input query parameters*: Query parameters to add to the
    URI for extra functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(*Only if relevant) Relevant headers*: Any supported header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*(Only if relevant) Returning status codes out of the ordinary (200 and 201)*:
    Different from errors, in case there''s a status code that''s considered a success
    but it''s not the usual case; for example, a success returns a redirection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will be enough to create a design document that can be understood by other
    engineers and allow them to work on the interface.
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice, though, to start with a quick draft of the different URIs
    and methods, and to have a quick look at all the different resources that the
    system has without getting into too much detail, such as a body description or
    errors. This helps to detect missing resource gaps or other kinds of inconsistencies
    in the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the API described in this chapter has the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of details that can be tweaked and improved here:'
  prefs: []
  type: TYPE_NORMAL
- en: It looks like we forgot to add the action to remove a pen, once created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a couple of `GET` actions for retrieving information about the created
    resource that should be added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `PUT` action, it feels a bit redundant to have to add `/text`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this feedback, we can again describe the API as follows (modifications
    have an arrow):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note how the organization in the hierarchical structure helps to take a good
    look at all the elements and find either gaps or relations that may not be obvious
    at first glance.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we can get into details. We can use the template described at the
    start of the section, or any other one that works for you. For example, we can
    define the endpoints to create a new pen and read a pen in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a new pen:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Creates a new pen, specifying the color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/pens`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `POST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Input body*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Errors*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Error in the body, such as an unrecognized color, a duplicated name, or a bad
    format.
  prefs: []
  type: TYPE_NORMAL
- en: '**Retrieving an existing pen:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Retrieves an existing pen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/pens/<pen id>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Return body*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Errors*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The main objective is that these small templates are useful and to the point.
    Feel free to tweak them as expected, and don't worry about being too completist
    with the errors or details. The most important part is that they are **useful**;
    for example, adding a `405 Method Not Allowed` message could be redundant.
  prefs: []
  type: TYPE_NORMAL
- en: The API can also be designed using tools such as Postman ([www.postman.com](https://www.postman.com)),
    which is an API platform that can be used to either design or test/debug existing
    APIs. While useful, it is good to be able to design an API without external tools,
    in case that's required, and because it forces you to think about the design and
    not necessarily the tool itself. We will also see how to use Open API, which is
    based more on the definition, and not so much on providing a test environment.
  prefs: []
  type: TYPE_NORMAL
- en: Designing and defining an API can also enable it to be structured in a standard
    manner afterward to take advantage of tools.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Open API specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A more structured alternative is to use a tool such as Open API ([https://www.openapis.org/](https://www.openapis.org/)).
    Open API is a specification for defining a RESTful API through a YAML or JSON
    document. This allows this definition to interact with other tools to generate
    automatic documentation for the API.
  prefs: []
  type: TYPE_NORMAL
- en: It allows the definition of different components that can be repeated, both
    as input and output. This makes it easy to build consistent reusable objects.
    There are also ways of inheriting or composing from one another, thereby creating
    a rich interface.
  prefs: []
  type: TYPE_NORMAL
- en: Describing the whole Open API specification in detail is beyond the scope of
    this book. Most common web frameworks allow integration with it, generating the
    YAML file automatically or the web documentation that we'll see later. It was
    previously called Swagger and its web page ([https://swagger.io/](https://swagger.io/))
    has a very useful editor and other resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is a YAML file that describes the two endpoints described
    above. The file is available on GitHub: [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/pen_example.yaml](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/pen_example.yaml):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the `components` part, the `Pen` object gets defined, and then is used in
    both endpoints. You can see how both endpoints, `POST /pens` and `GET /pens/{pen_id}`,
    are defined and describe the expected input and output, taking into account the
    different errors that can be produced.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most interesting aspects of Open API is the ability to automatically
    generate a documentation page with all the information to help any possible implementation.
    The generated documentation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_02_01.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.1: Swagger Pens documentation'
  prefs: []
  type: TYPE_NORMAL
- en: If the YAML file describes your interface correctly and fully, this can be really
    useful. In some cases, it could be advantageous to work from the YAML to the API.
    This first generates the YAML file and allows work in both directions from there,
    both in the frontend direction and the backend direction. For an API-first approach,
    it may make sense. It's even possible to automatically create skeletons of clients
    and servers in multiple languages, for example, servers in Python Flask or Spring,
    and clients in Java or Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that it's up to you to make the implementation match the definition
    closely. These skeletons will still require enough work to make them work correctly.
    Open API will simplify the process, but it won't magically solve all integration
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the endpoints contains further information and can even be tested in
    the same documentation, thereby significantly helping an external developer who
    wants to use the API, as we can see in the next graphic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_02_02.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.2: Swagger Pens expanded documentation'
  prefs: []
  type: TYPE_NORMAL
- en: Given that it's very easy to ensure that the server can generate this automatic
    documentation, even if the design is not started from an Open API YAML file, it's
    a good idea to generate it so as to create self-generating documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A critical part of virtually any API is the ability to distinguish between authorized
    and unauthorized access. Being able to log the user properly is critical, and
    a headache from the point of view of security.
  prefs: []
  type: TYPE_NORMAL
- en: Security is hard, so it's better to rely on standards to simplify the operation.
  prefs: []
  type: TYPE_NORMAL
- en: As we said before, these are just general tips, but in no way a comprehensive
    set of secure practices. This book is not focused on security. Please keep up
    with security issues and solutions, as this is a field that is always evolving.
  prefs: []
  type: TYPE_NORMAL
- en: The most important security issue regarding authentication is **to always use
    HTTPS endpoints** **in production**. This allows the channel to be protected against
    eavesdropping and makes communication private. Note that an HTTP website just
    means that the communication is private; you could be talking with the devil.
    But it's the bare minimum required to allow users of your API to send you passwords
    and other sensitive information without the fear that an external user is going
    to receive this information.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, most architectures use HTTPS until the request reaches the data center
    or secure network, and then use HTTP internally. This permits a check on the data
    flowing internally but also protects data that is traveling across the internet.
    While less important these days, it also improves efficiency, as encoding requests
    in HTTPS require extra processing power.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS endpoints are valid for all access, but other details are specific depending
    on whether they are HTML interfaces or RESTful ones.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating HTML interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In HTML web pages, normally, the flow to authenticate is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A login screen gets presented to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user enters their login and password and sends them to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server verifies the password. If correct, it returns a cookie with a session
    ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The browser receives the response and stores the cookie.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All new requests will send the cookie. The server will verify the cookie and
    properly identify the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user can log out, removing the cookie. If this is done explicitly, a request
    will be sent to the server to delete the session ID. Typically, the session ID
    will have an expiry time for cleaning itself. This expiry can renew itself on
    each access or force the user to log in again from time to time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's important to set up the cookie as `Secure`, `HttpOnly`, and `SameSite`.
    `Secure` ensures that the cookie is only sent to HTTPS endpoints, and not to HTTP
    ones. `HttpOnly` renders the cookie inaccessible by JavaScript, which makes it
    more difficult to obtain the cookie via malicious code. The cookie will be sent
    automatically to the host that sets it. `SameSite` ensures that cookies are only
    sent when the origin of the source is a page from the same host. It can be set
    to `Strict`, `Lax`, and `None`. `Lax` allows you to navigate to the page from
    a different site, thereby sending the cookie, while `Strict` doesn't allow it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can obtain more information at the Mozilla SameSite Cookie page: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite).'
  prefs: []
  type: TYPE_NORMAL
- en: Possible bad usage of the cookie is through XSS (cross-site scripting) attacks.
    A compromised script reads that cookie, and then forges bad requests authenticated
    as the user.
  prefs: []
  type: TYPE_NORMAL
- en: Another important kind of security problem is **cross-site request forgery**
    (**CSRF**). In this case, the fact that the user is logged in on an external service
    is exploited by presenting a URL that will be automatically executed in a different,
    compromised website.
  prefs: []
  type: TYPE_NORMAL
- en: For example, while accessing a forum, a URL from a common bank is called, presented
    as an image, for example. If the user is logged in to this bank, the operation
    will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The `SameSite` attribute greatly reduces the risk of CSRF, but in case the attribute
    is not understood by older browsers, operations presented to the user by the bank
    should present a random token, making the user send both the authenticated request
    with the cookie and a valid token. An external page won't know a valid random
    token, making this exploit much more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: The session ID that the cookie contains can either be stored in the database,
    being just a random unique identifier, or a rich token.
  prefs: []
  type: TYPE_NORMAL
- en: A random identifier is just that, a random number that stores the related information
    in the database, mainly, who is accessing and when the session expires. With every
    access, this session ID is queried to the server and the related information is
    retrieved. On very big deployments, with many accesses, this can create problems
    as it's less scalable. The database where the session ID is stored needs to be
    accessed by all workers, which can create a bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: One possible solution is to create a rich data token. This works by adding all
    the required information directly to the cookie; for example, storing the user
    ID, expiry, and so on, directly. This avoids database access, but makes the cookie
    possible to forge, as all information is in the open. To fix it, the cookie is
    signed.
  prefs: []
  type: TYPE_NORMAL
- en: The signature proves that the data was originated by a trusted login server
    and can be verified independently by any other server. This is more scalable and
    avoids bottlenecks. Optionally, the content can also be encrypted to avoid being
    read.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of this system is that the generation of the token can be
    independent of the general system. If the token can be validated independently,
    there's no need for the login server to be the same as the general server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even more so, a single token signer can issue tokens for multiple services.
    This is the basis for **SSO** (**Single Sign-On**): log in to an auth provider
    and then use the same account in several related services. This is very common
    in common services such as Google, Facebook or GitHub, to avoid having to create
    a specific login for some web pages.'
  prefs: []
  type: TYPE_NORMAL
- en: That operation mode, having a token authority, is the basis of the OAuth authorization
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating RESTful interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OAuth has become a common standard for authenticating access for APIs, and RESTful
    APIs in particular.
  prefs: []
  type: TYPE_NORMAL
- en: There's a difference between authenticating and authorizing, and in essence,
    OAuth is an authorization system. Authenticating is determining who the user is,
    while authorizing is what the user is capable of doing. OAuth uses the concept
    of `scope` to return what the capabilities of a user are.
  prefs: []
  type: TYPE_NORMAL
- en: Most implementations of OAuth, such as OpenID Connect, also include the user
    information in the returning token to also authenticate the user, returning who
    the user is.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is based on the idea that there''s an authorizer who can check the identity
    of the user and provide them with a token with information allowing the user to
    log in. The service will receive this token and will log the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_02_03.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.3: Authentication flow'
  prefs: []
  type: TYPE_NORMAL
- en: The most common version at the moment is OAuth 2.0, which allows flexibility
    in terms of logging in and flow. Keep in mind that OAuth is not exactly a protocol,
    but provides certain ideas that can be tweaked to the specific use case.
  prefs: []
  type: TYPE_NORMAL
- en: This means that there are different ways in which you can implement OAuth, and,
    crucially, that different authorizers will implement it differently. Please verify
    their documentation with care when implementing the integration.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, authorizers use the OpenID Connect protocol, which is based on OAuth.
  prefs: []
  type: TYPE_NORMAL
- en: There's an important difference in terms of whether the system accessing the
    API is the final user directly, or whether it accesses it on behalf of a user.
    An example of the latter could be a smartphone app to access a service like Twitter,
    or a service that needs to access the data stored for the user in GitHub, such
    as a code analysis tool. The app itself is not the one that performs the actions
    but transfers the actions of a user.
  prefs: []
  type: TYPE_NORMAL
- en: This flow is called the Authorization Code grant. The main characteristic is
    that the auth provider will present a login page to the user and redirect them
    with the authentication token.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this could be the sequence of calls for the Authorization Code
    grant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If the system accessing the API is from the end user directly, the Client Credentials
    grant type flow can be used instead. In this case, the first call will send `client_id`
    (user ID) and `client_secret` (password) to retrieve the authentication token
    directly. This token will be set in new calls as a header, authenticating the
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this skips a step, and is easier to automate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: While OAuth allows you to use an external server to retrieve the access token,
    that's not strictly required. It can be the same server as the rest. This is useful
    for this last flow, where the ability to log in with an external provider such
    as Facebook or Google is not as useful. Our example system will use the Client
    Credentials flow.
  prefs: []
  type: TYPE_NORMAL
- en: Self-encoded tokens
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The returned tokens from the authorization server can contain sufficient information
    such that no external check with the authorizer is required.
  prefs: []
  type: TYPE_NORMAL
- en: As we've seen, including the user information in the token is important to determine
    who the user is. If not, we will end with a request that is capable of doing the
    work, but without information on behalf of who.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, the token is typically encoded in a **JSON Web Token** (**JWT**).
    A JWT is a standard that encodes a JSON object in a URL-safe sequence of characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'A JWT has the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A header. This contains information on how the token is encoded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A payload. The body of the token. Some of the fields in this object, called
    claims, are standard, but it can allocate custom claims as well. Standard claims
    are not required and can describe elements such as the issuer (`iss`), or the
    expiration time of the token as Unix Epoch (`exp`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A signature. This verifies that the token was generated by the proper source.
    This uses different algorithms, based on the information in the header.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, a JWT is encoded, but it's not encrypted. A standard JWT library
    will decode its parts and verify that the signature is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test the different fields and systems in the interactive tool: [https://jwt.io/](https://jwt.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to generate a token using `pyjwt` ([https://pypi.org/project/PyJWT/](https://pypi.org/project/PyJWT/)),
    you''ll need to install PyJWT using pip if not previously installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, while opening a Python interpreter, to create a token with a payload
    with a user ID and an HS256 algorithm to sign it with the `"secret"` secret, you
    use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The JWT token can then be decoded and the payload extracted. If the secret
    is incorrect, it will produce an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The algorithm to be used is stored in the headers, but it''s a good idea, for
    reasons of security, to only validate the token with the expected algorithm and
    not rely on the header. In the past, there have been some security problems with
    certain JWT implementations and forgery of the tokens, as you can read here: [https://www.chosenplaintext.ca/2015/03/31/jwt-algorithm-confusion.html](https://www.chosenplaintext.ca/2015/03/31/jwt-algorithm-confusion.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The most interesting algorithms, though, are not symmetrical ones like `HS256`,
    where the same value is added for encoding and decoding, but public-private keys
    like RSA-256 (`RS256`). This allows the token to be encoded with the private key
    and verified with the public key.
  prefs: []
  type: TYPE_NORMAL
- en: This schema is very common, as the public key can be distributed widely, but
    only the proper authorizer who has the private key can be the source of the tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Including the payload information that can be used to identify the user allows
    authentication of the requests using just the information in the payload, once
    verified, as we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are rarely created fully formed from scratch. They are constantly
    being tweaked, with new features added, and bugs or inconsistencies fixed. To
    better communicate these changes, it's useful to create some sort of versioning
    to transmit this information.
  prefs: []
  type: TYPE_NORMAL
- en: Why versioning?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main advantage of versioning is to shape the conversation about what things
    are included when. This can be bug fixes, new features, or even newly introduced
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: If we know that the current interface released is version `v1.2.3`, and we are
    about to release version `v1.2.4`, which fixes bug X, we can talk about it more
    easily, as well as creating release notes informing users of that fact.
  prefs: []
  type: TYPE_NORMAL
- en: Internal versus external versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two kinds of versions that can get a bit confused. One is the internal
    version, which is something that makes sense for the developers of a project.
    This is normally related to the version of the software, usually with some help
    from version control, such as Git.
  prefs: []
  type: TYPE_NORMAL
- en: This version is very detailed and can cover very small changes, including small
    bug fixes. The aim of it is to be able to detect even minimal changes between
    software to allow the detection of bugs or the introduction of code.
  prefs: []
  type: TYPE_NORMAL
- en: The other is the external version. The external version is the version that
    people using the external service are going to be able to perceive. While this
    can be as detailed as the internal one, that is normally not that helpful to users
    and can provide a confusing message.
  prefs: []
  type: TYPE_NORMAL
- en: This largely depends on the kind of system and who their expected users are.
    A highly technical user will appreciate the extra details, but a more casual one
    will not.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an internal version may distinguish between two different bug fixes,
    as this is useful to replicate. An externally communicated version can combine
    them both in "multiple bug fixes and improvements."
  prefs: []
  type: TYPE_NORMAL
- en: Another good example of when it's useful to make a difference is when the interface
    changes massively. For example, a brand-new revamp of the look and feel of a site
    could use "Version 2 interface," but this can happen over multiple internal new
    versions, to be tested internally or by a selected group (for example, beta testers).
    Finally, when the "Version 2 interface" is ready, it can be activated for all
    users.
  prefs: []
  type: TYPE_NORMAL
- en: One way of describing the external version could be to call it a "marketing
    version."
  prefs: []
  type: TYPE_NORMAL
- en: Note that here we are avoiding the term "release version" as it could be misleading.
    This version is only used to communicate information externally.
  prefs: []
  type: TYPE_NORMAL
- en: This version will be more dependent on marketing efforts than technical implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common pattern for defining versions is to use semantic versioning. Semantic
    versioning describes a method with three increasing integers that carry different
    meanings, in descending order of incompatibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vX.Y.Z`'
  prefs: []
  type: TYPE_NORMAL
- en: X is called the **major** version. Any change in the major version will mean
    backward-incompatible changes.
  prefs: []
  type: TYPE_NORMAL
- en: Y is the **minor** version. Minor changes may add new features, but any change
    will be backward compatible.
  prefs: []
  type: TYPE_NORMAL
- en: Z is the **patch** version. It will only make small changes such as bug fixes
    and security patches, but it doesn't change the interface itself.
  prefs: []
  type: TYPE_NORMAL
- en: The `v` at the start is optional but helps to indicate that it's a version number.
  prefs: []
  type: TYPE_NORMAL
- en: This means that software designed to work with `v1.2.15` will work with versions
    `v1.2.35` and `v1.3.5`, but it won't work with version `v2.1.3` or version `v1.1.4`.
    It may work with version `v1.2.14`, but it may have some bug that was corrected
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, extra details can be added to describe interfaces that are not ready,
    for example, `v1.2.3-rc1` (release candidate) or `v1.2.3-dev0` (development version).
  prefs: []
  type: TYPE_NORMAL
- en: Normally, before the software is ready for release, the major number is set
    to zero (for example, `v0.1.3`), making version `v1.0.0` the first one to be publicly
    available.
  prefs: []
  type: TYPE_NORMAL
- en: 'This semantic versioning is very easy to understand and gives good information
    about changes. It is widely used, but it has some problems in certain cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Strictly adopting the major version for systems that don't have clear backward
    compatibility can be difficult. This was the reason why the Linux kernel stopped
    using proper semantic versioning, because they will never update the major version,
    as every single release needed to be backward compatible. In that case, a major
    version can be frozen for years and years and stops being a useful reference.
    In the Linux kernel, that happened with version 2.6.X, which remained for 8 years
    until version 3.0 was released in 2011 without any backward-incompatible change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semantic versioning requires a pretty strict definition of the interface. If
    the interface changes often with new features, as happens typically with online
    services, the minor version increases quickly, and the patch version is of almost
    no use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For online services, the combination of both will make only a single number
    useful, which is not a great use of it. Semantic versioning works better for cases
    that require multiple API versions working at the same time, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: The API is very stable and changes very rarely, though there are regular security
    updates. Every couple of years, there's a major update. A good example is databases,
    such as MySQL. Operative systems are another example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API belongs to a software library that can be used by multiple supported
    environments; for example, a Python library compatible with Python 2 for version
    v4 and Python 3 for v5\. This can allow several versions to be kept alive if required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the system effectively has a single version running at the same time, it
    is better to not add the extra effort to keep proper semantic versioning in place
    as the effort is not worth the reward in terms of the kind of investment required.
  prefs: []
  type: TYPE_NORMAL
- en: Simple versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of doing strict semantic versioning, a simplified version can be done
    instead. This won't carry the same kind of meaning, but it will be a constantly
    increasing counter. This will work to coordinate teams, although it won't require
    the same kind of commitment.
  prefs: []
  type: TYPE_NORMAL
- en: This is the same idea as the build number that can be created automatically
    by compilers, an increasing number to distinguish one version from another and
    work as a reference. However, a plain build number can be a bit dry to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is better to use a similar structure to semantic versioning, as it will
    be understandable by everyone; but instead of using it with specific rules, it
    is looser than that:'
  prefs: []
  type: TYPE_NORMAL
- en: Normally, for a new version, increase the patch version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If either the patch version gets too high (in other words, 100, 10, or another
    arbitrary number), increase the minor version and set the patch version to zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, if there's any special milestone for the project, as defined
    by the people working on it, increase the minor number earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do the same with the major version number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will allow the numbers to be increased in a consistent way without worrying
    too much about meaning.
  prefs: []
  type: TYPE_NORMAL
- en: This structure works very well for things like online cloud services, which,
    in essence, require an increasing counter, as they have a single version deployed
    at the same time. In this case, the most important use of the version is internal
    usage and won't require the maintenance that strict semantic versioning requires.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend and backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The usual way of dividing different services is by talking about the "frontend"
    and the "backend." They describe the layers of software, where the layer closer
    to the end user is the frontend, and the one behind is the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, the frontend is the layer that takes care of the presentation
    layer, next to the user, and the backend is the data access layer, which serves
    the business logic. In a client-server architecture, the client is the frontend
    and the server is the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_02_04.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.4: Client-Server architecture'
  prefs: []
  type: TYPE_NORMAL
- en: As architectures grow more complex, these terms become somewhat polysemic, and
    they are usually understood depending on the context. While *frontend* is almost
    always understood as the user interface directly, *backend* can be applied to
    multiple layers, meaning the next layer that gives support to whatever system
    is being discussed. For example, in a cloud application, the web application may
    use a database such as MySQL as the storage backend, or in-memory storage such
    as Redis as the cache backend.
  prefs: []
  type: TYPE_NORMAL
- en: The general approach for the frontend and backend is quite different.
  prefs: []
  type: TYPE_NORMAL
- en: The frontend focuses on the user experience, so the most important elements
    are usability, pleasing design, responsiveness, and so on. A lot of that requires
    an eye for the "final look" and how to make things easy to use. Frontend code
    is executed in the final user, so compatibility between different types of hardware
    can be important. At the same time, it distributes the load, so performance is
    most important from the point of view of the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: The backend focuses more on stability. Here, the hardware is under strict control,
    but the load is not distributed, making performance important in terms of controlling
    the total resources used. Modifying the backend is also easier, as changing it
    once changes it for all the users at the same time. But it's riskier, as a problem
    here may affect every single user. This environment primes more to focus on solid
    engineering practices and replicability.
  prefs: []
  type: TYPE_NORMAL
- en: The term full stack engineer is commonly used to describe someone who is comfortable
    doing both kinds of work. While this can work in certain aspects, it's actually
    quite difficult to find someone who is equally comfortable or who is inclined
    to work on both elements in the longer term.
  prefs: []
  type: TYPE_NORMAL
- en: Most engineers will naturally tend toward one of the sides, and most companies
    will have different teams working on both aspects. In a certain way, the personality
    traits for each work are different, with frontend work requiring more of an eye
    for design, and backend users being comfortable with stability and reliability
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, some common technologies used for the frontend are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: HTML and associated technologies such as CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript and libraries or frameworks to add interactivity, such as jQuery
    or React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Backend technologies, as they are under more direct control, can be more varied,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple programming languages, either scripting languages such as Python, PHP,
    Ruby, or even JavaScript using Node.js, or compiled languages such as Java or
    C#. They can even be mixed, making different elements in different languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Databases, either relational databases such as MySQL or PostgreSQL, or non-relational
    ones such as MongoDB, Riak, or Cassandra.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web servers, such as Nginx or Apache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability and high-availability tools, such as load balancers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure and cloud technologies, such as AWS services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container-related tech, like Docker or Kubernetes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The frontend will make use of interfaces defined by the backend to present the
    actions in a user-friendly way. There can be several frontends for the same backend,
    a typical example being multiple smartphone interfaces for different platforms,
    but that use the same API to communicate with the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that frontend and backend are conceptual divisions, but they don't
    necessarily need to be divided into different processes or repositories. A common
    case where the frontend and backend live together are web frameworks such as Ruby
    on Rails or Django, where you can define the frontend HTML interface at the same
    time as the backend controllers that handle the data access and business logic.
    In this case, the HTML code is served directly from the same process that performs
    access to the data. This process separates the concerns using the Model View Controller
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: Model View Controller structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Model View Controller, or MVC, is a design that separates the logic of a
    program into three distinct components.
  prefs: []
  type: TYPE_NORMAL
- en: The Model View Controller pattern started very early in the design of graphic
    user interfaces and has been used in that area since the first full graphic interactive
    interfaces in the 80s. In the 90s, it started being introduced as a way of handling
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This structure is really successful as it creates a clear separation of concepts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Model manages the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Controller accepts input from the user and transforms it into the manipulation
    of the model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The View represents the information for the user to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In essence, the Model is the core of the system, as it deals with the manipulation
    of the data. The Controller represents the input, and the View represents the
    output of the operations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Shape'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_02_05.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.5: The Model View Controller pattern'
  prefs: []
  type: TYPE_NORMAL
- en: The MVC structure can be considered at different levels, and it can be regarded
    as fractal. If several elements interact, they can have their own MVC structure,
    and the model part of a system can talk to a backend that provides information.
  prefs: []
  type: TYPE_NORMAL
- en: The MVC pattern can be implemented in different ways. For example, Django claims
    it is a Model View *Template*, as the controller is more the framework itself.
    However, these are minor details that don't contradict the general design.
  prefs: []
  type: TYPE_NORMAL
- en: The Model is arguably the most important element of the three as it's the core
    part of it. It contains the data access, but also the business logic. A rich Model
    component works as a way of abstracting the logic of the application from the
    input and output.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly, some of the barriers between controllers get a bit blurry. Different
    inputs may be dealt with in the Controller, producing different calls to the Model.
    At the same time, the output can be tweaked in the Controller before being passed
    to the view. While it's always difficult to enforce clear, strict boundaries,
    it's good to keep in mind what the main objective of each component is so as to
    provide clarity.
  prefs: []
  type: TYPE_NORMAL
- en: HTML interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the strict definition of APIs works for interfaces that are designed to
    be accessed by other programs, it's good to spend a bit of time talking about
    the basics of how to create a successful human interface. For this purpose, we
    will talk mainly about HTML interfaces, aimed at being used by the end user in
    a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the concepts that we will deal with apply to other kinds of human interfaces,
    such as GUIs or mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: HTML technologies are highly related to RESTful ones because they were developed
    in parallel during the early days of the internet. Typically, they are presented
    intertwined in modern web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional HTML interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way traditional web interfaces work is through HTTP requests, only using
    the `GET` and `POST` methods. `GET` retrieves a page from the server, while `POST`
    is paired with some form that submits data to the server.
  prefs: []
  type: TYPE_NORMAL
- en: This was a prerequisite, as browsers only implemented these methods. While,
    nowadays, most modern browsers can use all HTTP methods in requests, it's still
    a common requirement to allow compatibility with older browsers.
  prefs: []
  type: TYPE_NORMAL
- en: While this is certainly more restrictive than all the available options, it
    can work well for simple website interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a blog is read way more often than is written, so readers make
    use of a lot of `GET` requests to get the information, and perhaps some `POST`
    requests to send back some comments. The need to remove or change a comment was
    traditionally small, although it can be allocated with other URLs where `POST`
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: Note that browsers will ask you before retrying a `POST` request as they are
    not idempotent.
  prefs: []
  type: TYPE_NORMAL
- en: An HTML interface doesn't work in the same way as a RESTful interface because
    of these limitations, but it can also improve with a design that takes the abstractions
    and resources approach in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, some common abstractions for a blog are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Each post, with associated comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A main page with the latest posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A search page that can return posts that contain a certain word or tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is very similar to the interface in resources, where only the two resources
    of "comment" and "post,", which will be separated in a RESTful way, will be joined
    in the same concept.
  prefs: []
  type: TYPE_NORMAL
- en: The main limitation of traditional HTML interfaces is that every change needs
    to refresh the whole page. For simple applications like a blog, this can work
    quite well, but more complex applications may require a more dynamic approach.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add interactivity to the browser, we can add some JavaScript code that will
    perform actions to change the page directly on the browser representation; for
    example, selecting the color of the interface from a drop-down selector.
  prefs: []
  type: TYPE_NORMAL
- en: This is called manipulating the **Document Object Model** (**DOM**), which contains
    the representation of the document as defined by the HTML and possibly the CSS.
    JavaScript can access this representation and change it by editing any parameters
    or even adding or removing elements.
  prefs: []
  type: TYPE_NORMAL
- en: From JavaScript, independent HTTP requests can also be done, so we can use that
    to make specific calls to retrieve details that can be added to improve the experience
    of the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for a form to input an address, a dropdown may select the country.
    Once selected, a call to the server will retrieve the proper regions to incorporate
    the input. If the user selects **United States**, the list of all states will
    be retrieved and be available in the next dropdown. If the user selects **Canada**,
    the list of territories and provinces will be used instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_02_06.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.5: Improving user experience with appropriate dropdowns'
  prefs: []
  type: TYPE_NORMAL
- en: Another example, that reverses the interface somewhat, could be to use the ZIP
    code to determine the state automatically.
  prefs: []
  type: TYPE_NORMAL
- en: There is actually a service to retrieve this information called [https://zippopotam.us/](https://zippopotam.us/).
    It can be called and returns not only the state but further information, in JSON
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'These kinds of calls are called **Asynchronous JavaScript And XML** (**AJAX**).
    Although the name mentions XML, it''s not required, and any format can be retrieved.
    At the moment, it is very common to use JSON or even plain text. One possibility
    is to use HTML, so an area of the page can be replaced with snippets that come
    from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shape, rectangle'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_02_07.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.6: Using HTML to replace areas of the page'
  prefs: []
  type: TYPE_NORMAL
- en: Raw HTML, although somewhat inelegant, can be effective, so it's very common
    to use a RESTful API returning JSON to retrieve the expected data for these small
    elements and then modify the DOM with it through JavaScript code. Given that the
    objective of this API is not to replace the HTML interface in its entirety, but
    complement it, this RESTful API will likely be incomplete. It won't be possible
    to create a full experience using only these RESTful calls.
  prefs: []
  type: TYPE_NORMAL
- en: Other applications go directly to the point of creating an API-first approach
    and create the browser experience from there.
  prefs: []
  type: TYPE_NORMAL
- en: Single-page apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind a single-page app is easy. Let's open a single HTML page and
    change its content dynamically. If there's any new data to be required, it will
    be accessed through a specific (typically RESTful) API.
  prefs: []
  type: TYPE_NORMAL
- en: This completely detaches the human interface, understood as the elements that
    have the responsibility of displaying the information to a human, from the service.
    The service serves a RESTful API exclusively, without worrying about the representation
    of the data.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of approach is sometimes called API-first as it designs a system from
    the API to the representation, instead of creating it the other way around, which
    is the natural way in which it is created in an organic service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although there are specific frameworks and tools designed with this objective
    in mind, such as React or AngularJS, there are two main challenges with this kind
    of approach:'
  prefs: []
  type: TYPE_NORMAL
- en: The technical skill required to create a successful human interface on a single
    page is quite high, even with the help of tools. Any non-trivial representation
    of a valid interface will require keeping a lot of state and dealing with multiple
    calls. This is prone to have errors that compromise the stability of the page.
    The traditional approach for browser pages works with independent pages that limit
    the scope of each step, which is easier to handle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that there are interface expectations carried by the browser that
    can be difficult to avoid or replace, for example, hitting the back button.
  prefs: []
  type: TYPE_NORMAL
- en: The need to design and prepare the API beforehand can result in a slow start for
    the project. It requires more planification and upfront commitment, even if both
    sides are developed in parallel, which also has its challenges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These issues ensure that this approach is not usually done for new applications
    starting from scratch. However, if the application started with another kind of
    user interface, like a smartphone application, it could leverage the already existing
    REST API to generate an HTML interface that replicates the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of this approach is detaching the application from the user
    interface. Where an application starts its development as a small project with
    a regular HTML interface, the risk is that any other user interface will tend
    to conform to the HTML interface. This can quickly add up to a lot of technical
    debt and compromise the design of the API, as the abstractions that are used will
    likely be derived from the existing interface, instead of the most adequate ones.
  prefs: []
  type: TYPE_NORMAL
- en: A whole API-first approach greatly separates the interface, so creating a new
    interface is as easy to use as the already existing API. For applications that
    require multiple interfaces, such as an HTML interface, but also different smartphones
    applications for iOS and Android, that could be a good solution.
  prefs: []
  type: TYPE_NORMAL
- en: A single-page application can also be quite innovative in terms of presenting
    a full interface. This can create rich and complex interfaces that deviate from
    what could be understood as a "web page," as in the case of a game or an interactive
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Going all-in with a single-page application, as we've seen, can be quite challenging.
    To a certain degree, it is using a browser to overwrite its usage.
  prefs: []
  type: TYPE_NORMAL
- en: That's why normally the design doesn't go that far and creates a more traditional
    web interface. This interface is still recognizable as a web application but relies
    heavily on JavaScript to obtain information using a RESTful interface. This can
    happen as a natural step to migrating from a traditional HTML interface to a single-page
    app, but it may also be a conscious decision.
  prefs: []
  type: TYPE_NORMAL
- en: This approach combines the previous two. On the one hand, it still requires
    an HTML interface for the general approach of the interface, with clear pages
    to navigate. On the other, it creates a RESTful API that fills most of the information
    and uses JavaScript to make use of this API.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is similar to the dynamic page one, but there is an important
    difference, which is the intention to create a coherent API that can be used without
    being totally tailored to the HTML interface. That changes the approach significantly.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this tends to create a less complete RESTful API, as some of the
    elements may be added directly to the HTML part of it. But, at the same time,
    it allows the iterative migration of elements into the API, starting with certain
    elements, but adding more as time goes by. This stage is very flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the API for the example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we described in the first chapter, *General Overview of the Example*, we
    need to set the definition for the different interfaces that we will be working
    on in the example. Remember that the example is a microblogging application that
    will allow users to write their own text microposts so that they are available
    for others to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main interfaces in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: An HTML interface for allowing users to interact with the service using a browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A RESTful interface for allowing the creation of other clients like a smartphone
    app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will describe the design of the second interface. We will
    start with a description of the different basic definitions and resources that
    we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User**: A representation of the user of the application. It will be defined
    by a username and a password to be able to login.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Micropost**: A small text of up to 255 characters posted by a *User*. A *Micropost*
    can be optionally addressed to a *User*. It has also the time it was created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection**: The display of *Microposts* from a *User*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Follower**: A *User* can follow another *User*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timeline**: An ordered list of the *Microposts* by the followed *Users*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search**: Allow a search by *User* or by text contained in *Microposts*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can define these elements as resources in a RESTful way, in the way introduced
    earlier in the chapter, first as a quick description of the URIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that we added `POST` and `DELETE` resources for `/token` to deal with login
    and logout.
  prefs: []
  type: TYPE_NORMAL
- en: Once this brief design is complete, we can flesh out the definition of each
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will describe all the API endpoints in a bit more detail, following the template
    introduced previously in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Login:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Using the proper authentication credentials, return a valid
    access token. The token needs to be included in the requests as the `Authorization`
    header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/api/token`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `POST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Request body*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Return body*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Errors*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Logout:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Invalidate the bearer token. If successful, it will return a
    `204 No Content` error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/api/token`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `DELETE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Errors*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Retrieve user:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Returns the username resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/api/users/<username>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Query Parameters*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Return body*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Errors*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Retrieve user''s collection:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Returns the collection of all microposts from a user, in paginated
    form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/api/users/<username>/collection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Return body*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Errors*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Create new micropost:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Create a new micropost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource* *URI*: `/api/users/<username>/collection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `POST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Request body*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Errors*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Retrieve micropost:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Returns a single micropost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource* *URI*: `/api/users/<username>/collection/<micropost_id>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Return body*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Errors*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Update micropost:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Update the text for a micropost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource* *URI*: `/api/users/<username>/collection/<micropost_id>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `PUT, PATCH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Request body*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Errors*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Delete micropost:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Delete a micropost. If successful, it will return a `204 No
    Content` error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource* *URI*: `/api/users/<username>/collection/<micropost_id>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `DELETE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Errors*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Retrieve user''s timeline:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Returns the collection of all microposts from the timeline of
    a user, in paginated form. The microposts will be returned by timestamp order,
    with the oldest being returned first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource* *URI*: `/api/users/<username>/timeline`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Return* *body*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Errors*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Retrieve the users a user is following:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Returns a collection of all users that the selected user is
    following.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource* *URI*: `/api/users/<username>/following`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Return* *body*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Errors*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Follow a user:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Causes the selected user to follow a different user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/api/users/<username>/following`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `POST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Request body*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Errors*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Stop following a user:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Stops following a user. If successful, it will return a `204
    No Content` error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/api/users/<username>/following/<username>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `DELETE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Errors*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Retrieve a user''s followers:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Returns, in paginated form, all followers of this user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/api/users/<username>/followers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*:`Authentication: Bearer: <token>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Return body*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Errors*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Search microposts:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Description*: Returns, in paginated form, microposts that fulfill the search
    query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource URI*: `/api/search`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Method*: `GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Headers*: `Authentication: Bearer: <token>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Query parameters*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Return body*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Errors*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Review of the design and implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This two-step approach of presenting and designing a new API enables you to
    quickly see whether something is out of place as regards the design. Then, it
    can be iterated over until fixed. The next step is to start with the implementation,
    as we will see in forthcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described how the basics of API design are to create a set
    of useful abstractions that allow users to perform actions without having to care
    about the internal details. This led to describing how to define an API with resources
    and actions.
  prefs: []
  type: TYPE_NORMAL
- en: This definition of an API has evolved to cover RESTful interfaces that follow
    certain properties that make them very interesting for web server design. We described
    a bunch of useful standards and techniques when designing RESTful interfaces to
    create consistent and complete interfaces, including the OpenAPI tools. We went
    through authentication details as it's a very important element for APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that extra care should be advised when securing APIs that have external
    usage. We went through some general ideas and common strategies, but note that
    this book does not focus on security. This is a critical aspect of the design
    of any API and should be done carefully.
  prefs: []
  type: TYPE_NORMAL
- en: We covered the ideas behind versioning and how to create a proper versioning
    schema that's tailored to the specific use case for the API. We also covered the
    differences between the frontend and the backend and how this can be generalized.
    We also covered the MVC pattern, which is a very common way to structure software.
  prefs: []
  type: TYPE_NORMAL
- en: We described the different options for HTML interfaces to provide a complete
    overview of the different interfaces in web services. We covered different options
    in terms of how an HTML service can be constructed and interact with other APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we presented the design for the RESTful interface for the example,
    while reviewing the general design and endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Another critical element of design is the data structure. We will cover this
    next.
  prefs: []
  type: TYPE_NORMAL
