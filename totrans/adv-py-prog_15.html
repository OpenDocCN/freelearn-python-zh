<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer172">
			<h1 id="_idParaDest-245"><em class="italic"><a id="_idTextAnchor228"/>Chapter 13</em>: Starvation</h1>
			<p>In this chapter, we will discuss the concept of <strong class="bold">starvation</strong> and its potential causes in concurrent programming. We will cover a number of variations of the <strong class="bold">readers-writers problems</strong>, which are prime examples of starvation, and we will simulate them in example Python code. This chapter will also cover the relationship between <em class="italic">deadlock</em> and <em class="italic">starvation</em>, as well as some potential solutions for starvation.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Understanding starvation</li>
				<li>Approaching the readers-writers problem</li>
				<li>Solutions to starvation</li>
			</ul>
			<p>By the end of the chapter, you will have a deep understanding of starvation, what causes it, and what practical solutions can be implemented to address the problem.</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor229"/>Technical requirements</h1>
			<p>The code files for this chapter can be accessed through this link: <a href="https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter13">https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter13</a>.</p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor230"/>Understanding starvation</h1>
			<p><strong class="bold">Starvation</strong> is a problem in concurrent systems, in which<a id="_idIndexMarker1014"/> a process (or a thread) cannot gain access to the necessary resources in order to proceed with its execution and, therefore, cannot make any progress. In this section, we will look into the characteristics of a starvation situation, analyze its most common causes, and finally, consider a sample program that exemplifies starvation.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor231"/>What is starvation?</h2>
			<p>It is quite common for a concurrent program<a id="_idIndexMarker1015"/> to implement some sort of ordering between the different processes in its execution. For example, consider a program that has three separate processes, as follows:</p>
			<ul>
				<li>One is responsible for handling extremely pressing instructions that need to be run as soon as the necessary resources become available.</li>
				<li>Another process is responsible for other important executions, which are not as essential as the tasks in the first process.</li>
				<li>The last one handles miscellaneous, very infrequent tasks.</li>
			</ul>
			<p>Furthermore, these three processes need to utilize the same resources in order to execute their respective instructions.</p>
			<p>Intuitively, we have every reason to implement a specification that allows the first process to have the highest priority of execution and access to resources, then the second process, and then the last process, with the lowest priority. However, imagine situations in which the first two processes (with higher priorities) run so often that the third process cannot execute its instructions; anytime the third process needs to run, it checks to see whether the resources are available to be used and finds out that one of the other higher-priority processes is using them.</p>
			<p>This is a situation of starvation – the third process is given no opportunity to execute and, therefore, no progress can be made with that process. In a typical concurrent program, it is quite common to have more than three processes at different priority levels, yet the situation is fundamentally similar – some processes are given more opportunities to run and, therefore, they are constantly executing. Others have lower priorities and cannot access the necessary resources to execute.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor232"/>Scheduling</h2>
			<p>In the next few subsections, we will be discussing the potential candidates that cause starvation situations. Most<a id="_idIndexMarker1016"/> of the time, a poorly coordinated set of <em class="italic">scheduling instructions</em> is the main cause of starvation. For example, a considerably naive algorithm that deals with three separate tasks might implement constant communication and interaction between the first two tasks.</p>
			<p>This setup leads to the fact that the execution flow of the algorithm switches solely between the first and second tasks, while the third finds itself idle and unable to make any progress with its execution – in this case, because it is starved of CPU execution flow. Intuitively, we can identify the root of the problem as the fact that the algorithm allows the first two tasks to always dominate the CPU and, hence, effectively prevents any other task from also utilizing the CPU. A characteristic of a good scheduling algorithm is the ability to distribute the execution flow and allocate the resources equally and appropriately.</p>
			<p>As mentioned previously, many concurrent systems<a id="_idIndexMarker1017"/> and programs implement a specific order of priority, in terms of process and thread execution. This implementation of ordered scheduling may very likely lead to the starvation of processes and threads of lower priorities<a id="_idIndexMarker1018"/> and can result in a condition called <strong class="bold">priority inversion</strong>.</p>
			<p>Suppose that, in your concurrent program, you have process A of the highest priority, process B of a medium priority, and finally, process C of the lowest priority; process C would most likely be put in the situation of starvation. Additionally, if the execution of process A, the prioritized process, is dependent on the completion of process C, which is already in starvation, then process A might never be able to complete its execution either, even though it is given the highest priority in the concurrent program.</p>
			<p>The following diagram further illustrates the concept of priority inversion – a high-priority task running from the time <strong class="bold">t2</strong> to <strong class="bold">t3</strong> needs to access some resources, which are being utilized by a low-priority task:</p>
			<div>
				<div id="_idContainer169" class="IMG---Figure">
					<img src="image/B17499Figure_13.1.jpg" alt="Figure 13.1 – A diagram of priority inversion " width="1024" height="525"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1 – A diagram of priority inversion</p>
			<p>To reiterate, combining starvation<a id="_idIndexMarker1019"/> and priority inversion can lead to a situation where<a id="_idIndexMarker1020"/> even the high-priority tasks are unable to execute their instructions.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor233"/>Causes of starvation</h2>
			<p>With the complexity of designing<a id="_idIndexMarker1021"/> a scheduling algorithm in mind, let's discuss the specific causes of starvation. The situations that we described in the preceding section indicate some potential causes of a starvation situation. However, starvation can arise from a number of sources, as follows:</p>
			<ul>
				<li>Processes (or threads) with high priorities dominate the execution flow in the CPU and, hence, low-priority processes (or threads) are not given the opportunity to execute their own instructions.</li>
				<li>Processes (or threads) with high priorities dominate the usage of non-shareable resources and, hence, low-priority processes (or threads) are not given the opportunity to execute their own instructions. This situation is similar to the first one but addresses the priority of accessing resources, instead of the priority of the execution itself.</li>
				<li>Processes (or threads) with low priorities are waiting for resources to execute their instructions, but as soon as the resources become available, other processes (or threads) with higher priorities are immediately given access to them, so the low-priority processes (or threads) wait indefinitely.</li>
			</ul>
			<p>There are other causes of starvation as well, but the preceding are the most common root causes.</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor234"/>Starvation's relationship to deadlock</h2>
			<p>Interestingly, deadlock situations<a id="_idIndexMarker1022"/> can also lead to starvation, as the definition of starvation<a id="_idIndexMarker1023"/> states that if there is a process (or a thread) that is unable to make any progress because it cannot gain access to the necessary process, the process (or thread) is experiencing starvation.</p>
			<p>Recall our example of deadlock, the Dining Philosophers problem, illustrated as follows:</p>
			<div>
				<div id="_idContainer170" class="IMG---Figure">
					<img src="image/B17499Figure_13.2.jpg" alt="Figure 13.2 – An illustration of the Dining Philosophers problem " width="752" height="802"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2 – An illustration of the Dining Philosophers problem</p>
			<p>When deadlock occurs in this situation, no philosopher can obtain the necessary resources to execute their instructions (each philosopher is required to have two forks to start eating). Each philosopher<a id="_idIndexMarker1024"/> that is in deadlock is therefore also in a state<a id="_idIndexMarker1025"/> of starvation.</p>
			<p>The readers-writers problem describes in detail the various types of starvation, which we will consider next.</p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor235"/>Approaching the readers-writers problem</h1>
			<p>The readers-writers problem is one of the classic use cases<a id="_idIndexMarker1026"/> in concurrent programming, illustrating problems that might occur in a concurrent program. Throughout the analysis of the different variations of the readers-writers problem, we will reveal more about starvation, as well as its common causes. We will also simulate the problem in Python<a id="_idIndexMarker1027"/> so that a deeper understanding of the problem can be gained.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor236"/>Problem statement</h2>
			<p>In a readers-writers problem, first and foremost, we have a shared resource, which, in most cases, is a text file. Different threads interact with that text file; each is either a reader or a writer. A <strong class="bold">reader</strong> is a thread that simply accesses<a id="_idIndexMarker1028"/> the shared resource (the text file) and reads in the data<a id="_idIndexMarker1029"/> included in that file, while a <strong class="bold">writer</strong> is a thread that accesses, and possibly mutates, the contents of the text file.</p>
			<p>We know that writers and readers<a id="_idIndexMarker1030"/> cannot access the shared resources simultaneously since if a thread is writing data to the file, no other thread should be accessing the file to read any data from it. The goal of the readers-writers problem is therefore to find a correct and efficient way to design and coordinate the scheduling of these reader and writer threads. Successful implementation of that goal is not only that the program as a whole executes in the most optimized way but also that all threads are given sufficient opportunity to execute their instructions and no starvation can occur. Additionally, the shared resource (the text file) needs to be handled appropriately so that no data will be corrupted.</p>
			<p>The following diagram further illustrates the setup of the readers-writers problem:</p>
			<div>
				<div id="_idContainer171" class="IMG---Figure">
					<img src="image/B17499Figure_13.3.jpg" alt="Figure 13.3 – A diagram of the readers-writers problem " width="1419" height="655"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3 – A diagram of the readers-writers problem</p>
			<p>In the following subsections, we will be exploring different variations of the problem with increasing levels of complexity. From there, we will also implement sample solutions to these problems, thus gaining<a id="_idIndexMarker1031"/> hands-on experience in preventing starvation in concurrent applications.</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor237"/>The first readers-writers problem</h2>
			<p>As we mentioned, the problem asks us to come up with a scheduling algorithm so that readers and writers can access<a id="_idIndexMarker1032"/> the text file appropriately and efficiently, without mishandling or corrupting the data that is included. A naive solution to this problem is to impose a lock on the text file so that it becomes a non-shareable resource; this means that only one thread (either a reader or a writer) can access (and potentially manipulate) the text file at any given time.</p>
			<p>Yet, this approach simply equates to a sequential program – if the shared resource can be utilized by only one thread at a given time, none of the processing time between different threads can be overlapped and, effectively, the execution becomes sequential. Therefore, this is not an optimal solution, as it is taking advantage of concurrent programming.</p>
			<p>One insight regarding the reader threads can lead to a more optimal solution to this problem – since readers simply read in the text file and do not alter the data in it, multiple readers can be allowed to access the text file simultaneously. Indeed, even if more than one reader is fetching data from the text file at the same time, the data is not being changed in any way, and the consistency and accuracy of the data are therefore maintained.</p>
			<p>Following this approach, we will implement a specification in which no reader will be kept waiting if the shared resource is being opened for reading by another reader. Specifically, in addition to a lock on the shared resource, we will also have a counter for the number of readers currently accessing the resource. If at any point in the program that counter goes from zero to one (in other words, at least one reader is starting to access the resource), we will lock the resource from the writers; similarly, whenever the counter decreases to zero (in other words, no reader is asking for access to the resource), we will release the lock on the resource so that writers can access it.</p>
			<p>This specification is efficient for the readers in the sense that once the first reader has accessed the resource and placed a lock on it, no writers can access it, and the subsequent readers will not have to re-lock it until the last reader finishes reading the resource.</p>
			<p>Let's try to implement this solution<a id="_idIndexMarker1033"/> in Python. If you have already downloaded the code for this book from the GitHub page, go ahead and navigate to the <strong class="source-inline">Chapter13</strong> folder. Let's take a look at the <strong class="source-inline">Chapter13/example1.py</strong> file – specifically, the <strong class="source-inline">writer()</strong> and <strong class="source-inline">reader()</strong> functions, as follows:</p>
			<p class="source-code">def writer():</p>
			<p class="source-code">    global text</p>
			<p class="source-code">    while True:</p>
			<p class="source-code">        with resource:</p>
			<p class="source-code">            print(f'Writing being done by \</p>
			<p class="source-code">                   {threading.current_thread().name}.')</p>
			<p class="source-code">            text += f'Writing was done by \</p>
			<p class="source-code">                    {threading.current_thread().name}. '</p>
			<p class="source-code">def reader():</p>
			<p class="source-code">    global rcount</p>
			<p class="source-code">    while True:</p>
			<p class="source-code">        with rcounter:</p>
			<p class="source-code">            rcount += 1</p>
			<p class="source-code">            if rcount == 1:</p>
			<p class="source-code">                resource.acquire()</p>
			<p class="source-code">        print(f'Reading being done by \</p>
			<p class="source-code">               {threading.current_thread().name}:')</p>
			<p class="source-code">        print(text)</p>
			<p class="source-code">        with rcounter:</p>
			<p class="source-code">            rcount -= 1</p>
			<p class="source-code">            if rcount == 0:</p>
			<p class="source-code">                resource.release()</p>
			<p>In the preceding script, the <strong class="source-inline">writer()</strong> function, which is to be called by a <strong class="source-inline">threading.Thread</strong> instance (in other words, a separate thread), specifies the logic of the writer threads that we discussed previously – accessing the shared resource (in this case, the global variable, <strong class="source-inline">text</strong>, which is simply a Python string) and writing some data to the resource. Note that<a id="_idIndexMarker1034"/> we are putting all of its instructions inside a <strong class="source-inline">while</strong> loop to simulate the constant nature of the application (writers and readers constantly trying to access the shared resource).</p>
			<p>We can also see the reader logic in the <strong class="source-inline">reader()</strong> function. Before asking for access to the shared resource, each reader will increment a counter for the number of readers that are currently active and trying to access the resource. Similarly, after reading data off the file, each reader needs to decrement the number of readers. During this process, if a reader is the first reader to access the file (in other words, when the counter is one), it will put a lock on the file so that no writers can access it; conversely, when a reader is the last reader to read the file, it has to release that lock.</p>
			<p>One note about the handling of that counter of readers – you might have noticed that we are using a lock object named <strong class="source-inline">rcounter</strong> when incrementing/decrementing the counter variable (<strong class="source-inline">rcount</strong>). This is a method that is used to avoid a race condition, which is another common concurrency-related problem, for the counter variable; specifically, without the lock, multiple threads can be accessing and altering the counter variable at the same time, but the only way to ensure the integrity of the data is for this counter variable to be handled sequentially. We will discuss race conditions (and the practice that is used to avoid them) in more detail in the next chapter.</p>
			<p>Going back to our current script – in the main program, we will set up the <strong class="source-inline">text</strong> variable, the counter for readers, and two lock objects (for the reader counter and the shared resource respectively). We are also initializing and starting three reader threads and two writer threads, as follows:</p>
			<p class="source-code">text = 'This is some text. '</p>
			<p class="source-code">rcount = 0</p>
			<p class="source-code">rcounter = threading.Lock()</p>
			<p class="source-code">resource = threading.Lock()</p>
			<p class="source-code">threads = [threading.Thread(target=reader) for i in \</p>
			<p class="source-code">  range(3)] + [ \</p>
			<p class="source-code">    threading.Thread(target=writer) for i in \</p>
			<p class="source-code">      range(2)]</p>
			<p class="source-code">for thread in threads:</p>
			<p class="source-code">    thread.start()</p>
			<p>It is important to note that, since the instructions of the reader and writer threads are both wrapped in <strong class="source-inline">while</strong> loops, the script, when started, will run infinitely. You should cancel the Python execution<a id="_idIndexMarker1035"/> after around 3–4 seconds, when enough output has been produced so that the general behavior of the program can be observed.</p>
			<p>The following code shows the first few lines of output that I obtained after running the script:</p>
			<p class="source-code">&gt; python3 example1.py</p>
			<p class="source-code">Reading being done by Thread-1:</p>
			<p class="source-code">This is some text. </p>
			<p class="source-code">Reading being done by Thread-2:</p>
			<p class="source-code">Reading being done by Thread-1:</p>
			<p class="source-code">This is some text. </p>
			<p class="source-code">This is some text. </p>
			<p class="source-code">Reading being done by Thread-2:</p>
			<p class="source-code">Reading being done by Thread-1:</p>
			<p class="source-code">This is some text. </p>
			<p class="source-code">This is some text. </p>
			<p class="source-code">Reading being done by Thread-3:</p>
			<p class="source-code">Reading being done by Thread-1:</p>
			<p class="source-code">This is some text. </p>
			<p class="source-code">This is some text. </p>
			<p class="source-code">...</p>
			<p>As you can see, there is a specific pattern in the preceding output – all of the threads that were accessing the shared resource were readers. In fact, throughout my entire output, no writer was able to access the file and, therefore, the <strong class="source-inline">text</strong> variable only contains the initial string, <strong class="source-inline">This is some text.</strong>, and was not altered in any way. The output that you obtain should also have the same pattern (the shared resource not being altered).</p>
			<p>In this case, the writers are experiencing starvation, as none of them are able to access and use the resource. This is a direct result of our scheduling algorithm; since multiple readers are allowed to access the text file simultaneously, if there are multiple readers accessing the text file frequently enough, it will create a continuous stream of readers going through the text file, leaving no room for a writer to attempt to access the file.</p>
			<p>This scheduling algorithm<a id="_idIndexMarker1036"/> inadvertently gives priority to the readers over the writers<a id="_idIndexMarker1037"/> and is therefore called <strong class="bold">reader preference</strong>. So, this design is undesirable.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor238"/>The second readers-writers problem</h2>
			<p>The problem with the first approach is that when a reader is accessing the text file and a writer is waiting for the file to<a id="_idIndexMarker1038"/> be unlocked, if another reader starts its execution and wants to access the file, it will be given priority over the writer that has already been waiting. Additionally, if more and more readers keep requesting access to the file, the writer will be waiting indefinitely, and that was what we observed in our first code example.</p>
			<p>To address this problem, we will implement the specification that once a writer makes a request to access the file, no reader should be able to jump in line and access the file before that writer. To do this, we will have an additional lock object in our program to specify whether a writer is waiting for the file and, consequently, whether a reader thread can attempt to read the file; we will call this lock <strong class="source-inline">read_try</strong>.</p>
			<p>Similar to how the first of the readers accessing the text file always locks it from the writers, we will now have the first of the multiple writers that are waiting to access the <strong class="source-inline">read_try</strong> file lock, so that no reader can, again, jump in line before those writers that requested access before it. As we discussed in reference to the readers, since we are keeping track of the number of writers waiting for the text file, we will need to implement a counter for the number of writers, and its corresponding lock, in our program.</p>
			<p>The <strong class="source-inline">Chapter13/example2.py</strong> file contains<a id="_idIndexMarker1039"/> the code for this implementation, as follows (note that the <strong class="source-inline">reader()</strong> function is being omitted in the text):</p>
			<p class="source-code">import threading</p>
			<p class="source-code">def writer():</p>
			<p class="source-code">    global text</p>
			<p class="source-code">    global wcount</p>
			<p class="source-code">    while True:</p>
			<p class="source-code">        with wcounter:</p>
			<p class="source-code">            wcount += 1</p>
			<p class="source-code">            if wcount == 1:</p>
			<p class="source-code">                read_try.acquire()</p>
			<p class="source-code">        with resource:</p>
			<p class="source-code">            print(f'Writing being done by \</p>
			<p class="source-code">                  {threading.current_thread().name}.')</p>
			<p class="source-code">            text += f'Writing was done by \</p>
			<p class="source-code">                  {threading.current_thread().name}. '</p>
			<p class="source-code">        with wcounter:</p>
			<p class="source-code">            wcount -= 1</p>
			<p class="source-code">            if wcount == 0:</p>
			<p class="source-code">                read_try.release()</p>
			<p class="source-code">def reader():</p>
			<p class="source-code">    ...</p>
			<p class="source-code">text = 'This is some text. '</p>
			<p class="source-code">wcount = 0</p>
			<p class="source-code">rcount = 0</p>
			<p class="source-code">wcounter = threading.Lock()</p>
			<p class="source-code">rcounter = threading.Lock()</p>
			<p class="source-code">resource = threading.Lock()</p>
			<p class="source-code">read_try = threading.Lock()</p>
			<p class="source-code">threads = [threading.Thread(target=reader) for i in \</p>
			<p class="source-code">  range(3)] + </p>
			<p class="source-code">    [threading.Thread(target=writer) for i in \</p>
			<p class="source-code">      range(2)]</p>
			<p class="source-code">for thread in threads:</p>
			<p class="source-code">    thread.start()</p>
			<p>Compared to our first solution to the problem, the main program remains relatively the same (except for the initialization of the <strong class="source-inline">read_try</strong> lock, the <strong class="source-inline">wcount</strong> counter, and its lock, <strong class="source-inline">wcounter</strong>), but in our <strong class="source-inline">writer()</strong> function, we are locking <strong class="source-inline">read_try</strong> as soon as there is at least one writer waiting to access the file; when the last writer finishes its execution, it will release the lock so that any reader waiting for the file can now access it.</p>
			<p>Again, to see the output produced<a id="_idIndexMarker1040"/> by the program, we will have it run for 3–4 seconds and then cancel the execution, as the program would otherwise run forever. The following is the output that I obtained via this script:</p>
			<p class="source-code">&gt; python3 example2.py</p>
			<p class="source-code">Reading being done by Thread-1:</p>
			<p class="source-code">This is some text. </p>
			<p class="source-code">Reading being done by Thread-1:</p>
			<p class="source-code">This is some text. </p>
			<p class="source-code">Writing being done by Thread-4.</p>
			<p class="source-code">Writing being done by Thread-5.</p>
			<p class="source-code">Writing being done by Thread-4.</p>
			<p class="source-code">Writing being done by Thread-4.</p>
			<p class="source-code">Writing being done by Thread-4.</p>
			<p class="source-code">Writing being done by Thread-5.</p>
			<p class="source-code">Writing being done by Thread-4.</p>
			<p class="source-code">...</p>
			<p>It can be observed that while some readers were able to access the text file (indicated by the first four lines of my output), once a writer gained access to the shared resource, no reader was able to access it anymore. The rest of my output included messages about writing instructions – <strong class="source-inline">Writing being done by</strong>, and so on. As opposed to what we saw in the first solution of the readers-writers problem, this solution is giving priority to writers, and, as a consequence, the readers<a id="_idIndexMarker1041"/> are starved. This is therefore called <strong class="bold">writer preference</strong>.</p>
			<p>The priority that writers were given over readers resulted from the fact that while only the first and the last writers have to acquire and release the <strong class="source-inline">read_try</strong> lock respectively, each reader wanting to access the text file has to interact with that lock object individually. Once <strong class="source-inline">read_try</strong> is locked by a writer, no reader can even attempt to execute its instructions, let alone try to access the text file.</p>
			<p>There are cases in which some readers are able to gain access to the text file if the readers are initialized and executed before the writers (for example, in our program, the readers were the first three elements, and the writers were the last two, in our list of threads). However, once a writer is able to access the file and acquire the <strong class="source-inline">read_try</strong> lock during its execution, starvation<a id="_idIndexMarker1042"/> will most likely occur for the readers.</p>
			<p>This solution is also not desirable, as it gives higher priority to the writer threads in our program.</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor239"/>The third readers-writers problem</h2>
			<p>You have seen that both<a id="_idIndexMarker1043"/> of the solutions that we tried to implement can result in starvation by not giving equal priorities to the separate threads; one can starve the writers, and the other can starve the readers. A balance between these two approaches might give us an implementation with equal priorities among the readers and writers, and, hence, solve the problem of starvation.</p>
			<p>Recall that – in our second approach, we placed a lock on a reader's attempt to access the text file, requiring that no writer would be starved once it started waiting for the file. In this solution, we will implement a lock that also utilizes this logic but is then applied to both readers and writers. All of the threads will then be subjected to the constraints of the lock, and equal priority will hence be achieved among the separate threads.</p>
			<p>Specifically, this is a lock that specifies<a id="_idIndexMarker1044"/> whether a thread will be given access to the text file at a given moment; we will call this the <strong class="bold">service lock</strong>. Each writer or reader has to try to acquire this service lock before executing any of its instructions. A writer, having obtained this service lock, will also attempt to obtain the resource lock and release the service lock immediately thereafter. The writer will then execute its writing logic and finally release the resource lock at the end of its execution.</p>
			<p>Let's take a look at the <strong class="source-inline">writer()</strong> function in the <strong class="source-inline">Chapter13/example3.py</strong> file for our implementation in Python, as follows:</p>
			<p class="source-code">def writer():</p>
			<p class="source-code">    global text</p>
			<p class="source-code">    while True:</p>
			<p class="source-code">        with service:</p>
			<p class="source-code">            resource.acquire()</p>
			<p class="source-code">        print(f'Writing being done by \</p>
			<p class="source-code">              {threading.current_thread().name}.')</p>
			<p class="source-code">        text += f'Writing was done by \</p>
			<p class="source-code">              {threading.current_thread().name}. '</p>
			<p class="source-code">        resource.release()</p>
			<p>On the other hand, a reader will also need to acquire the service lock first. Since we are still allowing multiple readers to access the resource at the same time, we are implementing the reader counter and its corresponding lock.</p>
			<p>The reader will acquire<a id="_idIndexMarker1045"/> the service lock and the counter lock, increment the reader counter (and, potentially, lock the resource), and then release the service lock and counter lock sequentially. Now, it will actually read data off the text file, and finally, it will decrement the reader counter and potentially release the resource lock if it is the last reader to access the file at that time.</p>
			<p>The <strong class="source-inline">reader()</strong> function contains the following specification:</p>
			<p class="source-code">def reader():</p>
			<p class="source-code">    global rcount</p>
			<p class="source-code">    while True:</p>
			<p class="source-code">        with service:</p>
			<p class="source-code">            rcounter.acquire()</p>
			<p class="source-code">            rcount += 1</p>
			<p class="source-code">            if rcount == 1:</p>
			<p class="source-code">                resource.acquire()</p>
			<p class="source-code">        rcounter.release()</p>
			<p class="source-code">        print(f'Reading being done by \</p>
			<p class="source-code">              {threading.current_thread().name}:')</p>
			<p class="source-code">        #print(text)</p>
			<p class="source-code">        with rcounter:</p>
			<p class="source-code">            rcount -= 1</p>
			<p class="source-code">            if rcount == 0:</p>
			<p class="source-code">                resource.release()</p>
			<p>Finally, in our main program, we initialize<a id="_idIndexMarker1046"/> the text string, the reader counter, all of the necessary locks, and the reader and writer threads, as follows:</p>
			<p class="source-code">text = 'This is some text. '</p>
			<p class="source-code">rcount = 0</p>
			<p class="source-code">rcounter = threading.Lock()</p>
			<p class="source-code">resource = threading.Lock()</p>
			<p class="source-code">service = threading.Lock()</p>
			<p class="source-code">threads = [threading.Thread(target=reader) for i in \</p>
			<p class="source-code">  range(3)] + [</p>
			<p class="source-code">    threading.Thread(target=writer) for i in range(2)]</p>
			<p class="source-code">for thread in threads:</p>
			<p class="source-code">    thread.start()</p>
			<p>Note that we are commenting the code that prints out the current content of the text file in the <strong class="source-inline">reader()</strong> function for readability for our output later on. Run the program for 3–4 seconds and then cancel it. The following<a id="_idIndexMarker1047"/> output is what I obtained on my personal computer:</p>
			<p class="source-code">&gt; python3 example3.py</p>
			<p class="source-code">Reading being done by Thread-3:</p>
			<p class="source-code">Writing being done by Thread-4.</p>
			<p class="source-code">Reading being done by Thread-1:</p>
			<p class="source-code">Writing being done by Thread-5.</p>
			<p class="source-code">Reading being done by Thread-2:</p>
			<p class="source-code">Reading being done by Thread-3:</p>
			<p class="source-code">Writing being done by Thread-4.</p>
			<p class="source-code">...</p>
			<p>The pattern that we have with this current output is that the readers and writers are able to access the shared resource cooperatively and efficiently; all of the readers and writers are executing their instructions, and no thread is being starved by this scheduling algorithm.</p>
			<p>Note that as you work with a readers-writers problem in your concurrent program, you do not have to reinvent the wheel regarding the approaches that we just discussed. PyPI actually has an external library called <strong class="source-inline">readerwriterlock</strong> that contains the implementation of the three approaches<a id="_idIndexMarker1048"/> in Python, as well as support for timeouts. Go to <a href="https://pypi.org/project/readerwriterlock/">https://pypi.org/project/readerwriterlock/</a> to find out more about the library and its documentation.</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor240"/>Solutions to starvation</h1>
			<p>Through an analysis of different approaches<a id="_idIndexMarker1049"/> to the readers-writers problem, you have seen the key to solving starvation – since some threads will be starved if they are not given a high priority in accessing the shared resources, implementing fairness in the execution of all of the threads will prevent starvation from occurring. Fairness, in this case, does not require a program to forgo any order or priority that it has imposed on the different threads; but to implement fairness, a program needs to ensure that all threads are given sufficient opportunities to execute their instructions.</p>
			<p>Keeping this idea in mind, we can potentially address the problem of starvation by implementing one (or a combination) of the following approaches:</p>
			<ul>
				<li><strong class="bold">Increasing the priority of low-priority threads</strong>: As we did with the writer threads in the second approach<a id="_idIndexMarker1050"/> and the reader threads in the third approach to the readers-writers problem, prioritizing the threads that would otherwise not have any opportunity to access the shared resource can successfully eliminate starvation.</li>
				<li><strong class="bold">First-in-first-out thread queue</strong>: To ensure that a thread that started waiting for the shared resource<a id="_idIndexMarker1051"/> before another thread will be able to acquire the resource before the other thread, we can keep track of the threads requesting access in a first-in-first-out queue.</li>
				<li><strong class="bold">Other methods</strong>: Several methods can also be implemented to balance the selection frequency of different threads – for example, a priority queue that also gives gradually increasing priority to threads that have been waiting in the queue for a long time, or if a thread has been able to access the shared resource many times, it will be given less priority.</li>
			</ul>
			<p>Solving starvation in your concurrent program can be a rather complex and involved process, and a deep understanding of its scheduling algorithm, combined with an understanding of how processes and threads interact with the shared resources, is necessary during the process. As you saw in the example of the readers-writers problem, it can also take several implementations<a id="_idIndexMarker1052"/> and revisions of different approaches to arrive at a good solution to starvation.</p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor241"/>Summary</h1>
			<p>In this chapter, we have covered starvation and the specific situations in which it could occur by analyzing different instances of the readers-writers problem. We have gained insight into how starvation can be solved with different scheduling algorithms – by making sure that the priority is distributed appropriately among different processes and threads, starvation can be eliminated. These discussions will serve as a guide to solutions to real-life instances of starvation.</p>
			<p>In the next chapter, we will discuss the last of the three common problems of concurrent programming – <strong class="bold">race conditions</strong>. We will cover the basic foundation and causes of race conditions, relevant concepts, and the connection of race conditions to other concurrency-related problems.</p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor242"/>Questions</h1>
			<ol>
				<li>What is starvation and why is it undesirable in a concurrent program?</li>
				<li>What are the underlying causes of starvation? What are the common high-level causes of starvation that can manifest from the underlying causes?</li>
				<li>What is the connection between deadlock and starvation?</li>
				<li>What is the readers-writers problem?</li>
				<li>What is the first approach to the readers-writers problem? Why does starvation arise in that situation?</li>
				<li>What is the second approach to the readers-writers problem? Why does starvation arise in that situation?</li>
				<li>What is the third approach to the readers-writers problem? Why does it successfully address starvation?</li>
				<li>What are some common solutions to starvation?</li>
			</ol>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor243"/>Further reading</h1>
			<ul>
				<li><em class="italic">Parallel Programming with Python</em>, <em class="italic">Jan Palach</em>, <em class="italic">Packt Publishing Ltd</em>, <em class="italic">2014</em></li>
				<li><em class="italic">Python Parallel Programming Cookbook</em>, <em class="italic">Giancarlo Zaccone</em>, <em class="italic">Packt Publishing Ltd</em>, <em class="italic">2015</em></li>
				<li><em class="italic">Starvation and Fairness</em>, <em class="italic">Jakob Jenkov</em> (<a href="http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness">tutorials.jenkov.com/java-concurrency/starvation-and-fairness</a>)</li>
				<li><em class="italic">Faster Fair Solution for the Reader-Writer Problem</em>, <em class="italic">V. Popov and O. Mazonka</em></li>
			</ul>
		</div>
	</div>
</div>
</body></html>