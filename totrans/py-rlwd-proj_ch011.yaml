- en: Chapter 7
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: Data Inspection Features
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据检查功能
- en: 'There are three broad kinds of data domains: cardinal, ordinal, and nominal.
    The first project in this chapter will guide you through the inspection of cardinal
    data; values like weights, measures, and durations where the data is continuous,
    as well as counts where the data is discrete. The second project will guide reasoners
    through the inspection of ordinal data involving things like dates, where order
    matters, but the data isn’t a proper measurement; it’s more of a code or designator.
    The nominal data is a code that happens to use digits but doesn’t represent numeric
    values. The third project will cover the more complex case of matching keys between
    separate data sources.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据域大致分为三种类型：基数、顺序和名义。本章的第一个项目将指导您检查基数数据；这些数据值如重量、测量和持续时间是连续的，以及计数数据是离散的。第二个项目将指导推理者检查涉及日期等内容的顺序数据，其中顺序很重要，但数据不是正确的测量；它更像是一个代码或标识符。名义数据是一个使用数字的代码，但不代表数值。第三个项目将涵盖在单独的数据源之间匹配键的更复杂情况。
- en: An inspection notebook is required when looking at new data. It’s a great place
    to keep notes and lessons learned. It’s helpful when diagnosing problems that
    arise in a more mature analysis pipeline.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看新数据时需要一份检查笔记本。这是一个记录笔记和所学知识的好地方。在诊断更成熟的分析流程中出现的问题时，它非常有帮助。
- en: 'This chapter will cover a number of skills related to data inspection techniques:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖与数据检查技术相关的一系列技能：
- en: Essential notebook data inspection features using Python expressions, extended
    from the previous chapter.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python表达式进行的基本笔记本数据检查功能，这些功能是从上一章扩展而来的。
- en: The `statistics` module for examining cardinal data.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于检查基数数据的`statistics`模块。
- en: The `collections.Counter` class for examining ordinal and nominal data.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于检查顺序和名义数据的`collections.Counter`类。
- en: Some additional `collections.Counter` for matching primary and foreign keys.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些额外的`collections.Counter`用于匹配主键和外键。
- en: For the Ancombe’s Quartet example data set used in *Chapters 3*, *4*, and *5*,
    both of the attribute values are cardinal data. It’s a helpful data set for some
    of the inspections, but we’ll need to look at some other data sets for later projects
    in this chapter. We’ll start by looking at some inspection techniques for cardinal
    data. Readers who are focused on other data sets will need to discern which attributes
    represent cardinal data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在*第3章*、*第4章*和*第5章*中使用的Ancombe的四重奏示例数据集，两个属性值都是基数数据。这是一个对某些检查有帮助的数据集，但我们需要查看本章后面项目中的其他数据集。我们将首先查看一些用于基数数据的检查技术。专注于其他数据集的读者需要辨别哪些属性代表基数数据。
- en: '7.1 Project 2.2: Validating cardinal domains — measures, counts, and durations'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1 项目2.2：验证基数域——测量、计数和持续时间
- en: A great deal of data is cardinal in nature. Cardinal numbers are used to count
    things, like elements of a set. The concept can be generalized to include real
    numbers representing a weight or a measure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的数据在本质上都是基数。基数用于计数，例如集合的元素。这个概念可以推广到包括表示重量或测量的实数。
- en: 'A very interesting data set is available here: [https://www.kaggle.com/datasets/rtatman/iris-dataset-json-version](https://www.kaggle.com/datasets/rtatman/iris-dataset-json-version).
    This contains samples with numerous measurements of the pistils and stamen of
    different species of flowers. The measurements are identifiable because the unit,
    mm, is provided.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里可以找到一个非常有趣的数据集：[https://www.kaggle.com/datasets/rtatman/iris-dataset-json-version](https://www.kaggle.com/datasets/rtatman/iris-dataset-json-version)。这个数据集包含了不同物种的花瓣和雄蕊的多次测量样本。由于提供了单位mm，这些测量是可以识别的。
- en: 'Another interesting data set is available here: [https://datahub.io/core/co2-ppm](https://datahub.io/core/co2-ppm).
    This contains data with measurements of CO2 levels measured with units of ppm,
    parts per million.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的数据集在这里可以找到：[https://datahub.io/core/co2-ppm](https://datahub.io/core/co2-ppm)。这个数据集包含了以ppm（百万分之一）为单位测量的二氧化碳水平数据。
- en: 'We need to distinguish counts and measures from numbers that are only used
    to rank or order things, which are called ordinal numbers. Also, number-like data
    is sometimes only a code. US postal codes, for example, are merely strings of
    digits; they aren’t proper numeric values. We’ll look at these numeric values
    in [*Project 2.3: Validating text and codes — nominal data and ordinal* *numbers*](#x1-1710002).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要区分计数和度量与仅用于对事物进行排序或排列的数字，这些数字被称为序数。此外，类似数字的数据有时只是一个代码。例如，美国邮政编码只是一串数字；它们不是正确的数值。我们将在[*项目2.3：验证文本和代码——名义数据和序数*](#x1-1710002)中查看这些数值。
- en: Since this is an inspection notebook, the primary purpose is only to understand
    the range of values for cardinal data. A deeper analysis will come later. For
    now, we want a notebook that demonstrates the data is complete and consistent,
    and can be used for further processing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个检查笔记本，主要目的是仅了解基数数据的值范围。更深入的分析将在以后进行。目前，我们想要一个笔记本来证明数据是完整和一致的，并且可以用于进一步处理。
- en: In the event an enterprise is using data contracts, this notebook will demonstrate
    compliance with the data contract. With data contracts, the focus may shift slightly
    from showing “some data that is not usable” to showing “data found to be non-compliant
    with the contract.” In cases where the contract is inadequate for the analytical
    consumer, the notebook may shift further to show “compliant data that’s not useful.”
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个企业正在使用数据合同，这个笔记本将演示符合数据合同的情况。使用数据合同时，重点可能略微从显示“一些不可用的数据”转移到显示“发现不符合合同的数据。”在合同对于分析消费者来说不足够的情况下，笔记本可能进一步转向显示“有用但符合的数据。”
- en: We’ll start with a description of the kinds of cells to add to an inspection
    notebook. After that, we’ll about the architectural approach and wrap up with
    a detailed list of deliverables.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从描述要添加到检查笔记本中的单元格类型开始。然后，我们将讨论架构方法，并以详细的交付成果列表结束。
- en: 7.1.1 Description
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 描述
- en: This project’s intent is to inspect raw data to understand if it is actually
    cardinal data. In some cases, floating-point values may have been used to represent
    nominal data; the data appears to be a measurement but is actually a code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的目的是检查原始数据，以了解它是否实际上是基数数据。在某些情况下，可能使用了浮点值来表示名义数据；数据看起来像是一种度量，但实际上是一个代码。
- en: Spreadsheet software tends to transform all data into floating-point numbers;
    many data items may look like cardinal data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 电子表格软件倾向于将所有数据转换为浮点数；许多数据项可能看起来像基数数据。
- en: One example is US Postal Codes, which are strings of digits, but may be transformed
    into numeric values by a spreadsheet.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是美国邮政编码，它们是一串数字，但可以通过电子表格转换为数值。
- en: Another example is bank account numbers, which — while very long — can be converted
    into floating-point numbers. A floating-point value uses 8 bytes of storage, but
    will comfortably represent about 15 decimal digits. While this is a net saving
    in storage, it is a potential confusion of data types and there is a (small) possibility
    of having an account number altered by floating-point truncation rules.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是银行账户号码，虽然非常长，但可以转换为浮点数。浮点值使用8个字节的存储空间，但可以舒适地表示大约15位十进制数字。虽然这节省了存储空间，但可能会混淆数据类型，并且存在（小的）账户号码被浮点截断规则更改的可能性。
- en: The user experience is a Jupyter Lab notebook that can be used to examine the
    data, show some essential features of the raw data values, and confirm that the
    data really does appear to be cardinal.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用户体验是一个Jupyter Lab笔记本，可以用来检查数据，展示原始数据值的一些基本特征，并确认数据确实看起来是基数数据。
- en: 'There are several common sub-varieties of cardinal data:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 基数数据有几种常见的子类型：
- en: Counts; represented by integer values.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数；由整数值表示。
- en: Currency and other money-related values. These are often decimal values, and
    the `float` type is likely to be a bad idea.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 货币和其他与金钱相关的值。这些通常是十进制值，而`float`类型可能不是一个好主意。
- en: Duration values. These are often measured in days, hours, and minutes, but represent
    a time interval or a “delta” applied to a point in time. These can be normalized
    to seconds or days and represented by a float value.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续时间值。这些通常以天、小时和分钟来衡量，但代表一个时间间隔或对时间点应用的“增量”。这些可以归一化为秒或天，并以浮点值表示。
- en: More general measures are not in any of the previous categories. These are often
    represented by floating-point values.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更通用的度量标准不属于之前的任何类别。这些通常用浮点数表示。
- en: What’s important for this project is to have an overview of the data. Later
    projects will look at cleaning and converting the data for further use. This notebook
    is only designed to preview and inspect the data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目来说，重要的是要有一个数据的概览。后续的项目将查看清理和转换数据以供进一步使用。这个笔记本仅设计用于预览和检查数据。
- en: We’ll look at general measures first since the principles apply to counts and
    durations. Currency, as well as duration, values are a bit more complicated and
    we’ll look at them separately. Date-time stamps are something we’ll look at in
    the next project since they’re often thought of as ordinal data, not cardinal.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查看一般度量，因为原则适用于计数和持续时间。货币以及持续时间值要复杂一些，我们将单独查看它们。日期时间戳将在下一个项目中查看，因为它们通常被认为是序数数据，而不是基数数据。
- en: 7.1.2 Approach
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 方法
- en: 'This project is based on the initial inspection notebook from [*Chapter** 6*](ch010.xhtml#x1-1460006),
    [*Project* *2.1: Data Inspection Notebook*](ch010.xhtml#x1-1460006). Some of the
    essential cell content will be reused in this notebook. We’ll add components to
    the components shown in the earlier chapter – specifically, the `samples_iter()`
    function to iterate over samples in an open file. This feature will be central
    to working with the raw data.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目基于初始检查笔记本，来自[*第6章*](ch010.xhtml#x1-1460006)，[*项目2.1：数据检查笔记本*](ch010.xhtml#x1-1460006)。笔记本中的一些基本单元格内容将被重用。我们将向早期章节中显示的组件添加组件——特别是，`samples_iter()`
    函数，用于遍历打开文件中的样本。这个特性将是处理原始数据的核心。
- en: In the previous chapter, we suggested avoiding conversion functions. When starting
    down the path of inspecting data, it’s best to assume nothing and look at the
    text values first.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们建议避免使用转换函数。在开始检查数据的过程中，最好是先不预设任何假设，先查看文本值。
- en: 'There are some common patterns in the source data values:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 源数据值中存在一些常见模式：
- en: 'The values appear to be all numeric values. The `int()` or `float()` function
    works on all of the values. There are two sub-cases here:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值看起来都是数值。`int()` 或 `float()` 函数适用于所有值。这里有两个子情况：
- en: All of the values seem to be proper counts or measures in some expected range.
    This is ideal.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有值似乎都是一些预期的范围内的适当计数或度量。这是理想的。
- en: A few “outlier” values are present. These are values that seem to be outside
    the expected range of values.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一些“异常”值。这些值似乎超出了预期值范围。
- en: Some of the values are not valid numbers. They may be empty strings, or a code
    line “NULL”, “None”, or “N/A”.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些值不是有效数字。它们可能是空字符串，或者是一条代码行“NULL”，“None”，或“N/A”。
- en: Numeric outlier values can be measurement errors or an interesting phenomenon
    buried in the data. Outlier values can also be numeric code values indicating
    a known missing or otherwise unusable value for a sample. In the example of the
    CO2 data, there are outlier values of −99*.*99 parts per million, which encode
    a specific kind of missing data situation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 数值异常值可能是测量错误，也可能是数据中隐藏的有趣现象。异常值也可能是表示样本已知缺失或不可用值的数值代码。在二氧化碳数据的例子中，存在异常值 -99.*.*99
    百分之一，这些值编码了特定种类的缺失数据情况。
- en: Many data sets will be accompanied by metadata to explain the domain of values,
    including non-numeric values, as well as the numeric codes in use. Some enterprise
    data sources will not have complete or carefully explained metadata. This means
    an analyst needs to ask questions to locate the root cause for non-numeric values
    or special codes that appear in cardinal data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据集将伴随元数据来解释值域，包括非数值值，以及正在使用的数值代码。一些企业数据源可能没有完整或详细解释的元数据。这意味着分析师需要提问以找到非数值值或特殊代码在基数数据中出现的根本原因。
- en: 'The first question — *are all the values numeric?* — can be handled with code
    like the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题——*所有值都是数值吗？*——可以用以下代码处理：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The idea is to apply a conversion function, commonly `int()` or `float()`, but
    `decimal.Decimal()` may be useful for currency data or other data with a fixed
    number of decimal places. If the conversion function fails, the exceptional data
    is preserved in a mapping showing the counts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是应用转换函数，通常是 `int()` 或 `float()`，但对于货币数据或其他具有固定小数位数的其他数据，`decimal.Decimal()`
    可能很有用。如果转换函数失败，异常数据将保存在显示计数的映射中。
- en: 'You’re encouraged to try this with a sequence of strings like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励您尝试以下字符串序列：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This kind of test case will let you see how this function works with good (and
    bad) data. It can help to transform the test case into a docstring, and include
    it in the function definition.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试用例将让您看到该函数如何与良好（和不良）的数据一起工作。它可以帮助将测试用例转换为文档字符串，并将其包含在函数定义中。
- en: If the result of the `non_numeric()` function is an empty dictionary, then the
    lack of non-numeric data means all of the data is numeric.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `non_numeric()` 函数的结果是一个空字典，那么非数值数据的缺失意味着所有数据都是数值的。
- en: The test function is provided first to follow the pattern of higher-order functions
    like `map()` and `filter()`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 测试函数首先提供，以遵循像 `map()` 和 `filter()` 这样的高阶函数的模式。
- en: 'A variation on this function can be used as a numeric filter to pass the numeric
    values and reject the non-numeric values. This would look like the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的变体可以用作数值过滤器，以通过数值值并拒绝非数值值。这看起来如下：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function will silently reject the values that cannot be converted. The
    net effect of omitting the data is to create a NULL that does not participate
    in further computations. An alternative may be to replace invalid values with
    default values. An even more complicated choice is to interpolate a replacement
    value using adjacent values. Omitting samples may have a significant impact on
    the statistical measures used in later stages of processing. This `numeric_filter()`
    function permits the use of other statistical functions to locate outliers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将静默拒绝无法转换的值。省略数据的效果是创建一个不参与进一步计算的NULL。另一种选择是将无效值替换为默认值。更复杂的选择是使用相邻值插值替换值。省略样本可能对后续处理阶段使用的统计度量有重大影响。此
    `numeric_filter()` 函数允许使用其他统计函数来定位异常值。
- en: For data with good documentation or a data contract, outlier values like −99*.*99
    are easy to spot. For data without good documentation, a statistical test might
    be more appropriate. See [https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm](https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm)
    for details on approaches to locating outliers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有良好文档或数据合同的数据，像-99.*99这样的异常值很容易被发现。对于没有良好文档的数据，可能更适合进行统计测试。有关定位异常值的方法的详细信息，请参阅
    [https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm](https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm)。
- en: One approach suitable for small data sets is to use a median-based Z-score.
    We’ll dive into an algorithm that is built on a number of common statistical measures.
    This will involve computing the median using a function available in the built-in
    `statistics` package.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小数据集，一种合适的方法是使用基于中值的Z分数。我们将深入研究一个基于许多常见统计测量的算法。这将涉及使用内置 `statistics` 包中的函数计算中位数。
- en: For more information on basic statistics for data analytics, see *Statistics
    for Data* *Science*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据分析的基本统计信息，请参阅 *Statistics for Data *Science*。
- en: '[https://www.packtpub.com/product/statistics-for-data-science/9781788290678](https://www.packtpub.com/product/statistics-for-data-science/9781788290678).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/product/statistics-for-data-science/9781788290678](https://www.packtpub.com/product/statistics-for-data-science/9781788290678)。'
- en: The conventional Z-score for a sample, *Z*[i], is based on the mean, *Ȳ*, and
    the standard deviation, *σ*[Y] . It’s computed as *Z*[i] = ![Yi−Y¯- σY](img/file33.jpg).
    It measures how many standard deviations a value lies from the mean. Parallel
    with this is the idea of a median-based Z-score, *M*[i]. The median-based Z-score
    uses the median, *Ỹ*, and the median absolute deviation, MAD[Y] .
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 样本的常规Z分数，*Z*[i]，基于均值，*Ȳ*，和标准差，*σ*[Y]。它被计算为 *Z*[i] = ![Yi−Y¯- σY](img/file33.jpg)。它衡量一个值与均值的距离有多少个标准差。与此并行的是基于中值的Z分数的概念，*M*[i]。基于中值的Z分数使用中值，*Ỹ*，和中值绝对偏差，MAD[Y]。
- en: This is computed as *M*[i] = ![-Yi−Y˜- MADY](img/file34.jpg). This measures
    how many “MAD” units a value lies from the median of the samples.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这被计算为 *M*[i] = ![-Yi−Y˜- MADY](img/file34.jpg)。这衡量一个值与样本中位数的距离有多少个“MAD”单位。
- en: The MAD is the median of the absolute values of deviations from the median.
    It requires computing an overall median, *Ỹ*, then computing all the deviations
    from the overall median, *Y* [i] −*Ỹ*. From this sequence of deviations from the
    median, the median value is selected to locate a central value for all of the
    median absolute deviations. This is computed as MAD[Y] = median(|*Y* [i] −*Ỹ*|).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: MAD是中位数与中位数偏差的绝对值的均值。它需要计算一个整体中位数，*Ỹ*，然后计算所有与整体中位数，*Y* [i] −*Ỹ*的偏差。从这个中位数偏差的序列中，选择中值值以确定所有中值绝对偏差的中心值。这被计算为
    MAD[Y] = median(|*Y* [i] −*Ỹ*|)。
- en: The filter based on *M*[i] looks for any absolute value of the deviation from
    MAD[Y] that’s greater than 3*.*5, |*M*[i]| *>* 3*.*5\. These samples are possible
    outliers because their absolute deviation from the median is suspiciously large.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 基于乘数**M**[i]的过滤器寻找任何从MAD[Y]的偏差绝对值大于3.*5的样本，|*M*[i]| *>* 3.*5\. 这些样本可能是异常值，因为它们与中位数之间的绝对偏差异常大。
- en: 'To be complete, here’s a cell to read the source data:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整，这里有一个读取源数据的单元格：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This can be followed with a cell to compute the median and the median absolute
    deviation. The median computation can be done with the `statistics` module. The
    deviations can then be computed with a generator, and the median absolute deviation
    computed from the generator. The cell looks like the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以接着是一个计算中位数和中位数绝对偏差的单元格。中位数计算可以使用`statistics`模块完成。然后可以使用生成器计算偏差，从中计算中位数绝对偏差。单元格看起来如下：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The value of `y_text` is a generator that will extract the values mapped to
    the `’y’` key in each of the raw data samples in the NDJSON file. From these text
    values, the value of `y` is computed by applying the `numeric_filter()` function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`y_text`的值是一个生成器，它将从NDJSON文件中每个原始数据样本中映射到`’y’`键的值中提取值。从这些文本值中，通过应用`numeric_filter()`函数计算`y`的值。'
- en: It’s sometimes helpful to show that `len(y)`` ==`` len(y_text)` to demonstrate
    that all values are numeric. In some data sets, the presence of non-numeric data
    might be a warning that there are deeper problems.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时显示`len(y)`` ==`` len(y_text)`有助于证明所有值都是数值的。在某些数据集中，非数值数据的存在可能是一个警告，表明存在更深层次的问题。
- en: The value of `m_y` is the median of the `y` values. This is used to compute
    the MAD value as the median of the absolute deviations from the median. This median
    absolute deviation provides an expected range around the median.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_y`的值是`y`值的中位数。这用于计算MAD值，即从中位数到绝对偏差的中位数。这个中位数绝对偏差提供了一个围绕中位数的预期范围。'
- en: The `outliers_y` computation uses a generator expression to compute the median-based
    Z-score, and then keep only those scores that are more than 3.5 MADs from the
    median.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`outliers_y`的计算使用生成器表达式来计算基于中位数的Z分数，然后只保留那些与中位数超过3.5个MAD的分数。'
- en: The data in Series IV of Anscombe’s Quartet seems to suffer from an even more
    complicated outlier problem. While the ”x” attribute has a potential outlier,
    the ”y” attribute’s MAD is zero. This means more than half the ”y” attribute values
    are the same. This single value is the median, and the difference from the median
    will be zero for most of the samples.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 安斯康姆四重奏的第四系列数据似乎遭受了一个更复杂的异常值问题。虽然“x”属性有一个潜在的异常值，但“y”属性的MAD为零。这意味着超过一半的“y”属性值是相同的。这个单一值就是中位数，对于大多数样本，与中位数之间的差异将为零。
- en: This anomaly would become an interesting part of the notebook.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异常将成为笔记本中一个有趣的部分。
- en: Dealing with currency and related values
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理货币和相关值
- en: Most currencies around the world use a fixed number of decimal places. The United
    States, for example, uses exactly two decimal places for money. These are decimal
    values; the `float` type is almost always the wrong type for these values.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上的大多数货币都使用固定的小数位数。例如，美国货币精确到两位小数。这些是十进制值；对于这些值，`float`类型几乎总是错误的数据类型。
- en: Python has a `decimal` module with a `Decimal` type, which must be used for
    currency.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个`decimal`模块，其中包含`Decimal`类型，必须用于货币。
- en: Do not use `float` for currency or anything used in currency-related computations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用`float`来处理货币或任何与货币相关的计算。
- en: Tax rates, discount rates, interest rates, and other money-related fields are
    also decimal values. They’re often used with currency values, and computations
    must be done using decimal arithmetic rules.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 税率、折扣率、利率和其他与金钱相关的字段也是十进制值。它们通常与货币值一起使用，计算必须使用十进制算术规则进行。
- en: When we multiply `Decimal` values together, the results may have additional
    digits to the right of the decimal place. This requires applying rounding rules
    to determine how to round or truncate the extra digits. The rules are essential
    to getting the correct results. The `float` type `round()` function may not do
    this properly. The `decimal` module includes a wide variety of rounding and truncating
    algorithms.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`Decimal`值相乘时，结果可能在小数点右边有额外的数字。这需要应用舍入规则来确定如何舍入或截断额外的数字。这些规则对于获得正确的结果至关重要。`float`类型的`round()`函数可能无法正确执行此操作。`decimal`模块包含各种舍入和截断算法。
- en: Consider an item with a price of $12.99 in a locale that charges a sales tax
    of 6.25% on each purchase. This is not a tax amount of $0.811875\. The tax amount
    must be rounded; there are many, many rounding rules in common use by accountants.
    It’s essential to know which rule is required to compute the correct result.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个价格为$12.99的商品，在一个对每次购买征收6.25%销售税的地区。这并不是$0.811875的税款金额。税款金额必须四舍五入；会计师们普遍使用许多四舍五入规则。了解需要哪种规则来计算正确的结果是至关重要的。
- en: Because the underlying assumption behind currency is decimal computation, the
    `float` should never be used for currency amounts.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于货币背后的基本假设是十进制计算，因此`float`不应用于货币金额。
- en: This can be a problem when spreadsheet data is involved. Spreadsheet software
    generally uses `float` values with complex formatting rules to produce correct-looking
    answers. This can lead to odd-looking values in a CSV extract like 12*.*999999997
    for an attribute that should have currency values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及电子表格数据时，这可能会成为一个问题。电子表格软件通常使用具有复杂格式规则的`float`值来生成看起来正确的答案。这可能导致CSV提取中看起来奇怪的值，例如，对于应该有货币值的属性，值为12*.*999999997。
- en: Additionally, currency may be decorated with currency symbols like $, £, or
    €. There may also be separator characters thrown in, depending on the locale.
    For the US locale, this can mean stray ”,” characters may be present in large
    numbers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，货币可能带有货币符号，如$、£或€。根据地区，还可能有分隔符字符。对于美国地区，这可能意味着在大数字中可能存在多余的”,”字符。
- en: The ways currency values may have text decoration suggest the conversion function
    used by a `non_numeric()` or `numeric_filter()` function will have to be somewhat
    more sophisticated than the simple use of the `Decimal` class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 货币值可能有的文本装饰表明，`non_numeric()`或`numeric_filter()`函数使用的转换函数将必须比简单使用`Decimal`类更为复杂。
- en: Because of these kinds of anomalies, data inspection is a critical step in data
    acquisition and analysis.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些异常，数据检查是数据获取和分析中的关键步骤。
- en: Dealing with intervals or durations
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理区间或持续时间
- en: Some date will include duration data in the form `"12:34"`, meaning 12 hours
    and 34 minutes. This looks exactly like a time of day. In some cases, it might
    have the form `12h`` 34m`, which is a bit easier to parse. Without metadata to
    explain if an attribute is a duration or a time of day, this may be impossible
    to understand.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一些日期将包括以`"12:34"`形式表示的持续时间数据，这意味着12小时和34分钟。这看起来就像一天中的某个时间点。在某些情况下，它可能具有`12h
    34m`的形式，这更容易解析。如果没有元数据来解释属性是持续时间还是一天中的某个时间点，这可能是无法理解的。
- en: For durations, it’s helpful to represent the values as a single, common time
    unit. Seconds are a popular choice. Days are another common choice.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于持续时间，将值表示为单个、通用的时间单位很有帮助。秒是一个流行的选择。天也是一个常见的选择。
- en: 'We can create a cell with a given string, for example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个带有给定字符串的单元格，例如：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Given this string, we can create a cell to compute the duration in seconds
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个字符串，我们可以创建一个单元格来计算秒数，如下所示：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will compute a duration, `sec`, of 45,240 seconds from the source time
    as text, `time_text`. The final expression `sec` in a Jupyter notebook cell will
    display this variable’s value to confirm the computation worked. This cardinal
    value computation works out elegantly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从源文本`time_text`计算出一个持续时间为45,240秒的`sec`。Jupyter笔记本单元格中的最终表达式`sec`将显示此变量的值，以确认计算工作正常。这种基数值计算非常优雅。
- en: For formatting purposes, the inverse computation can be helpful. A floating-point
    value like 45,240 can be converted back into a sequence of integers, like (12,
    34, 0), which can be formatted as ”12:34” or ”12h 34m 0s”.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于格式化目的，逆计算可能很有帮助。一个浮点值如45,240可以转换回一个整数序列，如(12, 34, 0)，这可以格式化为”12:34”或”12h 34m
    0s”。
- en: 'It might look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能看起来像这样：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will produce the string `12:34` from the value of seconds given in the
    `sec` variable. The final expression `text` in a cell will display the computed
    value to help confirm the cell works.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从`sec`变量给出的秒数生成字符串`12:34`。单元格中的最终表达式`text`将显示计算值，以帮助确认单元格工作正常。
- en: It’s important to normalize duration strings and complex-looking times into
    a single float value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将持续时间字符串和看起来复杂的时态归一化到单个浮点值是很重要的。
- en: Now that we’ve looked at some of the tricky cardinal data fields, we can look
    at the notebook as a whole. In the next section, we’ll look at refactoring the
    notebook to create a useful module.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了一些棘手的基数数据字段，我们可以从整体上查看笔记本。在下一节中，我们将查看重构笔记本以创建一个有用的模块。
- en: Extract notebook functions
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提取笔记本函数
- en: 'The computation of ordinary Z-scores and median-based Z-scores are similar
    in several ways. Here are some common features we might want to extract:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 普通Z分数和基于中位数的Z分数的计算在几个方面是相似的。以下是一些我们可能想要提取的常见特征：
- en: Extracting the center and variance. This might be the mean and standard deviation,
    using the `statistics` module. Or it might be the median and MAD.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取中心和方差。这可能是指使用`statistics`模块的均值和标准差，或者可能是中位数和MAD。
- en: Creating a function to compute Z-scores from the mean or median.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个函数，从平均值或中位数计算Z分数。
- en: Applying the `filter()` function to locate outliers.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用`filter()`函数定位异常值。
- en: When looking at data with a large number of attributes, or looking at a large
    number of related data sets, it’s helpful to write these functions first in the
    notebook. Once they’ve been debugged, they can be cut from the notebook and collected
    into a separate module. The notebook can then be modified to import the functions,
    making it easier to reuse these functions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看具有大量属性的数据或查看大量相关数据集时，首先在笔记本中编写这些函数是有帮助的。一旦调试完成，它们可以从笔记本中剪切出来并收集到一个单独的模块中。然后可以修改笔记本以导入这些函数，使其更容易重用这些函数。
- en: 'Because the source data is pushed into a dictionary with string keys, it becomes
    possible to consider functions that work across a sequence of key values. We might
    have cells that look like the following example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于源数据被推入一个具有字符串键的字典中，因此可以考虑在一系列键值上工作的函数。我们可能有如下示例的单元格：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will analyze all of the columns named in the surrounding `for` statement.
    In this example, the x and y column names are provided as the collection of columns
    to analyze. The result is a small table of values with the column name, the raw
    data size, the filtered data size, and the median of the filtered data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将分析周围`for`语句中命名的所有列。在这个例子中，x和y列名被提供为要分析的列的集合。结果是包含列名、原始数据大小、过滤数据大小和过滤数据中位数的值的小表。
- en: 'The idea of a collection of descriptive statistics suggests a class to hold
    these. We might add the following dataclass:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 描述性统计集合的想法暗示了一个类来保存这些。我们可能添加以下数据类：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The class definition includes a class method to build instances of this class
    from a collection of raw values. Putting the instance builder into the class definition
    makes it slightly easier to add additional inspection attributes and the functions
    needed to compute those attributes. A function that builds `AttrSummary` instances
    can be used to summarize the attributes of a data set. This function might look
    like the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义包括一个类方法，用于从一组原始值构建该类的实例。将实例构建器放入类定义中使得添加额外的检查属性及其计算这些属性所需的函数稍微容易一些。一个构建`AttrSummary`实例的函数可以用来总结数据集的属性。此函数可能看起来如下：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This kind of function makes it possible to reuse inspection code for a number
    of attributes in a complicated data set. After looking at the suggested technical
    approach, we’ll turn to the deliverables for this project.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的函数使得在复杂数据集中重用多个属性的检查代码成为可能。在查看建议的技术方法后，我们将转向本项目的交付成果。
- en: 7.1.3 Deliverables
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 交付成果
- en: 'This project has the following deliverables:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目有以下交付成果：
- en: A `requirements-dev.txt` file that identifies the tools used, usually `jupyterlab==3.5.3`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`requirements-dev.txt`文件，用于标识使用的工具，通常是`jupyterlab==3.5.3`。
- en: Documentation in the `docs` folder.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docs`文件夹中的文档。'
- en: Unit tests for any new changes to the modules in use.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对使用中的模块的任何新更改进行单元测试。
- en: Any new application modules with code to be used by the inspection notebook.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何新的应用模块，其中包含用于检查笔记本的代码。
- en: A notebook to inspect the attributes that appear to have cardinal data.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于检查似乎具有基数数据的属性的笔记本。
- en: This project will require a `notebooks` directory. See [*List of deliverables*](ch005.xhtml#x1-260003)
    for some more information on this structure.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目需要一个`notebooks`目录。参见[*交付成果列表*](ch005.xhtml#x1-260003)以获取有关此结构的更多信息。
- en: We’ll look at a few of these deliverables in a little more detail.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更详细地查看其中的一些交付成果。
- en: Inspection module
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查模块
- en: You are encouraged to refactor functions like `samples_iter()`, `non_numeric()`,
    and `numeric_filter()` into a separate module. Additionally, the `AttrSummary`
    class and the closely related `summary_iter()` function are also good candidates
    for being moved to a separate module with useful inspection classes and functions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励将 `samples_iter()`、`non_numeric()` 和 `numeric_filter()` 等函数重构为单独的模块。此外，`AttrSummary`
    类和与之密切相关的 `summary_iter()` 函数也是移动到包含有用的检查类和函数的单独模块的好候选。
- en: Notebooks can be refactored to import these classes and functions from a separate
    module.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本可以被重构以从单独的模块导入这些类和函数。
- en: It’s easiest to throw this module into the `notebooks` folder to make it easier
    to access. An alternative is to include the `src` directory on the `PYTHONPATH`
    environment variable, making it available to the Jupyter Lab session.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将此模块放入 `notebooks` 文件夹中以便更容易访问是最简单的方法。另一种选择是将 `src` 目录包含在 `PYTHONPATH` 环境变量中，使其在
    Jupyter Lab 会话中可用。
- en: Another alternative is to create an IPython profile with the `ipython`` profile`` create`
    command at the terminal prompt. This will create a `~/.ipython/profile_default`
    directory with the default configuration files in it. Adding a `startup` folder
    permits including scripts that will add the `src` directory to the `sys.path`
    list of places to look for modules.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是在终端提示符下使用 `ipython profile create` 命令创建一个 IPython 配置文件。这将创建一个包含默认配置文件的
    `~/.ipython/profile_default` 目录。添加一个 `startup` 文件夹允许包括将 `src` 目录添加到 `sys.path`
    列表中的脚本，以便查找模块。
- en: See [https://ipython.readthedocs.io/en/stable/interactive/tutorial.html#startup-files](https://ipython.readthedocs.io/en/stable/interactive/tutorial.html#startup-files).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [https://ipython.readthedocs.io/en/stable/interactive/tutorial.html#startup-files](https://ipython.readthedocs.io/en/stable/interactive/tutorial.html#startup-files)。
- en: Unit test cases for the module
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模块的单元测试用例
- en: The various functions were refactored from a notebook to create a separate module
    need unit tests. In many cases, the functions will have doctest examples; the
    notebook as a whole will have a doctest cell.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将各种函数从笔记本重构为单独的模块需要单元测试。在许多情况下，函数将包含 doctest 示例；整个笔记本将有一个 doctest 单元。
- en: In this case, an extra option in the **pytest** command will execute these tests,
    as well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**pytest** 命令的额外选项将执行这些测试。
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `--doctest-modules` option will look for the doctest examples and execute
    them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`--doctest-modules` 选项将查找 doctest 示例并执行它们。'
- en: An alternative is to use the Python `doctest` command directly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是直接使用 Python 的 `doctest` 命令。
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is, of course, essential to test the code extracted from the notebook to
    be sure it works properly and can be trusted.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，测试从笔记本提取的代码以确保其正常工作并且可以信赖是至关重要的。
- en: This revised and expanded inspection notebook lets an analyst inspect unknown
    data sources to confirm values are likely to be cardinal numbers, for example,
    measures or counts. Using a filter function can help locate invalid or other anomalous
    text. Some statistical techniques can help to locate outlying values.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修订和扩展的检查笔记本允许分析师检查未知的数据源，以确认值可能是基数数，例如，度量或计数。使用过滤器函数可以帮助定位无效或其他异常文本。一些统计技术可以帮助定位异常值。
- en: In the next project, we’ll look at non-cardinal data. This includes nominal
    data (i.e., strings of digits that aren’t numbers), and ordinal values that represent
    ranking or ordering positions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个项目中，我们将探讨非基数数据。这包括名义数据（即，不是数字的数字字符串），以及表示排名或排序位置的序数值。
- en: '7.2 Project 2.3: Validating text and codes — nominal data and ordinal numbers'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2 项目 2.3：验证文本和代码 - 名义数据和序数
- en: 7.2.1 Description
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 描述
- en: 'In the previous project ([*Project 2.2: Validating cardinal domains — measures,*
    *counts, and durations*](#x1-1620001)), we looked at attributes that contained
    cardinal data – measures and counts. We also need to look at ordinal and nominal
    data. Ordinal data is generally used to provide ranks and ordering. Nominal data
    is best thought of as codes made up of strings of digits. Values like US postal
    codes and bank account numbers are nominal data.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个项目（[*项目 2.2：验证基数域 - 度量、计数和持续时间*](#x1-1620001)）中，我们研究了包含基数数据的属性 - 度量和计数。我们还需要查看序数和名义数据。序数数据通常用于提供排名和排序。名义数据最好理解为由数字字符串组成的代码。如美国邮政编码和银行账户号码这样的值属于名义数据。
- en: 'When we look at the **CO****2** **PPM — Trends in Atmospheric Carbon** **Dioxide**
    data set, available at [https://datahub.io/core/co2-ppm](https://datahub.io/core/co2-ppm),
    it has dates that are provided in two forms: as a `year-month-day` string and
    as a decimal number. The decimal number positions the first day of the month within
    the year as a whole.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看[https://datahub.io/core/co2-ppm](https://datahub.io/core/co2-ppm)提供的**CO****2**
    **PPM——大气二氧化碳趋势**数据集时，它提供了两种形式的日期：作为`year-month-day`字符串和作为十进制数字。这个十进制数字将月份的第一天定位在整年中的位置。
- en: It’s instructive to use ordinal day numbers to compute unique values for each
    date and compare these with the supplied ”Decimal Date” value. An integer day
    number may be more useful than the decimal date value because it avoids truncation
    to three decimal places.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用序数日期来计算每个日期的唯一值并与提供的“十进制日期”值进行比较是有教育意义的。整数日期可能比十进制日期值更有用，因为它避免了截断到三位小数。
- en: Similarly, many of the data sets available from [https://berkeleyearth.org/data/](https://berkeleyearth.org/data/)
    contain complicated date and time values. Looking at the source data, [https://berkeleyearth.org/archive/source-files/](https://berkeleyearth.org/archive/source-files/)
    has data sets with nominal values to encode precipitation types or other details
    of historical weather. For even more data, see [https://www.ncdc.noaa.gov/cdo-web/](https://www.ncdc.noaa.gov/cdo-web/).
    All of these datasets have dates in a variety of formats.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，从[https://berkeleyearth.org/data/](https://berkeleyearth.org/data/)提供的许多数据集中，包含复杂的日期和时间值。查看源数据，[https://berkeleyearth.org/archive/source-files/](https://berkeleyearth.org/archive/source-files/)中的数据集包含用于编码降水类型或其他历史天气细节的名义值。更多数据，请参阅[https://www.ncdc.noaa.gov/cdo-web/](https://www.ncdc.noaa.gov/cdo-web/)。所有这些数据集的日期格式各不相同。
- en: What’s important for this project is to get an overview of the data that involves
    dates and nominal code values. Later projects will look at cleaning and converting
    the data for further use. This notebook is only designed to preview and inspect
    the data. It is used to demonstrate the data is complete and consistent and can
    be used for further processing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目来说，重要的是要了解涉及日期和名义代码值的数据概览。未来的项目将查看清理和转换数据以供进一步使用。这个笔记本仅用于预览和检查数据。它用于证明数据是完整和一致的，并且可以用于进一步处理。
- en: Dates and times
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 日期和时间
- en: A date, time, and the combined date-time value represent a specific point in
    time, sometimes called a timestamp. Generally, these are modeled by Python `datetime`
    objects.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 日期、时间和组合的日期时间值代表一个特定的时间点，有时称为时间戳。通常，这些是通过Python的`datetime`对象来建模的。
- en: A date in isolation can generally be treated as a `datetime` with a time of
    midnight. A time in isolation is often part of a date stated elsewhere in the
    data or assumed from context. Ideally, a date-time value has been broken into
    separate columns of data for no good reason and can be combined. In other cases,
    the data might be a bit more difficult to track down. For example, a log file
    as a whole might have an implied date — because each log file starts at midnight
    UTC — and the time values must be combined with the (implied) log’s date.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的日期通常可以被视为午夜时间的`datetime`对象。单独的时间通常是在数据中其他地方声明的日期的一部分，或者从上下文中推断出来的。理想情况下，日期时间值被拆分为单独的数据列，没有很好的理由，并且可以组合。在其他情况下，数据可能更难追踪。例如，整个日志文件可能隐含一个日期——因为每个日志文件都是从UTC午夜开始的——并且时间值必须与（隐含的）日志的日期结合。
- en: Date-time values are quite complex and rich with strange quirks. To keep the
    Gregorian calendar aligned with the positions of stars, and the Moon, leap days
    are added periodically. The `datetime` library in Python is the best way to work
    with the calendar.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 日期时间值非常复杂且充满奇怪的特性。为了使格里高利历与星星和月亮的位置保持一致，会定期添加闰日。Python中的`datetime`库是处理日历的最佳方式。
- en: It’s generally a bad idea to do any date-time computation outside the `datetime`
    package.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在`datetime`包之外进行任何日期时间计算都不是一个好主意。
- en: Home-brewed date computations are difficult to implement correctly.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 自行编写的日期计算很难正确实现。
- en: The `toordinal()` function of a `datetime.datetime` object provides a clear
    relationship between dates and an ordinal number that can be used to put dates
    into order.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`datetime.datetime`对象的`toordinal()`函数提供了日期和序数之间的明确关系，可以使用它来对日期进行排序。'
- en: 'Because months are irregular, there are several common kinds of date computations:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于月份不规则，存在几种常见的日期计算方法：
- en: A date plus or minus a duration given in months. The day of the month is generally
    preserved, except in the unusual case of February 29, 30, or 31, where ad hoc
    rules will apply.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期加上或减去以月为单位给出的持续时间。月份的天数通常会被保留，除非在2月29日、30日或31日这种不寻常的情况下，将适用临时规则。
- en: A date plus or minus a duration given in days or weeks.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期加上或减去以天或周为单位给出的持续时间。
- en: These kinds of computations can result in dates in a different year. For month-based
    computations, an ordinal month value needs to be computed from the date. Given
    a date, *d*, with a year, *d.y*, and a month *d.m*, the ordinal month, *m*[o],
    is *d.y* × 12 + *d.m* − 1\. After a computation, the `divmod()` function will
    recover the year and month of the result. Note that months are generally numbered
    from 1, but the ordinal month computation numbers months from zero. This leads
    to a −1 when creating an ordinal month from a date, and a +1 when creating a date
    from an ordinal month. As noted above, when the resulting month is February, something
    needs to be done to handle the exceptional case of trying to build a possibly
    invalid date with a day number that’s invalid in February of the given year.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这类计算可能会导致出现在不同年份的日期。对于基于月的计算，需要从日期计算序数月份值。给定一个日期*d*，其年份为*d.y*，月份为*d.m*，序数月份*m*[o]是*d.y*
    × 12 + *d.m* − 1。计算后，`divmod()`函数将恢复结果的年份和月份。请注意，月份通常从1开始编号，但序数月份计算从0开始编号。这导致从日期创建序数月份时为-1，从序数月份创建日期时为+1。如上所述，当结果月份是二月时，需要做一些处理来处理试图构建一个可能无效的日期的异常情况，该日期的日期数在给定年份的二月中是无效的。
- en: For day- or week-based computations, the `toordinal()` function and `fromordinal()`
    functions will work correctly to order and compute differences between dates.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于天或周的运算，`toordinal()`函数和`fromordinal()`函数将正确地排序和计算日期之间的差异。
- en: All calendar computations must be done using ordinal values.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所有日历计算都必须使用序数值。
- en: 'Here are the three steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三步：
- en: Either use the built-in `toordinal()` method of a `datetime` object, or compute
    an ordinal month number.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`datetime`对象的内置`toordinal()`方法，或者计算序数月份。
- en: Apply duration offsets to the ordinal value.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将持续时间偏移应用于序数值。
- en: Either use the built-in `fromordinal()` class method of the `datetime` class,
    or use the `divmod()` function to compute the year and month of the ordinal month
    number.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`datetime`类的内置`fromordinal()`类方法，或者使用`divmod()`函数来计算序数月份的年份和月份。
- en: For some developers, the use of ordinal numbers for dates can feel complicated.
    Using `if` statements to decide if an offset from a date is in a different year
    is less reliable and requires more extensive edge-case testing. Using an expression
    like `year,`` month`` =`` divmod(date,`` 12)` is much easier to test.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些开发者来说，使用序数词表示日期可能会感觉复杂。使用`if`语句来判断日期的偏移量是否属于不同的年份不太可靠，并且需要更广泛的边缘情况测试。使用类似`year,
    month = divmod(date, 12)`的表达式要容易测试得多。
- en: In the next section, we’ll look at time and the problem of local time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨时间和本地时间的问题。
- en: Time values, local time, and UTC time
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 时间值、本地时间和UTC时间
- en: Local time is subject to a great deal of complex-seeming rules, particularly
    in the US. Some countries have a single time zone, simplifying what constitutes
    local time. In the US, however, each county decides which timezone it belongs
    to, leading to very complex situations that don’t necessarily follow US state
    borders.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本地时间受到许多看似复杂的规则的影响，尤其是在美国。一些国家只有一个时区，简化了本地时间的构成。然而，在美国，每个县都决定它属于哪个时区，导致出现非常复杂的情况，这些情况不一定遵循美国州界。
- en: Some countries (the US and Europe, as well as a scattering of other places)
    offset the time (generally, but not universally by one hour) for part of the year.
    The rules are not necessarily nationwide; Canada, Mexico, Australia, and Chile
    have regions that don’t have daylight savings time offsets. The Navajo nation
    — surrounded by the state of Arizona in the US — doesn’t switch its clocks.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一些国家（包括美国和欧洲，以及一些其他地方）在一年中的部分时间会调整时间（通常但并非普遍为一个小时）。这些规则并不一定是全国性的；加拿大、墨西哥、澳大利亚和智利的部分地区没有夏令时调整。纳瓦霍部落——位于美国亚利桑那州境内——不调整时钟。
- en: 'The rules are here: [https://data.iana.org/time-zones/tz-link.html](https://data.iana.org/time-zones/tz-link.html).
    This is part of the Python `datetime` library and is already available in Python.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 规则在这里：[https://data.iana.org/time-zones/tz-link.html](https://data.iana.org/time-zones/tz-link.html)。这是Python
    `datetime`库的一部分，并且已经在Python中可用。
- en: This complexity makes use of the **universal coordinated time** (**UTC**) imperative.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这种复杂性使得使用**通用协调时间**（**UTC**）变得至关重要。
- en: Local times should be converted into UTC for analysis purposes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析目的，应将本地时间转换为协调世界时（UTC）。
- en: See [https://www.rfc-editor.org/rfc/rfc3339](https://www.rfc-editor.org/rfc/rfc3339)
    for time formats that can include a local-time offset.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://www.rfc-editor.org/rfc/rfc3339](https://www.rfc-editor.org/rfc/rfc3339)，了解可以包含本地时间偏移的时间格式。
- en: UTC can be converted back into local time to be displayed to users.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: UTC可以转换回本地时间以供用户显示。
- en: 7.2.2 Approach
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 方法
- en: Dates and times often have bewildering formats. This is particularly true in
    the US, where dates are often written as numbers in month/day/year format. Using
    year/month/day puts the values in order of significance. Using day/month/year
    is the reverse order of significance. The US ordering is simply strange.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间通常有令人困惑的格式。这在美国尤其如此，那里的日期通常以月/日/年的数字格式书写。使用年/月/日将值按重要性顺序排列。使用日/月/年是重要性顺序的反向。美国的顺序只是奇怪。
- en: This makes it difficult to do inspections on completely unknown data without
    any metadata to explain the serialization format. A date like 01/02/03 could mean
    almost anything.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在没有元数据解释序列化格式的情况下对完全未知的数据进行检查变得困难。像01/02/03这样的日期可能意味着几乎任何事情。
- en: In some cases, a survey of many date-like values will reveal a field with a
    range of 1-12 and another field with a range of 1-31, permitting analysts to distinguish
    between the month and day. The remaining field can be taken as a truncated year.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，对许多类似日期的值的调查将揭示一个范围在1-12之间的字段，另一个范围在1-31之间的字段，允许分析师区分月份和日期。剩余的字段可以被视为截断的年份。
- en: In cases where there is not enough data to make a positive identification of
    month or day, other clues will be needed. Ideally, there’s metadata to define
    the date format.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有足够的数据来确认月份或日期的情况下，需要其他线索。理想情况下，有元数据来定义日期格式。
- en: The `datetime.strptime()` function can be used to parse dates when the format(s)
    are known. Until the date format is known, the data must be used cautiously.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`datetime.strptime()`函数可以在格式已知时用于解析日期。直到日期格式已知，数据必须谨慎使用。'
- en: 'Here are two Python modules that can help parse dates:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个可以帮助解析日期的Python模块：
- en: '[https://pypi.org/project/dateparser/](https://pypi.org/project/dateparser/)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pypi.org/project/dateparser/](https://pypi.org/project/dateparser/)'
- en: '[https://pypi.org/project/python-dateutil/](https://pypi.org/project/python-dateutil/)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pypi.org/project/python-dateutil/](https://pypi.org/project/python-dateutil/)'
- en: It’s important to carefully inspect the results of date parsing to be sure the
    results are sensible. There are some confounding factors.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查日期解析的结果，以确保结果是合理的非常重要。有一些混淆因素。
- en: Years, for example, can be provided as two or four digits. For example, when
    dealing with old data, it’s important to note the use of two-digit encoding schemes.
    For a few years prior to 2000, the year of date might have been given as a complicated
    two-digit transformation. In one scheme, values from 0 to 29 meant years 2000
    to 2029\. Values from 30 to 99 meant years 1930 to 1999\. These rules were generally
    ad hoc, and different enterprises may have used different year encodings.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，年份可以提供两位或四位数字。例如，处理旧数据时，注意使用两位数编码方案非常重要。在2000年之前几年，日期的年份可能被给出为一个复杂的两位数转换。在一个方案中，从0到29的值代表2000年到2029年的年份。从30到99的值代表1930年到1999年的年份。这些规则通常是临时的，不同的企业可能使用了不同的年份编码。
- en: Additionally, leap seconds have been added to the calendar a few times as a
    way to keep the clocks aligned with planetary motion. Unlike leap years, these
    are the result of ongoing research by astronomers, and are not defined by the
    way leap years are defined.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了保持时钟与行星运动保持一致，日历上已经几次添加了跳秒。与闰年不同，这些是天文学家持续研究的结果，并不是按照闰年的定义来确定的。
- en: See [https://www.timeanddate.com/time/leapseconds.html](https://www.timeanddate.com/time/leapseconds.html)
    for more information.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://www.timeanddate.com/time/leapseconds.html](https://www.timeanddate.com/time/leapseconds.html)获取更多信息。
- en: The presence of a leap second means that a timestamp like `1972-06-30T23:59:60`
    is valid. The 60 value for seconds represents the additional leap second. As of
    this book’s initial publication, there were 26 leap seconds, all added on June
    30 or December 31 of a given year. These values are rare but valid.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 跳秒的存在意味着像`1972-06-30T23:59:60`这样的时间戳是有效的。秒的60值代表额外的跳秒。截至本书首次出版时，共有26个跳秒，所有这些都在给定年份的6月30日或12月31日添加。这些值很少见但有效。
- en: Nominal data
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 名义数据
- en: Nominal data is not numeric but may consist of strings of digits, leading to
    possible sources of confusion and — in some cases — useless data conversions.
    While nominal data should be treated as text, it’s possible for a spreadsheet
    to treat US Postal ZIP codes as numbers and truncate the leading zeroes. For example,
    North Adams, MA, has a ZIP code of 01247\. A spreadsheet might lose the leading
    zero, making the code 1247.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 名义数据不是数值，可能由数字字符串组成，这可能导致混淆的来源，在某些情况下 — 无用的数据转换。虽然名义数据应被视为文本，但电子表格可能将美国邮政 ZIP
    码视为数字并截断前导零。例如，North Adams，MA 的 ZIP 码为 01247。电子表格可能会丢失前导零，使代码变为 1247。
- en: While it’s generally best to treat nominal data as text, it may be necessary
    to reformat ZIP codes, account numbers, or part numbers to restore the leading
    zeroes. This can be done in a number of ways; perhaps the best is to use f-strings
    to pad values on the left with leading ”0” characters. An expression like `f"{zip:0>5s}"`
    creates a string from the `zip` value using a format of `0>5s`. This format has
    a padding character, `0`, a padding rule of `>`, and a target size of `5`. The
    final character `s` is the type of data expected; in this case, a string.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常最好将名义数据视为文本，但在某些情况下可能需要重新格式化 ZIP 码、账户号码或零件号码以恢复前导零。这可以通过多种方式完成；也许最好的方法是使用
    f-string 在左侧填充前导 "0" 字符。像 `f"{zip:0>5s}"` 这样的表达式使用 `zip` 值创建一个字符串，格式为 `0>5s`。此格式具有填充字符
    `0`，填充规则 `>`，以及目标大小 `5`。最后的字符 `s` 是预期的数据类型；在这种情况下，是一个字符串。
- en: An alternative is something like `(5*"0"`` +`` zip)[-5:]` to pad a given `zip`
    value to 5 positions. This prepends zeroes and then takes the right-most five
    characters. It doesn’t seem as elegant as an f-string but can be more flexible.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是将给定的 `zip` 值填充到 5 个位置，例如 `(5*"0" + zip)[-5:]`。它会先添加零，然后取最右边的五个字符。这看起来不如
    f-string 那么优雅，但可能更加灵活。
- en: Extend the data inspection module
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 扩展数据检查模块
- en: 'In the previous project, [*Project 2.2: Validating cardinal domains — measures,*
    *counts, and durations*](#x1-1620001), we considered adding a module with some
    useful functions to examine cardinal data. We can also add functions for ordinal
    and nominal data.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个项目 [*项目 2.2：验证基数域 — 度量、计数和持续时间*](#x1-1620001) 中，我们考虑添加一个包含一些有用函数的模块来检查基数数据。我们也可以添加用于序数和名义数据的函数。
- en: 'For a given problem domain, the date parsing can be defined as a separate,
    small function. This can help to avoid the complicated-looking `strptime()` function.
    In many cases, there are only a few date formats, and a parsing function can try
    the alternatives. It might look like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的问题域，日期解析可以定义为单独的、小型的函数。这有助于避免看起来复杂的 `strptime()` 函数。在许多情况下，只有少数日期格式，解析函数可以尝试不同的选项。它可能看起来像这样：
- en: '[PRE13]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function has three date formats that it attempts to use to convert the
    data. If none of the formats match the data, a `ValueError` exception is raised.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数尝试使用三种日期格式来转换数据。如果没有任何格式与数据匹配，将引发 `ValueError` 异常。
- en: For rank ordering data and codes, a notebook cell can rely on a `collections.Counter`
    instance to get the domain of values. More sophisticated processing is not required
    for simple numbers and nominal codes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于排名顺序数据和代码，笔记本中的一个单元格可以依赖于一个 `collections.Counter` 实例来获取值的域。对于简单的数字和名义代码，不需要更复杂的处理。
- en: 7.2.3 Deliverables
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3 可交付成果
- en: 'This project has the following deliverables:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目有以下可交付成果：
- en: A `requirements-dev.txt` file that identifies the tools used, usually `jupyterlab==3.5.3`.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `requirements-dev.txt` 文件，用于标识使用的工具，通常是 `jupyterlab==3.5.3`。
- en: Documentation in the `docs` folder.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docs` 文件夹中的文档。'
- en: Unit tests for any new changes to the modules in use.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对使用中的模块任何新更改的单元测试。
- en: Any new application modules with code to be used by the inspection notebook.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何新的应用程序模块，其中包含用于检查笔记本的代码。
- en: A notebook to inspect the attributes that appear to have ordinal or nominal
    data.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于检查似乎具有序数或名义数据的属性的笔记本。
- en: 'The project directory structure suggested in [*Chapter** 1*](ch005.xhtml#x1-170001),
    [*Project Zero: A Template* *for Other Projects*](ch005.xhtml#x1-170001) mentions
    a `notebooks` directory. See [*List of deliverables*](ch005.xhtml#x1-260003) for
    some more information. For this project, the notebook directory is needed.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第一章*](ch005.xhtml#x1-170001)，[*项目零：其他项目的模板*](ch005.xhtml#x1-170001) 中建议的项目目录结构中提到了一个
    `notebooks` 目录。参见 [*可交付成果列表*](ch005.xhtml#x1-260003) 获取更多信息。对于这个项目，需要笔记本目录。
- en: We’ll look at a few of these deliverables in a little more detail.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更详细地查看这些可交付成果中的几个。
- en: Revised inspection module
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修订后的检查模块
- en: Functions for date conversions and cleaning up nominal data can be written in
    a separate module. Or they can be developed in a notebook, and then moved to the
    inspection module. As we noted in the [*Description*](#x1-1720001) section, this
    project’s objective is to support the inspection of the data and the identification
    of special cases, data anomalies, and outlier values.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 日期转换和清理名义数据的函数可以编写在一个单独的模块中。或者它们可以在笔记本中开发，然后移动到检查模块。正如我们在[*描述*](#x1-1720001)部分所指出的，这个项目的目标是支持数据的检查和特殊案例、数据异常和异常值的识别。
- en: Later, we can look at refactoring these functions into a more formal and complete
    data cleansing module. This project’s goal is to inspect the data and write some
    useful functions for the inspection process. This will create seeds to grow a
    more complete solution.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以将这些函数重构为一个更正式和完整的数据清洗模块。这个项目的目标是检查数据并编写一些用于检查过程的实用函数。这将创建一个更完整解决方案的种子。
- en: Unit test cases
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元测试用例
- en: Date parsing is — perhaps — one of the more awkwardly complicated problems.
    While we often think we’ve seen all of the source data formats, some small changes
    to upstream applications can lead to unexpected changes for data analysis purposes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 日期解析可能是——也许——更复杂的问题之一。虽然我们常常认为我们已经看到了所有的源数据格式，但上游应用程序的一些微小变化可能导致数据分析目的上的意外变化。
- en: Every time there’s a new date format, it becomes necessary to expand the unit
    tests with the bad data, and then adjust the parser to handle the bad data. This
    can lead to a surprisingly large number of date-time examples.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每当出现新的日期格式时，就有必要通过不良数据扩展单元测试，然后调整解析器以处理不良数据。这可能导致大量日期时间示例的意外增加。
- en: When confronted with a number of very similar cases, the `pytest` parameterized
    fixtures are very handy. These fixtures provide a number of examples of a test
    case.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对许多非常相似的案例时，`pytest`参数化固定装置非常方便。这些固定装置提供了一系列测试用例的示例。
- en: 'The fixture might look like the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 固定装置可能看起来像以下这样：
- en: '[PRE14]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each of the example values is a two-tuple with input text and the expected `datetime`
    object. This pair of values can be decomposed by the test case.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个示例值都是一个包含输入文本和预期`datetime`对象的二元组。这对值可以通过测试用例进行分解。
- en: 'A test that uses this fixture full of examples might look like the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个充满示例的固定装置进行的测试可能看起来像以下这样：
- en: '[PRE15]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This kind of test structure permits us to add new formats as they are discovered.
    The test cases in the `EXAMPLES` variable are easy to expand with additional formats
    and special cases.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试结构允许我们随着新格式的发现而添加新的格式。`EXAMPLES`变量中的测试用例很容易通过额外的格式和特殊情况进行扩展。
- en: 'Now that we’ve looked at inspecting cardinal, ordinal, and nominal data, we
    can turn to a more specialized form of nominal data: key values used to follow
    references between separate data sets.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了检查基数、序数和名义数据，我们可以转向一种更专门的名义数据形式：用于在单独的数据集之间跟踪引用的关键值。
- en: '7.3 Project 2.4: Finding reference domains'
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 项目 2.4：寻找参考域
- en: 'In many cases, data is decomposed to avoid repetition. In [*Chapter** 5*](ch009.xhtml#x1-1140005),
    [*Data* *Acquisition Features: SQL Database*](ch009.xhtml#x1-1140005), we touched
    on the idea of normalization to decompose data.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，数据被分解以避免重复。在[*第5章*](ch009.xhtml#x1-1140005)，[*数据获取特性：SQL数据库*](ch009.xhtml#x1-1140005)中，我们提到了将数据分解为规范化的想法。
- en: 'As an example, consider the data sets in this directory: [https://www.ncei.noaa.gov/pub/data/paleo/historical/northamerica/usa/new-england/](https://www.ncei.noaa.gov/pub/data/paleo/historical/northamerica/usa/new-england/)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个目录中的数据集：[https://www.ncei.noaa.gov/pub/data/paleo/historical/northamerica/usa/new-england/](https://www.ncei.noaa.gov/pub/data/paleo/historical/northamerica/usa/new-england/)
- en: There are three separate files. Here’s what we see when we visit the web page.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个单独的文件。当我们访问网页时，我们看到的是以下内容。
- en: 'Here’s the index of the `/pub/data/paleo/historical/northamerica/usa/new-england`
    file:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`/pub/data/paleo/historical/northamerica/usa/new-england`文件的索引：
- en: '|'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Name** | **Last modified** | **Size** | **Description** |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **最后修改** | **大小** | **描述** |'
- en: '|'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Parent Directory |  | - |  |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 父目录 |  | - |  |'
- en: '| new-england-oldweather-data.txt | 2014-01-30 13:02 | 21M |  |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| new-england-oldweather-data.txt | 2014-01-30 13:02 | 21M |  |'
- en: '| readme-new-england-oldweather.txt | 2014-01-29 19:22 | 9.6K |  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| readme-new-england-oldweather.txt | 2014-01-29 19:22 | 9.6K |  |'
- en: '| town-summary.txt | 2014-01-29 18:51 | 34K |  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| town-summary.txt | 2014-01-29 18:51 | 34K |  |'
- en: '|'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |  |  |  |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |'
- en: The `readme-new-england-oldweather.txt` file has descriptions of a number of
    codes and their meanings used in the main data set. The ”readme” file provides
    a number of mappings from keys to values. The keys are used in the massive ”oldweather-data”
    file to reduce the repetition of data.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`readme-new-england-oldweather.txt`文件描述了主数据集中使用的许多代码及其含义。该“readme”文件提供了一系列从键到值的映射。键用于庞大的“oldweather-data”文件中，以减少数据的重复。'
- en: 'These mappings include the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这些映射包括以下内容：
- en: The Temperature Code Key
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 温度代码键
- en: The Precipitation Type Key
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降水量类型键
- en: The Precipitation Amount key
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降水量关键值
- en: The Snowfall Amount key
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 雪量关键值
- en: The Like Values Code key
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相似值代码键
- en: The Pressure Code Key
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压力代码键
- en: The Sky Cover Key
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天空覆盖键
- en: The Sky Classification Key
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天空分类键
- en: The Location Code Key
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置代码键
- en: This is a rather complex decomposition of primary data into coded values.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对主数据到编码值的一种相当复杂的分解。
- en: 7.3.1 Description
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 描述
- en: In cases where data is decomposed or normalized, we need to confirm that references
    between items are valid. Relationships are often one-way — a sample will have
    a reference to an item in another collection of data. For example, a climate record
    may have a reference to ”Town Id” (TWID) with a value like `NY26`. A second data
    set with the ”location code key” provides detailed information on the definition
    of the `NY26` town ID. There’s no reverse reference from the location code data
    set to all of the climate records for that location.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据分解或规范化的情况下，我们需要确认项目之间的引用是否有效。关系通常是单向的——一个样本将引用另一个数据集中的一项。例如，气候记录可能有一个引用“Town
    Id”（TWID）的值，如`NY26`。第二个包含“位置代码键”的数据集提供了关于`NY26`城镇ID定义的详细信息。没有从位置代码数据集到该位置所有气候记录的反向引用。
- en: We often depict this relationship as an ERD. For example, [*Figure 7.1*](#7.1)*.*
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将这种关系表示为ERD。例如，[*图7.1*](#7.1)*.*。
- en: '![Figure 7.1: A Normalized Relationship ](img/file35.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：一个规范化的关系](img/file35.jpg)'
- en: 'Figure 7.1: A Normalized Relationship'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：一个规范化的关系
- en: A number of weather data records refer to a single location definition.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 许多天气数据记录引用单个位置定义。
- en: The database designers will call the Location’s “TWID” attribute a **primary**
    **key**. The WeatherData’s ID attribute is called a **foreign key**; it’s a primary
    key for a different class of entities. These are often abbreviated as PK and FK.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库设计者会将位置的“TWID”属性称为**主键**。WeatherData的ID属性被称为**外键**；它是不同类别的实体的主键。这些通常缩写为PK和FK。
- en: 'There are two closely related questions about the relationship between entities:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 关于实体之间关系的问题有两个密切相关：
- en: What is the *cardinality* of the relationship? This must be viewed from both
    directions. How many primary key entities have relationships with foreign key
    entities? How many foreign key entities have a relationship with a primary key
    entity?
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系的基数是多少？这必须从两个方向来考虑。有多少主键实体与外键实体有关联？有多少外键实体与主键实体有关联？
- en: What is the *optionality* of the relationship? Again, we must ask this in both
    directions. Must a primary entity have any foreign key references? Must the foreign
    key item have a primary key reference?
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系的**可选性**是什么？同样，我们必须从两个方向来询问这个问题。主实体是否必须有任何外键引用？外键项是否必须有主键引用？
- en: While a large number of combinations are possible, there are a few common patterns.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能的组合很多，但有一些常见的模式。
- en: The mandatory many-to-one relationship. This is exemplified by the historical
    weather data. Many weather data records must refer to a single location definition.
    There are two common variants. In one case, a location **must** have one or more
    weather records. The other common variant may have locations without any weather
    data that refers to the location.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制多对一关系。这以历史天气数据为例。许多天气数据记录必须引用单个位置定义。有两种常见的变体。在一种情况下，一个位置**必须**有一个或多个天气记录。另一种常见变体可能没有与位置相关的任何天气数据。
- en: An optional one-to-one relationship. This isn’t in the weather data example,
    but we may have invoices with payments and invoices without payments. The relationship
    is one-to-one, but a payment may not exist yet.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的一对一关系。这在天气数据示例中不存在，但我们可能有带有付款的发票和没有付款的发票。这种关系是一对一的，但付款可能尚未存在。
- en: A many-to-many relationship. An example of a many-to-many relationship is a
    product entity that has a number of features. Features are reused between products.
    This requires a separate many-to-many association table to track the relationship
    links.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This leads to the following two detailed inspections:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The domain of primary key values. For example, the “TWID” attribute of each
    location.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The domain of the foreign key values. For example, the ID attribute of each
    weather data record.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If these two sets are identical, we can be sure the foreign keys all have matching
    primary keys. We can count the number of rows that share a foreign key to work
    out the cardinality (and the optionality) of the relationship.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'If the two sets are not identical, we have to determine which set has the extra
    rows. Let’s call the two sets *P* and *F*. Further, we know that *P**≠**F*. There
    are a number of scenarios:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '*P* ⊃ *F*: This means there are some primary keys without any foreign keys.
    If the relationship is optional, then, there’s no problem. The *P*∖*F* is the
    set of unused entities.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*F* ⊂ *P*: This means there are foreign keys that do not have an associated
    primary key. This situation may be a misunderstanding of the key attributes, or
    it may mean data is missing.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s important for this project is to have an overview of key values and their
    relationship. This notebook is only designed to preview and inspect the data.
    It is used to demonstrate the data is complete and consistent, and can be used
    for further processing.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look at how we can build cells in a notebook to compare
    the keys and determine the cardinality of the relationships.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 7.3.2 Approach
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To work with data sets like [https://www.ncei.noaa.gov/pub/data/paleo/historical/northamerica/usa/new-england/](https://www.ncei.noaa.gov/pub/data/paleo/historical/northamerica/usa/new-england/)
    we’ll need to compare keys.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'This will lead to two kinds of data summarization cells in an inspection notebook:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing primary keys in a `Counter` object.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summarizing foreign key references to those primary keys, also using a `Counter`.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the `Counter` summaries are available, then the `.keys()` method will have
    the distinct primary or foreign key values. This can be transformed into a Python
    `set` object, permitting elegant comparison, subset checking, and set subtraction
    operations.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at the programming to collect key values and references to keys first.
    Then, we’ll look at summaries that are helpful.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Collect and compare keys
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The core inspection tool is the `collections.Counter` class. Let’s assume we
    have done two separate data acquisition steps. The first extracted the location
    definitions from the `readme-new-england-oldweather.txt` file. The second converted
    all of the `new-england-oldweather-data.txt` weather data records into a separate
    file.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: The inspection notebook can load the location definitions and gather the values
    of the `TWID` attribute.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'One cell for loading the key definitions might look like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 用于加载键定义的一个单元格可能如下所示：
- en: '[PRE16]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A cell for inspecting the definitions of the town keys might look like this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检查城镇键定义的单元格可能如下所示：
- en: '[PRE17]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This creates the `town_id_set` variable with a set of IDs in use. The values
    of the `town_id_counts` variable are the number of location definitions for each
    ID. Since this is supposed to be a primary key, it should have only a single instance
    of each value.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了包含使用的 ID 集合的 `town_id_set` 变量。`town_id_counts` 变量的值是每个 ID 的位置定义数量。由于这是一个主键，它应该只有每个值的单个实例。
- en: The data with references to the town keys may be much larger than the definitions
    of the keys. In some cases, it’s not practical to load all the data into memory,
    and instead, the inspection needs to work with summaries of selected columns.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 引用城镇键的数据可能比键的定义大得多。在某些情况下，将所有数据加载到内存中并不实际，因此检查需要与所选列的摘要一起工作。
- en: For this example, that means a `list` object is **not** created with the weather
    data. Instead, a generator expression is used to extract a relevant column, and
    this generator is then used to build the final summary `Counter` object.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，这意味着不会创建一个包含天气数据的 `list` 对象。相反，使用生成器表达式提取相关列，然后使用这个生成器构建最终的 `Counter`
    对象摘要。
- en: 'The rows of data with references to the foreign keys might look like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 引用外键的数据行可能看起来像这样：
- en: '[PRE18]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once the `weather_id_count` summary has been created, the following cell can
    compute the domain of key references like this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 `weather_id_count` 摘要，以下单元格可以计算键引用的域，如下所示：
- en: '[PRE19]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It’s important to note that this example emphatically does *not* create a list
    of individual weather report samples. That would be a lot of data jammed into
    memory at one time. Instead, this example uses a generator expression to extract
    the `’ID’` attribute from each row. These values are used to populate the `weather_id_count`
    variable. This is used to extract the set of IDs in use in the weather reports.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这个例子明确**不**创建单个天气报告样本的列表。那样会将大量数据一次性加载到内存中。相反，这个例子使用生成器表达式从每一行中提取 `‘ID’`
    属性。这些值用于填充 `weather_id_count` 变量。这用于提取天气报告中使用的 ID 集合。
- en: Since we have two sets, we can use Python’s set operations to compare the two.
    Ideally, a cell can assert that `weather_id_set`` ==`` town_id_set`. If the two
    are not equal, then the set subtraction operation can be used to locate anomalous
    data.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有两个集合，我们可以使用 Python 的集合操作来比较这两个集合。理想情况下，一个单元格可以断言 `weather_id_set` `==`
    `town_id_set`。如果这两个集合不相等，则可以使用集合减法操作来定位异常数据。
- en: Summarize keys counts
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 汇总键的数量
- en: The first summary is the comparison of primary keys to foreign keys. If the
    two sets don’t match, the list of missing foreign keys may be helpful for locating
    the root cause of the problem.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个摘要是比较主键和外键。如果这两个集合不匹配，缺失的外键列表可能有助于定位问题的根本原因。
- en: Additionally, the range of counts for a foreign key provides some hints as to
    its cardinality and optionality. When a primary key has no foreign key values
    referring to it, the relationship appears optional. This should be confirmed by
    reading the metadata descriptions. The lower and upper bounds on the foreign key
    counts provide the range of the cardinality. Does this range make sense? Are there
    any hints in the metadata about the cardinality?
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，外键计数的范围提供了一些关于其基数和可选性的线索。当一个主键没有外键值引用它时，这种关系看起来是可选的。这应该通过阅读元数据描述来确认。外键计数的上下限提供了基数范围。这个范围有意义吗？元数据中是否有关于基数的提示？
- en: 'The example data source for this project includes a file with summary counts.
    The `town-summary.txt` file has four columns: “STID”, “TWID”, “YEAR”, and “Records”.
    The “STID” is from the location definitions; it’s the US state. The “TWID” is
    the town ID. The “YEAR” is from the weather data; it’s the year of the report.
    Finally, the “Records” attribute is the count of weather reports for a given location
    and year.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的数据源示例包括一个包含摘要计数的文件。`town-summary.txt` 文件有四列：“STID”，“TWID”，“YEAR”和“Records”。“STID”来自位置定义；它是美国州。
    “TWID”是城镇 ID。“YEAR”来自天气数据；它是报告的年份。最后，“Records”属性是给定位置和年份的天气报告数量。
- en: The Town ID and Year form a logical pair of values that can be used to build
    a `collections.Counter` object. To fully reproduce this table, though, the location
    definitions are needed to map a Town ID, “TWID,” to the associated state, “STID.”
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: While it’s also possible to decompose the “TWID” key to extract the state information
    from the first two characters, this is not a good design alternative. This composite
    key is an uncommon kind of key design. It’s considerably more common for primary
    keys to be atomic with no internal information available. A good design treats
    the key as an opaque identifier and looks up the state information in the associated
    location definition table from the `readme` file.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 7.3.3 Deliverables
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This project has the following deliverables:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: A `requirements-dev.txt` file that identifies the tools used, usually `jupyterlab==3.5.3`.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation in the `docs` folder.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests for any new changes to the modules in use.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any new application modules with code to be used by the inspection notebook.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A notebook to inspect the attributes that appear to have foreign or primary
    keys.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The project directory structure suggested in [*Chapter** 1*](ch005.xhtml#x1-170001),
    [*Project Zero: A Template* *for Other Projects*](ch005.xhtml#x1-170001) mentions
    a `notebooks` directory. See [*List of deliverables*](ch005.xhtml#x1-260003) for
    some more information. For this project, the notebook directory is needed.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at a few of these deliverables in a little more detail.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Revised inspection module
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The functions for examining primary and foreign keys can be written in a separate
    module. It’s often easiest to develop these in a notebook first. There can be
    odd discrepancies that arise because of misunderstandings. Once the key examination
    works, it can be moved to the inspection module. As we noted in the [*Description*](#x1-1720001),
    this project’s objective is to support the inspection of the data and the identification
    of special cases, data anomalies, and outlier values.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Unit test cases
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s often helpful to create test cases for the most common varieties of key
    problems: primary keys with no foreign keys and foreign keys with no primary keys.
    These complications don’t often arise with readily available, well-curated data
    sets; they often arise with enterprise data with incomplete documentation.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: This can lead to rather lengthy fixtures that contain two collections of source
    objects. It doesn’t take many rows of data to reveal a missing key; two rows of
    data are enough to show a key that’s present and a row with a missing key.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: It’s also essential to keep these test cases separate from test cases for cardinal
    data processing, and ordinal data conversions. Since keys are a kind of nominal
    data, a key cardinality check may be dependent on a separate function to clean
    damaged key values.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: For example, real data may require a step to add leading zeroes to account numbers
    before they can be checked against a list of transactions to find transactions
    for the account. These two operations on account number keys need to be built
    — and tested — in isolation. The data cleanup application can combine the two
    functions. For now, they are separate concerns with separate test cases.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Revised notebook to use the refactored inspection model
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A failure to resolve foreign keys is a chronic problem in data acquisition
    applications. This is often due to a wide variety of circumstances, and there’s
    no single process for data inspection. This means a notebook can have a spectrum
    of information in it. We might see any of the following kinds of cells:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: A cell explaining the sets of keys match, and the data is likely usable.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cell explaining some primary keys have no foreign key data. This may include
    a summary of this subset of samples, separate from samples that have foreign key
    references.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cell explaining some foreign keys that have no primary key. These may may
    reflect errors in the data. It may reflect a more complex relationship between
    keys. It may reflect a more complicated data model. It may reflect missing data.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all cases, an extra cell with some markdown explaining the results is necessary.
    In the future, you will be grateful because in the past, you left an explanation
    of an anomaly in your notebook.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Summary
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter expanded on the core features of the inspection notebook. We looked
    at handling cardinal data (measures and counts), ordinal data (dates and ranks),
    and nominal data (codes like account numbers).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Our primary objective was to get a complete view of the data, prior to formalizing
    our analysis pipeline. A secondary objective was to leave notes for ourselves
    on outliers, anomalies, data formatting problems and other complications. A pleasant
    consequence of this effort is to be able to write some functions that can be used
    downstream to clean and normalize the data we’ve found.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting in [*Chapter** 9*](ch013.xhtml#x1-2080009), [*Project 3.1: Data Cleaning
    Base Application*](ch013.xhtml#x1-2080009), we’ll look at refactoring these inspection
    functions to create a complete and automated data cleaning and normalization application.
    That application will be based on the lessons learned while creating inspection
    notebooks.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at one more lesson that’s often learned from
    the initial inspection. We often discover the underlying schema behind multiple,
    diverse sources of data. We’ll look at formalizing the schema definition via JSONSchema,
    and using the schema to validate data.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 7.5 Extras
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some ideas for you to add to the projects in this chapter.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.1 Markdown cells with dates and data source information
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A minor feature of an inspection notebook is some identification of the date,
    time, and source of the data. It’s sometimes clear from the context what the data
    source is; there may, for example, be an obvious path to the data.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: However, in many cases, it’s not perfectly clear what file is being inspected
    or how it was acquired. As a general solution, any processing application should
    produce a log. In some cases, a metadata file can include the details of the processing
    steps.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: This additional metadata on the source and processing steps can be helpful when
    reviewing a data inspection notebook or sharing a preliminary inspection of data
    with others. In many cases, this extra data is pasted into ordinary markdown cells.
    In other cases, this data may be the result of scanning a log file for key `INFO`
    lines that summarize processing.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.2 Presentation materials
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common request is to tailor a presentation to users or peers to explain a
    new source of data, or explain anomalies found in existing data sources. These
    presentations often involve an online meeting or in-person meeting with some kind
    of “slide deck” that emphasizes the speaker’s points.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Proprietary tools like Keynote or PowerPoint are common for these slide decks.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: A better choice is to organize a notebook carefully and export it as `reveal.js`
    slides.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: The RISE extension for Jupyter is popular for this. See [https://rise.readthedocs.io/en/stable/](https://rise.readthedocs.io/en/stable/).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Having a notebook that is **also** the slide presentation for business owners
    and users provide a great deal of flexibility. Rather than copying and pasting
    to move data from an inspection notebook to PowerPoint (or Keynote), we only need
    to make sure each slide has a few key points about the data. If the slide has
    a data sample, it’s only a few rows, which provide supporting evidence for the
    speaker’s remarks.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: In many enterprises, these presentations are shared widely. It can be beneficial
    to make sure the data in the presentation comes directly from the source and is
    immune to copy-paste errors and omissions.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.3 JupyterBook or Quarto for even more sophisticated output
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some cases, a preliminary inspection of data may involve learning a lot of
    lessons about the data sources, encoding schemes, missing data, and relationships
    between data sets. This information often needs to be organized and published.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of ways to disseminate lessons learned about data:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Share the notebooks. For some communities of users, the interactive nature of
    a notebook invites further exploration.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export the notebook for publication. One choice is to create a PDF that can
    be shared. Another choice is to create RST, Markdown, or LaTeX and use a publishing
    pipeline to build a final, shareable document.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a tool like Jupyter{Book} to formalize the publication of a shareable document.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Quarto to publish a final, shareable document.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Jupyter{Book}, see [https://jupyterbook.org/en/stable/intro.html](https://jupyterbook.org/en/stable/intro.html).
    The larger “Executable{Books}” project ( [https://executablebooks.org/en/latest/tools.html](https://executablebooks.org/en/latest/tools.html))
    describes the collection of Python-related tools, including Myst-NB, Sphinx, and
    some related Sphinx themes. The essential ingredient is using Sphinx to control
    the final publication.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'For Quarto, see [https://quarto.org](https://quarto.org). This is somewhat
    more tightly integrated: it requires a single download of the Quarto CLI. The
    Quarto tool leverages Pandoc to produce a final, elegant, ready-to-publish file.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: You are encouraged to look at ways to elevate the shared notebook to an elegant
    report that can be widely shared.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
