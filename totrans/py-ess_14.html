<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch14"/>Chapter 14. Fit and Finish – Unit Testing, Packaging, and Documentation</h1></div></div></div><p>Beyond the Python language and its libraries, there are several other aspects to Python programming. We'll start by looking closely at the docstrings, which should be viewed as an essential ingredient in every package, module, class, and function definition. These have several purposes, one of which is to clarify what the object does.</p><p>In this chapter, we'll also look at the different approaches to unit testing. The <code class="literal">doctest</code> and <code class="literal">unittest</code> modules provide a comprehensive suite of tools. External tools like Nose are also widely used.</p><p>We'll also look at how we can leverage the <code class="literal">logging</code> module as part of a complete application. The Python logger is quite sophisticated as well, so we'll focus on a few of the essential features.</p><p>We'll examine some tools that are used to build Python documentation from the embedded docstring comments. Using tools to extract documentation allows us to focus on writing proper code and deriving the reference documents from the code. In order to create complete documentation—more than just an API reference—many developers use the Sphinx tool.</p><p>We'll also address the organization of files in a large Python project. Because Python is used in so many different contexts and has so many different frameworks, the layout for a web application built with Flask will look nothing like a web application built with Django. However, there are a few essential principles that we can follow for keeping Python programs neat and well organized.</p><div><div><div><div><h1 class="title"><a id="ch14lvl1sec117"/>Writing docstrings</h1></div></div></div><p>In <a class="link" href="ch07.html" title="Chapter 7. Basic Function Definitions">Chapter 7</a>, <em>Basic Function Definitions</em>, we noted<a class="indexterm" id="id677"/> that all functions should have a docstring that describes the function. In <a class="link" href="ch11.html" title="Chapter 11. Class Definitions">Chapter 11</a>, <em>Class Definitions</em>, and <a class="link" href="ch12.html" title="Chapter 12. Scripts, Modules, Packages, Libraries, and Applications">Chapter 12</a>, <em>Scripts, Modules, Packages, Libraries, and Applications</em>, we offered similar advice, without providing many details.</p><p>The <code class="literal">def</code> statement<a class="indexterm" id="id678"/> and the <code class="literal">class</code> statement should, universally, be followed by a triple-quoted string that describes the function, method, or class. It's not required by the language—it's required by all of the people who will try to read, understand, extend, improve, or repair our code.</p><p>We'll revisit an example from <a class="link" href="ch11.html" title="Chapter 11. Class Definitions">Chapter 11</a>, <em>Class Definitions</em>, to show the kinds of docstrings that were omitted. Here's how we might create a more complete class definition:</p><div><pre class="programlisting">class Point:
    """
    Point on a plane.

    Distances are calculated using hypotenuse.
    This is the "as a crow flies" straight line distance.

    Point on a plane.

    Distances are calculated using hypotenuse.
    This is the "as a crow flies" straight line distance.

    &gt;&gt;&gt; p_1 = Point(22, 7)
    &gt;&gt;&gt; p_1.x
    22
    &gt;&gt;&gt; p_1.y
    7
    &gt;&gt;&gt; p_1
    Point(22, 7)
    """
    def __init__(self, x, y):
        """Create a new point

        :param x: X coördinate
        :param y: Y coördinate
        """
        self.x= x
        self.y= y
    def __repr__(self):
        """Returns string representation of this Point."""
        return "{cls}({x:.0f}, {y:.0f})".format(
            cls=self.__class__.__name__, x=self.x, y=self.y)
    def dist(self, point):
        """Distance to another point measured on a plane.

        &gt;&gt;&gt; p_1 = Point(22, 7)
        &gt;&gt;&gt; p_2 = Point(20, 5)
        &gt;&gt;&gt; round(p_1.dist(p_2),4)
        2.8284

        :param point: Another instance of Point.
        :returns: float distance.
        """
        return math.hypot(self.x-point.x, self.y-point.y)</pre></div><p>In this<a class="indexterm" id="id679"/> class definition, we've provided four separate docstrings. For the class as a whole, we provided an overview of what the class does, plus an example of how the class behaves. This is shown as a copy and paste from the Python REPL, showing the input prefixed with <code class="literal">&gt;&gt;&gt;</code> prompts.</p><p>For each method function, we've provided a docstring that shows what the method function does. In the case of the <code class="literal">dist()</code> method, we've included another example interaction in the docstring to show an example of the expected behavior of the method.</p><p>The documentation of parameters and return values uses the <a class="indexterm" id="id680"/>
<strong>ReStructuredText</strong> (<strong>RST</strong>) markup language. This is widely used because of tools like <code class="literal">docutils</code> and Sphinx, which can format RST into nice-looking HTML or LaTeX. We'll look at RST in the section <em>Writing documentation with RST markup</em> later in this chapter.</p><p>For now, we can focus on <code class="literal">:param name:</code> and <code class="literal">:returns:</code> as markup syntax that helps tools understand the semantics of these constructs. The tool can then give them special formatting to reflect their meaning.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec118"/>Writing unit tests with doctest</h1></div></div></div><p>It is a <a class="indexterm" id="id681"/>widely adopted practice to provide concrete examples of classes and functions in docstrings. As shown in the preceding example, we can provide the following kind of example text in a docstring:</p><div><pre class="programlisting">&gt;&gt;&gt; p_1 = Point(22, 7)
&gt;&gt;&gt; p_2 = Point(20, 5)
&gt;&gt;&gt; round(p_1.dist(p_2),4)
2.8284</pre></div><p>A concrete example has many benefits. The goal of Python code is to be beautiful and readable. If the code sample is obscure or confusing, this is a design problem that really should be resolved. Writing more words in comments to try to explain bad code is a symptom of a deeper problem. A concrete example should be as clear and expressive as the code itself.</p><p>An additional benefit of concrete examples is that they are test cases. The <code class="literal">doctest</code> module can scan <a class="indexterm" id="id682"/>each docstring to locate these examples, build, and execute test cases. This will confirm that the output in the example matches the actual output.</p><p>One common approach to using <code class="literal">doctest</code> is to include the following in a <code class="literal">library</code> module:</p><div><pre class="programlisting">if __name__ == "__main__":
    import doctest
    doctest.testmod(verbose=1)</pre></div><p>If the module is executed as the main script instead of being imported, then it will import <code class="literal">doctest</code>, scan the module for docstrings, and execute all the tests in those docstrings. We've set the verbose level to one, which produces output that shows the tests in some detail. If we leave the verbose level to it's default value of zero, success is silent; not even an <code class="literal">Ok</code> is displayed.</p><p>We can also run <code class="literal">doctest</code> as a command-line application. Here's an example:</p><div><pre class="programlisting">
<strong>MacBookPro-SLott:Code slott$ python3 -m doctest Chapter_1/ch01_ex1.py -v</strong>
<strong>Trying:</strong>
<strong>    355/113</strong>
<strong>Expecting:</strong>
<strong>    3.1415929203539825</strong>
<strong>ok</strong>
<strong>...</strong>
<strong>1 items had no tests:</strong>
<strong>    ch01_ex1</strong>
<strong>9 items passed all tests:</strong>
<strong>   2 tests in __main__.__test__.assignment</strong>
<strong>   4 tests in __main__.__test__.cmath</strong>
<strong>   2 tests in __main__.__test__.division</strong>
<strong>   1 tests in __main__.__test__.expression</strong>
<strong>   3 tests in __main__.__test__.import 1</strong>
<strong>   1 tests in __main__.__test__.import 2</strong>
<strong>   2 tests in __main__.__test__.import 3</strong>
<strong>   2 tests in __main__.__test__.mixed_math</strong>
<strong>   2 tests in __main__.__test__.print</strong>
<strong>19 tests in 10 items.</strong>
<strong>19 passed and 0 failed.</strong>
<strong>Test passed.</strong>
</pre></div><p>We've run the <code class="literal">doctest</code> module as an application, providing it with the name of a file that should be examined to locate test examples inside docstrings. The output starts with the first example found. The example is this:</p><div><pre class="programlisting">&gt;&gt;&gt; 355/113
3.1415929203539825</pre></div><p>The <a class="indexterm" id="id683"/>verbose output shows the expression and the expected results. The output of <code class="literal">ok</code> indicates that the test was passed.</p><p>What about the one item that had no tests? That's the docstring for the module itself. This shows us that our test case coverage is incomplete. We should consider adding a test in the module docstring.</p><p>The summary showed that 9 items had 19 tests. The items are identified with strings such as <code class="literal">ch01_ex1.__test__.assignment</code>. The special name <code class="literal">__test__</code> is neither a function nor a class; it's a global variable. If there's a variable named <code class="literal">__test__</code>, it must be a dictionary. The keys in the <code class="literal">__test__</code> dictionary are documentation, and the values are strings that must include <code class="literal">doctest</code> examples.</p><p>The <a class="indexterm" id="id684"/>
<code class="literal">__test__</code> variable might look like this:</p><div><pre class="programlisting">__test__ = {
    'expression': """
        &gt;&gt;&gt; 355/113
        3.1415929203539825
    """,
<em>etc.</em>
}</pre></div><p>Each key identifies the test. Each value is a triple-quoted string that includes a snippet of REPL interaction showing the expected results.</p><p>As a practical matter, this particular test suffers from one of the potential limitations of <code class="literal">doctest</code> examples.</p><p>As we noted in <a class="link" href="ch05.html" title="Chapter 5. Logic, Comparisons, and Conditions">Chapter 5</a>, <em>Logic, Comparisons, and Conditions</em>, we should not use exact equality tests between floating point values. The proper way to write a test like this is to use <code class="literal">round(355/113, 6)</code> to truncate the trailing digits; the final digits might differ slightly depending on the hardware or underlying floating point libraries. It's better to write tests that are independent of implementation nuances.</p><p>There are a number of potential limitations with <code class="literal">doctest</code> examples. Dictionary keys have no defined order. Therefore, a <code class="literal">doctest</code> can fail when the keys are displayed in an order that differs from the expected output in the test. Similarly, set items have no defined order. Additionally, an error traceback message may not match precisely because it will have a line like <code class="literal">File "&lt;stdin&gt;", line 1, in &lt;module&gt;</code> that may vary depending on the context in which the test runs.</p><p>For some of these potential limitations, <code class="literal">doctest</code> offers directives that can be used to annotate the tests. The <a class="indexterm" id="id685"/>directives appear as special comments like this: <code class="literal"># doctest: +ELLIPSIS</code>. This will enable flexible pattern matching to cope with the variations in displayed output. For other limitations, we need to construct our test cases properly. We can use <code class="literal">sorted(some_dict.values())</code> to transform a dictionary result into a sorted list of tuples where the order is guaranteed.</p><p>Docstrings are an essential feature of good Python programming. Examples are an essential feature of well-written documentation. Given a tool that can verify the correctness of the examples, this kind of testing should be considered mandatory.</p></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec119"/>Using the unittest library for testing</h1></div></div></div><p>For<a class="indexterm" id="id686"/> more complex testing, the <code class="literal">doctest</code> examples may not provide enough depth or flexibility. A docstring with a large number of cases would become too long to be effective as documentation. A docstring with complex test setup, teardown, or mock objects may not be useful as documentation either.</p><p>For these cases, we'll use the <code class="literal">unittest</code> module to define test cases and test suites. When using <code class="literal">unittest</code>, we'll generally create separate modules. These test modules will contain <code class="literal">TestCase</code> classes that contain test methods.</p><p>Here's a quick overview of a typical test case class definition:</p><div><pre class="programlisting">import unittest

from Chapter_7.ch07_ex1 import FtoC

class Test_FtoC(unittest.TestCase):
    def setUp(self):
        self.temps= [50, 60, 72]
    def test_single(self):
        self.assertAlmostEqual(0.0, FtoC(32))
        self.assertAlmostEqual(100.0, FtoC(212))
    def test_map(self):
        temps_c = list(map(FtoC, self.temps))
        self.assertEqual(3, len(temps_c))
        rounded = [round(t,3) for t in temps_c]
        self.assertEqual([10.0, 15.556, 22.222], rounded)</pre></div><p>We've shown a <code class="literal">setUp()</code> method and two test methods. The default <code class="literal">runTest()</code> method will search for all methods with a name that begins with <code class="literal">test</code>; it will then run the <code class="literal">setUp()</code> method that is executed prior to each individual <code class="literal">test...</code> method.</p><p>We can use the Python <code class="literal">assert</code> statement to compare actual and expected results. Because there are so many common comparisons, the <code class="literal">TestCase</code> class offers handy methods for comparing different kinds of expected results with actual results. We've shown <code class="literal">assertEqual()</code> and <code class="literal">assertAlmostEqual()</code>. Each of these methods parallels the <code class="literal">assert</code> statement—they succeed silently. If there's a problem, they raise an <code class="literal">AssertionError</code> exception.</p><p>Using <a class="indexterm" id="id687"/>the <code class="literal">unittest</code> module allows us to write voluminous test cases. A <code class="literal">doctest</code> string is most useful when it expresses a few helpful concrete examples. A unit test is a better way to include many edge and corner cases.</p><p>The <code class="literal">unittest</code> module is also handy for test examples that involve interaction with the filesystem. We might have a <code class="literal">.csv</code> format file that has a number of examples. We can write a <code class="literal">runTest()</code> method that reads this file and treats each row as a test case.</p><p>When pursuing <a class="indexterm" id="id688"/>
<strong>acceptance test-driven development</strong> (<strong>ATDD</strong>), the test cases themselves can become quite complex. The test case setup may involve seeding a database with sample data prior to executing a big application feature, and then examining the resulting database contents. The essential structure of ATDD testing fits the unit testing design patterns offered by the <code class="literal">unittest</code> module. The "unit" under test is not an isolated class; instead, we're testing a complete web API or command-line application.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec99"/>Combining doctest and unittest</h2></div></div></div><p>We can<a class="indexterm" id="id689"/> incorporate <code class="literal">doctest</code> test cases into the <code class="literal">unittest</code> suite of tests. This assures us that the <code class="literal">doctest</code> examples are not overlooked when using <code class="literal">unittest</code> cases. We'll do this by using the <code class="literal">TestSuite</code> class, which can contain other <code class="literal">TestCase</code> classes as well as <code class="literal">TestSuite</code> classes.</p><p>A <code class="literal">doctest.DocTestSuite</code> object will create a proper <code class="literal">unittest.TestSuite</code> method from the <code class="literal">doctest</code> strings embedded in a given module. We can use a function like the following to locate all test cases in a large collection of packages and modules:</p><div><pre class="programlisting">def doctest_suite():
    files = glob.glob("Chapter*/ch*_ex*.py")
    by_chxx= lambda name: name.partition(".")[2].partition("_")[0]
    modules = sorted(
        (".".join(f.replace(".py","").split(os.sep)) for f in files),
        key=by_chxx)
    suites= [doctest.DocTestSuite(m) for m in modules]
    return unittest.TestSuite(suites)</pre></div><p>This function will return a <code class="literal">TestSuite</code> object built from other <code class="literal">TestSuite</code> objects. This function has five steps:</p><div><ol class="orderedlist arabic"><li class="listitem">It uses <code class="literal">glob.glob()</code> to get a list of all matching module names in the packages. This particular pattern will locate all of the example code for this book. We might have to change this to pass or reject other kinds of names that might be available.</li><li class="listitem">It <a class="indexterm" id="id690"/>defines a lambda object that extracts the chapter number from the module, ignoring the package. The expression uses <code class="literal">name.partition(".")</code> to split the complete module name into the package, the dot character, and the module name. Item number 2 from this sequence is the module name. This is partitioned on the <code class="literal">"_"</code> into chapter prefix, underscore, and example suffix. We use item number 0, the chapter prefix, as the sort order for the modules.</li><li class="listitem">The input to the <code class="literal">sorted()</code> function is a sequence of filenames restructured into module names. This transformation involves replacing the <code class="literal">".py"</code> filename suffix and then splitting the filename on the OS path separator ("/" on most OSes, but on Windows it is "\") into separate substrings. When we join the substrings using "." we get a module name, which we can use for sorting and test case discovery.</li><li class="listitem">We build a list comprehension of the test suites that can be built from the <code class="literal">doctest</code> examples in each module. This includes over 100 individual tests culled from the examples throughout this book.</li><li class="listitem">We assemble a single test suite from the list of test suites. This can then be executed to confirm that all of the examples produce the expected results.</li></ol></div><p>We can merge this doctest <code class="literal">TestSuite</code> object with a <code class="literal">TestSuite</code> object built from tests based on the <code class="literal">unittest.TestCase</code> definitions. This complete suite can then be executed to show that the code works as expected.</p><p>We often use something like the following:</p><div><pre class="programlisting">if __name__ == "__main__":
    runner= unittest.TextTestRunner( verbosity=1 )
    all_tests = unittest.TestSuite( suite() )
    runner.run( all_tests )</pre></div><p>This will create a test runner that produces a summary of tests and test failures. The <code class="literal">suite()</code> function—not shown—returns a <code class="literal">TestSuite()</code> method built from the <code class="literal">doctest_suite()</code> function and a function that scans files for <code class="literal">unittest.TestCase</code> classes.</p><p>The output summarizes the tests run and the failures. When we build a comprehensive test suite like this, we include both <code class="literal">unittest</code> and <code class="literal">doctest</code> cases. This allows us to freely mix complex suites with simple docstring examples.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec120"/>Using other add-on test libraries</h1></div></div></div><p>The <a class="indexterm" id="id691"/>
<code class="literal">doctest</code> and <code class="literal">unittest</code> modules allow us to write a number unit tests conveniently. In many cases, we want even more sophistication. One of the more popular additional features is test discovery. The <code class="literal">nose</code> package gives us a way to painlessly examine modules and packages for tests. See <a class="ulink" href="http://nose.readthedocs.org/en/latest/">http://nose.readthedocs.org/en/latest/</a> for more information.</p><p>There are several benefits of using <code class="literal">nose</code> as an extension to <code class="literal">unittest</code>. The <code class="literal">nose</code> module can collect tests from <code class="literal">unittest.TestCase</code> subclasses, as well as simple test functions, and also from test classes that are not subclasses of <code class="literal">unittest.TestCase</code>. We can use <code class="literal">nose</code> for writing timing tests too—something that can be a little awkward in <code class="literal">unittest</code>.</p><p>Because <code class="literal">nose</code> is particularly good at collecting tests automatically, there's no need to manually collect test cases into test suites; we don't need some of the examples shown earlier. Furthermore, <code class="literal">nose</code> supports test fixtures at the package, module, and class level, so expensive initialization can be done as infrequently as possible. This allows us to populate a test database for multiple modules of related testing—something that <code class="literal">unittest</code> can't do as easily.</p></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec121"/>Logging events and conditions</h1></div></div></div><p>A<a class="indexterm" id="id692"/> well-behaved application can produce a variety of processing summaries. For<a class="indexterm" id="id693"/> command-line applications, the summary might be a simple "everything went okay" message. For GUI applications, this summary is inverted—silence means things are working well, and a dialog box with an error message indicates things didn't work properly.</p><p>In some command-line processing contexts, the summary might include some additional details on the number of objects that were processed. In financial applications, some counts and the total values of various objects must balance properly to show that all objects that were received as input became proper outputs.</p><p>When we need additional details, beyond a simple "works or breaks" summary, we can leverage the <code class="literal">print()</code> function. The output can be redirected to the <code class="literal">sys.stderr</code> file to produce a handy log. While this is effective in small programs, it has a number of desirable features offered by the <code class="literal">logging</code> module.</p><p>The first step in using the <code class="literal">logging</code> module is to create logger objects and use the loggers to produce useful output. Each logger has a name that fits into a tree using names delimited with the <code class="literal">.</code> character. The logger names parallel the standards for module names; we can use the following:</p><div><pre class="programlisting">import logging
logger = logging.getLogger(__name__)</pre></div><p>This will create a module-wide <code class="literal">logger</code> object with a name that matches the module name. The root logger has the name <code class="literal">""</code>; that is, an empty string.</p><p>We can <a class="indexterm" id="id694"/>also create class-wide loggers as well as object-specific loggers. We can, for example, create a logger during the <code class="literal">__init__()</code> method part of object creation. We<a class="indexterm" id="id695"/> might use the <code class="literal">__qualname__</code> attribute of an object's class to provide a qualified class name for the logger. To create a logger for a specific instance of a class, we can suffix the class name with the <code class="literal">.</code> character and some unique identifier for the instance.</p><p>We use the logger to create messages with a severity level from <code class="literal">DEBUGGING</code> (the least severe) to <code class="literal">FATAL</code> or <code class="literal">CRITICAL</code> (synonyms for the most severe level.) We do this with a method name that reflects the severity level. Messages are created with methods like these:</p><div><pre class="programlisting">logger.debug("Finished with {0} using {2}".format(message, details))
logger.error("Error due to {0}".format(data))</pre></div><p>The <code class="literal">logging</code> module has a default configuration that does nothing. This means that we can include logging requests in an application without any further consideration. As long as we properly create a <code class="literal">Logger</code> instance and use methods of the logger instance, we don't need to do anything else.</p><p>To see output, we'll need to create a handler that will write the messages to a particular stream or file. This is usually done as part of the overall configuration of the logging system.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec100"/>Configuring the logging system</h2></div></div></div><p>We <a class="indexterm" id="id696"/>have several ways to configure the logging system. For small applications, we might provide the logging setup using the <code class="literal">logging.basicConfig()</code> function. We've shown this in <a class="link" href="ch13.html" title="Chapter 13. Metaprogramming and Decorators">Chapter 13</a>, <em>Metaprogramming and Decorators</em>. A simple initialization will send the output to the standard error stream and explicitly set a level that filters the messages being displayed. This uses the <code class="literal">stream</code> and <code class="literal">level</code> keyword arguments.</p><p>A slightly more complex configuration might look like this:</p><div><pre class="programlisting">logging.basicConfig(filename='app.log', filemode='a', level=logging.INFO)</pre></div><p>We've opened a named file, assigned a mode of <code class="literal">a</code> to append, and set the level to show messages with a severity that's equal to or greater than <code class="literal">INFO</code>.</p><p>Since each individual logger is named, we can adjust the level of detail for a specific logger. We can include a line like the following to enable debugging on a specific logger:</p><div><pre class="programlisting">logging.getLogger('Demonstration').setLevel(logging.DEBUG)</pre></div><p>This allows us to see details for a specific class or module. This is often a great help when debugging.</p><p>The <a class="indexterm" id="id697"/>
<code class="literal">logging.handlers</code> module offers a large number of handlers for routing, printing, or saving the sequence of logging messages. The preceding example shows the file handler. The stream handler is used to write to the standard error stream. In some cases, we need to have multiple handlers. We can apply filters to each handler, so that the handlers will reflect different kinds of details.</p><p>Logging configurations often get too complex for the <code class="literal">basicConfig()</code> function. The <code class="literal">logging.config</code> module offers several functions that can be used to configure the logging for an application. One general approach is to use the <code class="literal">logging.config.dictConfig()</code> function. We can create a Python <code class="literal">dict</code> object directly in Python, or read some serialized version of the <code class="literal">dict</code> object. The standard library documentation uses examples written in the YAML markup language because it's simple and flexible.</p><p>We might do something like this to create a configuration object:</p><div><pre class="programlisting">config = {
    'version': 1,
    'handlers': {
        'console': {
            'class' : 'logging.StreamHandler',
            'stream': 'ext://sys.stderr',
        }
    },
    'root': {
        'level': 'DEBUG',
        'handler': ['console'],
    },
}</pre></div><p>This object has the required <code class="literal">version</code> attribute to specify the structure of the configuration. A single handler is defined; it's named <code class="literal">console</code> and uses <code class="literal">logging.StreamHandler</code> is used to write to the standard error stream. The root logger is configured to use the <code class="literal">console</code> handler. The severity level is defined to include any message at or above the <code class="literal">DEBUG</code> level.</p><p>Only in configuration files is the root logger named <code class="literal">'root'</code>. In application code, the root logger is named with an empty string.</p><p>Larger and more sophisticated applications will rely on logging configurations in external configuration files. This permits flexible and sophisticated logging configurations.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec122"/>Writing documentation with RST markup</h1></div></div></div><p>While <a class="indexterm" id="id698"/>Python code should be beautiful <a class="indexterm" id="id699"/>and informative, it doesn't easily provide background or context to show why a particular algorithm or data structure was chosen. We often need to provide these additional details to help people maintain, extend, and make effective use of our software. While we can include a lot of information in a module docstring, it seems best to keep docstrings focused on implementation details, and provide the additional material separately.</p><p>We can write additional documentation in a variety of formats. We can use a sophisticated editor with complex file formats, or we can use simple text editors and plain text format. We can even write our documentation entirely in HTML. Python also offers a hybrid approach—we can write using a text editor with simplified <strong>ReStructuredText</strong> (<strong>RST</strong>) markup, and use the <code class="literal">docutils</code> tools to create nice-looking HTML pages or LaTeX files suitable for publication from that markup.</p><p>The RST markup language is widely used for creating Python documentation. This markup allows us to write plain text, while adhering to a few formatting rules. In the next section, we'll look at using the <code class="literal">docutils</code> tools to parse the RST and create an output document.</p><p>The rules of RST markup are simple. There is paragraph-level markup that applies to big blocks of text. Paragraphs must be separated by blank lines. When a line is "underlined" with a sequence of characters, it is taken as a heading. When a paragraph starts with an isolated punctuation mark, it's a bullet. When a paragraph starts with a letter or digit, and a punctuation mark, this indicates numbers instead of bullets. The <code class="literal">docutils</code> <code class="literal">rst2html.py</code> tool transforms each paragraph of the input to the proper kind of HTML structure.</p><p>There are many paragraph-level "directives" that can be used to insert an image, a table, an equation, or a large block of code. These directives are prefixed with <code class="literal">..</code> and end with <code class="literal">::</code>. We might use the directive <code class="literal">.. contents::</code> to add the table of contents to our document.</p><p>We can write inline markup inside the body of a paragraph. Inline markup includes a few simple constructs. If we surround a word with the <code class="literal">*</code> character, like <code class="literal">*this*</code>, we'll see the word in an <em>italic</em>-style font in the final document; we can use <code class="literal">**bold**</code> for <strong>bold</strong> characters. If we want to write a <code class="literal">*</code> character without confusing the tool, we can escape it with the <code class="literal">\</code> character. In many cases, however, we'll need to use a more complex semantic markup that looks like this: <code class="literal">:code:`code sample`</code>. This includes the text role, <code class="literal">:code:</code>, as a prefix that shows how to classify the marked characters; the content is surrounded by the <code class="literal">`</code> character. The text roles of <code class="literal">:code:</code> and <code class="literal">:math:</code> are widely used.</p><p>When we write a docstring, we'll often use additional RST markup. We'll use <code class="literal">:param name:</code> when defining the parameter to a function or class method. We use <code class="literal">:returns:</code> to annotate the return values from a function. When we provide this additional markup, we're assured that <a class="indexterm" id="id700"/>various formatting tools will <a class="indexterm" id="id701"/>produce elegant documentation from our docstrings.</p><p>Here's an example of what an RST file might contain:</p><div><pre class="programlisting">Writing RST Documentation
==========================

For more information, see http://docutils.sourceforge.net/docs/user/rst/quickref.html

1.  Separate paragraphs with blank lines.

2.  Underline headings.

#.  Prefix with one character for an unordered list. Otherwise it may be
    interpreted as an ordered list.

#.  Indent freely to show structure.

#.  Inline markup.

    -   Use ``*word*`` for *italics*, and ``**word**`` for **bold**.

    -   Use ``:code:\`word\``` for more complex semantic markup.</pre></div><p>We've shown a heading, underlined with a sequence of <code class="literal">=</code> characters. We've provided a URL; in the final HTML output, this will become a proper link using the <code class="literal">&lt;a&gt;</code> tag. We've shown numbered paragraphs. When we omit the leading number and use <code class="literal">#</code>, the <code class="literal">docutils</code> tools will assign increasing numbers. We've also shown indented bullet point within the last numbered paragraph.</p><p>While this example shows numbering and simple hyphen bullets, we can use lettering or Roman numerals as well. The <code class="literal">docutils</code> tools are generally able to parse a wide variety of formatting conventions.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec101"/>Creating HTML documentation from an RST source</h2></div></div></div><p>To create <a class="indexterm" id="id702"/>HTML or LaTeX (or any of the other supported formats), we'll use one of the <code class="literal">docutils</code> frontend tools. There are many individual conversion tools that are part of the <code class="literal">docutils</code> package.</p><p>The <code class="literal">docutils</code><a class="indexterm" id="id703"/> tools are not part of Python. See <a class="ulink" href="http://docutils.sourceforge.net">http://docutils.sourceforge.net</a> for <a class="indexterm" id="id704"/>the download.</p><p>All of the tools have a similar command-line interface. We might use the following command to create an HTML page from some RST input:</p><div><pre class="programlisting">
<strong>MacBookPro-SLott:Chapter_14 slott$ rst2html.py ch14_doc.rst ch14_doc.rst.html</strong>
</pre></div><p>We've provided the <code class="literal">rst2html.py</code> command. We've named the input file and the output file. This will use default values for the style sheet, and other optional features for the resulting document. We can configure the output through the command line or by providing a configuration file that assures a common look for all of our generated HTML files.</p><p>To create LaTeX, we can use the <code class="literal">rst2latex.py</code> or <code class="literal">rst2xetex.py</code> tool, and then a LaTeX formatter. <a class="indexterm" id="id705"/>TeX Live distribution works nicely for creating a PDF file from LaTeX. See <a class="ulink" href="https://www.tug.org/texlive/">https://www.tug.org/texlive/</a>.</p><p>For large and complex documents, creating a single RST file isn't ideal. While we can use the <code class="literal">.. include::</code> directive to insert material from separate files, the document must be built as a whole, which requires a large amount of memory; rebuilding a document after a small change might require a disproportionate amount of processing.</p><p>For a multipage website, we have to use a tool like Make, Ant, or SCons to rebuild the relevant HTML pages when a source RST file has been updated. This is the kind of overhead that calls out for a tool to automate and simplify production of large or complex documents.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec102"/>Using the Sphinx tool</h2></div></div></div><p>The <a class="indexterm" id="id706"/>Sphinx tool <a class="indexterm" id="id707"/>allows us to easily build multipage websites or complex documents. For more information, see <a class="ulink" href="http://sphinx-doc.org">http://sphinx-doc.org</a>. When we install Sphinx using <code class="literal">pip</code> or <code class="literal">easy_install</code>, the installer will also include <code class="literal">docutils</code> for us.</p><p>To create <a class="indexterm" id="id708"/>sophisticated documentation, we'll start with the <code class="literal">sphinx-quickstart</code> script. This application will build the template file structure, the configuration files, and a Makefile that we can use to rebuild our documents efficiently.</p><p>Sphinx adds a large number of directives and text roles to the basics of RST. These additional roles and directives make it easier to write about code with properly formatted references to modules, classes, and functions. Sphinx simplifies inter-document references—we can have multiple documents with consistent references to a target location; we can move the target and the references will all be updated.</p><p>The <code class="literal">sphinx-build</code> command is used to construct the target files from the RST source. Sphinx can build over a dozen different kinds of target documents, making it a versatile tool.</p><p>The <a class="indexterm" id="id709"/>Python documentation is built with Sphinx. This means that our projects can include documentation that looks as polished and elegant as Python's documentation.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec123"/>Organizing Python code</h1></div></div></div><p>Python programs <a class="indexterm" id="id710"/>should be beautiful. To that end, the language has few syntactic overheads; we should be able to write short scripts without unpleasant boilerplate. The principle is sometimes articulated as <em>Simple things should be simple</em>. The "Hello World" script really is a single line of code that uses the <code class="literal">print()</code> function.</p><p>A more complex file will generally have a few major sections:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <code class="literal">!#</code> line, often <code class="literal">#!/usr/bin/env python3</code>.</li><li class="listitem" style="list-style-type: disc">A docstring comment explaining what the module does.</li><li class="listitem" style="list-style-type: disc">The function or class definitions. We often group multiple functions and classes into a single module. The module is the proper unit of reuse in Python.</li><li class="listitem" style="list-style-type: disc">If the module can be run as a main script, we'll include an <code class="literal">if __name__ == "__main__":</code> section that defines the file's behavior when run as the main script.</li></ul></div><p>Many applications are too complex for a single file. When designing larger applications, the Pythonic ideal is to keep the resulting structure as flat as possible. While the language supports nested packages, deep nesting is not seen as desirable. In <a class="link" href="ch12.html" title="Chapter 12. Scripts, Modules, Packages, Libraries, and Applications">Chapter 12</a>, <em>Scripts, Modules, Packages, Libraries, and Applications</em>, we looked at the details of defining modules and packages.</p></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec124"/>Summary</h1></div></div></div><p>In this chapter, we've looked at several features of polished and complete Python projects. The most important feature of working code is a suite of unit tests that demonstrate that the code works. Code without test cases simply cannot be trusted. In order to make use of any software, we must have tests that show us that the software is trustworthy.</p><p>We've looked at including tests in docstrings. The <code class="literal">doctest</code> tool can locate these tests and execute them. We've looked at creating <code class="literal">unittest.TestCase</code> classes. We can combine the two into a script that will locate all <code class="literal">doctest</code> and <code class="literal">unittest</code> test cases into a single master test suite.</p><p>One other feature of good software is some explanation of how to install and use the software. This may be as short as a <code class="literal">README</code> file that provides basic information. Often, however, we need a more sophisticated document that provides a variety of additional information. We might want to provide context, design background, or examples that are too big to be packaged into module or class docstrings. We'll often write documentation using tools above and beyond the basic components that come with Python.</p><p>In <a class="link" href="ch15.html" title="Chapter 15. Next Steps">Chapter 15</a>, <em>Next Steps</em>, we'll look at the next steps in our exploration of Python. Once we've mastered the essentials, we need to add depth to the areas that are relevant to the problems we need to solve. We might want to study big data applications, web applications, or game development. Each of these more specialized areas will involve additional Python concepts, tools, and frameworks.</p></div></body></html>