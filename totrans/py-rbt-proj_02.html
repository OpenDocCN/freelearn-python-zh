<html><head></head><body><div><h1 class="header-title">Using GPIOs as Input</h1>
                
            
            
                
<p>In the previous chapter, we understood how GPIOs are used for output. But, as the name suggests, the GPIO can be used for both input and output purposes. In this chapter, we will see how you can go ahead and use these pins to input the data over to Raspberry Pi.</p>
<p>The topics which we will cover in this chapter are:</p>
<ul>
<li>A deeper dive into GPIOs</li>
<li>Interfacing the PIR sensor</li>
<li>Interfacing the ultrasonic proximity sensor</li>
<li>Interfacing through I2C</li>
</ul>


            

            
        
    </div>
<div><h1 class="header-title">A deeper dive into GPIOs</h1>
                
            
            
                
<p class="mce-root">I am sure you remember this line of code from the previous chapter:</p>
<pre>GPIO.setup(18,GPIO.OUT)</pre>
<p>As explained earlier, this basically tells us how GPIO the pin will behave in a certain program. By now, you must have guessed that by changing this single line of code we can change the behavior of the pin and convert it from output to input. This is how you would do it:</p>
<pre>GPIO.setup(18,GPIO.IN)</pre>
<p>Once you write this line of code in your program, the microcontroller will know that during the time that the program is being run, the pin number <kbd>18</kbd> will only be used for input purposes. </p>
<p>To understand how this would actually work, let's head back to our hardware and see how it can be done. Firstly, you need to connect an LED to any of the pins; we will be using pin number <kbd>23</kbd> in this program. Secondly, you need to connect a switch on pin number <kbd>24</kbd>. You can refer the diagram that follows for making the connections:</p>
<div><img src="img/8bac0a39-8e8e-4e0f-b91d-c14c9ea4e497.png" style="width:32.92em;height:44.92em;"/></div>
<p>Once you connect it, you can go ahead and write this program:</p>
<pre>import time import RPi.GPIO as GPIO<br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setup(24,GPIO.IN)<br/>GPIO.setup(23,GPIO.OUT)<br/>while True:<br/>  button_state = GPIO.input(24)<br/>    if button_state == True:<br/>      GPIO.output(23,GPIO.HIGH)<br/>    else:<br/>      GPIO.output(23,GPIO.LOW)<br/>  time.sleep(0.5)<br/>GPIO.cleanup()</pre>
<p>Once the program is uploaded, then, as soon as you press the push button, the LED will turn itself on. </p>
<p>Let's understand what exactly is happening. <kbd>while True:</kbd> is basically an infinite loop; once you apply this loop, the code running inside it is repeated over and over again until something breaks it, and by break I mean some interruption that causes the program to stop and exit. Now, ideally we exit the program by pressing <em>Ctrl</em> + <em>C</em> whenever there is an infinite loop. </p>
<pre>button_state = GPIO.input(24)  </pre>
<p>In the above line, the program understands where it has to look; in this program. In this line we are telling the program that we are looking for GPIO <kbd>24</kbd>, which is an input:</p>
<pre>if button_state == True:<br/>   GPIO.output(23,GPIO.HIGH)  </pre>
<p>If the button is high, in other words when the button is pressed and the current is reaching the pin number <kbd>24</kbd>, then the GPIO pin number <kbd>23</kbd> will be set to high:</p>
<pre>  else:<br/>   GPIO.output(23,GPIO.LOW)</pre>
<p>If the pin number <kbd>24</kbd> is not true, it will follow this line of code and will keep the pin number <kbd>23</kbd> low, in other words switched off. </p>
<p>So, there it is, your first program for using the GPIOs for input purposes.</p>


            

            
        
    </div>
<div><h1 class="header-title">Interfacing the PIR sensor</h1>
                
            
            
                
<p>So far, so good! In this unit, we will go ahead and interface out first sensor, which is a passive infrared, commonly known as a PIR sensor. This sensor is a very special sensor and is used very commonly in automation projects. Its low energy consumption makes it a superb contender for IoT projects as well. So let's see how it works.</p>
<p>You must have noticed that when we heat a metal to a high temperature, it slowly gets dark red in color, and when we heat it further, it gets brighter and slowly goes from red to yellow as depicted in the below diagram which shows a red hot steel tab. Now, as the temperature increases, the wavelength of the emitted radiation decreases; that is why with the increase in temperature the color changes from red to yellow, as yellow has a shorter wavelength compared to red. </p>
<div><img src="img/9ddb9af7-40a5-44f6-b1c0-c0ea8d7c3974.png" style="width:27.00em;height:36.08em;"/></div>
<p>But the interesting part is that even when the objects are not heated enough, they emit radiation; in fact, any object that is above the temperate of absolute zero emits some form of radiation. Some we can see with the naked eye, others we can't. So, at room temperature, objects emit infrared radiation which has a higher wavelength compared to visible light. Hence, we don't see it with our eyes. Nonetheless, it is still there.</p>
<p>What this PIR sensor does is that it senses the infrared light from the objects around it and whenever an object moves, it can sense the overall change in its pattern and, based on that, can detect if there is any movement that has happened in its proximity.</p>
<p>We assume that whenever there is someone in a room there will be some inherent movement that will happen, and hence this sensor is very commonly used as an occupancy sensor. Now, let's connect this sensor and see how we can use it:</p>
<div><img src="img/5cdeb242-f3b0-4a88-8ee5-eae7a520d307.png" style="width:36.42em;height:36.42em;"/></div>
<p>Once you have connected it as per the preceding diagram, go ahead and upload the code: :</p>
<pre>import time import RPi.GPIO as GPIO<br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setup(23,GPIO.IN) <br/>GPIO.setup(24,GPIO.OUT)<br/>while True:<br/> if GPIO.input(23) == 1: <br/>  GPIO.output(24,GPIO.HIGH)<br/> else: <br/>  GPIO.output(24,GPIO.LOW)<br/><br/> time.sleep(1)<br/>GPIO.cleanup()</pre>
<p>Now, let's see what is happening. The logic is very simple. As soon as the PIR sensor detects movement, it turns its output pin to high. All we have to do is to monitor that pin and that's basically it. </p>
<p>The logic is entirely similar to that of a push-button switch, and it will also work in a similar manner. So not much explaining is needed. </p>


            

            
        
    </div>
<div><h1 class="header-title">Interfacing the ultrasonic proximity sensor</h1>
                
            
            
                
<p>First, the basics. A proximity sensor is a type of sensor that senses the proximity of an object from it. There is a universe full of sensors that are available to accomplish this task and numerous technologies that allow us to do so. As the name says, the ultrasonic proximity sensor works on the principal of ultrasonic sound waves. The working principle is quite easy to understand. The ultrasonic sensor sends a beam of ultrasonic sound waves; these waves are inaudible to human ears, but nonetheless it is still a sound wave and it also behaves like a sound wave.</p>
<p>Now, as we know, sound bounces off different surfaces and forms an echo. You must have experienced this echo when speaking in an empty room. You can hear your own sound but with a slight delay. This delay is caused by the property of sound. A sound is a wave, hence it has a speed. Sound waves have a set speed of travel. So, to cover a specific distance, they take some time. By calculating this time, we can derive how far the sound waves are going before getting bounced off from a surface. </p>
<p>Similarly, in this sensor, we shoot ultrasonic sound waves in a specific direction and then sense the echo which bounces back. Naturally, there would be a delay in receiving the echo; the delay would be directly proportional to the distance of the object from the sensor and, based on this delay, we could easily compute the distance. </p>
<p>Now, to work with the proximity sensor, we need to understand the physical architecture of the sensor to wire it correctly. There are four pins in the sensor, which are:</p>
<ul>
<li>VCC (positive)</li>
<li>Trigger </li>
<li>Echo</li>
<li>GND (ground)</li>
</ul>
<p>I obviously don't have any need to explain what VCC and ground does. So, let's move on straight to trigger. Whenever the pin is high for 10 microseconds, the ultrasonic sensor will send eight cycles of 40 kHz sound waves to the target. Once the trigger cycle is completed, the <strong>ECHO</strong> is set to high. Once it receives the echo signal back, the <strong>ECHO</strong> pin is set back to low. Here is a diagram to show how it actually happens:</p>
<div><img src="img/525c7f0a-8913-4114-8f12-b108b2c8ef44.png"/></div>
<p>That is all we need to know for now. Subsequently, we will learn more as we move along. Now, to go ahead and make it live, connect it as per the diagram:</p>
<div><img src="img/7fedb272-4aa1-47cd-b7a6-7c78a67994af.png" style="width:39.00em;height:34.58em;"/></div>
<p>Once the connection is made, the following is the code that you need to run:</p>
<pre>import RPi.GPIO as GPIO<br/>import time<br/><br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setup(23,GPIO.OUT) <br/>GPIO.setup(24,GPIO.IN) <br/><br/>while True:<br/>     pulse_start = 0<br/>     pulse_stop = 0<br/>     duration = 0<br/>     distance = 0<br/><br/>     GPIO.output(23,GPIO.LOW)<br/>     time.sleep(0.1) <br/>     GPIO.output(23,GPIO.HIGH)<br/>     time.sleep(0.000010)<br/>     GPIO.output(23,GPIO.LOW)<br/><br/>     while GPIO.input(24)==0:<br/>         pulse_start = time.time()<br/><br/>     while GPIO.input(24)==1:<br/>         pulse_stop = time.time()<br/><br/>     duration = pulse_stop - pulse_start<br/><br/>     distance = duration*17150.0<br/>     distance = round(distance,2)<br/>     print ("distance" + str(distance)) <br/> <br/>     time.sleep(0.2)<br/>}</pre>
<p>Now, once you run this program, the output on your screen will be showing you the distance of the object once in every 0.2 seconds. Now, you must be wondering how this is communicating all these readings:</p>
<pre>GPIO.setup(23,GPIO.OUT) </pre>
<p>We are assigning pin <kbd>23</kbd> to give pulse to <strong>TRIGGER</strong> pin of the sensor when required:</p>
<pre>GPIO.setup(24,GPIO.IN)</pre>
<p>We are assigning pin <kbd>24</kbd> to receive the logic to confirm the receipt of the echo signal:</p>
<pre>pulse_start = 0<br/> pulse_stop = 0<br/> duration = 0<br/> distance = 0</pre>
<p>We will be using the preceding as variables, and every time the loop starts we are assigning them a value which is <kbd>0</kbd>; this is to wipe off the previous reading that we would have stored during the course of program:</p>
<pre>GPIO.output(23,GPIO.HIGH)<br/>  time.sleep(0.000010)<br/>  GPIO.output(23,GPIO.LOW)</pre>
<p>We keep the trigger pin number <kbd>23</kbd> high for 0.000010 seconds so that the ultrasonic sensor can send a brief pulse of ultrasonic waves:</p>
<pre>  while GPIO.input(24)==0: <br/> pulse_start = time.time()</pre>
<p>This while statement will keep noting down the time of the <kbd>pulse_start</kbd> variable until the time pin number <kbd>24</kbd> is low. The final reading of the time will be stored in the <kbd>pulse_start</kbd> variable, as in noting down the time when the pulse was sent:</p>
<pre>while GPIO.input(24)==1:<br/> pulse_stop = time.time()</pre>
<p>The <kbd>while</kbd> statement in this loop will start noting the time when the input on pin number <kbd>24</kbd> is high and it will keep noting the time until the pin number <kbd>24</kbd> remains high. The final reading of the time will be stored in the <kbd>pulse_stop</kbd> variable, as in noting down the time when the pulse is received:</p>
<pre> duration = pulse_stop - pulse_start</pre>
<p>In this statement we are calculating the overall time it took for the pulse to travel from the sensor to the object and bounce back to the receiver on the sensor:</p>
<pre> distance = duration*17150.0</pre>
<p>This is an arithmetic formula given by the manufacturer to convert the time duration it took for the ultrasonic waves to travel into the actual distance in centimeters. You may ask how did we get to this equation?</p>
<p>Let me give you a brief about it. With elementary physics we would remember this simple equation: <em>Speed</em> = <em>Distance</em> / <em>Time</em>.</p>
<p>Now you may also recall that the speed of sound is 343 meters per second. Now 1 meter has 100 centimeters hence to convert this speed into centimeters per second, we would have to multiply the speed by 100, hence the speed would be 34,300 centimeters per second. </p>
<p>Now we know one element of the equation which is the speed. So lets put the value of speed into the equation. Now the equation would look something like this: <em>34,300</em> = <em>Distance</em> / <em>Time</em>.</p>
<p>Now we know one thing that the distance which the sound is travelling is twice the actual distance. How ? Because the sound first goes from the sensor to the object. Then it bounces off that surface and reaches back to the sensor. So essentially it is covering twice the distance. Hence we to adapt this equation we have to make a small change: <em>34,300</em> / <em>2</em> = <em>Distance</em> / <em>Time</em></p>
<p>Now what we want out of this equation is distance So lets take all other part to the other side. Now the formula would look something like this: <em>17,150</em> * <em>Time</em> = <em>Distance</em></p>
<p>So here we have it the formula for the distance.</p>
<pre>distance = round(distance,2)</pre>
<p>As the distance the ultrasonic waves have traveled is twice the actual distance (once for going towards the object and second for bouncing back to the sensor), we divide it by half to get the actual distance:</p>
<pre>print 'Distance = ',distance</pre>
<p>Finally, we will print the measured distance via the following statement. Anything that is in the quotation marks <kbd>'...'</kbd> will be written the way it has been written. However, <kbd>distance</kbd> is written without quotation marks, and distance is a variable. Hence, the variable stored in the distance will be written in the final output on the screen:</p>
<pre> time.sleep(0.25)</pre>
<p>The code will pause on this line for a time of 0.2 seconds. If we did not have this pause, then the values would come out at an incredible speed which would be hard for us to read or understand. If you are tinkering around, I would recommend removing this statement and running the code to see what happens. </p>


            

            
        
    </div>
<div><h1 class="header-title">Interfacing through I2C</h1>
                
            
            
                
<p>So far, so good. Electronic circuits can be very interesting and, while they seem very complex, often we find that the working can be very simple. In the previous section, we interfaced one sensor at a time. We can go ahead and interface multiple sensors, but we are limited by the number of GPIOs that are present. We have also seen that some sensors such as ultrasonic sensors may use more than one GPIO pin for their working. This further reduces the number of sensors that we can interface with the microcontroller. Once we move on to more complex circuits, we will also realize that the wiring can be really messy and if a problem occurs then finding what's wrong becomes one tedious task.</p>
<p>Now, there is an even bigger problem that we face while designing robotic systems and that's the problem of timing—all the work done in a system has to be synchronized. Most of the systems are currently sequential in nature, as in the output of one unit becomes the input of another:</p>
<div><img src="img/f4e9da61-3abb-4425-a67d-14634a6a88f7.png" style="width:69.25em;height:26.00em;"/></div>
<p>Now, for the task to be completed, the <strong>PROCESSING UNIT 1</strong> has to deliver the input to <strong>PROCESSING UNIT 2</strong> when needed, and the same goes for <strong>PROCESSING UNIT 3</strong>. If the data is not timed perfectly, then either the <strong>PROCESSING UNIT 2</strong> will keep waiting for the input from <strong>PROCESSING UNIT 1</strong> or, even worse, the <strong>PROCESSING UNIT 1</strong> will send the data to <strong>PROCESSING UNIT 2</strong> at a time when it does not need it. In which case, the data will get lost and the process will have some errors. </p>
<p>Hence, to solve this problem, the computer scientists back in the day invented a system of pulsing. The clock pulse is a very simple square wave which has a 50% duty cycle (recollect <strong>pulse width modulation</strong> (<strong>PWM</strong>)). The circuits are designed to do one operation at either the rising or the falling edge of the clock pulse. Due to this synchronization, every part of the circuit knows when to work. Here is what the clock pulse looks like:</p>
<div><img src="img/3c40905e-e2fb-4fc5-8ed3-4166e7d88381.png" style="width:43.50em;height:16.58em;"/></div>
<p>Now, coming back to the point, we have two problems:</p>
<ul>
<li>There is a physical limit to how many devices/sensors can be connected to the robot </li>
<li>How to time the sensors and interconnected circuits to work in harmony </li>
</ul>
<p>To solve these problems, we use a very commonly used protocol called <strong>I2C</strong>, which stands for <strong>Inter-integrated Circuits</strong>. This protocol is extremely useful when we need to connect multiple devices on the same set of GPIOs, such as when we have only one set of GPIO pins over which multiple sensors can be linked. This is made possible due to unique addresses allocated to each hardware. This address is used to identify a sensor and then to communicate with it accordingly. Now, to implement the I2C protocol we need two lines; these lines are as follows:</p>
<ul>
<li>Data </li>
<li>Clock</li>
</ul>
<p>As you may have guessed, the clock line is used to send a clock pulse to the devices attached to it and the data is the bus over which the data flows to and fro. </p>
<p>Now, the entire I2C architecture works on a master-slave configuration, wherein the master generates the clock signal all the time for the slave devices and the slave devices have to constantly look for the clock pulse and the data packets sent by the master devices. Let's see how it's done.</p>
<p>As mentioned earlier, there are two lines: the data line, which is referred to as <strong>Serial Data</strong> (<strong>SDA</strong>), and the clock line, which is referred to as <strong>Serial Clock</strong> (<strong>SCL</strong>). From now on, we will be using the terms SCL and SDA:</p>
<div><img src="img/79ac98a9-6665-42b3-869d-ab8e8dd49634.png" style="width:108.75em;height:24.25em;"/></div>
<p>Lets look at the main pointers shown in the diagram:</p>
<ul>
<li><strong>Start condition</strong>: To start a communication, a start condition is created indicating that the communication is about to happen. This condition is depicted by the master by keeping the SDA line low before the SCL. This indicates all the slave devices are ready for communication.</li>
<li><strong>Address frame</strong>: Once the communication is started the master sends the address of the device that needs to be communicated with. This is a 7-bit address. In every clock pulse, a bit is sent, hence it takes seven clock pulses to send the 7-bit address. After that 7-bit address is a read/write bit. This indicates to the device whether the master would like to write in this operation or if it wants to read some data. Hence, the total address frame is of 8 bits, which takes eight clock pulses to be sent. After these eight pulses, during the ninth clock pulse, the master waits for the acknowledgement from the device. This acknowledgement is sent by the slave device when the SDA line is pulled low by the slave device which is being addressed. With this strategy, the master knows that the address sent by it has been received and the slave device is now ready for the communication. If the acknowledgement is not sent back, then it is up to the master what has to be done. </li>
<li><strong>Data frame</strong>: Once the acknowledgement is sent, depending on if it is a read or write operation, the data is either written by the master onto the slave or, in read operation, the data is sent by the slave over to the master. The length of this data frame can be arbitrary.</li>
<li><strong>Stop frame</strong>: Once the data transfer is completed, the stop condition is made by the master to indicate that the communication has to stop. This condition is done when the SDA line goes from low to high after the SCL line goes from low to high. </li>
</ul>
<p class="mce-root">So this is basically how I2C communication works. For every device we have a 7-bit address, hence we can connect up to 128 devices on a single bus. That's a lot of devices. The chances of running out of physical limits is almost negligible. Now let's go ahead and see how we can connect the sensors via this protocol. Generally, it is not required to do the core programming for the I2C, as it is lengthy and cumbersome. That's where the magic of open source comes in. There are a lot of developers across the globe who are working on these sensors and most of them are generous enough to make a library and share it for ease of programming. These libraries are available online and most of them take care of the complex process of communication. </p>
<p>Now is the time that we interface our first I2C device, which is an analogue to digital converter. You must be wondering why we use this converter in the first place. Recall the time when we started understanding GPIO pins. These magic pins can be used both as input and output; you may also remember that these pins can either be on or off—these are all digital pins, not only when it comes to output but also for input. But there are a huge amount of sensors that work over analogue communication. Due to the digital architecture of Raspberry Pi, it is difficult to interface these sensors directly. Hence, we use an <strong>analogue to digital converter</strong> (<strong>ADC</strong>), this converter converts the analogue value of the sensors to the digital bits that are understandable by Raspberry Pi.</p>
<p>We will be connecting an LDR, the resistor will change the value of resistance based on how much light is falling onto it. Hence, the voltage will be dependent upon how much light is falling over the LDR. </p>
<p>Now let's see how it is practically done. Take up your Pi and let's get going. To start, firstly we need to enable I2C on our Raspberry Pi; follow the steps listed here:</p>
<ol>
<li>Open the terminal (<em>Ctrl</em> + <em>Shift</em> + <em>T</em>)</li>
<li>Type <kbd>sudo raspi-config</kbd></li>
<li>Select the interfacing options:</li>
</ol>
<div><img src="img/a243036b-6009-41a8-ada5-95c07605e486.png" style="width:39.50em;height:20.33em;"/></div>
<ol start="4">
<li>Then go to Advanced Options:</li>
</ol>
<div><img style="color: black;font-size: 1em;width:43.42em;height:18.50em;" src="img/34b9c23e-33f6-40c7-b0e5-9fb0ef4fdc08.png"/></div>
<ol start="5">
<li>Then select I2C to enable it. Then select Yes:</li>
</ol>
<div><img src="img/8576cbcc-fd1c-49a7-9770-c4b05487d6c7.png" style="width:35.58em;height:23.17em;"/></div>
<p>Now install the <kbd>adafruit</kbd> library to interface the ADC1115:</p>
<ol>
<li>Open the terminal and copy the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>sudo apt-get install build-essential python-dev python-smbus python-pip </strong></pre>
<p style="padding-left: 90px">This command downloads the libraries and the dependencies over to Raspberry Pi</p>
<ol start="2">
<li>Now type the following:</li>
</ol>
<pre style="padding-left: 60px"><strong>sudo pip install adafruit-ads1x15</strong></pre>
<p>This command installs the libraries and the dependencies over to Raspberry Pi.</p>
<p>Now that the software is set up, let's get the hardware ready. Connect Raspberry Pi to the ADS1115 as shown in the following diagram:</p>
<div><img src="img/e2d82974-e11d-48c9-9af8-c153cfc1de35.png" style="width:34.17em;height:36.33em;"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">Once you are ready, go ahead and upload this code in Pi:</p>
<pre>import time<br/>import Adafruit_ADS1x15<br/>import RPi.GPIO as GPIO<br/>LED =14<br/><br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setup(LED,GPIO.OUT)<br/><br/>adc = Adafruit_ADS1x15.ADS1115()<br/>GAIN = 1<br/>channel=0<br/>adc.start_adc(channel, gain=GAIN)<br/><br/>while True:<br/>    value = adc.get_last_result()<br/>    print(str(value))<br/>    time.sleep(0.1)<br/>    if value &gt;= 100:<br/>        GPIO.output(LED,1)<br/>    else :<br/>        GPIO.output(LED,0)<br/><br/>adc.stop_adc()</pre>
<p>Note that there can be times when this code may not work, in which case try tweaking the value of threshold:</p>
<pre>if value &gt;= 100:</pre>
<p>What you might have noticed is that whenever the LDR is faced towards a light source, the LED also switches on, and whenever it is away from light, the LED switches off. </p>
<p>So now you have interfaced an I2C device. Let's understand how this code is actually working:</p>
<pre>import Adafruit_ADS1x15</pre>
<p>The preceding line of code imports the <kbd>Adafruit_ADS1x15</kbd> library in the code so that we can use all its functions during the program.</p>
<pre>adc = Adafruit_ADS1x15.ADS1115()</pre>
<p>The preceding line of code creates the instance of the library <kbd>Adafruit_ADS1x115</kbd>. The line <kbd>.ADS1115()</kbd> is the function for creating the instance as <kbd>adc</kbd>. Understood anything? Let me put it in English. </p>
<p>Now, instead of writing <kbd>Adafruit_ADS1x15</kbd> all the time, we can simply write <kbd>adc</kbd> to call the library functions. Further, you can use any word instead of <kbd>adc</kbd>; it can be your cat's name or your neighbor's name, and it would still work:</p>
<pre>GAIN = 1</pre>
<p>This is the value to which the sensing would be done. <kbd>1</kbd> depicts that the sensing would happen in full range. Which for our ADC is from a voltage range of 0V to +/-4.096V.  Now changing the gain would result in change of the sensing range. I.e. if we change the value of gain to <kbd>2</kbd> Then the Range in which the sensing would happen would be Half of the original range i.w. 0 to +/- 2.048 Volts. <br/>
<br/>
Now you must be asking what is the voltage range and why are we changing the gain ? <br/>
<br/>
The reason is simple. There are different types of analog sensors. Which give output in a wide variety of voltage range. Some sensors can give you output in the range of 0.5 volt to 4 volt others can give you from 0.1 volt to 0.98 volts. Now if we set the gain to <kbd>1</kbd> then the all of these sensors could be easily interfaced. As all of them fall in between the sensing range of 0 to 4.098 Volts. However as it is a 16 bit ADC hence the total number of discrete values that the ADC can provide would be in between 2<sup>16</sup> or 65,536 readings. Hence at the gain of <kbd>1</kbd> the minimum voltage change that the ADC could detect would be: <em>4.096 </em>/ <em>65536</em> = <em>0.000062</em>.</p>
<p>But if increase the gain to <kbd>4</kbd> then the sensing range would reduce to a mere <kbd>0</kbd> to +/- 1.0245. So this would be able to work with the output range between 0.1 volt to 0.98 volt. But now lets see the minimum voltage change that it could detect: <em>1.0245</em> / <em>65536</em> = <em>0.00001563</em>.</p>
<p>Now as you can see the minimum voltage that can be detected is very low. Which is a good thing for the compatibility with sensor.</p>
<p>Now, it is up to you as to what gain value you want. The LDR is working on 5V, hence it is better for us to use the entire gain reading of <kbd>1</kbd>:</p>
<pre>channel=0</pre>
<p>When you look closely at the ADC hardware, you will notice that there are various pins including <strong>A0</strong>, <strong>A1</strong>, <strong>A2</strong>, and <strong>A4</strong> This is a four-channel ADC—it can convert four analogue inputs and convert them into digital data. As we are only using one single data stream, we will be letting Pi know which pin it is connected on. With the following line, we are telling Pi to start the process of converting the data:</p>
<pre>adc.start_adc(channel, gain=GAIN)</pre>
<p>In the following line, we are instructing the ADC to stop the conversion, and that's where the code ends. </p>
<pre>adc.stop_adc()</pre>


            

            
        
    </div>
<div><h1 class="header-title">Summary </h1>
                
            
            
                
<p>This chapter was all about interfacing sensors with GPIOs so that the data can be retrieved by sensors. Moving forward, in the next chapter, with the help of these learned topics, we will learn how to make a pet-feeding robot.</p>


            

            
        
    </div></body></html>