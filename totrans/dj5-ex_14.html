<html><head></head><body>
<div><h1 class="chapterNumber">14</h1>
<h1 class="chapterTitle" id="_idParaDest-368">Rendering and Caching Content</h1>
<p class="normal">In the previous chapter, you used model inheritance and generic relations to create flexible course content models. You implemented a custom model field and you built a course management system using class-based views. Finally, you created a JavaScript drag-and-drop functionality using asynchronous HTTP requests to order course modules and their contents.</p>
<p class="normal">In this chapter, you will build the functionality to create a student registration system and manage student enrollment in courses. You will implement rendering of the different types of course content and learn how to cache data using the Django cache framework.</p>
<p class="normal">Rendering diverse content types is essential in e-learning platforms, where courses are typically structured with flexible modules that include a mix of text, images, videos, and documents. In this context, caching also becomes crucial. Since course content usually remains unchanged for extended periods – days, weeks, or even months – caching helps conserve computing power and reduces the need to query the database each time students access the same materials. By caching data, you not only save system resources but also improve performance when delivering content to a large number of students.</p>
<p class="normal">In this chapter, you will:</p>
<ul>
<li class="bulletList">Create public views for displaying course information</li>
<li class="bulletList">Build a student registration system</li>
<li class="bulletList">Manage student enrollment in courses</li>
<li class="bulletList">Render diverse content for course modules</li>
<li class="bulletList">Install and configure Memcached</li>
<li class="bulletList">Cache content using the Django cache framework</li>
<li class="bulletList">Use the Memcached and Redis cache backends</li>
<li class="bulletList">Monitor your Redis server in the Django administration site</li>
</ul>
<h1 class="heading-1" id="_idParaDest-369">Functional overview</h1>
<p class="normal"><em class="italic">Figure 14.1</em> shows a representation of the views, templates, and functionalities that will be built in this chapter:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_14_01.png"/></figure>
<p class="packt_figref">Figure 14.1: Diagram of functionalities built in Chapter 14</p>
<p class="normal">In this chapter, you will implement the <code class="inlineCode">CourseListView</code> public view to list courses and <code class="inlineCode">CourseDetailView</code> to show the details of a course. You will implement <code class="inlineCode">StudentRegistrationView</code> to allow students to create user accounts and <code class="inlineCode">StudentCourseListView</code> for students to enroll in courses. You will create the <code class="inlineCode">StudentCourseListView</code> for students to see the list of courses they are enrolled in and the <code class="inlineCode">StudentCourseDetailView</code> to access all the content of a course, organized in the different course modules. You will also add a cache to your views using the Django cache framework, first with the Memcached backend and then replacing it with the Redis cache backend.</p>
<p class="normal">The source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter14">https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter14</a>.</p>
<p class="normal">All Python modules used in this chapter are included in the <code class="inlineCode">requirements.txt</code> file in the source code that comes along with this chapter. You can follow the instructions to install each Python module below or you can install all requirements at once with the <code class="inlineCode">python -m pip install -r requirements.txt</code> command.</p>
<h1 class="heading-1" id="_idParaDest-370">Displaying the catalog of courses</h1>
<p class="normal">You might be<a id="_idIndexMarker1262"/> eager to get to rendering and caching but there are a few items we must set up before we can do that. Let’s start with the course catalog. For your course catalog, you have to build the following functionalities:</p>
<ul>
<li class="bulletList">List all available courses, optionally filtered by subject</li>
<li class="bulletList">Display a single course overview</li>
</ul>
<p class="normal">This will allow students to see all the courses available on the platform and enroll in those they are interested in. Edit the <code class="inlineCode">views.py</code> file of the <code class="inlineCode">courses</code> application and add the following code:</p>
<pre class="programlisting code"><code class="hljs-code">from django.db.models import Count
from .models import Subject
class CourseListView(TemplateResponseMixin, View):
    model = Course
    template_name = 'courses/course/list.html'
def get(self, request, subject=None):
        subjects = Subject.objects.annotate(
            total_courses=Count('courses')
        )
        courses = Course.objects.annotate(
            total_modules=Count('modules')
        )
        if subject:
            subject = get_object_or_404(Subject, slug=subject)
            courses = courses.filter(subject=subject)
        return self.render_to_response(
            {
                'subjects': subjects,
                'subject': subject,
                'courses': courses
            }
        )
</code></pre>
<p class="normal">This is the <code class="inlineCode">CourseListView</code> view. It inherits from <code class="inlineCode">TemplateResponseMixin</code> and <code class="inlineCode">View</code>. In this view, the following tasks are performed:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Retrieve all subjects using the ORM’s <code class="inlineCode">annotate()</code> method with the <code class="inlineCode">Count()</code> aggregation function to include the total number of courses for each subject.</li>
<li class="numberedList">Retrieve all available courses, including the total number of modules contained in each course.</li>
<li class="numberedList">If a subject slug URL parameter is given, retrieve the corresponding <code class="inlineCode">subject</code> object and limit the query to the courses that belong to the given subject.</li>
<li class="numberedList">Use the <code class="inlineCode">render_to_response()</code> method provided by <code class="inlineCode">TemplateResponseMixin</code> to render the objects to a template and return an HTTP response.</li>
</ol>
<p class="normal">Let’s create a<a id="_idIndexMarker1263"/> detail view for displaying a single course overview. Add the following code to the <code class="inlineCode">views.py</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">from django.views.generic.detail import DetailView
class CourseDetailView(DetailView):
    model = Course
    template_name = 'courses/course/detail.html'
</code></pre>
<p class="normal">This view inherits from the generic <code class="inlineCode">DetailView</code> provided by Django. You specify the <code class="inlineCode">model</code> and <code class="inlineCode">template_name</code> attributes. Django’s <code class="inlineCode">DetailView</code> expects a primary key (<code class="inlineCode">pk</code>) or slug URL parameter to retrieve a single object for the given model. The view renders the template specified in <code class="inlineCode">template_name</code>, including the <code class="inlineCode">Course</code> object in the template context variable <code class="inlineCode">object</code>.</p>
<p class="normal">Edit the main <code class="inlineCode">urls.py</code> file of the <code class="inlineCode">educa</code> project and add the following URL pattern to it:</p>
<pre class="programlisting code"><code class="hljs-code"><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> courses.views </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> CourseListView</strong>
urlpatterns = [
    # ...
<strong class="hljs-slc">    path(</strong><strong class="hljs-string-slc">''</strong><strong class="hljs-slc">, CourseListView.as_view(), name=</strong><strong class="hljs-string-slc">'course_list'</strong><strong class="hljs-slc">),</strong>
]
</code></pre>
<p class="normal">You add the <code class="inlineCode">course_list</code> URL pattern to the main <code class="inlineCode">urls.py</code> file of the project because you want to display the list of courses in the URL <code class="inlineCode">http://127.0.0.1:8000/</code>, and all other URLs for the <code class="inlineCode">courses</code> application have the <code class="inlineCode">/course/</code> prefix.</p>
<p class="normal">Edit the <code class="inlineCode">urls.py</code> file<a id="_idIndexMarker1264"/> of the <code class="inlineCode">courses</code> application and add the following URL patterns:</p>
<pre class="programlisting code"><code class="hljs-code">path(
    'subject/&lt;slug:subject&gt;/',
    views.CourseListView.as_view(),
    name='course_list_subject'
),
path(
    '&lt;slug:slug&gt;/',
    views.CourseDetailView.as_view(),
    name='course_detail'
),
</code></pre>
<p class="normal">You define the following URL patterns:</p>
<ul>
<li class="bulletList"><code class="inlineCode">course_list_subject</code>: For displaying all courses for a subject</li>
<li class="bulletList"><code class="inlineCode">course_detail</code>: For displaying a single course overview</li>
</ul>
<p class="normal">Let’s build templates for the <code class="inlineCode">CourseListView</code> and <code class="inlineCode">CourseDetailView</code> views.</p>
<p class="normal">Create the following file structure inside the <code class="inlineCode">templates/courses/</code> directory of the <code class="inlineCode">courses</code> application:</p>
<pre class="programlisting con"><code class="hljs-con">course/
    list.html
    detail.html
</code></pre>
<p class="normal">Edit the <code class="inlineCode">courses/course/list.html</code> template of the <code class="inlineCode">courses</code> application and write the following<a id="_idIndexMarker1265"/> code:</p>
<pre class="programlisting code"><code class="hljs-code">{% extends "base.html" %}
{% block title %}
  {% if subject %}
    {{ subject.title }} courses
  {% else %}
    All courses
  {% endif %}
{% endblock %}
{% block content %}
  &lt;h1&gt;
    {% if subject %}
      {{ subject.title }} courses
    {% else %}
      All courses
    {% endif %}
  &lt;/h1&gt;
&lt;div class="contents"&gt;
&lt;h3&gt;Subjects&lt;/h3&gt;
&lt;ul id="modules"&gt;
&lt;li {% if not subject %}class="selected"{% endif %}&gt;
&lt;a href="{% url "course_list" %}"&gt;All&lt;/a&gt;
&lt;/li&gt;
      {% for s in subjects %}
        &lt;li {% if subject == s %}class="selected"{% endif %}&gt;
&lt;a href="{% url "course_list_subject" s.slug %}"&gt;
            {{ s.title }}
            &lt;br&gt;
&lt;span&gt;
              {{ s.total_courses }} course{{ s.total_courses|pluralize }}
            &lt;/span&gt;
&lt;/a&gt;
&lt;/li&gt;
      {% endfor %}
    &lt;/ul&gt;
&lt;/div&gt;
&lt;div class="module"&gt;
    {% for course in courses %}
      {% with subject=course.subject %}
        &lt;h3&gt;
&lt;a href="{% url "course_detail" course.slug %}"&gt;
            {{ course.title }}
          &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;
&lt;a href="{% url "course_list_subject" subject.slug %}"&gt;{{ subject }}&lt;/a&gt;.
            {{ course.total_modules }} modules.
            Instructor: {{ course.owner.get_full_name }}
        &lt;/p&gt;
      {% endwith %}
    {% endfor %}
  &lt;/div&gt;
{% endblock %}
</code></pre>
<p class="normal">Make sure that no<a id="_idIndexMarker1266"/> template tag is split into multiple lines.</p>
<p class="normal">This is the template for listing the available courses. You create an HTML list to display all <code class="inlineCode">Subject</code> objects and build a link to the <code class="inlineCode">course_list_subject</code> URL for each of them. You also include the total number of courses for each subject and use the <code class="inlineCode">pluralize</code> template filter to add a plural suffix to the word <strong class="screenText">course</strong> when the number is different than <code class="inlineCode">1</code>, to show <em class="italic">0 courses</em>, <em class="italic">1 course</em>, <em class="italic">2 courses</em>, etc. You add a <code class="inlineCode">selected</code> HTML class to highlight the current subject if a subject is selected. You iterate over every <code class="inlineCode">Course</code> object, displaying the total number of modules and the instructor’s name.</p>
<p class="normal">Run the development server and open <code class="inlineCode">http://127.0.0.1:8000/</code> in your browser. You should see a page similar to the following one:</p>
<figure class="mediaobject"><img alt="Graphical user interface, text, application  Description automatically generated" src="img/B21088_14_02.png"/></figure>
<p class="packt_figref">Figure 14.2: The course list page</p>
<p class="normal">The left sidebar<a id="_idIndexMarker1267"/> contains all subjects, including the total number of courses for each of them. You can click any subject to filter the courses displayed.</p>
<p class="normal">Edit the <code class="inlineCode">courses/course/detail.html</code> template and add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">{% extends "base.html" %}
{% block title %}
  {{ object.title }}
{% endblock %}
{% block content %}
  {% with subject=object.subject %}
    &lt;h1&gt;
      {{ object.title }}
    &lt;/h1&gt;
&lt;div class="module"&gt;
&lt;h2&gt;Overview&lt;/h2&gt;
&lt;p&gt;
&lt;a href="{% url "course_list_subject" subject.slug %}"&gt;
        {{ subject.title }}&lt;/a&gt;.
        {{ object.modules.count }} modules.
        Instructor: {{ object.owner.get_full_name }}
      &lt;/p&gt;
      {{ object.overview|linebreaks }}
    &lt;/div&gt;
  {% endwith %}
{% endblock %}
</code></pre>
<p class="normal">This template displays the overview and details for a single course. Open <code class="inlineCode">http://127.0.0.1:8000/</code> in your browser and click on one of the courses. You should see a page with<a id="_idIndexMarker1268"/> the following structure:</p>
<figure class="mediaobject"><img alt="A picture containing text  Description automatically generated" src="img/B21088_14_03.png"/></figure>
<p class="packt_figref">Figure 14.3: The course overview page</p>
<p class="normal">You have created <a id="_idIndexMarker1269"/>a public area for displaying courses. Next, you need to allow users to register as students and enroll in courses.</p>
<h1 class="heading-1" id="_idParaDest-371">Adding student registration</h1>
<p class="normal">We need to implement <a id="_idIndexMarker1270"/>student registration to enable enrollment in courses and access to content. Create a new application using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py startapp students
</code></pre>
<p class="normal">Edit the <code class="inlineCode">settings.py</code> file of the <code class="inlineCode">educa</code> project and add the new application to the <code class="inlineCode">INSTALLED_APPS</code> setting, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">INSTALLED_APPS = [
    # ...
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'students.apps.StudentsConfig'</strong><strong class="hljs-slc">,</strong>
]
</code></pre>
<h2 class="heading-2" id="_idParaDest-372">Creating a student registration view</h2>
<p class="normal">Edit the <code class="inlineCode">views.py</code> file <a id="_idIndexMarker1271"/>of the <code class="inlineCode">students</code> application and write the following code:</p>
<pre class="programlisting code"><code class="hljs-code">from django.contrib.auth import authenticate, login
from django.contrib.auth.forms import UserCreationForm
from django.urls import reverse_lazy
from django.views.generic.edit import CreateView
class StudentRegistrationView(CreateView):
    template_name = 'students/student/registration.html'
    form_class = UserCreationForm
    success_url = reverse_lazy('student_course_list')
    def form_valid(self, form):
        result = super().form_valid(form)
        cd = form.cleaned_data
        user = authenticate(
            username=cd['username'], password=cd['password1']
        )
        login(self.request, user)
        return result
</code></pre>
<p class="normal">This is the view that allows students to register on your site. You use the generic <code class="inlineCode">CreateView</code>, which provides the functionality for creating model objects. This view requires the following attributes:</p>
<ul>
<li class="bulletList"><code class="inlineCode">template_name</code>: The path of the template to render this view.</li>
<li class="bulletList"><code class="inlineCode">form_class</code>: The form for creating objects, which has to be <code class="inlineCode">ModelForm</code>. You use Django’s <code class="inlineCode">UserCreationForm</code> as the registration form to create <code class="inlineCode">User</code> objects.</li>
<li class="bulletList"><code class="inlineCode">success_url</code>: The URL to redirect the user to when the form is successfully submitted. For this, you reverse the URL named <code class="inlineCode">student_course_list</code>, which we will create in the <em class="italic">Accessing the course contents</em> section for listing the courses that students are enrolled in.</li>
</ul>
<p class="normal">The <code class="inlineCode">form_valid()</code> method is executed when valid form data has been posted. It has to return an HTTP response. You override this method to log the user in after they have successfully signed up.</p>
<p class="normal">Create a new file<a id="_idIndexMarker1272"/> inside the <code class="inlineCode">students</code> application directory and name it <code class="inlineCode">urls.py</code>. Add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">from django.urls import path
from . import views
urlpatterns = [
    path(
        'register/',
        views.StudentRegistrationView.as_view(),
        name='student_registration'
    ),
]
</code></pre>
<p class="normal">Then, edit the main <code class="inlineCode">urls.py</code> of the <code class="inlineCode">educa</code> project and include the URLs for the <code class="inlineCode">students</code> application by adding the following pattern to your URL configuration:</p>
<pre class="programlisting code"><code class="hljs-code">urlpatterns = [
    # ...
<strong class="hljs-slc">    path(</strong><strong class="hljs-string-slc">'students/'</strong><strong class="hljs-slc">, include(</strong><strong class="hljs-string-slc">'students.urls'</strong><strong class="hljs-slc">)),</strong>
]
</code></pre>
<p class="normal">Create the following file structure inside the <code class="inlineCode">students</code> application directory:</p>
<pre class="programlisting con"><code class="hljs-con">templates/
    students/
        student/
            registration.html
</code></pre>
<p class="normal">Edit the <code class="inlineCode">students/student/registration.html</code> template and add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">{% extends "base.html" %}
{% block title %}
  Sign up
{% endblock %}
{% block content %}
  &lt;h1&gt;
    Sign up
  &lt;/h1&gt;
&lt;div class="module"&gt;
&lt;p&gt;Enter your details to create an account:&lt;/p&gt;
&lt;form method="post"&gt;
      {{ form.as_p }}
      {% csrf_token %}
      &lt;p&gt;&lt;input type="submit" value="Create my account"&gt;&lt;/p&gt;
&lt;/form&gt;
&lt;/div&gt;
{% endblock %}
</code></pre>
<p class="normal">Run the<a id="_idIndexMarker1273"/> development server and open <code class="inlineCode">http://127.0.0.1:8000/students/register/</code> in your browser. You should see a registration form like this:</p>
<figure class="mediaobject"><img alt="Graphical user interface, text, application, email  Description automatically generated" src="img/B21088_14_04.png"/></figure>
<p class="packt_figref">Figure 14.4: The student registration form</p>
<p class="normal">Note that<a id="_idIndexMarker1274"/> the <code class="inlineCode">student_course_list</code> URL specified in the <code class="inlineCode">success_url</code> attribute of the <code class="inlineCode">StudentRegistrationView</code> view doesn’t exist yet. If you submit the form, Django won’t find the URL to redirect you to after a successful registration. As <a id="_idIndexMarker1275"/>mentioned, you will create this URL in the <em class="italic">Accessing the course contents</em> section.</p>
<h2 class="heading-2" id="_idParaDest-373">Enrolling in courses</h2>
<p class="normal">After users<a id="_idIndexMarker1276"/> create an account, they should be able to enroll in courses. To store enrollments, you need to create a many-to-many relationship between the <code class="inlineCode">Course</code> and <code class="inlineCode">User</code> models.</p>
<p class="normal">Edit the <code class="inlineCode">models.py</code> file of the <code class="inlineCode">courses</code> application and add the following field to the <code class="inlineCode">Course</code> model:</p>
<pre class="programlisting code"><code class="hljs-code">students = models.ManyToManyField(
    User,
    related_name='courses_joined',
    blank=True
)
</code></pre>
<p class="normal">From the shell, execute the following command to create a migration for this change:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py makemigrations
</code></pre>
<p class="normal">You will see output similar to this:</p>
<pre class="programlisting con"><code class="hljs-con">Migrations for 'courses':
  courses/migrations/0004_course_students.py
    - Add field students to course
</code></pre>
<p class="normal">Then, execute the next command to apply pending migrations:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py migrate
</code></pre>
<p class="normal">You should see some output that ends with the following line:</p>
<pre class="programlisting con"><code class="hljs-con">Applying courses.0004_course_students... OK
</code></pre>
<p class="normal">You can now associate students with the courses in which they are enrolled. Let’s create the functionality for students to enroll in courses.</p>
<p class="normal">Create a new file inside the <code class="inlineCode">students</code> application directory and name it <code class="inlineCode">forms.py</code>. Add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">from django import forms
from courses.models import Course
class CourseEnrollForm(forms.Form):
    course = forms.ModelChoiceField(
        queryset=Course.objects.none(),
        widget=forms.HiddenInput
    )
    def __init__ (self, form):
        super(CourseEnrollForm, self).__init__(*args, **kwargs)
        self.fields['course'].queryset = Course.objects.all()
</code></pre>
<p class="normal">This form will be used to enroll students in courses. The <code class="inlineCode">course</code> field is for the course in which the user will be enrolled; therefore, it’s <code class="inlineCode">ModelChoiceField</code>. You use a <code class="inlineCode">HiddenInput</code> widget because this field is not intended to be visible to the user. Initially, you define the QuerySet as <code class="inlineCode">Course.objects.none()</code>. Using <code class="inlineCode">none()</code> creates an empty QuerySet that does not return any objects and, importantly, does not query the database. This avoids unnecessary database load during form initialization. You populate the actual QuerySet in the <code class="inlineCode">__init__()</code> method of the form. This dynamic setting allows you to adapt the form to different situations, such as filtering available courses based on <a id="_idIndexMarker1277"/>specific criteria. Overall, this approach gives you greater flexibility in managing form data, ensuring that data is fetched based on the context in which the form is used. This method also aligns with best practices in Django for handling form QuerySets efficiently.</p>
<p class="normal">You are going to use this form in the <code class="inlineCode">CourseDetailView</code> view to display a button to enroll. Edit the <code class="inlineCode">views.py</code> file of the <code class="inlineCode">students</code> application and add the following code:</p>
<pre class="programlisting code"><code class="hljs-code">from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic.edit import FormView
from .forms import CourseEnrollForm
class StudentEnrollCourseView(LoginRequiredMixin, FormView):
    course = None
    form_class = CourseEnrollForm
    def form_valid(self, form):
        self.course = form.cleaned_data['course']
        self.course.students.add(self.request.user)
        return super().form_valid(form)
    def get_success_url(self):
        return reverse_lazy(
            'student_course_detail', args=[self.course.id]
        )
</code></pre>
<p class="normal">This is the <code class="inlineCode">StudentEnrollCourseView</code> view. It handles the enrollment of students in courses. The view inherits from the <code class="inlineCode">LoginRequiredMixin</code> mixin so that only logged-in users can access the view. It also inherits from Django’s <code class="inlineCode">FormView</code> view, since it handles a form submission. You use the <code class="inlineCode">CourseEnrollForm</code> form for the <code class="inlineCode">form_class</code> attribute and also define a <code class="inlineCode">course</code> attribute for storing the given <code class="inlineCode">Course</code> object. When the form is valid, the current user is added to the students enrolled in the course.</p>
<p class="normal">The <code class="inlineCode">get_success_url()</code> method returns the URL that the user will be redirected to if the form was successfully submitted. This method is equivalent to the <code class="inlineCode">success_url</code> attribute. Then, you reverse the URL named <code class="inlineCode">student_course_detail</code>.</p>
<p class="normal">Edit the <code class="inlineCode">urls.py</code> file <a id="_idIndexMarker1278"/>of the <code class="inlineCode">students</code> application and add the following URL pattern to it:</p>
<pre class="programlisting code"><code class="hljs-code">path(
    'enroll-course/',
    views.StudentEnrollCourseView.as_view(),
    name='student_enroll_course'
),
</code></pre>
<p class="normal">Let’s add the enroll button form to the course overview page. Edit the <code class="inlineCode">views.py</code> file of the <code class="inlineCode">courses</code> application and modify <code class="inlineCode">CourseDetailView</code> to make it look as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> students.forms </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> CourseEnrollForm</strong>
class CourseDetailView(DetailView):
    model = Course
    template_name = 'courses/course/detail.html'
<strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">def</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">get_context_data</strong><strong class="hljs-slc">(</strong><strong class="hljs-params-slc">self, **kwargs</strong><strong class="hljs-slc">):</strong>
<strong class="hljs-slc">        context = </strong><strong class="hljs-built_in-slc">super</strong><strong class="hljs-slc">().get_context_data(**kwargs)</strong>
<strong class="hljs-slc">        context[</strong><strong class="hljs-string-slc">'enroll_form'</strong><strong class="hljs-slc">] = CourseEnrollForm(</strong>
<strong class="hljs-slc">            initial={</strong><strong class="hljs-string-slc">'course'</strong><strong class="hljs-slc">:self.</strong><strong class="hljs-built_in-slc">object</strong><strong class="hljs-slc">}</strong>
<strong class="hljs-slc">        )</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> context</strong>
</code></pre>
<p class="normal">You use the <code class="inlineCode">get_context_data()</code> method to include the enrollment form in the context for rendering the templates. You initialize the hidden <code class="inlineCode">course</code> field of the form with the current <code class="inlineCode">Course</code> object so that it can be submitted directly.</p>
<p class="normal">Edit the <code class="inlineCode">courses/course/detail.html</code> template and locate the following line:</p>
<pre class="programlisting code"><code class="hljs-code">{{ object.overview|linebreaks }}
</code></pre>
<p class="normal">Replace it with the following code:</p>
<pre class="programlisting code"><code class="hljs-code">{{ object.overview|linebreaks }}
<strong class="hljs-slc">{% </strong><strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> request.user.is_authenticated %}</strong>
<strong class="hljs-slc">  &lt;form action=</strong><strong class="hljs-string-slc">"{% url "</strong><strong class="hljs-slc">student_enroll_course</strong><strong class="hljs-string-slc">" %}"</strong><strong class="hljs-slc"> method=</strong><strong class="hljs-string-slc">"post"</strong><strong class="hljs-slc">&gt;</strong>
<strong class="hljs-slc">    {{ enroll_form }}</strong>
<strong class="hljs-slc">    {% csrf_token %}</strong>
<strong class="hljs-slc">    &lt;</strong><strong class="hljs-built_in-slc">input</strong><strong class="hljs-slc"> </strong><strong class="hljs-built_in-slc">type</strong><strong class="hljs-slc">=</strong><strong class="hljs-string-slc">"submit"</strong><strong class="hljs-slc"> value=</strong><strong class="hljs-string-slc">"Enroll now"</strong><strong class="hljs-slc">&gt;</strong>
<strong class="hljs-slc">  &lt;/form&gt;</strong>
<strong class="hljs-slc">{% </strong><strong class="hljs-keyword-slc">else</strong><strong class="hljs-slc"> %}</strong>
<strong class="hljs-slc">  &lt;a href=</strong><strong class="hljs-string-slc">"{% url "</strong><strong class="hljs-slc">student_registration</strong><strong class="hljs-string-slc">" %}"</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">class</strong><strong class="hljs-slc">=</strong><strong class="hljs-string-slc">"button"</strong><strong class="hljs-slc">&gt;</strong>
<strong class="hljs-slc">    Register to enroll</strong>
<strong class="hljs-slc">  &lt;/a&gt;</strong>
<strong class="hljs-slc">{% endif %}</strong>
</code></pre>
<p class="normal">This is the button <a id="_idIndexMarker1279"/>for enrolling in courses. If the user is authenticated, the enrollment button is displayed, including the hidden form that points to the <code class="inlineCode">student_enroll_course</code> URL. If the user is not authenticated, a link to register on the platform will be displayed instead.</p>
<p class="normal">Make sure that the development server is running, open <code class="inlineCode">http://127.0.0.1:8000/</code> in your browser, and click a course. If you are logged in, you should see an <strong class="screenText">ENROLL NOW</strong> button placed below the course overview, as follows:</p>
<figure class="mediaobject"><img alt="Graphical user interface, text, application, email  Description automatically generated" src="img/B21088_14_05.png"/></figure>
<p class="packt_figref">Figure 14.5: The course overview page, including an ENROLL NOW button</p>
<p class="normal">If you are <a id="_idIndexMarker1280"/>not logged in, you will see a <strong class="screenText">REGISTER TO ENROLL</strong> button instead.</p>
<h1 class="heading-1" id="_idParaDest-374">Rendering course contents</h1>
<p class="normal">Once students are <a id="_idIndexMarker1281"/>enrolled in courses, they need a central location to access all courses they are signed up for. We need to compile the list of courses the student is enrolled in and provide access to the contents of each course. Then, we need to implement a system to render various types of content, such as text, images, videos and documents, which make up the course modules. Let’s build the necessary views and templates for users to access course contents.</p>
<h2 class="heading-2" id="_idParaDest-375">Accessing course contents</h2>
<p class="normal">You need a view <a id="_idIndexMarker1282"/>for displaying the courses that students are enrolled in and a view for accessing the actual course contents. Edit the <code class="inlineCode">views.py</code> file of the <code class="inlineCode">students</code> application and add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">from django.views.generic.list import ListView
from courses.models import Course
class StudentCourseListView(LoginRequiredMixin, ListView):
    model = Course
    template_name = 'students/course/list.html'
def get_queryset(self):
        qs = super().get_queryset()
        return qs.filter(students__in=[self.request.user])
</code></pre>
<p class="normal">This is the view to see courses that students are enrolled in. It inherits from <code class="inlineCode">LoginRequiredMixin</code> to make sure that only logged-in users can access the view. It also inherits from the generic <code class="inlineCode">ListView</code> for displaying a list of <code class="inlineCode">Course</code> objects. You override the <code class="inlineCode">get_queryset()</code> method to retrieve only the courses that a student is enrolled in; you filter the QuerySet by the student’s <code class="inlineCode">ManyToManyField</code> field to do so.</p>
<p class="normal">Then, add the following code to the <code class="inlineCode">views.py</code> file of the <code class="inlineCode">students</code> application:</p>
<pre class="programlisting code"><code class="hljs-code">from django.views.generic.detail import DetailView
class StudentCourseDetailView(LoginRequiredMixin, DetailView):
    model = Course
    template_name = 'students/course/detail.html'
def get_queryset(self):
        qs = super().get_queryset()
        return qs.filter(students__in=[self.request.user])
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        # get course object
        course = self.get_object()
        if 'module_id' in self.kwargs:
            # get current module
            context['module'] = course.modules.get(
                id=self.kwargs['module_id']
            )
        else:
            # get first module
            context['module'] = course.modules.all()[0]
        return context
</code></pre>
<p class="normal">This is the <code class="inlineCode">StudentCourseDetailView</code> view. You override the <code class="inlineCode">get_queryset()</code> method to limit the base QuerySet to courses in which the student is enrolled. You also override the <code class="inlineCode">get_context_data()</code> method<a id="_idIndexMarker1283"/> to set a course module in the context if the <code class="inlineCode">module_id</code> URL parameter is given. Otherwise, you set the first module of the course. This way, enrolled students will be able to navigate through modules inside a course.</p>
<p class="normal">Edit the <code class="inlineCode">urls.py</code> file of the <code class="inlineCode">students</code> application and add the following URL patterns to it:</p>
<pre class="programlisting code"><code class="hljs-code">path(
    'courses/',
    views.StudentCourseListView.as_view(),
    name='student_course_list'
),
path(
    'course/&lt;pk&gt;/',
    views.StudentCourseDetailView.as_view(),
    name='student_course_detail'
),
path(
    'course/&lt;pk&gt;/&lt;module_id&gt;/',
    views.StudentCourseDetailView.as_view(),
    name='student_course_detail_module'
),
</code></pre>
<p class="normal">Create the following file structure inside the <code class="inlineCode">templates/students/</code> directory of the <code class="inlineCode">students</code> application:</p>
<pre class="programlisting con"><code class="hljs-con">course/
    detail.html
    list.html
</code></pre>
<p class="normal">Edit <a id="_idIndexMarker1284"/>the <code class="inlineCode">students/course/list.html</code> template and add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">{% extends "base.html" %}
{% block title %}My courses{% endblock %}
{% block content %}
  &lt;h1&gt;My courses&lt;/h1&gt;
&lt;div class="module"&gt;
    {% for course in object_list %}
      &lt;div class="course-info"&gt;
&lt;h3&gt;{{ course.title }}&lt;/h3&gt;
&lt;p&gt;&lt;a href="{% url "student_course_detail" course.id %}"&gt;
        Access contents&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
    {% empty %}
      &lt;p&gt;
        You are not enrolled in any courses yet.
        &lt;a href="{% url "course_list" %}"&gt;Browse courses&lt;/a&gt;
        to enroll in a course.
      &lt;/p&gt;
    {% endfor %}
  &lt;/div&gt;
{% endblock %}
</code></pre>
<p class="normal">This template displays the courses that the student is enrolled in. Remember that when a new student successfully registers with the platform, they will be redirected to the <code class="inlineCode">student_course_list</code> URL. Let’s also redirect students to this URL when they log in to the platform.</p>
<p class="normal">Edit the <code class="inlineCode">settings.py</code> file of the <code class="inlineCode">educa</code> project and add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">from django.urls import reverse_lazy
LOGIN_REDIRECT_URL = reverse_lazy('student_course_list')
</code></pre>
<p class="normal">This is the setting used by the <code class="inlineCode">auth</code> module to redirect the student after a successful login if no <code class="inlineCode">next</code> parameter is present in the request. After a successful login, a student will be redirected to the <code class="inlineCode">student_course_list</code> URL to view the courses that they are enrolled in.</p>
<p class="normal">Edit<a id="_idIndexMarker1285"/> the <code class="inlineCode">students/course/detail.html</code> template and add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">{% extends "base.html" %}
{% block title %}
  {{ object.title }}
{% endblock %}
{% block content %}
  &lt;h1&gt;
    {{ module.title }}
  &lt;/h1&gt;
&lt;div class="contents"&gt;
&lt;h3&gt;Modules&lt;/h3&gt;
&lt;ul id="modules"&gt;
      {% for m in object.modules.all %}
        &lt;li data-id="{{ m.id }}" {% if m == module %}class="selected"{% endif %}&gt;
&lt;a href="{% url "student_course_detail_module" object.id m.id %}"&gt;
&lt;span&gt;
              Module &lt;span class="order"&gt;{{ m.order|add:1 }}&lt;/span&gt;
&lt;/span&gt;
&lt;br&gt;
            {{ m.title }}
          &lt;/a&gt;
&lt;/li&gt;
      {% empty %}
        &lt;li&gt;No modules yet.&lt;/li&gt;
      {% endfor %}
    &lt;/ul&gt;
&lt;/div&gt;
&lt;div class="module"&gt;
    {% for content in module.contents.all %}
      {% with item=content.item %}
        &lt;h2&gt;{{ item.title }}&lt;/h2&gt;
        {{ item.render }}
      {% endwith %}
    {% endfor %}
  &lt;/div&gt;
{% endblock %}
</code></pre>
<p class="normal">Make sure no template tag is split across multiple lines. This is the template for enrolled students to access the contents of a course. First, you build an HTML list including all course modules and highlighting the current module. Then, you iterate over the current module contents and access each content item to display it using <code class="inlineCode">{{ item.render }}</code>. You will add the <code class="inlineCode">render()</code> method to the content models next. This method will take care of rendering the content properly.</p>
<p class="normal">You can now <a id="_idIndexMarker1286"/>access <code class="inlineCode">http://127.0.0.1:8000/students/register/</code>, register a new student account, and enroll in any course.</p>
<h2 class="heading-2" id="_idParaDest-376">Rendering different types of content</h2>
<p class="normal">To display the <a id="_idIndexMarker1287"/>course contents, you need to render the different content types that you created: <em class="italic">text</em>, <em class="italic">image</em>, <em class="italic">video</em>, and <em class="italic">file</em>.</p>
<p class="normal">Edit the <code class="inlineCode">models.py</code> file of the <code class="inlineCode">courses</code> application and add the following <code class="inlineCode">render()</code> method to the <code class="inlineCode">ItemBase</code> model:</p>
<pre class="programlisting code"><code class="hljs-code"><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> django.template.loader </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> render_to_string</strong>
class ItemBase(models.Model):
    # ...
<strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">def</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">render</strong><strong class="hljs-slc">(</strong><strong class="hljs-params-slc">self</strong><strong class="hljs-slc">):</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> render_to_string(</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">f'courses/content/</strong><strong class="hljs-subst-slc">{self._meta.model_name}</strong><strong class="hljs-string-slc">.html'</strong><strong class="hljs-slc">,</strong>
<strong class="hljs-slc">            {</strong><strong class="hljs-string-slc">'item'</strong><strong class="hljs-slc">: self}</strong>
<strong class="hljs-slc">        )</strong>
</code></pre>
<p class="normal">This method uses the <code class="inlineCode">render_to_string()</code> function for rendering a template and returning the rendered content as a string. Each kind of content is rendered using a template named after the content model. <code class="inlineCode">self._meta.model_name</code> is used to generate the appropriate template name for each content model dynamically. The <code class="inlineCode">render()</code> method provides a common interface for rendering diverse content.</p>
<p class="normal">Create the following file structure inside the <code class="inlineCode">templates/courses/</code> directory of the <code class="inlineCode">courses</code> application:</p>
<pre class="programlisting con"><code class="hljs-con">content/
    text.html
    file.html
    image.html
    video.html
</code></pre>
<p class="normal">Edit the <code class="inlineCode">courses/content/text.html</code> template and write this code:</p>
<pre class="programlisting code"><code class="hljs-code">{{ item.content|linebreaks }}
</code></pre>
<p class="normal">This is the <a id="_idIndexMarker1288"/>template to render text content. The <code class="inlineCode">linebreaks</code> template filter replaces line breaks in plain text with HTML line breaks.</p>
<p class="normal">Edit the <code class="inlineCode">courses/content/file.html</code> template and add the following:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;p&gt;
&lt;a href="{{ item.file.url }}" class="button"&gt;Download file&lt;/a&gt;
&lt;/p&gt;
</code></pre>
<p class="normal">This is the template to render files. It generates a link to download the file.</p>
<p class="normal">Edit the <code class="inlineCode">courses/content/image.html</code> template and write:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;p&gt;
&lt;img src="img/{{ item.file.url }}" alt="{{ item.title }}"&gt;
&lt;/p&gt;
</code></pre>
<p class="normal">This is the template to render images.</p>
<p class="normal">You also have to create a template for rendering <code class="inlineCode">Video</code> objects. You will use <code class="inlineCode">django-embed-video</code> for embedding video content. <code class="inlineCode">django-embed-video</code> is a third-party Django application that allows you to embed videos in your templates, from sources such as YouTube or Vimeo, by simply providing their public URL.</p>
<p class="normal">Install the package with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python -m pip install django-embed-video==1.4.9
</code></pre>
<p class="normal">Edit the <code class="inlineCode">settings.py</code> file of your project and add the application to the <code class="inlineCode">INSTALLED_APPS</code> setting, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">INSTALLED_APPS = [
    # ...
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'embed_video'</strong><strong class="hljs-slc">,</strong>
]
</code></pre>
<p class="normal">You can find the <code class="inlineCode">django-embed-video</code> application’s documentation at <a href="https://django-embed-video.readthedocs.io/en/latest/. ">https://django-embed-video.readthedocs.io/en/latest/.</a></p>
<p class="normal">Edit the <code class="inlineCode">courses/content/video.html</code> template and write the following code:</p>
<pre class="programlisting code"><code class="hljs-code">{% load embed_video_tags %}
{% video item.url "small" %}
</code></pre>
<p class="normal">This is the template to render videos.</p>
<p class="normal">Now, run the development server and access <code class="inlineCode">http://127.0.0.1:8000/course/mine/</code> in your browser. Access the site with a user that belongs to the <code class="inlineCode">Instructors</code> group, and add multiple contents to a course. To include video content, you can just copy any YouTube URL, such as <code class="inlineCode">https://www.youtube.com/watch?v=bgV39DlmZ2U</code>, and include it in the <code class="inlineCode">url</code> field of the form.</p>
<p class="normal">After adding contents to the course, open <code class="inlineCode">http://127.0.0.1:8000/</code>, click the course, and click on the <strong class="screenText">ENROLL NOW</strong> button. You should be enrolled in the course and redirected to the <code class="inlineCode">student_course_detail</code> URL. <em class="italic">Figure 14.6</em> shows a sample course contents page:</p>
<figure class="mediaobject"><img alt="Graphical user interface, application, website  Description automatically generated" src="img/B21088_14_06.png"/></figure>
<p class="packt_figref">Figure 14.6: A course contents page</p>
<p class="normal">Great! You have<a id="_idIndexMarker1290"/> created a common interface for rendering courses with different types of content.</p>
<h1 class="heading-1" id="_idParaDest-377">Using the cache framework</h1>
<p class="normal">Processing HTTP requests to<a id="_idIndexMarker1291"/> your web application usually entails database access, data manipulation, and template rendering. It is much more expensive in terms of processing than just serving a static website. The overhead in some requests can be significant when your site starts getting more and more traffic. This is where caching becomes essential. By caching queries, calculation results, or rendered content in an HTTP request, you will avoid expensive operations in the following requests that need to return the same data. This translates into shorter response times and less processing on the server side.</p>
<p class="normal">Django includes a robust cache system that allows you to cache data with different levels of granularity. You can cache a single query, the output of a specific view, parts of rendered template content, or your entire site. Items are stored in the cache system for a default time, but you can specify the timeout when you cache data.</p>
<p class="normal">This is how the cache framework is usually used when your application processes an HTTP request:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Try to find the requested data in the cache.</li>
<li class="numberedList">If found, return the cached data.</li>
<li class="numberedList">If not found, perform the following steps:<ol class="alphabeticList" style="list-style-type: lower-alpha;">
<li class="alphabeticList" value="1">Perform the database query or processing required to generate the data.</li>
<li class="alphabeticList">Save the generated data in the cache.</li>
<li class="alphabeticList">Return the data.</li>
</ol>
</li>
</ol>
<p class="normal">You can read<a id="_idIndexMarker1292"/> detailed information about Django’s cache system at <a href="https://docs.djangoproject.com/en/5.0/topics/cache/">https://docs.djangoproject.com/en/5.0/topics/cache/</a>.</p>
<h2 class="heading-2" id="_idParaDest-378">Available cache backends</h2>
<p class="normal">Django comes with<a id="_idIndexMarker1293"/> the following cache backends:</p>
<ul>
<li class="bulletList"><code class="inlineCode">backends.memcached.PyMemcacheCache</code> or <code class="inlineCode">backends.memcached.PyLibMCCache</code>: Memcached backends. Memcached is a fast and efficient memory-based cache server. The backend to use depends on the Memcached Python bindings you choose.</li>
<li class="bulletList"><code class="inlineCode">backends.redis.RedisCache</code>: A Redis cache backend. This backend was added in Django 4.0.</li>
<li class="bulletList"><code class="inlineCode">backends.db.DatabaseCache</code>: Uses the database as a cache system.</li>
<li class="bulletList"><code class="inlineCode">backends.filebased.FileBasedCache</code>: Uses the file storage system. This serializes and stores each cache value as a separate file.</li>
<li class="bulletList"><code class="inlineCode">backends.locmem.LocMemCache</code>: A local memory cache backend. This is the default cache backend.</li>
<li class="bulletList"><code class="inlineCode">backends.dummy.DummyCache</code>: A dummy cache backend intended only for development. It implements the cache interface without actually caching anything. This cache is per-process and thread-safe.</li>
</ul>
<div><p class="normal">For optimal performance, use a memory-based cache backend like Memcached or Redis, since <a id="_idIndexMarker1294"/>accessing memory is faster than accessing data from databases of files.</p>
</div>
<h1 class="heading-1" id="_idParaDest-379">Installing Memcached</h1>
<p class="normal">Memcached is <a id="_idIndexMarker1295"/>a popular high-performance, memory-based cache server. We are going to use Memcached and the <code class="inlineCode">PyMemcacheCache</code> Memcached backend.</p>
<h2 class="heading-2" id="_idParaDest-380">Installing the Memcached Docker image</h2>
<p class="normal">Run the following <a id="_idIndexMarker1296"/>command from the shell to pull the Memcached Docker image:</p>
<pre class="programlisting con"><code class="hljs-con">docker pull memcached:1.6.26
</code></pre>
<p class="normal">This will download the Memcached Docker image to your local machine. You can find more information about the official Memcached Docker image at <a href="https://hub.docker.com/_/memcached">https://hub.docker.com/_/memcached</a>. If you don’t want to use Docker, you can also download Memcached from <a href="https://memcached.org/downloads">https://memcached.org/downloads</a>.</p>
<p class="normal">Run the Memcached Docker container with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker run -it --rm --name memcached -p 11211:11211 memcached:1.6.26 -m 64
</code></pre>
<p class="normal">Memcached runs on port <code class="inlineCode">11211</code> by default. The <code class="inlineCode">-p</code> option is used to publish the <code class="inlineCode">11211</code> port to the same host interface port. The <code class="inlineCode">-m</code> option is used to limit the memory for the container to <code class="inlineCode">64</code> MB. Memcached runs in memory, and it is allotted a specified amount of RAM. When the allotted RAM is full, Memcached starts removing the oldest data to store new data. If you want to run the command in detached mode (in the background of your terminal), you can use the <code class="inlineCode">-d</code> option.</p>
<p class="normal">You can find more information about Memcached at <a href="https://memcached.org">https://memcached.org</a>.</p>
<h2 class="heading-2" id="_idParaDest-381">Installing the Memcached Python binding</h2>
<p class="normal">After installing<a id="_idIndexMarker1297"/> Memcached, you have to install a Memcached Python binding. We will install <code class="inlineCode">pymemcache</code>, which is a fast, pure-Python Memcached client. Run the following command in the shell:</p>
<pre class="programlisting con"><code class="hljs-con">python -m pip install pymemcache==4.0.0
</code></pre>
<p class="normal">You can read more information about the <code class="inlineCode">pymemcache</code> library at <a href="https://github.com/pinterest/pymemcache">https://github.com/pinterest/pymemcache</a>.</p>
<h1 class="heading-1" id="_idParaDest-382">Django cache settings</h1>
<p class="normal">Django provides <a id="_idIndexMarker1298"/>the following cache settings:</p>
<ul>
<li class="bulletList"><code class="inlineCode">CACHES</code>: A dictionary containing all available caches for the project.</li>
<li class="bulletList"><code class="inlineCode">CACHE_MIDDLEWARE_ALIAS</code>: The cache alias to use for storage.</li>
<li class="bulletList"><code class="inlineCode">CACHE_MIDDLEWARE_KEY_PREFIX</code>: The prefix to use for cache keys. Set a prefix to avoid key collisions if you share the same cache between several sites.</li>
<li class="bulletList"><code class="inlineCode">CACHE_MIDDLEWARE_SECONDS</code>: The default number of seconds to cache pages.</li>
</ul>
<p class="normal">The caching system for the project can be configured using the <code class="inlineCode">CACHES</code> settings. This setting allows you to specify the configuration for multiple caches. Each cache included in the <code class="inlineCode">CACHES</code> dictionary can specify the following data:</p>
<ul>
<li class="bulletList"><code class="inlineCode">BACKEND</code>: The cache backend to use.</li>
<li class="bulletList"><code class="inlineCode">KEY_FUNCTION</code>: A string containing a dotted path to a callable that takes a prefix, version, and key as arguments and returns a final cache key.</li>
<li class="bulletList"><code class="inlineCode">KEY_PREFIX</code>: A string prefix for all cache keys, to avoid collisions.</li>
<li class="bulletList"><code class="inlineCode">LOCATION</code>: The location of the cache. Depending on the cache backend, this might be a directory, a host and port, or a name for the in-memory backend.</li>
<li class="bulletList"><code class="inlineCode">OPTIONS</code>: Any additional parameters to be passed to the cache backend.</li>
<li class="bulletList"><code class="inlineCode">TIMEOUT</code>: The default timeout, in seconds, for storing the cache keys. It is 300 seconds by default, which is 5 minutes. If set to <code class="inlineCode">None</code>, the cache keys will not expire.</li>
<li class="bulletList"><code class="inlineCode">VERSION</code>: The default version number for the cache keys. Useful for cache versioning.</li>
</ul>
<p class="normal">You can find more<a id="_idIndexMarker1299"/> information about the <code class="inlineCode">CACHES</code> settings at <a href="https://docs.djangoproject.com/en/5.0/ref/settings/#caches">https://docs.djangoproject.com/en/5.0/ref/settings/#caches</a>.</p>
<h2 class="heading-2" id="_idParaDest-383">Adding Memcached to your project</h2>
<p class="normal">Let’s configure <a id="_idIndexMarker1300"/>the cache for your <a id="_idIndexMarker1301"/>project. Edit the <code class="inlineCode">settings.py</code> file of the <code class="inlineCode">educa</code> project and add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': '127.0.0.1:11211',
    }
}
</code></pre>
<p class="normal">You are using the <code class="inlineCode">PyMemcacheCache</code> backend. You specify its location using the <code class="inlineCode">address:port</code> notation. If you have multiple Memcached instances, you can use a list for <code class="inlineCode">LOCATION</code>.</p>
<p class="normal">You have set up Memcached for your project. Let’s start caching data!</p>
<h1 class="heading-1" id="_idParaDest-384">Cache levels</h1>
<p class="normal">Django provides<a id="_idIndexMarker1302"/> the following levels of caching, listed here by ascending order of granularity:</p>
<ul>
<li class="bulletList"><strong class="screenText">Low-level cache API</strong>: Provides the highest granularity. Allows you to cache specific queries or calculations.</li>
<li class="bulletList"><strong class="screenText">Template cache</strong>: Allows you to cache template fragments.</li>
<li class="bulletList"><strong class="screenText">Per-view cache</strong>: Provides caching for individual views.</li>
<li class="bulletList"><strong class="screenText">Per-site cache</strong>: The highest-level cache. It caches your entire site.</li>
</ul>
<div><p class="normal">Think about your cache strategy before implementing caching. Focus first on expensive queries or calculations that are not calculated on a per-user basis.</p>
</div>
<p class="normal">In the upcoming sections, we will explore how to use each of these caching levels in our project.</p>
<p class="normal">Let’s start by learning <a id="_idIndexMarker1303"/>how to use the low-level cache API in your Python code.</p>
<h2 class="heading-2" id="_idParaDest-385">Using the low-level cache API</h2>
<p class="normal">The low-level <a id="_idIndexMarker1304"/>cache API allows you to store objects in <a id="_idIndexMarker1305"/>the cache with any granularity. It is located at <code class="inlineCode">django.core.cache</code>. You can import it like this:</p>
<pre class="programlisting code"><code class="hljs-code">from django.core.cache import cache
</code></pre>
<p class="normal">This uses the default cache. It’s equivalent to <code class="inlineCode">caches['default']</code>. Accessing a specific cache is also possible via its alias:</p>
<pre class="programlisting code"><code class="hljs-code">from django.core.cache import caches
my_cache = caches['alias']
</code></pre>
<p class="normal">Let’s take a look at how the cache API works. Open the Django shell with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py shell
</code></pre>
<p class="normal">Execute the following code:</p>
<pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from django.core.cache import cache
&gt;&gt;&gt; cache.set('musician', 'Django Reinhardt', 20)
</code></pre>
<p class="normal">You access the default cache backend and use <code class="inlineCode">set(key, value, timeout)</code> to store a key named <code class="inlineCode">'musician'</code> with a value that is the string <code class="inlineCode">'Django Reinhardt'</code> for 20 seconds. If you don’t specify a timeout, Django uses the default timeout specified for the cache backend in the <code class="inlineCode">CACHES</code> settings. Now, execute the following code:</p>
<pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; cache.get('musician')
'Django Reinhardt'
</code></pre>
<p class="normal">You retrieve the key from the cache. Wait for 20 seconds and execute the same code:</p>
<pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; cache.get('musician')
</code></pre>
<p class="normal">No value is returned this time. The <code class="inlineCode">'musician'</code> cache key has expired and the <code class="inlineCode">get()</code> method returns <code class="inlineCode">None</code> because the key is not in the cache anymore.</p>
<div><p class="normal">Always avoid storing a <code class="inlineCode">None</code> value in a cache key because you won’t be able to distinguish between the actual value and a cache miss.</p>
</div>
<p class="normal">Let’s cache a QuerySet with the following code:</p>
<pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from courses.models import Subject
&gt;&gt;&gt; subjects = Subject.objects.all()
&gt;&gt;&gt; cache.set('my_subjects', subjects)
</code></pre>
<p class="normal">You perform a QuerySet on the <code class="inlineCode">Subject</code> model and store the returned objects in the <code class="inlineCode">'my_subjects'</code> key. Let’s retrieve the cached data:</p>
<pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; cache.get('my_subjects')
&lt;QuerySet [&lt;Subject: Mathematics&gt;, &lt;Subject: Music&gt;, &lt;Subject: Physics&gt;, &lt;Subject: Programming&gt;]&gt;
</code></pre>
<p class="normal">You are going to cache some queries in your views. Edit the <code class="inlineCode">views.py</code> file of the <code class="inlineCode">courses</code> application<a id="_idIndexMarker1306"/> and <a id="_idIndexMarker1307"/>add the following import:</p>
<pre class="programlisting code"><code class="hljs-code">from django.core.cache import cache
</code></pre>
<p class="normal">In the <code class="inlineCode">get()</code> method of the <code class="inlineCode">CourseListView</code>, find the following lines:</p>
<pre class="programlisting code"><code class="hljs-code">subjects = Subject.objects.annotate(
    total_courses=Count('courses')
)
</code></pre>
<p class="normal">Replace the lines with the following ones:</p>
<pre class="programlisting code"><code class="hljs-code"><strong class="hljs-slc">subjects = cache.get(</strong><strong class="hljs-string-slc">'</strong><strong class="hljs-string-slc">all_subjects'</strong><strong class="hljs-slc">)</strong>
<strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">not</strong><strong class="hljs-slc"> subjects:</strong>
    subjects = Subject.objects.annotate(
        total_courses=Count('courses')
    )
<strong class="hljs-slc">    cache.</strong><strong class="hljs-built_in-slc">set</strong><strong class="hljs-slc">(</strong><strong class="hljs-string-slc">'all_subjects'</strong><strong class="hljs-slc">, subjects)</strong>
</code></pre>
<p class="normal">In this code, you try to get the <code class="inlineCode">all_subjects</code> key from the cache using <code class="inlineCode">cache.get()</code>. This returns <code class="inlineCode">None</code> if the given key is not found. If no key is found (not cached yet or cached but timed out), the query is performed to retrieve all <code class="inlineCode">Subject</code> objects and their number <a id="_idIndexMarker1308"/>of courses, and<a id="_idIndexMarker1309"/> the result is cached using <code class="inlineCode">cache.set()</code>.</p>
<h2 class="heading-2" id="_idParaDest-386">Checking cache requests with Django Debug Toolbar</h2>
<p class="normal">Let’s add Django <a id="_idIndexMarker1310"/>Debug<a id="_idIndexMarker1311"/> Toolbar to the project to check the cache queries. You learned how to use Django Debug Toolbar in <em class="italic">Chapter 7</em>, <em class="italic">Tracking User Actions</em>.</p>
<p class="normal">First, install Django Debug Toolbar with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python -m pip install django-debug-toolbar==4.3.0
</code></pre>
<p class="normal">Edit the <code class="inlineCode">settings.py</code> file of your project and add <code class="inlineCode">debug_toolbar</code> to the <code class="inlineCode">INSTALLED_APPS</code> setting, as follows. The new line is highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">INSTALLED_APPS = [
    # ...
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'debug_toolbar'</strong><strong class="hljs-slc">,</strong>
]
</code></pre>
<p class="normal">In the same file, add the following line highlighted in bold to the <code class="inlineCode">MIDDLEWARE</code> setting:</p>
<pre class="programlisting code"><code class="hljs-code">MIDDLEWARE = [
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'debug_toolbar.middleware.DebugToolbarMiddleware'</strong><strong class="hljs-slc">,</strong>
'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
</code></pre>
<p class="normal">Remember that <code class="inlineCode">DebugToolbarMiddleware</code> has to be placed before any other middleware, except for middleware that encodes the response’s content, such as <code class="inlineCode">GZipMiddleware</code>, which, if present, should come first.</p>
<p class="normal">Add the following lines at the end of the <code class="inlineCode">settings.py</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">INTERNAL_IPS = [
    '127.0.0.1',
]   
</code></pre>
<p class="normal">Django Debug Toolbar will only display if your IP address matches an entry in the <code class="inlineCode">INTERNAL_IPS</code> setting.</p>
<p class="normal">Edit the main <code class="inlineCode">urls.py</code> file of the project and add the following URL pattern to <code class="inlineCode">urlpatterns</code>:</p>
<pre class="programlisting code"><code class="hljs-code">path('__debug__/', include('debug_toolbar.urls')),
</code></pre>
<p class="normal">Run the development server and open <code class="inlineCode">http://127.0.0.1:8000/</code> in your browser.</p>
<p class="normal">You should now see Django Debug Toolbar on the right side of the page. Click on <strong class="screenText">Cache</strong> in the sidebar <a id="_idIndexMarker1312"/>menu. You <a id="_idIndexMarker1313"/>will see the following panel:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_14_07.png"/></figure>
<p class="packt_figref">Figure 14.7: The Cache panel of Django Debug Toolbar including cache requests for CourseListView on a cache miss</p>
<p class="normal">Under <strong class="screenText">Total calls</strong> you should see <strong class="screenText">2</strong>. The first time the <code class="inlineCode">CourseListView</code> view is executed, there are two cache requests. Under <strong class="screenText">Commands</strong>, you will see that the <code class="inlineCode">get</code> command has been executed once, and that the <code class="inlineCode">set</code> command has been executed once as well. The <code class="inlineCode">get</code> command corresponds to the call that retrieves the <code class="inlineCode">all_subjects</code> cache key. This is the first call displayed under <strong class="screenText">Calls</strong>. The first time the view is executed, a cache miss occurs because no data is cached yet. That’s why there is <strong class="screenText">1</strong> under <strong class="screenText">Cache misses</strong>. Then, the <code class="inlineCode">set</code> command is used to store the results of the <code class="inlineCode">subjects</code> QuerySet in the cache using the <code class="inlineCode">all_subjects</code> cache key. This is the second call displayed under <strong class="screenText">Calls</strong>.</p>
<p class="normal">In the <strong class="screenText">SQL</strong> menu item of Django Debug Toolbar, you will see the total number of SQL queries executed in this request. This includes the query to retrieve all subjects that are then stored in the cache:</p>
<figure class="mediaobject"><img alt="Graphical user interface, application  Description automatically generated" src="img/B21088_14_08.png"/></figure>
<p class="packt_figref">Figure 14.8: SQL queries executed for CourseListView on a cache miss</p>
<p class="normal">Reload the <a id="_idIndexMarker1314"/>page in the <a id="_idIndexMarker1315"/>browser and click on <strong class="screenText">Cache</strong> in the sidebar menu:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_14_09.png"/></figure>
<p class="packt_figref">Figure 14.9: The Cache panel of Django Debug Toolbar, including cache requests for the CourseListView view on a cache hit</p>
<p class="normal">Now, there is only a single cache request. Under <strong class="screenText">Total calls</strong>, you should see <strong class="screenText">1</strong>, and under <strong class="screenText">Commands</strong>,<strong class="screenText"> </strong>you can see that the cache request corresponds to a <code class="inlineCode">get</code> command. In this case, there is a cache hit (see <strong class="screenText">Cache hits</strong>) instead of a cache miss because the data has been found in the cache. Under <strong class="screenText">Calls</strong>, you can see the <code class="inlineCode">get</code> request to retrieve the <code class="inlineCode">all_subjects</code> cache key.</p>
<p class="normal">Check the <strong class="screenText">SQL</strong> menu item of the debug toolbar. You should see that there is one less SQL query in this request. You are saving one SQL query because the view finds the data in the cache and doesn’t need to retrieve it from the database:</p>
<figure class="mediaobject"><img alt="Graphical user interface, application  Description automatically generated" src="img/B21088_14_10.png"/></figure>
<p class="packt_figref">Figure 14.10: SQL queries executed for CourseListView on a cache hit</p>
<p class="normal">In this example, for a single request, it takes more time to retrieve the item from the cache than the time saved on the additional SQL query. However, when you have many users accessing your site, you will find that significant time reductions can be achieved by retrieving the data from the cache instead of hitting the database, and you will be able to serve the site to more concurrent users.</p>
<p class="normal">Successive requests to the same URL will retrieve the data from the cache. Since we didn’t specify a timeout when caching data with <code class="inlineCode">cache.set('all_subjects', subjects)</code> in the <code class="inlineCode">CourseListView</code> view, the default timeout will be used (300 seconds by default, which is 5 minutes). When the timeout is reached, the next request to the URL will generate<a id="_idIndexMarker1316"/> a cache <a id="_idIndexMarker1317"/>miss, the QuerySet will be executed, and data will be cached for another 5 minutes. You can define a different default timeout in the <code class="inlineCode">TIMEOUT</code> element of the <code class="inlineCode">CACHES</code> setting.</p>
<h2 class="heading-2" id="_idParaDest-387">Low-level caching based on dynamic data</h2>
<p class="normal">Often, you<a id="_idIndexMarker1318"/> will want to cache <a id="_idIndexMarker1319"/>something that is based on dynamic data. In these cases, you have to build dynamic keys that contain all the information required to uniquely identify the cached data.</p>
<p class="normal">Edit the <code class="inlineCode">views.py</code> file of the <code class="inlineCode">courses</code> application and modify the <code class="inlineCode">CourseListView</code> view to make it look like this:</p>
<pre class="programlisting code"><code class="hljs-code">class CourseListView(TemplateResponseMixin, View):
    model = Course
    template_name = 'courses/course/list.html'
def get(self, request, subject=None):
        subjects = cache.get('all_subjects')
        if not subjects:
            subjects = Subject.objects.annotate(
                total_courses=Count('courses')
            )
            cache.set('all_subjects', subjects)
        <strong class="hljs-slc">all_courses</strong> = Course.objects.annotate(
            total_modules=Count('modules')
        )
        if subject:
            subject = get_object_or_404(Subject, slug=subject)
<strong class="hljs-slc">            key = </strong><strong class="hljs-string-slc">f'subject_</strong><strong class="hljs-subst-slc">{subject.</strong><strong class="hljs-built_in-slc">id</strong><strong class="hljs-subst-slc">}</strong><strong class="hljs-string-slc">_courses'</strong>
<strong class="hljs-slc">            courses = cache.get(key)</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">not</strong><strong class="hljs-slc"> courses:</strong>
<strong class="hljs-slc">                courses = all_courses.</strong><strong class="hljs-built_in-slc">filter</strong><strong class="hljs-slc">(subject=subject)</strong>
<strong class="hljs-slc">                cache.</strong><strong class="hljs-built_in-slc">set</strong><strong class="hljs-slc">(key, courses)</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">else</strong><strong class="hljs-slc">:</strong>
<strong class="hljs-slc">            courses = cache.get(</strong><strong class="hljs-string-slc">'all_courses'</strong><strong class="hljs-slc">)</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">not</strong><strong class="hljs-slc"> courses:</strong>
<strong class="hljs-slc">                courses = all_courses</strong>
<strong class="hljs-slc">                cache.</strong><strong class="hljs-built_in-slc">set</strong><strong class="hljs-slc">(</strong><strong class="hljs-string-slc">'all_courses'</strong><strong class="hljs-slc">, courses)</strong>
return self.render_to_response(
            {
                'subjects': subjects,
                'subject': subject,
                'courses': courses
            }
        )
</code></pre>
<p class="normal">In this <a id="_idIndexMarker1320"/>case, you<a id="_idIndexMarker1321"/> also cache both all courses and courses filtered by subject. You use the <code class="inlineCode">all_courses</code> cache key for storing all courses if no subject is given. If there is a subject, you build the key dynamically with <code class="inlineCode">f'subject_{subject.id}_courses'</code>.</p>
<p class="normal">It’s important to note that you can’t use a cached QuerySet to build other QuerySets, since what you cached are actually the results of the QuerySet. So you can’t do the following:</p>
<pre class="programlisting code"><code class="hljs-code">courses = cache.get('all_courses')
courses.filter(subject=subject)
</code></pre>
<p class="normal">Instead, you have to create the base QuerySet <code class="inlineCode">Course.objects.annotate(total_modules=Count('modules'))</code>, which is not going to be executed until it<a id="_idIndexMarker1322"/> is forced, and use <a id="_idIndexMarker1323"/>it to further restrict the QuerySet with <code class="inlineCode">all_courses.filter(subject=subject)</code> for cases where the data was not found in the cache.</p>
<h2 class="heading-2" id="_idParaDest-388">Caching template fragments</h2>
<p class="normal">Caching template <a id="_idIndexMarker1324"/>fragments is a higher-level approach. You<a id="_idIndexMarker1325"/> need to load the cache template tags in your template using <code class="inlineCode">{% load cache %}</code>. Then, you will be able to use the <code class="inlineCode">{% cache %}</code> template tag to cache specific template fragments. You usually use the template tag as follows:</p>
<pre class="programlisting code"><code class="hljs-code">{% cache 300 fragment_name %}
    ...
{% endcache %}
</code></pre>
<p class="normal">The <code class="inlineCode">{% cache %}</code> template tag has two required arguments: the timeout in seconds and a name for the fragment. If you need to cache content depending on dynamic data, you can do so by passing additional arguments to the <code class="inlineCode">{% cache %}</code> template tag to uniquely identify the fragment.</p>
<p class="normal">Edit the <code class="inlineCode">/students/course/detail.html</code> file of the <code class="inlineCode">students</code> application. Add the following code at the top of it, just after the <code class="inlineCode">{% extends %}</code> tag:</p>
<pre class="programlisting code"><code class="hljs-code">{% load cache %}
</code></pre>
<p class="normal">Then, find the following lines:</p>
<pre class="programlisting code"><code class="hljs-code">{% for content in module.contents.all %}
  {% with item=content.item %}
    &lt;h2&gt;{{ item.title }}&lt;/h2&gt;
    {{ item.render }}
  {% endwith %}
{% endfor %}
</code></pre>
<p class="normal">Replace them with the following ones:</p>
<pre class="programlisting code"><code class="hljs-code"><strong class="hljs-slc">{% cache </strong><strong class="hljs-string-slc">600</strong><strong class="hljs-slc"> module_contents module %}</strong>
  {% for content in module.contents.all %}
    {% with item=content.item %}
      &lt;h2&gt;{{ item.title }}&lt;/h2&gt;
      {{ item.render }}
    {% endwith %}
  {% endfor %}
<strong class="hljs-slc">{% endcache %}</strong>
</code></pre>
<p class="normal">You cache this template fragment using the name <code class="inlineCode">module_contents</code> and pass the current <code class="inlineCode">Module</code> object to it. Thus, you uniquely identify the fragment. This is important to avoid caching a module’s contents and serving the wrong content when a different module is requested.</p>
<p class="normal">If the <code class="inlineCode">USE_I18N</code> setting is set to <code class="inlineCode">True</code>, the per-site middleware cache will respect the active language. If you use the <code class="inlineCode">{% cache %}</code> template tag, you have to use one of the translation-specific<a id="_idIndexMarker1326"/> variables available in <a id="_idIndexMarker1327"/>templates to achieve the same result, such as <code class="inlineCode">{% cache 600 name request.LANGUAGE_CODE %}</code>.</p>
<h2 class="heading-2" id="_idParaDest-389">Caching views</h2>
<p class="normal">You can cache the<a id="_idIndexMarker1328"/> output of individual views using the <code class="inlineCode">cache_page</code> decorator located at <code class="inlineCode">django.views.decorators.cache</code>. The decorator requires a <code class="inlineCode">timeout</code> argument (in seconds).</p>
<p class="normal">Let’s use it in your views. Edit the <code class="inlineCode">urls.py</code> file of the <code class="inlineCode">students</code> application and add the following import:</p>
<pre class="programlisting code"><code class="hljs-code">from django.views.decorators.cache import cache_page
</code></pre>
<p class="normal">Then, apply the <code class="inlineCode">cache_page</code> decorator to the <code class="inlineCode">student_course_detail</code> and <code class="inlineCode">student_course_detail_module</code> URL patterns, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">path(
    'course/&lt;pk&gt;/',
<strong class="hljs-slc">    cache_page(</strong><strong class="hljs-number-slc">60</strong><strong class="hljs-slc"> * </strong><strong class="hljs-number-slc">15</strong><strong class="hljs-slc">)(</strong>views.StudentCourseDetailView.as_view()<strong class="hljs-slc">)</strong>,
    name='student_course_detail'
),
path(
    'course/&lt;pk&gt;/&lt;module_id&gt;/',
<strong class="hljs-slc">    cache_page(</strong><strong class="hljs-number-slc">60</strong><strong class="hljs-slc"> * </strong><strong class="hljs-number-slc">15</strong><strong class="hljs-slc">)(</strong>views.StudentCourseDetailView.as_view()<strong class="hljs-slc">)</strong>,
    name='student_course_detail_module'
),
</code></pre>
<p class="normal">Now, the complete<a id="_idIndexMarker1329"/> content returned by the <code class="inlineCode">StudentCourseDetailView</code> is cached for 15 minutes.</p>
<div><p class="normal">The per-view cache uses the URL to build the cache key. Multiple URLs pointing to the same view will be cached separately.</p>
</div>
<h2 class="heading-2" id="_idParaDest-390">Using the per-site cache</h2>
<p class="normal">This is the <a id="_idIndexMarker1330"/>highest-level cache. It allows you to cache your <a id="_idIndexMarker1331"/>entire site. To allow the per-site cache, edit the <code class="inlineCode">settings.py</code> file of your project and add the <code class="inlineCode">UpdateCacheMiddleware</code> and <code class="inlineCode">FetchFromCacheMiddleware</code> classes to the <code class="inlineCode">MIDDLEWARE</code> setting, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">MIDDLEWARE = [
    'debug_toolbar.middleware.DebugToolbarMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'django.middleware.cache.UpdateCacheMiddleware'</strong><strong class="hljs-slc">,</strong>
'django.middleware.common.CommonMiddleware',
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'django.middleware.cache.FetchFromCacheMiddleware'</strong><strong class="hljs-slc">,</strong>
'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
</code></pre>
<p class="normal">Remember that middleware is executed in the given order during the request phase, and in reverse order during the response phase. <code class="inlineCode">UpdateCacheMiddleware</code> is placed before <code class="inlineCode">CommonMiddleware</code> because it runs during response time, when middleware is executed in reverse order. <code class="inlineCode">FetchFromCacheMiddleware</code> is placed after <code class="inlineCode">CommonMiddleware</code> intentionally because it needs to access the request data set by the latter.</p>
<p class="normal">Next, add the following settings to the <code class="inlineCode">settings.py</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">CACHE_MIDDLEWARE_ALIAS = 'default'
CACHE_MIDDLEWARE_SECONDS = 60 * 15 # 15 minutes
CACHE_MIDDLEWARE_KEY_PREFIX = 'educa'
</code></pre>
<p class="normal">In these settings, you use the default cache for your cache middleware and set the global cache timeout to <code class="inlineCode">15</code> minutes. You also specify a prefix for all cache keys to avoid collisions in case you use the same Memcached backend for multiple projects. Your site will now cache and return cached content for all <code class="inlineCode">GET</code> requests.</p>
<p class="normal">You can access the different pages and check the cache requests using Django Debug Toolbar. The per-site cache is not viable for many sites because it affects all views, even the ones that you might not want to cache, like management views where you want data to be returned from the database to reflect the latest changes.</p>
<p class="normal">In this project, the best approach is to cache the templates or views that are used to display course contents to students while keeping the content management views for instructors without any cache.</p>
<p class="normal">Let’s<a id="_idIndexMarker1332"/> deactivate<a id="_idIndexMarker1333"/> the per-site cache. Edit the <code class="inlineCode">settings.py</code> file of your project and comment out the <code class="inlineCode">UpdateCacheMiddleware</code> and <code class="inlineCode">FetchFromCacheMiddleware</code> classes in the <code class="inlineCode">MIDDLEWARE</code> setting, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">MIDDLEWARE = [
    'debug_toolbar.middleware.DebugToolbarMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    <strong class="hljs-comment-slc"># </strong>'django.middleware.cache.UpdateCacheMiddleware',
'django.middleware.common.CommonMiddleware',
    <strong class="hljs-comment-slc"># </strong>'django.middleware.cache.FetchFromCacheMiddleware',
'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
</code></pre>
<p class="normal">You have seen an overview of the different methods provided by Django to cache data. You should always define your cache strategy wisely, taking into account expensive QuerySets or calculations, data that won’t change frequently, and data that will be accessed <a id="_idIndexMarker1334"/>concurrently <a id="_idIndexMarker1335"/>by many users.</p>
<h1 class="heading-1" id="_idParaDest-391">Using the Redis cache backend</h1>
<p class="normal">Django also<a id="_idIndexMarker1336"/> provides a Redis cache backend. Let’s change the settings to use Redis instead of Memcached as the cache backend for the project. Remember that you already used Redis in <em class="italic">Chapter 7</em>, <em class="italic">Tracking User Actions</em>, and in <em class="italic">Chapter 10</em>, <em class="italic">Extending Your Shop</em>.</p>
<p class="normal">Install <code class="inlineCode">redis-py</code> in your environment using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python -m pip install redis==5.0.4
</code></pre>
<p class="normal">Then, edit the <code class="inlineCode">settings.py</code> file of the <code class="inlineCode">educa</code> project and modify the <code class="inlineCode">CACHES</code> setting, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">CACHES = {
    'default': {
        'BACKEND': <strong class="hljs-string-slc">'django.core.cache.backends.redis.RedisCache'</strong><strong class="hljs-slc">,</strong>
'LOCATION': <strong class="hljs-string-slc">'redis://127.0.0.1:6379'</strong><strong class="hljs-slc">,</strong>
    }
}
</code></pre>
<p class="normal">The project will now use the <code class="inlineCode">RedisCache</code> cache backend. The location is defined in the format <code class="inlineCode">redis://[host]:[port]</code>. You use <code class="inlineCode">127.0.0.1</code> to point to the localhost and <code class="inlineCode">6379</code>, which is the default port for Redis.</p>
<p class="normal">You can read more about the Redis cache backend at <a href="https://docs.djangoproject.com/en/5.0/topics/cache/#redis">https://docs.djangoproject.com/en/5.0/topics/cache/#redis</a>.</p>
<p class="normal">Initialize the Redis Docker container using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker run -it --rm --name redis -p 6379:6379 redis:7.2.4
</code></pre>
<p class="normal">If you want to run the command in the background (in detached mode), you can use the <code class="inlineCode">-d</code> option.</p>
<p class="normal">Run the development server and open <code class="inlineCode">http://127.0.0.1:8000/</code> in your browser. Check the cache requests in the <strong class="screenText">Cache </strong>panel of Django Debug Toolbar. You are now using Redis as your<a id="_idIndexMarker1337"/> project’s cache backend instead of Memcached.</p>
<h2 class="heading-2" id="_idParaDest-392">Monitoring Redis with Django Redisboard</h2>
<p class="normal">You can monitor<a id="_idIndexMarker1338"/> your Redis server<a id="_idIndexMarker1339"/> using Django Redisboard. Django Redisboard adds Redis statistics to the Django administration site. You can find more information about Django Redisboard at <a href="https://github.com/ionelmc/django-redisboard">https://github.com/ionelmc/django-redisboard</a>.</p>
<p class="normal">Install <code class="inlineCode">django-redisboard</code> in your environment using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python -m pip install django-redisboard==8.4.0
</code></pre>
<p class="normal">Edit the <code class="inlineCode">settings.py</code> file of your project and add the application to the <code class="inlineCode">INSTALLED_APPS</code> setting, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">INSTALLED_APPS = [
    # ...
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'redisboard'</strong><strong class="hljs-slc">,</strong>
]
</code></pre>
<p class="normal">Run the following command from your project’s directory to run the Django Redisboard migrations:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py migrate redisboard
</code></pre>
<p class="normal">Run the development server and open <code class="inlineCode">http://127.0.0.1:8000/admin/redisboard/redisserver/add/</code> in your browser to add a Redis server to monitor. For <strong class="screenText">Label</strong>, enter <code class="inlineCode">redis</code>, and for <strong class="screenText">URL</strong>, enter <code class="inlineCode">redis://localhost:6379/0</code>, as in <em class="italic">Figure 14.11</em>:</p>
<figure class="mediaobject"><img alt="Graphical user interface, text, application, email  Description automatically generated" src="img/B21088_14_11.png"/></figure>
<p class="packt_figref">Figure 14.11: The form to add a Redis server for Django Redisboard in the administration site</p>
<p class="normal">We will monitor <a id="_idIndexMarker1340"/>the<a id="_idIndexMarker1341"/> Redis instance running on our localhost, which runs on port <code class="inlineCode">6379</code> and uses the Redis database numbered <code class="inlineCode">0</code>. Click on <strong class="screenText">SAVE</strong>. The information will be saved to the database, and you will be able to see the Redis configuration and metrics on the Django administration site:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_14_12.png"/></figure>
<p class="packt_figref">Figure 14.12: The Redis monitoring of Django Redisboard on the administration site</p>
<p class="normal">Congratulations! You<a id="_idIndexMarker1342"/> have successfully<a id="_idIndexMarker1343"/> implemented caching for your project.</p>
<h1 class="heading-1" id="_idParaDest-393">Summary</h1>
<p class="normal">In this chapter, you implemented the public views for the course catalog. You built a system for students to register and enroll in courses. You also created the functionality to render different types of content for the course modules. Finally, you learned how to use the Django cache framework and you used the Memcached and Redis cache backends for your project.</p>
<p class="normal">In the next chapter, you will build a RESTful API for your project using Django REST framework and consume it using the Python Requests library.</p>
<h1 class="heading-1" id="_idParaDest-394">Additional resources</h1>
<p class="normal">The following resources provide additional information related to the topics covered in this chapter:</p>
<ul>
<li class="bulletList">Source code for this chapter: <a href="https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter14 ">https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter14</a></li>
<li class="bulletList"><code class="inlineCode">django-embed-video</code> documentation: <a href="https://django-embed-video.readthedocs.io/en/latest/">https://django-embed-video.readthedocs.io/en/latest/</a></li>
<li class="bulletList">Django’s cache framework documentation: <a href="https://docs.djangoproject.com/en/5.0/topics/cache/">https://docs.djangoproject.com/en/5.0/topics/cache/</a></li>
<li class="bulletList">Memcached Docker image: <a href="https://hub.docker.com/_/memcached">https://hub.docker.com/_/memcached</a></li>
<li class="bulletList">Memcached downloads: <a href="https://memcached.org/downloads">https://memcached.org/downloads</a></li>
<li class="bulletList">Memcached official website: <a href="https://memcached.org">https://memcached.org</a></li>
<li class="bulletList">Django’s <code class="inlineCode">CACHES</code> settings documentation: <a href="https://docs.djangoproject.com/en/5.0/ref/settings/#caches">https://docs.djangoproject.com/en/5.0/ref/settings/#caches</a>.</li>
<li class="bulletList"><code class="inlineCode">pymemcache</code>'s source code: <a href="https://github.com/pinterest/pymemcache">https://github.com/pinterest/pymemcache</a></li>
<li class="bulletList">Django Redis cache backend: <a href="https://docs.djangoproject.com/en/5.0/topics/cache/#redis">https://docs.djangoproject.com/en/5.0/topics/cache/#redis</a></li>
<li class="bulletList">Official Redis Docker image: <a href="https://hub.docker.com/_/redis">https://hub.docker.com/_/redis</a></li>
<li class="bulletList">Redis download options: <a href="https://redis.io/download/">https://redis.io/download/</a></li>
<li class="bulletList">Django Redisboard source code: <a href="https://github.com/ionelmc/django-redisboard">https://github.com/ionelmc/django-redisboard</a></li>
</ul>
</div>
</body></html>