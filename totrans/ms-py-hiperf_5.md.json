["```py\n#!/usr/bin/python\n\nimport thread\nimport time\n\n# Prints the time 5 times, once every \"delay\" seconds\ndef print_time( threadName, delay):\n   count = 0\n   while count < 5:\n      time.sleep(delay)\n      count += 1\n      print \"%s: %s\" % ( threadName, time.ctime(time.time()) )\n\n# Create two threads as follows\ntry:\n   thread.start_new_thread( print_time, (\"Thread-1\", 2, ) )\n   thread.start_new_thread( print_time, (\"Thread-2\", 4, ) )\nexcept:\n   print \"Error: unable to start thread\"\n\n# We need to keep the program working, otherwise the threads won't live\n\nwhile True:\n   pass\n```", "```py\ninterrupt_main\n```", "```py\nexit\n\n```", "```py\ndef print_time( threadName, delay):\n   count = 0\n   while count < 5:\n      time.sleep(delay)\n      count += 1\n      print \"%s: %s\" % ( threadName, time.ctime(time.time()) )\n      if delay == 2 and count == 2:\n      thread.exit()\n```", "```py\n#!/usr/bin/python\n\nimport thread\nimport time\n\nglobal_value = 0\n\ndef run( threadName ):\n   global global_value\n   print \"%s with value %s\" % (threadName, global_value)\n   global_value = global_value + 1\n\nfor i in range(10):\n   thread.start_new_thread( run, (\"Thread-\" + str(i), ) )\n\n# We need to keep the program working, otherwise the threads won't live\nwhile 1:\n   pass\n```", "```py\n#!/usr/bin/python\n\nimport thread\nimport time\n\nglobal_value = 0\n\ndef run( threadName, lock ):\n   global global_value\n   lock.acquire()\n   local_copy = global_value\n   print \"%s with value %s\" % (threadName, local_copy)\n   global_value = local_copy + 1\n   lock.release()\n\nlock = thread.allocate_lock()\n\nfor i in range(10):\n   thread.start_new_thread( run, (\"Thread-\" + str(i), lock) )\n\n# We need to keep the program working, otherwise the threads won't live\nwhile 1:\n   pass\n```", "```py\nget_ident\n```", "```py\nstack_size\n```", "```py\n#!/usr/bin/python\n\nimport threading\n\nglobal_value = 0\n\ndef run( threadName, lock ):\n   global global_value\n   lock.acquire()\n   local_copy = global_value\n   print \"%s with value %s\" % (threadName, local_copy)\n   global_value = local_copy + 1\n   lock.release()\n\nlock = threading.Lock()\n\nfor i in range(10):\n   t = threading.Thread( target=run, args=(\"Thread-\" + str(i), lock) )\n   t.start()\n```", "```py\nimport threading\nimport time\n\nclass MyThread(threading.Thread):\n\n  def __init__(self, count):\n    threading.Thread.__init__(self)\n    self.total = count\n\n  def run(self):\n\n    for i in range(self.total):\n      time.sleep(1)\n      print \"Thread: %s - %s\" % (self.name, i)\n\nt = MyThread(4)\nt2 = MyThread(3)\n\nt.start()\nt2.start()\n\nprint \"This program has finished\"\n```", "```py\n#....\nf = open(\"output-file.txt\", \"w+\")\nt = MyThread(4, f)\nt2 = MyThread(3, f)\n\nt.start()\nt2.start()\nf.close() #close the file handler\nprint \"This program has finished\"\n```", "```py\n#...\nt.start()\nt2.start()\n#both threads are working, let's stop the main thread\nt.join() \nt2.join()\nf.close() #now that both threads have finished, lets close the file handler\nprint \"This program has finished\"\n```", "```py\nimport urllib2\n\nsites = [\n  \"http://www.google.com\",\n  \"http://www.bing.com\",\n  \"http://stackoverflow.com\",\n  \"http://facebook.com\",\n  \"http://twitter.com\"\n]\n\ndef check_http_status(url):\n  return urllib2.urlopen(url).getcode()\n\nhttp_status = {}\nfor url in sites:\n  http_status[url] = check_http_status(url)\n\nfor  url in http_status#:\n  print \"%s: %s\" % (url, http_status[url])\n```", "```py\n$time python non_threading_httpstatus.py\n\n```", "```py\nimport urllib2\nimport threading\n\nsites = [\n  \"http://www.google.com\",\n  \"http://www.bing.com\",\n  \"http://stackoverflow.com\",\n  \"http://facebook.com\",\n  \"http://twitter.com\"\n]\n\nclass HTTPStatusChecker(threading.Thread):\n\n  def __init__(self, url):\n    threading.Thread.__init__(self)\n    self.url = url\n    self.status = None\n\n  def getURL(self):\n    return self.url\n\n  def getStatus(self):\n    return self.status\n\n  def run(self):\n    self.status = urllib2.urlopen(self.url).getcode()\n\nthreads = []\nfor url in sites:\n  t = HTTPStatusChecker(url)\n  t.start() #start the thread\n  threads.append(t) \n\n#let the main thread join the others, so we can print their result after all of them have finished.\nfor t in threads:\n  t.join()\n\nfor  t in threads:\n  print \"%s: %s\" % (t.url, t.status)\n```", "```py\n$time python threading_httpstatus.py\n\n```", "```py\nimport threading\nimport time\n\nclass ThreadA(threading.Thread):\n\n  def __init__(self, event):\n    threading.Thread.__init__(self)\n    self.event = event\n\n  def run(self):\n    count = 0\n    while count < 5:\n      time.sleep(1)\n      if self.event.is_set():\n        print \"A\"\n        self.event.clear()\n      count += 1\n\nclass ThreadB(threading.Thread):\n\n  def __init__(self, evnt):\n    threading.Thread.__init__(self)\n    self.event = evnt\n\n  def run(self):\n    count = 0\n    while count < 5:\n      time.sleep(1)\n      if not self.event.is_set():\n        print \"B\"\n        self.event.set()\n      count += 1\n\nevent = threading.Event()\n\nta = ThreadA(event)\ntb = ThreadB(event)\n\nta.start()\ntb.start()\n```", "```py\n#!/usr/bin/python\n\nimport multiprocessing\n\ndef run( pname ):\n  print pname\n\nfor i in range(10):\n  p = multiprocessing.Process(target=run, args=(\"Process-\" + str(i), ))\n  p.start()\n  p.join()\n```", "```py\n#!/usr/bin/python\n\nimport multiprocessing\n\ndef run( pname ):\n  print pname\n\nif __name__ == '__main__':\n  for i in range(10):\n    p = multiprocessing.Process(target=run, args=(\"Process-\" + str(i), ))\n    p.start()\n    p.join()\n```", "```py\nimport multiprocessing\nimport time\n\ndef first():\n  print \"There is no problem here\"\n\ndef second():\n  raise RuntimeError(\"Error raised!\")\n\ndef third():\n  time.sleep(3)\n  print \"This process will be terminated\"\n\nworkers = [ multiprocessing.Process(target=first), multiprocessing.Process(target=second), multiprocessing.Process(target=third)]\n\nfor w in workers:\n  w.start()\n\nworkers[-1].terminate()\n\nfor w in workers:\n  w.join()\n\nfor w in workers:\n  print w.exitcode\n```", "```py\nfrom multiprocessing import Queue, Process\nimport random\n\ndef generate(q):\n  while True:\n    value = random.randrange(10)\n    q.put(value)\n    print \"Value added to queue: %s\" % (value)\n\ndef reader(q):\n  while True:\n    value = q.get()\n    print \"Value from queue: %s\" % (value)\n\nqueue = Queue()\np1 = Process(target=generate, args=(queue,))\np2 = Process(target=reader, args=(queue,))\n\np1.start()\np2.start()\n```", "```py\nfrom multiprocessing import Pipe, Process\nimport random\n\ndef generate(pipe):\n   while True:\n    value = random.randrange(10)\n    pipe.send(value)\n    print \"Value sent: %s\" % (value)\n\ndef reader(pipe):\n   f = open(\"output.txt\", \"w\")\n   while True:\n     value = pipe.recv()\n     f.write(str(value))\n     print \".\"\n\ninput_p, output_p = Pipe()\np1 = Process(target=generate, args=(input_p,))\np2 = Process(target=reader, args=(output_p,))\n\np1.start()\np2.start()\n```", "```py\nfrom multiprocessing import Process, Event, Pool\nimport time\n\nevent = Event()\nevent.set()\n\ndef worker(i, e):\n    if e.is_set():\n      time.sleep(0.1)\n      print \"A - %s\" % (time.time())\n      e.clear()\n    else:\n      time.sleep(0.1)\n      print \"B - %s\" % (time.time())\n      e.set()\n\npool = Pool(3)\npool.map(worker, [ (x, event) for x in range(9)])\nInstead, you'd have to do something like this:\nfrom multiprocessing import Process, Event, Pool\nimport time\n\nevent = Event()\nevent.set()\n\ndef worker(i):\n   if event.is_set():\n     time.sleep(0.1)\n     print \"A - %s\" % (time.time())\n     event.clear()\n   else:\n     time.sleep(0.1)\n     print \"B - %s\" % (time.time())\n     event.set()\n\npool = Pool(3)\npool.map(worker, range(9))\n```"]