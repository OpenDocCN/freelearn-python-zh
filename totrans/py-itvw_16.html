<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch16"/>Chapter 16. Al Sweigart</h1></div></div></div><div><img src="img/B08180_13_01.jpg" alt="Al Sweigart"/></div><p>Al Sweigart<a id="id415" class="indexterm"/> is an American software developer and the creator of two cross-platform Python modules: Pyperclip, for <a id="id416" class="indexterm"/>copying and <a id="id417" class="indexterm"/>pasting text, and PyAutoGUI, for controlling the mouse and keyboard. He is a successful author who has published four books on Python programming and a book on Scratch, a programming language for children. Al's books teach beginners how to code and he is passionate about helping young people and adults to develop programming skills. Al focuses on making programming knowledge more accessible and regularly speaks at Python conferences.</p><div><blockquote class="blockquote"><p>
<strong>Discussion themes: Python books, Python packages, v2.7/v3.x.</strong>
</p><p>
<strong>Catch up with Al Sweigart here: @AlSweigart</strong>
</p></blockquote></div><p>
<strong>Mike Driscoll</strong>: So how did <a id="id418" class="indexterm"/>you become a programmer?</p><p>
<strong>Al Sweigart</strong>: I was a kid who loved the 8-bit Nintendo. Then a friend of mine found a book in the elementary school library about programming games in BASIC. I was hooked.</p><p>I sort of hate telling people how I got into programming, because I was one of those people who started when they were a young kid. I worry that telling my story makes people think, "Oh no, I haven't <a id="id419" class="indexterm"/>been programming since I was three weeks old, so it's too late for me. I'll never catch up!"</p><div><blockquote class="blockquote"><p>
<strong>Al Sweigart: 'If anything, programming has become so much easier than it was 20 years ago.'</strong>
</p></blockquote></div><p>If anything, programming has become so much easier than it was 20 years ago. We didn't have Wikipedia and Stack Overflow back then. I think everything that I learned about programming between the third grade and graduating high school, anybody could now learn in about a dozen weekends.</p><p>Most of my programming knowledge was drawn from that one book. I tried to make sense of the reference manual that came with my family's Compaq 386 computer. I couldn't understand that manual at all. I ended up never making anything as impressive as the Nintendo games I played.</p><p>
<strong>Driscoll</strong>: So<a id="id420" class="indexterm"/> how did you end up moving into Python itself?</p><p>
<strong>Sweigart</strong>: I first picked up Python around 2004. I was looking at making some web apps, and I was mostly programming in PHP and Perl, when a friend pointed out Python to me.</p><p>At that time, I wanted to learn as many different programming languages as I could, and Python was really nice. I loved the readability of the language. Everything that I used to do in Perl, I started doing in Python. I never found a programming language that I liked better after that, so I just stuck to Python and now it's been over a decade.</p><p>I sometimes feel that I need to actually force myself to learn different programming languages, just to stay on top of things. But Python has become my go-to language. Whenever I have to write a quick script or automate some really short task, it's easy to use Python.</p><p>Then again, it's really hard to predict the future and I've stopped trying. For instance, I really thought that something would come along to replace JavaScript, but if anything, it's just getting more popular! That, and I originally thought that including cameras in cell phones was a silly idea. So I've learned not to try to predict the future.</p><div><blockquote class="blockquote"><p>
<strong>Al Sweigart: 'It's really hard to predict the future and I've stopped trying.'</strong>
</p></blockquote></div><p>
<strong>Driscoll</strong>: Python is <a id="id421" class="indexterm"/>playing a major role in the AI and machine learning boom. Can you explain that?</p><p>
<strong>Sweigart</strong>: Well, not to <a id="id422" class="indexterm"/>fawn over Python too much, but what makes Python great for AI are the things that make it great as a language in general.</p><div><blockquote class="blockquote"><p>
<strong>Al Sweigart: 'What makes Python great for AI are the things that make it great as a language in general.'</strong>
</p></blockquote></div><p>Python is easy to learn and easy to use. It turns out that for most applications this is what's important. "Powerful" is a meaningless term when it comes to programming languages, because every language describes itself as "powerful".</p><p>Theoretically, there's no calculation that one language can do that another language can't. In practice though, you need a human programmer to take the time to sit down and write the actual code. A language that makes that easy to do is the one that will see more adoption, a larger community, and more libraries. So it doesn't surprise me that Python takes the lead in something like machine learning, where so many of the tools were developed recently.</p><p>
<strong>Driscoll</strong>: What made you decide to start<a id="id423" class="indexterm"/> actually writing books about the Python language?</p><p>
<strong>Sweigart</strong>: In 2008, my girlfriend was a nanny for a 10-year-old kid. He wanted to learn how to program, but he didn't really know where to start. I tried to find something on the web for him, but so much of the content back then was aimed at professional software developers.</p><p>So I started writing a tutorial, which eventually became <em>Invent Your Own Computer Games with Python</em>. I didn't want to bury the reader with programming concepts and technical jargon. I just wanted to list the source code to a game and then explain how its code worked. I kept adding more games and eventually it ballooned into book length. I self-published it, but also put it on the web for free under a Creative Commons license. People seemed to like it, so I went on to write <em>Making Games with Python and Pygame</em>.</p><p>There's a little<a id="id424" class="indexterm"/> cipher program in <em>Invent Your Own Computer Games with Python</em>. I thought putting a bunch of these classic ciphers together would make a good book. I'd explain not only how to write code to perform the encryption, but also how to break the encryption. These ciphers are from ancient Roman times, up to the 16th century, so the average laptop today has more than enough computing power to break them. That book became <em>Cracking Codes with Python</em>.</p><p>After I wrote that third book, writing turned into what I did with all of my spare time. There came a point where I could take a chance, leave the software developer job that I had, and write full-time. That worked out pretty well.</p><div><blockquote class="blockquote"><p>
<strong>Al Sweigart: 'I came up with the right idea for a book, at the right time, and also for the right language.'</strong>
</p></blockquote></div><p>I thought that I'd go back to another developer job after a year or so of writing, but <em>Automate the Boring Stuff with Python</em> completely blew me away with its success. It was mostly luck. I came up with the right idea for a book, at the right time, and also for the right language. So a lot of things just fell together.</p><p>
<strong>Driscoll</strong>: Why did you <a id="id425" class="indexterm"/>decide to self-publish?</p><p>
<strong>Sweigart</strong>: No Starch Press had approached me about publishing <em>Invent Your Own Computer Games with Python</em>, but that plan had fallen through.</p><p>I had this half-edited manuscript, so I finished editing it and turned it into a PDF to put on Amazon. All the promotion I did was online. I'd tell people about it on forums. People didn't see it as spamming because the PDF was also completely free to download.</p><p>
<strong>Driscoll</strong>: Do you think that the success of <em>Invent Your Own Computer Games with Python</em> was due to having the book as a PDF, or as a web page?</p><p>
<strong>Sweigart</strong>: I still think<a id="id426" class="indexterm"/> putting the book online for free, with a Creative Commons license, led to more people buying the book. People could see the book and generate word of mouth. There were other benefits too. With the book online, I could take a look at the traffic and see which chapters were getting the most attention.</p><div><blockquote class="blockquote"><p>
<strong>Al Sweigart: 'The most popular chapters...were on GUI automation, web scraping and regular expressions. So when PyCon had calls for talk proposals, those were the topics that I chose.'</strong>
</p></blockquote></div><p>The most popular chapters on the <em>Automate the Boring Stuff with Python</em> site were on GUI automation, web scraping, <a id="id427" class="indexterm"/>and regular expressions. So when PyCon had calls for talk proposals, those were the topics that I chose. That's how I started speaking at the regional PyCons and then at US PyCon in 2017.</p><p>I've noticed that the most popular topics in my books are not always the stuff that I think is the most interesting. I remember that when I was writing <em>Automate the Boring Stuff with Python</em>, I thought that the chapter on image manipulation would be popular. But it turns out that most people don't need to generate their own image files from Python scripts as much as I do.</p><div><blockquote class="blockquote"><p>
<strong>Al Sweigart: 'I've noticed that the most popular topics in my books are not always the stuff that I think is the most interesting.'</strong>
</p></blockquote></div><p>
<strong>Driscoll</strong>: What have you learned<a id="id428" class="indexterm"/> as an author?</p><p>
<strong>Sweigart</strong>: It's going to be more work than you think! A lot of people email me and say, "Oh hey, I'm interested in writing a book on programming. Do you have any advice for me?"</p><p>I don't know what to tell them. I'm a software developer by training. I know what I did and that my approach worked for me. But that's like a lottery winner advising you on which numbers to pick. <em>Automate the Boring Stuff with Python</em> did far better than my other books. I'm not really sure how well I could reproduce those results for someone else.</p><p>My most recent book was <em>Scratch Programming Playground</em>, which uses the Scratch programming tool, from the MIT Media Lab, to teach programming concepts to kids. That book is doing modestly well, but unfortunately the audience for Scratch isn't as large as the audience for Python.</p><p>I did learn that writing is something you have to do to get better at it. Actual practice is better than any advice I could give. Also, I learned that good editors are worth their weight in gold.</p><p>
<strong>Driscoll</strong>: So what would you do differently if you could start over with one of your other books that didn't do so well?</p><p>
<strong>Sweigart</strong>: I mean, if we're talking about the first book, then my biggest mistake was not writing it for Python 3. Originally, I was just using Python 2, because that's what I knew.</p><p>I didn't start questioning that decision until someone said, "Hey, why don't you use Python 3?" There really wasn't a particular reason not to, so I made the switch to Python 3 for <em>Invent Your Own Computer Games with Python</em>. That turned out to be a really smart thing.</p><div><blockquote class="blockquote"><p>
<strong>Al Sweigart: 'I made the switch to Python 3 for Invent Your Own Computer Games with Python. That turned out to be a really smart thing.'</strong>
</p></blockquote></div><p>Another big mistake when writing <em>Invent Your Own Computer Games with Python</em> was that I originally had the entire text just as HTML, because I was making it as a web tutorial in a text file. I was writing unit tests and using linting tools just to make sure that everything was formatted well. That turned out to be a large headache.</p><p>What I should have done is use Microsoft Word. A lot of people are really surprised when I tell them that, but Word and Excel are the two best things to come out of Microsoft. If I could send a message 10 years back in time, I'd tell myself to use real desktop publishing software.</p><p>
<strong>Driscoll</strong>: Why did you choose Scratch, rather <a id="id429" class="indexterm"/>than one of the other children's beginner languages?</p><p>
<strong>Sweigart</strong>: Scratch is the<a id="id430" class="indexterm"/> best programming tool for kids that I've encountered. A lot of programming tools for kids are dumbed down to the point that I don't feel like they're actually teaching programming.</p><p>Scratch made a lot of smart design decisions and teaches real programming, while hiding the messy details. Everyone interested in teaching kids to code should read the Scratch white paper by Mitch Resnick and also watch his TED talk.</p><p>
<strong>Driscoll</strong>: So I want to change topic here slightly. Why did you create the Python packages Pyperclip and PyAutoGUI?</p><p>
<strong>Sweigart</strong>: Pyperclip <a id="id431" class="indexterm"/>and <a id="id432" class="indexterm"/>PyAutoGUI both came out <a id="id433" class="indexterm"/>of needs that came up while I was <a id="id434" class="indexterm"/>writing programming books.</p><div><blockquote class="blockquote"><p>
<strong>Al Sweigart: 'Pyperclip and PyAutoGUI both came out of needs that came up while I was writing programming books.'</strong>
</p></blockquote></div><p>In <em>Cracking Codes with Python</em>, you're dealing with encrypting and decrypting text. Often, you're working with a lot of random nonsense text that you need to reproduce exactly, and having a copy-and-paste mechanism makes that much easier. It lets the user put the output into an email, or save it in a document. So I thought, "Well, how do you copy-and-paste text in Python?" There were some modules on PyPI that did copy-and-paste, but they would only work on one operating system, or they only worked for Python 2.</p><p>I wanted to have one module that worked on all operating systems, and also worked for Python 2 and Python 3. All I needed was a copy function and a paste function. I didn't think it would turn out to be much work, but of course it was. Fortunately, the user doesn't have to see all the messy details that went into making Pyperclip work on so many platforms. They only see a module with two functions.</p><p>
<strong>Driscoll</strong>: So how did you get started on this<a id="id435" class="indexterm"/> idea of one module?</p><p>
<strong>Sweigart</strong>: I didn't want readers to have to deal with picking different modules depending on what their computer setup was.</p><p>I combined all of that code into one module, to become Pyperclip, because I noticed that there was nothing on PyPI that did that. PyAutoGUI was created for similar reasons. I wanted to have a chapter on GUI automation for <em>Automate the Boring Stuff with Python</em>, but all the existing modules on PyPI were for different operating systems and worked differently.</p><div><blockquote class="blockquote"><p>
<strong>Al Sweigart: 'The way that PyAutoGUI came about was because of this need to have one module that just worked.'</strong>
</p></blockquote></div><p>The way that PyAutoGUI came about was because of this need to have one module that just worked. I think that's the main reason that PyAutoGUI is the most popular open source project that I've ever started. It's useful to a wide range of people.</p><p>
<strong>Driscoll</strong>: What do you think should be the goal for<a id="id436" class="indexterm"/> anyone creating Python packages?</p><p>
<strong>Sweigart</strong>: If you want to create a Python package, or any software, the most important thing is that it's easy to use.</p><div><blockquote class="blockquote"><p>
<strong>Al Sweigart: 'If you want to create a Python package, or any software, the most important thing is that it's easy to use.'</strong>
</p></blockquote></div><p>Before I even start writing any code, I just type out what the API would be like and how I would use it myself. I think a lot of programmers just like writing code and solving technical problems, but they don't realize that all of that is worthless if it's too complicated for people to actually use.</p><div><blockquote class="blockquote"><p>
<strong>Al Sweigart: 'When starting out, the algorithms you write don't have to be elegant. You don't even need the code to be perfectly clean.'</strong>
</p></blockquote></div><p>When starting out, the algorithms you write don't have to be elegant. You don't even need the code to be perfectly clean. As long as using the module is simple, then that's what gets people paying attention. Once you know you've made something that works, and that people want, then you can clean up the code for future development.</p><div><blockquote class="blockquote"><p>
<strong>Al Sweigart: 'I'm always thrilled that many people use Pyperclip and it isn't just a toy that I created for myself.'</strong>
</p></blockquote></div><p>I'm always thrilled that many people use Pyperclip and it isn't just a toy that I created for myself. I've learned a lot about making software that fits other people's needs. For example, with PyAutoGUI, I received bug reports from people with non-English keyboards or non-English language settings. These were issues that I would have never thought of if I was the only one using my creation.</p><p>It's given me an appreciation for just how much effort goes into making code that is robust enough for a wide and diverse set of users. I've made a few other open source projects, but Pyperclip and PyAutoGUI are the ones that taught me the most about writing software for other people.</p><p>
<strong>Driscoll</strong>: Are there any other major insights that you've learned from operating these popular open source<a id="id437" class="indexterm"/> projects?</p><p>
<strong>Sweigart</strong>: I've learned that, for the most part, people are really nice. I've heard some stories from open source maintainers about rude people demanding that you fix the bug they're encountering right then and there. But the people I've communicated with are really welcoming and even-handed about their criticisms. I really appreciate that.</p><p>
<strong>Driscoll</strong>: What advice would you give to<a id="id438" class="indexterm"/> anyone who is reluctant to share their code online?</p><p>
<strong>Sweigart</strong>: The sooner you put your code online and get people looking at it, the better.</p><p>You have to get over that fear of criticism, because I know code reviews have made me a better software developer more than anything else. You're missing out on so many opportunities to improve if you don't put yourself out there, and you can always post under an alias anyway.</p><div><blockquote class="blockquote"><p>
<strong>Al Sweigart: 'The sooner you put your code online and get people looking at it, the better.'</strong>
</p></blockquote></div><p>It's a lot like going to the gym. Sometimes people go to the gym and they're worried that everybody else is watching and judging them. But the other people at the gym are too busy thinking about themselves to notice them. I think the same thing applies to code. Most people don't actually read your code. I'm pretty sure that most technical recruiters who contacted me, never actually took the time to go through the hundreds of lines of code that I had out there already.</p><p>I tend to hate any code that I wrote more than two weeks ago. I look back on it and see so many mistakes and rough edges. A lot of programmers are like that. If you're worried that your code is too unpolished to post online, then at least you're in good company.</p><p>
<strong>Driscoll</strong>: So do you have any <a id="id439" class="indexterm"/>specific advice for someone who wants to create the next big open source package in Python?</p><p>
<strong>Sweigart</strong>: There's something <a id="id440" class="indexterm"/>called the Nobel Prize effect, which is when scientists win a Nobel Prize and then think, "What could I do to win a second Nobel Prize? I need to work on an even greater problem."</p><p>Then they set their sights way too high and never accomplish anything again. I sometimes feel that way about Pyperclip and PyAutoGUI because I didn't imagine they would become as popular as they did.</p><p>My GitHub profile has a ton of other repos that nobody has paid much attention to. So my advice would be to keep working on different ideas that you have. It's really hard to predict what's going to become popular. This was the case with the open source projects that I've created, but also with the books that I've written. I really had no idea that the successful things that I've worked on would be successful. Most of the things that I've worked on have not been successful at all.</p><p>Start small and keep growing. Learn from your mistakes and realize that you will make a lot of them. Put your code out there for criticism and learn to work with others, because all the big open source projects are made by teams, not by individuals. I think that's probably the best recipe for success.</p><div><blockquote class="blockquote"><p>
<strong>Al Sweigart: 'All the big open source projects are made by teams, not by individuals.'</strong>
</p></blockquote></div><p>
<strong>Driscoll</strong>: What are you most<a id="id441" class="indexterm"/> excited about in Python today?</p><p>
<strong>Sweigart</strong>: It seems like we're finally turning a corner when it comes to Python 3 adoption and for good reason.</p><p>There have been efficiency improvements to several places in the language and most notably to dictionaries in 3.6 (which are at the foundation of much of Python itself). The asyncio module seems like it could become a killer feature. But mostly I'm just excited that Python is being used by more people outside of software engineering like hobbyists, academics, and data scientists.</p><p>
<strong>Driscoll</strong>: What do you think about the long life of Python 2.7? Should everyone move to Python 3 now?</p><p>
<strong>Sweigart</strong>: Yes, absolutely people<a id="id442" class="indexterm"/> should move to Python 3. In 2018, the excuse that modules don't support Python 3 yet isn't true and hasn't been true for years.</p><p>The only reason to continue to use Python 2 is if you have a large existing codebase of Python 2 code, which, since Python had so much popularity early on, is unfortunately the case for a lot of codebases. But I feel at this point that there's been too many improvements to Python 3 <a id="id443" class="indexterm"/>to ignore.</p><div><blockquote class="blockquote"><p>
<strong>Al Sweigart: 'I feel at this point that there's been too many improvements to Python 3 to ignore.'</strong>
</p></blockquote></div><p>The better handling of Unicode strings was the selling point for me personally. I've seen a lot of code that just falls over the instant that someone uses non-ASCII characters in a string somewhere. I always thought it was odd that the versions before Python 3 were so awkward when it came to Unicode characters, until a friend pointed out that Python mostly predates Unicode. It's easy to forget how long Python has been around.</p><p>
<strong>Driscoll</strong>: So where do you see Python<a id="id444" class="indexterm"/> going as a language? What features do you see coming in, or which fields do you see Python opening up in?</p><p>
<strong>Sweigart</strong>: Python looks out at the programming landscape and weeps because there are no more worlds to conquer.</p><div><blockquote class="blockquote"><p>
<strong>Al Sweigart: 'Python looks out at the programming landscape and weeps because there are no more worlds to conquer.'</strong>
</p></blockquote></div><p>That's an exaggeration, of course. But it's amazing how many different areas Python is used in. It's a great general scripting language, but it's also used in massively scaled systems. It's used for web apps, but also machine learning. It's used by the largest tech companies, but also in high school computer science classes.</p><p>I'm trying to think about areas where Python hasn't been so successful. Embedded devices is one area, but MicroPython is addressing that as well. Python is a hard sell for triple-A gaming and VR, but it's great for hobbyist game makers and even a few indie game developers. Python is used for web app backends, but JavaScript is still the king of the frontend. I would love to see Python in the browser.</p><p>I've been a big fan of the changes in Python 3, if anything just because Python 3 got strings to finally work sensibly. A lot of programmers in the English-speaking world forget that ASCII is not a universal code. In fact, ASCII is not even universal in English-speaking countries. The original ASCII character set has a dollar sign, but not a British pound symbol. Writing code that won't <a id="id445" class="indexterm"/>break when somebody submits a string with accented letters is a huge win.</p><div><blockquote class="blockquote"><p>
<strong>Al Sweigart: 'The Python community itself is the best community in tech that I've ever found.'</strong>
</p></blockquote></div><p>What makes me optimistic about Python isn't the language itself, so much as the people behind it. The Python community itself is the best community in tech that I've ever found. They care about being open and inclusive, and that attracts a lot of new blood and fresh eyes. So I still think that Python has a lot of steam, even though it's been around for close to 30 years now. I think that Python is going to be relevant and sticking around for quite some time yet.</p><p>
<strong>Driscoll</strong>: Thank you, Al Sweigart.</p></div></body></html>