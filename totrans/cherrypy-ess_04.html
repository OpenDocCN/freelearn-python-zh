<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. CherryPy in Depth</h1></div></div></div><p>
<a class="link" href="ch03.html" title="Chapter 3. Overview of CherryPy">Chapter 3</a> introduced the common aspects of CherryPy without going into too much detail. In this chapter, we will dive into what makes CherryPy such a powerful library for the web developer by explaining key features, such as how to run multiple HTTP servers, use additional URI dispatchers, use the built-in tools and develop new ones, serve static contents, and finally how CherryPy and WSGI interact. This chapter will be dense but will be a good base to allow you to be more at ease and efficient with the product.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec01"/>HTTP Compliance</h1></div></div></div><p>CherryPy has been evolving slowly but surely to comply as much as it can with the HTTP specifications—firstly by supporting the old HTTP/1.0 and then moving gradually towards fully supporting HTTP/1.1, as defined in RFC 2616. CherryPy is said to be conditionally compliant with HTTP/1.1 as it implements all the<em> must</em> and<em> required</em> levels but not all the<em> should</em> levels of the specification. Therefore, CherryPy supports the following features of HTTP/1.1:<a id="id76" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>If a client claims to support HTTP/1.1, it must send a<code class="literal"> Host</code> header field in any request made with that protocol version. If it is not done, CherryPy will immediately stop the request processing with a<code class="literal"> 400</code> error code message (section 14.23 of RFC 2616).</p></li><li class="listitem"><p>CherryPy generates a<code class="literal"> Date</code> header field in all the configurations (section 14.18 of RFC 2616).</p></li><li class="listitem"><p>CherryPy does handle the<code class="literal"> Continue</code> response status code (<code class="literal">100</code>) on clients supporting it.</p></li><li class="listitem"><p>CherryPy's built-in HTTP server supports persistent connections that are the default in HTTP/1.1, through the use of the<code class="literal"> Connection: Keep-Alive</code> header. Be aware that changing the HTTP server (for more details refer to<a class="link" href="ch10.html" title="Chapter 10. Deployment">Chapter 10</a>) may break this compatibility, if the chosen server does not support such a feature.</p></li><li class="listitem"><p>CherryPy handles correctly chunked requests and responses.</p></li><li class="listitem"><p>CherryPy supports requests set with<code class="literal"> If-Modified-Since</code> and<code class="literal"> If-Unmodified-Since</code> headers and responds accordingly to each of them.</p></li><li class="listitem"><p>CherryPy allows any HTTP methods.</p></li><li class="listitem"><p>CherryPy handles all the combinations of HTTP versions between the client and the setting set for the server.<a id="id77" class="indexterm"/>
</p></li></ul></div><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.15069444444444" style="text-align: left" class="C1"/><col width="1.20833333333333" style="text-align: left" class="C2"/><col width="1.47083333333333" style="text-align: left" class="C3"/><col width="1.46944444444444" style="text-align: left" class="C4"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Request Protocol</p>
</th><th style="text-align: left" valign="bottom">
<p>Server Protocol</p>
</th><th style="text-align: left" valign="bottom">
<p>Written Response Protocol</p>
</th><th style="text-align: left" valign="bottom">
<p>Response Feature Set</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>1.0</p>
</td><td style="text-align: left" valign="top">
<p>1.0</p>
</td><td style="text-align: left" valign="top">
<p>1.0</p>
</td><td style="text-align: left" valign="top">
<p>1.0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1.0</p>
</td><td style="text-align: left" valign="top">
<p>1.1</p>
</td><td style="text-align: left" valign="top">
<p>1.1</p>
</td><td style="text-align: left" valign="top">
<p>1.0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1.1</p>
</td><td style="text-align: left" valign="top">
<p>1.0</p>
</td><td style="text-align: left" valign="top">
<p>1.0</p>
</td><td style="text-align: left" valign="top">
<p>1.0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1.1</p>
</td><td style="text-align: left" valign="top">
<p>1.1</p>
</td><td style="text-align: left" valign="top">
<p>1.1</p>
</td><td style="text-align: left" valign="top">
<p>1.1</p>
</td></tr></tbody></table></div><div><h3 class="title"><a id="note19"/>Note</h3><p>The server protocol can be modified via the<code class="literal"> server.protocol_version</code> key.</p><p>The written response protocol is the version returned in the HTTP response to inform the user-agent what protocol the server is supporting.</p><p>The response feature set protocol version is the one used internally by CherryPy during the response processing. In the second case, CherryPy only limits what it does to the response to HTTP/1.0.</p></div><p>All in all CherryPy 3 offers a wide range of capabilities, thanks to its good support of HTTP/1.1, and therefore can be safely used in a large set of scenarios.</p></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec02"/>Multiple HTTP Servers</h1></div></div></div><p>By default, CherryPy starts a single instance of its own built-in HTTP server. However, it may happen that:<a id="id78" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>You are required to have a different HTTP server. This will be covered extensively in<a class="link" href="ch10.html" title="Chapter 10. Deployment">Chapter 10</a>.</p></li><li class="listitem"><p>You are required to run your application on different network interfaces in one single Python process. CherryPy provides an API to run different HTTP server instances in one single process.</p></li></ul></div><p>First let us see how the CherryPy server is usually started:</p><div><pre class="programlisting">conf = {'global': {'server.socket_port': 100100,
'server.socket_host': 'localhost'}}
cherrypy.config.update(conf)
cherrypy.server.quickstart()
</pre></div><p>As you can see, we call the<code class="literal"> quickstart()</code> method of the server object, which will instantiate the built-in HTTP server and start it in its own thread.</p><p>Now imagine we have one application that we wish to run on different network interfaces; we should do as follows:</p><div><pre class="programlisting">from cherrypy import _cpwsgi
# Create a server on interface 1102.168.0.12 port 100100
s1 = _cpwsgi.CPWSGIServer()
s1.bind_addr = ('1102.168.0.12', 100100)
# Create a server on interface 1102.168.0.27 port 4700
s2 = _cpwsgi.CPWSGIServer()
s2.bind_addr = ('1102.168.0.27', 4700)
# Inform CherryPy which servers to start and use
cherrypy.server.httpservers = {s1: ('1102.168.0.12', 100100),
s2: ('1102.168.0.27', 4700)}
cherrypy.server.start()
</pre></div><p>As you can see, we first create two instances of the built-in HTTP server and for each we set the binding address on which the socket should be listening for incoming requests.</p><p>Then we attach those servers to the CherryPy pool of HTTP servers and call the<code class="literal"> start()</code> method, which will start each one on its interface.</p><p>Notice that we do not call<code class="literal"> cherrypy.config.update</code>, because it would update the global configuration settings shared by all the servers. However, this is not really an issue because each instance of the built-in server has the attributes matching the configuration keys. Thus:</p><div><pre class="programlisting">s1.socket_port = 100100
s1.socket_host = '1102.168.0.12'
s1.socket_file = ''
s1.socket_queue_size = 5
s1.socket_timeout = 10
s1.protocol_version = 'HTTP/1.1'
s1.reverse_dns = False
s1.thread_pool = 10
s1.max_request_header_size = 500 * 1024
s1.max_request_body_size = 100 * 1024 * 1024
s1.ssl_certificate = None
s1.ssl_private_key = None
</pre></div><p>As you can see, you can directly set the server instance settings and avoid using the global configuration. This technique also allows for an application to be served via HTTP and HTTPS at the same time as we will see in<a class="link" href="ch10.html" title="Chapter 10. Deployment">Chapter 10</a>.</p></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec03"/>Multi-Threaded Application Server</h1></div></div></div><p>CherryPy is designed around the threaded pattern. Although it is transparent to the developer, each time the application gets or sets a value into the CherryPy namespace, (<code class="literal">cherrypy.request</code> and<code class="literal"> cherrypy.response</code> objects mainly) it does so in a multi-threaded environment. Both<code class="literal"> cherrypy.request</code> and<code class="literal"> cherrypy.response</code> are thread-data containers, which imply that your application calls them independently by knowing which request is proxied through them at run time.<a id="id79" class="indexterm"/>
</p><p>When using the built-in CherryPy server, a pool of threads is created to handle incoming requests. The size of the pool is configured via the<code class="literal"> server.thread_pool</code> key, which defaults to<code class="literal"> 10</code>. Although it could sound like a good idea to create a larger pool of threads to improve the performance of the server, it is not always the case.</p><p>This value must be tuned as per application requirements. In fact if your application has a very short average request processing time, then it is likely that each thread will not be busy for a very long period of time. If you create a large pool of threads, it is more likely that most of them will just sit there, consuming your memory for very little benefit. It is therefore advisable to run performance testing against your application in different configurations in order to determine the best number of threads that should be created for your requirements.</p><p>Application servers using the threaded pattern are not always highly regarded because the use of threads is seen as increasing the likelihood of problems due to synchronization requirements. Alternatives exist, such as:</p><div><ul class="itemizedlist"><li class="listitem"><p>Multi-processes pattern: In this case, each request is handled by its own Python process. It is arguable that synchronization is easier but in some specific cases the performance and stability of the server can be better.</p></li><li class="listitem"><p>Asynchronous pattern: In this configuration, the operation of accepting new connections and sending back data to the client is done asynchronously from the request processing itself. This can be achieved, thanks to the capabilities of underlying operating systems allowing it. This technique has proven to be very efficient speed-wise. However, it requires a fairly different application development approach that can perturb some developers.</p></li></ul></div><p>All in all, which solution is the best can be debated ad infinitum and such questions will never really be answered. In fact, each scenario requires a different approach.</p></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec04"/>URI Dispatching</h1></div></div></div><p>As we have seen in the<a class="link" href="ch03.html" title="Chapter 3. Overview of CherryPy">Chapter 3</a>, by default CherryPy maps URIs to Python callables that have an<code class="literal"> exposed</code> attribute set to<code class="literal"> True</code>. Over time, it has appeared that the CherryPy community wants to be more flexible and that other dispatchers' solutions would be appreciated. That's why CherryPy 3 provides three other built-in dispatchers and offers a simple way to write and use your own dispatchers.<a id="id80" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>One is set to allow applications to be developed per HTTP methods. (GET, POST, PUT, etc.)</p></li><li class="listitem"><p>The second is based on a popular third-party package named Routes and developed by Ben Bangert from the original Ruby implementation for Ruby on Rails.</p></li><li class="listitem"><p>The third dispatcher is a Virtual Host one, which allows dispatching based on the domain requested rather than the URI path.</p></li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec01"/>HTTP Method Dispatcher</h2></div></div></div><p>In some applications, URIs are independent of the action to be performed by the server on the resource. For example, look at the following URI:<a id="id81" class="indexterm"/>
</p><div><pre class="programlisting">http://somehost.com/album/delete/12
</pre></div><p>As you can see, the URI contains the operation the client wishes to carry out. With the default CherryPy dispatcher this would map to something like:</p><div><pre class="programlisting">album.delete(12)
</pre></div><p>Although it's fine, you may wish to remove that operation from the URI itself and make it more independent, so that it would look like:</p><div><pre class="programlisting">http://somehost.com/album/12
</pre></div><p>You may wonder immediately how the server is supposed to know which operation to perform. This information is carried by the HTTP request itself, thanks to the HTTP method:</p><div><pre class="programlisting">DELETE /album/12 HTTP/1.1
</pre></div><p>The page handler handling such a request would look like the following:</p><div><pre class="programlisting">class Album:
exposed = True
def GET(self, id):
....
def POST(self, title, description):
....
def PUT(self, id, title, description):
....
def DELETE(self, id):
....
</pre></div><p>When using the HTTP method dispatcher, the page handler called would be<code class="literal"> album.DELETE(12)</code>.</p><p>If you look at the previous class definition, you will see that the methods do not carry the<code class="literal"> exposed</code> attribute but instead the class itself is set with that attribute. The reason for this comes from the way the dispatcher is implemented.</p><p>When a request reaches the server, CherryPy looks for the best matching page handler. When using the HTTP method dispatcher, the handler is in fact the conceptual representation of the resource targeted by the URI, in our example the instance of the<code class="literal"> album</code> class. Then the dispatcher checks if the class has a method matching the name of the HTTP method used for the request. If so, the dispatcher calls it with the remaining parameters. Otherwise, it sends back immediately an HTTP error code<code class="literal"> 405 Method Not Allowed</code> to inform the client that it cannot use the HTTP method and thus cannot perform that operation on that particular resource.<a id="id82" class="indexterm"/>
</p><p>For example, if we did not have a definition for<code class="literal"> DELETE</code> in the<code class="literal"> Album</code> class, such an error code would be returned upon the request we have used so far.</p><p>In any case, however, CherryPy will automatically add the<code class="literal"> Allow</code> HTTP header to the response to inform the client which methods it can use against the resource.</p><div><h3 class="title"><a id="note20"/>Note</h3><p>Note that in this case CherryPy does not look for<code class="literal"> index</code> or<code class="literal"> default</code> page handlers as it would with the URI-to-object dispatcher. This comes from a fundamental difference between dispatching based on the URI solely as compared to the URI+HTPP method.<a class="link" href="ch06.html" title="Chapter 6. Web Services">Chapter 6</a> will review this in more detail.</p></div><p>To enable the HTTP method dispatcher, you must set the<code class="literal"> request.dispatch</code> key to an instance of that dispatcher for the targeted path.</p><p>For example, if our whole application was built using that technique, we would use:</p><div><pre class="programlisting">{'/' : {'request.dispatch': cherrypy.dispatch.MethodDispatcher()}}
</pre></div><p>The HTTP method dispatcher is often used in applications following REST principles, as we will see in<a class="link" href="ch06.html" title="Chapter 6. Web Services">Chapter 6.</a>
<a id="id83" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec02"/>Routes Dispatcher</h2></div></div></div><p>Whether in the URI-to-object or HTTP-method dispatcher, we have not explicitly declared the URI associated with a page handler; instead we have left the responsibility of finding the best correspondence to the CherryPy engine. Many developers prefer the explicit approach and decide how URIs should map to page handlers.<a id="id84" class="indexterm"/>
</p><p>Therefore, when using the Routes dispatcher you must connect a pattern that matches URIs and associates a specific page handler.</p><p>Let's review an example:</p><div><pre class="programlisting">import cherrypy
class Root:
def index(self):
return "Not much to say"
def hello(self, name):
return "Hello %s" % name
if __name__ == '__main__':
root = Root()
# Create an instance of the dispatcher
d = cherrypy.dispatch.RoutesDispatcher()
# connect a route that will be handled by the 'index' handler
d.connect('default_route', '', controller=root)
# connect a route to the 'hello' handler
# this will match URIs such as '/say/hello/there'
# but not '/hello/there'
d.connect('some_other', 'say/:action/:name',
controller=root, action='hello')
# set the dispatcher
conf = {'/': {'request.dispatch': d}}
cherrypy.quickstart(root, '/', config=conf)
</pre></div><div><h3 class="title"><a id="note21"/>Note</h3><p>When using the Routes dispatcher handlers, you need not have an<code class="literal"> exposed</code> attribute.</p></div><p>The<code class="literal"> connect</code> method of the Routes dispatcher is defined as:</p><div><pre class="programlisting">connect(name, route, controller, **kwargs)
</pre></div><p>Here are the parameters for the<code class="literal"> connect</code> method:</p><div><ul class="itemizedlist"><li class="listitem"><p>The<code class="literal"> name</code> parameter is the unique name for the route to connect.</p></li><li class="listitem"><p>The<code class="literal"> route</code> is the pattern to match URIs.</p></li><li class="listitem"><p>The<code class="literal"> controller</code> is the instance containing page handlers.</p></li><li class="listitem"><p>
<code class="literal">**kwargs</code> allows you to pass on extra valid parameters for a route.</p></li></ul></div><p>Please refer to the official Routes documentation to understand how the package works.</p><p>By default, the CherryPy Routes dispatcher does not pass on the<code class="literal"> action</code> and<code class="literal"> controller</code> values returned by the Routes mapper when matching a URI against any of the route. These are not necessarily useful in a CherryPy application. However, if you need them you can set the<code class="literal"> fetch_result</code> parameter of the Routes dispatcher constructor to<code class="literal"> True</code>. Then both values will be passed on to page handlers but in this case you will have to add<code class="literal"> controller</code> and<code class="literal"> action</code> parameters to all your page handlers.<a id="id85" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec03"/>Virtual Host Dispatcher</h2></div></div></div><p>It may happen that you need to host different web applications within one CherryPy server with each application serving one given domain name. CherryPy provides an easy way to do this, as in the following example:<a id="id86" class="indexterm"/>
</p><div><pre class="programlisting">import cherrypy
class Site:
def index(self):
return "Hello, world"
index.exposed = True
class Forum:
def __init__(self, name):
self.name = name
def index(self):
return "Welcome on the %s forum" % self.name
index.exposed = True
if __name__ == '__main__':
site = Site()
site.cars = Forum('Cars')
site.music = Forum('My Music')
hostmap = {'www.ilovecars.com': '/cars',
'www.mymusic.com': '/music',}
cherrypy.config.update({'server.socket_port': 80})
conf = {'/': {'request.dispatch': cherrypy.dispatch.VirtualHost(**hostmap)}}
cherrypy.tree.mount(site, config=conf)
cherrypy.server.quickstart()
cherrypy.engine.start()
</pre></div><p>First, as you can see, we simply create a tree of applications. Next, we define the<code class="literal"> hostmap</code> dictionary, which will inform the<code class="literal"> VirtualHost</code> dispatcher how to serve a request based on its domain. Thus the requests coming from <a class="ulink" href="http://www.mymusic.com">www.mymusic.com</a> will be served by the application mounted at the<code class="literal"> /music</code> prefix. Next, we tell CherryPy that we will be using the<code class="literal"> VirtualHost</code> dispatcher and we finally mount the site application and start the server as usual.<a id="id87" class="indexterm"/>
</p><p>Note that this example will require that you edit your<code class="literal"> hosts</code> file on your machine to add the following two domains:</p><div><pre class="programlisting">127.0.0.1 www.ilovecars.com
127.0.0.1 www.mymusic.com
</pre></div><p>It will automatically redirect requests to those domains to your local server instead of looking for them on the Internet. Once you have finished with this example, you ought to remove these lines from the<code class="literal"> hosts</code> file.</p></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec05"/>Hook into CherryPy's Core Engine</h1></div></div></div><p>One of the most powerful aspects of CherryPy is how its core lets you modify its normal behavior with a very fine granularity. Indeed, CherryPy offers a mechanism called hooking to customize the core engine.<a id="id88" class="indexterm"/>
</p><p>A<strong> hook</strong> is an entry point for Python callables to be applied at specific points during the request processing. CherryPy provides the following entry points:<a id="id89" class="indexterm"/>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.84041686158411" style="text-align: left" class="C1"/><col width="3.63731944444444" style="text-align: left" class="C2"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Hook Point</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">on_start_resource</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Called at the beginning of the process.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">before_request_body</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Called before CherryPy tries to read the request body. It allows a tool to inform CherryPy whether this action should be performed by setting the<code class="literal"> process_request_body</code> attribute to<code class="literal"> False</code> within the tool.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">before_handler</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Called before the page handler is invoked. A tool could for instance set the handler to<code class="literal"> None</code> to inform CherryPy that it should not process the page handler.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">before_finalize</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Called whether or not the page handler has been called and before CherryPy starts processing the response.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">on_end_resource</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Called when the resource processing is terminated.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">before_error_response after_error_response</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Called when an error is trapped by the CherryPy engine to allow the application to recover and decide what to do next.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">on_end_request</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Called at the end of the overall processing, right after the link with the client has been closed. This allows you to free resources.</p>
</td></tr></tbody></table></div><p>The following figure shows the global process followed by CherryPy when handling a request. The black lines and arrows show the normal flow while the gray ones indicate the path when an error occurs.<a id="id90" class="indexterm"/>
</p><div><img src="img/1848_04_01.jpg" alt="Hook into CherryPy's Core Engine"/></div><p>Attaching a callback at one of these hook points is done via a call to:</p><div><pre class="programlisting">cherrypy.request.hooks.attach(point, callback, failsafe=None,
priority=None, **kwargs)
</pre></div><p>The first parameter is the name of the hook point as shown in the previous table. The second parameter is the Python callable that will be applied. The third parameter indicates to CherryPy that even if another callback may fail during the processing of this hook point, CherryPy must run this callable. The last parameter must be a value between 0 and 100 to indicate the weight of each callback and provide a way to order them. Lower values will be run first.</p><p>The<code class="literal"> failsafe</code> argument is quite helpful as it offers a way for an application to be flexible and recover from problems that may occur. Indeed some callbacks may fail without impacting the whole chain of the request processing.<a id="id91" class="indexterm"/>
</p><div><h3 class="title"><a id="note22"/>Note</h3><p>Note that you can obviously attach as many callbacks as required at a given hook point. Callbacks can be hooked on the fly while the application is running as well. However, the more callbacks you attach, the slower the processing of that hook point will become.</p></div><p>The hooking mechanism is fairly close to what used to be called filters in CherryPy 2. However, it was observed over time that they were too low level and were making users uncomfortable most of the time. That's why it is still rare for developers to use them directly as is. Instead they are applied through a higher-level interface named tools.</p></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec06"/>CherryPy Toolbox</h1></div></div></div><p>The tool interface has been designed by Robert Brewer while refactoring CherryPy. The goal was to offer ready-to-employ tools achieving common tasks with a friendly and flexible API. Within CherryPy, built-in tools offer a single interface to call the CherryPy library that we have reviewed in<a class="link" href="ch03.html" title="Chapter 3. Overview of CherryPy">Chapter 3</a> using the hooking mechanism.<a id="id92" class="indexterm"/>
</p><p>As we have seen in<a class="link" href="ch03.html" title="Chapter 3. Overview of CherryPy">Chapter 3</a> tools can be used in three different ways:</p><div><ul class="itemizedlist"><li class="listitem"><p>From the configuration settings</p></li><li class="listitem"><p>As a Python decorator or via the special<code class="literal"> _cp_config</code> attribute of a page handler</p></li><li class="listitem"><p>As a Python callable that can be applied from within any function</p></li></ul></div><p>Thanks to this flexibility, a tool can be set either globally to a path and its subset or to a particular page handler. Let's now review the built-in tools provided by CherryPy.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec04"/>Basic Authentication Tool</h2></div></div></div><p>
<strong>Purpose:</strong> The purpose of this tool is to provide basic authentication (RFC 2617) to your application.</p><p>
<strong>Arguments:</strong>
<a id="id93" class="indexterm"/>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="0.829180555555555" style="text-align: left" class="C1"/><col width="1.82022222222222" style="text-align: left" class="C2"/><col width="2.82293055555556" style="text-align: left" class="C3"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">realm</code>
</p>
</td><td style="text-align: left" valign="top">
<p>N/A ( N/A in this case means the parameter must be provided by the developer as it has no default.)</p>
</td><td style="text-align: left" valign="top">
<p>String defining the realm value.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">users</code>
</p>
</td><td style="text-align: left" valign="top">
<p>N/A</p>
</td><td style="text-align: left" valign="top">
<p>Dictionary of the form username:password or a Python callable returning such a dictionary.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">encrypt</code>
</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>Python callable used to encrypt the password returned by the client and compare it with the encrypted password provided in the users dictionary. If None it uses an MD5 hash.</p>
</td></tr></tbody></table></div><p>
<strong>Example:</strong>
</p><div><pre class="programlisting">import sha
import cherrypy
class Root:
@cherrypy.expose
def index(self):
return """&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;a href="admin"&gt;Admin area&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
"""
class Admin:
@cherrypy.expose
def index(self):
return "This is a private area"
if __name__ == '__main__':
def get_users():
# 'test': 'test'
return {'test': 'a104a8fe5ccb110ba61c4c0873d3101e10871082fbbd3'}
def encrypt_pwd(token):
return sha.new(token).hexdigest()
conf = {'/admin': {'tools.basic_auth.on': True,
'tools.basic_auth.realm': 'Some site',
'tools.basic_auth.users': get_users,
'tools.basic_auth.encrypt': encrypt_pwd}}
root = Root()
root.admin = Admin()
cherrypy.quickstart(root, '/', config=conf)
</pre></div><p>The<code class="literal"> get_users</code> function returns a hard-coded dictionary but it could also fetch the values from a database or anywhere else. Keep in mind that the basic authentication scheme is not really secure as the password is only encoded and can be decoded on the fly if someone captures it. This scheme is, however, often used over SSL because it is the easiest to put in place while the Secure Socket Layer encrypts the enclosed data.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec05"/>Caching Tool</h2></div></div></div><p>
<strong>Purpose:</strong> The purpose of this tool is to provide basic in-memory caching of CherryPy generated content.<a id="id94" class="indexterm"/>
</p><p>
<strong>Arguments:</strong>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.45834722222222" style="text-align: left" class="C1"/><col width="1.19587777777778" style="text-align: left" class="C2"/><col width="2.767375" style="text-align: left" class="C3"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">invalid_methods</code>
</p>
</td><td style="text-align: left" valign="top">
<p>("POST", "PUT", "DELETE")</p>
</td><td style="text-align: left" valign="top">
<p>Tuples of strings of HTTP methods not to be cached. These methods will also invalidate (delete) any cached copy of the resource.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">cache_class</code>
</p>
</td><td style="text-align: left" valign="top">
<p>MemoryCache</p>
</td><td style="text-align: left" valign="top">
<p>Class object to be used for caching.</p>
</td></tr></tbody></table></div><p>A comprehensive example would be out of the scope of this book but if you are interested in this tool you should first look at the CherryPy test suite as well as visit the CherryPy users' mailing-list.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec06"/>Decoding Tool</h2></div></div></div><p>
<strong>Purpose:</strong> The purpose of this tool is to decode the incoming request parameters.</p><p>
<strong>Arguments:</strong>
<a id="id95" class="indexterm"/>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.375" style="text-align: left" class="C1"/><col width="0.885416666666667" style="text-align: left" class="C2"/><col width="3.01736111111111" style="text-align: left" class="C3"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">encoding</code>
</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>What encoding is to be used to decode the incoming content? If None it looks for the<code class="literal"> Content-Type</code> header and if it cannot find a suitable charset it uses<code class="literal"> default_encoding</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">default_encoding</code>
</p>
</td><td style="text-align: left" valign="top">
<p>"UTF-8"</p>
</td><td style="text-align: left" valign="top">
<p>Default encoding to be used when none is provided or found.</p>
</td></tr></tbody></table></div><p>
<strong>Example:</strong>
</p><div><pre class="programlisting">import cherrypy
from cherrypy import tools
class Root:
@cherrypy.expose
def index(self):
return """&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;form action="hello" method="post"&gt;
&lt;input type="text" name="name" value="" /&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
"""
@cherrypy.expose
@tools.decode(encoding='ISO-88510-1')
def hello(self, name):
return "Hello %s" % (name, )
if __name__ == '__main__':
cherrypy.quickstart(Root(), '/')
</pre></div><p>In this case when the HTML form is sent to the server, CherryPy tries to decode the incoming data using the encoding we have set. If you look at the type of the<code class="literal"> name</code> parameter you will see that when using the decoding tool it is<em> Unicode</em> whereas without the tool it is a<em> string</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec07"/>Digest Authentication Tool</h2></div></div></div><p>
<strong>Purpose:</strong> The purpose of this tool is to provide digest authentication as defined in RFC 2617.<a id="id96" class="indexterm"/>
</p><p>
<strong>Arguments:</strong>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.17638888888889" style="text-align: left" class="C1"/><col width="1.08402777777778" style="text-align: left" class="C2"/><col width="3.01736111111111" style="text-align: left" class="C3"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">realm</code>
</p>
</td><td style="text-align: left" valign="top">
<p>N/A</p>
</td><td style="text-align: left" valign="top">
<p>String defining the realm value.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">users</code>
</p>
</td><td style="text-align: left" valign="top">
<p>N/A</p>
</td><td style="text-align: left" valign="top">
<p>Dictionary of the form—username:password or a Python callable returning such a dictionary.</p>
</td></tr></tbody></table></div><p>
<strong>Example:</strong>
</p><div><pre class="programlisting">import cherrypy
class Root:
@cherrypy.expose
def index(self):
return """&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;a href="admin"&gt;Admin area&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
"""
class Admin:
@cherrypy.expose
def index(self):
return "This is a private area"
if __name__ == '__main__':
def get_users():
return {'test': 'test'}
conf = {'/admin': {'tools.digest_auth.on': True,
'tools.digest_auth.realm': 'Some site',
'tools.digest_auth.users': get_users}}
root = Root()
root.admin = Admin()
cherrypy.quickstart(root, '/', config=conf)
</pre></div><p>Note that the digest tool does not provide a way to pass an encrypted password. The reason for this is that the digest scheme is defined not to send the password across the wire as clear text. The way it works is as follows:</p><div><ol class="orderedlist"><li class="listitem"><p>1. The client requests to access the resource. The server returns a<code class="literal"> 401</code> error code indicating it uses the digest scheme. The server provides a token for this exchange.</p></li><li class="listitem"><p>2. The client creates a new message based on the token, the username, and the password and generates a hash via the MD5 algorithm.</p></li><li class="listitem"><p>3. Upon receiving the new message from the client, the server tries to generate the same values. If they all match, the authentication is allowed.</p></li></ol></div><p>As you can see, the password never transits as clear text on the wire. Discussions have taken place to decide how the digest tool can be evolved in order to avoid the need to store passwords as clear text. One way would be to store one of the intermediate steps of the digest token (step 1) and compare this value with what has been sent by the client. This is beyond the scope of this book but you can get more information from the CherryPy mailing lists.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec08"/>Encode Tool</h2></div></div></div><p>
<strong>Purpose:</strong> The purpose of this tool is to encode the response content in a defined encoding.<a id="id97" class="indexterm"/>
</p><p>
<strong>Arguments:</strong>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.02361805555556" style="text-align: left" class="C1"/><col width="1.00764583333333" style="text-align: left" class="C2"/><col width="3.24304861111111" style="text-align: left" class="C3"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">encoding</code>
</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>What encoding is to be used to encode the response? If None, it looks for the<code class="literal"> Content-Type</code> header and sets a suitable charset if it can.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">errors</code>
</p>
</td><td style="text-align: left" valign="top">
<p>"strict"</p>
</td><td style="text-align: left" valign="top">
<p>Defines how the tool must react when it fails to encode a character.</p>
</td></tr></tbody></table></div><p>
<strong>Example:</strong>
</p><div><pre class="programlisting">import cherrypy
from cherrypy import tools
class Root:
@cherrypy.expose
def index(self):
return """&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;form action="hello" method="post"&gt;
&lt;input type="text" name="name" value="" /&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
"""
@cherrypy.expose
@tools.encode(encoding='ISO-88510-15')
def hello(self, name):
return "Hello %s" % name
if __name__ == '__main__':
cherrypy.quickstart(Root(), '/')
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec09"/>Error Redirect Tool</h2></div></div></div><p>
<strong>Purpose:</strong> The purpose of this tool is to modify the default CherryPy error handler.<a id="id98" class="indexterm"/>
</p><p>
<strong>Arguments:</strong>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.17638888888889" style="text-align: left" class="C1"/><col width="1.08402777777778" style="text-align: left" class="C2"/><col width="3.01736111111111" style="text-align: left" class="C3"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">url</code>
</p>
</td><td style="text-align: left" valign="top">
<p>''</p>
</td><td style="text-align: left" valign="top">
<p>The URL to which it should be redirected.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">internal</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">True</code>
</p>
</td><td style="text-align: left" valign="top">
<p>When<code class="literal"> True</code>, the redirection is hidden from the client and happens only within the context of this request. If<code class="literal"> False</code>, CherryPy informs the client that a redirection should be issued by the client itself to the URL provided.</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec10"/>Etag Tool</h2></div></div></div><p>
<strong>Purpose:</strong> The purpose of this tool is to validate an<strong> Entity Tag</strong> (<strong>Etag</strong>) sent by a user agent and generate the response accordingly as defined by RFC 2616 section 14.24. Etags are one of the ways to cache HTTP responses and thus diminish the burden on any parties involved.<a id="id99" class="indexterm"/>
</p><p>
<strong>Argument:</strong>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.17638888888889" style="text-align: left" class="C1"/><col width="1.08402777777778" style="text-align: left" class="C2"/><col width="3.01736111111111" style="text-align: left" class="C3"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">autotags</code>
</p>
</td><td style="text-align: left" valign="top">
<p>False</p>
</td><td style="text-align: left" valign="top">
<p>When<code class="literal"> True</code> the tool will generate an<code class="literal"> etag</code> value based on the response body set.</p>
</td></tr></tbody></table></div><p>
<strong>Example:</strong>
</p><div><pre class="programlisting">import cherrypy
from cherrypy import tools
class Root:
@cherrypy.expose
def index(self):
return """&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;form action="hello" method="post"&gt;
&lt;input type="text" name="name" value="" /&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
"""
@cherrypy.expose
def hello(self, name):
return "Hello %s" % name
if __name__ == '__main__':
conf = {'/': {'tools.etags.on': True,
'tools.etags.autotags': True}}
cherrypy.quickstart(Root(), '/', config=conf)
</pre></div><p>In the previous example, we set the<code class="literal"> etags</code> tool for the whole application. On the first request to the<code class="literal"> index</code> page handler, the tool will generate an<code class="literal"> etag</code> value and insert it in the response headers. On the next request to that URI, the client will include the last received<code class="literal"> etag</code>. The tool will compare it with the current one and if they match the response will be<code class="literal"> 304 Not Modified</code> informing the client that it can safely use its copy of the resource.</p><p>Note that if you need the<code class="literal"> etag</code> value to be computed in a different fashion, the best way is to set the<code class="literal"> autotags</code> parameter to<code class="literal"> False</code>, the default, and then from within your page handler add the<code class="literal"> Etag</code> header yourself to the response headers.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec11"/>Gzip Tool</h2></div></div></div><p>
<strong>Purpose:</strong> The purpose of this tool is to perform content encoding on the response body.</p><p>
<strong>Arguments:</strong>
<a id="id100" class="indexterm"/>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.28063297254966" style="text-align: left" class="C1"/><col width="2.30741543257378" style="text-align: left" class="C2"/><col width="1.86772304871027" style="text-align: left" class="C3"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">compress_level</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">10</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Level of compression to be achieved. The lower it is, the faster it will be.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">mime_types</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">['text/html', 'text/plain']</code>
</p>
</td><td style="text-align: left" valign="top">
<p>List of MIME types that can be compressed.</p>
</td></tr></tbody></table></div><p>
<strong>Example:</strong>
</p><div><pre class="programlisting">import cherrypy
from cherrypy import tools
class Root:
@cherrypy.expose
@tools.gzip()
def index(self):
return "this will be compressed"
if __name__ == '__main__':
cherrypy.quickstart(Root(), '/')
</pre></div><p>Note that the<code class="literal"> gzip</code> tool should not be used when the response is streamed via its<code class="literal"> stream</code> attribute. Indeed in this case CherryPy starts sending the body as soon as it has something to send, for instance when the page handler yields the content, instead of returning it.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec12"/>Ignore Headers Tool</h2></div></div></div><p>
<strong>Purpose:</strong> The purpose of this tool is to remove the specified headers from the HTTP request before they are processed by CherryPy.<a id="id101" class="indexterm"/>
</p><p>
<strong>Argument:</strong>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.37084722222222" style="text-align: left" class="C1"/><col width="1.60140277777778" style="text-align: left" class="C2"/><col width="2.52688194444444" style="text-align: left" class="C3"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ignore_headers</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">headers=('Range',)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Tuple of header names to be disregarded.</p>
</td></tr></tbody></table></div><p>
<strong>Example:</strong>
</p><div><pre class="programlisting">import cherrypy
from cherrypy import tools
class Root:
@cherrypy.expose
@tools.ignore_headers(headers=('Accept-Language',))
def index(self):
return "Accept-Language: %s" \
% cherrypy.request.headers.get('Accept-Language',
'none provided')
@cherrypy.expose
def other(self):
return "Accept-Language: %s" % cherrypy.request.headers.get('Accept-Language')
if __name__ == '__main__':
cherrypy.quickstart(Root(), '/')
</pre></div><p>If you access <a class="ulink" href="http://localhost:8080/">http://localhost:8080/</a>, you will get the following message whether or not the client has indeed set that header:</p><div><pre class="programlisting">Accept-Language: none provided
</pre></div><p>If you navigate to <a class="ulink" href="http://localhost:8080/other">http://localhost:8080/other</a> you will get the following message:</p><div><pre class="programlisting">Accept-Language: en-us,en;q=0.5
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec13"/>Log Headers Tool</h2></div></div></div><p>
<strong>Purpose:</strong> The purpose of this tool is to dump request headers into the error log file when an error occurs on the server. This tool is disabled by default.<a id="id102" class="indexterm"/>
</p><p>
<strong>Argument:</strong> None</p><p>
<strong>Example:</strong>
</p><div><pre class="programlisting">import cherrypy
from cherrypy import tools
class Root:
@cherrypy.expose
def index(self):
raise StandardError, "Some sensible error message here"
if __name__ == '__main__':
cherrypy.config.update({'global': {'tools.log_headers.on':
True}})
cherrypy.quickstart(Root(), '/')
</pre></div><p>When you access <a class="ulink" href="http://localhost:8080">http://localhost:8080</a>, the error will be raised and the error log will show the request headers. Note that in this case this tool is set at the web-server level via the<code class="literal"> cherrypy.config.update()</code> method but it can be applied on a per path basis as well.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec14"/>Log Tracebacks Tool</h2></div></div></div><p>
<strong>Purpose:</strong> The purpose of this tool is to dump the error's traceback into the error log file when an exception is raised. This tool is enabled by default.<a id="id103" class="indexterm"/>
</p><p>
<strong>Argument:</strong> None</p><p>
<strong>Example:</strong>
</p><div><pre class="programlisting">import cherrypy
from cherrypy import tools
class Root:
@cherrypy.expose
def index(self):
raise StandardError, "Some sensible error message here"
if __name__ == '__main__':
# This tool is applied globally to the CherryPy process
# by using the global cherrypy.config.update method.
cherrypy.config.update({'global': {'tools.log_tracebacks.on':
False}})
cherrypy.quickstart(Root(), '/')
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec15"/>Proxy Tool</h2></div></div></div><p>
<strong>Purpose:</strong> The purpose of this tool is to change the base URL of the requests. This is especially helpful when running the application behind another server such as Apache.<a id="id104" class="indexterm"/>
</p><p>
<strong>Arguments:</strong>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="0.664035296196678" style="text-align: left" class="C1"/><col width="1.34305555555556" style="text-align: left" class="C2"/><col width="3.4418033796879" style="text-align: left" class="C3"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">base</code>
</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>If set and<code class="literal"> local</code> is none, this will be the new base URL available from<code class="literal"> cherrypy.request.base</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">local</code>
</p>
</td><td style="text-align: left" valign="top">
<p>'X-Forwarded-Host'</p>
</td><td style="text-align: left" valign="top">
<p>Which header to look at for the local hosts set for instance by the front-end web server.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">remote</code>
</p>
</td><td style="text-align: left" valign="top">
<p>'X-Forwarded-For'</p>
</td><td style="text-align: left" valign="top">
<p>Header to look for the IP address of the originating client.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">scheme</code>
</p>
</td><td style="text-align: left" valign="top">
<p>'X-Forwarded-Proto'</p>
</td><td style="text-align: left" valign="top">
<p>Header to look for the original scheme used:<em> http</em> or<em> https</em> for instance.</p>
</td></tr></tbody></table></div><p>When the base is not set, the tool will build the new base URI from the values fetched from the request headers based on the other parameters.</p><p>
<strong>Example:</strong>
</p><div><pre class="programlisting">import cherrypy
from cherrypy import tools
class Root:
@cherrypy.expose
def index(self):
return "Base URL: %s %s " % (cherrypy.request.base,
cherrypy.url(''))
@cherrypy.expose
def other(self):
raise cherrypy.HTTPRedirect(cherrypy.url(''))
if __name__ == '__main__':
conf = {'global': {'tools.proxy.on': True,
'tools.proxy.base': 'http://someapp.net/blog',
'tools.proxy.local': ''}}
cherrypy.config.update(conf)
cherrypy.quickstart(Root(), '/')
</pre></div><p>When navigating to <a class="ulink" href="http://localhost:8080">http://localhost:8080</a> you will see the following message:</p><div><pre class="programlisting">Base URL: http://someapp.net/blog http://someapp.net/blog/
</pre></div><p>If you navigate to <a class="ulink" href="http://localhost:8080/other">http://localhost:8080/other</a>, you will be redirected to <a class="ulink" href="http://someapp.net/blog/">http://someapp.net/blog/</a>, which shows that the proxy tools ensure in a transparent manner that the CherryPy library stays coherent in behavior in accordance with the settings you provide.</p><p>For more examples on using this tool behind another server please see<a class="link" href="ch10.html" title="Chapter 10. Deployment">Chapter 10</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec16"/>Referer Tool</h2></div></div></div><p>
<strong>Purpose:</strong> The purpose of this tool is to allow the filtering of requests based on a pattern. Requests can be rejected or accepted after matching the pattern.<a id="id105" class="indexterm"/>
</p><p>
<strong>Arguments:</strong>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.17638888888889" style="text-align: left" class="C1"/><col width="1.20973333333333" style="text-align: left" class="C2"/><col width="3.02499166666667" style="text-align: left" class="C3"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">pattern</code>
</p>
</td><td style="text-align: left" valign="top">
<p>N/A</p>
</td><td style="text-align: left" valign="top">
<p>Regular expression pattern.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">accept</code>
</p>
</td><td style="text-align: left" valign="top">
<p>True</p>
</td><td style="text-align: left" valign="top">
<p>If<code class="literal"> True</code> any matching referer will allow the request to proceed. Otherwise, any matching referer will cause the request to be rejected.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">accept_missing</code>
</p>
</td><td style="text-align: left" valign="top">
<p>False</p>
</td><td style="text-align: left" valign="top">
<p>Whether requests with no referer can be allowed or not.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">error</code>
</p>
</td><td style="text-align: left" valign="top">
<p>403</p>
</td><td style="text-align: left" valign="top">
<p>HTTP error code to be returned to the user agent upon refusal.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">message</code>
</p>
</td><td style="text-align: left" valign="top">
<p>'Forbidden Referer header.'</p>
</td><td style="text-align: left" valign="top">
<p>Message to be returned to the user agent upon refusal.</p>
</td></tr></tbody></table></div><p>
<strong>Example:</strong>
</p><div><pre class="programlisting">import cherrypy
from cherrypy import tools
class Root:
@cherrypy.expose
def index(self):
return cherrypy.request.headers.get('Referer')
if __name__ == '__main__':
conf = {'/': {'tools.referer.on': True,
'tools.referer.pattern': 'http://[^/]*dodgy\.com',
'tools.referer.accept': False}}
cherrypy.quickstart(Root(), '/', config=conf)
</pre></div><p>In this example, we will reject all requests coming from the<code class="literal"> dodgy.com</code> domain and sub-domains.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec17"/>Response Headers Tool</h2></div></div></div><p>
<strong>Purpose:</strong> The purpose of this tool is to allow some common headers to be set for all or many page handlers at once.<a id="id106" class="indexterm"/>
</p><p>
<strong>Argument:</strong>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.17638888888889" style="text-align: left" class="C1"/><col width="1.34305555555556" style="text-align: left" class="C2"/><col width="2.75833333333333" style="text-align: left" class="C3"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">headers</code>
</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>List of tuples: header, value</p>
</td></tr></tbody></table></div><p>
<strong>Example:</strong>
</p><div><pre class="programlisting">import cherrypy
from cherrypy import tools
class Root:
@cherrypy.expose
def index(self):
return "Some text"
@cherrypy.expose
def other(self):
return "Some other text"
if __name__ == '__main__':
conf = {'/': {'tools.response_headers.on': True,
'tools.response_headers.headers': [('Content-Type',
'text/plain')]}}
cherrypy.quickstart(Root(), '/', config=conf)
</pre></div><p>In this example, the tool sets<code class="literal"> Content-Type</code> to<code class="literal"> text/plain</code> for all page handlers.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec18"/>Trailing Slash Tool</h2></div></div></div><p>
<strong>Purpose:</strong> The purpose of this tool is to provide a flexible way to deal with the trailing slash of requests. This tool is enabled by default.<a id="id107" class="indexterm"/>
</p><p>
<strong>Arguments:</strong>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="0.995847222222222" style="text-align: left" class="C1"/><col width="1.05140277777778" style="text-align: left" class="C2"/><col width="3.21668055555556" style="text-align: left" class="C3"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">missing</code>
</p>
</td><td style="text-align: left" valign="top">
<p>True</p>
</td><td style="text-align: left" valign="top">
<p>If the page handler is the index, if the<code class="literal"> missing</code> parameter is<code class="literal"> True</code>, and if the request missed a trailing slash, CherryPy will automatically issue a redirection towards the URI with the additional slash at the end.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">extra</code>
</p>
</td><td style="text-align: left" valign="top">
<p>False</p>
</td><td style="text-align: left" valign="top">
<p>If the page handler is not the index, if the<code class="literal"> extra</code> parameter is set to<code class="literal"> True</code>, and if the URI has a trailing slash, CherryPy will issue a redirection towards the URI without the trailing slash.</p>
</td></tr></tbody></table></div><p>
<strong>Example:</strong>
</p><div><pre class="programlisting">import cherrypy
from cherrypy import tools
class Root:
@cherrypy.expose
def index(self):
return "This should have been redirected to add the trailing
slash"
@cherrypy.expose
def nothing(self):
return "This should have NOT been redirected"
nothing._cp_config = {'tools.trailing_slash.on': False}
@cherrypy.expose
def extra(self):
return "This should have been redirected to remove the
trailing slash"
extra._cp_config = {'tools.trailing_slash.on': True,
'tools.trailing_slash.missing': False,
'tools.trailing_slash.extra': True}
if __name__ == '__main__':
cherrypy.quickstart(Root(), '/')
</pre></div><p>To understand this tool, navigate to the following URLs:</p><p>
<a class="ulink" href="http://localhost:8080">http://localhost:8080</a>
</p><p>
<a class="ulink" href="http://localhost:8080/nothing">http://localhost:8080/nothing</a>
</p><p>
<a class="ulink" href="http://localhost:8080/nothing/">http://localhost:8080/nothing/</a>
</p><p>
<a class="ulink" href="http://localhost:8080/extra/">http://localhost:8080/extra/</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec19"/>XML-RPC Tool</h2></div></div></div><p>
<strong>Purpose:</strong> The purpose of this tool is to transform CherryPy into an XML-RPC server and make page handlers XML-RPC callables.<a id="id108" class="indexterm"/>
</p><p>
<strong>Argument:</strong> None</p><p>
<strong>Example:</strong>
</p><div><pre class="programlisting">import cherrypy
from cherrypy import _cptools
class Root:
@cherrypy.expose
def index(self):
return "Regular web page handler"
class XMLRPCApp(_cptools.XMLRPCController):
@cherrypy.expose
def echo(self, message):
return message
if __name__ == '__main__':
root = Root()
root.xmlrpc = XMLRPCApp()
cherrypy.quickstart(root, '/')
</pre></div><p>The<code class="literal"> XMLRPCController</code> is a helper class that should be used instead of the XML-RPC tool directly.</p><p>You can then test your XML-RPC handler as follows:</p><div><pre class="programlisting">&gt;&gt;&gt; import xmlrpclib
&gt;&gt;&gt; s = xmlrpclib.ServerProxy('http://localhost:8080/xmlrpc')
&gt;&gt;&gt; s.echo('test')
'test'
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec20"/>Toolbox</h2></div></div></div><p>CherryPy tools must belong to a toolbox that is to be managed by the CherryPy engine. Toolboxes have their own namespace to avoid name collision. Although nothing prevents you from using the default toolbox you can create one of your own as follows:</p><div><pre class="programlisting">from cherrypy._cptools import Toolbox,
mytb = Toolbox('mytb')
mytb.xml_parse = Tool('before_handler', xmlparse)
conf = {'/': {'mytb.xml_parse.on': True,
'mytb.xml_parse.engine': 'amara'}}
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec21"/>Creating a Tool</h2></div></div></div><p>Now that we have reviewed the toolbox shipped with CherryPy, we will explain how to write a tool. Before deciding to create a tool you should ask yourself a few questions such as:<a id="id109" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>Should the added feature be handled at the CherryPy level?</p></li><li class="listitem"><p>At which level of the request processing should this be applied?</p></li><li class="listitem"><p>Will you modify CherryPy's default behavior?</p></li></ul></div><p>These questions simply allow you to make sure that the feature you want to add is at the right level. Tools can sometimes look like a pattern on their own, upon which you can design your application.</p><p>We will create a tool that will read and parse XML contained in a request body into a page handler parameter. To do so, we will be using the ElementTree library. (ElementTree is maintained by Fredrik Lundh and Amara by Uche Ogbuji.)</p><p>A tool is created either by sub-classing the<code class="literal"> Tool</code> class or via an instance of that class as shown in the following example. Instantiating the<code class="literal"> Tool</code> class is the most common case to consider and it is the one we will be discussing.</p><p>The class constructor declaration is as follows:</p><div><pre class="programlisting">Tool(point, callable, name=None, priority=50)
</pre></div><div><ul class="itemizedlist"><li class="listitem"><p>The<code class="literal"> point</code> parameter is a string indicating to which hook point this tool should be attached.</p></li><li class="listitem"><p>The<code class="literal"> callable</code> parameter is a Python callable that will be applied.</p></li><li class="listitem"><p>The<code class="literal"> name</code> parameter defines what the name of the tool will be within the toolbox. When it is not provided, it uses the name of the attribute holding the instance of the tool within the toolbox (refer to our example).</p></li><li class="listitem"><p>The<code class="literal"> priority</code> sets the order of the tools when several tools are attached at the same hook point.<a id="id110" class="indexterm"/>
</p></li></ul></div><p>Once an instance of the tool is created, you can attach it to the built-in toolbox as follows:</p><div><pre class="programlisting">cherrypy.tools.mytool = Tool('on_start_resource', mycallable)
</pre></div><p>This tool will be available like any other built-in tools to your application.<a id="id111" class="indexterm"/>
</p><p>When creating a tool, you can provide two attributes to your callable that will be used when initializing the tool. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem"><p>
<code class="literal">failsafe:</code> If<code class="literal"> True</code>, it means the tool will run even when an error is raised before the tool's turn. It defaults to<code class="literal"> False</code>.</p></li><li class="listitem"><p>
<code class="literal">priority:</code> Relative order of this tool in regards to others at the same hook point. It defaults to<code class="literal"> 50</code>.</p></li></ul></div><p>Thus you could write:</p><div><pre class="programlisting">def mycallable(...):
CherryPytools, creating....
mycallable.failsafe = True
mycallable.priority = 30
cherrypy.tools.mytool = Tool('on_start_resource', mycallable)
</pre></div><p>CherryPy provides a shortcut for tools that will be applied at the<code class="literal"> before_handler</code> hook point, in other words just before the page handler is called. This should be one of the most common cases for non-built-in tools.</p><div><pre class="programlisting">cherrypy.tools.mytool = Tool('before_handler', mycallable)
</pre></div><p>This is equivalent to the following:</p><div><pre class="programlisting">cherrypy.tools.mytool = HandlerTool(mycallable)
</pre></div><p>The<code class="literal"> HandlerTool</code> class provides one additional feature as it allows your callable to be applied as a page handler itself through the<code class="literal"> handler(*args, **kwargs)</code> method of the<code class="literal"> HandlerTool</code> class. Thus:</p><div><pre class="programlisting">class Root:
other = cherrypy.tools.mytool.handler()
</pre></div><p>This can be useful to provide the same handler in different areas of your application without duplicating code.</p><p>Let's now see a more elaborate example:</p><div><pre class="programlisting">import cherrypy
from cherrypy import tools
CherryPytools, creatingfrom cherrypy import Tool
from xml.parsers.expat import ExpatError
from xml.sax._exceptions import SAXParseException
def xmlparse(engine='elementtree', valid_content_types=['text/xml',
'application/xml'], param_name='doc'):
# Transform the XML document contained in the request body into
# an instance of the chosen XML engine.
# Get the mime type of the entity sent by the user-agent
ct = cherrypy.request.headers.get('Content-Type', None)
# if it is not a mime type we can handle
# then let's inform the user-agent
if ct not in valid_content_types:
raise cherrypy.HTTPError(415, 'Unsupported Media Type')
# CherryPy will set the request.body with a file object
# where to read the content from
if hasattr(cherrypy.request.body, 'read'):
content = cherrypy.request.body.read()
doc = content
try:
if engine == 'elementtree':
from elementtree import ElementTree as ETX
doc = ETX.fromstring(content)
elif engine == 'amara':
import amara
doc = amara.parse(content)
except (ExpatError, SAXParseException):
raise cherrypy.HTTPError(400, 'XML document not
well-formed')
# inject the parsed document instance into
# the request parameters as if it had been
# a regular URL encoded value
cherrypy.request.params[param_name] = doc
# Create a new Tool and attach it to the default CherryPy toolbox
tools.xml_parse = Tool('before_handler', xmlparse)
class Root:
@cherrypy.expose
@tools.xml_parse()
def echoet(self, doc):
return doc.find('.//message').text
@cherrypy.expose
@tools.xml_parse(engine='amara', param_name='d')
def echoamara(self, d):
return unicode(d.root.message)
if __name__ == '__main__':
cherrypy.quickstart(Root(), '/')
</pre></div><div><h3 class="title"><a id="note23"/>Note</h3><p>In order to test the tool, you will need ElementTree or Amara or both. You can install both via the<code class="literal"> easy_install</code> command.</p></div><p>Our XML tool will read the HTTP body content and parse it via the specified XML toolkit. Then it will inject back the parsed document into the request parameters so that the new document instance is passed on to the page handler as a regular parameter.</p><p>Launch the previous example and then run in a Python interpreter:</p><div><pre class="programlisting">&gt;&gt;&gt; s = '&lt;root&gt;&lt;message&gt;Hello!&lt;message&gt;&lt;/root&gt;'
&gt;&gt;&gt; headers = {'Content-Type': 'application/xml'}
&gt;&gt;&gt; import httplib
&gt;&gt;&gt; conn = httplib.HTTPConnection("localhost:8080")
&gt;&gt;&gt; conn.request("POST", "/echoet", s, headers)
&gt;&gt;&gt; r1 = conn.getresponse()
&gt;&gt;&gt; print r1.status, r1.reason
200 OK
&gt;&gt;&gt; r1.read()
'Hello!'
&gt;&gt;&gt; conn.request("POST", "/echoamara", s, headers)
&gt;&gt;&gt; r1 = conn.getresponse()
&gt;&gt;&gt; print r1.status, r1.reason
200 OK
&gt;&gt;&gt; r1.read()
'Hello!'
&gt;&gt;&gt; conn.request("POST", "/echoamara", s)
&gt;&gt;&gt; r1 = conn.getresponse()
&gt;&gt;&gt; print r1.status, r1.reason
415 Unsupported Media Type
&gt;&gt;&gt; conn.close()
<a id="id114" class="indexterm"/>
</pre></div><p>As you can see the tool interface provided by CherryPy 3 is powerful, flexible, and yet quite intuitive and easy to reuse. However, always be careful to ponder over your requirements before using tools. They should be used for low-level operations that fit into the HTTP request/response model.<a id="id115" class="indexterm"/>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec07"/>Static Resource Serving</h1></div></div></div><p>CherryPy provides two simple tools to serve either a single file or an entire directory. In either case CherryPy takes care of the HTTP caching aspect of your static resource by automatically checking the presence of the<code class="literal"> If-Modified-Since</code> and<code class="literal"> If-Unmodified-Since</code> headers in the request and returning directly the<code class="literal"> 304 Not Modified</code> response, if that's the case.<a id="id116" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec22"/>Using the Staticfile Tool to Serve a Single File</h2></div></div></div><p>The<code class="literal"> staticfile</code> tool can be used to serve a single file.<a id="id117" class="indexterm"/>
</p><p>
<strong>Arguments:</strong>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.55902777777778" style="text-align: left" class="C1"/><col width="0.960416666666667" style="text-align: left" class="C2"/><col width="2.75833333333333" style="text-align: left" class="C3"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">filename</code>
</p>
</td><td style="text-align: left" valign="top">
<p>N/A</p>
</td><td style="text-align: left" valign="top">
<p>Absolute or relative path to the physical file.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">root</code>
</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>If filename is relative you must provide the root directory of the file.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">match</code>
</p>
</td><td style="text-align: left" valign="top">
<p>""</p>
</td><td style="text-align: left" valign="top">
<p>Regular expression to check that the URI path matches a certain pattern.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">content_types</code>
</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>Dictionary of the form<code class="literal"> ext: mime type</code>.</p>
</td></tr></tbody></table></div><p>
<strong>Example:</strong>
</p><p>For this purpose let's imagine we have the following directory layout:</p><div><pre class="programlisting">application \
myapp.py
design1.css
</pre></div><p>
<code class="literal">design1.css</code> is set as follows:</p><div><pre class="programlisting">body {
background-color: #86da12;
}
</pre></div><p>The<code class="literal"> myapp.py</code> module will be defined like this:</p><div><pre class="programlisting">import cherrypy
class MyApp:
@cherrypy.expose
def index(self):
return """&lt;html&gt;
&lt;head&gt;
&lt;title&gt;My application&lt;/title&gt;
&lt;link rel="stylesheet" href="css/style.css" type="text/css"&gt;&lt;/link&gt;
&lt;/head&gt;
&lt;html&gt;
&lt;body&gt;
Hello to you.
static resource servingsingle file, Staticfile tool used&lt;/body&gt;
&lt;/html&gt;"""
if __name__ == '__main__':
import os.path
current_dir = os.path.dirname(os.path.abspath(__file__))
cherrypy.config.update({'environment': 'production',
'log.screen': True})
conf = {'/': {'tools.staticfile.root': current_dir},
'/css/style.css': {'tools.staticfile.on': True,
'tools.staticfile.filename':
'design1.css'}}
cherrypy.quickstart(MyApp(), '/my', config=conf)
</pre></div><p>Several points must be taken into consideration:</p><div><ul class="itemizedlist"><li class="listitem"><p>The root directory can be set globally for the entire application so that you don't have to define it for each URI path.</p></li><li class="listitem"><p>When using the<code class="literal"> staticfile</code> tool the URI and the physical resource need not have the same name. In fact they can be entirely unrelated in their naming as in the previous example.</p></li><li class="listitem"><p>Note also that even though the application is mounted on the<code class="literal"> /my</code> prefix, meaning that requests to the CSS file will be<code class="literal"> /my/css/style.css</code> (note that this is the case because the path provided in the<code class="literal"> href</code> attribute of the link element is relative and not absolute: it does not start with a<code class="literal"> /)</code>, our configuration settings do not include the prefix. As we have seen in Chapter 3, this is because the configuration settings are independent from where the application is mounted.<a id="id119" class="indexterm"/>
</p></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec23"/>Using the Staticdir Tool to Serve a Complete Directory</h2></div></div></div><p>The<code class="literal"> staticdir</code> tool can be used to serve a complete directory.</p><p>
<strong>Arguments:</strong>
<a id="id120" class="indexterm"/>
</p><div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; "><colgroup><col width="1.55902777777778" style="text-align: left" class="C1"/><col width="0.960416666666667" style="text-align: left" class="C2"/><col width="2.75833333333333" style="text-align: left" class="C3"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Default</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">dir</code>
</p>
</td><td style="text-align: left" valign="top">
<p>N/A</p>
</td><td style="text-align: left" valign="top">
<p>Absolute or relative path to the physical directory.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">root</code>
</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>If<code class="literal"> dir</code> is relative you must provide the root directory of the file.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">match</code>
</p>
</td><td style="text-align: left" valign="top">
<p>""</p>
</td><td style="text-align: left" valign="top">
<p>Regular expression pattern to match files.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">content_types</code>
</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>Dictionary of the form ext: mime type.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">index</code>
</p>
</td><td style="text-align: left" valign="top">
<p>""</p>
</td><td style="text-align: left" valign="top">
<p>If the URI is not directed at a file but at a directory, you can specify the name of the physical index file to be served.</p>
</td></tr></tbody></table></div><p>
<strong>Example:</strong>
</p><p>Consider the new directory layout.</p><div><pre class="programlisting">application \
myapp.py
data \
design1.css
some.js
feeds \
app.rss
app.atom
</pre></div><p>Handling that structure via the static directory tool would be similar to:</p><div><pre class="programlisting">import cherrypy
class MyApp:
@cherrypy.expose
def index(self):
return """&lt;html&gt;
&lt;head&gt;
&lt;title&gt;My application&lt;/title&gt;
&lt;link rel="stylesheet" href="static/css/design1.css"
type="text/css"&gt;&lt;/link&gt;
&lt;script type="application/javascript"
src="img/some.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;html&gt;
&lt;body&gt;
&lt;a href="feed/app.rss"&gt;RSS 2.0 feed&lt;/a&gt;
&lt;a href="feed/app.atom"&gt;Atom 1.0 feed&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;"""
static resource servingdirectory, Staticdir tool usedif __name__ == '__main__':
import os.path
current_dir = os.path.dirname(os.path.abspath(__file__))
cherrypy.config.update({'environment': 'production',
'log.screen': True})
conf = {'/': {'tools.staticdir.root': current_dir},
'/static/css': {'tools.gzip.on': True,
'tools.gzip.mime_types':['text/css'],
'tools.staticdir.on': True,
'tools.staticdir.dir': 'data'},
'/static/scripts': {'tools.gzip.on': True,
'tools.gzip.mime_types':
['application/javascript'],
'tools.staticdir.on': True,
'tools.staticdir.dir': 'data'},
'/feed': {'tools.staticdir.on': True,
'tools.staticdir.dir': 'feeds',
'tools.staticdir.content_types':
{'rss':'application/xml',
'atom': 'application/atom+xml'}}}
cherrypy.quickstart(MyApp(), '/', config=conf)
</pre></div><p>In this example, you will note that the URI paths for the CSS and the JavaScript files match exactly their physical counterparts. Also take a close look at how we define the appropriate<code class="literal"> Content-Type</code> for the resource based on the file extension. This is useful when CherryPy cannot determine the proper MIME type to be used on its own. Finally, see how we mix the static directory tool with the<code class="literal"> gzip</code> one so that our static content is compressed before being served.<a id="id122" class="indexterm"/>
</p><div><h3 class="title"><a id="note24"/>Note</h3><p>You may find it limitating that CherryPy requires absolute paths to work with the different static tools. But consider the fact that CherryPy cannot control how an application will be deployed and where it will live. Therefore, it is up to the deployers to provide that information. Remember, however, that the absolute path can be provided via the<code class="literal"> root</code> attribute or directly within the<code class="literal"> filename</code> or<code class="literal"> dir</code> ones.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec24"/>Bypassing Static Tools to Serve Static Content</h2></div></div></div><p>Sometimes you may want to reuse CherryPy's internal functionalities for serving content but without using the static tools directly. This is possible by calling the<code class="literal"> serve_file</code> function from your page handler. This function is actually the one called by the built-in tools as well. Consider the following example:<a id="id123" class="indexterm"/>
</p><div><pre class="programlisting">import os.path
import cherrypy
from cherrypy.lib.static import serve_file
class Root:
@cherrypy.expose
def feed(self, name):
accepts = cherrypy.request.headers.elements('Accept')
for accept in accepts:
if accept.value == 'application/atom+xml':
return serve_file(os.path.join(current_dir, 'feeds',
'%s.atom' % name),
content_type='application/atom+xml')
# Not Atom accepted? Well then send RSS instead...
return serve_file(os.path.join(current_dir, 'feeds',
'%s.rss' % name),
content_type='application/xml')
if __name__ == '__main__':
current_dir = os.path.dirname(os.path.abspath(__file__))
cherrypy.config.update({'environment': 'production',
'log.screen': True})
cherrypy.quickstart(Root(), '/')
</pre></div><p>Here we define a feed page handler that, when called, will check what is the preferred representation of the feed of the user-agent—it maybe RSS or Atom.<a id="id124" class="indexterm"/>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec08"/>WSGI Support</h1></div></div></div><p>
<strong>Web Server Gateway Interface</strong> (<strong>WSGI</strong>) is defined in a<strong> Python Enhancement Proposal</strong> (<strong>PEP-333</strong>) written by Phillip J. Eby to provide a loosely-coupled bridge between the web server and web applications.<a id="id125" class="indexterm"/>
</p><p>WSGI defines the following three components:</p><div><ul class="itemizedlist"><li class="listitem"><p>Server or gateway<a id="id126" class="indexterm"/>
</p></li><li class="listitem"><p>Middleware</p></li><li class="listitem"><p>Application or framework</p></li></ul></div><p>The following figure shows WSGI along with its layers:</p><div><img src="img/1848_04_02.jpg" alt="WSGI Support"/></div><p>The goal of WSGI is to allow components to be plugged and played at will, with the minimum API overhead possible. This allows code reuse of common functionalities such as session, authentication, URL dispatching, logging, etc. In fact, because the API is minimal and unobtrusive, frameworks or libraries supporting the WSGI specification will be able to handle these components.<a id="id127" class="indexterm"/>
</p><p>Until CherryPy 3.0, the support of WSGI within CherryPy was not welcome due to the internal design of CherryPy and also the belief that WSGI would not necessarily make the product a better one. When Robert Brewer undertook the refactoring of the project, he improved the WSGI support based on the work achieved by Christian Wyglendowski to the point of making it a first class citizen within CherryPy and therefore fulfilling expectations from the community.</p><div><h3 class="title"><a id="note25"/>Note</h3><p>Note that CherryPy tools and WSGI middlewares are different by design but not by capability. They aim at providing the same functionalities in a distinct way. CherryPy tools are mainly meaningful within CherryPy and are therefore optimized in that context. CherryPy tools and WSGI middlewares can coexist in a single application.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec25"/>
<strong>Hosting a WSGI Application within the CherryPy WSGI Server</strong>
</h2></div></div></div><p>Let's see an example on how to use CherryPy in a WSGI environment:</p><div><pre class="programlisting">import cherrypy
from paste.translogger import TransLogger
WSGIWSGI application, hostingdef application(environ, start_response):
status = '200 OK'
response_headers = [('Content-type', 'text/plain')]
start_response(status, response_headers)
return ['Hello world!\n']
if __name__ == '__main__':
cherrypy.tree.graft(TransLogger(application), script_name='/')
cherrypy.server.quickstart()
cherrypy.engine.start()
</pre></div><p>Let's explain what we have done:</p><div><ol class="orderedlist"><li class="listitem"><p>1. First we create a WSGI application respecting the WSGI specification, hence a Python callable respecting the WSGI application signature. The<code class="literal"> environ</code> parameter contains values to be propagated orthogonally across the processing from the server to the application. Middlewares can alter this dictionary by adding new values or transforming existing values. The<code class="literal"> start_response</code> parameter is a Python callable provided by the outer layer (a middleware or ultimately the WSGI server) to perform the response processing. Our WSGI application then returns an iterable, which will be consumed by the outer layers.</p></li><li class="listitem"><p>2. Then, we encapsulate the application into a middleware provided by the paste package. Paste is a suite of common WSGI middlewares created and maintained by Ian Bicking. In our example, we use the<code class="literal"> TransLogger</code> middleware to enable logging of incoming requests. WSGI defines middlewares to act like a server for encapsulated WSGI applications and as an application for the hosting WSGI server.</p></li><li class="listitem"><p>3. Finally, we graft the WSGI application into the CherryPy tree through the<code class="literal"> cherrypy.tree.graft()</code> method and we start the CherryPy server and engine.</p></li></ol></div><p>As the built-in CherryPy server is a WSGI server, it can handle the WSGI application without any trouble. Bear in mind, however, that many aspects of CherryPy such as tools and configuration settings will not be applied to the hosted WSGI application. You will need to use middlewares to perform operations such as the<code class="literal"> paste.transLogger</code>. Alternatively, you can use the<code class="literal"> wsgiapp</code> tool as follows:</p><div><pre class="programlisting">import cherrypy
from paste.translogger import TransLogger
def application(environ, start_response):
status = '200 OK'
response_headers = [('Content-type', 'text/plain')]
start_response(status, response_headers)
return ['Hello world!\n']
class Root:
pass
if __name__ == '__main__':
app = TransLogger(application)
conf = {'/': {'tools.wsgiapp.on': True,
'tools.wsgiapp.app': app,
'tools.gzip.on': True}}
cherrypy.tree.mount(Root(), '/', config=conf)
cherrypy.server.quickstart()
cherrypy.engine.start()
</pre></div><p>In this example, we wrap the WSGI application using the<code class="literal"> wsgiapp</code> tool. Notice that we can apply tools on the WSGI application as if it was a regular page handler.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec26"/>
<strong>Hosting a CherryPy WSGI Application within a Third-Party WSGI Server</strong>
</h2></div></div></div><p>In this example, we will write a CherryPy application as we traditionally do and host it in a WSGI server different from the built-in one. Indeed, we will be using the default WSGI server provided by the<code class="literal"> wsgiref</code> package.<a id="id129" class="indexterm"/>
</p><div><h3 class="title"><a id="note26"/>Note</h3><p>The<code class="literal"> wsgiref</code> package is a set of WSGI helpers that has become part of the Python standard library as of Python 2.5. Otherwise, you can get it via<code class="literal"> easy_install wsgiref</code>.</p></div><div><pre class="programlisting">import cherrypy
from cherrypy import tools
from wsgiref.simple_server import make_server
from flup.middleware.gzip import GzipMiddleware
class Root:
@cherrypy.expose
@tools.response_headers(headers=[('Content-Language', 'en-GB')])
def index(self):
return "Hello world!"
if __name__ == '__main__':
wsgi_app = cherrypy.Application(Root(), script_name="/")
cherrypy.engine.start(blocking=False)
httpd = make_server('localhost', 8080, GzipMiddleware(wsgi_app))
print "HTTP Serving HTTP on http://localhost:8080/"
httpd.serve_forever()
</pre></div><p>Let's explain this example:</p><div><ol class="orderedlist"><li class="listitem"><p>1. First we create a regular CherryPy application. Note how we can still safely use CherryPy tools in this context.</p></li><li class="listitem"><p>2. Then we make a WSGI application from it through the<code class="literal"> cherrypy.Application</code> helper. This returns a WSGI-valid callable made of the CherryPy application.</p></li><li class="listitem"><p>3. Next we start the CherryPy engine in a non-blocking mode as we still need CherryPy to handle the request and dispatch to the correct page handler.</p></li><li class="listitem"><p>4. Then we create a WSGI server instance hosting our WSGI application, which is encapsulated in the gzip middleware, which compresses the response body. This middleware is provided by the<code class="literal"> flup</code> package, which is another WSGI set of middlewares. (Flup is maintained by Allan Saddi.)</p></li></ol></div><p>To conclude, the level of support for WSGI within CherryPy 3 is excellent, while being flexible enough so that you can use the best of both designs when need be. CherryPy can be seen as a comprehensive and coherent WSGI implementation. Moreover, CherryPy has the most comprehensive and fastest WSGI server currently available and you have no reason to believe you should drop the library if you want WSGI support. You can get more information about WSGI at <a class="ulink" href="http://wsgi.org">http://wsgi.org</a>.</p></div></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec09"/>Summary<a id="id130" class="indexterm"/>
</h1></div></div></div><p>In this chapter, we have reviewed key points of the CherryPy library, which will hopefully open your mind on how to make the most of its capabilities. While being a small package CherryPy offers an extended and yet coherent set of features all geared towards making your life easier. Some aspects of CherryPy have been left out, however, as they go beyond the scope of this book and the best place to gather more detailed information is by visiting the user and developer public mailing lists.</p><p>Now that you have acquired a good background with the library, we will move on to using it by developing a simple photoblog application.</p></div></div></div>
</body></html>