<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;5.&#xA0;The Proxy Pattern &#x2013; Controlling Object Access" id="19UOO1-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. The Proxy Pattern – Controlling Object Access</h1></div></div></div><p class="calibre6">In the previous chapter, we started with a brief introduction to Structural patterns and went ahead to discuss about the Façade design pattern. We understood the concept of Façade with a UML diagram and also learned how it's applied in the real world with the help of Python implementations. You learned about the upsides and downsides of the Façade pattern in the FAQs section.</p><p class="calibre6">In this chapter, we take a step forward and deal with the Proxy pattern that falls under the hood of the Structural design patterns. We will get introduced to the Proxy pattern as a concept and go ahead with a discussion on the design pattern and see how it is used in software application development. We will work with a sample use case and implement it in Python v3.5.</p><p class="calibre6">In this chapter, we will cover the following topics in brief:</p><div class="book"><ul class="itemizedlist"><li class="listitem">An introduction to proxy and Proxy design patterns</li><li class="listitem">A UML diagram for the Proxy pattern</li><li class="listitem">Variations of Proxy patterns</li><li class="listitem">A real-world use case with the Python v3.5 code implementation</li><li class="listitem">Advantages of the Proxy pattern</li><li class="listitem">Comparison - Façade and the Proxy pattern</li><li class="listitem">Frequently asked questions</li></ul></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;The Proxy Pattern &#x2013; Controlling Object Access" id="19UOO1-5ae934a69a004514b92177e2702ed0a9">
<div class="book" title="Understanding the Proxy design pattern"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec37" class="calibre1"/>Understanding the Proxy design pattern</h1></div></div></div><p class="calibre6">Proxy, in <a id="id146" class="calibre1"/>general terms, is a system that intermediates between the seeker and provider. Seeker is the one that makes the request, and provider delivers the resources in response to the request. In the web world, we can relate this to a proxy server. The clients (users in the World Wide Web), when they make a request to the website, first connect to a proxy server asking for resources such as a web page. The proxy server internally evaluates this request, sends it to an appropriate server, and gets back the response, which is then delivered to the client. Thus, a proxy server encapsulates requests, enables privacy, and works well in distributed architectures.</p><p class="calibre6">In the<a id="id147" class="calibre1"/> context of design patterns, <code class="email">Proxy</code> is a class that acts as an interface to real objects. Objects can be of several types such as network connections, large objects in memory and file, among others. In short, <code class="email">Proxy</code> is a wrapper or agent object that wraps the real serving object. Proxy could provide additional functionality to the object that it wraps and doesn't change the object's code. The main intention of the Proxy pattern is to provide a surrogate or placeholder for another object in order to control access to a real object.</p><p class="calibre6">The<a id="id148" class="calibre1"/> Proxy pattern is used in multiple scenarios such as the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">It represents a complex system in a simpler way. For example, a system that involves multiple complex calculations or procedures should have a simpler interface that can act as a proxy for the benefit of the client.</li><li class="listitem">It adds security to the existing real objects. In many cases, the client is not allowed to access the real object directly. This is because the real object can get compromised with malicious activities. This way proxies act as a shield against malicious intentions and protect the real object.</li><li class="listitem">It provides a local interface for remote objects on different servers. A clear example of this is with the distributed systems where the client wants to run certain commands on the remote system, but the client may not have direct permissions to make this happen. So it contacts a local object (proxy) with the request, which is then executed by the proxy on the remote machine.</li><li class="listitem">It provides a light handle for a higher memory-consuming object. Sometimes, you may not want to load the main objects unless they're really necessary. This is because real objects are really heavy and may need high resource utilization. A classic example is that of profile pictures of users on a website. You're much better off showing smaller profile images in the list view, but of course, you'll need to load the actual image to show the detailed view of the user profile.</li></ul></div><p class="calibre6">Let's understand the pattern with a simple example. Consider the example of an <code class="email">Actor</code> and his <code class="email">Agent</code>. When production houses want to approach an <code class="email">Actor</code> for a movie, typically, they talk to the <code class="email">Agent</code> and not to the <code class="email">Actor</code> directly. Based on the schedule of the <code class="email">Actor</code> and other engagements, the <code class="email">Agent</code> gets back to the production house on the availability and interest in working in the movie. Now, in this scenario, instead of production houses directly talking to the <code class="email">Actor</code>, the <code class="email">Agent</code> acts as a <code class="email">Proxy</code> that handles all the scheduling &amp; payments for the <code class="email">Actor</code>. </p><p class="calibre6">The following Python code implements this scenario where the <code class="email">Actor</code> is the <code class="email">Proxy</code>. The <code class="email">Agent</code> object is used to<a id="id149" class="calibre1"/> find out if the <code class="email">Actor</code> is busy. If the <code class="email">Actor</code> is busy, the <code class="email">Actor().occupied()</code> method is called and if the <code class="email">Actor</code> is not busy, the <code class="email">Actor().available()</code> method gets returned.</p><div class="informalexample"><pre class="programlisting">class Actor(object):
    def __init__(self):
        self.isBusy = False
    
    def occupied(self):
        self.isBusy = True
        print(type(self).__name__ , "is occupied with current movie")

    def available(self):
        self.isBusy = False
        print(type(self).__name__ , "is free for the movie")

    def getStatus(self):
        return self.isBusy

class Agent(object):
    def __init__(self):
        self.principal = None
    
    def work(self):
        self.actor = Actor()
        if self.actor.getStatus():
            self.actor.occupied()
        else:
            self.actor.available()


if __name__ == '__main__':
    r = Agent()
    r.work()</pre></div><p class="calibre6">The Proxy design pattern essentially does the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">It provides a surrogate for another object so that you can control access to the original object</li><li class="listitem">It is used as a layer or interface to support distributed access</li><li class="listitem">It adds delegation and protects the real component from undesired impact</li></ul></div></div></div>
<div class="book" title="A UML class diagram for the Proxy pattern" id="1AT9A1-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec38" class="calibre1"/>A UML class diagram for the Proxy pattern</h1></div></div></div><p class="calibre6">We <a id="id150" class="calibre1"/>will now discuss the Proxy pattern with the help of the following UML diagram. As we discussed in the previous paragraph, the Proxy pattern has three main actors: the production house, <code class="email">Agent</code>, and the <code class="email">Actor</code>. Let's put these in a UML diagram and see how the classes look:</p><div class="mediaobject"><img src="../images/00017.jpeg" alt="A UML class diagram for the Proxy pattern" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre6">As we observe the UML diagram, you'll realize that there are three main participants in this pattern:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">Proxy</code>: This maintains a reference that lets the <code class="email">Proxy</code> access the real object. It provides an interface identical to the <code class="email">Subject</code> so that <code class="email">Proxy</code> can substitute the real subject. Proxies are also responsible for creating and deleting the <code class="email">RealSubject</code>.</li><li class="listitem"><code class="email">Subject</code>: It provides a representation for both, the <code class="email">RealSubject</code> and <code class="email">Proxy</code>. As <code class="email">Proxy</code> and <code class="email">RealSubject</code> implement <code class="email">Subject</code>, <code class="email">Proxy</code> can be used wherever <code class="email">RealSubject</code> is expected.</li><li class="listitem"><code class="email">RealSubject</code>: It defines the real object that the <code class="email">Proxy</code> represents.</li></ul></div><p class="calibre6">From the data structure's perspective, the UML diagram can be represented as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">Proxy</code>: It is a class that controls access to the <code class="email">RealSubject</code> class. It handles the client's requests and is responsible for creating or deleting <code class="email">RealSubject</code>.</li><li class="listitem"><code class="email">Subject</code>/<code class="email">RealSubject</code>: <code class="email">Subject</code> is an interface that defines what <code class="email">RealSubject</code> and <code class="email">Proxy</code> should look like. <code class="email">RealSubject</code> is an actual implementation of the <code class="email">Subject</code> interface. It provides the real functionality that is then used by the client.</li><li class="listitem"><code class="email">Client</code>: It <a id="id151" class="calibre1"/>accesses the <code class="email">Proxy</code> class for the work to be accomplished. The <code class="email">Proxy</code> class internally controls access to <code class="email">RealSubject</code> and directs the work requested by <code class="email">Client</code>.</li></ul></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Understanding different types of Proxies" id="1BRPS1-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec39" class="calibre1"/>Understanding different types of Proxies</h1></div></div></div><p class="calibre6">There <a id="id152" class="calibre1"/>are multiple common situations where Proxies are used. We talked about some of them in the beginning of this chapter. Based on how the Proxies are used, we can categorize them as virtual proxy, remote proxy, protective proxy, and smart proxy. Let's learn a little more about them in this section.</p></div>

<div class="book" title="Understanding different types of Proxies" id="1BRPS1-5ae934a69a004514b92177e2702ed0a9">
<div class="book" title="A virtual proxy"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec33" class="calibre1"/>A virtual proxy</h2></div></div></div><p class="calibre6">Here, you'll learn<a id="id153" class="calibre1"/> in detail about the virtual proxy. It is a placeholder for objects that are very heavy to instantiate. For example, you want to load a large image on your website. Now this request will take a long time to load. Typically, developers will create a placeholder icon on the web page suggesting that there's an image. However, the image will only be loaded when the user actually clicks on the icon thus saving the cost of loading a heavy image in memory. Thus, in virtual proxies, the real object is created when the client first requests or accesses the object.</p></div></div>

<div class="book" title="Understanding different types of Proxies" id="1BRPS1-5ae934a69a004514b92177e2702ed0a9">
<div class="book" title="A remote proxy"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec34" class="calibre1"/>A remote proxy</h2></div></div></div><p class="calibre6">A remote <a id="id154" class="calibre1"/>proxy can be defined in the following terms. It provides a local representation of a real object that resides on a remote server or different address space. For example, you want to build a monitoring system for your application that has multiple web servers, DB servers, celery task servers, caching servers, among others. If we want to monitor the CPU and disk utilization of these servers, we need to have an object that is available in the context of where the monitoring application runs but can perform remote commands to get the actual parameter values. In such cases, having a remote proxy object that is a local representation of the remote object would help.</p></div></div>

<div class="book" title="Understanding different types of Proxies" id="1BRPS1-5ae934a69a004514b92177e2702ed0a9">
<div class="book" title="A protective proxy"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec35" class="calibre1"/>A protective proxy</h2></div></div></div><p class="calibre6">You'll understand<a id="id155" class="calibre1"/> more about the protective proxy with the following points. This proxy controls access to the sensitive matter object of <code class="email">RealSubject</code>. For example, in today's world of distributed systems, web applications have multiple services that work together to provide functionality. Now, in such systems, an authentication service acts as a protective proxy server that is responsible for authentication and authorization. In this case, Proxy internally helps in protecting the core functionality <a id="id156" class="calibre1"/>of the website for unrecognized or unauthorized agents. Thus, the surrogate object checks that the caller has access permissions required to forward the request.</p></div></div>

<div class="book" title="Understanding different types of Proxies" id="1BRPS1-5ae934a69a004514b92177e2702ed0a9">
<div class="book" title="A smart proxy"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec36" class="calibre1"/>A smart proxy</h2></div></div></div><p class="calibre6">Smart proxies<a id="id157" class="calibre1"/> interpose additional actions when an object is accessed. For example, consider that there's a core component in the system that stores states in a centralized location. Typically, such a component gets called by multiple different services to complete their tasks and can result in issues with shared resources. Instead of services directly invoking the core component, a smart proxy is built-in and checks whether the real object is locked before it is accessed in order to ensure that no other object can change it.</p></div></div>
<div class="book" title="The Proxy pattern in the real world"><div class="book" id="1CQAE2-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec40" class="calibre1"/>The Proxy pattern in the real world</h1></div></div></div><p class="calibre6">We will<a id="id158" class="calibre1"/> take up a payment use case to demonstrate a real-world scenario for the Proxy pattern. Let's say that you go to shop at a mall and like a nice denim shirt there. You would like to purchase the shirt but you don't have enough cash to do so.</p><p class="calibre6">In yesteryears, you'd go to an ATM, take out the money, then come to the mall, and pay for it. Even earlier, you had a bank check for which you had to go to the bank, withdraw money, and then come back to pay for your expense.</p><p class="calibre6">Thanks to the banks, we now have something called a debit card. So now, when you want to purchase something, you present your debit card to the merchant. When you punch in your card details, the money is debited in the merchant's account for your expense.</p><p class="calibre6">Let's develop an application in Python v3.5 and implement the above use case. We start with the client first. You went to the shopping mall and now would like to purchase a nice denim shirt. Lets see how <code class="email">Client</code> code is written:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Your behavior is represented by the <code class="email">You</code> class—the client</li><li class="listitem">To buy the shirt, the <code class="email">make_payment()</code> method is provided by the class</li><li class="listitem">The special <code class="email">__init__()</code> method calls the Proxy and instantiates it</li><li class="listitem">The <code class="email">make_payment()</code> method invokes the Proxy's method internally to make the payment</li><li class="listitem">The <code class="email">__del__()</code> method returns in case the payment is successful</li></ul></div><p class="calibre6">Thus, the code example is as follows:</p><div class="informalexample"><pre class="programlisting">class You:
    def __init__(self):
        print("You:: Lets buy the Denim shirt")
        self.debitCard = DebitCard()
        self.isPurchased = None
    
    def make_payment(self):
        self.isPurchased = self.debitCard.do_pay()
    
    def __del__(self):
        if self.isPurchased:
            print("You:: Wow! Denim shirt is Mine :-)")
        else:
            print("You:: I should earn more :(")

you = You()
you.make_payment()</pre></div><p class="calibre6">Now let's <a id="id159" class="calibre1"/>talk about the <code class="email">Subject</code> class. As we know, the <code class="email">Subject</code> class is an interface that is implemented by the <code class="email">Proxy</code> and <code class="email">RealSubject</code>.</p><div class="book"><ul class="itemizedlist"><li class="listitem">In this example, the subject is the <code class="email">Payment</code> class. It is an abstract base class and represents an interface.</li><li class="listitem"><code class="email">Payment</code> has the <code class="email">do_pay()</code> method that needs to be implemented by the <code class="email">Proxy</code> and <code class="email">RealSubject</code>.</li></ul></div><p class="calibre6">Let's see these methods in action in the following code:</p><div class="informalexample"><pre class="programlisting">from abc import ABCMeta, abstractmethod

class Payment(metaclass=ABCMeta):

    @abstractmethod
    def do_pay(self):
        pass</pre></div><p class="calibre6">We also developed the <code class="email">Bank</code> class that represents <code class="email">RealSubject</code> in this scenario:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">Bank</code> will actually make the payment from your account in the merchant's account.</li><li class="listitem"><code class="email">Bank</code> has multiple methods to process the payment. The <code class="email">setCard()</code> method is used by the <code class="email">Proxy</code> to send the debit card details to the bank.</li><li class="listitem">The <code class="email">__getAccount()</code> method is a private method of <code class="email">Bank</code> that is used to get the account details of the debit card holder. For simplicity, we have enforced the debit card number to be the same as the account number.</li><li class="listitem"><code class="email">Bank</code> also<a id="id160" class="calibre1"/> has the <code class="email">__hasFunds()</code> method to see if the account holder has enough funds in the account to pay for the shirt.</li><li class="listitem">The <code class="email">do_pay()</code> method that is implemented by the <code class="email">Bank</code> class (from the Payment interface) is actually responsible for making the payment to the merchant based on available funds:<div class="informalexample"><pre class="programlisting">class Bank(Payment):
    
    def __init__(self):
        self.card = None
        self.account = None
    
    def __getAccount(self):
        self.account = self.card # Assume card number is account number
        return self.account

    def __hasFunds(self):
        print("Bank:: Checking if Account", self.__getAccount(), "has enough funds")
        return True

    def setCard(self, card):
        self.card = card

    def do_pay(self):
        if self.__hasFunds():
            print("Bank:: Paying the merchant")
            return True
        else:
            print("Bank:: Sorry, not enough funds!")
            return False</pre></div></li></ul></div><p class="calibre6">Let's now understand the last piece, which is the <code class="email">Proxy</code>:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">DebitCard</code> class is the <code class="email">Proxy</code> here. When <code class="email">You</code> wants to make a payment, it calls the <code class="email">do_pay()</code> method. This is because <code class="email">You</code> doesn't want go to the bank to withdraw money and pay the merchant.</li><li class="listitem">The <code class="email">DebitCard</code> class acts as a surrogate for the <code class="email">RealSubject</code>, <code class="email">Bank</code>.</li><li class="listitem">The <code class="email">payWithCard()</code> method internally controls the object creation of <code class="email">RealSubject</code>, the <code class="email">Bank</code> class, and presents the card details to <code class="email">Bank</code>.</li><li class="listitem"><code class="email">Bank</code> goes through the internal checks on the account and does the payment, as described in previous code snippet:<div class="informalexample"><pre class="programlisting">class DebitCard(Payment):
    
    def __init__(self):
        self.bank = Bank()
    
    def do_pay(self):
        card = input("Proxy:: Punch in Card Number: ")
        self.bank.setCard(card)
        return self.bank.do_pay()</pre></div></li></ul></div><p class="calibre6">For a<a id="id161" class="calibre1"/> positive case, when funds are enough, the output is as follows:</p><div class="mediaobject"><img src="../images/00018.jpeg" alt="The Proxy pattern in the real world" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre6">For a negative case—insufficient funds—the output is as follows:</p><div class="mediaobject"><img src="../images/00019.jpeg" alt="The Proxy pattern in the real world" class="calibre14"/></div><p class="calibre15"> </p></div>
<div class="book" title="Advantages of the Proxy pattern" id="1DOR01-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec41" class="calibre1"/>Advantages of the Proxy pattern</h1></div></div></div><p class="calibre6">As we've<a id="id162" class="calibre1"/> seen how the Proxy pattern works in the real world, let's browse through the advantages of the Proxy pattern:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Proxies can help improve the performance of the application by caching heavy objects or, typically, the frequently accessed objects</li><li class="listitem">Proxies also authorize the access to <code class="email">RealSubject</code>; thus, this pattern helps in delegation only if the permissions are right</li><li class="listitem">Remote proxies also facilitate interaction with remote servers that can work as network<a id="id163" class="calibre1"/> connections and database connections and can be used to monitor systems</li></ul></div></div>
<div class="book" title="Comparing the Fa&#xE7;ade and Proxy patterns" id="1ENBI1-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec42" class="calibre1"/>Comparing the Façade and Proxy patterns</h1></div></div></div><p class="calibre6">Both the<a id="id164" class="calibre1"/> façade and proxy patterns are structural <a id="id165" class="calibre1"/>design patterns. They are similar in the sense that they both have a proxy/façade object in front of the real objects. Differences are really in the intent or purpose of the patterns, as shown in the following table:</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre20"><col class="calibre21"/><col class="calibre21"/></colgroup><thead class="calibre22"><tr class="calibre23"><th valign="bottom" class="calibre24">
<p class="calibre10">Proxy pattern</p>
</th><th valign="bottom" class="calibre24">
<p class="calibre10">Façade pattern</p>
</th></tr></thead><tbody class="calibre25"><tr class="calibre23"><td valign="top" class="calibre9">
<p class="calibre10">It provides you with a surrogate or placeholder for another object to control access to it</p>
</td><td valign="top" class="calibre9">
<p class="calibre10">It provides you with an interface to large subsystems of classes</p>
</td></tr><tr class="calibre23"><td valign="top" class="calibre9">
<p class="calibre10">A Proxy object has the same interface as that of the target object and holds references to target objects</p>
</td><td valign="top" class="calibre9">
<p class="calibre10">It minimizes the communication and dependencies between subsystems</p>
</td></tr><tr class="calibre23"><td valign="top" class="calibre9">
<p class="calibre10">It acts as an intermediary between the client and object that is wrapped</p>
</td><td valign="top" class="calibre9">
<p class="calibre10">A Façade object provides a single, simplified interface</p>
</td></tr></tbody></table></div></div>
<div class="book" title="Frequently asked questions" id="1FLS41-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec43" class="calibre1"/>Frequently asked questions</h1></div></div></div><p class="calibre6">Q1. What is<a id="id166" class="calibre1"/> the difference between the Decorator pattern and Proxy pattern?</p><p class="calibre6">A: A Decorator adds behavior to the object that it decorates at runtime, while a Proxy controls access to an object. The relationship between Proxy and <code class="email">RealSubject</code> is at compile time and not dynamic.</p><p class="calibre6">Q2. What are the disadvantages of the Proxy pattern?</p><p class="calibre6">A: The Proxy pattern can increase the response time. For instance, if the Proxy is not well-architectured or has some performance issues, it can add to the response time of <code class="email">RealSubject</code>. Generally, it all depends on how well a Proxy is written.</p><p class="calibre6">Q3. Can the client access <code class="email">RealSubject</code> independently?</p><p class="calibre6">A: Yes, but there are certain advantages that Proxies provide such as virtual, remote, and others, so it's advantageous to use the Proxy pattern.</p><p class="calibre6">Q4. Does the Proxy add any functionality of its own?</p><p class="calibre6">A: A Proxy can add additional functionality to <code class="email">RealSubject</code> without changing the object's code. Proxy<a id="id167" class="calibre1"/> and <code class="email">RealSubject</code> would implement the same interface.</p></div>
<div class="book" title="Summary" id="1GKCM1-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec44" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">We began the chapter by understanding what Proxies are. We understood the basics of a Proxy and how it is used effectively in software architecture. You then learned about the Proxy design pattern and the context in which it's used. We looked at how the Proxy design patterns control access to the real object that provides the required functionality.</p><p class="calibre6">We also saw the pattern with a UML diagram and sample code implementation in Python v3.5.</p><p class="calibre6">Proxy patterns are implemented in four different ways: virtual proxy, remote proxy, protective proxy, and smart proxy. You learned about each of these with a real-world scenario.</p><p class="calibre6">We compared the Façade and Proxy design patterns so that the difference between their use cases and intentions are clear to you.</p><p class="calibre6">We also covered a section on FAQs that would help you get more ideas on the pattern and its possible advantages/disadvantages.</p><p class="calibre6">At the end of this chapter, we're now geared up to learn more Structural patterns in the chapters to come.</p></div></body></html>