- en: Chapter 2. Working with CSV and Excel Worksheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a world where your important documents were stored in files and managed
    on work desks. Thanks to the advent of computers and software such as Excel sheets
    we can manage our data in an organized way. In fact, you can even manage worksheets
    in an automated way, and that too with Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading CSV files with reader objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing data into CSV files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing your own CSV dialects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing employee information in an automated way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading Excel sheets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing data into worksheets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting Excel cells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with Excel formulae
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building charts within Excel sheets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating the comparison of company financials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until computers became a part of our daily lives, office records were created
    on paper and stored in cabinets. Today, thanks to the ever-growing computational
    field, we store these records using computer applications in a text file. Text
    (`.txt`) files were great at saving large amounts of data; it was also easy to
    search for information within a text file, but the data was never stored in an
    organized way. Over time as the information grew, the need for storing information
    also increased and resulted in the advent of CSV and Excel sheets, where data
    not only could be stored in a structured format but also read and processed easily.
  prefs: []
  type: TYPE_NORMAL
- en: CSV files contain data separated by commas; hence, they are referred to as **comma-separated
    values** (**CSV**) files. CSV allows for storing data in a tabular format. CSV
    files are easier to import on any storage system, independent of the software
    being used. Since CSV files are plain text files, they can be modified easily
    and are hence used for the quick exchange of data.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Excel sheets contain data separated by tabs or other delimiters.
    Excel sheets store and retrieve data in a grid format of columns and rows. They allow
    the formatting of data, working with formulas, and have the capability of hosting
    multiple sheets in a file. Excel is ideal for entering, calculating, and analyzing
    company data, such as sales figures or commissions.
  prefs: []
  type: TYPE_NORMAL
- en: While CSV files are text files used to store and retrieve data from programs,
    Excel files are binary files and are used for more advanced operations like charting,
    calculations and often for storing reports.
  prefs: []
  type: TYPE_NORMAL
- en: Python has a useful set of modules to work with both CSV and Excel files. You
    can read/write CSV and Excel files, format Excel cells, prepare charts, and perform
    calculations on data with formulae.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes in this chapter will focus on the Python modules that help us performing
    the preceding operations on CSV and Excel sheets. Specifically, we will focus
    on the following Python modules in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`csv` ([https://docs.python.org/2/library/csv.html](https://docs.python.org/2/library/csv.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`openpyxl` ([https://pypi.python.org/pypi/openpyxl](https://pypi.python.org/pypi/openpyxl))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XlsxWriter` ([https://pypi.python.org/pypi/XlsxWriter](https://pypi.python.org/pypi/XlsxWriter))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading CSV files with reader objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to read CSV files, specifically how to create
    and use the reader object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need to install Python v2.7\. To work
    with the CSV files, we have a nice module, `csv`, which is packaged with the default
    Python installation. So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On your Linux/Mac computer, go to Terminal and use Vim, or choose your favorite
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We start by creating a CSV file. As we know, a CSV file has a structured format
    where data is separated by commas, so creating one should be trivial. The following
    screenshot is of a CSV file that contains details of contacts in different parts
    of the country. We name it as `mylist.csv`:![How to do it...](img/Chapter2-Image2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s write the Python code to read this CSV file and print data from
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/Chapter2-Image1.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Oh! What happened? We seem to have hit an error. The error suggests that the
    CSV reader could not find the new line character. This happens in CSV files written
    on a Mac platform. This is because Mac OS uses **carriage return** (**CR**) as
    the end of line character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Python has a simple solution for this issue; we open the file in **rU** mode
    (which is **universal newline** mode). The following program runs perfectly fine
    and we can read the file contents appropriately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_003.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'That''s great! There''s another simple fix for the issue we observed in the
    preceding code snippet. What we could do is, simply change the file format from
    Mac CSV to Windows CSV. We can do this by performing the **Open** and **Save As**
    operations on the file. In the following example, I have saved `mylist.csv` as
    `mylist_wincsv.csv` (Windows CSV format), and reading the file contents is not
    an issue anymore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code example, we print a part of the data from the CSV file.
    If you realize, a CSV file can also be read as a 2D list in Python with the first
    index as row and the second index as column. Here we print the second, third,
    and fourth columns from `row1` and `row2`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_004.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'With Python, it''s also very convenient to read the contents of a CSV file
    in a dictionary with a helpful `DictReader(f)` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code snippet, we open the file with the file handle, `f`.
    This file handle is then used as an argument to `DictReader()`, which will treat
    the first row values as column names. These column names act as a key in the dictionary
    where the data gets stored. So, in the preceding program, we can selectively print
    the data from three columns: **first_name**, **last_name**, and **e-mail** and
    print them like in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_005.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The `csv` module''s `DictReader()` has a few helper methods and attributes
    that make it easy to read CSV files. These are also known as **reader objects**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this code example, we used the following attributes and method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fieldnames`: Gives list of column names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dialect`: CSV file format (we ''ll read more about it)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`line_num`: Current line number being read'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next()`: Takes you to the next line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following screenshot, the first line contains all the column names from
    our CSV file. In the second line, we print the dialect used to read the CSV file.
    The third line prints the line number we''re currently reading, and the last line
    of the screenshot depicts the next line that the reader object will move to while
    reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python module, `csv`, is a helper and it is perfectly possible to process
    a CSV file by opening the file with the `open()` method and reading the file contents
    with the `readline()` method. You can then perform the `split()` operation on
    every line of the file to get the file contents.
  prefs: []
  type: TYPE_NORMAL
- en: Reading is great, but you'll read something only when something is written in
    a CSV file, isn't it? :) Let's look at the methods available for writing data
    into CSV files in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Writing data into CSV files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, for the recipes in this section, we don't need any new modules apart
    from the ones that are bundled with the Python installation, that is, the `csv`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, lets open a file in write mode and in text format. We create two Python
    lists that contain the data to be written into the CSV file. The following code
    will perform these operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s now add the data into the CSV file with the `write()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we initialized the CSV file with a header; the column
    names used are: **Sr**., **Names**, and **Grades**. Next, we start a Python `for`
    loop to run four times and write four rows of data into the CSV file. Remember,
    we have the data in the Python lists, `Names` and `Grades`. The `writerow()` method actually
    adds the content in the CSV file, adding a row one by one inside the `for` loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The output of the preceding code snippet can be seen in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_007.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Cool, that was simple and straightforward. It is interesting to note that,
    by default, when we write into a CSV file, the file contents in a row are separated
    by commas. But what if we want to change the behavior to make it separated by
    tabs (`\t`)? The `writer()` method has this facility of changing not only the
    delimiter but also the line terminator. (Note: Delimiter is the character that
    is used to separate the data within a row in a CSV file. The terminator character
    is used to mark the end of a row in a CSV file. You will relate to this in the
    following example):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the preceding code snippet is run, a new file, `write.csv`, gets created
    on the filesystem. File contents can be viewed in the following screenshot. If
    you look at the contents in a given row, you will see them separated by tabs and
    not by commas. The new line delimeter is the return key (pressed twice), which
    is also evident in the following screenshot. Note that there''s an extra newline
    character between both the rows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_008.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Developing your own CSV dialects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make it easier to read and write into CSV files, we can specify the formatting
    parameters that are a part of the `Dialect` class of the `csv` module. Here, we
    look at some of the dialects available and learn how to write our own.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the same `csv` module that is present in the default
    installation of Python, so there is no need to install anything explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first look at some of the attributes that are present in the `Dialect`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Dialect.delimeter`: We used this in the previous recipe where we changed the
    way the contents are written in the row of a CSV file. It is used to separate
    two fields.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dialect.lineterminator`: This is used to signify the termination of a line
    added in a CSV file. We also used this in our previous section.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dialect.skipinitialspace`: This will skip all the leading spaces after a delimiter.
    It helps avoid accidental human error.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can get a list of the available dialects with the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The two main dialects available are `excel` and `excel-tab`. The `excel` dialect
    is for working with data in the default export format for Microsoft Excel, and
    also works with OpenOffice or NeoOffice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s now create a dialect of our choice. For instance, we choose the `-`
    symbol to demarcate columns in a CSV file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We create a file, `pipes.csv`, which looks as follows:![How to do it...](img/image_03_009.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we run the preceding Python code on the `pipes.csv` file it returns every
    line as an array with all the elements split by the `-` character. The following screenshot
    shows the output of our program:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_010.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the second code snippet, we register our own dialect with the `register_dialect()`
    method. We have named our dialect as `pipes` and the delimiter associated with
    `pipes` is the symbol `-`, as we intended to do.
  prefs: []
  type: TYPE_NORMAL
- en: We now read the `pipes.csv` file with our very own `read()` method, and use
    the reader object to get the contents of the CSV file. But wait, did you see the
    use of `dialect='pipes'`? This will make sure that the reader expects the columns
    to be separated by `-` and reads the data accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: If you observe, the `reader` object has split rows based on `-`, which is defined
    by the dialect, `pipes`.
  prefs: []
  type: TYPE_NORMAL
- en: You learned about reading and writing your own data into CSV files. You also
    understood the usage of dialects. It's time to get a feel of how to use the preceding concepts
    with a real-world use case.
  prefs: []
  type: TYPE_NORMAL
- en: Managing employee information in an automated way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mike is the HR Manager of his organization and is trying to gather the contact
    information of all the employees from the state of California. He wants to segregate
    this information so that he can conduct a survey on all employees from the CA
    State. He not only wants to collect this information but also persist it to another
    CSV file so that it is easy to work on it at a later point in time.
  prefs: []
  type: TYPE_NORMAL
- en: Can we help Mike here? How do you apply the concepts you learned so far? Will
    you learn something more while helping Mike? Let's look at the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We don't need any special modules for this example. All the modules that have
    been installed as part of the previous recipes are enough for us. For this example,
    we use the same `mylist.csv` file that contained the employee information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's directly get to the code and open the two files. One file handle is used
    for reading the file contents (to read the employee data) and the other one is
    used for writing into the `CA_Employees.csv` file. Note the differences in the
    mode in which the files are opened (`'rt'` and `'wt'`). Of course, the employee
    CSV file is opened in the read mode and the `CA_Employees.csv` file is opened
    in the write mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we read the employee information from the CSV file as a dictionary with
    the `DictReader()` method. We also create a `csvWriter` object, using which we
    will write the data into the `CA_Employees.csv` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You would imagine when we start reading the rows of the CSV file, we''d also
    read the first row. We should skip this row as this just contains the column names,
    right? Yes, we skip the header using the `line_num` attribute of the `reader`
    object (Remember, we learned about attributes earlier in this chapter). Once the
    header is skipped, we iterate over all the rows and filter out employees who belong
    to the `CA`  State and get the e-mail and phone information for these employees.
    The filtered data is then written into the `CA_Employees.csv` file with the `csvWriter`
    object. Note that once the file operations are complete, it is important to close
    the file handles as this may result in memory leaks or data inconsistencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we run the preceding program in its entirety, we will get a `CA_Employees.csv` file
    that looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_03_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you look at the code implementation, we use the `line_num` attribute to skip
    the header row, which is the first row of the `mylist.csv` file. We also write
    the filtered data into the newly created `CA_Employees.csv` file with the `writerow()`
    method. Nice work, I think Mike is already happy with you. His problems are solved.
    :)
  prefs: []
  type: TYPE_NORMAL
- en: We come to an end of this section on working with CSV files. CSV files essentially
    store data in pure text format. We can't achieve many things with these files,
    hence the advent of Excel sheets. In the next recipe, we start working with Excel
    sheets and appreciate what they can offer!
  prefs: []
  type: TYPE_NORMAL
- en: Reading Excel sheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might be aware, Microsoft office has started providing a new extension
    to Microsoft Excel sheets, which is `.xlsx`, from Office 2007\. With this change,
    Excel sheets moved to a XML based file format (Office Open XML) with ZIP compression.
    Microsoft made this change when the business community asked for an open file
    format that can help transferring data across applications that pushed them. Let's
    gets started and see how we can work with Excel sheets using Python!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we use the `openpyxl` module to read Excel sheets. The `openpyxl` module
    is a comprehensive module that performs both read and write operations on Excel
    sheets. Another alternative to `openpyxl` is the `xlrd` module. While `xlrd` has
    been good at supporting Excel formats since way back in 1995, the module can only
    be used to read data from Excel sheets. The `openpyxl` module helps in performing
    more operations, such as modifying data, writing data into files, and copying,
    which are imperative to working with Excel files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install the `openpyxl` module with our favorite tool, `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by creating our own Excel sheet with the content as shown in the following
    screenshot. As you must be aware, Excel files are called **workbooks** and contain
    one or more worksheets, and hence Excel files are also known as **spreadsheets**.
    We save the file as `myxlsx.xlsx` in two sheets, **People** and  **Items**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at the data from the **People** sheet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_012.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now, let''s look at the data from the **Items** sheet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_013.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Let''s now go ahead and read the XLSX file. The following code will help us
    in getting the names of all the worksheets present in the Excel workbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if you want to work with a given sheet, how do you get access to that
    object? The following code snippet, takes us to the **People** worksheet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Wow, that's cool!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s now move ahead and read the cell objects. We can read the cells either
    by the name or based on the row/column location. The following code snippet demonstrates
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'But how do I get the values in the cell? Simple enough, object.value returns
    you the value present in the cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we run the Python code snippet, we will get the following output as seen
    in this screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_014.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, we import the `openpyxl` module. This module has a
    method with which you can access the worksheet objects and cells in it. The `load_workbook()` method
    loads the complete Excel sheet in the memory. The `get_sheet_names()` and `get_sheet_by_name()` methods
    help in selecting the worksheets of the given workbook. Thus, we have the workbook
    and worksheet objects ready with us.
  prefs: []
  type: TYPE_NORMAL
- en: The cell objects can be accessed with the `cell()` method, and `cell().value`
    returns the actual value present in the cell of worksheet. Nice, see how trivial
    it is to read data from Excel sheets with Python. But again, reading is only helpful
    if we know how to write data into Excel sheets. So, what are we waiting for? Let's
    go ahead and learn that as well in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Writing data into worksheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading files is a breeze with the `openpyxl` module. Now, let's shift our focus
    to writing Excel files. We'll perform multiple operations with Excel files in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will use another fantastic Python module, which is `xlsxwriter`.
    As the name suggests, this module help us perform multiple operations on Excel
    sheets. Interestingly, `xlsxwriter` doesn''t support read operations on an Excel
    sheet (at the time of writing this book). We install the `xlsxwrite` module using
    `pip`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start with a very basic operation of creating an XLSX file and adding a
    new sheet to it. The following code performs this operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s move ahead and perform the `write` operations on the worksheet and store
    some useful information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first code snippet of this recipe creates a `workbook` object with the `Workbook()`
    method under a new Excel file, `add_sheet.xlsx`. It then goes ahead and creates
    a `worksheet` object with the `add_worksheet()` method. A new sheet named `New
    Sheet 2` is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second code example, we create an XLSX file named `Expenses01.xlsx`.
    We add the expenses data to it from the `expenses` dictionary. For doing this,
    we iterate through the dictionary and use the keys as one column and the values
    as another column in the Excel sheet. Finally, we add one last row that sums up
    all the expenses. The contents of `Expenses01.xlsx` are shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_03_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code snippets, we performed simple write operations on an Excel
    sheet with the `xlsxwrite` module. We first created a workbook with the `Workbook()`
    method and added a new `sheet` object to this workbook with the `add_worksheet()`
    method. Using the `write()` method on the `worksheet` object, we added data to
    the Excel sheet. We also did a small formula operation to get the total of all
    expenses with `=SUM(B1:B4)`.
  prefs: []
  type: TYPE_NORMAL
- en: What we saw was a very basic example of writing Excel files. We could perform
    many more operations programmatically as we are used to doing manually on Excel
    sheets. Let's now learn how to format Excel cells in the next set of recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting Excel cells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cells are formatted for various reasons. In the business world, they are used
    to group data based on a theme, or in the case of a software development process,
    cells are colored to indicate whether a feature is done or a bug is fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the same `xlsxwriter` module and format the cells.
    We will learn how to add and apply formats to the cells.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We continue with the expenses example to demonstrate the formatting of cells.
    But first let''s understand how to create formats. Formats are added with the
     `add_format()` method. This method returns a `format` object. The following code
    example shows how to create a format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, we created a cell format, wherein the data in the
    cell (to which the format is applied) is `bold` and color is set to `green`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Coming back to the example of expenses sheet, how about highlighting the cells
    where the expenses have gone above 150? Yes, we can do that programmatically by
    creating a format to highlight the cells in red. But let''s go in order. First,
    we create a sheet and add data to it, as in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code will create an Excel sheet named `cell_format.xlsx` and add
    expenses to it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s create a format where the cells are colored with blue and the cell
    values will be in red. We could set the format with the `set_font_color()` method,
    but in the following example, we set the format through options like `''bg_color''`
    and `''font_color''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the only remaining step is to apply this format on the expenses that are
    above 150\. The following code applies the format and respects the condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we run this program, the contents of the `cell_format.xlsx` file looks
    as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_03_016.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cool, so now that we have the cell formatting done, how about moving on to working
    with formulas in Excel sheets?
  prefs: []
  type: TYPE_NORMAL
- en: Playing with Excel formulae
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We take a very simple example to demonstrate the use of formulae in Excel sheets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the same `xlsxwriter` module and add formulae to
    the cells. There are numerous operations that are supported by Excel sheets, such
    as getting standard deviation of data, logarithm, getting trends among others,
    so it's worth spending time to understand the majority of available operations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to perform the following step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We work with a simple example, wherein we add a list of numbers with the  `SUM()`
    formula and store the sum to the cell **A1**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we run the preceding code, a new Excel file, `formula.xlsx` gets created
    with cell **A1** containing the number **6** (addition of `1`, `2`, and `3`).
  prefs: []
  type: TYPE_NORMAL
- en: As in the preceding section, we can perform more complex mathematical operations
    using Excel formulae. For instance, you can plan the yearly IT budget for your
    team in an Excel sheet.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's no fun if we don't discuss about charts and finish a chapter on Excel
    sheets. Yes, in the next section we will talk about working with Excel charts.
  prefs: []
  type: TYPE_NORMAL
- en: Building charts within Excel sheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Excel sheets are capable of building a variety of charts, including line chart,
    bar chart, and pie charts among others that help us depict trends and visualize
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the same `xlsxwriter` module and use methods defined
    in the module to build charts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we will write a column in an Excel file that is filled with
    numbers. We can take the values in all the cells and construct a line chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, we have a list of data that has integer values
    ranging from `10` to `50`. As usual, we create a workbook with the `Workbook()`
    method and add a default **Sheet1** worksheet. We then write a new column with
    all the numbers present in the list data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `add_chart()` method then defines the type of chart. In this case, it's
    a line chart. The `add_chart()` method returns an object of type chart. But simply
    creating an object doesn't help. How will the chart know the data points to be
    plotted? This happens with the `add_series()` method that takes the cell values
    to plot the graph. In this case, the cell ranges from **A1** to **A6** (remember
    we have added all the numbers from the `data` list to column **A** beginning at
    **A1**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the chart is ready, it should also be added on to the Excel sheet. This
    is achieved with the `insert_chart()` method that takes the cell name and chart
    object as arguments. In this example, the chart is inserted at cell **C1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we run this program, a new file `chart_line.xlsx` gets created with the
    line graph inserted in it. The following screenshot shows the line graph and plotted
    data:![How to do it...](img/image_03_017.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automating the comparison of company financials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our recipes on Excel sheets covered multiple aspects like reading/writing files,
    formatting cells, working with formulae, and charts. Let's solve a nice business
    case with the knowledge we gained in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Monica is a Finance manager at Xtel Inc and is responsible for the company's
    earnings. Xtel Inc is looking for funding, and Monica is tasked with comparing
    the company financials based on the income statements of the last three years.
    This data will go to the investors so that they can make an appropriate decision
    about investing in Xtel Inc. Getting this data for three years will be easy, but
    the CFO of Xtel has asked Monica to get this data on a month-on-month basis for
    the last 5 years. Monica is worried about comparing the company financials for
    60 months manually! With the knowledge gained in this chapter, do you think you
    can help Monica?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lets solve Monica's problem with a Python recipe. For this recipe, we will compare
    the financials of the last three years for Xtel Inc and plot the comparison in
    an Excel sheet using Python. We will do that with the help of the factors influencing the
    company's income statement, that is, the revenue, costs, and gross profits.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following code, we first add the information on the company financials,
    such as revenue, the cost of goods sold, and the gross profit. Assume that we
    have this data in a Python list `data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then plot these values in a column chart and also calculate the net gain
    in percentages using Excel formulae. The following code snippet does exactly what
    Monica needs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we run this Python program, a new Excel sheet is generated that compares
    the company's financial performance across three years, as shown in the following
    screenshot. Exactly what Monica wanted! :)![How to do it...](img/image_03_018.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding code snippet, we collect the data of the company financials
    in a Python list, `data`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `xlsxwriter` module, we create a workbook object and then add a worksheet
    to it with the `add_worksheet()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the worksheet and the data, we start writing the data into the
    worksheet with the `write_row()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We also add a chart object to our worksheet. This will help us add bar charts
    for comparing the company financials of the last three years easily. We add the
    chart object using the `add_chart()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have the data already populated in our sheet, we use this data to create
    bar charts for all three years using the `add_series()` method. The `add_series()`
    method takes the excel cells as parameters and plots the bar chart for the data
    in these cells. Finally, we insert the chart object (and the bar charts) in the
    worksheet with the `insert_chart()` method.
  prefs: []
  type: TYPE_NORMAL
- en: At last, we add the gain figures for all the years with excel formula using
    the `write()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Cool! That was easy, you did it for Monica! She can modify this Python code
    snippet to compare the company financials for all the data points she needs and
    that too in a very short time. Indeed, the CEO of Xtel Inc will be very happy
    with her work!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well guys, that's it for this chapter. The fun with CSV and Excel files never
    ceases. There are many more operations that you can perform with these files,
    and they can be used in different ways in the business and software development
    world. So, I highly recommend you to try out the modules we discussed in this
    chapter and build on them for your own use case. See you in the next chapter!
  prefs: []
  type: TYPE_NORMAL
