<html><head></head><body><div><h1 class="header-title">Basics of Motors</h1>
                
            
            
                
<p>All right then! We have made a robot that takes care of your garden and I hope it's working fine. It's time to take things to another level.</p>
<p>We have always thought that robots are like WALL-E, moving around and doing things for us. Well, my friend, now that dream is not far away. In fact, in this chapter we will be going ahead and making one. Let's see how it's done. </p>
<p>We will be covering the following topics:</p>
<ul>
<li>The basics</li>
<li>Getting it rolling</li>
<li>Changing the speed</li>
</ul>


            

            
        
    </div>
<div><h1 class="header-title">The basics</h1>
                
            
            
                
<p>Whenever we talk about moving from one place to another, we think about wheels and similarly whenever we think about moving the wheels of a robot, we think about motors. There are various different types of motors that exist. So let's firstly look at the most basic type of motor, which is called a brushed DC motor. As the name suggests, it works on a direct current. You may find such motors like this:</p>
<div><img src="img/f7fd7980-d47b-4ab1-b5c1-4ee766d7bbf1.png" style="width:29.42em;height:22.08em;"/></div>
<p>Trust me, these things are omnipresent, from the Christmas gift you bought for your neighbor to the biggest baddest machines out there—you will find these motors hiding under the hood. These motors are common for a reason and that is because they are very, very simple. So simple that powering them up only requires a battery and two wires. Simply connect the positive to one terminal and negative to the other, and the motor will start spinning. Interchange those connections and the direction of the rotation will change. Take two cells and double the voltage and the motor will spin even faster. It is that simple.</p>
<p>Now you might assume that we would simply connect this motor to Raspberry Pi and that we would be good to go. But unfortunately this is not going to be the case. As you may remember from the previous chapters, Raspberry Pi can only supply around 50 milliamps, but the consumption of a motor can be much higher. Hence, to run one we need an intermediate device. </p>
<p>The first thing that will come to your mind will be to use a relay, and why not? They can channel a huge amount of current and can handle high voltages. This should be the ideal choice. You would be right if you thought so, but only to some extent, and that is because a relay is simply a switch we can use to turn the motor on or off. We would not be able to control the speed or the direction of rotation of the motor. Now, you would think that this problem is not new and that we can very easily solve it by using <strong>pulse width modulation</strong> (<strong>PWM</strong>), right? Well, the answer is no! Because these relays are mechanical devices, and due to their mechanical nature, there are some maximum limits in terms of it being switched on or off in a second. Hence, it would not be able to cope with the frequency of PWM. Finally, we would still be left with the problem of changing the direction and the speed of the motor. So what do we do now?</p>
<p>As I always say, the beauty of a problem is that it always has a solution, and the solution here is called a motor driver. A motor driver is primarily a set of electronic relays—a switch that can allow high currents yet is not mechanical. Hence, we can switch it hundreds of times every second. These electronic relays are either made of simple transistors or, in high power applications, they can even use MOSFETs for switching. We can simply give PWM to these electronic switches and get the voltage to modulate while making sure that enough current is being delivered to the circuit. Further, as I mentioned earlier, the motor driver is made of a set of these electronic relays. The most common and workable fashion in which they are arranged is called a full bridge or an H Bridge. Before I explain any further, let's see what this is, exactly: </p>
<div><img src="img/3f250030-b631-4351-9746-c38e7caf0222.png" style="width:26.25em;height:22.33em;"/></div>
<p>In a full bridge we have four switching circuits across the connected motor; these can be independently switched on or off based on the requirements. In the off state, all of these switching circuits are in an open state, hence keeping the motor switched off. Now, whenever we want to start the motor, we will have to switch on two switches in such a way that the circuit is complete and the motor starts working. So let's see what it would look like:</p>
<div><img src="img/61cf5d12-fe36-447a-b233-1304060c39cf.png" style="width:28.08em;height:27.92em;"/></div>
<p>Here, we have switched on the switching circuit <strong>S2</strong> and <strong>S3</strong>; this in turn completes the circuit and lets the current flow in the motor. Now, to control the speed, these same switching circuits can be switched on and off at a very high frequency at varying duty cycles to achieve a specific mean voltage. Now that we can achieve a specific speed for the motor by changing the voltage via these two switching circuits, let's see how we are going to change the direction  of rotation of the motor:</p>
<div><img src="img/5d887368-95b7-4bfb-aba6-31c27cf7ef13.png" style="width:28.25em;height:24.17em;"/></div>
<p>In this circuit we have switched off the previously connected <strong>S2</strong> and <strong>S3</strong> and instead switched on <strong>S1</strong> and <strong>S4</strong>, hence the polarity to the motor is reversed. As we discussed earlier, whenever the polarity of a DC-brushed motor is changed, the direction also changes subsequently. There are various types of motor drivers you can find on the market. What we have understood here is called a brushed DC H-bridge motor driver; there are other types of motor drivers as well for controlling other types of motors, but currently we will stick to the brushed motor only. While selecting a motor driver, you should examine the specification sheet of the motor driver very carefully. Some of the key specifications that will be mentioned are as follows:</p>
<ul>
<li><strong>Voltage rating</strong>: There will be a minimum and maximum limit to the voltage that the motor driver can handle and modulate between. Make sure your motor lies in between this specific voltage range. </li>
<li><strong>Current rating</strong>: There will be an absolute maximum current that the motor driver can handle; going anywhere beyond it will burn or damage the motor driver. This can be a little deceptive. Let's see why. Except for the absolute maximum, there will be many other current ratings that might be specified. These might be:
<ul>
<li><strong>Repetitive maximum current</strong>: This is the current rating that can be the maximum current the motor driver can handle, but not continuously. This rating is given because at times the load on the motor might increase and there might be a higher current requirement for a brief moment. The motor driver will provide the adequate current on a repetitive basis without getting damaged. But this current requirement should not be continuous. </li>
<li><strong>Burst maximum current</strong>: This is the absolute maximum current that the motor driver can handle; anything beyond it will damage the motor driver. The DC motors might have a very high current requirement when it starts from a standstill. Hence, the motor drivers are designed to handle these currents. But this surge of current should not be repetitive, otherwise heating and subsequent damage can happen. Often, burst maximum current is referred to as the maximum current by the manufacturers.</li>
<li><strong>Continuous maximum current</strong>: This is the real deal; the continuous maximum current is the maximum continuous current that the motor driver can mange on a continuous basis. </li>
</ul>
</li>
<li><strong>Supply voltage</strong>: This is the operating voltage of the motor driver—this voltage must be given to the motor driver for its own internal workings. </li>
<li><strong>Logic supply voltage</strong>: This is the control signal given to the motor driver, and can be given at various voltages such as 5V, 3.3V, and 12V. Hence, the motor driver will specify the maximum logical voltage that it can accept in the signal line.</li>
</ul>
<p>Now, let's see what we have got. During the course of this book, we will be using the L298N motor driver module, which currently is one of the most common motor driver modules available on the market. It has two channels—you have two H-bridges and hence you can connect two motors onto it. Further, the specifications for this motor driver are also decent for the price. Here are the specifications:</p>
<ul>
<li><strong>Voltage rating</strong>: 2.5V to 46V</li>
<li><strong>Repetitive maximum current</strong>: 2.5 amp</li>
<li><strong>Burst maximum current</strong>: 3 amp</li>
<li><strong>Continuous maximum current</strong>: 2 amp</li>
<li><strong>Supply voltage</strong>: 4.5V to 7V</li>
<li><strong>Logic supply voltage</strong>: 4.5V to 7V</li>
</ul>
<p>Once you have the physical motor driver with you, you will notice the following pins:</p>
<ul>
<li><strong>Motor A</strong>: This is channel 1 of the motor driver. You can connect the first motor to this port.</li>
<li><strong>Motor B</strong>: This is channel 2 of the motor driver. You can connect a second motor to this port. If you only have one motor, you can simply leave this port unconnected.</li>
<li><strong>GND</strong>: This is the ground of the power supply that you will attach for the motor. It is very important that you not only connect the ground of the power supply but also connect the ground of Raspberry Pi to this port so that the circuit is complete between Raspberry Pi and the motor driver. </li>
<li><strong>VCC</strong>: This is the positive port of the motor driver. This is where the positive terminal of your battery or power adapter will go.</li>
<li><strong>IN 1 and IN 2</strong>: These are the two logical inputs that we need to provide from the microcontroller for motor A. Whenever IN 1 receives the signal, one part of the H-bridge is activated—the motor starts spinning in one direction. Whenever IN 2 receives the signal, the other part of the H-bridge is activated, making the motor spin in the opposite direction.</li>
<li><strong>IN 3 and IN 4</strong>: This is the logical input of the motor B, which will work in exactly the same way as IN 1 and IN 2.</li>
<li><strong>EN A and EN B</strong>: These are the enable pins for both the channels. If these pins are not high, the respective channels will not work despite any signal that you give over the input ports. You might notice that there is a small cap on the EN ports. This is called a shunt. What it does is that it makes contact between the two pins that it has been connected on. This cap, when present over the EN pin, means that it would permanently be high as long as this shunt is connected. </li>
</ul>


            

            
        
    </div>
<div><h1 class="header-title">Getting it rolling</h1>
                
            
            
                
<p>OK, that's a lot of theory, so now let's fire up one of our motors via Raspberry Pi. To do that, go ahead and connect the motor and the motor driver as shown:</p>
<div><img src="img/0e0b5815-8180-4424-ab8c-8dbcd4d0d7fe.png" style="width:30.33em;height:47.17em;"/></div>
<p class="mce-root">Now, once you are done with it, let's upload the code and see what happens:</p>
<pre>import RPi.GPIO as GPIO<br/>from time import sleep<br/>GPIO.setmode(GPIO.BCM)<br/><br/>Motor1R = 20<br/>Motor1L = 21<br/><br/>GPIO.setup(Motor1R,GPIO.OUT)<br/>GPIO.setup(Motor1L,GPIO.OUT)<br/><br/><br/>GPIO.output(Motor1R,GPIO.HIGH)<br/>GPIO.output(Motor1L,GPIO.LOW)<br/><br/>sleep(5)<br/><br/>GPIO.output(Motor1R,GPIO.LOW)<br/>GPIO.output(Motor1L,GPIO.HIGH)<br/><br/>sleep(5)<br/><br/>GPIO.cleanup()</pre>
<p>Now, let's understand the code a bit:</p>
<pre>Motor1R = 20<br/>Motor1L = 21</pre>
<p>Pin number <kbd>20</kbd> is connected to IN 1 of the motor driver. For convenience, we have changed motor 1 right to <kbd>Motor1R</kbd>; in reality, the motor can spin in any direction but we have just written this for convenience and understanding. Similarly, we have done this for <kbd>Motor1L</kbd> as well. This is connected to IN 2, hence this will lead to the motor spinning in the other direction:</p>
<pre>GPIO.output(Motor1R,GPIO.HIGH)<br/>GPIO.output(Motor1L,GPIO.LOW)</pre>
<p>Here, we are making the <kbd>Motor1R</kbd> or the pin number <kbd>20</kbd> high, which means that the input motor driver is getting is:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td><strong>Motor</strong></td>
<td><strong>Pin</strong></td>
<td><strong>Input</strong></td>
<td><strong>State</strong></td>
</tr>
<tr>
<td><kbd>Motor 1R</kbd></td>
<td>Pin number 20 of Raspberry Pi</td>
<td>IN 1</td>
<td><kbd>HIGH</kbd></td>
</tr>
<tr>
<td><kbd>Motor 1L</kbd></td>
<td>Pin number 21 of Raspberry Pi</td>
<td>IN 2</td>
<td><kbd>LOW</kbd></td>
</tr>
</tbody>
</table>
<p>Now, after a delay of 5 seconds, the following code will run, which will change the state of the pins as depicted in the below table:</p>
<pre>GPIO.output(Motor1R,GPIO.LOW)<br/>GPIO.output(Motor1L,GPIO.HIGH)</pre>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td><strong>Motor</strong></td>
<td><strong>Pin</strong></td>
<td><strong>Input</strong></td>
<td><strong>State</strong></td>
</tr>
<tr>
<td><kbd>Motor 1R</kbd></td>
<td>Pin number 20 of Raspberry Pi</td>
<td>IN 1</td>
<td><kbd>LOW</kbd></td>
</tr>
<tr>
<td><kbd>Motor 1L</kbd></td>
<td>Pin number 21 of Raspberry Pi</td>
<td>IN 2</td>
<td><kbd>HIGH</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p>Now, let's see what happens once we run it. The motor will spin firstly in one direction and then it will go in the other direction. The code is very straightforward and I don't think there is any need for explanation. All we are doing here is simply turning either of the two GPIOs connected to the motor driver on and off. Once the input IN 1 of the motor driver is activated, a part of the H-bridge is switched on, causing the motor to spin in one direction. Whenever the IN 2 of the motor driver is high, then the opposite part of H-bridge is turned on, causing the polarity at the output end of the motor driver to change, and hence the motor turns in the other direction.</p>


            

            
        
    </div>
<div><h1 class="header-title">Changing the speed </h1>
                
            
            
                
<p>Now that we have understood how to change the direction of the motor using the motor driver, it's time to take it a step further and control the speed of the motor using the motor driver. To do this, we don't really have to do much. The motor drivers are built to understand the PWM signals. Once the PWM signal to the motor driver is provided, then the motor driver in turn adjusts the output voltage for the motor and hence changes the speed of the motor driver. The PWM has to be provided on the same input ports IN 1 and IN 2 for motor A, and IN 3 and IN 4 for motor B. It is obvious that the pin on which the PWM is provided will decide the direction in which the motor will move, and the duty cycle of the PWM will decide the speed at which the motor will be spinning. </p>
<p>Now we have understood how speed control in motor driver works. It's time to do it by ourselves. To do so, we do not need to make any changes to the connections; all we need to do is to upload the following code:</p>
<pre>import RPi.GPIO as GPIO<br/>from time<br/>import sleep<br/>GPIO.setmode(GPIO.BCM)<br/><br/>Motor1R = 20<br/>Motor1L = 21<br/><br/>GPIO.setup(Motor1R, GPIO.OUT)<br/>GPIO.setup(Motor1L, GPIO.OUT)<br/><br/>pwm = GPIO.PWM(Motor1R, 100)<br/>pwm.start(0)<br/><br/>try:<br/>while True:<br/>  GPIO.output(Motor1L, GPIO.LOW)<br/>for i in range(0, 101):<br/>  pwm.ChangeDutyCycle(i)<br/>sleep(0.1)<br/><br/>except KeyboardInterrupt:<br/><br/>  pwm.stop()<br/>GPIO.cleanup()</pre>
<p>What happened after you ran this code? I'm sure the motor started slowly and then started increasing its speed and, upon reaching its top speed, it eventually stopped—exactly what we wanted it to do. If you remember, this code looks very familiar. Remember changing the brightness of the LED in the first chapter? It is almost the same; there are a few differences, though, so let's see what they are:</p>
<pre>pwm = GPIO.PWM(Motor1R, 100)</pre>
<p>In this line, we are simply defining the pin we have to give the PWM on—as in, on <kbd>Motor1R</kbd>, which corresponds to pin number <kbd>20</kbd>. Also, we are are defining the frequency of the PWM as <kbd>100</kbd> hertz or 100 times in a second:</p>
<pre>pwm.start(0)</pre>
<p>If you remember, the preceding command from the previous chapters, <kbd>pwm.start()</kbd>, is primarily used for defining the duty cycle of the  signal. Here, we are giving it the duty cycle as <kbd>0</kbd> that is the pin would be off:</p>
<pre>GPIO.output(Motor1L,GPIO.LOW)</pre>
<p>As we are running motor in one specific direction and which is <kbd>1R</kbd> hence the other half of the H bridge should be turned off. this would be done by the above line by putting the line <kbd>1L</kbd> LOW. If we don't do this then the pin <kbd>21</kbd> can be in an arbitrary state, hence it can be either on or off. This might conflict with the direction in which the motor is moving and the hardware would not work properly:</p>
<pre> for i in range(0,101):</pre>
<p>Here comes the real deal; this line, <kbd>for i in range(0,101):</kbd>, will keep on running the program contained in it until the time the value of <kbd>i</kbd> is between <kbd>0</kbd> to <kbd>101</kbd>. It will also increment the value of <kbd>i</kbd> every time this loop runs. Here, every time, the value will increase by one:</p>
<pre>            pwm.ChangeDutyCycle(i)</pre>
<p>Now, this is a slightly new command. Previously, we have used the line <kbd>pwm.start(0)</kbd> to assign a duty cycle to the PWM. As we have already assigned a duty cycle value to the PWM, to change it we would use the previously mentioned command. The duty cycle would be the same as the value of <kbd>i</kbd>.</p>
<p>Hence, every time the code passes through the <kbd>for</kbd> loop, the value or the duty cycle will increase by one. Super easy, isn't it?</p>
<p>Everything in robotics is very easy if you do it right. The idea is to break your problem into small pieces and solve them one by one; trust me, once you do that, nothing will look difficult to you. </p>


            

            
        
    </div>
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p class="mce-root">In this chapter, we worked on the various aspects of a motor. Moving on, by using all the basics, we will study the interaction of Bluetooth with mobile devices and build a Bluetooth-controlled robotic car.</p>


            

            
        
    </div></body></html>