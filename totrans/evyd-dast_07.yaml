- en: 'Chapter 7. Sets: No Duplicates'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。集合：无重复
- en: Within the confines of computer science, **sets** are typically used as a simple
    collection of objects that contain no duplicates. In the broader realm of mathematics
    in general, however, a set is an abstract data structure that can be described
    as a collection of distinct objects or values stored in no particular order. For
    the purpose of this discussion, we will choose to view a set as the computer implementation
    of a mathematically finite set.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学的范畴内，**集合**通常被用作一个简单的对象集合，其中不包含重复项。然而，在更广泛的数学领域，集合是一个抽象的数据结构，可以描述为按无特定顺序存储的不同对象或值的集合。为了讨论的目的，我们将选择将集合视为数学有限集合的计算机实现。
- en: When working with problems to which the mathematical concepts of set theory
    can be applied, set data structures provide a powerful group of tools for combining
    and examining relationships between collections of similar objects. However, even
    outside set theory and mathematics, the set data structure provides functionality
    that can be useful in everyday applications. For example, since a set naturally
    eliminates duplicates, any application that requires maintaining or editing a
    collection of unique elements would benefit from storing objects in a set data
    structure. Similarly, if you need to eliminate duplicates from an existing collection,
    most implementations of the set data structure will allow you to create a new
    set from a collection of arrays; and in doing so, you will filter out duplicates
    automatically. Overall, sets are a relatively simple data structure, which provide
    tremendous functionality and power in analyzing collections of data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理可以应用集合论数学概念的问题时，集合数据结构提供了一组强大的工具，用于组合和检查类似对象集合之间的关系。然而，即使在集合论和数学之外，集合数据结构也提供了在日常生活中可能有用的功能。例如，由于集合自然地消除了重复项，任何需要维护或编辑唯一元素集合的应用程序都将从存储对象在集合数据结构中受益。同样，如果你需要从现有集合中消除重复项，大多数集合数据结构的实现都将允许你从一个数组集合中创建一个新的集合；在这样做的时候，你将自动过滤掉重复项。总的来说，集合是一个相对简单的数据结构，在分析数据集合时提供了巨大的功能性和力量。
- en: 'In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Definition of the set data structure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合数据结构的定义
- en: Set theory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合论
- en: Initializing sets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化集合
- en: Common set operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见集合运算
- en: Revisiting the users logged in to a service problem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视登录到服务的用户问题
- en: Case study - music playlists
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究 - 音乐播放列表
- en: Hash table-based sets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于哈希表的集合
- en: Tree-based sets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于树的集合
- en: Array-based sets
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于数组的集合
- en: Set theory
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合论
- en: 'The concept of a set is relatively simple, but in practice a concrete implementation
    can be somewhat difficult to understand due to its mathematical origins. Therefore,
    in order to fully appreciate the set data structure, it becomes necessary to examine
    some of the characteristics and functions of **set theory** upon which the set
    data structure is built. Set theory is a branch of mathematics that studies collections,
    or *sets*, of objects. Although set theory is a major area of research in mathematics
    with many interrelated sub-fields, we really only need to examine five functions
    for combining and relating sets to one another to understand the set data structure:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的概念相对简单，但在实践中，由于其数学起源，具体的实现可能有些难以理解。因此，为了完全欣赏集合数据结构，有必要检查构建集合数据结构的基础——**集合论**的一些特性和函数。集合论是研究对象集合或*集合*的数学分支。尽管集合论是数学中的一个主要研究领域，有许多相互关联的子领域，但我们实际上只需要检查五个用于结合和关联集合的函数，以理解集合数据结构：
- en: '**Union**: A union is one of the fundamental methods of combining and relating
    sets to one another. A union of a series of *n* sets is the set of only those
    distinct elements contained in those sets. This means that, if you combine sets
    *A* and *B*, the resulting set will only contain unique elements from set *A*
    and *B*. If an element exists in both *A* and *B*, it will only appear once in
    our result set. We use the notation *A* ∪ *B* to denote the *union* of sets *A*
    and *B*. The following Venn diagram represents the union of two sets:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并集**：并集是结合和关联集合的基本方法之一。一系列 *n* 个集合的并集是仅包含那些在这些集合中出现的不同元素的集合。这意味着，如果你将集合 *A*
    和 *B* 结合起来，结果集合将只包含来自集合 *A* 和 *B* 的唯一元素。如果一个元素同时存在于 *A* 和 *B* 中，它将只在我们结果集中出现一次。我们使用符号
    *A* ∪ *B* 来表示集合 *A* 和 *B* 的并集。以下维恩图表示了两个集合的并集：'
- en: '![Set theory](img/00008.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![集合论](img/00008.jpeg)'
- en: '**Intersection**: An intersection is the second fundamental method of combining
    and relating sets to one another. An intersection of a collection of *n* sets
    is the set of elements that exist in each of the sets being evaluated. So if we
    examine sets *A* and *B* for an intersection, our resulting set will only include
    those elements that exist in both *A* and *B*. Any elements that are unique to
    *A* or *B* will be discarded. We use the notation *A* ∩ *B* to denote the *intersection*
    of set *A* with set *B*. The following Venn diagram represents the intersection
    of two sets:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交集**：交集是组合和关联集合的第二种基本方法。一个由 *n* 个集合组成的交集是存在于每个被评估集合中的元素集合。因此，如果我们检查集合 *A*
    和 *B* 的交集，我们的结果集合将只包括存在于 *A* 和 *B* 中的那些元素。任何只属于 *A* 或 *B* 的元素将被丢弃。我们使用符号 *A* ∩
    *B* 来表示集合 *A* 与集合 *B* 的交集。以下维恩图表示了两个集合的交集：'
- en: '![Set theory](img/00009.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![集合论](img/00009.jpeg)'
- en: '**Difference**: The difference operation is the opposite of the intersection
    operation. The difference of a collection of *n* sets is the set of elements that
    are unique to each set being evaluated. If we examine sets *A* and *B* for a difference,
    our resulting set will only include those elements that exist in either *A* or
    *B*. Any elements that are part of the intersection of *A* and *B* will be discarded.
    We use the notation *A* Δ *B* to denote the *difference* between sets *A* and
    *B*. The following Venn diagram represents the difference of two sets:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**差集**：差集操作是交集操作的相反操作。一个由 *n* 个集合组成的差集是每个被评估集合中唯一的元素集合。如果我们检查集合 *A* 和 *B* 的差集，我们的结果集合将只包括存在于
    *A* 或 *B* 中的那些元素。任何属于 *A* 和 *B* 交集的元素将被丢弃。我们使用符号 *A* Δ *B* 来表示集合 *A* 和 *B* 之间的差集。以下维恩图表示了两个集合的差集：'
- en: '![Set theory](img/00010.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![集合论](img/00010.jpeg)'
- en: '**Compliment**: The compliment, or the **relative compliment**, of *A* in *B*
    is the set of elements that are found in *B* but not found in *A*. If we examine
    sets *A* and *B* for a compliment, only those elements that are unique to *B*
    will be included in our result set. Any elements that are unique to *A* or are
    part of the intersection of *A* and *B* will be discarded. We use the notation
    *B\**A *to denote the relative compliment of set *A* with respect to set *B*. The
    following Venn diagram represents the compliment of two sets:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**补集**：*A* 在 *B* 中的补集，或称为**相对补集**，是存在于 *B* 但不存在于 *A* 中的元素集合。如果我们检查集合 *A* 和
    *B* 的补集，只有那些只属于 *B* 的元素将包含在我们的结果集合中。任何只属于 *A* 或是 *A* 和 *B* 交集的元素将被丢弃。我们使用符号 *B\**A*
    来表示集合 *A* 相对于集合 *B* 的相对补集。以下维恩图表示了两个集合的补集：'
- en: '![Set theory](img/00011.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![集合论](img/00011.jpeg)'
- en: '**Subset**: The subset is the final fundamental method of combining and relating
    sets to one another. The subset operation determines if set *A* is a subset of
    set *B*, or rather if set *B* is a **superset** of set *A*. This relationship
    of one set being a subset of another is called an **inclusion**, or a **containment** when
    considering one set is a superset of another set. In the next figure, we can say
    that *A* is the subset of *B* or *B* is the superset of *A*. We use the notation
    *A* ⊂ *B* to denote that set *A* is an inclusion of set *B*, or *B ⊃*  *A* to
    denote that set *B* is the containment of set *A*.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子集**：子集是组合和关联集合的最终基本方法。子集操作确定集合 *A* 是否是集合 *B* 的子集，或者换句话说，集合 *B* 是否是集合 *A*
    的**超集**。一个集合是另一个集合的子集的关系称为**包含**，或者当一个集合是另一个集合的超集时，称为**包含**。在下一个图中，我们可以说 *A* 是
    *B* 的子集，或者 *B* 是 *A* 的超集。我们使用符号 *A* ⊂ *B* 来表示集合 *A* 是集合 *B* 的包含，或者 *B ⊃* *A* 来表示集合
    *B* 是集合 *A* 的包含。'
- en: '![Set theory](img/00012.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![集合论](img/00012.jpeg)'
- en: Initializing sets
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化集合
- en: Sets are not terribly commonplace in development, but each of the languages
    we are examining supports data structures with some form of concrete implementations.
    Here are some examples of initializing a set, adding a few values to the collection
    including one duplicate, and printing the set's count to the console after each
    step.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 集合在开发中并不十分常见，但我们正在检查的每种语言都支持以某种具体形式实现的数据结构。以下是一些初始化集合、向集合中添加一些值（包括一个重复值）以及在每一步后将集合的计数打印到控制台的示例。
- en: '**C#**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'C# provides a concrete implementation of the set data structure through the
    `HashSet<T>` class. Since this class is generic, the caller may define the type
    used for elements. For example, the following example initializes a new set where
    the elements will be `string` types:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: C#通过`HashSet<T>`类提供了集合数据结构的具体实现。由于此类是泛型的，调用者可以定义用于元素的类型。例如，以下示例初始化了一个新集合，其中元素将是`string`类型：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Java**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'Java provides a `HashSet<E>` class as well as other classes that implement
    the `Set<E>` interface. In this chapter, we''ll look at an example of the `HashSet<E>`
    class only:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了一个`HashSet<E>`类以及其他实现`Set<E>`接口的类。在本章中，我们将仅查看`HashSet<E>`类的示例：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Objective-C**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'Objective-C provides immutable as well as mutable set classes, `NSSet` and
    `NSMutableSet`. In this chapter, we will only be examining the mutable version
    in detail:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C提供了不可变和可变的集合类，`NSSet`和`NSMutableSet`。在本章中，我们只将详细检查可变版本：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Swift**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Sets in Swift are created using the `Set` class. Swift sets are mutable when
    initialized as **variables** using `var`, but they can also be created as immutable
    by initializing them as **constants** using `let`. In this chapter, we will only
    be examining the mutable version in detail:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的集合使用`Set`类创建。当使用`var`初始化为**变量**时，Swift集合是可变的，但它们也可以通过使用`let`初始化为**常量**来创建不可变。在本章中，我们只将详细检查可变版本：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Set operations
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合操作
- en: 'Not all concrete implementations of the set data structures expose the same
    operational methods. However, the more common operations should be available or
    can be made available as needed by the developer. As you examine these operations,
    note how the language is similar to the language of set theory operations discussed
    earlier. You will find that most of the set data structure functionality will
    closely mirror that of set theory in general:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有集合数据结构的具体实现都公开相同的操作方法。然而，更常见的操作应该是可用的，或者可以通过开发者的需要来提供。在检查这些操作时，请注意语言与之前讨论的集合理论操作语言的相似性。您会发现大多数集合数据结构的功能将紧密地反映集合理论的一般功能：
- en: '**add**: The add operation, sometimes referred to as an insert, introduces
    a new object into the collection if that object does not already exist in the
    collection. This functionality, which prevents duplicate objects from being added
    to the collection, is one of the core advantages of using a set over many other
    data structures. Most implementations of the set data structure will return a
    Boolean value denoting whether or not the element could be added to the collection.
    Add operations have an **O**(*n*) cost.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加**: 添加操作，有时称为插入，如果该对象尚未存在于集合中，则将其引入集合。这种防止重复对象被添加到集合中的功能是使用集合而不是许多其他数据结构的核心优势之一。大多数集合数据结构的实现将返回一个布尔值，表示元素是否可以添加到集合中。添加操作具有**O**(*n*)的成本。'
- en: '**remove**: The remove, or delete, operation allows the caller to remove a
    value or object from the collection if it exists. Most implementations of the
    set data structure return a Boolean value denoting whether or not the remove operation
    was successful. Remove operations have an **O**(*n*) cost.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**: 删除或删除操作允许调用者从集合中删除一个值或对象，如果它存在。大多数集合数据结构的实现返回一个布尔值，表示删除操作是否成功。删除操作具有**O**(*n*)的成本。'
- en: '**capacity**: The capacity operation returns the maximum number of values the
    set can hold. This is not an operation that developers will naturally see in the
    four languages we are discussing as each of the mutable sets found in these languages
    can dynamically resize on demand. However, some implementations do permit the
    set to be limited in size as part of its definition. Capacity has an **O**(1)
    operational cost.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容量**: 容量操作返回集合可以存储的最大值数。这不是开发者在讨论的四种语言中自然看到的操作，因为这些语言中找到的每个可变集合都可以根据需要动态调整大小。然而，一些实现确实允许将集合的大小限制为其定义的一部分。容量具有**O**(1)的操作成本。'
- en: '**union**: The union operation returns a new set containing the unique elements
    of two or more sets. Therefore, this operation has a worst-case cost of **O**(*n*+*m*),
    where *n* is the size of the first set and *m* is the size of the second set.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并集**: 并集操作返回一个包含两个或多个集合中唯一元素的新集合。因此，此操作的最坏情况成本为**O**(*n*+*m*)，其中*n*是第一个集合的大小，*m*是第二个集合的大小。'
- en: '**intersection**: The intersection operation returns only those elements that
    are shared between two or more sets. This means that, if you supply the method
    with two sets, you will only get back those elements that already exist in both
    sets. Intersection carries an **O**(*n***m*), where *n* is the size of the first
    set and *m* is the size of the second set. Interestingly, if you attempt to perform
    an intersection on a series of three or more sets, the cost becomes *(n-1) ** **O**(*L*),
    where *n* is the number of *sets* involved in the operation and *L* is the size
    of the largest set in the series. Obviously, this cost is quite high and using
    this operation on multiple sets simultaneously could get out of hand very quickly.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**intersection**: 交集操作仅返回两个或多个集合之间共享的元素。这意味着，如果您向该方法提供两个集合，您将仅获得存在于两个集合中的那些元素。交集的成本为
    **O**(*n***m*)，其中 *n* 是第一个集合的大小，*m* 是第二个集合的大小。有趣的是，如果您尝试对三个或更多集合进行交集操作，成本将变为 *(n-1) ** **O**(*L*)，其中
    *n* 是参与操作的集合数量，*L* 是系列中最大集合的大小。显然，这个成本相当高，并且同时使用此操作在多个集合上可能会迅速失控。'
- en: '**difference**: The difference operation is the opposite of the intersection
    operation, returning only those elements that are unique to each set. This operation
    has an operational cost of **O**(*m*), where *m* is the length of the shorter
    of the two sets being evaluated.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**difference**: 差集操作是交集操作的相反，仅返回每个集合中独特的元素。此操作的成本为 **O**(*m*)，其中 *m* 是两个被评估集合中较短的那个的长度。'
- en: '**subset**: The subset operation returns a Boolean value determining whether
    set *A* is a subset of set *B*. For set *A* to be considered a subset of set *B*,
    every element within set *A* must also be included in set *B*. If only a portion
    of the elements of set *A* are contained in set *B*, then sets *A* and *B* share
    an intersection, but *A* is not a subset of *B*. This operation has an operational
    cost of **O**(*m*), where *m* is the length of set *A*.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**subset**: 子集操作返回一个布尔值，确定集合 *A* 是否是集合 *B* 的子集。对于集合 *A* 被认为是集合 *B* 的子集，集合 *A*
    中的每个元素也必须包含在集合 *B* 中。如果集合 *A* 的只有部分元素包含在集合 *B* 中，那么集合 *A* 和 *B* 有交集，但 *A* 不是 *B*
    的子集。此操作的操作成本为 **O**(*m*)，其中 *m* 是集合 *A* 的长度。'
- en: '**count**: The count, or size, operation represents the *cardinality* of a
    particular set, which is really just the set theory way of saying the number of
    elements in the set. Count is typically a simple property on the collection and,
    therefore, has an **O**(*1*) cost.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**count**: `count` 操作，或称为大小，表示特定集合的 **基数**，这实际上是集合论中表达集合中元素数量的方式。计数通常是集合上的一个简单属性，因此具有
    **O**(*1*) 的成本。'
- en: '**isEmpty**: The isEmpty operation returns a Boolean value representing whether
    the set contains any elements at all. Some implementations provide a corresponding
    `isFull` operation, but only for those instances where the set capacity can be
    limited to a specific value. Both `isEmpty` and `isFull` have an **O**(*1*) cost.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**isEmpty**: `isEmpty` 操作返回一个布尔值，表示集合是否包含任何元素。一些实现提供了相应的 `isFull` 操作，但仅限于那些可以将集合容量限制为特定值的实例。`isEmpty`
    和 `isFull` 都有 **O**(*1*) 的成本。'
- en: 'Example: revisiting users logged in to a service'
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例：回顾登录服务的用户
- en: 'Let''s revisit the users logged into a service problem from [Chapter 2](part0019_split_000.html#I3QM2-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 2.  Arrays: Foundational Collections"), *Arrays: Foundational Collection*, one
    more time and examine how the code will be changed if we had chosen a set as the
    underlying data structure rather than an array or list.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回顾 [第2章](part0019_split_000.html#I3QM2-77f2b5b248f04368a6f723b0e9357ef3
    "第2章。数组：基础集合") 中的用户登录服务问题，*数组：基础集合*，并检查如果我们选择集合而不是数组或列表作为底层数据结构，代码将如何改变。
- en: '**C#**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'In this example, we have replaced the `List<User>` object with a `HashSet<User>`
    object. The majority of our code is unchanged, but you should note the exclusion
    of the `CanAddUser(User)` method. Originally, this method validated the *authenticated
    user* action by ensuring that the collection had room for another object and then
    ensuring that the object to be added was not already included in the collection.
    A set data structure eliminates the need for the second step as it intrinsically
    prevents duplicate objects from being added. Since the only validation our class
    now requires is a capacity check, we can handle that inline with the `UserAuthenticated(User)`
    functionality. As an added bonus, we can now easily report whether or not the
    user was successfully added, as `HashSet<T>.Add(T)` returns `true` for success,
    and `false` when the object already exists in the set:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`List<User>`对象替换为了`HashSet<User>`对象。我们的代码大部分没有改变，但请注意，我们排除了`CanAddUser(User)`方法。原本，这个方法通过确保集合有空间容纳另一个对象，然后确保要添加的对象尚未包含在集合中来验证已认证用户的操作。集合数据结构消除了进行第二步的需要，因为它本质上防止了重复对象的添加。由于我们的类现在只需要进行容量检查验证，我们可以将这个检查与`UserAuthenticated(User)`功能一起内联处理。作为额外的奖励，我们现在可以轻松地报告用户是否成功添加，因为`HashSet<T>.Add(T)`在成功时返回`true`，当对象已存在于集合中时返回`false`：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Java**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'Changes in our Java example almost mirror those of our C# example. Again, we
    have replaced the `List<User>` object with a `HashSet<User>` object. The majority
    of our code is unchanged, except for the exclusion of the `canAddUser(User)` method.
    In Java, the `HashSet<E>` class implements the `Set<E>` interface and is based
    on a set data structure, which eliminates the need for checking whether an object
    exists in the collection before adding it. Since the only validation our class
    now requires is a capacity check, we can handle that inline with the `userAuthenticated(User)`
    functionality. Again, we can now easily report whether or not the user was successfully
    added, as `HashSet<E>.add(E)` returns `true` for success, and `false` when the
    object already exists in the set:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Java示例中的更改几乎与我们的C#示例相同。同样，我们用`HashSet<User>`对象替换了`List<User>`对象。我们的代码大部分没有改变，除了排除了`canAddUser(User)`方法。在Java中，`HashSet<E>`类实现了`Set<E>`接口，并基于集合数据结构，消除了在添加对象之前检查对象是否存在于集合中的需要。由于我们的类现在只需要进行容量检查验证，我们可以将这个检查与`userAuthenticated(User)`功能一起内联处理。同样，我们现在可以轻松地报告用户是否成功添加，因为`HashSet<E>.add(E)`在成功时返回`true`，当对象已存在于集合中时返回`false`：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Objective-C**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: Changes to our Objective-C example yield some interesting results. Although
    we are exchanging the `NSMutableArray` collection for an `NSMutableSet` collection,
    the majority of our code remains the same, including the fact that we are not
    going to return a `BOOL` representing the success or failure of our `addObject:`
    operation. This is because `addObject:` does not return a value; if we were to
    include it in `userAuthenticated:`, we would have to resort to calling the `containsObject:`
    method prior to calling `addObject:` on our set collection. Since the entire point
    of this exercise is to use a set to eliminate the need to check for duplicates
    before adding new objects, to re-introduce this functionality would defeat the
    purpose and potentially put us in a more costly position than if we simply stuck
    with an array or list.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Objective-C示例的更改产生了一些有趣的结果。尽管我们用`NSMutableArray`集合替换了`NSMutableSet`集合，但大部分代码保持不变，包括我们不会返回一个表示`addObject:`操作成功或失败的`BOOL`值。这是因为`addObject:`不返回任何值；如果我们将其包含在`userAuthenticated:`中，我们不得不在调用集合上的`addObject:`之前调用`containsObject:`方法。由于这个练习的整个目的是使用集合来消除在添加新对象之前检查重复的需要，重新引入这个功能将违背初衷，并可能使我们处于比简单地坚持使用数组或列表更昂贵的位置。
- en: 'This is not to say that there are no valid applications that could benefit
    from a set as well as a report on the success or failure of an `addObject:` operation;
    this is just not one of those cases:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说没有有效的应用可以从集合以及关于`addObject:`操作成功或失败的报告中获得好处；这只是说这种情况并不适用：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Swift**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'The outcome of our Swift example is almost exactly like that of our Objective-C
    example. Again, we are replacing our array with a set, but sets in Swift function
    much like they do in Objective-C. Therefore, our final code is more abbreviated
    but does not immediately provide the same functionality as our C# and Java implementations:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Swift示例的结果几乎与我们的Objective-C示例完全相同。再次强调，我们正在用集合替换数组，但在Swift中集合的工作方式与在Objective-C中类似。因此，我们的最终代码更加简洁，但并不立即提供与我们的C#和Java实现相同的功能：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We would need a contract
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们需要一份合同
- en: If you look carefully at each of the three solutions to the logged in user business
    problem, you will probably notice they all share common public methods. In our
    array implementation, list implementation, and set implementation, we have two
    public methods named `UserAuthenticated()` and `UserLoggedOut()`, or some variation
    of these names depending on the language. This would not be an issue if we were
    to just choose one implementation that best suits our needs and move on. However,
    what if there were justifiable reasons to keep each one of these classes in our
    solution to efficiently work within specific environmental conditions?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察解决已登录用户业务问题的三个方案中的每一个，你可能会注意到它们都共享一些公共方法。在我们的数组实现、列表实现和集合实现中，我们有两个名为
    `UserAuthenticated()` 和 `UserLoggedOut()` 的公共方法，或者根据语言的不同，这些名称可能会有所变化。如果我们只是选择最适合我们需求的一个实现并继续前进，这不会成为问题。然而，如果我们有合理的理由保留这些类中的每一个，以便在特定的环境条件下高效工作，那会怎样呢？
- en: In actuality, it is very common to see multiple classes that share the same
    public-facing methods but have uniquely implemented functionality under the hood.
    If we were to simply create three (or more) separate implementations that are
    completely independent of one another, our application would have a resulting
    *code smell*. That's because, whenever we want to use a specific implementation,
    we will need to call for it by name, which requires some advance knowledge of
    which classes and implementations are available. Plus, although our code might
    work just fine, it will be fragile, inextensible, and more difficult to maintain
    in the long term.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，看到多个类共享相同的公共方法，但在底层有独特实现的代码非常普遍。如果我们简单地创建三个（或更多）完全独立的独立实现，我们的应用程序将产生一个 *代码异味*。这是因为，每当我们想要使用特定的实现时，我们都需要通过名称来调用它，这需要我们对哪些类和实现可用有一定的预先了解。此外，尽管我们的代码可能运行得很好，但它将是脆弱的、不可扩展的，并且长期维护起来会更加困难。
- en: A better solution would involve defining a contract that each class implements.
    In C# or Java, we would define an interface, while in Objective-C and Swift, we
    would define a protocol. The difference between these two patterns is mostly semantics,
    as they will both provide our caller with the names of the methods, what the methods
    expect, and what the methods will return. What is important is that by doing this,
    we greatly simplify and harden our implementation of both the functionality and
    the calling class structures.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案将涉及定义一个每个类都实现的合同。在C#或Java中，我们会定义一个接口，而在Objective-C和Swift中，我们会定义一个协议。这两种模式之间的区别主要在于语义，因为它们都将为我们的调用者提供方法名称、方法期望的内容以及方法将返回的内容。重要的是，通过这样做，我们极大地简化并加强了功能实现和调用类结构的实现。
- en: 'Case-study: music playlists'
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究：音乐播放列表
- en: '**Business problem**: A music streaming service wants to provide their users
    with a better streaming experience. Currently, user playlists are a simple collection
    of songs dumped into a bucket that provides no means of filtering or ordering
    the collection. The content management team has heard the complaints of their
    users and has tasked the engineering team with building a better playlist.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**业务问题**：一个音乐流媒体服务希望为用户提供更好的流媒体体验。目前，用户播放列表只是一个简单的歌曲集合，被倒入一个没有提供过滤或排序集合方式的桶中。内容管理团队已经听到了用户的投诉，并已将构建更好的播放列表的任务分配给了工程团队。'
- en: This new playlist tool will have several key requirements. The more basic requirements
    include the ability to add and remove songs from the list, the ability to differentiate
    between an empty list and a list with elements, as well the ability to report
    on the total count of elements in the list. For those customers who are not interested
    in paying for the premium service, the lists will be limited to a 100 songs so
    our playlist tool must also have the ability to set a capacity and easily identify
    when the capacity has been met.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的播放列表工具将会有几个关键要求。更基本的要求包括能够从列表中添加和删除歌曲，能够区分空列表和包含元素的列表，以及能够报告列表中元素的总数。对于那些对付费高级服务不感兴趣的客户，列表将限制为100首歌曲，因此我们的播放列表工具还必须具备设置容量和轻松识别容量已满的能力。
- en: Additionally, many premium users are known to have thousands of songs in their
    playlist, as well as multiple themed playlists for everything from riding their
    bike to doing the laundry. For these users the playlist tool must include some
    advanced analysis and editing features. First, there must be a way to easily consolidate
    playlists and, since we don't want to have songs that exist in both playlists
    to appear twice, this consolidation must prevent duplicates. Next, the playlist
    should be able to easily identify songs that are duplicated between two lists
    as well as identify songs that are unique to specific lists. Finally, some users
    will want to know more information about their collection of playlists, such as
    whether one playlist exists as part of another playlist. Based on these requirements,
    the developer decides that a set will be the most efficient way to represent the
    playlists, so the core class's functionality will be based on that data structure.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多高级用户在他们的播放列表中拥有数千首歌曲，以及针对从骑自行车到洗衣服等一切事物的多个主题播放列表。对于这些用户，播放列表工具必须包括一些高级分析和编辑功能。首先，必须有一种简单的方法来轻松合并播放列表，并且由于我们不希望同时存在于两个播放列表中的歌曲出现两次，这种合并必须防止重复。接下来，播放列表应该能够轻松识别两个列表之间重复的歌曲，以及识别特定列表中独特歌曲。最后，一些用户可能希望了解有关他们播放列表集合的更多信息，例如是否有一个播放列表作为另一个播放列表的一部分存在。基于这些要求，开发者决定使用集合来表示播放列表将是最有效的方法，因此核心类的功能将基于该数据结构。
- en: '**C#**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'C# provides the generic collection `HashSet<T>`. This class provides all of
    the basic operations we would expect to see in a concrete set implementation with
    the added benefit of generic type casting:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了泛型集合 `HashSet<T>`。这个类提供了我们在具体的集合实现中期望看到的所有基本操作，并增加了泛型类型转换的额外好处：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using the `HashSet<T>` interface, we create one private field for our class
    called `_songs`. Our constructor instantiates this field, giving us the underlying
    data structure to build our `PlaylistSet` class on. We also create four public
    fields: `capacity`, `premiumUser`, `isEmpty`, and `isFull`. The `capacity` field
    stores the maximum numbers of songs non-premium users can store in their playlist,
    while `premiumUser` denotes whether this list belongs to a premium account or
    not. The `isEmpty` and `isFull` fields allow our class to easily implement the
    two operations of the same name. The `isEmpty` field simply returns whether or
    not the count of the set is `0`. The `isFull` field first checks whether this
    list belongs to a premium account. If `true`, the collection is never full as
    we allow premium users to store unlimited songs in their playlists. If this list
    does not belong to a premium account, our getter ensures that the current count
    of `_songs` has not exceeded the capacity and returns that comparison:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `HashSet<T>` 接口，我们为我们的类创建了一个名为 `_songs` 的私有字段。我们的构造函数实例化了这个字段，为我们提供了构建 `PlaylistSet`
    类的基础数据结构。我们还创建了四个公共字段：`capacity`、`premiumUser`、`isEmpty` 和 `isFull`。`capacity`
    字段存储非高级用户可以在他们的播放列表中存储的最大歌曲数量，而 `premiumUser` 表示这个列表是否属于高级账户。`isEmpty` 和 `isFull`
    字段允许我们的类轻松实现同名操作。`isEmpty` 字段简单地返回集合的计数是否为 `0`。`isFull` 字段首先检查这个列表是否属于高级账户。如果是
    `true`，则集合永远不会满，因为我们允许高级用户在他们的播放列表中存储无限数量的歌曲。如果这个列表不属于高级账户，我们的获取器确保 `_songs` 的当前计数没有超过容量，并返回这个比较：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `AddSong(Song song)` method provides the *add* functionality to our class.
    This method first confirms that the collection is not full. If this is so, the
    method returns `false` as we cannot add any more songs to the list. Otherwise,
    the method returns the result of `HashSet<T>.Add(T)` which returns `true` if `song`
    is added, meaning the song was not already in the list.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSong(Song song)` 方法为我们这个类提供了 *添加* 功能。该方法首先确认集合没有满。如果是这样，该方法返回 `false`，因为我们不能向列表中添加更多歌曲。否则，该方法返回
    `HashSet<T>.Add(T)` 的结果，如果 `song` 被添加，则返回 `true`，这意味着歌曲不在列表中。'
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `RemoveSong(Song song)` method provides *remove* functionality to our class.
    This method simply returns the result of `HashSet<T>.Remove(T)`, which will return
    `true` if the song exists in the list; otherwise, it will return `false`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveSong(Song song)` 方法为我们这个类提供了 *移除* 功能。这个方法简单地返回 `HashSet<T>.Remove(T)`
    的结果，如果歌曲存在于列表中，则返回 `true`；否则，返回 `false`：'
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `MergeWithPlaylist(HashSet<Song> playlist)` method provides the *union*
    functionality for our class. Luckily, `HashSet<T>` exposes the union functionality
    with the `Union(HashSet<T>)` method, so our method simply calls it. In this case,
    `Union()` will merge the `playlist` parameter with our existing `_songs` list:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`MergeWithPlaylist(HashSet<Song> playlist)` 方法为我们这个类提供了 *并集* 功能。幸运的是，`HashSet<T>`
    通过 `Union(HashSet<T>)` 方法公开了并集功能，所以我们的方法只是简单地调用它。在这种情况下，`Union()` 将合并 `playlist`
    参数和我们的现有 `_songs` 列表：'
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, the `FindSharedSongsInPlaylist(HashSet<Song> playlist)` method provides
    the *intersection* functionality to our class. Again, `HashSet<T>` conveniently
    provides the `IntersectWith(HashSet<T>)` method, which our method takes advantage
    of. Note that this method does not modify our list in-place, but rather returns
    the actual intersection of our list and the `playlist` parameter. We do this because
    it would not be very useful to simply eliminate songs that are unique to one list
    or the other. This method will instead be used for informational purposes by other
    functions within the overall application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`FindSharedSongsInPlaylist(HashSet<Song> playlist)` 方法为我们这个类提供了 *交集* 功能。同样，`HashSet<T>`
    方便地提供了 `IntersectWith(HashSet<T>)` 方法，我们这个方法正是利用了它。请注意，这个方法不会修改我们的列表，而是返回我们的列表和
    `playlist` 参数的实际交集。我们这样做是因为仅仅消除列表中独特歌曲并不是很有用。这个方法将用于整体应用程序中的其他功能的信息目的。
- en: 'Since we are not modifying the existing list but only returning information
    about the intersection, our method first makes a copy of the `_songs` set using
    the overloaded `HashSet<T>` object. Then, our method modifies the copied list
    and returns the result of the intersection operation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不是修改现有的列表，而是只返回关于交集的信息，我们的方法首先使用重载的 `HashSet<T>` 对象复制 `_songs` 集合。然后，我们的方法修改复制的列表，并返回交集操作的结果：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `FindUniqueSongs(HashSet<Song> playlist)` method provides the *difference*
    functionality to our class and works under a methodology that is very similar
    to the previous method. Again, this method does not modify our existing set in
    place but returns the results of the `ExceptWith()` operation on the copied set
    and the `playlist` parameter:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindUniqueSongs(HashSet<Song> playlist)` 方法为我们这个类提供了 *差集* 功能，并且其工作方法与上一个方法非常相似。同样，这个方法不会修改我们现有的集合，而是返回对复制的集合和
    `playlist` 参数的 `ExceptWith()` 操作的结果：'
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `IsSubset(HashSet<Song> playlist)` and `IsSuperset(HashSet<Song> playlist)`
    methods provide the functionalities implied by their names. These methods utilize
    the `HashSet<T>.IsSubSetOf(HashSet<T>)` and `HashSet<T>.IsSuperSetOf(HashSet<T>)`
    methods, respectively and return a Boolean value representing the result of those
    comparisons:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsSubset(HashSet<Song> playlist)` 和 `IsSuperset(HashSet<Song> playlist)` 方法提供了它们名字所暗示的功能。这些方法分别利用
    `HashSet<T>.IsSubSetOf(HashSet<T>)` 和 `HashSet<T>.IsSuperSetOf(HashSet<T>)` 方法，并返回一个表示这些比较结果的布尔值：'
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, the `TotalSongs()` method returns the number of elements found in the
    `_songs` set, providing *count* functionality to our collection.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`TotalSongs()` 方法返回 `_songs` 集合中找到的元素数量，为我们这个集合提供了 *计数* 功能。
- en: '**Java**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'Java provides the generic collection `HashSet<E>` that implements the `Set<E>`
    interface. This class provides all of the basic operations we would expect to
    see in a concrete set implementation with the added benefit of generic type casting:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了实现 `Set<E>` 接口的泛型集合 `HashSet<E>`。这个类提供了我们在具体的集合实现中期望看到的所有基本操作，并增加了泛型类型转换的额外好处：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using `HashSet<E>`, we create one private field for our class called `_songs`.
    Our constructor instantiates this field, giving us the underlying data structure
    to build our `PlaylistSet` class on. We also create two public fields and two
    public accessors: `capacity`, `premiumUser`, `isEmpty()`, and `isFull()`. The
    `capacity` field stores the maximum numbers of songs non-premium users can store
    in their playlist, while `premiumUser` denotes whether this list belongs to a
    premium account or not. The `isEmpty()` and `isFull()` accessors allow our class
    to easily implement the two operations of the same name. These two accessors function
    exactly as their C# field counterparts. The `isEmpty()` method simply returns
    whether or not the count of the set is `0`. The `isFull()` method first checks
    whether this list belongs to a premium account.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `HashSet<E>`，我们为我们的类创建了一个名为 `_songs` 的私有字段。我们的构造函数实例化这个字段，为我们提供了构建 `PlaylistSet`
    类的基础数据结构。我们还创建了两个公共字段和两个公共访问器：`capacity`、`premiumUser`、`isEmpty()` 和 `isFull()`。`capacity`
    字段存储非高级用户可以在他们的播放列表中存储的最大歌曲数量，而 `premiumUser` 表示这个列表是否属于高级账户。`isEmpty()` 和 `isFull()`
    访问器允许我们的类轻松实现同名操作。这两个访问器的工作方式与它们的 C# 字段对应物完全相同。`isEmpty()` 方法简单地返回集合的计数是否为 `0`。`isFull()`
    方法首先检查这个列表是否属于高级账户。
- en: 'If `true`, the collection is never full as we allow premium users to store
    unlimited songs in their playlists. If this list does not belong to a premium
    account, our getter ensures that the current count of `_songs` has not exceeded
    `capacity` and returns that comparison:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是 `true`，则集合永远不会满，因为我们允许高级用户在他们的播放列表中存储无限数量的歌曲。如果这个列表不属于高级账户，我们的获取器确保 `_songs`
    的当前计数没有超过 `capacity`，并返回这个比较结果：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `addSong(Song song)` method provides *add* functionality to our class.
    This method first confirms that the collection is not full. If so, the method
    returns `false` as we cannot add any more songs to the list. Otherwise, the method
    returns the result of `HashSet<E>.add(E)`, which will return `true` if the song
    is added, and that too only if the song is not already in this playlist:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`addSong(Song song)` 方法为我们这个类提供了 *添加* 功能。这个方法首先确认集合没有满。如果是这样，方法返回 `false`，因为我们不能向列表中添加更多歌曲。否则，方法返回
    `HashSet<E>.add(E)` 的结果，如果歌曲被添加，并且只有在歌曲尚未存在于这个播放列表中时才会返回 `true`：'
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `removeSong(Song song)` method provides the *remove* functionality to our
    class. This method simply returns the result of `HashSet<E>.remove(E)`, which
    will return `true` if the song exists in the set; otherwise, it will return `false`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeSong(Song song)` 方法为我们这个类提供了 *删除* 功能。这个方法简单地返回 `HashSet<E>.remove(E)`
    的结果，如果歌曲存在于集合中，则返回 `true`；否则，返回 `false`。'
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `mergeWithPlaylist(HashSet<Song> playlist)` method provides *union* functionality
    for our class, and this is where our class begins to truly diverge from our previous
    C# example. `HashSet<E>` exposes the *union* functionality we''re looking for,
    but only by calling the `HashSet<E>.addAll(HashSet<E>)` method. This method accepts
    a set of `Song` objects as a parameter and attempts to add each one to our `_songs`
    collection. If the `Song` element being added already exists in the `_songs` set,
    that element will be discarded, leaving us with only unique `Song` objects from
    both lists or a union of the two sets:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`mergeWithPlaylist(HashSet<Song> playlist)` 方法为我们这个类提供了 *并集* 功能，这也是我们的类开始真正与之前的
    C# 示例不同的地方。`HashSet<E>` 提供了我们需要的 *并集* 功能，但只能通过调用 `HashSet<E>.addAll(HashSet<E>)`
    方法来实现。这个方法接受一个 `Song` 对象的集合作为参数，并尝试将每个对象添加到我们的 `_songs` 集合中。如果被添加的 `Song` 元素已经存在于
    `_songs` 集合中，该元素将被丢弃，只留下来自两个列表或两个集合的唯一的 `Song` 对象：'
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, the `findSharedSongsInplaylist(HashSet<Song> playlist)` method provides
    the *intersection* functionality to our class. Again, `HashSet<E>` exposes intersection
    functionality, but not directly. Our method uses the `HashSet<E>.retainAll(HashSet<E>)`
    method, which retains all of the elements in the `_songs` set, that also exist
    in the `playlist` parameter, or intersection of the two collections. As in our
    C# example, we are not modifying the `_songs` set in place but rather returning
    the intersection between a copy of `_songs` and the `playlist` parameter:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`findSharedSongsInplaylist(HashSet<Song> playlist)` 方法为我们这个类提供了 *交集* 功能。同样，`HashSet<E>`
    提供了交集功能，但不是直接提供。我们的方法使用 `HashSet<E>.retainAll(HashSet<E>)` 方法，该方法保留 `_songs` 集合中所有也存在于
    `playlist` 参数中的元素，或者两个集合的交集。正如我们的 C# 示例一样，我们并没有在原地修改 `_songs` 集合，而是返回 `_songs`
    的一个副本和 `playlist` 参数之间的交集：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `findUniqueSongs(HashSet<Song> playlist)` method provides the *difference*
    functionality to our class. Once again, `HashSet<E>` exposes the difference functionality,
    but through the `removeAll(HashSet<E>)` method. The `removeAll()` method removes
    all of the `_songs` elements that are also contained in the playlist parameter
    or the difference between the two collections. Again, this method does not modify
    our existing set in place but returns the results of the `removeAll()` method,
    or difference operation, on the `_songs` copy and the `playlist` parameter:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`findUniqueSongs(HashSet<Song> playlist)` 方法为我们提供的类提供 *差异* 功能。再次，`HashSet<E>`
    揭示了差异功能，但通过 `removeAll(HashSet<E>)` 方法。`removeAll()` 方法移除所有在播放列表参数或两个集合之间的差异中包含的
    `_songs` 元素。同样，此方法不会修改我们现有的集合，而是返回 `_songs` 复制和 `playlist` 参数上的 `removeAll()`
    方法或差异操作的结果：'
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `isSubset(HashSet<Song> playlist)` and `isSuperset(HashSet<Song> playlist)`
    methods provide the functionality of the same names. These methods both utilize
    the `HashSet<E>.containsAll(HashSet<E>)` method and return a Boolean value representing
    the result of those comparisons. Our methods simply swap the source set and the
    parameter to obtain the desired comparison since `HashSet<E>` does not provide
    a specific comparator for each function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`isSubset(HashSet<Song> playlist)` 和 `isSuperset(HashSet<Song> playlist)` 方法提供了同名功能。这两个方法都利用了
    `HashSet<E>.containsAll(HashSet<E>)` 方法，并返回一个布尔值，表示这些比较的结果。我们的方法只是交换源集合和参数以获得所需的比较，因为
    `HashSet<E>` 没有为每个函数提供特定的比较器：'
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, the `totalSongs()` method returns the number of elements found in the
    `_songs` set using the collection's `size()` method, providing the *count* functionality
    to our collection.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`totalSongs()` 方法使用集合的 `size()` 方法返回 `_songs` 集合中找到的元素数量，为我们提供的集合提供 *计数*
    功能。
- en: '**Objective-C**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'Objective-C provides the `NSSet` and `NSMutableSet` class clusters as the concrete
    implementations of the set data structure. These class clusters provide most of
    the functionality we would expect to see in a set data structure, and the explicit
    functions that are missing are very simple to implement, which makes the Objective-C
    implementation fairly straightforward:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 提供了 `NSSet` 和 `NSMutableSet` 类簇作为集合数据结构的具体实现。这些类簇提供了我们在集合数据结构中预期看到的大部分功能，并且缺少的显式函数非常简单易实现，这使得
    Objective-C 的实现相当直接：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using `NSMutableSet`, we create one private ivar for our class called `_songs`.
    Our initializer instantiates this field, giving us the underlying data structure
    to build our `EDSPlaylistSet` class on. We also create four public properties:
    `capacity`, `premiumUser`, `isEmpty`, and `isFull` in our header file, backed
    by private ivars of the same name. The `capacity` property stores the maximum
    numbers of songs non-premium users can store in their playlist, while `premiumUser`
    denotes if this list belongs to a premium account or not. The `isEmpty` and `isFull`
    properties allow our class to easily implement the two operations of the same
    name. The `isEmpty` property simply returns whether or not the count of the set
    is `0`, while the `isFull` property first checks whether this list belongs to
    a premium account. If `true`, the collection is never full as we allow premium
    users to store unlimited songs in their playlists. If this list does not belong
    to a premium account, our method ensures that the current count of `_songs` has
    not exceeded the capacity and returns that comparison:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NSMutableSet`，我们为我们的类创建了一个名为 `_songs` 的私有 ivar。我们的初始化器实例化了这个字段，为我们提供了构建
    `EDSPlaylistSet` 类的基础数据结构。我们还在头文件中创建了四个公共属性：`capacity`、`premiumUser`、`isEmpty`
    和 `isFull`，这些属性由同名的私有 ivar 支持。`capacity` 属性存储非高级用户可以在他们的播放列表中存储的最大歌曲数量，而 `premiumUser`
    表示此列表是否属于高级账户。`isEmpty` 和 `isFull` 属性允许我们的类轻松实现同名操作。`isEmpty` 属性简单地返回集合的计数是否为
    `0`，而 `isFull` 属性首先检查此列表是否属于高级账户。如果是 `true`，则集合永远不会满，因为我们允许高级用户在他们的播放列表中存储无限数量的歌曲。如果此列表不属于高级账户，我们的方法确保
    `_songs` 的当前计数没有超过容量，并返回该比较的结果：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `addSong:` method provides *add* functionality to our class. This method
    first confirms that the collection is not full and then confirms that the object
    is actually contained in the `_songs` collection. If the collection does not pass
    both tests, the method returns `NO`, as we cannot add any more songs to the list
    or the song already exists in the collection. Otherwise, the method calls `addObject:`
    and returns `YES`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`addSong:` 方法为我们类提供 *添加* 功能。此方法首先确认集合未满，然后确认对象实际上包含在 `_songs` 集合中。如果集合未通过这两个测试，则方法返回
    `NO`，因为我们不能向列表添加更多歌曲或歌曲已存在于集合中。否则，方法调用 `addObject:` 并返回 `YES`：'
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `removeSong:` method provides *remove* functionality to our class. This
    method confirms that the song exists in the collection, then removes the song
    using `removeObject:`, and finally returns `YES`. If the song does not exist in
    the collection, the method returns `NO`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeSong:` 方法为我们类提供 *移除* 功能。此方法确认歌曲存在于集合中，然后使用 `removeObject:` 移除歌曲，并最终返回
    `YES`。如果歌曲不在集合中，则方法返回 `NO`：'
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `mergeWithPlaylist:` method provides *union* functionality for our class.
    Luckily, `NSSet` exposes the union functionality with the `unionSet:` method,
    so our method simply calls it. In this case, `unionSet:` will merge the `playlist`
    parameter with our existing `_songs` list:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`mergeWithPlaylist:` 方法为我们类提供 *并集* 功能。幸运的是，`NSSet` 通过 `unionSet:` 方法公开了并集功能，因此我们的方法只需简单地调用它。在这种情况下，`unionSet:`
    将将 `playlist` 参数与我们的现有 `_songs` 列表合并：'
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, the `findSharedSongsInplaylist:` method provides *intersection* functionality
    to our class. Again, `NSSet` exposes the intersection functionality through the
    `intersectSet:` method. As in our C# example, we are not modifying the `_songs`
    set in place but rather returning the intersection between a copy of `_songs`
    and the `playlist` parameter:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`findSharedSongsInplaylist:` 方法为我们类提供 *交集* 功能。同样，`NSSet` 通过 `intersectSet:`
    方法公开了交集功能。正如我们的 C# 示例一样，我们不是在原地修改 `_songs` 集合，而是在 `_songs` 复制和 `playlist` 参数之间返回交集：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `findUniqueSongs:` method provides the *difference* functionality to our
    class. Once again, `NSSet` exposes the difference functionality through the `minusSet:`
    method. And again, this method does not modify our existing set in place but returns
    the results of the `minusSet:`, or difference, operation on the `_songs` copy
    and the `playlist` parameter:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`findUniqueSongs:` 方法为我们类提供 *差集* 功能。再次，`NSSet` 通过 `minusSet:` 方法公开了差集功能。同样，此方法不会修改我们现有的集合，而是返回
    `_songs` 复制和 `playlist` 参数上的 `minusSet:` 或差集操作的结果：'
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `isSubset:` and `isSuperset:` methods provide the functionalities by their names.
    These methods utilize the `isSubsetOfSet:` method on `NSSet` in much the same
    way that our Java example utilizes the `containsAll(HashSet<E>)` method of the
    `Set<E>` interface:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`isSubset:` 和 `isSuperset:` 方法通过其名称提供功能。这些方法以与我们的 Java 示例使用 `Set<E>` 接口的 `containsAll(HashSet<E>)`
    方法类似的方式，利用 `NSSet` 上的 `isSubsetOfSet:` 方法：'
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finally, the `totalSongs` method returns the number of elements found in the
    `_songs` set, providing *count* functionality to our collection.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`totalSongs` 方法返回 `_songs` 集合中找到的元素数量，为我们集合提供 *计数* 功能。
- en: '**Swift**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Swift provides the `Set` class as a concrete implementation of the set data
    structure. This class provides all of the functionality we would expect to see
    in a set data structure, even more so than its Objective-C counterpart, which
    makes the Swift implementation very clean:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了 `Set` 类作为集合数据结构的具体实现。此类提供了我们在集合数据结构中预期看到的所有功能，甚至比其 Objective-C 对应物还要多，这使得
    Swift 实现非常简洁：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Using `Set`, we create one private ivar for our class called `_songs` and initialize
    it inline with its declaration, giving us the underlying data structure to build
    our `PlaylistSet` class on. We also create four public fields, `_capacity`, `_premiumUser`,
    `_isEmpty`, and `_isFull`, as well as public accessors for the last three. The
    `capacity` field stores the maximum number of songs non-premium users can store
    in their playlist while `premiumUser` denotes whether this list belongs to a premium
    account or not. The `isEmpty` and `isFull` fields allow our class to easily implement
    the two operations of the same name. The `isEmpty()` field simply returns whether
    or not the count of the set is `0`. The `isFull()` field first checks if this
    list belongs to a premium account. If `true`, the collection is never full as
    we allow premium users to store unlimited songs in their playlists. If this list
    does not belong to a premium account, our getter ensures that the current count
    of `_songs` has not exceeded `capacity` and returns that comparison:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Set`，我们为我们的类创建了一个私有实例变量 `_songs`，并在其声明时直接初始化，这为我们构建 `PlaylistSet` 类提供了底层的数据结构。我们还创建了四个公共字段：`_capacity`、`_premiumUser`、`_isEmpty`
    和 `_isFull`，以及后三个字段的公共访问器。`capacity` 字段存储非高级用户可以在他们的播放列表中存储的最大歌曲数量，而 `premiumUser`
    表示此列表是否属于高级账户。`isEmpty` 和 `isFull` 字段允许我们的类轻松实现同名操作。`isEmpty()` 字段简单地返回集合的计数是否为
    `0`。`isFull()` 字段首先检查此列表是否属于高级账户。如果是 `true`，则集合永远不会满，因为我们允许高级用户在他们的播放列表中存储无限数量的歌曲。如果此列表不属于高级账户，我们的获取器将确保
    `_songs` 的当前计数没有超过 `capacity`，并返回这个比较结果：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `addSong(song: Song)` method provides *add* functionality to our class.
    This method first confirms that the collection is not full and then confirms that
    the object is actually contained in the `_songs` collection. If the collection
    does not pass both tests, the method returns `false`, as we cannot add any more
    songs to the list or the song already exists in the collection. Otherwise, the
    method calls `insert()` and returns `true`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`addSong(song: Song)` 方法为我们类提供了 **add** 功能。此方法首先确认集合不为满，然后确认对象实际上包含在 `_songs`
    集合中。如果集合未通过这两个测试，则方法返回 `false`，因为我们不能向列表中添加更多歌曲或歌曲已存在于集合中。否则，方法调用 `insert()` 并返回
    `true`：'
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `removeSong(song: Song)` method provides *remove* functionality to our
    class. This method confirms that the song exists in the collection, then removes
    the song using `remove()`, and finally returns `true`. If the song does not exist
    in the collection, the method returns `false`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeSong(song: Song)` 方法为我们类提供了 **remove** 功能。此方法确认歌曲存在于集合中，然后使用 `remove()`
    删除歌曲，并最终返回 `true`。如果歌曲不存在于集合中，则方法返回 `false`：'
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `mergeWithPlaylist(playlist: Set<Song>)` method provides the *union* functionality
    for our class. Luckily, `Set` exposes the union functionality with the `unionInPlace()`
    method, so our method simply calls it. In this case, `unionInPlace()` will merge
    the `playlist` parameter with our existing `_songs` list:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`mergeWithPlaylist(playlist: Set<Song>)` 方法为我们类提供了 **union** 功能。幸运的是，`Set`
    通过 `unionInPlace()` 方法暴露了并集功能，因此我们的方法只需调用它。在这种情况下，`unionInPlace()` 将将 `playlist`
    参数与我们的现有 `_songs` 列表合并：'
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, the `findSharedSongsInplaylist(playlist: Set<Song>)` method provides *intersection*
    functionality to our class. The `Set` class exposes the intersection functionality
    using the `intersect()` method. The `intersect()` method does not modify `_songs`,
    but only returns the results of the intersection between `_songs` and the `playlist`
    parameter, so we simply return the results of this method call:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，`findSharedSongsInplaylist(playlist: Set<Song>)` 方法为我们类提供了 **intersection**
    功能。`Set` 类通过 `intersect()` 方法暴露了交集功能。`intersect()` 方法不会修改 `_songs`，但只返回 `_songs`
    和 `playlist` 参数之间的交集结果，因此我们只需返回这个方法调用的结果：'
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `findUniqueSongs(playlist: Set<Song>)` method provides *difference* functionality
    to our class. Once again, `Set` exposes the difference functionality using the
    `subtract()` method. The `subtract()` method does not modify `_songs`, but only
    returns the results of the difference between `_songs` and the `playlist` parameter,
    so we simply return the results of this method call:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`findUniqueSongs(playlist: Set<Song>)` 方法为我们类提供了 **difference** 功能。再次强调，`Set`
    通过 `subtract()` 方法暴露了差集功能。`subtract()` 方法不会修改 `_songs`，但只返回 `_songs` 和 `playlist`
    参数之间的差集结果，因此我们只需返回这个方法调用的结果：'
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `isSubset(playlist: Set<Song>)` and `isSuperset(playlist: Set<Song>)` methods
    provide the functionalities by their names. These methods utilize the `isSubSetOf()`
    and `isSuperSetOf()` methods, respectively, and return a Boolean value representing
    the result of those comparisons:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`isSubset(playlist: Set<Song>)` 和 `isSuperset(playlist: Set<Song>)` 方法通过其名称提供功能。这些方法分别利用
    `isSubSetOf()` 和 `isSuperSetOf()` 方法，并返回一个表示这些比较结果的布尔值：'
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, the `totalSongs()` method returns the number of elements found in the
    `_songs` set, providing *count* functionality to our collection.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`totalSongs()` 方法返回在 `_songs` 集合中找到的元素数量，为我们集合提供 *计数* 功能。
- en: Advanced topics
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级主题
- en: 'Now that we have examined how sets are used in common applications, we should
    take some time to examine how they are implemented under the hood. The majority
    of sets come in three varieties: hash table-based sets, tree-based sets, and array-based
    sets.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经考察了集合在常见应用中的使用方式，我们应该花些时间来考察它们在底层是如何实现的。大多数集合有三种类型：基于哈希表的集合、基于树的集合和基于数组的集合。
- en: Hash table-based sets
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于哈希表的集合
- en: Hash table-based sets are typically used for unordered collections of data.
    As such, the majority of sets you will encounter for non-specialized applications
    will be hash table-based. Hash table-based sets share similar operational costs
    with dictionaries. For example, search, insert, and delete operations all have
    an operational cost of **O**(*n*).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 基于哈希表的集合通常用于无序数据集合。因此，对于非专业应用，你将遇到的绝大多数集合将是基于哈希表的。基于哈希表的集合与字典具有相似的操作成本。例如，搜索、插入和删除操作的操作成本都是
    **O**(*n*)。
- en: Tree-based sets
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于树的集合
- en: Tree-based sets are typically based on binary search trees, but they sometimes
    can be based on other structures. Due to their design, the binary search tree
    allows for very efficient search functions on average, as each node that is examined
    can allow for branches of the tree to be discarded from the remaining search pattern.
    Although the worst case scenario for searching a binary search tree has an **O**(*n*)
    operational cost, in practice this is rarely required.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 基于树的集合通常基于二叉搜索树，但有时也可以基于其他结构。由于它们的设计，二叉搜索树允许在平均情况下非常高效的搜索功能，因为每个被检查的节点都可以允许从剩余的搜索模式中丢弃树的分支。尽管搜索二叉搜索树的最坏情况下的操作成本是
    **O**(*n*)，但在实践中这很少需要。
- en: Array-based sets
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于数组的集合
- en: Arrays can be used to implement subsets of sets, making union, intersection,
    and difference operations much more efficient in properly organized array-based
    sets.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以用来实现集合的子集，这使得在正确组织的基于数组的集合中进行并集、交集和差集操作变得更加高效。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the basic definition of the set data structure.
    In order to fully appreciate the functionality of the structure, we briefly examined
    the most basic principles of set theory upon which the set data structure is based.
    Following this, we looked at the most common operations of sets and how they relate
    to the set theory functions. We then looked at how to implement a set in each
    of the four languages we're studying in this text. Next, we revisited the users
    logged into a service problem one more time to see if we could improve upon its implementation
    at all using a set data structure as opposed to an array or list. Following this,
    we examined a case study where sets would be beneficial. Finally, we looked at
    the varying implementations of sets, including hash table-based sets, tree-based
    sets, and array-based sets.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了集合数据结构的基本定义。为了充分欣赏该结构的功能，我们简要地考察了集合数据结构所基于的集合论的基本原则。随后，我们探讨了集合的常见操作以及它们与集合论函数的关系。然后，我们研究了如何在文本中研究的四种语言中实现集合。接下来，我们再次审视了登录到服务的用户问题，看看我们能否使用集合数据结构而不是数组或列表来改进其实施。在此之后，我们考察了一个案例研究，其中集合将是有益的。最后，我们研究了集合的不同实现方式，包括基于哈希表的集合、基于树的集合和基于数组的集合。
