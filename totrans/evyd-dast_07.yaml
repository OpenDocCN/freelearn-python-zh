- en: 'Chapter 7. Sets: No Duplicates'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within the confines of computer science, **sets** are typically used as a simple
    collection of objects that contain no duplicates. In the broader realm of mathematics
    in general, however, a set is an abstract data structure that can be described
    as a collection of distinct objects or values stored in no particular order. For
    the purpose of this discussion, we will choose to view a set as the computer implementation
    of a mathematically finite set.
  prefs: []
  type: TYPE_NORMAL
- en: When working with problems to which the mathematical concepts of set theory
    can be applied, set data structures provide a powerful group of tools for combining
    and examining relationships between collections of similar objects. However, even
    outside set theory and mathematics, the set data structure provides functionality
    that can be useful in everyday applications. For example, since a set naturally
    eliminates duplicates, any application that requires maintaining or editing a
    collection of unique elements would benefit from storing objects in a set data
    structure. Similarly, if you need to eliminate duplicates from an existing collection,
    most implementations of the set data structure will allow you to create a new
    set from a collection of arrays; and in doing so, you will filter out duplicates
    automatically. Overall, sets are a relatively simple data structure, which provide
    tremendous functionality and power in analyzing collections of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Definition of the set data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common set operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revisiting the users logged in to a service problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case study - music playlists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash table-based sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tree-based sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array-based sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of a set is relatively simple, but in practice a concrete implementation
    can be somewhat difficult to understand due to its mathematical origins. Therefore,
    in order to fully appreciate the set data structure, it becomes necessary to examine
    some of the characteristics and functions of **set theory** upon which the set
    data structure is built. Set theory is a branch of mathematics that studies collections,
    or *sets*, of objects. Although set theory is a major area of research in mathematics
    with many interrelated sub-fields, we really only need to examine five functions
    for combining and relating sets to one another to understand the set data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Union**: A union is one of the fundamental methods of combining and relating
    sets to one another. A union of a series of *n* sets is the set of only those
    distinct elements contained in those sets. This means that, if you combine sets
    *A* and *B*, the resulting set will only contain unique elements from set *A*
    and *B*. If an element exists in both *A* and *B*, it will only appear once in
    our result set. We use the notation *A* ∪ *B* to denote the *union* of sets *A*
    and *B*. The following Venn diagram represents the union of two sets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Set theory](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Intersection**: An intersection is the second fundamental method of combining
    and relating sets to one another. An intersection of a collection of *n* sets
    is the set of elements that exist in each of the sets being evaluated. So if we
    examine sets *A* and *B* for an intersection, our resulting set will only include
    those elements that exist in both *A* and *B*. Any elements that are unique to
    *A* or *B* will be discarded. We use the notation *A* ∩ *B* to denote the *intersection*
    of set *A* with set *B*. The following Venn diagram represents the intersection
    of two sets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Set theory](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Difference**: The difference operation is the opposite of the intersection
    operation. The difference of a collection of *n* sets is the set of elements that
    are unique to each set being evaluated. If we examine sets *A* and *B* for a difference,
    our resulting set will only include those elements that exist in either *A* or
    *B*. Any elements that are part of the intersection of *A* and *B* will be discarded.
    We use the notation *A* Δ *B* to denote the *difference* between sets *A* and
    *B*. The following Venn diagram represents the difference of two sets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Set theory](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Compliment**: The compliment, or the **relative compliment**, of *A* in *B*
    is the set of elements that are found in *B* but not found in *A*. If we examine
    sets *A* and *B* for a compliment, only those elements that are unique to *B*
    will be included in our result set. Any elements that are unique to *A* or are
    part of the intersection of *A* and *B* will be discarded. We use the notation
    *B\**A *to denote the relative compliment of set *A* with respect to set *B*. The
    following Venn diagram represents the compliment of two sets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Set theory](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Subset**: The subset is the final fundamental method of combining and relating
    sets to one another. The subset operation determines if set *A* is a subset of
    set *B*, or rather if set *B* is a **superset** of set *A*. This relationship
    of one set being a subset of another is called an **inclusion**, or a **containment** when
    considering one set is a superset of another set. In the next figure, we can say
    that *A* is the subset of *B* or *B* is the superset of *A*. We use the notation
    *A* ⊂ *B* to denote that set *A* is an inclusion of set *B*, or *B ⊃*  *A* to
    denote that set *B* is the containment of set *A*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Set theory](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Initializing sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sets are not terribly commonplace in development, but each of the languages
    we are examining supports data structures with some form of concrete implementations.
    Here are some examples of initializing a set, adding a few values to the collection
    including one duplicate, and printing the set's count to the console after each
    step.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: 'C# provides a concrete implementation of the set data structure through the
    `HashSet<T>` class. Since this class is generic, the caller may define the type
    used for elements. For example, the following example initializes a new set where
    the elements will be `string` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java provides a `HashSet<E>` class as well as other classes that implement
    the `Set<E>` interface. In this chapter, we''ll look at an example of the `HashSet<E>`
    class only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objective-C provides immutable as well as mutable set classes, `NSSet` and
    `NSMutableSet`. In this chapter, we will only be examining the mutable version
    in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets in Swift are created using the `Set` class. Swift sets are mutable when
    initialized as **variables** using `var`, but they can also be created as immutable
    by initializing them as **constants** using `let`. In this chapter, we will only
    be examining the mutable version in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Set operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not all concrete implementations of the set data structures expose the same
    operational methods. However, the more common operations should be available or
    can be made available as needed by the developer. As you examine these operations,
    note how the language is similar to the language of set theory operations discussed
    earlier. You will find that most of the set data structure functionality will
    closely mirror that of set theory in general:'
  prefs: []
  type: TYPE_NORMAL
- en: '**add**: The add operation, sometimes referred to as an insert, introduces
    a new object into the collection if that object does not already exist in the
    collection. This functionality, which prevents duplicate objects from being added
    to the collection, is one of the core advantages of using a set over many other
    data structures. Most implementations of the set data structure will return a
    Boolean value denoting whether or not the element could be added to the collection.
    Add operations have an **O**(*n*) cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**remove**: The remove, or delete, operation allows the caller to remove a
    value or object from the collection if it exists. Most implementations of the
    set data structure return a Boolean value denoting whether or not the remove operation
    was successful. Remove operations have an **O**(*n*) cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**capacity**: The capacity operation returns the maximum number of values the
    set can hold. This is not an operation that developers will naturally see in the
    four languages we are discussing as each of the mutable sets found in these languages
    can dynamically resize on demand. However, some implementations do permit the
    set to be limited in size as part of its definition. Capacity has an **O**(1)
    operational cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**union**: The union operation returns a new set containing the unique elements
    of two or more sets. Therefore, this operation has a worst-case cost of **O**(*n*+*m*),
    where *n* is the size of the first set and *m* is the size of the second set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**intersection**: The intersection operation returns only those elements that
    are shared between two or more sets. This means that, if you supply the method
    with two sets, you will only get back those elements that already exist in both
    sets. Intersection carries an **O**(*n***m*), where *n* is the size of the first
    set and *m* is the size of the second set. Interestingly, if you attempt to perform
    an intersection on a series of three or more sets, the cost becomes *(n-1) ** **O**(*L*),
    where *n* is the number of *sets* involved in the operation and *L* is the size
    of the largest set in the series. Obviously, this cost is quite high and using
    this operation on multiple sets simultaneously could get out of hand very quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**difference**: The difference operation is the opposite of the intersection
    operation, returning only those elements that are unique to each set. This operation
    has an operational cost of **O**(*m*), where *m* is the length of the shorter
    of the two sets being evaluated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**subset**: The subset operation returns a Boolean value determining whether
    set *A* is a subset of set *B*. For set *A* to be considered a subset of set *B*,
    every element within set *A* must also be included in set *B*. If only a portion
    of the elements of set *A* are contained in set *B*, then sets *A* and *B* share
    an intersection, but *A* is not a subset of *B*. This operation has an operational
    cost of **O**(*m*), where *m* is the length of set *A*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**count**: The count, or size, operation represents the *cardinality* of a
    particular set, which is really just the set theory way of saying the number of
    elements in the set. Count is typically a simple property on the collection and,
    therefore, has an **O**(*1*) cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**isEmpty**: The isEmpty operation returns a Boolean value representing whether
    the set contains any elements at all. Some implementations provide a corresponding
    `isFull` operation, but only for those instances where the set capacity can be
    limited to a specific value. Both `isEmpty` and `isFull` have an **O**(*1*) cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: revisiting users logged in to a service'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s revisit the users logged into a service problem from [Chapter 2](part0019_split_000.html#I3QM2-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 2.  Arrays: Foundational Collections"), *Arrays: Foundational Collection*, one
    more time and examine how the code will be changed if we had chosen a set as the
    underlying data structure rather than an array or list.'
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have replaced the `List<User>` object with a `HashSet<User>`
    object. The majority of our code is unchanged, but you should note the exclusion
    of the `CanAddUser(User)` method. Originally, this method validated the *authenticated
    user* action by ensuring that the collection had room for another object and then
    ensuring that the object to be added was not already included in the collection.
    A set data structure eliminates the need for the second step as it intrinsically
    prevents duplicate objects from being added. Since the only validation our class
    now requires is a capacity check, we can handle that inline with the `UserAuthenticated(User)`
    functionality. As an added bonus, we can now easily report whether or not the
    user was successfully added, as `HashSet<T>.Add(T)` returns `true` for success,
    and `false` when the object already exists in the set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changes in our Java example almost mirror those of our C# example. Again, we
    have replaced the `List<User>` object with a `HashSet<User>` object. The majority
    of our code is unchanged, except for the exclusion of the `canAddUser(User)` method.
    In Java, the `HashSet<E>` class implements the `Set<E>` interface and is based
    on a set data structure, which eliminates the need for checking whether an object
    exists in the collection before adding it. Since the only validation our class
    now requires is a capacity check, we can handle that inline with the `userAuthenticated(User)`
    functionality. Again, we can now easily report whether or not the user was successfully
    added, as `HashSet<E>.add(E)` returns `true` for success, and `false` when the
    object already exists in the set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: Changes to our Objective-C example yield some interesting results. Although
    we are exchanging the `NSMutableArray` collection for an `NSMutableSet` collection,
    the majority of our code remains the same, including the fact that we are not
    going to return a `BOOL` representing the success or failure of our `addObject:`
    operation. This is because `addObject:` does not return a value; if we were to
    include it in `userAuthenticated:`, we would have to resort to calling the `containsObject:`
    method prior to calling `addObject:` on our set collection. Since the entire point
    of this exercise is to use a set to eliminate the need to check for duplicates
    before adding new objects, to re-introduce this functionality would defeat the
    purpose and potentially put us in a more costly position than if we simply stuck
    with an array or list.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not to say that there are no valid applications that could benefit
    from a set as well as a report on the success or failure of an `addObject:` operation;
    this is just not one of those cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The outcome of our Swift example is almost exactly like that of our Objective-C
    example. Again, we are replacing our array with a set, but sets in Swift function
    much like they do in Objective-C. Therefore, our final code is more abbreviated
    but does not immediately provide the same functionality as our C# and Java implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We would need a contract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look carefully at each of the three solutions to the logged in user business
    problem, you will probably notice they all share common public methods. In our
    array implementation, list implementation, and set implementation, we have two
    public methods named `UserAuthenticated()` and `UserLoggedOut()`, or some variation
    of these names depending on the language. This would not be an issue if we were
    to just choose one implementation that best suits our needs and move on. However,
    what if there were justifiable reasons to keep each one of these classes in our
    solution to efficiently work within specific environmental conditions?
  prefs: []
  type: TYPE_NORMAL
- en: In actuality, it is very common to see multiple classes that share the same
    public-facing methods but have uniquely implemented functionality under the hood.
    If we were to simply create three (or more) separate implementations that are
    completely independent of one another, our application would have a resulting
    *code smell*. That's because, whenever we want to use a specific implementation,
    we will need to call for it by name, which requires some advance knowledge of
    which classes and implementations are available. Plus, although our code might
    work just fine, it will be fragile, inextensible, and more difficult to maintain
    in the long term.
  prefs: []
  type: TYPE_NORMAL
- en: A better solution would involve defining a contract that each class implements.
    In C# or Java, we would define an interface, while in Objective-C and Swift, we
    would define a protocol. The difference between these two patterns is mostly semantics,
    as they will both provide our caller with the names of the methods, what the methods
    expect, and what the methods will return. What is important is that by doing this,
    we greatly simplify and harden our implementation of both the functionality and
    the calling class structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case-study: music playlists'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Business problem**: A music streaming service wants to provide their users
    with a better streaming experience. Currently, user playlists are a simple collection
    of songs dumped into a bucket that provides no means of filtering or ordering
    the collection. The content management team has heard the complaints of their
    users and has tasked the engineering team with building a better playlist.'
  prefs: []
  type: TYPE_NORMAL
- en: This new playlist tool will have several key requirements. The more basic requirements
    include the ability to add and remove songs from the list, the ability to differentiate
    between an empty list and a list with elements, as well the ability to report
    on the total count of elements in the list. For those customers who are not interested
    in paying for the premium service, the lists will be limited to a 100 songs so
    our playlist tool must also have the ability to set a capacity and easily identify
    when the capacity has been met.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, many premium users are known to have thousands of songs in their
    playlist, as well as multiple themed playlists for everything from riding their
    bike to doing the laundry. For these users the playlist tool must include some
    advanced analysis and editing features. First, there must be a way to easily consolidate
    playlists and, since we don't want to have songs that exist in both playlists
    to appear twice, this consolidation must prevent duplicates. Next, the playlist
    should be able to easily identify songs that are duplicated between two lists
    as well as identify songs that are unique to specific lists. Finally, some users
    will want to know more information about their collection of playlists, such as
    whether one playlist exists as part of another playlist. Based on these requirements,
    the developer decides that a set will be the most efficient way to represent the
    playlists, so the core class's functionality will be based on that data structure.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: 'C# provides the generic collection `HashSet<T>`. This class provides all of
    the basic operations we would expect to see in a concrete set implementation with
    the added benefit of generic type casting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `HashSet<T>` interface, we create one private field for our class
    called `_songs`. Our constructor instantiates this field, giving us the underlying
    data structure to build our `PlaylistSet` class on. We also create four public
    fields: `capacity`, `premiumUser`, `isEmpty`, and `isFull`. The `capacity` field
    stores the maximum numbers of songs non-premium users can store in their playlist,
    while `premiumUser` denotes whether this list belongs to a premium account or
    not. The `isEmpty` and `isFull` fields allow our class to easily implement the
    two operations of the same name. The `isEmpty` field simply returns whether or
    not the count of the set is `0`. The `isFull` field first checks whether this
    list belongs to a premium account. If `true`, the collection is never full as
    we allow premium users to store unlimited songs in their playlists. If this list
    does not belong to a premium account, our getter ensures that the current count
    of `_songs` has not exceeded the capacity and returns that comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `AddSong(Song song)` method provides the *add* functionality to our class.
    This method first confirms that the collection is not full. If this is so, the
    method returns `false` as we cannot add any more songs to the list. Otherwise,
    the method returns the result of `HashSet<T>.Add(T)` which returns `true` if `song`
    is added, meaning the song was not already in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RemoveSong(Song song)` method provides *remove* functionality to our class.
    This method simply returns the result of `HashSet<T>.Remove(T)`, which will return
    `true` if the song exists in the list; otherwise, it will return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MergeWithPlaylist(HashSet<Song> playlist)` method provides the *union*
    functionality for our class. Luckily, `HashSet<T>` exposes the union functionality
    with the `Union(HashSet<T>)` method, so our method simply calls it. In this case,
    `Union()` will merge the `playlist` parameter with our existing `_songs` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Next, the `FindSharedSongsInPlaylist(HashSet<Song> playlist)` method provides
    the *intersection* functionality to our class. Again, `HashSet<T>` conveniently
    provides the `IntersectWith(HashSet<T>)` method, which our method takes advantage
    of. Note that this method does not modify our list in-place, but rather returns
    the actual intersection of our list and the `playlist` parameter. We do this because
    it would not be very useful to simply eliminate songs that are unique to one list
    or the other. This method will instead be used for informational purposes by other
    functions within the overall application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are not modifying the existing list but only returning information
    about the intersection, our method first makes a copy of the `_songs` set using
    the overloaded `HashSet<T>` object. Then, our method modifies the copied list
    and returns the result of the intersection operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FindUniqueSongs(HashSet<Song> playlist)` method provides the *difference*
    functionality to our class and works under a methodology that is very similar
    to the previous method. Again, this method does not modify our existing set in
    place but returns the results of the `ExceptWith()` operation on the copied set
    and the `playlist` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IsSubset(HashSet<Song> playlist)` and `IsSuperset(HashSet<Song> playlist)`
    methods provide the functionalities implied by their names. These methods utilize
    the `HashSet<T>.IsSubSetOf(HashSet<T>)` and `HashSet<T>.IsSuperSetOf(HashSet<T>)`
    methods, respectively and return a Boolean value representing the result of those
    comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `TotalSongs()` method returns the number of elements found in the
    `_songs` set, providing *count* functionality to our collection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java provides the generic collection `HashSet<E>` that implements the `Set<E>`
    interface. This class provides all of the basic operations we would expect to
    see in a concrete set implementation with the added benefit of generic type casting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `HashSet<E>`, we create one private field for our class called `_songs`.
    Our constructor instantiates this field, giving us the underlying data structure
    to build our `PlaylistSet` class on. We also create two public fields and two
    public accessors: `capacity`, `premiumUser`, `isEmpty()`, and `isFull()`. The
    `capacity` field stores the maximum numbers of songs non-premium users can store
    in their playlist, while `premiumUser` denotes whether this list belongs to a
    premium account or not. The `isEmpty()` and `isFull()` accessors allow our class
    to easily implement the two operations of the same name. These two accessors function
    exactly as their C# field counterparts. The `isEmpty()` method simply returns
    whether or not the count of the set is `0`. The `isFull()` method first checks
    whether this list belongs to a premium account.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `true`, the collection is never full as we allow premium users to store
    unlimited songs in their playlists. If this list does not belong to a premium
    account, our getter ensures that the current count of `_songs` has not exceeded
    `capacity` and returns that comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addSong(Song song)` method provides *add* functionality to our class.
    This method first confirms that the collection is not full. If so, the method
    returns `false` as we cannot add any more songs to the list. Otherwise, the method
    returns the result of `HashSet<E>.add(E)`, which will return `true` if the song
    is added, and that too only if the song is not already in this playlist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `removeSong(Song song)` method provides the *remove* functionality to our
    class. This method simply returns the result of `HashSet<E>.remove(E)`, which
    will return `true` if the song exists in the set; otherwise, it will return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mergeWithPlaylist(HashSet<Song> playlist)` method provides *union* functionality
    for our class, and this is where our class begins to truly diverge from our previous
    C# example. `HashSet<E>` exposes the *union* functionality we''re looking for,
    but only by calling the `HashSet<E>.addAll(HashSet<E>)` method. This method accepts
    a set of `Song` objects as a parameter and attempts to add each one to our `_songs`
    collection. If the `Song` element being added already exists in the `_songs` set,
    that element will be discarded, leaving us with only unique `Song` objects from
    both lists or a union of the two sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `findSharedSongsInplaylist(HashSet<Song> playlist)` method provides
    the *intersection* functionality to our class. Again, `HashSet<E>` exposes intersection
    functionality, but not directly. Our method uses the `HashSet<E>.retainAll(HashSet<E>)`
    method, which retains all of the elements in the `_songs` set, that also exist
    in the `playlist` parameter, or intersection of the two collections. As in our
    C# example, we are not modifying the `_songs` set in place but rather returning
    the intersection between a copy of `_songs` and the `playlist` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `findUniqueSongs(HashSet<Song> playlist)` method provides the *difference*
    functionality to our class. Once again, `HashSet<E>` exposes the difference functionality,
    but through the `removeAll(HashSet<E>)` method. The `removeAll()` method removes
    all of the `_songs` elements that are also contained in the playlist parameter
    or the difference between the two collections. Again, this method does not modify
    our existing set in place but returns the results of the `removeAll()` method,
    or difference operation, on the `_songs` copy and the `playlist` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isSubset(HashSet<Song> playlist)` and `isSuperset(HashSet<Song> playlist)`
    methods provide the functionality of the same names. These methods both utilize
    the `HashSet<E>.containsAll(HashSet<E>)` method and return a Boolean value representing
    the result of those comparisons. Our methods simply swap the source set and the
    parameter to obtain the desired comparison since `HashSet<E>` does not provide
    a specific comparator for each function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `totalSongs()` method returns the number of elements found in the
    `_songs` set using the collection's `size()` method, providing the *count* functionality
    to our collection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objective-C provides the `NSSet` and `NSMutableSet` class clusters as the concrete
    implementations of the set data structure. These class clusters provide most of
    the functionality we would expect to see in a set data structure, and the explicit
    functions that are missing are very simple to implement, which makes the Objective-C
    implementation fairly straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `NSMutableSet`, we create one private ivar for our class called `_songs`.
    Our initializer instantiates this field, giving us the underlying data structure
    to build our `EDSPlaylistSet` class on. We also create four public properties:
    `capacity`, `premiumUser`, `isEmpty`, and `isFull` in our header file, backed
    by private ivars of the same name. The `capacity` property stores the maximum
    numbers of songs non-premium users can store in their playlist, while `premiumUser`
    denotes if this list belongs to a premium account or not. The `isEmpty` and `isFull`
    properties allow our class to easily implement the two operations of the same
    name. The `isEmpty` property simply returns whether or not the count of the set
    is `0`, while the `isFull` property first checks whether this list belongs to
    a premium account. If `true`, the collection is never full as we allow premium
    users to store unlimited songs in their playlists. If this list does not belong
    to a premium account, our method ensures that the current count of `_songs` has
    not exceeded the capacity and returns that comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addSong:` method provides *add* functionality to our class. This method
    first confirms that the collection is not full and then confirms that the object
    is actually contained in the `_songs` collection. If the collection does not pass
    both tests, the method returns `NO`, as we cannot add any more songs to the list
    or the song already exists in the collection. Otherwise, the method calls `addObject:`
    and returns `YES`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `removeSong:` method provides *remove* functionality to our class. This
    method confirms that the song exists in the collection, then removes the song
    using `removeObject:`, and finally returns `YES`. If the song does not exist in
    the collection, the method returns `NO`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mergeWithPlaylist:` method provides *union* functionality for our class.
    Luckily, `NSSet` exposes the union functionality with the `unionSet:` method,
    so our method simply calls it. In this case, `unionSet:` will merge the `playlist`
    parameter with our existing `_songs` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `findSharedSongsInplaylist:` method provides *intersection* functionality
    to our class. Again, `NSSet` exposes the intersection functionality through the
    `intersectSet:` method. As in our C# example, we are not modifying the `_songs`
    set in place but rather returning the intersection between a copy of `_songs`
    and the `playlist` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `findUniqueSongs:` method provides the *difference* functionality to our
    class. Once again, `NSSet` exposes the difference functionality through the `minusSet:`
    method. And again, this method does not modify our existing set in place but returns
    the results of the `minusSet:`, or difference, operation on the `_songs` copy
    and the `playlist` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isSubset:` and `isSuperset:` methods provide the functionalities by their names.
    These methods utilize the `isSubsetOfSet:` method on `NSSet` in much the same
    way that our Java example utilizes the `containsAll(HashSet<E>)` method of the
    `Set<E>` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `totalSongs` method returns the number of elements found in the
    `_songs` set, providing *count* functionality to our collection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift provides the `Set` class as a concrete implementation of the set data
    structure. This class provides all of the functionality we would expect to see
    in a set data structure, even more so than its Objective-C counterpart, which
    makes the Swift implementation very clean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `Set`, we create one private ivar for our class called `_songs` and initialize
    it inline with its declaration, giving us the underlying data structure to build
    our `PlaylistSet` class on. We also create four public fields, `_capacity`, `_premiumUser`,
    `_isEmpty`, and `_isFull`, as well as public accessors for the last three. The
    `capacity` field stores the maximum number of songs non-premium users can store
    in their playlist while `premiumUser` denotes whether this list belongs to a premium
    account or not. The `isEmpty` and `isFull` fields allow our class to easily implement
    the two operations of the same name. The `isEmpty()` field simply returns whether
    or not the count of the set is `0`. The `isFull()` field first checks if this
    list belongs to a premium account. If `true`, the collection is never full as
    we allow premium users to store unlimited songs in their playlists. If this list
    does not belong to a premium account, our getter ensures that the current count
    of `_songs` has not exceeded `capacity` and returns that comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addSong(song: Song)` method provides *add* functionality to our class.
    This method first confirms that the collection is not full and then confirms that
    the object is actually contained in the `_songs` collection. If the collection
    does not pass both tests, the method returns `false`, as we cannot add any more
    songs to the list or the song already exists in the collection. Otherwise, the
    method calls `insert()` and returns `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `removeSong(song: Song)` method provides *remove* functionality to our
    class. This method confirms that the song exists in the collection, then removes
    the song using `remove()`, and finally returns `true`. If the song does not exist
    in the collection, the method returns `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mergeWithPlaylist(playlist: Set<Song>)` method provides the *union* functionality
    for our class. Luckily, `Set` exposes the union functionality with the `unionInPlace()`
    method, so our method simply calls it. In this case, `unionInPlace()` will merge
    the `playlist` parameter with our existing `_songs` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `findSharedSongsInplaylist(playlist: Set<Song>)` method provides *intersection*
    functionality to our class. The `Set` class exposes the intersection functionality
    using the `intersect()` method. The `intersect()` method does not modify `_songs`,
    but only returns the results of the intersection between `_songs` and the `playlist`
    parameter, so we simply return the results of this method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `findUniqueSongs(playlist: Set<Song>)` method provides *difference* functionality
    to our class. Once again, `Set` exposes the difference functionality using the
    `subtract()` method. The `subtract()` method does not modify `_songs`, but only
    returns the results of the difference between `_songs` and the `playlist` parameter,
    so we simply return the results of this method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isSubset(playlist: Set<Song>)` and `isSuperset(playlist: Set<Song>)` methods
    provide the functionalities by their names. These methods utilize the `isSubSetOf()`
    and `isSuperSetOf()` methods, respectively, and return a Boolean value representing
    the result of those comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `totalSongs()` method returns the number of elements found in the
    `_songs` set, providing *count* functionality to our collection.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have examined how sets are used in common applications, we should
    take some time to examine how they are implemented under the hood. The majority
    of sets come in three varieties: hash table-based sets, tree-based sets, and array-based
    sets.'
  prefs: []
  type: TYPE_NORMAL
- en: Hash table-based sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hash table-based sets are typically used for unordered collections of data.
    As such, the majority of sets you will encounter for non-specialized applications
    will be hash table-based. Hash table-based sets share similar operational costs
    with dictionaries. For example, search, insert, and delete operations all have
    an operational cost of **O**(*n*).
  prefs: []
  type: TYPE_NORMAL
- en: Tree-based sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tree-based sets are typically based on binary search trees, but they sometimes
    can be based on other structures. Due to their design, the binary search tree
    allows for very efficient search functions on average, as each node that is examined
    can allow for branches of the tree to be discarded from the remaining search pattern.
    Although the worst case scenario for searching a binary search tree has an **O**(*n*)
    operational cost, in practice this is rarely required.
  prefs: []
  type: TYPE_NORMAL
- en: Array-based sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays can be used to implement subsets of sets, making union, intersection,
    and difference operations much more efficient in properly organized array-based
    sets.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basic definition of the set data structure.
    In order to fully appreciate the functionality of the structure, we briefly examined
    the most basic principles of set theory upon which the set data structure is based.
    Following this, we looked at the most common operations of sets and how they relate
    to the set theory functions. We then looked at how to implement a set in each
    of the four languages we're studying in this text. Next, we revisited the users
    logged into a service problem one more time to see if we could improve upon its implementation
    at all using a set data structure as opposed to an array or list. Following this,
    we examined a case study where sets would be beneficial. Finally, we looked at
    the varying implementations of sets, including hash table-based sets, tree-based
    sets, and array-based sets.
  prefs: []
  type: TYPE_NORMAL
