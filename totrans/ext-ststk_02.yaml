- en: Chapter 2. Writing Execution Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Execution modules form the backbone of the workload that Salt performs. They're
    also easy to write, and the techniques used in writing them form the foundation
    for writing every other type of Salt module. With a solid understanding of how
    execution modules work, the functionality of other module types will also be opened
    up.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll talk about:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of writing Salt modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making use of Salt built-ins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using good practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting execution modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Salt modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few items that are consistent across all Salt modules. These pieces
    generally work the same way across all module types, though there are a handful
    of places where you can expect at least a little deviation. We'll cover those
    in other chapters as we get to them. For now, let's talk about the things that
    are generally the same.
  prefs: []
  type: TYPE_NORMAL
- en: Hidden objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It has long been common for programmers to preface functions, variables, and
    the like with an underscore, if they are only intended to be used internally in
    the same module. In many languages, objects that are used like this are said to
    be **private objects**.
  prefs: []
  type: TYPE_NORMAL
- en: Some environments enforce private behavior by not allowing external code to
    reference those things directly. Other environments allow it, but its use is discouraged.
    Salt modules fall into the list of environments that enforce private function
    behavior; if a function inside a Salt module begins with an underscore, it will
    not even be exposed to other modules that try to call it.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, there is a special type of object whose name begins and ends with
    two underscores. These "magic methods" are nicknamed **dunder** (meaning double
    underscore). How Python normally treats them is beyond the scope of this book,
    but it is important to know that Salt adds some of its own. Some are built-ins,
    which are generally available in (almost) all module types, whereas others are
    user-defined objects that Salt will apply special treatment to.
  prefs: []
  type: TYPE_NORMAL
- en: The __virtual__() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a function that can appear in any module. If there is no `__virtual__()`
    function, then the module will always be available on every system. If that module
    is present, then its job is to determine whether the requirements for that module
    are met. These requirements could be any number of things from configuration settings
    to package dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: If the requirements are not met, then the `__virtual__()` function will return
    `False`. In more recent versions of Salt, it is possible to instead return a tuple
    containing both the `False` value and a reason why the module cannot be loaded.
    If they are met, then there are two types of value that it can return. This is
    where things get just a tad tricky.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that the module that we are working on is located at `salt/modules/mymodule.py`.
    If the requirements are met, and the module is to be referred to as `mymodule`,
    then the `__virtual__()` function will return `True`. Assuming there is also a
    function in that module called `test()`, it would be called using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If the requirements are met, but this module is to be referred to as `testmodule`,
    then the `__virtual__()` function will return the string `testmodule` instead.
    However, instead of returning that string directly, you should define it before
    all of the functions using the `__virtualname__` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and start writing a module, using the `__virtual__()` function
    and `__virtualname__` variable. We won''t check for any requirements yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Formatting your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get any further, I want to point out some important things that you
    should be aware of now, so that you don't get into any bad habits that need to
    be fixed later.
  prefs: []
  type: TYPE_NORMAL
- en: The module starts off with a special kind of comment called a `docstring`. In
    Salt, this begins and ends with three single quotes, all on one line, by themselves.
    Do not use double quotes. Do not put text on the same line as the quotes. All
    public functions must also include a `docstring`, with the same rules. These `docstrings`
    are used internally by Salt, to provide help text to functions such as `sys.doc`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that these guidelines are specific to Salt; Python itself follows
    a different style. Check *Understanding the Salt style guide* in *Appendix B*
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Take note that the `docstring` for the `ping()` function includes a `CLI Example`.
    You should always include just enough information to make it clear what the function
    is meant to do, and at least one (or more, as warranted) command-line examples
    that demonstrate how to use that function. Private functions do not include a
    `CLI Example`.
  prefs: []
  type: TYPE_NORMAL
- en: You should always include two blank lines between any imports and variable declarations
    at the top and the functions below, and between all functions. There should be
    no whitespace at the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary motivation behind the `__virtual__()` function is not just to rename
    modules. Using this function allows Salt to not only detect certain pieces of
    information about the system but also use them to appropriately load specific
    modules to make certain tasks more generic.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1](part0015_split_000.html#E9OE1-d9976ffc65994572ad672a3ef48f1135
    "Chapter 1. Starting with the Basics"), *Starting with the Basics*, mentioned
    some of these examples. `salt/modules/aptpkg.py` contains a number of tests to
    determine whether it is running on a Debian-like operating system that uses the
    `apt` suite of tools to perform package management. There are similar tests in
    `salt/modules/yumpkg.py`, `salt/modules/pacman.py`, `salt/modules/solarispkg.py`,
    and a number of others. If all of the tests pass for any of those modules, then
    it will be loaded as the `pkg` module.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are building a set of modules like this, it is important to remember
    that they should all perform as similarly as possible. For instance, all of the
    `pkg` modules contain a function called `install()`. Every single `install()`
    function accepts the same arguments, performs the same task (as appropriate for
    that platform), and then returns data in exactly the same format.
  prefs: []
  type: TYPE_NORMAL
- en: There may be situations where one function is appropriate for one platform,
    but not another. For example, `salt/modules/aptpkg.py` contains a function called
    `autoremove()`, which calls out to `apt-get autoremove`. There is no such functionality
    in `yum`, so that function does not exist in `salt/modules/yumpkg.py`. If there
    were, then that function would be expected to behave the same way between both
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Using the salt.utils library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding module will always run, because it doesn't check for requirements
    on the system. Let's go ahead and add some checking now.
  prefs: []
  type: TYPE_NORMAL
- en: There is an extensive set of tools available to import inside the `salt/utils/`
    directory. A large number of them live directly under the `salt.utils` namespace,
    including a very commonly used function called `salt.utils.which()`. When given
    the name of a command, this function will report the location of that command,
    if it exists on the system. If it does not exist, then it will return `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and rework the `__virtual__()` function to look for a command
    called `mysql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `salt.utils` libraries ship with Salt, but you need to explicitly import
    them. It is common for Python coders to import only parts of functions. You may
    find it tempting to use the following import line instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And then use the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Although not expressly forbidden in Salt, this is discouraged except when necessary.
    Although it may require more typing, especially if you use a particular function
    several times in a particular module, doing so makes it easier to tell at a glance
    which module a particular function came from.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-calling with the __salt__ dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are times when it is helpful to be able to call out to another function
    in another module. For instance, calling external shell commands is a pretty important
    part of Salt. It''s so important in fact that it was standardized in the `cmd`
    module. The most common command for issuing shell commands is `cmd.run`. The following
    Salt command demonstrates using `cmd.run` on a Windows Minion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you had a need for your execution module to obtain the output from such
    a command, you would use the following Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `__salt__` object is a dictionary, which contains references to all of the
    available functions on that Minion. If a module exists, but its `__virtual__()`
    function returns `False`, then it will not appear in this list. As a function
    reference, it requires parentheses at the end, with any arguments inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create a function that tells us whether or not the `sshd`
    daemon is running on a Linux system, and listening to a port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If `sshd` is running and listening on a port, the output of the `netstat -tulpn
    | grep sshd` command should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If `mysqld` is running, and listening either on IPv4 or IPv6 (or both), then
    this function will return `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function is far from perfect. There are a number of factors that may cause
    this command to return a false positive. For instance, let''s say you were looking
    for `sshd` instead of `mysqld`. And say you were a fan of American football, and
    had written your own high-definition football video-streaming service that you
    called `passhd`. This may be unlikely, but it''s certainly not impossible. And
    it brings up an important point: when dealing with data received either from users
    or from computers, **trust but verify**. In fact, you should always assume that
    somebody is going to try to do something bad, and you should watch for ways to
    keep them from doing so.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting configuration parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whereas some software can be accessed without any special configuration, there
    is plenty that does require some information to be set up. There are four places
    that an execution module can get its configuration from: the Minion configuration
    file, grain data, pillar data, and the master configuration file.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is one of those places where Salt built-ins behave differently. Grain and
    pillar data are available to execution and state modules, but not to other types
    of module. This is because grain and pillar data is specific to the Minion running
    the module. Runners, for instance, cannot access this data, because runners are
    used on the Master; not directly on Minions.
  prefs: []
  type: TYPE_NORMAL
- en: The first place we can look for configuration is from the `__opts__` dictionary.
    When working in modules that execute on a Minion, this dictionary will contain
    a copy of the data from the Minion configuration file. It may also contain some
    information that Salt generates on its own during runtime. When accessed from
    modules that execute on the Master, this data will come from the master configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to set configuration values inside grain or pillar data.
    This information is accessed using the `__grains__` and `__pillar__` dictionaries,
    respectively. The following example shows different configuration values being
    pulled from each of these locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since those values may not actually exist, it is better to use Python''s `dict.get()`
    method, and supply a default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The last place we can store configuration data is inside the master configuration
    file. All of the Master's configuration can be stored inside a pillar dictionary
    called `master`. By default, this is not made available to Minions. However, it
    can be turned on by setting `pillar_opts` to `True` in the `master` configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `pillar_opts` is turned on, you can use commands like this to access a
    value in the `master` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Finally, it is possible to ask Salt to search each of these locations, in turn,
    for a specific variable. This can be very valuable when you don't care which component
    carries the information that you need, so long as you can get it from somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to search each of these areas, cross-call to the `config.get()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will search for the configuration parameter in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__opts__` (on the Minion).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`__grains__`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`__pillar__`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`__opts__` (on the Master).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep in mind that when using `config.get()`, the first value found will be used.
    If the value that you are looking for is defined in both `__grains__` and `__pillar__`,
    then the value in `__grains__` will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of using `config.get()` is that this function will automatically
    resolve data that is referred to using `sdb://` URIs. When accessing those dictionaries
    directly, any `sdb://` URIs will need to be handled manually. Writing and using
    SDB modules will be covered in [Chapter 3](part0023_split_000.html#LTSU2-d9976ffc65994572ad672a3ef48f1135
    "Chapter 3. Extending Salt Configuration"), *Extending Salt Configuration*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and set up a module that obtains configuration data and uses
    it to make a connection to a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This execution module will run on the Minion, but it can connect to any MySQL
    database using configuration defined in any of the four configuration areas. However,
    this function is pretty limited. If the `MySQLdb` driver is not installed, then
    errors will appear in the Minion's log files when it starts up. If you need to
    perform other types of query, you will need to grab the configuration values each
    time. Let's solve each of these problems in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Did you notice that we used a variable called `db_` instead of `db`? In Python,
    it is considered better practice to use variable names that are at least three
    characters long. Salt also considers this to be a requirement. A very common means
    of accomplishing this for variables that would normally be shorter is to append
    one or two underscores to the end of the variable name.
  prefs: []
  type: TYPE_NORMAL
- en: Handling imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A number of Salt modules require third-party Python libraries to be installed.
    If any of those libraries aren't installed, then the `__virtual__()` function
    should return `False`. But how do you know beforehand whether or not the libraries
    can be imported?
  prefs: []
  type: TYPE_NORMAL
- en: 'A very common trick in a Salt module involves attempting to import libraries,
    and then recording whether or not the import succeeded. This is often accomplished
    using a variable with a name like `HAS_LIBS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, Python will attempt to import `MySQLdb`. If it succeeds, then
    it will set `HAS_LIBS` to `True`. Otherwise, it will set it to `False`. And because
    this directly correlates to the value that needs to be returned from the `__virtual__()`
    function, we can just return it as it is, so long as we''re not changing `__virtualname__`.
    If we were, then the function would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Reusing code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's still the matter of eliminating redundant code between different functions
    in the same module. In the case of modules that use connection objects (such as
    a database cursor, or a cloud provider authentication) throughout the code, specific
    functions are often set aside to gather configuration, and establish a connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very common name for these in-cloud modules is `_get_conn()`, so let''s go
    with that in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This greatly simplifies our code, by turning a large chunk of lines in every
    function into a single line. Of course, this can be taken quite a bit further.
    The actual `salt/modules/mysql.py` module that ships with Salt uses a function
    called `_connect()` instead of `_get_conn()`, and it also has `cur.execute()`
    abstracted out into its own `_execute()` function. You can see these at Salt''s
    GitHub page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/saltstack/salt](https://github.com/saltstack/salt)'
  prefs: []
  type: TYPE_NORMAL
- en: Logging messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Very often, you will perform an operation that requires some kind of message
    to be logged somewhere. This is especially common when writing new code; it's
    nice to be able to log debugging information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Salt has a logging system built in, based on Python''s own `logging` library.
    To turn it on, there are two lines that you''ll need to add toward the top of
    your module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With these in place, you can log messages using a command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There are five levels of logging that are typically used in Salt:'
  prefs: []
  type: TYPE_NORMAL
- en: '`log.info()`: Information at this level is something that is considered to
    be important to all users. It doesn''t mean anything is wrong, but like all log
    messages, its output will be sent to `STDERR` instead of `STDOUT` (so long as
    Salt is running in the foreground, and not configured to log elsewhere).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`log.warn()`: A message logged from here should indicate to the user that something
    is not happening as it should be. However, it is not so broken as to stop the
    code from running.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`log.error()`: This denotes that something has gone wrong, and Salt is unable
    to continue until it is fixed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`log.debug()`: This is not only information that is useful for determining
    what the program is thinking but is also intended to be useful to regular users
    of the program for things like troubleshooting.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`log.trace()`: This is similar to a debug message, but the information here
    is more likely to be useful only to developers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For now, we''ll add a `log.trace()` to our `_get_conn()` function, which lets
    us know when we successfully connect to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are certain places where it is tempting to use log messages, but they
    should be avoided. Specifically, log messages may be used in any function, except
    for `__virtual__()`. Log messages used outside of functions, and in the `__virtual__()`
    function, make for messy log files that are a pain to read and navigate.
  prefs: []
  type: TYPE_NORMAL
- en: Using the __func_alias__ dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a handful of words that are reserved in Python. Unfortunately, some
    of these words are also very useful for things like function names. For instance,
    many modules have a function whose job is to list data relevant to that module,
    and it seems natural to call such a function `list()`. But that would conflict
    with Python's `list` built-in. This poses a problem, since function names are
    directly exposed to the Salt command.
  prefs: []
  type: TYPE_NORMAL
- en: 'A workaround is available for this. A `__func_alias__` dictionary may be declared
    at the top of a module, which creates a map between aliases used from the command
    line and the actual name of the function. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, the `list_` function will be called as `mysqltest.list`
    (as in the `CLI Example`) instead of `mysqltest.list_`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Why did we call the variable `type_` instead of `type`? Because `type` is a
    Python built-in. But since this function only has one argument, it's not expected
    that users will need to use `type_=<something>` as part of their Salt command.
  prefs: []
  type: TYPE_NORMAL
- en: Validating data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From that last piece of code, a number of readers at this point probably have
    warning bells going off in their heads. It allows for a very common type of security
    vulnerability called an injection attack. Because the function does not perform
    any sort of validation on the `type_` variable, it is possible for users to pass
    in code that can cause destruction, or obtain data that they shouldn't have.
  prefs: []
  type: TYPE_NORMAL
- en: 'One might think that this isn''t necessarily a problem in Salt, because in
    a number of environments, only trusted users should have access. However, because
    Salt can be used by a wide range of user types, who may be intended to only have
    limited access, there are a number of scenarios where an injection attack can
    be devastating. Imagine a user running the following Salt command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is often easy to fix, by adding some simple checking to any user input
    (remember: **trust but verify**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we've declared which types are valid before allowing them to be
    passed in to the SQL query. Even a single bad character will cause Salt to refuse
    to complete the command. This kind of data validation is often better, because
    it doesn't try to modify the input data to make it safe to run. Doing so is referred
    to as *validating user input*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve added in another piece of code as well: a Salt exception. There are
    a number of these available in the `salt.exceptions` library, but `CommandExecutionError`
    is one that you may find yourself using quite a bit when validating data.'
  prefs: []
  type: TYPE_NORMAL
- en: Formatting strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A quick note on string formatting: Older Python developers may have noticed
    that we opted to use `str.format()` instead of the older `printf`-style string
    handling. The following two lines of code do the same thing in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: String formatting using `str.format()` is just a little faster in Python, and
    is required in Salt except for in places where it doesn't make sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t be tempted to use the following shortcut available in Python 2.7.x:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Because Salt still needs to run on Python 2.6, which doesn't support using `{}`
    instead of `{0}`, this will cause problems for users on older platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The final module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we put all of the preceding code together, we end up with the following
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Troubleshooting execution modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with any programming, the more time you spend writing execution modules,
    the more likely you are to encounter issues. Let's take a moment to talk about
    how to troubleshoot and debug your code.
  prefs: []
  type: TYPE_NORMAL
- en: Using salt-call
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `salt-call` command has always been a valuable tool for testing and troubleshooting
    code. Without it, you would need to restart the `salt-minion` service each time
    you wanted to test new code; believe me, that gets old fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `salt-call` doesn''t start up a service, it will always run the latest
    copy of the Salt code. It does do most of the things that the `salt-minion` service
    does: it loads grains, connects to the Master (unless told not to) to obtain pillar
    data, goes through the loader process to decide which modules to load, and then
    performs the requested command. Pretty much the only thing it doesn''t do is keep
    running.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `salt-call` to issue a command is also the same as using the `salt` command,
    except that a target is not required (because the target is the Minion that `salt-call`
    is running on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that even though you're issuing `salt-call` commands on the same
    machine that will be performing the execution, it tends to run a little slower.
    There are two reasons for this. First of all, you are still basically starting
    up the `salt-minion` service each time, without actually keeping it running. That
    means that detecting grains, loading modules, and so on will have to happen each
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a feel for how much time this really takes, try comparing execution
    times both with and without grain detection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if you''re testing a module that makes use of grains, this is not
    an acceptable strategy. The second thing that slows down commands is having to
    connect to the Master. This doesn''t take nearly as much time as grain detection,
    but it does take a hit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `--local` flag doesn't just tell `salt-call` not to talk to the Master.
    It actually tells `salt-call` to use itself as the Master (meaning, operate in
    local mode). If your module makes use of pillars or other resources on the Master,
    then you can just serve them locally instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any configuration in the master configuration file that you need can be copied
    directly to the `Minion` file. If you''re just using the defaults, you don''t
    even need to do that: just copy the necessary files from the Master to the Minion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Once everything is in place, go ahead and fire up `salt-call` with the `--local`
    flag and get to troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: <function> is not available
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When I''m writing a new module, one of the first problems I have is getting
    the module to show up. Quite often this is because of obviously bad code, such
    as a typo. For instance, if we were to change our import from `salt.utils` to
    `salt.util`, our module would fail to load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In cases like this, we can find the problem by running `salt-call` in `debug`
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Another possibility is that there is a problem with the `__virtual__()` function.
    This is the one time I would recommend adding log messages to that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: However, make sure you pull them out before you ever get into production, or
    you're going to have some very unhappy users sooner or later.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code files by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in or register to our website using your e-mail address and password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hover the mouse pointer on the SUPPORT tab at the top.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on Code Downloads & Errata.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter the name of the book in the Search box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the book for which you're looking to download the code files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose from the drop-down menu where you purchased this book from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on Code Download.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  prefs: []
  type: TYPE_NORMAL
- en: WinRAR/7-Zip for Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zipeg/iZip/UnRarX for Mac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7-Zip/PeaZip for Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning how to write execution modules creates an excellent foundation for
    writing other Salt modules. Salt contains a number of built-ins, many of which
    are available across all module types. A number of libraries also ship with Salt
    inside the `salt/utils/` directory. And troubleshooting Salt modules is easiest
    when using the `salt-call` command, particularly in local mode.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we'll talk about various types of Salt module that can be used to handle
    configuration.
  prefs: []
  type: TYPE_NORMAL
