- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Objects in Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的对象
- en: We have a design in hand and are ready to turn that design into a working program!
    Of course, it doesn't usually happen this way. We'll be seeing examples and hints
    for good software design throughout the book, but our focus is object-oriented
    programming. So, let's have a look at the Python syntax that allows us to create
    object-oriented software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们手头有一个设计方案，并准备好将其转化为一个可工作的程序！当然，事情通常不会这么顺利。本书中我们将看到关于良好软件设计的例子和提示，但我们的重点是面向对象编程。因此，让我们来看看允许我们创建面向对象软件的Python语法。
- en: 'After completing this chapter, we will understand the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，我们将了解以下内容：
- en: Python's type hints
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python的类型提示
- en: Creating classes and instantiating objects in Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中创建类和实例化对象
- en: Organizing classes into packages and modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将课程组织成包和模块
- en: How to suggest that people don't clobber an object's data, invalidating the
    internal state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何建议人们不要破坏对象的数据，从而破坏内部状态
- en: Working with third-party packages available from the Python Package Index, PyPI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用来自 Python 包索引 PyPI 的第三方包
- en: This chapter will also continue our case study, moving into the design of some
    of the classes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续我们的案例研究，转向一些类的设计。
- en: Introducing type hints
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍类型提示
- en: Before we can look closely at creating classes, we need to talk a little bit
    about what a class is and how we're sure we're using it correctly. The central
    idea here is that everything in Python is an object.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨创建类之前，我们需要稍微谈谈什么是类以及我们如何确保正确地使用它。这里的中心思想是，Python中的万物皆对象。
- en: 'When we write literal values like `"Hello, world!"` or `42`, we''re actually
    creating instances of built-in classes. We can fire up interactive Python and
    use the built-in `type()` function on the class that defines the properties of
    these objects:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写像 `"Hello, world!"` 或 `42` 这样的字面值时，我们实际上是在创建内置类的实例。我们可以启动交互式Python，并使用定义这些对象属性的类上的内置
    `type()` 函数：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The point of *object-oriented* programming is to solve a problem via the interactions
    of objects. When we write `6*7`, the multiplication of the two objects is handled
    by a method of the built-in `int` class. For more complex behaviors, we'll often
    need to write unique, new classes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的目的是通过对象的交互来解决一个问题。当我们编写 `6*7` 时，这两个对象的乘法操作是由内置的 `int` 类的方法处理的。对于更复杂的行为，我们通常会需要编写独特的新类。
- en: 'Here are the first two core rules of how Python objects work:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Python对象工作原理的前两条核心规则：
- en: Everything in Python is an object
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 中的一切都是对象
- en: Every object is defined by being an instance of at least one class
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个对象都通过至少属于一个类来定义
- en: These rules have many interesting consequences. A class definition we write,
    using the `class` statement, creates a new object of class `type`. When we create
    an **instance** of a class, the class object will be used to create and initialize
    the instance object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则有许多有趣的后果。我们使用`class`语句编写的类定义创建了一个新的`type`类对象。当我们创建一个类的**实例**时，类对象将用于创建和初始化实例对象。
- en: 'What''s the distinction between class and type? The `class` statement lets
    us define new types. Because the `class` statement is what we use, we''ll call
    them classes throughout the text. See *Python objects, types, classes, and instances
    - a glossary* by Eli Bendersky: [https://eli.thegreenplace.net/2012/03/30/python-objects-types-classes-and-instances-a-glossary](https://eli.thegreenplace.net/2012/03/30/python-objects-types-classes-and-instances-a-glossary)
    for this useful quote:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 类和类型之间的区别是什么？`class`语句让我们能够定义新的类型。因为`class`语句是我们所使用的，所以我们将它们在整个文本中称为类。参见Eli
    Bendersky的*Python对象、类型、类和实例 - 术语表*：[https://eli.thegreenplace.net/2012/03/30/python-objects-types-classes-and-instances-a-glossary](https://eli.thegreenplace.net/2012/03/30/python-objects-types-classes-and-instances-a-glossary)中的这段有用引言：
- en: '"The terms "class" and "type" are an example of two names referring to the
    same concept."'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “类”和“类型”这两个术语是两个指代同一概念的名称的例子。
- en: We'll follow common usage and call the annotations **type hints**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循常规用法，并将这些注释称为**类型提示**。
- en: 'There''s another important rule:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有另一个重要的规则：
- en: A variable is a reference to an object. Think of a yellow sticky note with a
    name scrawled on it, slapped on a thing.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量是对一个对象的引用。想象一下一张黄色的便利贴，上面写着名字，贴在某个东西上。
- en: 'This doesn''t seem too earth-shattering but it''s actually pretty cool. It
    means the type information – what an object is – is defined by the class(es) associated
    with the object. This type information is not attached to the *variable* in any
    way. This leads to code like the following being valid but very confusing Python:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来似乎并不惊天动地，但实际上相当酷。这意味着类型信息——一个对象是什么——是由与该对象关联的类（们）定义的。这种类型信息以任何方式都不附加到*变量*上。这导致以下代码虽然有效但非常令人困惑的Python代码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We created an object using a built-in class, `str`. We assigned a long name,
    `a_string_variable`, to the object. Then, we created an object using a different
    built-in class, `int`. We assigned this object the same name. (The previous string
    object has no more references and ceases to exist.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用内置类`str`创建了一个对象，并将一个长名称`a_string_variable`分配给该对象。然后，我们使用另一个内置类`int`创建了一个对象，并将相同的名称分配给这个对象。（之前的字符串对象不再有任何引用，因此不再存在。）
- en: 'Here are the two steps, shown side by side, showing how the variable is moved
    from object to object:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了两个步骤，并排显示，说明了变量是如何从一个对象移动到另一个对象的：
- en: '![Diagram  Description automatically generated](img/B17070_02_01.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_02_01.png)'
- en: 'Figure 2.1: Variable names and objects'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：变量名和对象
- en: The various properties are part of the object, not the variable. When we check
    the type of a variable with `type()`, we see the type of the object the variable
    currently references. The variable doesn't have a type of its own; it's nothing
    more than a name. Similarly, asking for the `id()` of a variable shows the ID
    of the object the variable refers to. So obviously, the name `a_string_variable`
    is a bit misleading if we assign the name to an integer object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 各种属性都是对象的一部分，而不是变量的。当我们使用 `type()` 函数检查变量的类型时，我们看到的是变量当前引用的对象的类型。变量本身并没有类型；它不过是一个名字。同样地，请求一个变量的
    `id()` 会显示变量所引用的对象的ID。因此，如果我们把名字分配给一个整数对象，那么名字 `a_string_variable` 就有点误导了。
- en: Type checking
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型检查
- en: 'Let''s push the relationship between object and type a step further, and look
    at some more consequences of these rules. Here''s a function definition:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将对象与类型之间的关系再向前推进一步，并看看这些规则的一些更多后果。下面是一个函数定义：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function does a little computation on a parameter variable, `n`. It computes
    the remainder after division, the modulo. If we divide an odd number by two, we'll
    have one left over. If we divide an even number by two, we'll have zero left over.
    This function returns a true value for all odd numbers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数对一个参数变量`n`进行少量计算。它计算除法后的余数，即模数。如果我们用2除以一个奇数，我们会剩下1。如果我们用2除以一个偶数，我们会剩下0。此函数对所有奇数返回一个真值。
- en: 'What happens when we fail to provide a number? Well, let''s just try it and
    see (a common way to learn Python!). Entering code at the interactive prompt,
    we''ll get something like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们未能提供一个数字时会发生什么？嗯，让我们试一试看看（这是学习Python的一种常见方法！）在交互式提示符中输入代码，我们会得到类似以下的内容：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is an important consequence of Python''s super-flexible rules: nothing
    prevents us from doing something silly that may raise an exception. This is an
    important tip:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由 Python 的超级灵活规则产生的一个重要后果：没有任何东西阻止我们做些愚蠢的事情，这可能会引发异常。这是一个重要的提示：
- en: Python doesn't prevent us from attempting to use non-existent methods of objects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Python 并不允许我们尝试使用对象不存在的函数。
- en: 'In our example, the `%` operator provided by the `str` class doesn''t work
    the same way as the `%` operator provided by the `int` class, raising an exception.
    For strings, the `%` operator isn''t used very often, but it does interpolation:
    `"a=%d" % 113` computes a string `''a=113''`; if there''s no format specification
    like `%d` on the left side, the exception is a `TypeError`. For integers, it''s
    the remainder in division: `355 % 113` returns an integer, `16`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`str` 类提供的 `%` 操作符与 `int` 类提供的 `%` 操作符工作方式不同，会引发异常。对于字符串，`%` 操作符并不常用，但它可以进行插值：`"a=%d"
    % 113` 计算出的字符串是 `'a=113'`；如果左侧没有像 `%d` 这样的格式指定符，则异常是 `TypeError`。对于整数，它是除法的余数：`355
    % 113` 返回一个整数，`16`。
- en: This flexibility reflects an explicit trade-off favoring ease of use over sophisticated
    prevention of potential problems. This allows a person to use a variable name
    with little mental overhead.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性反映了一种明确的权衡，即为了方便使用而牺牲了复杂地预防潜在问题的能力。这使得一个人在使用变量名时几乎无需动用太多心智资源。
- en: Python's internal operators check that operands meet the requirements of the
    operator. The function definition we wrote, however, does not include any runtime
    type checking. Nor do we want to add code for runtime type checking. Instead,
    we use tools to examine code as part of testing. We can provide annotations, called
    **type hints**, and use tools to examine our code for consistency among the type
    hints.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的内部运算符会检查操作数是否符合运算符的要求。然而，我们编写的函数定义中并不包括任何运行时类型检查。我们也不想添加运行时类型检查的代码。相反，我们使用工具作为测试的一部分来检查代码。我们可以提供称为
    **类型提示** 的注释，并使用工具检查我们的代码在类型提示之间的一致性。
- en: First, we'll look at the annotations. In a few contexts, we can follow a variable
    name with a colon, `:`, and a type name. We can do this in the parameters to functions
    (and methods). We can also do this in assignment statements. Further, we can also
    add `->` syntax to a function (or a class method) definition to explain the expected
    return type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看注释。在几种情况下，我们可以在变量名后面跟一个冒号 `:`, 然后是一个类型名。我们可以在函数（和方法）的参数中这样做。我们也可以在赋值语句中这样做。此外，我们还可以在函数（或类方法）定义中添加
    `->` 语法来解释预期的返回类型。
- en: 'Here''s how type hints look:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是类型提示的样式：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We've added two type hints to our `odd()` little function definition. We've
    specified that argument values for the `n` parameter should be integers. We've
    also specified that the result will be one of the two values of the Boolean type.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的`odd()`小函数定义添加了两个类型提示。我们指定了`n`参数的值应该是整数。我们还指定了结果将是布尔类型两个值之一。
- en: While the hints consume some storage, they have no runtime impact. Python politely
    ignores these hints; this means they're optional. People reading your code, however,
    will be more than delighted to see them. They are a great way to inform the reader
    of your intent. You can omit them while you're learning, but you'll love them
    when you go back to expand something you wrote earlier.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些提示会消耗一些存储空间，但它们对运行时没有影响。Python会礼貌地忽略这些提示；这意味着它们是可选的。然而，阅读你代码的人却会非常高兴看到它们。它们是向读者传达你意图的绝佳方式。在你学习时可以省略它们，但当你回头扩展之前所写的内容时，你会非常喜爱它们。
- en: The **mypy** tool is commonly used to check the hints for consistency. It's
    not built into Python, and requires a separate download and install. We'll talk
    about virtual environments and installation of tools later in this chapter, in
    the *Third-party libraries* section. For now, you can use `python -m pip install
    mypy` or `conda install mypy` if you're using **the conda tool**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**mypy** 工具通常用于检查提示的一致性。它不是 Python 的内置工具，需要单独下载和安装。我们将在本章的 *第三方库* 部分后面讨论虚拟环境和工具的安装。目前，如果您使用
    **conda 工具**，可以使用 `python -m pip install mypy` 或 `conda install mypy`。'
- en: 'Let''s say we had a file, `bad_hints.py`, in a `src` directory, with these
    two functions and a few lines to call the `main()` function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个文件，名为 `bad_hints.py`，位于 `src` 目录中，其中包含这两个函数和一些调用 `main()` 函数的代码行：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we run the `mypy` command at the OS''s terminal prompt:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在操作系统的终端提示符下运行`mypy`命令时：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The **mypy** tool is going to spot a bunch of potential problems, including
    at least these:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**mypy** 工具将发现一系列潜在问题，包括至少以下这些：'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `def main():` statement is on *line 12* of our example because our file
    has a pile of comments not shown above. For your version, the error might be on
    *line 1*. Here are the two problems:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`def main():`语句位于我们示例的**第12行**，因为我们的文件中有一堆未在上文显示的注释。对于你的版本，错误可能出现在**第1行**。以下是两个问题：'
- en: The `main()` function doesn't have a return type; **mypy** suggests including
    `-> None` to make the absence of a return value perfectly explicit.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()` 函数没有返回类型；**mypy** 建议包含 `-> None` 以使返回值的缺失完全明确。'
- en: 'More important is *line 13*: the code will try to evaluate the `odd()` function
    using a `str` value. This doesn''t match the type hint for `odd()` and indicates
    another possible error.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更重要的是*第13行*：代码将尝试使用一个`str`值来评估`odd()`函数。这与`odd()`函数的类型提示不匹配，并表明了另一个可能存在的错误。
- en: Most of the examples in this book will have type hints. We think they're always
    helpful, especially in a pedagogical context, even though they're optional. Because
    most of Python is generic with respect to type, there are a few cases where Python
    behavior is difficult to describe via a succinct, expressive hint. We'll steer
    clear of these edge cases in this book.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大多数示例都将包含类型提示。我们认为它们总是有帮助的，尤其是在教学环境中，即使它们是可选的。因为大多数Python代码在类型方面是通用的，所以有一些情况下，Python的行为难以通过简洁、富有表现力的提示来描述。在这本书中，我们将避免这些边缘情况。
- en: Python Enhancement Proposal (PEP) 585 covers some new language features to make
    type hints a bit simpler. We've used **mypy** version 0.812 to test all of the
    examples in this book. Any older version will encounter problems with some of
    the newer syntax and annotation techniques.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Python增强提案（PEP）585涵盖了某些新的语言特性，以使类型提示变得更加简单。我们使用**mypy**版本0.812来测试本书中的所有示例。任何较旧版本都将遇到一些较新语法和注解技术的兼容性问题。
- en: Now that we've talked about how parameters and attributes are described with
    type hints, let's actually build some classes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了如何使用类型提示来描述参数和属性，接下来让我们实际构建一些类。
- en: Creating Python classes
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Python 类
- en: We don't have to write much Python code to realize that Python is a very *clean* language.
    When we want to do something, we can just do it, without having to set up a bunch
    of prerequisite code. The ubiquitous *hello world* in Python, as you've likely
    seen, is only one line.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要写很多Python代码就能意识到Python是一种非常*简洁*的语言。当我们想要做某事时，我们只需去做，无需设置一大堆先决代码。你可能已经看到的Python中无处不在的*hello
    world*，仅有一行代码。
- en: 'Similarly, the simplest class in Python 3 looks like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，Python 3 中最简单的类看起来是这样的：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There's our first object-oriented program! The class definition starts with
    the `class` keyword. This is followed by a name (of our choice) identifying the
    class and is terminated with a colon.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的第一个面向对象程序！类的定义从`class`关键字开始。之后是一个名称（由我们选择），用于标识这个类，并以冒号结束。
- en: The class name must follow standard Python variable naming rules (it must start
    with a letter or underscore, and can only be comprised of letters, underscores,
    or numbers). In addition, the Python style guide (search the web for *PEP 8*)
    recommends that classes should be named using what PEP 8 calls **CapWords** notation
    (start with a capital letter; any subsequent words should also start with a capital).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 类名必须遵循标准的 Python 变量命名规则（它必须以字母或下划线开头，并且只能由字母、下划线或数字组成）。此外，Python 风格指南（在网络上搜索
    *PEP 8*）建议使用 PEP 8 所称的 **CapWords** 语法来命名类（以大写字母开头；任何后续单词也应以大写字母开头）。
- en: The class definition line is followed by the class contents, indented. As with
    other Python constructs, indentation is used to delimit the classes, rather than
    braces, keywords, or brackets, as many other languages use. Also, in line with
    the style guide, use four spaces for indentation unless you have a compelling
    reason not to (such as fitting in with somebody else's code that uses tabs for
    indents).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义行后面跟着类的内容，缩进。与其他 Python 构造一样，缩进用于界定类，而不是大括号、关键字或括号，正如许多其他语言所使用的。此外，根据样式指南，除非有充分的理由不这样做（例如，与使用制表符缩进的他人的代码兼容），否则请使用四个空格进行缩进。
- en: Since our first class doesn't actually add any data or behaviors, we simply
    use the `pass` keyword on the second line as a placeholder to indicate that no
    further action needs to be taken.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的第一节课实际上并没有添加任何数据或行为，所以我们只需在第二行使用`pass`关键字作为占位符，以表明不需要采取任何进一步的操作。
- en: 'We might think there isn''t much we can do with this most basic class, but
    it does allow us to instantiate objects of that class. We can load the class into
    the Python 3 interpreter, so we can interactively play with it. To do this, save
    the class definition mentioned earlier in a file named `first_class.py` and then
    run the `python -i first_class.py` command. The `-i` argument tells Python to *run
    the code and then drop to the interactive interpreter*. The following interpreter
    session demonstrates a basic interaction with this class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会认为对于这个最基本的类，我们能够做的事情并不多，但它确实允许我们实例化该类的对象。我们可以将这个类加载到 Python 3 解释器中，这样我们就可以与之进行交互式操作。为此，将前面提到的类定义保存到一个名为
    `first_class.py` 的文件中，然后运行 `python -i first_class.py` 命令。`-i` 参数告诉 Python 在运行代码后进入交互式解释器。以下解释器会话展示了与这个类的基本交互：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code instantiates two objects from the new class, assigning the object
    variable names `a` and `b`. Creating an instance of a class is a matter of typing
    the class name, followed by a pair of parentheses. It looks much like a function
    call; **calling** a class will create a new object. When printed, the two objects
    tell us which class they are and what memory address they live at. Memory addresses
    aren't used much in Python code, but here, they demonstrate that there are two
    distinct objects involved.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从新类中实例化了两个对象，将对象变量命名为`a`和`b`。创建类的实例只需输入类名，然后跟上一对括号。这看起来很像函数调用；**调用**一个类将创建一个新的对象。当打印时，这两个对象会告诉我们它们属于哪个类以及它们居住在哪个内存地址。在Python代码中，内存地址并不常用，但在这里，它们展示了涉及的是两个不同的对象。
- en: 'We can see they''re distinct objects by using the `is` operator:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`is`运算符来看到它们是不同的对象：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This can help reduce confusion when we've created a bunch of objects and assigned
    different variable names to the objects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于在我们创建了一堆对象并为这些对象分配了不同的变量名时减少混淆。
- en: Adding attributes
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加属性
- en: Now, we have a basic class, but it's fairly useless. It doesn't contain any
    data, and it doesn't do anything. What do we have to do to assign an attribute
    to a given object?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个基本的类，但它相当无用。它不包含任何数据，也不做任何事情。我们该如何给一个特定的对象分配属性？
- en: 'In fact, we don''t have to do anything special in the class definition to be
    able to add attributes. We can set arbitrary attributes on an instantiated object
    using dot notation. Here''s an example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在类定义中我们不需要做任何特殊操作就能添加属性。我们可以使用点符号在实例化的对象上设置任意属性。以下是一个示例：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we run this code, the two `print` statements at the end tell us the new
    attribute values on the two objects:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，最后的两个`print`语句会告诉我们两个对象上的新属性值：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code creates an empty `Point` class with no data or behaviors. Then, it
    creates two instances of that class and assigns each of those instances `x` and `y` coordinates
    to identify a point in two dimensions. All we need to do to assign a value to
    an attribute on an object is use the `<object>.<attribute> = <value>` syntax.
    This is sometimes referred to as **dot notation**. The value can be anything:
    a Python primitive, a built-in data type, or another object. It can even be a
    function or another class!'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个空的`Point`类，没有数据或行为。然后，它创建了该类的两个实例，并将每个实例的`x`和`y`坐标分配给它们，以标识二维空间中的一个点。要为一个对象的属性赋值，我们只需使用`<object>.<attribute>
    = <value>`语法。这有时被称为**点符号**。值可以是任何东西：Python原语、内置数据类型或另一个对象。甚至可以是一个函数或另一个类！
- en: 'Creating attributes like this is confusing to the **mypy** tool. There''s no
    easy way to include the hints in the `Point` class definition. We can include
    hints on the assignment statements, like this: `p1.x: float = 5`. In general,
    there''s a much, much better approach to type hints and attributes that we''ll
    examine in the *Initializing the object* section, later in this chapter. First,
    though, we''ll add behaviors to our class definition.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '创建这样的属性会让 **mypy** 工具感到困惑。在 `Point` 类定义中包含提示信息并没有简单的方法。我们可以在赋值语句中包含提示，例如：`p1.x:
    float = 5`。一般来说，在类型提示和属性方面有一个好得多的方法，我们将在本章后面的 *初始化对象* 部分进行探讨。不过，首先，我们将向我们的类定义中添加行为。'
- en: Making it do something
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让它做些事情
- en: Now, having objects with attributes is great, but object-oriented programming
    is really about the interaction between objects. We're interested in invoking
    actions that cause things to happen to those attributes. We have data; now it's
    time to add behaviors to our classes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，拥有具有属性的实体是很好的，但面向对象编程真正关注的是实体之间的交互。我们感兴趣的是调用那些导致属性发生变化的行为。我们有了数据；现在是为我们的类添加行为的时候了。
- en: 'Let''s model a couple of actions on our `Point` class. We can start with a **method** called `reset`,
    which moves the point to the origin (the origin is the place where `x` and `y` are
    both zero). This is a good introductory action because it doesn''t require any
    parameters:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Point`类上模拟几个动作。我们可以从一个名为`reset`的方法开始，该方法将点移动到原点（原点是`x`和`y`都为零的位置）。这是一个很好的入门动作，因为它不需要任何参数：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This `print` statement shows us the two zeros on the attributes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`print`语句显示了属性上的两个零：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In Python, a method is formatted identically to a function. It starts with the `def` keyword,
    followed by a space, and the name of the method. This is followed by a set of
    parentheses containing the parameter list (we'll discuss that `self` parameter,
    sometimes called the instance variable, in just a moment), and terminated with
    a colon. The next line is indented to contain the statements inside the method.
    These statements can be arbitrary Python code operating on the object itself and
    any parameters passed in, as the method sees fit.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，方法与函数的格式相同。它以`def`关键字开头，后面跟一个空格，然后是方法名。接着是一组括号，包含参数列表（我们将在稍后讨论这个`self`参数，有时也称为实例变量），并以冒号结束。下一行缩进以包含方法内的语句。这些语句可以是任意操作对象本身和任何传入参数的Python代码，正如方法所适合的那样。
- en: We've omitted type hints in the `reset()` method because it's not the most widely
    used place for hints. We'll look at the best place for hints in the *Initializing
    the object* section. We'll look a little more at these instance variables, first,
    and how the `self` variable works.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`reset()`方法中省略了类型提示，因为这并不是最常用于提示的地方。我们将在*初始化对象*部分探讨最佳提示位置。首先，我们将更详细地看看这些实例变量，以及`self`变量是如何工作的。
- en: Talking to yourself
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与自己对话
- en: The one difference, syntactically, between methods of classes and functions
    outside classes is that methods have one required argument. This argument is conventionally
    named `self`; I've never seen a Python programmer use any other name for this
    variable (convention is a very powerful thing). There's nothing technically stopping
    you, however, from calling it `this` or even `Martha`, but it's best to acknowledge
    the social pressure of the Python community codified in PEP 8 and stick with `self`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在类外部的类方法和函数在语法上的一个区别是，方法有一个必需的参数。这个参数传统上被命名为 `self`；我从未见过有 Python 程序员为这个变量使用其他名称（惯例是非常强大的东西）。然而，技术上并没有阻止你将其命名为
    `this` 或甚至 `Martha`，但最好还是承认 Python 社区在 PEP 8 中编码的社会压力，并坚持使用 `self`。
- en: The `self` argument to a method is a reference to the object that the method
    is being invoked on. The object is an instance of a class, and this is sometimes
    called the instance variable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 方法中的`self`参数是对正在调用该方法的对象的引用。该对象是类的实例，这有时被称为实例变量。
- en: We can access attributes and methods of that object via this variable. This
    is exactly what we do inside the `reset` method when we set the `x` and `y` attributes
    of the `self` object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过这个变量访问那个对象的属性和方法。这正是我们在`reset`方法内部设置`self`对象的`x`和`y`属性时所做的事情。
- en: Pay attention to the difference between a **class** and an **object** in this
    discussion. We can think of the **method** as a function attached to a class.
    The `self` parameter refers to a specific instance of the class. When you call
    the method on two different objects, you are calling the same method twice, but
    passing two different **objects** as the `self` parameter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次讨论中请注意区分**类**和**对象**的区别。我们可以把**方法**看作是附加到类上的一个函数。`self`参数指的是类的特定实例。当你对两个不同的对象调用方法时，你实际上是两次调用相同的方法，但传递了两个不同的**对象**作为`self`参数。
- en: Notice that when we call the `p.reset()` method, we do not explicitly pass the `self` argument
    into it. Python automatically takes care of this part for us. It knows we're calling
    a method on the `p` object, so it automatically passes that object, `p`, to the
    method of the class, `Point`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到当我们调用`p.reset()`方法时，我们并没有显式地将`self`参数传递给它。Python会自动为我们处理这部分。它知道我们正在调用`p`对象上的方法，因此它会自动将那个对象`p`传递给`Point`类的方法。
- en: 'For some, it can help to think of a method as a function that happens to be
    part of a class. Instead of calling the method on the object, we could invoke
    the function as defined in the class, explicitly passing our object as the `self` argument:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些人来说，可以将一种方法想象成一个恰好是某个类一部分的函数。我们不必在对象上调用该方法，而可以像在类中定义的那样调用该函数，明确地将我们的对象作为`self`参数传递：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The output is the same as in the previous example because, internally, the exact
    same process has occurred. This is not really a good programming practice, but
    it can help to cement your understanding of the `self` argument.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与上一个示例相同，因为内部发生的是完全相同的过程。这并不是一个好的编程实践，但它可以帮助你巩固对`self`参数的理解。
- en: 'What happens if we forget to include the `self` argument in our class definition?
    Python will bail with an error message, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在类定义中忘记包含`self`参数会发生什么？Python会抛出一个错误信息，如下所示：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The error message is not as clear as it could be ("Hey, silly, you forgot to
    define the method with a `self` parameter" could be more informative). Just remember
    that when you see an error message that indicates missing arguments, the first
    thing to check is whether you forgot the `self` parameter in the method definition.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息不如它本可以那么清晰（“嘿，傻瓜，你忘记在方法定义中使用`self`参数了”可以提供更多信息）。只需记住，当你看到指示缺少参数的错误信息时，首先要检查的是是否在方法定义中忘记了`self`参数。
- en: More arguments
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多论点
- en: 'How do we pass multiple arguments to a method? Let''s add a new method that
    allows us to move a point to an arbitrary position, not just to the origin. We
    can also include a method that accepts another `Point` object as input and returns
    the distance between them:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何向一个方法传递多个参数？让我们添加一个新的方法，允许我们将一个点移动到任意位置，而不仅仅是原点。我们还可以包括一个方法，该方法接受另一个`Point`对象作为输入，并返回它们之间的距离：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We've defined a class with two attributes, `x`, and `y`, and three separate
    methods, `move()`, `reset()`, and `calculate_distance()`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个具有两个属性`x`和`y`以及三个独立方法`move()`、`reset()`和`calculate_distance()`的类。
- en: The `move()` method accepts two arguments, `x` and `y`, and sets the values
    on the `self` object. The `reset()` method calls the `move()` method, since a
    reset is just a move to a specific known location.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`move()` 方法接受两个参数，`x` 和 `y`，并将这些值设置在 `self` 对象上。`reset()` 方法调用 `move()` 方法，因为重置实际上是将对象移动到特定的已知位置。'
- en: The `calculate_distance()` method computes the Euclidean distance between two
    points. (There are a number of other ways to look at distance. In the *Chapter
    3*, *When Objects Are Alike*, case study, we'll look at some alternatives.) For
    now, we hope you understand the math. The definition is ![](img/B17070_02_001.png),
    which is the `math.hypot()` function. In Python we'll use `self.x`, but mathematicians
    often prefer to write ![](img/B17070_02_002.png).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate_distance()` 方法计算两点之间的欧几里得距离。（还有许多其他看待距离的方法。在 *第3章*，*当物体相似时* 的案例研究中，我们将探讨一些替代方案。）目前，我们希望你能理解数学原理。定义是
    ![图片](img/B17070_02_001.png)，即 `math.hypot()` 函数。在 Python 中我们使用 `self.x`，但数学家们通常更喜欢写成
    ![图片](img/B17070_02_002.png)。'
- en: 'Here''s an example of using this class definition. This shows how to call a
    method with arguments: include the arguments inside the parentheses and use the
    same dot notation to access the method name within the instance. We just picked
    some random positions to test the methods. The test code calls each method and
    prints the results on the console:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用此类定义的示例。这展示了如何带参数调用一个方法：将参数放在括号内，并使用相同的点符号来访问实例中的方法名。我们只是随机选取了一些位置来测试这些方法。测试代码会调用每个方法，并将结果打印到控制台：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `assert` statement is a marvelous test tool; the program will bail if the
    expression after `assert` evaluates to `False` (or zero, empty, or `None`). In
    this case, we use it to ensure that the distance is the same regardless of which
    point called the other point's `calculate_distance()` method. We'll see a lot
    more use of `assert` in *Chapter 13*, *Testing Object-Oriented Programs*, where
    we'll write more rigorous tests.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert`语句是一个出色的测试工具；如果`assert`后面的表达式评估为`False`（或零、空或`None`），程序将退出。在这种情况下，我们使用它来确保无论哪个点调用另一个点的`calculate_distance()`方法，距离都是相同的。在*第13章*，*面向对象程序的测试*中，我们将看到更多`assert`的使用，我们将编写更严格的测试。'
- en: Initializing the object
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化对象
- en: If we don't explicitly set the `x` and `y` positions on our `Point` object,
    either using `move` or by accessing them directly, we'll have a broken `Point`
    object with no real position. What will happen when we try to access it?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有明确设置我们的`Point`对象的`x`和`y`位置，无论是使用`move`方法还是直接访问它们，我们将得到一个没有实际位置的损坏的`Point`对象。当我们尝试访问它时会发生什么？
- en: Well, let's just try it and see. *Try it and see* is an extremely useful tool
    for Python study. Open up your interactive interpreter and type away. (Using the
    interactive prompt is, after all, one of the tools we used to write this book.)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们试一试看看。*试一试看看*是Python学习中的一个极其有用的工具。打开你的交互式解释器并开始输入。毕竟，使用交互式提示符是我们用来编写这本书的工具之一。
- en: 'The following interactive session shows what happens if we try to access a
    missing attribute. If you saved the previous example as a file or are using the
    examples distributed with the book, you can load it into the Python interpreter
    with the `python -i more_arguments.py` command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下交互式会话展示了如果我们尝试访问一个缺失的属性会发生什么。如果您将前面的示例保存为文件或正在使用书中提供的示例，您可以使用`python -i more_arguments.py`命令将其加载到Python解释器中：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Well, at least it threw a useful exception. We'll cover exceptions in detail
    in *Chapter 4*, *Expecting the Unexpected*. You've probably seen them before (especially
    the ubiquitous `SyntaxError`, which means you typed something incorrectly!). At
    this point, simply be aware that it means something went wrong.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，至少它抛出了一个有用的异常。我们将在*第4章*，*预料之外*中详细讲解异常。你可能之前见过它们（尤其是无处不在的`SyntaxError`，这意味着你输入了错误的内容！）。在这个阶段，只需意识到这意味着出了点问题。
- en: The output is useful for debugging. In the interactive interpreter, it tells
    us the error occurred at *line 1*, which is only partially true (in an interactive
    session, only one statement is executed at a time). If we were running a script
    in a file, it would tell us the exact line number, making it easy to find the
    offending code. In addition, it tells us that the error is an `AttributeError`,
    and gives a helpful message telling us what that error means.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输出对于调试很有用。在交互式解释器中，它告诉我们错误发生在*第1行*，这在某种程度上是正确的（在交互会话中，每次只执行一条语句）。如果我们在一个文件中运行脚本，它将告诉我们确切的行号，这使得找到有问题的代码变得容易。此外，它还告诉我们错误是`AttributeError`，并给出有用的信息，告诉我们这个错误意味着什么。
- en: We can catch and recover from this error, but in this case, it feels like we
    should have specified some sort of default value. Perhaps every new object should
    be `reset()` by default, or maybe it would be nice if we could force the user
    to tell us what those positions should be when they create the object.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以捕捉并从这种错误中恢复，但在这个情况下，感觉我们应该指定某种默认值。也许每个新对象都应该默认调用`reset()`，或者如果我们能强制用户在创建对象时告诉我们那些位置应该是什么，那会更好。
- en: Interestingly, **mypy** can't determine whether `y` is supposed to be an attribute
    of a `Point` object. Attributes are – by definition – dynamic, so there's no simple
    list that's part of a class definition. However, Python has some widely followed
    conventions that can help name the expected set of attributes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，**mypy** 无法确定 `y` 是否应该是 `Point` 对象的属性。属性按定义是动态的，因此不存在一个简单的列表是类定义的一部分。然而，Python
    有一些广泛遵循的约定，可以帮助命名预期的属性集。
- en: Most object-oriented programming languages have the concept of a **constructor**,
    a special method that creates and initializes the object when it is created. Python
    is a little different; it has a constructor and an initializer. The constructor
    method, `__new__()`, is rarely used unless you're doing something very exotic.
    So, we'll start our discussion with the much more common initialization method,
    `__init__()`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数面向对象的编程语言都有**构造函数**的概念，这是一种在对象创建时创建和初始化对象的特殊方法。Python 稍有不同；它有一个构造函数和一个初始化器。构造函数方法
    `__new__()` 通常很少使用，除非你在做非常特殊的事情。因此，我们将从更常见的初始化方法 `__init__()` 开始我们的讨论。
- en: The Python initialization method is the same as any other method, except it
    has a special name, `__init__`. The leading and trailing double underscores mean
    this is a special method that the Python interpreter will treat as a special case.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的初始化方法与任何其他方法相同，只是它有一个特殊的名称，`__init__`。前后的双下划线表示这是一个特殊的方法，Python 解释器会将其视为特殊情况。
- en: Never name a method of your own with leading and trailing double underscores.
    It may mean nothing to Python today, but there's always the possibility that the
    designers of Python will add a function that has a special purpose with that name
    in the future. When they do, your code will break.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要用前后双下划线命名你自己的方法。这可能在今天的Python中没有任何意义，但总有这样的可能性，即Python的设计者将来会添加一个具有特殊目的的函数，其名称与你的方法相同。当他们这样做的时候，你的代码将会出错。
- en: 'Let''s add an initialization function on our `Point` class that requires the
    user to supply `x` and `y` coordinates when the `Point` object is instantiated:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Point`类中添加一个初始化函数，该函数要求用户在实例化`Point`对象时提供`x`和`y`坐标：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Constructing a `Point` instance now looks like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个 `Point` 实例现在看起来是这样的：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, our `Point` object can never go without both `x` and `y` coordinates! If
    we try to construct a `Point` instance without including the proper initialization
    parameters, it will fail with a `not enough arguments` error similar to the one
    we received earlier when we forgot the `self` argument in a method definition.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`Point`对象绝不能没有`x`和`y`坐标！如果我们尝试构建一个没有包含适当初始化参数的`Point`实例，它将失败并显示一个类似于我们之前忘记在方法定义中包含`self`参数时收到的`not
    enough arguments`错误。
- en: Most of the time, we put our initialization statements in an `__init__()` function.
    It's very important to be sure that all of the attributes are initialized in the
    `__init__()` method. Doing this helps the **mypy** tool by providing all of the
    attributes in one obvious place. It helps people reading your code, also; it saves
    them from having to read the whole application to find mysterious attributes set
    outside the class definition.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们将初始化语句放在一个`__init__()`函数中。确保所有属性在`__init__()`方法中初始化非常重要。这样做有助于**mypy**工具，因为它在一个明显的地方提供了所有属性。这也帮助了阅读你代码的人；它节省了他们阅读整个应用程序以找到在类定义外部设置的神秘属性的时间。
- en: While they're optional, it's generally helpful to include type annotations on
    the method parameters and result values. After each parameter name, we've included
    the expected type of each value. At the end of the definition, we've included
    the two-character `->` operator and the type returned by the method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们是可选的，但通常在方法参数和结果值上包含类型注解是有帮助的。在每个参数名称之后，我们都包括了每个值的预期类型。在定义的末尾，我们包括了两个字符的`->`运算符和由方法返回的类型。
- en: Type hints and defaults
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型提示和默认值
- en: As we've noted a few times now, hints are optional. They don't do anything at
    runtime. There are tools, however, that can examine the hints to check for consistency.
    The **mypy** tool is widely used to check type hints.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前多次提到的，提示（hints）是可选的。它们在运行时不会做任何事情。然而，有一些工具可以检查提示以确保一致性。**mypy**工具被广泛用于检查类型提示。
- en: 'If we don''t want to make the two arguments required, we can use the same syntax
    Python functions use to provide default arguments. The keyword argument syntax
    appends an equals sign after each variable name. If the calling object does not
    provide this argument, then the default argument is used instead. The variables
    will still be available to the function, but they will have the values specified
    in the argument list. Here''s an example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想提供所需的两个参数，可以使用Python函数提供默认参数时使用的相同语法。关键字参数语法在每个变量名后附加一个等号。如果调用对象没有提供此参数，则使用默认参数。这些变量仍然可用于函数，但它们将具有在参数列表中指定的值。以下是一个示例：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The definitions for the individual parameters can get long, leading to very
    long lines of code. In some examples, you''ll see this single logical line of
    code expanded to multiple physical lines. This relies on the way Python combines
    physical lines to match `()`''s. We might write this when the line gets long:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 单个参数的定义可能会变得很长，从而导致代码行数非常多。在一些示例中，你会看到这条单独的逻辑代码行被扩展成多个物理行。这依赖于Python将物理行组合起来匹配括号`()`的方式。当行变得很长时，我们可能会这样写：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This style isn't used very often, but it's valid and keeps the lines shorter
    and easier to read.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种样式并不常用，但它有效，并且可以使行距更短，更容易阅读。
- en: The type hints and defaults are handy, but there's even more we can do to provide
    a class that's easy to use and easy to extend when new requirements arise. We'll
    add documentation in the form of docstrings.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示和默认值非常方便，但当我们遇到新的需求时，我们还可以做更多来提供一个易于使用且易于扩展的类。我们将添加文档形式的docstrings。
- en: Explaining yourself with docstrings
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用文档字符串进行自我解释
- en: Python can be an extremely easy-to-read programming language; some might say
    it is self-documenting. However, when carrying out object-oriented programming,
    it is important to write API documentation that clearly summarizes what each object
    and method does. Keeping documentation up to date is difficult; the best way to
    do it is to write it right into our code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Python 可以是一种极其易于阅读的编程语言；有些人可能会说它是自文档化的。然而，在进行面向对象编程时，编写清晰总结每个对象和方法功能的 API 文档非常重要。保持文档更新是困难的；最好的方法是将文档直接写入我们的代码中。
- en: Python supports this through the use of **docstrings**. Each class, function,
    or method header can have a standard Python string as the first indented line
    inside the definition (the line that ends in a colon).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通过使用 **docstrings** 来支持这一点。每个类、函数或方法头都可以有一个标准的 Python 字符串作为定义内部的第一行缩进（以冒号结束的行）。
- en: Docstrings are Python strings enclosed within apostrophes (`'`) or quotation
    marks (`"`). Often, docstrings are quite long and span multiple lines (the style
    guide suggests that the line length should not exceed 80 characters), which can
    be formatted as multi-line strings, enclosed in matching triple apostrophe (`'''`)
    or triple quote (`"""`) characters.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Docstrings 是 Python 中用单引号 (`'`) 或双引号 (`"`) 包围的字符串。通常，文档字符串相当长，跨越多行（风格指南建议行长度不应超过
    80 个字符），可以格式化为多行字符串，用匹配的三重单引号 (`'''`) 或三重双引号 (`"""`) 包围。
- en: A docstring should clearly and concisely summarize the purpose of the class
    or method it is describing. It should explain any parameters whose usage is not
    immediately obvious, and is also a good place to include short examples of how
    to use the API. Any caveats or problems an unsuspecting user of the API should
    be aware of should also be noted.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个文档字符串应该清晰地简洁地总结所描述的类或方法的目的。它应该解释任何使用不明显的参数，并且也是包含API使用短示例的好地方。还应注明API用户应该注意的任何警告或问题。
- en: One of the best things to include in a docstring is a concrete example. Tools
    like **doctest** can locate and confirm these examples are correct. All the examples
    in this book are checked with the doctest tool.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档字符串中包含一个具体的例子是其中最好的做法之一。像**doctest**这样的工具可以定位并确认这些例子是否正确。本书中的所有例子都经过doctest工具的检查。
- en: 'To illustrate the use of docstrings, we will end this section with our completely
    documented `Point` class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明文档字符串的使用，我们将以我们完全文档化的`Point`类结束本节：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Try typing or loading (remember, it's `python -i point.py`) this file into the
    interactive interpreter. Then, enter `help(Point)<enter>` at the Python prompt.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在交互式解释器中输入或加载（记住，是`python -i point.py`）此文件。然后，在Python提示符下输入`help(Point)<enter>`。
- en: 'You should see nicely formatted documentation for the class, as shown in the
    following output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到格式良好的类文档，如下所示输出：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Not only is our documentation every bit as polished as the documentation for
    built-in functions, but we can run `python -m doctest point_2.py` to confirm the
    example shown in the docstring.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的文档不仅与内置函数的文档一样精致，而且我们可以通过运行`python -m doctest point_2.py`来确认文档字符串中显示的示例。
- en: Further, we can run **mypy** to check the type hints, also. Use `mypy –-strict
    src/*.py` to check all of the files in the `src` folder. If there are no problems,
    the **mypy** application doesn't produce any output. (Remember, **mypy** is not
    part of the standard installation, so you'll need to add it. Check the preface
    for information on extra packages that need to be installed.)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以运行 **mypy** 来检查类型提示，同样。使用 `mypy –-strict src/*.py` 来检查 `src` 文件夹中的所有文件。如果没有问题，**mypy**
    应用程序不会产生任何输出。（记住，**mypy** 不是标准安装的一部分，所以你需要将其添加。请参阅前言以获取有关需要安装的额外包的信息。）
- en: Modules and packages
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和包
- en: Now we know how to create classes and instantiate objects. You don't need to
    write too many classes (or non-object-oriented code, for that matter) before you
    start to lose track of them. For small programs, we generally put all our classes
    into one file and add a little script at the end of the file to start them interacting.
    However, as our projects grow, it can become difficult to find the one class that
    needs to be edited among the many classes we've defined. This is where **modules** come
    in. Modules are Python files, nothing more. The single file in our small program
    is a module. Two Python files are two modules. If we have two files in the same
    folder, we can load a class from one module for use in the other module.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何创建类和实例化对象。在你开始失去对这些类的跟踪之前，你不需要编写太多的类（或者更不用说非面向对象的代码了）。对于小型程序，我们通常将所有类放入一个文件中，并在文件末尾添加一个小脚本以启动它们之间的交互。然而，随着我们的项目增长，在定义的众多类中找到需要编辑的那个类可能会变得困难。这就是**模块**发挥作用的地方。模块就是Python文件，没有更多。我们小型程序中的单个文件就是一个模块。两个Python文件就是两个模块。如果我们有同一文件夹中的两个文件，我们就可以从一个模块中加载一个类，用于另一个模块。
- en: The Python module name is the file's *stem*; the name without the `.py` suffix.
    A file named `model.py` is a module named `model`. Module files are found by searching
    a path that includes the local directory and the installed packages.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Python模块的名称是文件的*基础名*；即不带`.py`后缀的名称。一个名为`model.py`的文件是一个名为`model`的模块。模块文件通过搜索包括本地目录和已安装包的路径来找到。
- en: The `import` statement is used for importing modules or specific classes or
    functions from modules. We've already seen an example of this in our `Point` class
    in the previous section. We used the `import` statement to get Python's built-in `math` module
    and use its `hypot()` function in the `distance` calculation. Let's start with
    a fresh example.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 语句用于导入模块或从模块中导入特定的类或函数。我们已经在上一节中通过我们的 `Point` 类看到了这个例子。我们使用 `import`
    语句来获取 Python 的内置 `math` 模块，并在 `distance` 计算中使用其 `hypot()` 函数。让我们从一个新的例子开始。'
- en: If we are building an e-commerce system, we will likely be storing a lot of
    data in a database. We can put all the classes and functions related to database
    access into a separate file (we'll call it something sensible: `database.py`).
    Then, our other modules (for example, customer models, product information, and
    inventory) can import classes from the `database` module in order to access the
    database.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在构建一个电子商务系统，我们很可能会在数据库中存储大量数据。我们可以将所有与数据库访问相关的类和函数放入一个单独的文件中（我们可以称它为有意义的名称：`database.py`）。然后，我们的其他模块（例如，客户模型、产品信息和库存）可以导入`database`模块中的类，以便访问数据库。
- en: Let's start with a module called `database`. It's a file, `database.py`, containing
    a class called `Database`. A second module called `products` is responsible for
    product-related queries. The classes in the `products` module need to instantiate
    the `Database` class from the `database` module so that they can execute queries
    on the product table in the database.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从名为 `database` 的模块开始。它是一个文件，`database.py`，包含一个名为 `Database` 的类。另一个名为 `products`
    的模块负责与产品相关的查询。`products` 模块中的类需要从 `database` 模块实例化 `Database` 类，这样它们才能在数据库中的产品表上执行查询。
- en: 'There are several variations on the `import` statement syntax that can be used
    to access the `Database` class. One variant is to import the module as a whole:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 语句的语法有多种变体，可以用来访问 `Database` 类。一种变体是将整个模块导入：'
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This version imports the `database` module, creating a `database` namespace.
    Any class or function in the `database` module can be accessed using the `database.<something>` notation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此版本导入`database`模块，创建一个`database`命名空间。`database`模块中的任何类或函数都可以使用`database.<something>`的表示法进行访问。
- en: 'Alternatively, we can import just the one class we need using the `from...import`
    syntax:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`from...import`语法只导入所需的那个类：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This version imported only the `Database` class from the `database` module.
    When we have a few items from a few modules, this can be a helpful simplification
    to avoid using longer, fully qualified names like `database.Database`. When we
    import a number of items from a number of different modules, this can be a potential
    source of confusion when we omit the qualifiers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本只从`database`模块导入了`Database`类。当我们从几个模块中导入少量项目时，这可以是一个有用的简化，以避免使用较长的完全限定名称，如`database.Database`。当我们从多个不同的模块中导入大量项目时，如果我们省略了限定词，这可能会成为混淆的潜在来源。
- en: 'If, for some reason, `products` already has a class called `Database`, and
    we don''t want the two names to be confused, we can rename the class when used
    inside the `products` module:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，`products` 已经有一个名为 `Database` 的类，而我们又不想这两个名称混淆，我们可以在 `products` 模块内部使用时重命名该类：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can also import multiple items in one statement. If our `database` module
    also contains a `Query` class, we can import both classes using the following
    code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在一个语句中导入多个项目。如果我们`database`模块也包含一个`Query`类，我们可以使用以下代码同时导入这两个类：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can import all classes and functions from the `database` module using this
    syntax:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种语法从`database`模块导入所有类和函数：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Don''t do this.** Most experienced Python programmers will tell you that
    you should never use this syntax (a few will tell you there are some very specific
    situations where it is useful, but we can disagree). One way to learn why to avoid
    this syntax is to use it and try to understand your code two years later. We can
    save some time and two years of poorly written code with a quick explanation now!'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要这样做**。大多数经验丰富的 Python 程序员会告诉你永远不应该使用这种语法（有些人会告诉你有一些非常具体的情况下它是有用的，但我们可以有不同的看法）。学习为什么要避免这种语法的一种方法就是使用它，然后尝试在两年后理解你的代码。现在快速解释一下，我们可以节省一些时间和避免两年糟糕的代码！'
- en: 'We''ve got several reasons for avoiding this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免这样做有几个原因：
- en: When we explicitly import the `database` class at the top of our file using `from
    database import Database`, we can easily see where the `Database` class comes
    from. We might use `db = Database()` 400 lines later in the file, and we can quickly
    look at the imports to see where that `Database` class came from. Then, if we
    need clarification as to how to use the `Database` class, we can visit the original
    file (or import the module in the interactive interpreter and use the `help(database.Database)`
    command). However, if we use the `from database import *` syntax, it takes a lot
    longer to find where that class is located. Code maintenance becomes a nightmare.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用 `from database import Database` 在文件顶部显式导入 `database` 类时，我们可以轻松地看到 `Database`
    类的来源。我们可能在文件中400行后使用 `db = Database()`，然后可以快速查看导入以确定那个 `Database` 类的来源。然后，如果我们需要关于如何使用
    `Database` 类的澄清，我们可以访问原始文件（或在交互式解释器中导入模块并使用 `help(database.Database)` 命令）。然而，如果我们使用
    `from database import *` 语法，找到那个类所在位置的时间会大大增加。代码维护变得如同噩梦一般。
- en: If there are conflicting names, we're doomed. Let's say we have two modules,
    both of which provide a class named `Database`. Using `from module_1 import *`
    and `from module_2 import *` means the second import statement overwrites the
    `Database` name created by the first import. If we used `import module_1` and
    `import module_2`, we'd use the module names as qualifiers to disambiguate `module_1.Database`
    from `module_2.Database`.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在冲突的名称，我们就注定要失败了。假设我们有两个模块，它们都提供了一个名为`Database`的类。使用`from module_1 import
    *`和`from module_2 import *`意味着第二个导入语句会覆盖第一个导入创建的`Database`名称。如果我们使用`import module_1`和`import
    module_2`，我们会使用模块名称作为限定符来区分`module_1.Database`和`module_2.Database`。
- en: In addition, most code editors are able to provide extra functionality, such
    as reliable code completion, the ability to jump to the definition of a class,
    or inline documentation, if normal imports are used. The `import *` syntax can
    hamper their ability to do this reliably.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，大多数代码编辑器都能够提供额外的功能，例如可靠的代码补全、跳转到类定义的能力，或者内联文档，如果使用正常的导入语句的话。`import *` 语法可能会妨碍它们可靠地执行这些功能。
- en: Finally, using the `import *` syntax can bring unexpected objects into our local
    namespace. Sure, it will import all the classes and functions defined in the module
    being imported from, but unless a special `__all__` list is provided in the module,
    this `import` will also import any classes or modules that were themselves imported
    into that file!
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用 `import *` 语法可能会将意外的对象引入我们的局部命名空间。当然，它将导入从导入的模块中定义的所有类和函数，但除非模块中提供了特殊的
    `__all__` 列表，否则这个 `import` 也会导入任何自身被导入到该文件中的类或模块！
- en: Every name used in a module should come from a well-specified place, whether
    it is defined in that module, or explicitly imported from another module. There
    should be no magic variables that seem to come out of thin air. We should *always* be
    able to immediately identify where the names in our current namespace originated.
    We promise that if you use this evil syntax, you will one day have extremely frustrating
    moments of *where on earth can this class be coming from?*
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块中使用的每个名称都应该来自一个明确指定的位置，无论是定义在该模块中，还是明确从另一个模块导入。不应该存在看似凭空出现的魔法变量。我们应当始终能够立即识别出我们当前命名空间中名称的来源。我们承诺，如果你使用这种邪恶的语法，你总有一天会经历极其令人沮丧的时刻，比如“这个类究竟是从哪里冒出来的？”
- en: For fun, try typing `import this` into your interactive interpreter. It prints
    a nice poem (with a couple of inside jokes) summarizing some of the idioms that
    Pythonistas tend to practice. Specific to this discussion, note the line "Explicit
    is better than implicit." Explicitly importing names into your namespace makes
    your code much easier to navigate than the implicit `from module import *` syntax.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了娱乐，试着在你的交互式解释器中输入`import this`。它会打印一首优美的诗（包含一些内部玩笑），总结了一些Python程序员倾向于使用的惯用语。具体到这次讨论，请注意这句“明确优于隐晦。”明确地将名称导入你的命名空间，比隐式的`from
    module import *`语法使你的代码更容易导航。
- en: Organizing modules
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织模块
- en: As a project grows into a collection of more and more modules, we may find that
    we want to add another level of abstraction, some kind of nested hierarchy on
    our modules' levels. However, we can't put modules inside modules; one file can
    hold only one file after all, and modules are just files.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目逐渐发展成为一个包含越来越多模块的集合，我们可能会发现我们想要添加另一个抽象层级，在我们的模块层级上某种嵌套的层次结构。然而，我们不能在模块中嵌套模块；毕竟，一个文件只能包含一个文件，而模块只是文件。
- en: Files, however, can go in folders, and so can modules. A **package** is a collection
    of modules in a folder. The name of the package is the name of the folder. We
    need to tell Python that a folder is a package to distinguish it from other folders
    in the directory. To do this, place a (normally empty) file in the folder named `__init__.py`.
    If we forget this file, we won't be able to import modules from that folder.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，文件可以放入文件夹中，模块也是如此。一个**包**是一个文件夹中模块的集合。包的名称就是文件夹的名称。我们需要告诉Python一个文件夹是一个包，以便将其与其他目录中的文件夹区分开来。为此，在文件夹中放置一个名为`__init__.py`的（通常是空的）文件。如果我们忘记了这个文件，我们就无法从这个文件夹中导入模块。
- en: Let's put our modules inside an `ecommerce` package in our working folder, which
    will also contain a `main.py` file to start the program. Let's additionally add
    another package inside the `ecommerce` package for various payment options.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的模块放在工作文件夹内的`ecommerce`包中，这个包也将包含一个`main.py`文件以启动程序。另外，我们还在`ecommerce`包内添加了一个包，用于各种支付选项。
- en: We need to exercise some caution in creating deeply nested packages. The general
    advice in the Python community is "flat is better than nested." In this example,
    we need to create a nested package because there are some common features to all
    of the various payment alternatives.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建深度嵌套的包时，我们需要保持一定的谨慎。Python 社区的一般建议是“扁平优于嵌套”。在这个例子中，我们需要创建一个嵌套包，因为所有各种支付替代方案都有一些共同特性。
- en: 'The folder hierarchy will look like this, rooted under a directory in the project
    folder, commonly named `src`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹层次结构将如下所示，根目录位于项目文件夹中的一个目录下，通常命名为 `src`：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `src` directory will be part of an overall project directory. In addition
    to `src`, the project will often have directories with names like `docs` and `tests`.
    It's common for the project parent directory to also have configuration files
    for tools like **mypy** among others. We'll return to this in *Chapter 13*, *Testing
    Object-Oriented Programs*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`src` 目录将作为整体项目目录的一部分。除了 `src`，项目通常还会有名为 `docs` 和 `tests` 等的目录。项目父目录通常还会包含为
    **mypy** 等工具的配置文件。我们将在 *第 13 章*，*面向对象程序的测试* 中回到这一点。'
- en: 'When importing modules or classes between packages, we have to be cautious
    about the structure of our packages. In Python 3, there are two ways of importing
    modules: absolute imports and relative imports. We''ll look at each of them separately.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当在包之间导入模块或类时，我们必须谨慎对待我们包的结构。在Python 3中，有两种导入模块的方式：绝对导入和相对导入。我们将分别探讨每一种。
- en: Absolute imports
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绝对导入
- en: '**Absolute imports** specify the complete path to the module, function, or
    class we want to import. If we need access to the `Product` class inside the `products` module,
    we could use any of these syntaxes to perform an absolute import:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**绝对导入**指定了我们想要导入的模块、函数或类的完整路径。如果我们需要访问`products`模块内的`Product`类，我们可以使用以下任何一种语法来进行绝对导入：'
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Or, we could specifically import a single class definition from the module
    within a package:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在包内从模块中具体导入一个类定义：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Or, we could import an entire module from the containing package:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以从包含的包中导入整个模块：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `import` statements use the period operator to separate packages or modules.
    A package is a namespace that contains module names, much in the way an object
    is a namespace containing attribute names.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句使用点操作符来分隔包或模块。包是一个包含模块名称的命名空间，就像对象是一个包含属性名称的命名空间一样。'
- en: These statements will work from any module. We could instantiate a `Product` class
    using this syntax in `main.py`, in the `database` module, or in either of the
    two payment modules. Indeed, assuming the packages are available to Python, it
    will be able to import them. For example, the packages can also be installed in
    the Python `site-packages` folder, or the `PYTHONPATH` environment variable could
    be set to tell Python which folders to search for packages and modules it is going
    to import.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句可以在任何模块中工作。我们可以在`main.py`文件中的`database`模块，或者两个支付模块中的任何一个中使用这种语法实例化一个`Product`类。实际上，假设这些包对Python可用，它将能够导入它们。例如，这些包也可以安装到Python的`site-packages`文件夹中，或者可以将`PYTHONPATH`环境变量设置为告诉Python搜索哪些文件夹以查找它将要导入的包和模块。
- en: With these choices, which syntax do we choose? It depends on your audience and
    the application at hand. If there are dozens of classes and functions inside the
    `products` module that we want to use, we'd generally import the module name using
    the `from ecommerce import products` syntax, and then access the individual classes
    using `products.Product`. If we only need one or two classes from the `products` module,
    we can import them directly using the `from ecommerce.products import Product` syntax.
    It's important to write whatever makes the code easiest for others to read and
    extend.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些选择中，我们该选择哪种语法？这取决于你的受众和当前的应用。如果我们想使用`products`模块中的几十个类和函数，我们通常会使用`from ecommerce
    import products`语法来导入模块名称，然后使用`products.Product`来访问单个类。如果我们只需要`products`模块中的一个或两个类，我们可以直接使用`from
    ecommerce.products import Product`语法来导入。重要的是要编写使代码对他人来说最容易阅读和扩展的内容。
- en: Relative imports
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相对导入
- en: When working with related modules inside a deeply nested package, it seems kind
    of redundant to specify the full path; we know what our parent module is named.
    This is where **relative imports** come in. Relative imports identify a class,
    function, or module as it is positioned relative to the current module. They only
    make sense inside module files, and, further, they only make sense where there's
    a complex package structure.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当在深度嵌套的包内部处理相关模块时，指定完整路径似乎有些多余；我们知道我们的父模块叫什么名字。这就是相对导入发挥作用的地方。相对导入根据相对于当前模块的位置来识别类、函数或模块。它们仅在模块文件中才有意义，而且更进一步，它们仅在存在复杂包结构的地方才有意义。
- en: 'For example, if we are working in the `products` module and we want to import
    the `Database` class from the `database` module next to it, we could use a relative
    import:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们正在`products`模块中工作，并且想要从相邻的`database`模块导入`Database`类，我们可以使用相对导入：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The period in front of `database` says *use the database module inside the current
    package*. In this case, the current package is the package containing the `products.py` file
    we are currently editing, that is, the `ecommerce` package.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在`database`前的时期表示*使用当前包内的数据库模块*。在这种情况下，当前包是我们正在编辑的`products.py`文件所在的包，即`ecommerce`包。
- en: 'If we were editing the `stripe` module inside the `ecommerce.payments` package,
    we would want, for example, to *use the database package inside the parent package* instead.
    This is easily done with two periods, as shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要编辑位于`ecommerce.payments`包内的`stripe`模块，例如，我们可能希望*使用父包内的数据库包*。这可以通过使用两个点轻松实现，如下所示：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can use more periods to go further up the hierarchy, but at some point,
    we have to acknowledge that we have too many packages. Of course, we can also
    go down one side and back up the other. The following would be a valid import
    from the `ecommerce.contact` package containing an `email` module if we wanted
    to import the `send_mail` function into our `payments.stripe` module:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用更多的点来进入更高级别的层次，但到了某个阶段，我们必须承认我们拥有太多的包。当然，我们也可以沿着一边向下，然后再从另一边向上。如果我们想将`send_mail`函数导入到我们的`payments.stripe`模块中，以下将是从`ecommerce.contact`包中导入的有效导入，其中包含一个`email`模块：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This import uses two periods indicating *the parent of the payments.stripe package*,
    and then uses the normal `package.module` syntax to go back down into the `contact`
    package to name the `email` module.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导入使用了两个点来表示*`payments.stripe`包的父包*，然后使用正常的`package.module`语法向下进入`contact`包，以命名`email`模块。
- en: Relative imports aren't as useful as they might seem. As mentioned earlier,
    the *Zen of Python* (you can read it when you run `import this`) suggests "flat
    is better than nested". Python's standard library is relatively flat, with few
    packages and even fewer nested packages. If you're familiar with Java, the packages
    are deeply nested, something the Python community likes to avoid. A relative import
    is needed to solve a specific problem where module names are reused among packages.
    They can be helpful in a few cases. Needing more than two dots to locate a common
    parent-of-a-parent package suggests the design should be flattened out.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Packages as a whole
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为整体的包
- en: We can import code that appears to come directly from a package, as opposed
    to a module inside a package. As we'll see, there's a module involved, but it
    has a special name, so it's hidden. In this example, we have an `ecommerce` package
    containing two module files named `database.py` and `products.py`. The `database`
    module contains a `db` variable that is accessed from a lot of places. Wouldn't
    it be convenient if this could be imported as `from ecommerce import db` instead
    of `from ecommerce.database import db``?`
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the `__init__.py` file that defines a directory as a package? This
    file can contain any variable or class declarations we like, and they will be
    available as part of the package. In our example, if the `ecommerce/__init__.py` file
    contained the following line:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 记得那个定义目录为包的`__init__.py`文件吗？这个文件可以包含我们喜欢的任何变量或类声明，它们将作为包的一部分可用。在我们的例子中，如果`ecommerce/__init__.py`文件包含以下行：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We could then access the `db` attribute from `main.py` or any other file using
    the following import:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以随后从`main.py`或任何其他文件中通过以下导入访问`db`属性：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It might help to think of the `ecommerce/__init__.py` file as if it were the
    `ecommerce.py` file. It lets us view the `ecommerce` package as having a module
    protocol as well as a package protocol. This can also be useful if you put all
    your code in a single module and later decide to break it up into a package of
    modules. The `__init__.py` file for the new package can still be the main point
    of contact for other modules using it, but the code can be internally organized
    into several different modules or subpackages.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: We recommend not putting much code in an `__init__.py` file, though. Programmers
    do not expect actual logic to happen in this file, and much like with `from x
    import *`, it can trip them up if they are looking for the declaration of a particular
    piece of code and can't find it until they check `__init__.py`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: After looking at modules in general, let's dive into what should be inside a
    module. The rules are flexible (unlike other languages). If you're familiar with
    Java, you'll see that Python gives you some freedom to bundle things in a way
    that's meaningful and informative.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Organizing our code in modules
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的代码组织成模块
- en: 'The Python module is an important focus. Every application or web service has
    at least one module. Even a seemingly "simple" Python script is a module. Inside
    any one module, we can specify variables, classes, or functions. They can be a
    handy way to store the global state without namespace conflicts. For example,
    we have been importing the `Database` class into various modules and then instantiating
    it, but it might make more sense to have only one `database` object globally available
    from the `database` module. The `database` module might look like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then we can use any of the import methods we''ve discussed to access the `database`
    object, for example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'A problem with the preceding class is that the `database` object is created
    immediately when the module is first imported, which is usually when the program
    starts up. This isn''t always ideal, since connecting to a database can take a
    while, slowing down startup, or the database connection information may not yet
    be available because we need to read a configuration file. We could delay creating
    the database until it is actually needed by calling an `initialize_database()` function
    to create a module-level variable:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `Optional[Database]` type hint signals to the **mypy** tool that this may
    be `None` or it may have an instance of the `Database` class. The `Optional` hint
    is defined in the `typing` module. This hint can be handy elsewhere in our application
    to make sure we confirm that the value for the `database` variable is not `None`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The `global` keyword tells Python that the database variable inside `initialize_database()`
    is the module-level variable, outside the function. If we had not specified the
    variable as global, Python would have created a new local variable that would
    be discarded when the function exits, leaving the module-level value unchanged.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: We need to make one additional change. We need to import the `database` module
    as a whole. We can't import the `db` object from inside the module; it might not
    have been initialized. We need to be sure `database.initialize_database()` is
    called before `db` will have a meaningful value. If we wanted direct access to
    the database object, we'd use `database.db`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'A common alternative is a function that returns the current database object.
    We could import this function everywhere we needed access to the database:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As these examples illustrate, all module-level code is executed immediately
    at the time it is imported. The `class` and `def` statements create code objects
    to be executed later when the function is called. This can be a tricky thing for
    scripts that perform execution, such as the main script in our e-commerce example.
    Sometimes, we write a program that does something useful, and then later find
    that we want to import a function or class from that module into a different program.
    However, as soon as we import it, any code at the module level is immediately
    executed. If we are not careful, we can end up running the first program when
    we really only meant to access a couple of functions inside that module.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, we should always put our startup code in a function (conventionally,
    called `main()`) and only execute that function when we know we are running the
    module as a script, but not when our code is being imported from a different script.
    We can do this by **guarding** the call to `main` inside a conditional statement,
    demonstrated as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `Point` class (and the `main()` function) can be reused without worry. We
    can import the contents of this module without any surprising processing happening.
    When we run it as a main program, however, it executes the `main()` function.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: This works because every module has a `__name__` special variable (remember,
    Python uses double underscores for special variables, such as a class' `__init__` method)
    that specifies the name of the module when it was imported. When the module is
    executed directly with `python module.py`, it is never imported, so the `__name__` is
    arbitrarily set to the `"__main__"` string.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Make it a policy to wrap all your scripts in an `if __name__ == "__main__"``:` test,
    just in case you write a function that you may want to be imported by other code
    at some point in the future.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: So, methods go in classes, which go in modules, which go in packages. Is that
    all there is to it?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, no. This is the typical order of things in a Python program, but
    it''s not the only possible layout. Classes can be defined anywhere. They are
    typically defined at the module level, but they can also be defined inside a function
    or method, like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We've defined a `Formatter` class as an abstraction to explain what a formatter
    class needs to have. We haven't used the abstract base class (abc) definitions
    (we'll look at these in detail in *Chapter 6*, *Abstract Base Classes and Operator
    Overloading*). Instead, we've provided the method with no useful body. It has
    a full suite of type hints, to make sure **mypy** has a formal definition of our
    intent.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Within the `format_string()` function, we created an internal class that is
    an extension of the `Formatter` class. This formalizes the expectation that our
    class inside the function has a specific set of methods. This connection between
    the definition of the `Formatter` class, the `formatter` parameter, and the concrete
    definition of the `DefaultFormatter` class assures that we haven't accidentally
    forgotten something or added something.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'We can execute this function like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `format_string` function accepts a string and optional `Formatter` object
    and then applies the formatter to that string. If no `Formatter` instance is supplied,
    it creates a formatter of its own as a local class and instantiates it. Since
    it is created inside the scope of the function, this class cannot be accessed
    from anywhere outside of that function. Similarly, functions can be defined inside
    other functions as well; in general, any Python statement can be executed at any
    time.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: These inner classes and functions are occasionally useful for one-off items
    that don't require or deserve their own scope at the module level, or only make
    sense inside a single method. However, it is not common to see Python code that
    frequently uses this technique.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how to create classes and how to create modules. With these core
    techniques, we can start thinking about writing useful, helpful software to solve
    problems. When the application or service gets big, though, we often have boundary
    issues. We need to be sure that objects respect each other's privacy and avoid
    confusing entanglements that make complex software into a spaghetti bowl of interrelationships.
    We'd prefer each class to be a nicely encapsulated ravioli. Let's look at another
    aspect of organizing our software to create a good design.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Who can access my data?
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most object-oriented programming languages have a concept of **access control**.
    This is related to abstraction. Some attributes and methods on an object are marked
    private, meaning only that object can access them. Others are marked protected,
    meaning only that class and any subclasses have access. The rest are public, meaning
    any other object is allowed to access them.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Python doesn't do this. Python doesn't really believe in enforcing laws that
    might someday get in your way. Instead, it provides unenforced guidelines and
    best practices. Technically, all methods and attributes on a class are publicly
    available. If we want to suggest that a method should not be used publicly, we
    can put a note in docstrings indicating that the method is meant for internal
    use only (preferably, with an explanation of how the public-facing API works!).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: We often remind each other of this by saying "We're all adults here." There's
    no need to declare a variable as private when we can all see the source code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: By convention, we generally prefix an internal attribute or method with an underscore
    character, `_`. Python programmers will understand a leading underscore name to
    mean *this is an internal variable, think three times before accessing it directly*.
    But there is nothing inside the interpreter to stop them from accessing it if
    they think it is in their best interest to do so. Because, if they think so, why
    should we stop them? We may not have any idea what future uses our classes might
    be put to, and it may be removed in a future release. It's a pretty clear warning
    sign to avoid using it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s another thing you can do to strongly suggest that outside objects
    don''t access a property or method: prefix it with a double underscore, `__`.
    This will perform **name mangling** on the attribute in question. In essence,
    name mangling means that the method can still be called by outside objects if
    they really want to do so, but it requires extra work and is a strong indicator
    that you demand that your attribute remains **private**.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: When we use a double underscore, the property is prefixed with `_<classname>`.
    When methods in the class internally access the variable, they are automatically
    unmangled. When external classes wish to access it, they have to do the name mangling
    themselves. So, name mangling does not guarantee privacy; it only strongly recommends
    it. This is very rarely used, and often a source of confusion when it is used.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Don't create new double-underscore names in your own code, it will only cause
    grief and heartache. Consider this reserved for Python's internally defined special
    names.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: What's important is that encapsulation – as a design principle – assures that
    the methods of a class encapsulate the state changes for the attributes. Whether
    or not attributes (or methods) are private doesn't change the essential good design
    that flows from encapsulation.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The encapsulation principle applies to individual classes as well as a module
    with a bunch of classes. It also applies to a package with a bunch of modules.
    As designers of object-oriented Python, we're isolating responsibilities and clearly
    encapsulating features.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: And, of course, we're using Python to solve problems. It turns out there's a
    huge standard library available to help us create useful software. The vast standard
    library is why we describe Python as a "batteries included" language. Right out
    of the box, you have almost everything you need, no running to the store to buy
    batteries.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Outside the standard library, there's an even larger universe of third-party
    packages. In the next section, we'll look at how we extend our Python installation
    with even more ready-made goodness.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Third-party libraries
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python ships with a lovely standard library, which is a collection of packages
    and modules that are available on every machine that runs Python. However, you''ll
    soon find that it doesn''t contain everything you need. When this happens, you
    have two options:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Write a supporting package yourself
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use somebody else's code
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won't be covering the details about turning your packages into libraries,
    but if you have a problem you need to solve and you don't feel like coding it
    (the best programmers are extremely lazy and prefer to reuse existing, proven
    code, rather than write their own), you can probably find the library you want
    on the **Python Package Index** (**PyPI**) at [http://pypi.python.org/](http://pypi.python.org/).
    Once you've identified a package that you want to install, you can use a tool
    called `pip` to install it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install packages using an operating system command such as the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If you try this without making any preparation, you'll either be installing
    the third-party library directly into your system Python directory, or, more likely,
    will get an error that you don't have permission to update the system Python.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The common consensus in the Python community is that you don't touch any Python
    that's part of the OS. Older Mac OS X releases had a Python 2.7 installed. This
    was not really available for end users. It's best to think of it as part of the
    OS; and ignore it and always install a fresh, new Python.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Python ships with a tool called `venv`, a utility that gives you a Python installation
    called a **virtual environment** in your working directory. When you activate
    this environment, commands related to Python will work with your virtual environment''s
    Python instead of the system Python. So, when you run `pip` or `python`, it won''t
    touch the system Python at all. Here''s how to use it:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: (For other OSes, see [https://docs.python.org/3/library/venv.html](https://docs.python.org/3/library/venv.html),
    which has all the variations required to activate the environment.)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Once the virtual environment is activated, you are assured that `python -m pip`
    will install new packages into the virtual environment, leaving any OS Python
    alone. You can now use the `python -m pip install mypy` command to add the **mypy**
    tool to your current virtual environment.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: On a home computer – where you have access to the privileged files – you can
    sometimes get away with installing and working with a single, centralized system-wide
    Python. In an enterprise computing environment, where system-wide directories
    require special privileges, a virtual environment is required. Because the virtual
    environment approach always works, and the centralized system-level approach doesn't
    always work, it's generally a best practice to create and use virtual environments.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: It's typical to create a different virtual environment for each Python project.
    You can store your virtual environments anywhere, but a good practice is to keep
    them in the same directory as the rest of the project files. When working with
    version control tools like **Git**, the `.gitignore` file can make sure your virtual
    environments are not checked into the Git repository.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: When starting something new, we often create the directory, and then `cd` into
    that directory. Then, we'll run the `python -m venv env` utility to create a virtual
    environment, usually with a simple name like `env`, and sometimes with a more
    complex name like `CaseStudy39`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can use one of the last two lines in the preceding code (depending
    on the operating system, as indicated in the comments) to activate the environment.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Each time we do some work on a project, we can `cd` to the directory and execute
    the `source` (or `activate.bat`) line to use that particular virtual environment.
    When switching projects, a `deactivate` command unwinds the environment setup.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Virtual environments are essential for keeping your third-party dependencies
    separate from Python's standard library. It is common to have different projects
    that depend on different versions of a particular library (for example, an older
    website might run on Django 1.8, while newer versions run on Django 2.1). Keeping
    each project in separate virtual environments makes it easy to work in either
    version of Django. Furthermore, it prevents conflicts between system-installed
    packages and `pip`-installed packages if you try to install the same package using
    different tools. Finally, it bypasses any OS permission restrictions surrounding
    the OS Python.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: There are several third-party tools for managing virtual environments effectively.
    Some of these include `virtualenv`, `pyenv`, `virtualenvwrapper`, and `conda`.
    If you're working in a data science environment, you'll probably need to use `conda`
    so you can install more complex packages. There are a number of features leading
    to a lot of different approaches to solving the problem of managing the huge Python
    ecosystem of third-party packages.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Case study
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section expands on the object-oriented design of our realistic example.
    We'll start with the diagrams created using the **Unified Modeling Language**
    (**UML**) to help depict and summarize the software we're going to build.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: We'll describe the various considerations that are part of the Python implementation
    of the class definitions. We'll start with a review of the diagrams that describe
    the classes to be defined.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Logical view
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the overview of the classes we need to build. This is (except for one
    new method) the previous chapter''s model:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_02_02.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Logical view diagram'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three classes that define our core data model, plus some uses of
    the generic list class. We''ve shown it using the type hint of `List`. Here are
    the four central classes:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The `TrainingData` class is a container with two lists of data samples, a list
    used for training our model and a list used for testing our model. Both lists
    are composed of `KnownSample` instances. Additionally, we'll also have a list
    of alternative `Hyperparameter` values. In general, these are tuning values that
    change the behavior of the model. The idea is to test with different hyperparameters
    to locate the highest-quality model.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve also allocated a little bit of metadata to this class: the name of the
    data we''re working with, the datetime of when we uploaded the data the first
    time, and the datetime of when we ran a test against the model.'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Each instance of the `Sample` class is the core piece of working data. In our
    example, these are measurements of sepal lengths and widths and petal lengths
    and widths. Steady-handed botany graduate students carefully measured lots and
    lots of flowers to gather this data. We hope that they had time to stop and smell
    the roses while they were working.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `KnownSample` object is an extended `Sample`. This part of the design foreshadows
    the focus of *Chapter 3*, *When Objects Are Alike*. A `KnownSample` is a `Sample`
    with one extra attribute, the assigned species. This information comes from skilled
    botanists who have classified some data we can use for training and testing.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Hyperparameter` class has the *k* used to define how many of the nearest
    neighbors to consider. It also has a summary of testing with this value of *k*.
    The quality tells us how many of the test samples were correctly classified. We
    expect to see that small values of *k* (like 1 or 3) don't classify well. We expect
    middle values of *k* to do better, and very large values of *k* to not do as well.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `KnownSample` class on the diagram may not need to be a separate class definition.
    As we work through the details, we'll look at some alternative designs for each
    of these classes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the `Sample` (and `KnownSample`) classes. Python offers three
    essential paths for defining a new class:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: A `class` definition; we'll focus on this to start.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `@dataclass` definition. This provides a number of built-in features. While
    it's handy, it's not ideal for programmers who are new to Python, because it can
    obscure some implementation details. We'll set this aside for *Chapter 7*, *Python
    Data Structures*.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An extension to the `typing.NamedTuple` class. The most notable feature of this
    definition will be that the state of the object is immutable; the attribute values
    cannot be changed. Unchanging attributes can be a useful feature for making sure
    a bug in the application doesn't mess with the training data. We'll set this aside
    for *Chapter 7*, also.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our first design decision is to use Python's `class` statement to write a class
    definition for `Sample` and its subclass `KnownSample`. This may be replaced in
    the future (i.e., *Chapter 7*) with alternatives that use data classes as well
    as `NamedTuple`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Samples and their states
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The diagram in *Figure 2.2* shows the `Sample` class and an extension, the
    `KnownSample` class. This doesn''t seem to be a complete decomposition of the
    various kinds of samples. When we review the user stories and the process views,
    there seems to be a gap: specifically, the "make classification request" by a
    User requires an unknown sample. This has the same flower measurements attributes
    as a `Sample`, but doesn''t have the assigned species attribute of a `KnownSample`.
    Further, there''s no state change that adds an attribute value. The unknown sample
    will never be formally classified by a Botanist; it will be classified by our
    algorithm, but it''s only an AI, not a Botanist.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make a case for two distinct subclasses of `Sample`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '`UnknownSample`: This class contains the initial four `Sample` attributes.
    A User provides these objects to get them classified.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KnownSample`: This class has the `Sample` attributes plus the classification
    result, a species name. We use these for training and testing the model.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, we consider class definitions as a way to encapsulate state and behavior.
    An `UnknownSample` instance provided by a user starts out with no species. Then,
    after the classifier algorithm computes a species, the `Sample` changes state
    to have a species assigned by the algorithm.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'A question we must always ask about class definitions is this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '**Is there any change in behavior that goes with the change in state?**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: In this case, it doesn't seem like there's anything new or different that can
    happen. Perhaps this can be implemented as a single class with some optional attributes.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: We have another possible state change concern. Currently, there's no class that
    owns the responsibility of partitioning `Sample` objects into the training or
    testing subsets. This, too, is a kind of state change.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to a second important question:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '**What class has responsibility for making this state change?**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: In this case, it seems like the `TrainingData` class should own the discrimination
    between testing and training data.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: One way to help look closely at our class design is to enumerate all of the
    various states of individual samples. This technique helps uncover a need for
    attributes in the classes. It also helps to identify the methods to make state
    changes to objects of a class.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Sample state transitions
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the life cycles of `Sample` objects. An object''s life cycle
    starts with object creation, then state changes, and (in some cases) the end of
    its processing life when there are no more references to it. We have three scenarios:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '**Initial load**: We''ll need a `load()` method to populate a `TrainingData` object
    from some source of raw data. We''ll preview some of the material in *Chapter
    9*, *Strings, Serialization, and File Paths*, by saying that reading a CSV file
    often produces a sequence of dictionaries. We can imagine a `load()` method using
    a CSV reader to create `Sample` objects with a species value, making them `KnownSample`
    objects. The `load()` method splits the `KnownSample` objects into the training
    and testing lists, which is an important state change for a `TrainingData` object.'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hyperparameter testing**: We''ll need a `test()` method in the `Hyperparameter` class.
    The body of the `test()` method works with the test samples in the associated `TrainingData`
    object. For each sample, it applies the classifier and counts the matches between
    Botanist-assigned species and the best guess of our AI algorithm. This points
    out the need for a `classify()` method for a single sample that''s used by the `test()` method
    for a batch of samples. The `test()` method will update the state of the `Hyperparameter` object
    by setting the quality score.'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**User-initiated classification**: A RESTful web application is often decomposed
    into separate view functions to handle requests. When handling a request to classify
    an unknown sample, the view function will have a `Hyperparameter` object used
    for classification; this will be chosen by the Botanist to produce the best results.
    The user input will be an `UnknownSample` instance. The view function applies
    the `Hyperparameter.classify()` method to create a response to the user with the
    species the iris has been classed as. Does the state change that happens when
    the AI classifies an `UnknownSample` really matter? Here are two views:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each `UnknownSample` can have a `classified` attribute. Setting this is a change
    in the state of the `Sample`. It's not clear that there's any behavior change
    associated with this state change.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The classification result is not part of the `Sample` at all. It's a local variable
    in the view function. This state change in the function is used to respond to
    the user, but has no life within the `Sample` object.
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s a key concept underlying this detailed decomposition of these alternatives:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '**There''s no "right" answer.**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Some design decisions are based on non-functional and non-technical considerations.
    These might include the longevity of the application, future use cases, additional
    users who might be enticed, current schedules and budgets, pedagogical value,
    technical risk, the creation of intellectual property, and how cool the demo will
    look in a conference call.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 1*, *Object-Oriented Design*, we dropped a hint that this application
    is the precursor to a consumer product recommender. We noted: "The users eventually
    want to tackle complex consumer products, but recognize that solving a difficult
    problem is not a good way to learn how to build this kind of application. It''s
    better to start with something of a manageable level of complexity and then refine
    and expand it until it does everything they need."'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Because of that, we'll consider a change in state from `UnknownSample` to `ClassifiedSample` to
    be very important. The `Sample` objects will live in a database for additional
    marketing campaigns or possibly reclassification when new products are available
    and the training data changes.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: We'll decide to keep the classification and the species data in the `UnknownSample` class.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'This analysis suggests we can coalesce all the various `Sample` details into
    the following design:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_02_03.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: The updated UML diagram'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: This view uses the open arrowhead to show a number of subclasses of `Sample`.
    We won't directly implement these as subclasses. We've included the arrows to
    show that we have some distinct use cases for these objects. Specifically, the
    box for `KnownSample` has a condition **species is not None** to summarize what's
    unique about these `Sample` objects. Similarly, the `UnknownSample` has a condition,
    **species is None**, to clarify our intent around `Sample` objects with the species
    attribute value of `None`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: In these UML diagrams, we have generally avoided showing Python's "special"
    methods. This helps to minimize visual clutter. In some cases, a special method
    may be absolutely essential, and worthy of showing in a diagram. An implementation
    almost always needs to have an `__init__()` method.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s another special method that can really help: the  `__repr__()` method
    is used to create a representation of the object. This representation is a string
    that generally has the syntax of a Python expression to rebuild the object. For
    simple numbers, it''s the number. For a simple string, it will include the quotes.
    For more complex objects, it will have all the necessary Python punctuation, including
    all the details of the class and state of the object. We''ll often use an f-string
    with the class name and the attribute values.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the start of a class, `Sample`, which seems to capture all the features
    of a single sample:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `__repr__()` method reflects the fairly complex internal state of this `Sample` object.
    The states implied by the presence (or absence) of a species and the presence
    (or absence) of a classification lead to small behavior changes. So far, any changes
    in object behavior are limited to the `__repr__()` method used to display the
    current state of the object.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: What's important is that the state changes do lead to a (tiny) behavioral change.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two application-specific methods for the `Sample` class. These are
    shown in the next code snippet:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `classify()` method defines the state change from unclassified to classified.
    The `matches()` method compares the results of classification with a Botanist-assigned
    species. This is used for testing.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of how these state changes can look:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We have a workable definition of the `Sample` class. The `__repr__()` method
    is quite complex, suggesting there may be some improvements possible.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: It can help to define responsibilities for each class. This can be a focused
    summary of the attributes and methods with a little bit of additional rationale
    to tie them together.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Class responsibilities
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which class is responsible for actually performing a test? Does the `Training`
    class invoke the classifier on each `KnownSample` in a testing set? Or, perhaps,
    does it provide the testing set to the `Hyperparameter` class, delegating the
    testing to the `Hyperparameter` class? Since the `Hyperparameter` class has responsibility
    for the *k* value, and the algorithm for locating the *k*-nearest neighbors, it
    seems sensible for the `Hyperparameter` class to run the test using its own *k*
    value and a list of `KnownSample` instances provided to it.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: It also seems clear the `TrainingData` class is an acceptable place to record
    the various `Hyperparameter` trials. This means the `TrainingData` class can identify
    which of the `Hyperparameter` instances has a value of *k* that classifies irises
    with the highest accuracy.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple, related state changes here. In this case, both the `Hyperparameter`
    and `TrainingData` classes will do part of the work. The system – as a whole –
    will change state as individual elements change state. This is sometimes described
    as **emergent behavior**. Rather than writing a monster class that does many things,
    we've written smaller classes that collaborate to achieve the expected goals.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: This `test()` method of `TrainingData` is something that we didn't show in the
    UML image. We included `test()` in the `Hyperparameter` class, but, at the time,
    it didn't seem necessary to add it to `TrainingData`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the start of the class definition:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note how we write type hints for classes not yet defined. When a class is defined
    later in the file, any reference to the yet-to-be-defined class is a *forward
    reference*. The forward references to the not-yet-defined `TrainingData` class
    are provided as strings, not the simple class name. When **mypy** is analyzing
    the code, it resolves the strings into proper class names.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'The testing is defined by the following method:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We start by resolving the weak reference to the training data. This will raise
    an exception if there's a problem. For each testing sample, we classify the sample,
    setting the sample's `classification` attribute. The `matches` method tells us
    if the model's classification matches the known species. Finally, the overall
    quality is measured by the fraction of tests that passed. We can use the integer
    count, or a floating-point ratio of tests passed out of the total number of tests.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: We won't look at the classification method in this chapter; we'll save that
    for *Chapter 10*, *The Iterator Pattern*. Instead, we'll finish this model by
    looking at the `TrainingData` class, which combines the elements seen so far.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: The TrainingData class
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TrainingData` class has lists with two subclasses of `Sample` objects.
    The `KnownSample` and `UnknownSample` can be implemented as extensions to a common
    parent class, `Sample`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at this from a number of perspectives in *Chapter 7*. The `TrainingData`
    class also has a list with `Hyperparameter` instances. This class can have simple,
    direct references to previously defined classes.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'This class has the two methods that initiate the processing:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: The `load()` method reads raw data and partitions it into training data and
    test data. Both of these are essentially `KnownSample` instances with different
    purposes. The training subset is for evaluating the *k*-NN algorithm; the testing
    subset is for determining how well the *k* hyperparameter is working.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `test()` method uses a `Hyperparameter` object, performs the test, and saves
    the result.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Looking back at *Chapter 1*''s context diagram, we see three stories: *Provide
    Training Data*, *Set Parameters and Test Classifier*, and *Make Classification
    Request*. It seems helpful to add a method to perform a classification using a
    given `Hyperparameter` instance. This would add a `classify()` method to the `TrainingData`
    class. Again, this was not clearly required at the beginning of our design work,
    but seems like a good idea now.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the start of the class definition:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We've defined a number of attributes to track the history of the changes to
    this class. The uploaded time and the tested time, for example, provide some history.
    The `training`, `testing`, and `tuning` attributes have `Sample` objects and `Hyperparameter`
    objects.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: We won't write methods to set all of these. This is Python and direct access
    to attributes is a huge simplification to complex applications. The responsibilities
    are encapsulated in this class, but we don't generally write a lot of getter/setter
    methods.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 5*, *When to Use Object-Oriented Programming*, we'll look at some
    clever techniques, like Python's property definitions, additional ways to handle
    these attributes.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: The `load()` method is designed to process data given by another object. We
    could have designed the `load()` method to open and read a file, but then we'd
    bind the `TrainingData` to a specific file format and logical layout. It seems
    better to isolate the details of the file format from the details of managing
    training data. In *Chapter 5*, we'll look closely at reading and validating input.
    In *Chapter 9*, *Strings, Serialization, and File Paths*, we'll revisit the file
    format considerations.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we''ll use the following outline for acquiring the training data:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We'll depend on a source of data. We've described the properties of this source
    with a type hint, `Iterable[dict[str, str]]`. The `Iterable` states that the method's
    results can be used by a `for` statement or the `list` function. This is true
    of collections like lists and files. It's also true of generator functions, the
    subject of *Chapter 10*, *The Iterator Pattern*.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of this iterator need to be dictionaries that map strings to strings.
    This is a very general structure, and it allows us to require a dictionary that
    looks like this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This required structure seems flexible enough that we can build some object
    that will produce it. We'll look at the details in *Chapter 9*.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining methods delegate most of their work to the `Hyperparameter` class.
    Rather than do the work of classification, this class relies on another class
    to do the work:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In both cases, a specific `Hyperparameter` object is provided as a parameter.
    For testing, this makes sense because each test should have a distinct value.
    For classification, however, the "best" `Hyperparameter` object should be used
    for classification.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: This part of the case study has built class definitions for `Sample`, `KnownSample`,
    `TrainingData`, and `Hyperparameter`. These classes capture parts of the overall
    application. This isn't complete, of course; we've omitted some important algorithms.
    It's good to start with things that are clear, identify behavior and state change,
    and define the responsibilities. The next pass of design can then fill in details
    around this existing framework.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Recall
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some key points in this chapter:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Python has optional type hints to help describe how data objects are related
    and what the parameters should be for methods and functions.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create Python classes with the `class` statement. We should initialize the
    attributes in the special `__init__()` method.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules and packages are used as higher-level groupings of classes.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to plan out the organization of module content. While the general advice
    is "flat is better than nested," there are a few cases where it can be helpful
    to have nested packages.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python has no notion of "private" data. We often say "we're all adults here";
    we can see the source code, and private declarations aren't very helpful. This
    doesn't change our design; it simply removes the need for a handful of keywords.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can install third-party packages using PIP tools. We can create a virtual
    environment, for example, with `venv`.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write some object-oriented code. The goal is to use the principles and syntax
    you learned in this chapter to ensure you understand the topics we've covered.
    If you've been working on a Python project, go back over it and see whether there
    are some objects you can create and add properties or methods to. If it's large,
    try dividing it into a few modules or even packages and play with the syntax.
    While a "simple" script may expand when refactored into classes, there's generally
    a gain in flexibility and extensibility.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have such a project, try starting a new one. It doesn't have to
    be something you intend to finish; just stub out some basic design parts. You
    don't need to fully implement everything; often, just a `print("this method will
    do something")` is all you need to get the overall design in place. This is called **top-down
    design**, in which you work out the different interactions and describe how they
    should work before actually implementing what they do. The converse, **bottom-up
    design**, implements details first and then ties them all together. Both patterns
    are useful at different times, but for understanding object-oriented principles,
    a top-down workflow is more suitable.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: If you're having trouble coming up with ideas, try writing a to-do application.
    It can keep track of things you want to do each day. Items can have a state change
    from incomplete to completed. You might want to think about items that have an
    intermediate state of started, but not yet completed.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Now try designing a bigger project. A collection of classes to model playing
    cards can be an interesting challenge. Cards have a few features, but there are
    many variations on the rules. A class for a hand of cards has interesting state
    changes as cards are added. Locate a game you like and create classes to model
    cards, hands, and play. (Don't tackle creating a winning strategy; that can be
    hard.)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: A game like Cribbage has an interesting state change where two cards from each
    player's hand are used to create a kind of third hand, called "the crib." Make
    sure you experiment with the package and module-importing syntax. Add some functions
    in various modules and try importing them from other modules and packages. Use
    relative and absolute imports. See the difference, and try to imagine scenarios
    where you would want to use each one.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how simple it is to create classes and assign properties
    and methods in Python. Unlike many languages, Python differentiates between a
    constructor and an initializer. It has a relaxed attitude toward access control.
    There are many different levels of scope, including packages, modules, classes,
    and functions. We understood the difference between relative and absolute imports,
    and how to manage third-party packages that don't come with Python.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn more about sharing implementation using inheritance.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
