["```py\ndef leftright(me,maximum=1.0):\n   center=vec(0,0,0)\n   left =[]\n   right=[]\n   for v in me.verts:\n      weight = (v.co-center).length/maximum\n      if v.co.x > 0.0 :\n         right.append((v.index, weight))\n      elif v.co.x > 0.0 :\n         left.append((v.index, weight))\n   return left,right   \n\nif __name__ == \"__main__\":\n   try:\n      ob = Blender.Scene.GetCurrent().objects.active\n      me = ob.getData(mesh=True)\n\n      vgroups = me.getVertGroupNames()\n      if 'Left' in vgroups:\n         me.removeVertsFromGroup('Left')\n      else:\n         me.addVertGroup('Left')\n      if 'Right' in vgroups:\n         me.removeVertsFromGroup('Right')\n      else:\n         me.addVertGroup('Right')\n\n      left,right = leftright(me,vec(ob.getSize()).length)\n\n      for v,w in left:\n         me.assignVertsToGroup('Left',[v],w,Blender.Mesh.AssignModes.ADD)\n      for v,w in right:\n         me.assignVertsToGroup('Right',[v],w,Blender.Mesh.AssignModes.ADD)\n\n      Blender.Window.Redraw()\n\n   except Exception as e:\n      Blender.Draw.PupMenu('Error%t|'+str(e)[:80])\n\n```", "```py\nimport Blender\nfrom Blender import Modifier\n\ntarget  = Blender.Object.Get('Target')\ndeformer= Blender.Object.Get('Deformer')\n\nmod = target.modifiers.append(Modifier.Types.LATTICE)\nmod[Modifier.Settings.OBJECT] = deformer\ntarget.makeDisplayList()\nBlender.Window.RedrawAll()\n```", "```py\nimport Blender\nfrom Blender import Modifier\n\ntarget  = Blender.Object.Get('Target')\ndeformer= Blender.Object.Get('Deformer')\n\nmod = target.modifiers.append(Modifier.Types.LATTICE)\nmod[Modifier.Settings.OBJECT] = deformer\nmod[Modifier.Settings.VERTGROUP] = 'Right'\n\ntarget.makeDisplayList()\nBlender.Window.RedrawAll()\n```", "```py\ntxt = ob.getData()\ncurve = Blender.Curve.Get(txt.getName())\n```", "```py\nimport Blender\n\nfrom Blender.Geometry import BezierInterp as interpolate\nfrom Blender.Mathutils import Vector as vec\n\ndef curve2mesh(c):\n   vlists=[]\n   for cn in c:\n      npoints = len(cn)\n\n      points=[]\n      first=True\n      for segment in range(npoints-1):\n         a=cn[segment].vec\n         b=cn[segment+1].vec\n         lastpoints = interpolate(vec(a[1]),vec(a[2]),vec(b[0]),vec(b[1]),6)\n         if first:\n            first = False\n            points.append(lastpoints[0])\n            points.extend(lastpoints[1:])\n      if cn.isCyclic():\n         a=cn[-1].vec\n         b=cn[0].vec\n         lastpoints=interpolate(vec(a[1]),vec(a[2]),vec(b[0]),vec(b[1]),6)\n         points.extend(lastpoints[:-2])\n\n      vlists.append(points)\n\n   return vlists   \n```", "```py\ndef expand(me,loop,offset=0.05,plist=[]):\n\n   ov = [me.verts[i] for i in verts_from_edgeloop(loop)]\n\n   inside=False\n   for polygon in plist:\n      if in_polygon(loop[0].v1.co,polygon):\n         inside=True\n         break   # we don't deal with multiple inclusions\n\n   n=len(ov)\n   points=[]\n   for i in range(n):\n      va = (ov[i].co-ov[(i+1)%n].co).normalize()\n      vb = (ov[i].co-ov[(i-1)%n].co).normalize()\n      cosa=abs(vec(va).dot(vb))\n      if cosa>0.99999 :   # almost colinear\n         c = vec(va[1],va[0],va[2])\n      else:\n         c = va+vb\n      l = offset/c.length\n      p = ov[i].co+l*c\n      if in_polygon(p,ov) != inside:\n         p = ov[i].co-l*c\n      print i,ov[i].co,va,vb,c,l,cosa,p\n      points.append(p)\n\n   return points\n```", "```py\nfrom Blender.Geometry import LineIntersect2D\nfrom Blender.Mathutils import Vector as vec\n\ndef in_polygon(p,polygon):\n   intersections = 0\n   n = len(polygon)\n   if n<3 : return False\n   for i in range(n):\n      if LineIntersect2D (p,vec(1.0,0.0,0.0),polygon[i].co,polygon[(i+1)%n].co):\n         intersections+=1\n   return intersections % 2 == 1\n```", "```py\n   vlist = curve2mesh(c)\n\n   me = Blender.Mesh.New('Mesh')\n   ob = Blender.Scene.GetCurrent().objects.new(me,'Mesh')\n\n   me.addVertGroup('TextTop')\n   me.addVertGroup('TextBottom')\n   me.addVertGroup('Outline')\n```", "```py\n   loop=[]\n   for v in vlist:\n      offset=len(me.verts)\n      me.verts.extend(v)\n      edgeoffset=len(me.edges)\n      me.edges.extend([(i+offset,i+offset+1) for i in range(len(v)-1)])\n      me.edges.extend([(len(v)-1+offset,offset)])\n      me.remDoubles(0.001)\n\n      me.assignVertsToGroup('TextTop', range(offset,len(me.verts)),1.0, Blender.Mesh.AssignModes.ADD)\n      loop.append([me.edges[i] for i in range(edgeoffset,len(me.edges) )])\n```", "```py\n   for l in range(len(loop)):\n      points = expand.expand(me,loop[l],0.02,loop[:l]+loop[l+1:])\n      offset=len(me.verts)\n      me.verts.extend(points)\n      edgeoffset=len(me.edges)\n      me.edges.extend([(i+offset,i+offset+1) for i in range(len(points)-1)])\n      me.edges.extend([(len(points)-1+offset,offset)])\n      eloop=[me.edges[i] for i in range(edgeoffset,len(me.edges))]\n      me.assignVertsToGroup('Outline',range(offset,len(me.verts)),1.0,Blender.Mesh.AssignModes.ADD)\n      faces=[]\n      for e1,e2 in zip( expand.ordered_edgeloop(loop[l]),expand.ordered_edgeloop(eloop)):\n         f1=(e1.v1.index,e1.v2.index,e2.v2.index,e2.v1.index)\n         f2=(e1.v2.index,e1.v1.index,e2.v2.index,e2.v1.index)\n         faces.append(least_warped(me,f1,f2))\n      me.faces.extend(faces)\n```", "```py\n   deselect_all_edges(me)\n   select_edges(me,'TextBottom')\n   me.fill()\n```", "```py\n   me.triangleToQuad()\n   me.subdivide()\n\n   mod = ob.modifiers.append(Blender.Modifier.Types.SUBSURF)\n   mod[Blender.Modifier.Settings.LEVELS]=2\n\n   select_all_faces(me)\n   set_smooth(me)\n   select_all_edges(me)\n   me.recalcNormals()\n```", "```py\nfrom collections import defaultdict\n\ndef localcurvature(me,positive=False):\n\n   end=defaultdict(list)\n   for e in me.edges:\n      end[e.v1.index].append(e.v2)\n      end[e.v2.index].append(e.v1)\n\n   weights=[]\n   for v1 in me.verts:\n      dvdn = []\n      for v2 in end[v1.index]:\n         dv = v1.co-v2.co\n         dvdn.append(dv.dot(v1.no.normalize()))\n      weights.append((v1.index,sum(dvdn)/max(len(dvdn),1.0)))\n\n   if positive:\n      weights = [(v,max(0.0,w)) for v,w in weights]\n\n   minimum = min(w for v,w in weights)\n   maximum = max(w for v,w in weights)\n   span = maximum - minimum\n\n   if span > 1e-9:\n      return [(v,(w-minimum)/span) for v,w in weights]\n   return weights\n```", "```py\nweights.append((v1.index,sum(dvdn)/max(len(dvdn),1.0)))\n```", "```py\nif __name__ == \"__main__\":\n   try:\n      choice = Blender.Draw.PupMenu(\"Normalization%t|Onlypositive|Full range\")\n      if choice>0:\n         ob = Blender.Scene.GetCurrent().objects.active\n         me = ob.getData(mesh=True)\n\n         try:\n            me.removeVertGroup('Curvature')\n         except AttributeError:\n            pass\n\n         me.addVertGroup('Curvature')\n\n         for v,w in localcurvature(me,positive=(choice==1)):\n            me.assignVertsToGroup('Curvature',[v],w,Blender.Mesh.AssignModes.ADD)\n\n         Blender.Window.Redraw()\n\n   except Exception as e:\n      Blender.Draw.PupMenu('Error%t|'+str(e)[:80])\n```", "```py\n   me=Blender.Mesh.New('Clock')\n   me.verts.extend(clockmesh.Clock_verts)\n   me.faces.extend(clockmesh.Clock_faces)\n\n   scn=Blender.Scene.GetCurrent()\n   ob=scn.objects.new(me)\n   scn.objects.active=ob\n\n   me.addVertGroup('BigHand')\n   me.assignVertsToGroup('BigHand',clockmesh.Clock_vertexgroup_BigHand,1.0, Blender.Mesh.AssignModes.ADD)\n\n   … <similar code for LittleHand, BigArm and LittleArm vertex groupsomitted> ...   \n\n   ar = Blender.Armature.New('ClockBones')\n   ar.envelopes=False\n   ar.vertexGroups=False\n   obbones = scn.objects.new(ar)\n\n   mod = ob.modifiers.append(Blender.Modifier.Types.ARMATURE)\n   mod[Blender.Modifier.Settings.OBJECT]=obbones\n   mod[Blender.Modifier.Settings.ENVELOPES]=False\n   mod[Blender.Modifier.Settings.VGROUPS]=True\n\n   ar.makeEditable()\n   bigarm = Blender.Armature.Editbone()\n   bigarm.head = vec(0.0,0.0 ,0.57)\n   bigarm.tail = vec(0.0,0.75,0.57)\n   ar.bones['BigArm'] = bigarm\n   bighand = Blender.Armature.Editbone()\n   bighand.head = bigarm.tail\n   bighand.tail = vec(0.0,1.50,0.57)\n   bighand.parent = bigarm\n   ar.bones['BigHand'] = bighand\n\n   … <similar code for the little hand omitted> …\n\n   ar.update()\n\n   obbones.makeParent([ob])\n```", "```py\nar = Blender.Armature.New('BugBones')\n   ar.autoIK = True\n   obbones = scn.objects.new(ar)\n   ar.makeEditable()\n```", "```py\n   for vg,vlist,parent,connected in vgroup:\n\n      bone = Blender.Armature.Editbone()\n      bb = bounding_box([verts[i] for i in vlist])\n```", "```py\n      axis=1\n      if vg.startswith('wing') or vg.startswith('leg'): axis = 0\n```", "```py\n\n      if parent != None : \n         parenty = (ar.bones[parent].head[1] +ar.bones[parent].tail[1])/2.0\n```", "```py\n      if connected:\n         bone.head = ar.bones[parent].tail.copy()\n      else:\n         if axis==1:\n            bone.head=Blender.Mathutils.Vector(0,bb[1][0],0)\n         else:\n            bone.head=Blender.Mathutils.Vector(bb[0][1],parenty,bb[2][1])\n```", "```py\nThe tail position of the bone is calculated in a similar manner:if axis==1:\n         bone.tail=Blender.Mathutils.Vector(0,bb[1][1],0)\n      else:\n         bone.tail=Blender.Mathutils.Vector(bb[0][0],parenty,bb[2][0])\n```", "```py\n      ar.bones[vg] = bone\n\n      if parent != None :\n         bone.parent=ar.bones[parent]\n      else:\n         bone.clearParent()\n\n      if connected: bone.options=Blender.Armature.CONNECTED\n```", "```py\nme=ob.getData(mesh=1)\n\nmats=[ Blender.Material.New(), Blender.Material.New()]\nmats[0].rgbCol=[1.0,1.0,1.0]\nmats[1].rgbCol=[0.0,0.0,0.0]\n\nob.setMaterials(mats)\nob.colbits=3\n\nfor f in me.faces:\n   if f.index%2 == 0 :\n      f.mat=0\n   else:\n      f.mat=1\n```", "```py\nmats=[Material.New(),Material.New(),Material.New()]\nmats[0].rgbCol=[1.0,1.0,1.0]\nmats[1].rgbCol=[0.0,0.0,0.0]\nmats[2].rgbCol=[1.0,0.0,0.0]\nob.setMaterials(mats)\nob.colbits=3\ntxt=ob.getData()\n\nfor i in range(len(txt.getText())):\n   txt.setMaterial(i,1+i%2)\n\n```", "```py\nimport Blender\nob=Blender.Scene.getCurrent().objects.active\nme=ob.getData(mesh=1)\n\nme.vertexColors=True\nfor f in me.faces:\n   for i,v in enumerate(f.verts):\n      g = int(max(0.0,min(1.0,v.co.z))*255)\n      f.col[i].r=g\n      f.col[i].g=g\n      f.col[i].b=g\n\nmats=[Blender.Material.New()]\nmats[0].setMode(Blender.Material.Modes['VCOL_PAINT'])\nob.setMaterials(mats)\nob.colbits=1\nob.makeDisplayList()\n\nBlender.Window.RedrawAll()\n```", "```py\nimport re\n\ndef matindex2vertgroups(me,matgroups):\n   if len(matgroups)>16 :\n      raise ArgumentError(\"number of groups larger than number ofmaterials possible (16)\")\n\n   groupnames = me.getVertGroupNames()\n\n   vertexgroupset={}\n   for name in groupnames:\n      vertexgroupset[name]=set(me.getVertsFromGroup(name))\n      print name,len(vertexgroupset[name])\n\n   faceset={}\n   for f in me.faces:\n      faceset[f.index]=set([v.index for v in f.verts])\n\n   for i,matgroup in enumerate(matgroups):\n      for name in groupnames:\n         if re.search('^'+matgroup+'$',name):\n            for f,vset in faceset.items():\n               if vset.issubset(vertexgroupset[name]) :\n                  me.faces[f].mat = i\n            break\n```"]