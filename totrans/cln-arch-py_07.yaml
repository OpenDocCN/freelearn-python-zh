- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: 'The Application Layer: Orchestrating Use Cases'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用层：编排用例
- en: In [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor091), we developed the Domain
    layer of our task management system and implemented entities, value objects, and
    domain services that encapsulate our core business rules. While this gives us
    a solid foundation, business rules alone don’t make a usable application. We need
    a way to coordinate these domain objects to fulfill user needs such as creating
    tasks, managing projects, and handling notifications. This is where the **Application
    layer** comes in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](Chapter_04.xhtml#_idTextAnchor091)中，我们开发了任务管理系统的领域层，并实现了封装核心业务规则的实体、值对象和领域服务。虽然这为我们提供了一个坚实的基础，但仅有业务规则并不能构成一个可用的应用程序。我们需要一种协调这些领域对象以满足创建任务、管理项目和处理通知等用户需求的方法。这正是应用层发挥作用的地方。
- en: The Application layer acts as the conductor in our Clean Architecture orchestra.
    It coordinates domain objects and external services to accomplish specific use
    cases while maintaining the strict boundary between our business rules and the
    outside world. By implementing this layer correctly, we create applications that
    are not only functional but also maintainable and adaptable to change.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层在我们干净的架构交响乐中扮演着指挥家的角色。它协调领域对象和外部服务以完成特定的用例，同时保持我们业务规则与外部世界之间的严格边界。通过正确实现这一层，我们创建的应用不仅功能强大，而且易于维护和适应变化。
- en: In this chapter, we’ll explore how to implement an effective Application layer
    using our task management system as an example. We’ll see how to create use cases
    that orchestrate domain objects while maintaining clean architectural boundaries.
    You’ll learn how to implement request and response models that clearly define
    use case boundaries, and how to manage dependencies on external services without
    compromising architectural integrity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将以任务管理系统为例，探讨如何实现有效的应用层。我们将看到如何创建编排领域对象的用例，同时保持清晰的架构边界。您将学习如何实现请求和响应模型，以明确定义用例边界，以及如何管理对外部服务的依赖，而不会损害架构的完整性。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding the role of the Application layer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解应用层的角色
- en: Implementing use case interactors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现用例交互器
- en: Defining request and response models
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义请求和响应模型
- en: Maintaining separation from external concerns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持对外部关注点的分离
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples presented in this chapter and throughout the rest of the book
    are tested with Python 3.13\. For brevity, in addition to the lack of logging
    statements, some code examples in the chapter are only partially implemented.
    Complete versions of all examples can be found in the book’s accompanying GitHub
    repository at [https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和本书其余部分展示的代码示例均使用Python 3.13进行测试。为了简洁，除了缺少日志语句外，本章的一些代码示例仅部分实现。所有示例的完整版本可以在本书配套的GitHub仓库[https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python)中找到。
- en: Understanding the role of the Application layer
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解应用层的角色
- en: The Application layer serves as a thin layer that coordinates our domain objects
    and services to accomplish meaningful user tasks. While our domain model provides
    the building blocks, tasks, projects, deadlines, it’s the Application layer that
    assembles these pieces into useful features.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层作为一个薄层，协调我们的领域对象和服务以完成有意义的用户任务。虽然我们的领域模型提供了构建块，如任务、项目、截止日期，但将这些部件组装成有用功能的正是应用层。
- en: 'The Application layer serves another critical function: information hiding.
    In [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor091), we saw how domain entities
    hide their internal state and implementation details. The Application layer extends
    this principle across architectural boundaries, hiding infrastructure details
    from the domain and domain complexities from external interfaces. This deliberate
    hiding of information is what makes the additional effort of creating ports, adapters,
    and request/response models worthwhile. By exposing only what’s necessary through
    carefully designed interfaces, we create a system where components can evolve
    independently yet work together seamlessly.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层还承担另一个关键功能：信息隐藏。在[*第4章*](Chapter_04.xhtml#_idTextAnchor091)中，我们看到了领域实体如何隐藏它们的内部状态和实现细节。应用层将这一原则扩展到架构边界，从领域隐藏基础设施细节，从外部接口隐藏领域复杂性。这种有意的隐藏信息使得创建端口、适配器和请求/响应模型所付出的额外努力变得值得。通过通过精心设计的接口仅暴露必要的信息，我们创建了一个组件可以独立进化但又能无缝协作的系统。
- en: '![Figure 5.1: Application layer and task management](img/B31577_05_1.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：应用层和任务管理](img/B31577_05_1.png)'
- en: 'Figure 5.1: Application layer and task management'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：应用层和任务管理
- en: 'In *Figure 5.1*, we illustrate how the Application layer fits within Clean
    Architecture’s concentric layers. It acts as a mediator between the Domain layer,
    where our core business entities such as Task and Project reside, and the outer
    layers of our system. By encapsulating use cases that orchestrate domain entities,
    the Application layer maintains the Dependency Rule: outer layers depend inward,
    and inner layers remain unaffected by changes in outer layers.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图5.1*中，我们说明了应用层如何在Clean Architecture的同心层中定位。它充当领域层（我们的核心业务实体如任务和项目所在）和系统外层之间的调解者。通过封装编排领域实体的用例，应用层维护了依赖规则：外层依赖于内层，内层不受外层变化的影响。
- en: 'The Application layer has several distinct responsibilities:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层有几个不同的职责：
- en: '**Use case orchestration**:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例编排**：'
- en: Coordinating domain objects to accomplish user tasks
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调领域对象以完成用户任务
- en: Managing the sequence of operations
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理操作序列
- en: Ensuring business rules are properly applied
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保业务规则得到正确应用
- en: '**Error handling and validation**:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理和验证**：'
- en: Validating input before it reaches domain objects
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在输入到达领域对象之前进行验证
- en: Catching and translating domain errors
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获和翻译领域错误
- en: Providing consistent error responses
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一致的错误响应
- en: '**Transaction management**:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务管理**：'
- en: Ensuring operations are atomic when needed
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在需要时操作是原子的
- en: Maintaining data consistency
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护数据一致性
- en: Managing rollbacks on failures
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理失败时的回滚
- en: '**Boundary translation**:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边界转换**：'
- en: Converting external data formats to domain formats
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将外部数据格式转换为领域格式
- en: Transforming domain objects for external presentation
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将领域对象转换为外部展示格式
- en: Managing cross-boundary communication
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理跨边界通信
- en: These responsibilities work together to create a robust orchestration layer
    that maintains clean boundaries while ensuring reliable application behavior.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些责任共同工作，创建一个健壮的编排层，在保持清晰的边界的同时确保可靠的应用行为。
- en: Error handling with result types
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用结果类型的错误处理
- en: 'Before diving into our implementation patterns, it’s essential to understand
    a fundamental concept in our Application layer: the use of the **result type**.
    This pattern forms the backbone of our error-handling strategy, providing explicit
    handling of success and failure rather than relying solely on exceptions. This
    approach provides several benefits:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入我们的实现模式之前，理解我们应用层的一个基本概念至关重要：**结果类型**的使用。这个模式构成了我们错误处理策略的骨干，提供了对成功和失败的明确处理，而不是仅仅依赖于异常。这种方法提供了几个好处：
- en: Makes success/failure paths explicit in function signatures
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数签名中使成功/失败路径明确
- en: Provides consistent error handling across the application
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整个应用中提供一致的错误处理
- en: Maintains clean architectural boundaries by translating domain errors
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过翻译领域错误来维护清晰的架构边界
- en: Improves testability and error handling predictability
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高可测试性和错误处理的可预测性
- en: 'First, we define a standardized `Error` class to represent all application-level
    errors:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个标准化的`Error`类来表示所有应用层错误：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we define a `Result` class that encapsulates either a successful value
    or an error:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`Result`类，它封装了成功值或错误：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The use of result types enables clean orchestration of domain operations, as
    demonstrated in this usage example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用结果类型可以干净地协调领域操作，如下面的使用示例所示：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The usage example above demonstrates several key advantages of the result pattern:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的使用示例展示了结果模式的一些关键优势：
- en: '**Clean error paths**: Notice how the error cases are handled uniformly through
    `Result.failure()`, providing a consistent interface regardless of the underlying
    error type'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰的错误路径**：注意错误情况是如何通过`Result.failure()`统一处理的，无论底层错误类型如何，都提供了一个一致的接口。'
- en: '**Explicit domain translation**: The conversion from domain-specific errors
    (`ProjectNotFoundError`) to application-level errors happens cleanly at the boundary'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式领域转换**：从领域特定错误（`ProjectNotFoundError`）到应用级错误的转换在边界处干净地发生。'
- en: '**Self-contained context**: The `Result` object packages both the outcome and
    any error context, making the function’s behavior completely clear from its return
    value'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自包含上下文**：`Result`对象封装了结果和任何错误上下文，使得函数的行为从其返回值完全清晰。'
- en: '**Testing clarity**: The example makes it easy to test both success and failure
    cases by checking the result’s state rather than trying to catch exceptions'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试清晰度**：该示例通过检查结果的状态而不是尝试捕获异常，使得测试成功和失败情况变得容易。'
- en: '**Error handling boundaries in Clean Architecture**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Clean Architecture中的错误处理边界**'
- en: When implementing error handling in the Application layer, we explicitly catch
    and transform only expected domain and business errors into results. Thus, we
    don’t have an `except Exception:` clause paired with the expected errors. This
    separation maintains clean architectural boundaries. Concerns such as global error
    handling remain in the outer layers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现应用层的错误处理时，我们明确地只捕获和转换预期的领域和业务错误为结果。因此，我们没有与预期错误配对的`except Exception:`子句。这种分离保持了清晰的架构边界。如全局错误处理等问题仍保留在外层。
- en: Application layer patterns
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用层模式
- en: 'To understand how the Application layer manages its responsibilities, let’s
    examine how data flows through our architecture:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解应用层如何管理其职责，让我们考察数据是如何通过我们的架构流动的：
- en: '![Figure 5.2: Request/Response flow in Clean Architecture](img/B31577_05_2.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：Clean Architecture中的请求/响应流程](img/B31577_05_2.png)'
- en: 'Figure 5.2: Request/Response flow in Clean Architecture'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：Clean Architecture中的请求/响应流程
- en: The flow shown in *Figure 5.2* demonstrates several key patterns working together.
    A request enters through the Interface Adapters layer and is handled by our Application
    layer’s **data transfer objects** (**DTOs)**, which validate and transform the
    input into formats our domain can process. Use cases then orchestrate domain operations,
    working with these validated inputs to interact with domain objects and coordinate
    with external services through ports. The use cases return results that encapsulate
    either success (with a response DTO) or failure (with an error), which the Interface
    Adapters layer can then map directly to appropriate HTTP responses. Don’t worry
    about understanding all the discrete components in *Figure 5.2* now; we’ll cover
    them in more detail throughout the chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图5.2*所示，该流程演示了几个关键模式协同工作。一个请求通过接口适配器层进入，并由我们应用层的**数据传输对象**（**DTOs**）处理，这些对象验证并转换输入为领域可以处理的格式。用例随后协调领域操作，与这些验证后的输入一起与领域对象交互，并通过端口与外部服务协调。用例返回的结果封装了成功（带有响应DTO）或失败（带有错误），接口适配器层可以将其直接映射到适当的HTTP响应。现在不必担心理解*图5.2*中的所有离散组件；我们将在本章的其余部分详细讨论它们。
- en: 'This choreographed interaction relies on three foundational patterns that work
    together to maintain clean architectural boundaries:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编排的交互依赖于三个基础模式协同工作，以保持清晰的架构边界：
- en: '**Use case interactors**: These serve as the primary orchestrators, implementing
    specific business operations while managing transactions and coordinating domain
    objects. They ensure each operation is focused and its execution is consistent.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例交互器**：这些作为主要协调者，在管理事务和协调领域对象的同时，实现特定的业务操作。它们确保每个操作都集中精力，其执行是一致的。'
- en: '**Interface boundaries**: Establish clear contracts between our Application
    layer and the services it depends on.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口边界**：在我们的应用层及其依赖的服务之间建立清晰的合同。'
- en: '**Dependency inversion**: Enables flexible implementation and straightforward
    testing through these boundaries, ensuring our core business logic remains decoupled
    from external concerns.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖反转**：通过这些边界实现灵活的实现和简单的测试，确保我们的核心业务逻辑与外部关注点解耦。'
- en: Initially, our use cases will work with simple parameters and return basic data
    structures. As our application grows, we’ll introduce more sophisticated patterns
    for handling data that cross our architectural boundaries. This evolution helps
    us maintain a clean separation between layers while keeping our code adaptable
    to change.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们的用例将使用简单的参数并返回基本的数据结构。随着我们的应用程序增长，我们将引入更复杂的模式来处理跨越我们架构边界的跨层数据。这种进化帮助我们保持层之间的清晰分离，同时使我们的代码能够适应变化。
- en: These patterns align naturally with the SOLID principles we explored in [*Chapter
    2*](Chapter_02.xhtml#_idTextAnchor040). Use cases embody the Single Responsibility
    Principle by focusing each operation on a specific goal. Interface definitions
    support interface segregation by defining focused, client-specific contracts.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式与我们在[*第二章*](Chapter_02.xhtml#_idTextAnchor040)中探讨的SOLID原则自然一致。用例通过将每个操作集中在特定的目标上体现了单一职责原则。接口定义通过定义专注的、客户端特定的合同支持接口分离。
- en: Planning for evolution
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为进化做准备
- en: Applications rarely remain static—successful ones inevitably grow in scope and
    complexity. What starts as a simple task management system might need to evolve
    to support multiple teams, integrate with various external services, or handle
    complex workflow automation. The Application layer patterns we’ve explored enable
    this evolution with minimal friction.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序很少保持静态——成功者不可避免地会扩大范围和复杂性。最初可能只是一个简单的任务管理系统，可能需要进化以支持多个团队，与各种外部服务集成，或处理复杂的流程自动化。我们探索的应用层模式以最小的摩擦实现了这种进化。
- en: 'Let’s examine how our task management system can grow through real-world scenarios:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实际场景来考察我们的任务管理系统如何成长：
- en: '**Use case extensibility**:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例可扩展性**：'
- en: Expanding task notifications from email to include Slack or similar communication
    platforms
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任务通知从电子邮件扩展到包括Slack或类似的通信平台
- en: Composing individual use cases, such as *assign task* and *set deadline,* into
    higher-level operations such as *sprint planning*
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单个用例，如**分配任务**和**设置截止日期**，组合成更高级的操作，例如**冲刺计划**
- en: '**Clean dependencies**:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清理依赖**：'
- en: Starting with local file storage for attachments, then seamlessly adding S3
    support through the same interface
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地文件存储附件开始，然后无缝添加通过相同界面的S3支持
- en: Switching database engines from SQLite to PostgreSQL without modifying use case
    code
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不修改用例代码的情况下，将数据库引擎从SQLite切换到PostgreSQL
- en: '**Consistent boundaries**:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致的边界**：'
- en: Handling data transformation in Request objects across new API versions (v1
    versus v2) while reusing the same underlying use case code
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新的API版本（v1与v2）之间处理请求对象中的数据转换，同时重用相同的底层用例代码
- en: Implementing distinct Response transformers for different clients (mobile, web,
    CLI) while sharing identical core business logic
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不同的客户端（移动、Web、CLI）实现不同的响应转换器，同时共享相同的核心业务逻辑
- en: This architectural foundation lets us confidently evolve our system. When the
    marketing team requests Salesforce integration, or when compliance requires audit
    logging, these capabilities can be added without disrupting existing functionality
    or compromising architectural integrity.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个架构基础让我们有信心地进化我们的系统。当营销团队要求Salesforce集成，或者当合规性要求审计日志时，这些功能可以添加而不会破坏现有功能或损害架构完整性。
- en: In the next section, we’ll explore how to implement these concepts in Python,
    creating robust use case interactors that uphold the principles of Clean Architecture.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何在Python中实现这些概念，创建遵守清洁架构原则的健壮用例交互器。
- en: Implementing use case interactors
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现用例交互器
- en: Having explored the theoretical foundations of the Application layer, we now
    turn to practical implementation. Use case interactors are the concrete classes
    that implement application-specific business rules. The term *interactors* emphasizes
    their role in interacting with and coordinating various parts of the system. While
    the Domain layer defines what the business rules are, interactors define how and
    when these rules are applied in response to specific application needs. In Python,
    we can implement these interactors in a way that’s both clean and expressive.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨了应用层的理论基础之后，我们现在转向实际实施。用例交互器是实现特定业务规则的实体类。术语*交互器*强调了它们在与系统各个部分交互和协调中的作用。虽然领域层定义了业务规则是什么，但交互器定义了如何以及何时根据特定的应用需求应用这些规则。在Python中，我们可以以既清晰又富有表现力的方式实现这些交互器。
- en: Structuring a use case
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用案例的结构化
- en: 'A well-designed use case interactor orchestrates domain objects while maintaining
    clean architectural boundaries. Let’s examine how this is achieved:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的用例交互器在协调领域对象的同时，保持清晰的架构边界。让我们看看这是如何实现的：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, looking at the outer structure of a use case, we see some key components.
    Dependency interfaces are injected, and the class has a public `execute` method
    that returns a `Result` object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从用例的外部结构来看，我们可以看到一些关键组件。依赖接口被注入，并且类有一个公开的`execute`方法，该方法返回一个`Result`对象。
- en: 'Next, let’s examine the `execute` method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查`execute`方法：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we can see the orchestration of business rules upon the `Task` domain
    object to accomplish the discrete goal of the use case: completing the task.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到业务规则在`Task`领域对象上的编排，以实现用例的离散目标：完成任务。
- en: 'This implementation embodies several key architectural principles:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现体现了几个关键架构原则：
- en: '**Encapsulation**: The use case class provides a clear boundary around a specific
    business operation.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：用例类为特定的业务操作提供了一个清晰的边界。'
- en: '**Interface definition**: The `execute` method provides a clean, focused interface
    using the result type. The result pattern ensures both success and failure paths
    are explicit in our interface, making error handling a first-class concern.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口定义**：`execute`方法通过使用结果类型提供了一个清晰、专注的接口。结果模式确保我们的接口中成功和失败路径都是明确的，使错误处理成为一等关注点。'
- en: '**Error handling**: Domain errors are caught and translated into application-level
    errors.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：领域错误被捕获并转换为应用级错误。'
- en: '**Dependency injection**: Dependencies are passed in through the constructor,
    adhering to the Dependency Inversion Principle introduced in [*Chapter 2*](Chapter_02.xhtml#_idTextAnchor040).'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入**：依赖项通过构造函数传入，遵循在[*第二章*](Chapter_02.xhtml#_idTextAnchor040)中引入的依赖倒置原则。'
- en: Of these principles, dependency injection deserves special attention as it enables
    much of our architectural flexibility.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些原则中，依赖注入值得特别注意，因为它使我们的架构灵活性成为可能。
- en: Dependency injection
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'Earlier we saw how dependency injection helps maintain clean architectural
    boundaries in our use cases. Let’s expand on this by examining how to structure
    our interfaces to maximize the benefits of dependency injection while ensuring
    our use cases remain flexible and testable. In Python, we can implement this elegantly
    using abstract base classes:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们看到了依赖注入如何帮助在我们的用例中保持清晰的架构边界。让我们通过检查如何结构化我们的接口来进一步探讨这一点，以最大化依赖注入的好处，同时确保我们的用例保持灵活和可测试。在Python中，我们可以使用抽象基类优雅地实现这一点：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By defining these interfaces in the Application layer, we strengthen our architectural
    boundaries while providing clear contracts for outer layers to implement. This
    approach provides several advanced benefits beyond basic dependency injection:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在应用层定义这些接口，我们加强了我们的架构边界，同时为外部层提供了清晰的实现合同。这种方法提供了超越基本依赖注入的几个高级好处：
- en: Interface definitions express exactly what the Application layer needs, no more
    and no less
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口定义精确表达了应用层所需的内容，不多也不少
- en: Abstract methods document the expected behavior through clear method signatures
    and docstrings
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象方法通过清晰的方法签名和文档字符串来记录预期的行为
- en: The Application layer maintains control over its dependencies while remaining
    independent of their implementations
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层在保持对其依赖项控制的同时，保持对其实现的独立性
- en: Test implementations can focus on exactly what each use case requires
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试实现可以专注于每个用例的确切需求
- en: 'A concrete implementation adhering to this contract might take a form such
    as this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 遵守此合同的实体实现可能具有如下形式：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example demonstrates how outer layers can implement the interfaces defined
    by our Application layer, handling the specifics of data persistence while adhering
    to the contract our business logic expects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例演示了外层如何实现由我们的应用层定义的接口，同时处理数据持久化的具体细节，并遵守业务逻辑预期的合同。
- en: Handling complex operations
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理复杂操作
- en: Real-world use cases often involve multiple steps and potential failure points.
    Let’s examine how to manage this complexity while maintaining Clean Architecture
    principles. Consider a project completion scenario that requires the coordination
    of multiple tasks.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 实际应用场景通常涉及多个步骤和潜在的故障点。让我们看看如何在保持清晰架构原则的同时管理这种复杂性。考虑一个需要协调多个任务的项目完成场景。
- en: 'The `CompleteProjectUseCase` follows our established pattern:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompleteProjectUseCase`遵循我们建立的模式：'
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let’s examine its `execute` method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来检查它的`execute`方法：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This implementation demonstrates several patterns for managing complexity:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现展示了管理复杂性的几种模式：
- en: '**Coordinated operations**: The use case manages multiple related operations
    as a single logical unit:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协调操作**：用例将多个相关操作作为一个单一逻辑单元管理：'
- en: Completing all outstanding tasks
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成所有未完成的任务
- en: Updating the project status
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新项目状态
- en: Notifying stakeholders
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知利益相关者
- en: '**Error management**: The use case provides comprehensive error handling:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误管理**：用例提供了全面的错误处理：'
- en: Domain-specific errors are caught and translated.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获并转换特定领域的错误。
- en: Each operation’s potential failures are considered. In a more involved example,
    you might see a rollback of the `Task` saves if the `Project` update or save failed.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑每个操作的潜在失败情况。在更复杂的示例中，如果项目更新或保存失败，可能会看到`Task`保存的回滚。
- en: Error responses are consistent and informative.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误响应一致且信息丰富。
- en: '**Clear dependencies**: Required services are explicitly defined:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**明确依赖**：所需服务被明确定义：'
- en: Defining repositories for data access
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义数据访问的存储库
- en: Providing notification services for external communication
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供外部通信的通告服务
- en: Injecting dependencies for flexibility and testing
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入依赖以实现灵活性和测试
- en: '**Input validation**: Parameters are validated before processing:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入验证**：在处理之前验证参数：'
- en: Required IDs are checked for existence
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查所需ID是否存在
- en: Optional parameters are handled appropriately
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当处理可选参数
- en: Domain rules are enforced
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行领域规则
- en: '**Transactional integrity**: Changes to both tasks and projects are handled
    as a cohesive operation:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务完整性**：对任务和项目的更改被作为一个整体操作处理：'
- en: The code example could be extended to support true transactionality by just
    capturing the starting state and then rolling back if one of our statements fails.
    See the code for `CompleteProjectUseCase` in the book’s accompanying GitHub repository
    for an example of this.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过仅捕获起始状态并在我们的某个语句失败时回滚，代码示例可以扩展以支持真正的事务性。请参阅书中随附的GitHub存储库中的`CompleteProjectUseCase`代码示例。
- en: By applying these patterns consistently across our Application layer, we create
    a robust system that handles complex operations gracefully while maintaining clean
    architectural boundaries and clear separation of concerns.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在应用层持续应用这些模式，我们创建了一个健壮的系统，它优雅地处理复杂操作，同时保持清晰的架构边界和关注点的清晰分离。
- en: Defining request and response models
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义请求和响应模型
- en: In the previous section, our use cases worked directly with primitive types
    and dictionaries. While this approach can work for simple cases, as our application
    grows, we need more structured ways to handle data crossing our architectural
    boundaries. Request and response models serve this purpose, providing specialized
    DTOs that handle data transformation between the outer layers and our application
    core. Building on the information hiding principles we introduced earlier, these
    models extend this concept to architectural boundaries, specifically protecting
    our domain logic from external format details while shielding external interfaces
    from domain implementation specifics. This reciprocal boundary protection is particularly
    important as different interfaces evolve at different rates.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们的用例直接与原始类型和字典交互。虽然这种方法对于简单情况可能有效，但随着我们应用的扩展，我们需要更多结构化的方式来处理跨越架构边界的跨数据。请求和响应模型服务于这个目的，提供专门的数据传输对象（DTOs），以处理外部层和我们的应用核心之间的数据转换。基于我们之前引入的信息隐藏原则，这些模型将这一概念扩展到架构边界，具体来说，保护我们的领域逻辑免受外部格式细节的影响，同时屏蔽外部接口免受领域实现细节的影响。这种相互的边界保护对于不同接口以不同速度发展尤为重要。
- en: Request models
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求模型
- en: '**Request models** capture and validate incoming data before it reaches our
    Application layer’s use cases. They provide a clear structure for input data and
    perform preliminary validation:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求模型**在数据到达我们的应用层用例之前捕获和验证传入的数据。它们为输入数据提供清晰的架构，并执行初步验证：'
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Request models serve multiple architectural purposes by establishing a clear
    boundary between outer and inner layers. Through input validation and the `to_execution_params`
    method, they ensure that use cases remain focused purely on business logic. The
    validation step catches malformed data early, while `to_execution_params` transforms
    API-friendly formats (such as string IDs) into proper domain types (such as UUIDs)
    that our business logic expects.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请求模型通过建立外部层和内部层之间清晰的边界，服务于多个架构目的。通过输入验证和`to_execution_params`方法，它们确保用例仅关注业务逻辑。验证步骤可以提前捕获格式错误的数据，而`to_execution_params`将API友好的格式（如字符串ID）转换为我们的业务逻辑期望的正确领域类型（如UUID）。
- en: 'This transformation capability is particularly powerful as it:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换能力特别强大，因为它：
- en: Keeps use cases clean and focused, working only with domain types
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持用例简洁和专注，仅与领域类型交互
- en: Centralizes data conversion logic in a single, predictable location
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据转换逻辑集中在一个单一、可预测的位置
- en: Allows API formats to evolve without impacting core business logic
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许API格式演变而不影响核心业务逻辑
- en: Improves testability by providing clear format boundaries
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供清晰的格式边界来提高可测试性
- en: By the time data flows through a request model to reach our use cases, it has
    been both validated and transformed into the precise format our domain logic expects.
    This maintains Clean Architecture’s separation of concerns, ensuring that outer
    layer implementation details (such as how IDs are formatted in HTTP requests)
    never leak into our core business rules.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据通过请求模型流过并到达我们的用例时，它已经被验证并转换为我们的领域逻辑期望的精确格式。这保持了清洁架构的关注点分离，确保外部层实现细节（如HTTP请求中ID的格式）永远不会泄露到我们的核心业务规则中。
- en: Response models
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应模型
- en: '**Response models** handle the transformation of domain objects into structures
    suitable for external consumption. They maintain our clean architectural boundaries
    by explicitly controlling what domain data is exposed and how it’s formatted:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应模型**负责将领域对象转换为适合外部消费的结构。它们通过明确控制暴露的领域数据及其格式来维护我们清晰的架构边界：'
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While `to_execution_params` of the request model transforms inbound data to
    match domain expectations, `from_entity` handles the outbound journey by converting
    domain objects into formats suitable to traverse the boundary to the Adapters
    layer. This symmetrical pattern means our use cases can work purely with domain
    objects while both input and output are automatically adapted to external needs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`to_execution_params`将请求模型中的传入数据转换为符合领域期望的格式，但`from_entity`通过将领域对象转换为适合跨越边界到适配器层的格式来处理输出旅程。这种对称模式意味着我们的用例可以仅与领域对象交互，同时输入和输出都会自动适应外部需求。
- en: 'The `from_entity` method serves several key purposes:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`from_entity`方法具有几个关键用途：'
- en: Protects domain objects from exposure to external layers
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护领域对象免受外部层的暴露
- en: Controls exactly what data is exposed and in what format (e.g., converting UUIDs
    back to strings)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精确控制暴露的数据以及数据格式（例如，将UUID转换回字符串）
- en: Provides a consistent serialization point for all external interfaces
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有外部接口提供一致的序列化点
- en: Allows computed or derived fields (such as `task_count`) without modifying domain
    objects
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许计算或派生字段（如`task_count`），而无需修改域对象
- en: Includes computed or aggregate data not present in the base entity
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括在基本实体中不存在的不包含计算或聚合数据
- en: Optimizes performance by omitting large amounts of irrelevant data
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过省略大量无关数据来优化性能
- en: Includes operation-specific metadata
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括特定操作元数据
- en: 'Let’s revisit an evolved version of the `CompleteProjectUseCase` to show how
    request models, domain logic, and response models work together:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`CompleteProjectUseCase`的演变版本，以展示请求模型、域逻辑和响应模型是如何协同工作的：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example demonstrates how our use case remains focused purely on orchestrating
    domain logic while request and response models handle the necessary transformations
    at our architectural boundaries. The use case receives an already-validated request,
    works with proper domain types throughout its execution, and returns a response
    model wrapped in a `Result` object that can be consumed by any outer layer implementation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例演示了我们的用例如何纯粹专注于编排域逻辑，而请求和响应模型则处理在架构边界处必要的转换。用例接收一个已经验证的请求，在其执行过程中使用适当的域类型，并返回一个包含在`Result`对象中的响应模型，该对象可以被任何外层实现消费。
- en: In the Interface Adapters layer, these response models can be consumed by a
    variety of components including controllers handling HTTP requests, command-line
    interface command processors, or message queue handlers. Each adapter can transform
    the response data appropriately for its specific transport mechanism, converting
    it to JSON over HTTP, console output, or message payloads as needed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口适配器层，这些响应模型可以被各种组件消费，包括处理HTTP请求的控制器、命令行界面命令处理器或消息队列处理器。每个适配器都可以根据其特定的传输机制适当地转换响应数据，将其转换为HTTP上的JSON、控制台输出或所需的消息有效负载。
- en: Maintaining separation from external services
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持与外部服务的分离
- en: 'While request and response models handle data transformation at our API surface,
    our application must also interact with external services like email systems,
    file storage, and third-party APIs. The Application layer maintains separation
    from these services through **ports**— interfaces that define exactly what capabilities
    our application requires without specifying implementation details. In our task
    management system, external services might include:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然请求和响应模型处理API表面的数据转换，但我们的应用程序还必须与外部服务（如电子邮件系统、文件存储和第三方API）交互。应用程序层通过**端口**与这些服务保持分离——端口定义了应用程序所需的确切功能，而不指定实现细节。在我们的任务管理系统，外部服务可能包括：
- en: Email services for sending notifications (such as SendGrid or AWS SES)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于发送通知的电子邮件服务（例如SendGrid或AWS SES）
- en: File storage systems for attachments (such as AWS S3 or Google Cloud Storage)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于附件的文件存储系统（例如AWS S3或Google Cloud Storage）
- en: Authentication services (such as Auth0 or Okta)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证服务（例如Auth0或Okta）
- en: Calendar integration services (such as Google Calendar or Microsoft Outlook)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日历集成服务（例如Google日历或Microsoft Outlook）
- en: External messaging systems (such as Slack or Microsoft Teams)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部消息系统（例如Slack或Microsoft Teams）
- en: While request/response models and ports both serve to maintain clean architectural
    boundaries, they address different aspects of the system’s interaction with the
    outside world. Request/response models handle data transformation at our API boundaries,
    following consistent interfaces across all use cases (for example, `from_entity`
    and `to_execution_params`) to ensure uniform data handling.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然请求/响应模型和端口都旨在维护清晰的架构边界，但它们处理系统与外部世界交互的不同方面。请求/响应模型处理API边界的数据转换，遵循所有用例之间的一致接口（例如，`from_entity`和`to_execution_params`），以确保统一的数据处理。
- en: Ports, in contrast, define interfaces for the services our Application layer
    depends on with each port being specifically crafted to represent a particular
    external service’s capabilities. This dual approach ensures our core business
    logic remains independent of both data format details and external implementation
    specifics.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，端口定义了应用程序层依赖的服务接口，每个端口都是专门设计来表示特定外部服务功能的。这种双重方法确保我们的核心业务逻辑独立于数据格式细节和外部实现的具体细节。
- en: Interface boundaries
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口边界
- en: 'Ports allow the Application layer to specify exactly what capabilities it needs
    from external services without being coupled to specific implementations. Let’s
    examine how these boundary mechanisms work together:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 端口允许应用层精确指定它需要从外部服务中获取哪些功能，而不需要与特定实现绑定。让我们看看这些边界机制是如何协同工作的：
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This interface exemplifies information hiding at architectural boundaries. It
    reveals only the operations our Application layer needs while concealing all implementation
    details—whether notifications are sent via email, SMS, or another mechanism remains
    completely hidden from our core business logic.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口体现了在架构边界处的信息隐藏。它只揭示了应用层需要的操作，而隐藏了所有实现细节——通知是通过电子邮件、短信还是其他机制发送，对我们核心业务逻辑来说完全隐藏。
- en: 'Then, in each use case, we might leverage the defined port like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在每一个用例中，我们可能会像这样利用定义的端口：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This approach demonstrates the distinct roles of our boundary mechanisms:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法展示了我们的边界机制的不同角色：
- en: Request/response models handle the transformation of data at API boundaries
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求/响应模型处理API边界处的数据转换
- en: Ports define the service capabilities our use cases need
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口定义了用例需要的服务能力
- en: The Application layer uses both to maintain clean separation while coordinating
    the overall flow
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层使用这两个依赖关系来保持清晰的分离，同时协调整体流程
- en: You might recall in our previous example in the *Handling complex operations*
    section that we referenced a concrete `NotificationService`; here, we’ve matured
    our design by defining an abstract interface or port (`NotificationPort`). This
    shift from implementation to interface better aligns with the Dependency Rule
    and provides clearer architectural boundaries.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得在我们之前的例子中，在*处理复杂操作*部分，我们引用了一个具体的`NotificationService`；在这里，我们通过定义一个抽象接口或端口（`NotificationPort`）来成熟我们的设计。这种从实现到接口的转变更好地符合依赖规则，并提供了更清晰的架构边界。
- en: 'By depending only on the abstract capability interface rather than concrete
    implementations, our use case maintains information hiding in both directions:
    the use case knows nothing about notification implementation details, while notification
    services know nothing about use case internals beyond the parameters provided
    through the interface.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仅依赖于抽象能力接口而不是具体实现，我们的用例在两个方向上保持了信息隐藏：用例对通知实现细节一无所知，而通知服务对用例内部（除通过接口提供的参数外）一无所知。
- en: We can now explore how to effectively manage the external dependencies these
    boundaries help us control.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以探讨如何有效地管理这些边界帮助我们控制的对外部依赖。
- en: Supporting evolving service requirements
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持不断变化的服务需求
- en: As systems evolve, we need patterns that allow us to add new capabilities and
    adapt to changing service implementations. Let’s examine two key patterns for
    managing this evolution.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统的演变，我们需要允许我们添加新功能并适应不断变化的服务实现的模式。让我们看看管理这种演变的关键模式。
- en: Supporting optional integration
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持可选集成
- en: 'As applications grow, we often want to make certain service integrations optional
    or environment-specific. The optional services pattern helps manage this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，我们经常希望将某些服务集成设置为可选或特定于环境。可选服务模式有助于管理这一点：
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This approach provides several advantages:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法提供了几个优点：
- en: Core business operations remain focused and stable through the primary `task_repository`
    and `notification_service` dependencies
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过主要的`task_repository`和`notification_service`依赖关系，核心业务操作保持专注和稳定
- en: New capabilities can be added without modifying existing code using the flexible
    `_optional_services` dictionary
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用灵活的`_optional_services`字典在不修改现有代码的情况下添加新功能
- en: Optional services can be configured based on deployment needs via the `register_service`
    method
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选服务可以通过`register_service`方法根据部署需求进行配置
- en: Testing remains straightforward as dependencies are explicit in the constructor,
    with optional services clearly separated from the core requirements
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试保持简单，因为依赖关系在构造函数中是明确的，可选服务与核心需求明显分离
- en: The use of a dictionary to store optional services combined with conditional
    execution (e.g., `if analytics := self._optional_services.get('analytics')`) provides
    a clean pattern for gracefully handling features that may or may not be present
    in any given deployment.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典存储可选服务并结合条件执行（例如，`if analytics := self._optional_services.get('analytics')`）为优雅地处理可能或可能不在任何给定部署中存在的功能提供了一个干净的模式。
- en: Adapting to service changes
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适应服务变更
- en: 'When integrating with third-party services or managing system upgrades, we
    often need to switch between different interfaces. The adapter pattern helps us
    manage this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当与第三方服务集成或管理系统升级时，我们经常需要在不同的接口之间切换。适配器模式帮助我们管理这一点：
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The adapter pattern is particularly valuable in several scenarios:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式在几个场景中特别有价值：
- en: '**Integrating with third-party services**: The `ModernNotificationService`
    can be wrapped without modifying its interface'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与第三方服务集成**：`ModernNotificationService`可以被包装而不修改其接口'
- en: '**Managing system upgrades**: The adapter’s translation layer (`send_notification`
    to specific notification methods) isolates changes in service implementations'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理系统升级**：适配器的转换层（`send_notification`到特定的通知方法）隔离了服务实现中的变化'
- en: '**Supporting multiple implementations**: Different services can be adapted
    to the same `NotificationPort` interface'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持多种实现**：不同的服务可以被适配到相同的`NotificationPort`接口'
- en: '**Transitioning between service versions**: The mapping of structured payloads
    in `notify_task_completed` allows protocol evolution while maintaining backward
    compatibility'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在服务版本之间过渡**：`notify_task_completed`中结构化有效载荷的映射允许协议演变，同时保持向后兼容性'
- en: By using these patterns together, we can create systems that gracefully handle
    both optional features and changing service implementations while maintaining
    clean architectural boundaries.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合使用这些模式，我们可以创建能够优雅地处理可选功能和不断变化的服务实现，同时保持清晰架构边界的系统。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the Application layer of Clean Architecture, focusing
    on how it orchestrates domain objects and coordinates with external services to
    fulfill user needs. We learned how to implement use cases that maintain clean
    architectural boundaries while providing meaningful functionality.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Clean Architecture的应用层，重点关注它是如何编排领域对象并与外部服务协调以满足用户需求的。我们学习了如何实现使用案例，在保持清晰架构边界的同时提供有意义的函数。
- en: Through our task management system example, we discovered how to create use
    case interactors that coordinate domain objects while respecting the Dependency
    Rule introduced in [*Chapter 1*](Chapter_01.xhtml#_idTextAnchor015). We built
    upon the SOLID principles from [*Chapter 2*](Chapter_02.xhtml#_idTextAnchor040)
    and the type-awareness patterns from [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor060)
    to create robust, maintainable implementations. Our use cases effectively orchestrate
    the domain objects and services we developed in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor091),
    showing how Clean Architecture layers work together harmoniously.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的任务管理系统示例，我们发现了如何创建使用案例交互器，在尊重在[*第一章*](Chapter_01.xhtml#_idTextAnchor015)中引入的依赖规则的同时协调领域对象。我们基于[*第二章*](Chapter_02.xhtml#_idTextAnchor040)中的SOLID原则和[*第三章*](Chapter_03.xhtml#_idTextAnchor060)中的类型感知模式创建了健壮、可维护的实现。我们的使用案例有效地编排了我们在[*第四章*](Chapter_04.xhtml#_idTextAnchor091)中开发的领域对象和服务，展示了Clean
    Architecture层如何和谐地协同工作。
- en: 'We implemented several key patterns and concepts:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了几个关键模式和概念：
- en: Use case interactors that orchestrate domain operations
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于编排领域操作的使用案例交互器
- en: Request and response models that create clear boundaries
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建清晰边界的请求和响应模型
- en: Error handling patterns that maintain architectural separation
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护架构分离的错误处理模式
- en: Interface definitions that keep external concerns isolated
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持外部关注点隔离的接口定义
- en: These implementations demonstrated how to maintain the integrity of our architecture
    while handling real-world requirements. We saw how proper boundaries allow our
    application to evolve and adapt to changing needs without compromising its core
    design.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实现展示了如何在处理现实世界需求的同时保持我们架构的完整性。我们看到了适当的边界如何使我们的应用程序能够进化并适应不断变化的需求，而不会损害其核心设计。
- en: In [*Chapter 6*](Chapter_06.xhtml#_idTextAnchor144), we’ll explore how our clean
    boundaries enable the creation of effective adapters that translate between our
    Application layer and the outside world. We’ll see how the patterns we’ve established
    with request/response models and ports naturally extend to implementing controllers,
    gateways, and presenters.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第六章*](Chapter_06.xhtml#_idTextAnchor144)中，我们将探讨我们的清晰边界如何使创建有效的适配器成为可能，这些适配器可以在我们的应用层和外部世界之间进行转换。我们将看到我们与请求/响应模型和端口建立的模式如何自然地扩展到实现控制器、网关和演示者。
- en: Further reading
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Building Microservices: Designing Fine-Grained Systems* by Sam Newman. Although
    focused on microservices, this book’s chapters on service boundaries, inter-service
    communication, and data handling provide valuable insights for creating well-defined
    boundaries in application layers and can be applied to monolithic applications
    as well.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《构建微服务：设计细粒度系统》由山姆·纽曼所著。尽管本书专注于微服务，但其关于服务边界、服务间通信和数据处理的章节为创建应用层中定义明确的边界提供了宝贵的见解，并且这些内容同样适用于单体应用。
- en: '*Hexagonal Architecture* by Alistair Cockburn ([https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)).
    This article explains the ports and adapters (or hexagonal architecture) pattern,
    which is highly complementary to Clean Architecture principles. It provides a
    clear understanding of managing dependencies and boundary translation, which are
    central to implementing the Application layer.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《六边形架构》由阿利斯泰尔·科克本所著（[https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)）。这篇文章解释了端口和适配器（或六边形架构）模式，该模式与清洁架构原则高度互补。它提供了对管理依赖和边界转换的清晰理解，这些是实施应用层的关键。
