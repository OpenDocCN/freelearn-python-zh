- en: '8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Itertools Module
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming emphasizes stateless objects. In Python, this leads us
    to work with generator expressions, generator functions, and iterables, instead
    of large, mutable collection objects. In this chapter, we’ll look at elements
    of the `itertools` library. This library has numerous functions to help us work
    with iterable sequences of objects, as well as collection objects.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced iterator functions in [Chapter 3](Chapter_03.xhtml#x1-510003),
    [Functions, Iterators, and Generators](Chapter_03.xhtml#x1-510003). In this chapter,
    we’ll expand on that superficial introduction. We used some related functions
    in [Chapter 5](Chapter_05.xhtml#x1-1000005), [Higher-Order Functions](Chapter_05.xhtml#x1-1000005).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a large number of iterator functions in the `itertools` module. We’ll
    examine the combinatoric functions in the next chapter. In this chapter, we’ll
    look at the following three broad groupings of the remaining iterator functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions that work with potentially infinite iterators. These can be applied
    to any iterable or an iterator over any collection. For example, the `enumerate()`
    function doesn’t require an upper bound on the number of items in the iterable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions that work with finite iterators. Often, these are used to create a
    reduction of the source. For example, grouping the items produced by an iterator
    reduces the source to groups of items with a common key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `tee()` iterator function clones an iterator into several copies that can
    each be used independently. This provides a way to overcome the primary limitation
    of Python iterators: they can be used only once. This is memory-intensive, however,
    and redesign is often required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to emphasize the important limitation of iterables that we’ve touched
    upon in other places: they can only be used once.'
  prefs: []
  type: TYPE_NORMAL
- en: Iterables can be used only once.
  prefs: []
  type: TYPE_NORMAL
- en: This can be astonishing because there’s no error exception raised by attempting
    to reuse an iterator that’s been consumed fully. Once exhausted, they appear to
    have no elements and will only raise the `StopIteration` exception every time
    they’re used.
  prefs: []
  type: TYPE_NORMAL
- en: There are some other features of iterators that don’t involve such profound
    limitations. Note that many Python functions, as well as the `for` statement,
    will use the built-in `iter()` function to create as many iterators as required
    from a collection object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other features of iterators include:'
  prefs: []
  type: TYPE_NORMAL
- en: There’s no `len()` function for an iterator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterators, a subclass of iterables, can do `next()` operations, unlike a container.
    We’ll often use the built-in `iter()` to create an iterator that has a `next()`
    operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `for` statement makes the distinction between containers and other iterables
    invisible by evaluating the built-in `iter()` function. A container object, for
    example, a list, responds to this function by producing an iterator over the items.
    An iterable object that’s not a collection, for example, a generator function,
    returns itself, since it is designed to follow the `Iterator` protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These points will provide some necessary background for this chapter. The idea
    of the `itertools` module is to leverage what iterables can do to create succinct,
    expressive applications without the complicated-looking overheads associated with
    the details of managing the iterables.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 Working with the infinite iterators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `itertools` module provides a number of functions that we can use to enhance
    or enrich an iterable source of data. We’ll look at the following three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count()`: This is an unlimited version of the `range()` function. An upper
    bound must be imposed by the consumer of this sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cycle()`: This will reiterate a cycle of values. The consumer must decide
    when enough values have been produced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repeat()`: This can repeat a single value an indefinite number of times. The
    consumer must end the repetition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our goal is to understand how these various iterator functions can be used in
    generator expressions and with generator functions.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.1 Counting with count()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The built-in `range()` function is defined by an upper limit: the lower limit
    and step values are optional. The `count()` function, on the other hand, has a
    start and optional step, but no upper limit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function can be thought of as the primitive basis for a function such
    as the built-in `enumerate()` function. We can define the `enumerate()` function
    in terms of `zip()` and `count()` functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `enumerate()` function behaves as if it’s a `zip()` function that uses the
    `count()` function to generate the values associated with some iterable source
    of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, the following two expressions are equivalent to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Both will emit a sequence of numbers of two-tuples. The first item in each tuple
    is an integer counter. The second item comes from the iterator. In this example,
    the iterator is built from a string of characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s something we can do with the `count()` function that’s difficult to
    do with the `enumerate()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The value of `count(b,`` s)` is the sequence of values {b,b + s,b + 2s,b + 3s,...}.
    In this example, it will provide values of 1, 4, 7, 10, and so on as the identifiers
    for each value from the enumerator. The `enumerate()` function doesn’t provide
    a way to change the step.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, of course, combine generator functions to achieve this result. Here’s
    how changing the step can be done with the `enumerate()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This shows how a new value, 1 + 3e, is computed from the source enumeration
    value of e. This behaves like the sequence started at 1 and is incremented by
    3\.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.2 Counting with float arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `count()` function permits non-integer values. We can use something such
    as the `count(0.5,`` 0.1)` expression to provide floating-point values. This will
    accumulate an error if the increment value doesn’t have an exact representation.
    It’s generally better to use integer `count()` arguments such as `(0.5+x*.1`` for`` x`` in`` count())`
    to ensure that representation errors don’t accumulate.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a way to examine the accumulating error. This exploration of the float
    approximation shows some interesting functional programming techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll define a function that will evaluate items from an iterator until some
    condition is met. This is a way to find the first item that meets some criteria
    defined by a function. Here’s how we can define a `find_first()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function starts by getting the next value from the iterator object. No
    specific type is provided; the type variable `T` tells mypy that the source iterator
    and the target result will be the same type. If the chosen item passes the test,
    that is, this is the desired value, iteration stops and the return value will
    be of the given type associated with the type variable, `T`. Otherwise, we’ll
    evaluate this function recursively to search for a subsequent value that passes
    the test.
  prefs: []
  type: TYPE_NORMAL
- en: Because the tail-call recursion is not replaced with an optimized `for` statement,
    this is limited to iterables with about 1,000 items.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have some series of values computed by a generator, this will consume
    items from the iterator. Here’s a silly example. Let’s say we have an approximation
    that is a sum of a series of values. One example is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ( 1 1 1 ) π = 4 arctan (1) = 4 1− 3-+ 5-− 7-⋅⋅⋅ ](img/file64.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The terms of this series can be created by a generator function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will yield values like `Fraction(1,`` 1)`, `Fraction(-1,`` 3)`, `Fraction(1,`` 5)`,
    and `Fraction(-1,`` 7)`. It will yield an infinite number of them. We want values
    up until the first value that meets some criteria. For example, we may want to
    know the first value that will be less than ![1100](img/file65.jpg) (this is pretty
    easy to work out with pencil and paper to check the results):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our goal is to compare counting with float values against counting with integer
    values and then applying a scaling factor. We want to define a source that has
    both sequences as pairs. As an introduction to the concept, we’ll look at generating
    pairs from two parallel sources. Then we’ll return to the computation shown above.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `source` object is a generator of the pairs of
    pure float and int-to-float values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Pair` tuple will have two float values: one generated by summing float
    values, and the other generated by counting integers and multiplying by a floating-point
    scaling factor.'
  prefs: []
  type: TYPE_NORMAL
- en: The generator, `source`, has provided a type hint on the assignment statement
    to show that it iterates over the pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we evaluate the `find_first(not_equal,`` source)` method, we’ll repeatedly
    compare float approximations of decimal values until they differ. One is a sum
    of 0.1 values: 0.1 ×∑ [x∈ℕ]1\. The other is a sum of integer values, weighted
    by 0.1: ∑ [x∈ℕ]0.1\. Viewed as abstract mathematical definitions, there’s no distinction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can formalize it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∑ ∑ 0.1 × 1 ≡ 0.1 x∈ℕ x∈ℕ ](img/file66.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With concrete approximations of the abstract numbers, however, the two values
    will differ. The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After about 928 iterations, the sum of the error bits has accumulated to 10^(−12).
    Neither value has an exact binary representation.
  prefs: []
  type: TYPE_NORMAL
- en: The `find_first()` function example is close to the Python recursion limit.
    We’d need to rewrite the function to use tail-call optimization to locate examples
    with a larger cumulative error value.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve left this as change as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'The smallest detectable difference can be computed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This uses a simple equality check instead of an error range. After six steps,
    the `count(0,`` 0.1)` method has accumulated a tiny, but measurable, error of
    10^(−16). While small, these error values can accumulate to become more significant
    and visible in a longer computation. When looking at how ![-1 10](img/file69.jpg)
    is represented as a binary value, an infinite binary expansion would be required.
    This is truncated to about 10^(−16) ≈ 2^(−53) from the conceptual value. The magic
    number 53 is the number of bits available in IEEE standard for 64-bit floating-point
    values.
  prefs: []
  type: TYPE_NORMAL
- en: This is why we generally count things with ordinary integers and apply a weighting
    to compute a floating-point value.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.3 Re-iterating a cycle with cycle()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `cycle()` function repeats a sequence of values. This can be used when partitioning
    data into subsets by cycling among the dataset identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: We can imagine using it to solve silly fizz-buzz problems. Visit [http://rosettacode.org/wiki/FizzBuzz](http://rosettacode.org/wiki/FizzBuzz)
    for a comprehensive set of solutions to a fairly trivial programming problem.
    Also see [https://projecteuler.net/problem=1](https://projecteuler.net/problem=1)
    for an interesting variation on this theme.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `cycle()` function to emit sequences of `True` and `False` values
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These two generator expressions can produce infinite sequences with a pattern
    of `[``True``,` `False``,` `False``,` `True``,` `False``,` `False``,` `...]` or
    `[``True``,` `False``,` `False``,` `False``,` `False``,` `True``,` `False``,`
    `False``,` `False``,` `False``,` `...]`. These are iterators and can only be consumed
    once. They will tend to maintain their internal state. If we don’t consume precisely
    15 values, the least common multiple of their cycles, the next time we consume
    values, they will be in an unexpected, in-between state.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we zip together a finite collection of numbers and these two derived values,
    we’ll get a set of three-tuples with a number, the multiple of three true-false
    condition, and the multiple of five true-false condition. It’s important to introduce
    a finite iterable to create a proper upper bound on the volume of data being generated.
    Here’s a sequence of values and their multiplier conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a generator; we can use `list(multipliers)` to see the resulting object.
    It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now decompose the triples and use a filter to pass numbers that are
    multiples and reject all others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` clause decomposes each triple into two parts: the value, `i`, and
    the flags, `multipliers`. If any of the multipliers are true, the value is passed;
    otherwise, it’s rejected.'
  prefs: []
  type: TYPE_NORMAL
- en: The `cycle()` function has another, more valuable, use for exploratory data
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Using cycle() for data sampling
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We often need to work with samples of large sets of data. The initial phases
    of cleansing and model creation are best developed with small sets of data and
    tested with larger and larger sets of data. We can use the `cycle()` function
    to fairly select rows from within a larger set. This is distinct from making random
    selections and trusting the fairness of the random number generator. Because this
    approach is repeatable and doesn’t rely on a random number generator, it can be
    applied to very large datasets processed by multiple computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a population size, N[p], and the desired sample size, N[s], this is the
    required size of the cycle, c, that will produce appropriate subsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![c = Np- Ns ](img/file72.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ll assume that the data can be parsed with a common library like the `csv`
    module. This leads to an elegant way to create subsets. Given a value for the
    `cycle_size` and two open files, `source_file` and `target_file`, we can create
    subsets using the following function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `subset_iter()` function uses a `cycle()` function based on the selection
    factor, `cycle_size`. For example, we might have a population of ten million records;
    a 1,000-record subset would be built with `cycle_size` set to c = ![107 103](img/file73.jpg)
    = 10,000\. We’d keep one record in ten thousand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `subset_iter()` function can be used by a function that reads from a source
    file and writes a subset to a destination file. This processing is part of the
    following function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can use this generator function to filter the data using the `cycle()` function
    and the source data that’s available from the `csv` reader. Since the chooser
    expression and the expression used to write the rows are both non-strict, there’s
    little memory overhead from this kind of processing.
  prefs: []
  type: TYPE_NORMAL
- en: We can also rewrite this method to use `compress()`, `filter()`, and `islice()`
    functions, as we’ll see later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This design can also be used to reformat a file from any non-standard CSV-like
    format into a standardized CSV format. As long as we define a parser function
    that returns consistently defined tuples of strings and write consumer functions
    that write tuples to the target files, we can do a great deal of cleansing and
    filtering with relatively short, clear scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.4 Repeating a single value with repeat()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `repeat()` function seems like an odd feature: it returns a single value
    over and over again. It can serve as an alternative for the `cycle()` function
    when a single value is needed.'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between selecting all of the data and selecting a subset of the
    data can be expressed with this. The expression `(x==0`` for`` x`` in`` cycle(range(size)))`
    emits a `[True,`` False,`` False,`` ...]` pattern, suitable for picking a subset.
    The function `(x==0`` for`` x`` in`` repeat(0))` emits a `[True,`` True,`` True,`` ...]`
    pattern, suitable for selecting all of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of the following kinds of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to make a single parameter change, which will either pick all
    data or pick a subset of data. We can also use `cycle([True])` instead of `repeat(True)`;
    the results are identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern can be extended to randomize the subset chosen. The following
    technique adds an additional kind of choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `randomized()` function generates a potentially infinite sequence of random
    numbers over a given range. This fits the pattern of `cycle()` and `repeat()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This provides us the ability to use a variety of techniques for selecting subsets.
    A small change among available functions `all()`, `subset()`, and `randomized()`
    lets us change our sampling approach in a way that seems succinct and expressive.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Using the finite iterators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `itertools` module provides a number of functions that we can use to produce
    finite sequences of values. We’ll look at 10 functions in this module, plus some
    related built-in functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enumerate()`: This function is actually part of the `__builtins__` package,
    but it works with an iterator and is very similar to functions in the `itertools`
    module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accumulate()`: This function returns a sequence of reductions of the input
    iterable. It’s a higher-order function and can do a variety of clever calculations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chain()`: This function combines multiple iterables serially.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupby()`: This function uses a function to decompose a single iterable into
    a sequence of iterables over subsets of the input data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zip_longest()`: This function combines elements from multiple iterables. The
    built-in `zip()` function truncates the sequence at the length of the shortest
    iterable. The `zip_longest()` function pads the shorter iterables with the given
    fill value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compress()`: This function filters one iterable based on a second, parallel
    iterable of Boolean values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`islice()`: This function is the equivalent of a slice of a sequence when applied
    to an iterable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dropwhile()` and `takewhile()`: Both of these functions use a Boolean function
    to filter items from an iterable. Unlike `filter()` or `filterfalse()`, these
    functions rely on a single `True` or `False` value to change their filter behavior
    for all subsequent values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filterfalse()`: This function applies a filter function to an iterable. This
    complements the built-in `filter()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`starmap()`: This function maps a function to an iterable sequence of tuples
    using each iterable as an `*args` argument to the given function. The `map()`
    function does a similar thing using multiple parallel iterables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll start with functions that could be seen as useful for grouping or arranging
    items of an `Iterator`. After that, we’ll look at functions that are more appropriate
    for filtering and mapping the items.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1 Assigning numbers with enumerate()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the [Using enumerate() to include a sequence number](Chapter_04.xhtml#x1-920007)
    section of [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    we used the `enumerate()` function to make a naive assignment of rank numbers
    to sorted data. We can do things such as pairing up a value with its position
    in the original sequence, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will sort the items in `raw_values` in order, create two-tuples with an
    ascending sequence of numbers, and materialize an object we can use for further
    calculations.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](Chapter_07.xhtml#x1-1530007), [Complex Stateless Objects](Chapter_07.xhtml#x1-1530007),
    we implemented an alternative form of the `enumerate()` function, the `rank()`
    function, which handles ties in a more statistically useful way.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating rows of data is a common feature that is added to a parser to record
    the source data row numbers. In many cases, we’ll create some kind of `row_iter()`
    function to extract the string values from a source file. This may iterate over
    the string values in tags of an XML file or in columns of a CSV file. In some
    cases, we may even be parsing data presented in an HTML file parsed with Beautiful
    Soup.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    we parsed an XML file to create a simple sequence of position tuples. We then
    created legs with a start, end, and distance. We did not, however, assign an explicit
    leg number. If we ever sorted the trip collection, we’d be unable to determine
    the original ordering of the legs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 7](Chapter_07.xhtml#x1-1530007), [Complex Stateless Objects](Chapter_07.xhtml#x1-1530007),
    we expanded on the basic parser to create named tuples for each leg of the trip.
    The output from this enhanced parser looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The value of `trip[0]` is quite wide, too wide for the book. To keep the output
    in a form that fits in this book’s pages, we’ve wrapped the string representation
    of the value, and used `pprint` to show the individual lines. The first `Leg`
    object is a short trip between two points on the Chesapeake Bay.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a function that will build a more complex tuple with the input order
    information as part of the tuple. First, we’ll define a slightly more complex
    version of the `Leg` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Leg` definition is similar to the variations shown in [Chapter 7](Chapter_07.xhtml#x1-1530007),
    [Complex Stateless Objects](Chapter_07.xhtml#x1-1530007), specifically the `LegNT`
    definition. We’ll define a function that decomposes pairs and creates `Leg` instances
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can use this function to enumerate each pair of start and end points. We’ll
    decompose the pair and then re-assemble the `order`, `start`, and `end` parameters
    and the `haversine(start,end)` parameter’s value as a single `Leg` instance. This
    generator function will work with an iterable sequence of pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of the preceding explanation, it is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We’ve parsed the original file into the path points, created start-end pairs,
    and then created a trip that was built of individual `Leg` objects. The `enumerate()`
    function ensures that each item in the iterable sequence is given a unique number
    that increments from the default starting value of 0\. A second argument value
    to the `enumerate()` function can be given to provide a different starting value.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.2 Running totals with accumulate()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `accumulate()` function folds a given function into an iterable, accumulating
    a series of reductions. This will iterate over the running totals from another
    iterator; the default function is `operator.add()`. We can provide alternative
    functions to change the essential behavior from sum to product. The Python library
    documentation shows a particularly clever use of the `max()` function to create
    a sequence of maximum values so far.
  prefs: []
  type: TYPE_NORMAL
- en: One application of running totals is quartiling data. The quartile is one of
    many measures of position. The general approach is to multiply a sample’s value
    by a scaling factor to convert it to the quartile number. If values range from
    0 ≤ v[i] < N, we can scale by ⌈![N 4-](img/file74.jpg)⌉ to convert any value,
    v[i], to a value in the range 0 to 3, which map to the various quartiles. The
    `math.ceil()` function is used to round the scaling fraction up to the next higher
    integer. This will ensure that no scaled value will produce a scaled result of
    4, an impossible fifth quartile.
  prefs: []
  type: TYPE_NORMAL
- en: If the minimum value of v[i] is not zero, we’ll need to subtract this from each
    value before multiplying by the scaling factor.
  prefs: []
  type: TYPE_NORMAL
- en: In the [Assigning numbers with enumerate()](#x1-1780001) section, we introduced
    a sequence of latitude-longitude coordinates that describe a sequence of legs
    on a voyage. We can use the distances as a basis for quartiling the waypoints.
    This allows us to determine the midpoint in the trip.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the previous section for the value of the `trip` variable. The value is
    a sequence of `Leg` instances. Each `Leg` object has a start point, an end point,
    and a distance. The calculation of quartiles looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We extracted the distance values and computed the accumulated distances for
    each leg. The last of the accumulated distances is the total. The value of the
    `quartiles` variable is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `zip()` function to merge this sequence of quartile numbers with
    the original data points. We can also use functions such as `groupby()` to create
    distinct collections of the legs in each quartile.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.3 Combining iterators with chain()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A collection of iterators can be unified into a single sequence of values via
    the `chain()` function. This can be helpful to combine data that was decomposed
    via the `groupby()` function. We can use this to process a number of collections
    as if they were a single collection.
  prefs: []
  type: TYPE_NORMAL
- en: Python’s `contextlib` offers a clever class, `ExitStack()`, which can be used
    to perform a number of operations at the end of the context in a `with` statement.
    This permits an application to create any number of sub-contexts, all of which
    will have a proper `__enter__()` and `__exit__()` evaluated. This is particularly
    useful when we have an indefinite number of files to open.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we can combine the `itertools.chain()` function with a `contextlib.ExitStack`
    object to process—and properly close—a collection of files. Further, the data
    from all of these files will be processed as a single iterable sequence of values.
    Instead of wrapping each individual file operation in a `with` statement, we can
    wrap all of the operations in a single `with` context.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a single context for multiple files like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We’ve created an `ExitStack` object that can contain a number of individual
    contexts open. When the `with` statement finishes, all items in the `ExitStack`
    object will be closed properly. In the above function, a sequence of open file
    objects is assigned to the `files` variable. The `stack.enter_context()` method
    enters these objects into the `ExitStack` object to be properly closed.
  prefs: []
  type: TYPE_NORMAL
- en: Given the sequence of files in the `files` variable, we created a sequence of
    CSV readers in the `readers` variable. In this case, all of our files have a common
    tab-delimited format, which makes it very pleasant to open them with a simple,
    consistent application of a function to the sequence of files.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we chained all of the readers into a single iterator with `chain(*readers)`.
    This was used to yield the sequence of rows from all of the files.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that we can’t return the `chain(*readers)` object. If
    we do, this would exit the `with` statement context, closing all the source files.
    Instead, we must yield individual rows from the generator so that the `with` statement
    context is kept active until all the rows are consumed.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.4 Partitioning an iterator with groupby()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can use the `groupby()` function to partition an iterator into smaller iterators.
    This works by evaluating the given `key` function for each item in the given iterable.
    If the key value matches the previous item’s key, the two items are part of the
    same partition. If the key does not match the previous item’s key, the previous
    partition is ended and a new partition is started. Because the matching is done
    on adjacent items in the iterable, the values must be sorted by the key.
  prefs: []
  type: TYPE_NORMAL
- en: The output from the `groupby()` function is a sequence of two-tuples. Each tuple
    has the group’s key value and an iterable over the items in the group, something
    like `[(key,`` iter(group)),`` (key,`` iter(group)),`` ...]`. Each group’s iterator
    can then be processed to create a materialized collection, or perhaps reduce it
    to some summary value.
  prefs: []
  type: TYPE_NORMAL
- en: In the [Running totals with accumulate()](#x1-1790002) section, earlier in the
    chapter, we showed how to compute quartile values for an input sequence. We’ll
    extend that to create groups based on the distance quartiles. Each group will
    be an iterator over legs that fit into the range of distances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the `trip` variable with the raw data and the `quartile` variable with
    the quartile assignments, we can group the data using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will start by zipping the quartile numbers with the raw trip data, creating
    an iterator over two-tuples with quartile number and leg. The `groupby()` function
    will use the given lambda object to group by the quartile number, `q_raw[0]`,
    in each `q_raw` tuple. We used a `for` statement to examine the results of the
    `groupby()` function. This shows how we get a group key value and an iterator
    over members of each individual group.
  prefs: []
  type: TYPE_NORMAL
- en: The input to the `groupby()` function must be sorted by the key values. This
    will ensure that all of the items in a group will be adjacent. For very large
    datasets, this may force us to use the operating system’s sort in the rare cases
    of a file being too large to fit into memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we can also create groups using a `defaultdict(list)` object. This
    avoids a sort step, but can build a large, in-memory dictionary of lists. The
    function can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We created a `defaultdict` object that will use `list()` as the default value
    associated with each new key. The type hints clarify the relationship between
    the `key` function, which emits objects of some arbitrary type associated with
    the type variable `KT`, and the dictionary, which uses the same type, `KT`, for
    the keys.
  prefs: []
  type: TYPE_NORMAL
- en: Each item will have the given `key()` function applied to create a key value.
    The item is appended to the list in the `defaultdict` object with the given key.
  prefs: []
  type: TYPE_NORMAL
- en: Once all of the items are partitioned, we can then return each partition as
    an iterator over the items that share a common key. This will retain all of the
    original values in memory, and introduce a dictionary and a list for each unique
    key value. For very large datasets, this may require more memory than is available
    on the processor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type hints clarify that the source is some arbitrary type, associated with
    the variable `DT`. The result will be an iterator that includes iterators of the
    type `DT`. This makes a strong statement that no transformation is happening:
    the range type matches the input domain type.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.5 Merging iterables with zip_longest() and zip()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We saw the `zip()` function in [Chapter 4](Chapter_04.xhtml#x1-740004), [Working
    with Collections](Chapter_04.xhtml#x1-740004). The `zip_longest()` function differs
    from the `zip()` function in an important way: whereas the `zip()` function stops
    at the end of the shortest iterable, the `zip_longest()` function pads short iterables
    with a given value, and stops at the end of the longest iterable.'
  prefs: []
  type: TYPE_NORMAL
- en: The `fillvalue=` keyword parameter allows filling with a value other than the
    default value, `None`.
  prefs: []
  type: TYPE_NORMAL
- en: For most exploratory data analysis applications, padding with a default value
    is statistically difficult to justify. The Python Standard Library document includes
    the `grouper` recipe that can be done with the `zip_longest()` function. It’s
    difficult to expand on this without drifting far from our focus on data analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.6 Creating pairs with pairwise())
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `pairwise()` function consumes a source iterator, emitting the items in
    pairs. See the `legs()` function in [Chapter 4](Chapter_04.xhtml#x1-740004), [Working
    with Collections](Chapter_04.xhtml#x1-740004), for an example of creating pairs
    from a source iterable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a small example of transforming a sequence of characters into adjacent
    pairs of characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This kind of analysis locates letter pairs, called ”bigrams” or ”digraphs.”
    This can be helpful when trying to understand a simple letter substitution cipher.
    The frequency of bigrams in encoded text can suggest possible ways to break the
    cipher.
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3.10, this function was moved from being a recipe to being a proper
    `itertools` function.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.7 Filtering with compress()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The built-in `filter()` function uses a predicate to determine whether an item
    is passed or rejected. Instead of a function that calculates a value, we can use
    a second, parallel iterable to determine which items to pass and which to reject.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the [Re-iterating a cycle with cycle()](#x1-1740003) section of this chapter,
    we looked at data selection using a simple generator expression. Its essence was
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Each value for the rule iterable must be a Boolean value. To choose all items,
    it can repeat a `True` value. To pick a fixed subset, it can cycle among a `True`
    value followed by copies of a `False` value. To pick 1/4 of the items, we could
    use `cycle([True]`` +`` 3*[False])`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list comprehension can be revised as `compress(some_source,`` selectors)`,
    using a function for the `selectors` argument value. If we make that change, the
    processing is simplified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: These examples rely on the alternative selection rules `all_rows()`, `subset()`,
    and `randomized()`, as shown previously. The `subset()` and `randomized()` functions
    must be defined with a proper parameter with the value for c to pick ![1 c](img/file75.jpg)
    of the rows from the source. The `selectors` expression must build an iterable
    over `True` and `False` values based on one of the selection rule functions. The
    rows to be kept are selected by applying the `source` iterable to the row-selection
    iterable.
  prefs: []
  type: TYPE_NORMAL
- en: Since all of this is done as a lazy evaluation, rows are not read from the source
    until required. This allows us to process very large sets of data efficiently.
    Also, the relative simplicity of the Python code means that we don’t really need
    a complex configuration file and an associated parser to make choices among the
    selection rules. We have the option to use this bit of Python code as the configuration
    for a larger data-sampling application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of the `filter()` function as having the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We cloned the iterable using the `tee()` function. We’ll look at this function
    in detail later. The `map()` function will generate results of applying the filter
    predicate function, `function()`, to each value in the iterable, yielding a sequence
    of `True` and `False` values. The sequence of Booleans is used to compress the
    original sequence, passing only items associated with `True`. This builds the
    features of the `filter()` function from the `compress()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The function’s hint can be broadened to `Callable[[SrcT],`` Any]`. This is because
    the `compress()` function will make use of the truthiness or falsiness of the
    values returned. It seems helpful to emphasize that the values will be understood
    as Booleans, hence the use of `bool` in the type hint, not `Any`.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.8 Picking subsets with islice()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    we looked at slice notation to select subsets from a collection. Our example was
    to pair up items sliced from a list object. The following is a simple list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create pairs using list slices as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `islice()` function gives us similar capabilities without the overhead
    of materializing a list object. This will work with an iterable of any size. The
    `islice()` function accepts an `Iterable` source, and the three parameters that
    define a slice: the start, stop, and step values. This means `islice(source,`` 1,`` None,`` 2)`
    is similar to `source[1::2]`. Instead of the slice-like shorthand using `:`, optional
    parameter values are used; the rules match the built-in `range()` function. The
    important difference is that `source[1::2]` only works for a `Sequence` object
    like a list or tuple. The `islice(source,`` 1,`` None,`` 2)` function works for
    any iterable, including an iterator object, or a generator expression.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will create pairs of values of an iterable using the
    `islice()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We created two independent iterators over a collection of data points in the
    `flat` variable. These could be two separate iterators over an open file or a
    database result set. The two iterators need to be independent to ensure a change
    in one `islice()` source doesn’t interfere with the other `islice()` source.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will produce a sequence of two-tuples from the original sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Since `islice()` works with an iterable, this kind of design can work with extremely
    large sets of data. We can use this to pick a subset out of a larger set of data.
    In addition to using the `filter()` or `compress()` functions, we can also use
    the `islice(source,`` 0,`` None,`` c)` method to pick a ![1c](img/file78.jpg)-sized
    subset from a larger set of data.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.9 Stateful filtering with dropwhile() and takewhile()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `dropwhile()` and `takewhile()` functions are stateful filter functions.
    They start in one mode; the given predicate function is a kind of flip-flop that
    switches the mode. The `dropwhile()` function starts in reject mode; when the
    function becomes `False`, it switches to pass mode. The `takewhile()` function
    starts in pass mode; when the given function becomes `False`, it switches to reject
    mode. Since these are filters, they will consume the entire iterable argument
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use these to skip header or footer lines in an input file. We use the
    `dropwhile()` function to reject header rows and pass the remaining data. We use
    the `takewhile()` function to pass data and reject trailer rows. We’ll return
    to the simple GPL file format shown in [Chapter 3](Chapter_03.xhtml#x1-510003),
    [Functions, Iterators, and Generators](Chapter_03.xhtml#x1-510003). The file has
    a header that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is followed by rows that look like the following example data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there’s an invisible tab character, `\t`, between the RGB color triple
    and the color name. To make it more visible, we can typeset the example like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This little typesetting technique seems a little misleading, since it doesn’t
    look like that in most programming editors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can locate the final line of the headers—the # line—using a parser based
    on the `dropwhile()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We created a CSV reader to parse the lines based on tab characters. This will
    neatly separate the `color` three-tuple from the name. The three-tuple will need
    further parsing. This will produce an iterator that starts with the `#` line and
    continues with the rest of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `islice()` function to discard the first item of an iterable.
    The `islice(rows,`` 1,`` None)` expression is similar to asking for a `rows[1:]`
    slice: the first item is quietly discarded. Once the last of the heading rows
    have been discarded, we can parse the color tuples and return more useful color
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: For this particular file, we can also use the number of columns located by the
    CSV `reader()` function. Header rows only have a single column, allowing the use
    of the `dropwhile(lambda`` row:`` len(row)`` ==`` 1,`` rdr)` expression to discard
    header rows. This isn’t a good approach in general, because locating the last
    line of the headers is often easier than trying to define some general pattern
    that distinguishes all header (or trailer) lines from the meaningful file content.
    In this case, the header rows were distinguishable by the number of columns; this
    is a rarity.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.10 Two approaches to filtering with filterfalse() and filter()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Chapter 5](Chapter_05.xhtml#x1-1000005), [Higher-Order Functions](Chapter_05.xhtml#x1-1000005),
    we looked at the built-in `filter()` function. The `filterfalse()` function from
    the `itertools` module could be defined from the `filter()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the `filter()` function, the predicate function can be the `None` value.
    The value of the `filter(None,`` iterable)` method is all the `True` values in
    the iterable. The value of the `filterfalse(None,`` iterable)` method is all the
    `False` values from the iterable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The point of having the `filterfalse()` function is to promote reuse. If we
    have a succinct function that makes a filter decision, we should be able to use
    that function to partition input to pass as well as reject groups without having
    to fiddle around with logical negation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This kind of processing into two subsets will include all items from the source.
    The `rule()` function is unchanged, and we can’t introduce a subtle logic bug
    through improper negation of this function.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.11 Applying a function to data via starmap() and map()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The built-in `map()` function is a higher-order function that applies a function
    to items from an iterable. We can think of the simple version of the `map()` function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This works well when the `arg_iter` parameter is an iterable that provides individual
    values. The actual `map()` function is quite a bit more sophisticated than this,
    and can also work with a number of iterables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `starmap()` function in the `itertools` module is the `*args` version of
    the `map()` function. We can imagine the definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This reflects a small shift in the semantics of the `map()` function to properly
    handle an iterable-of-tuples structure. Each tuple is decomposed and applied to
    the various positional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: When we look at the trip data, from the preceding commands, we can redefine
    the construction of a `Leg` object based on the `starmap()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use the `starmap()` function to assemble the `Leg` objects, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how it looks when we apply this `get_trip_starmap()` function to read
    source data and iterate over the created `Leg` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `make_leg()` function accepts a pair of `Point` objects, and returns a `Leg`
    object with the start point, end point, and distance between the two points. The
    `legs()` function from [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with
    Collections](Chapter_04.xhtml#x1-740004), creates pairs of `Point` objects that
    reflect the start and end of a leg of the voyage. The pairs created by `legs()`
    are provided as input to `make_leg()` to create proper `Leg` objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `map()` function can also accept multiple iterables. When we use `map(f,`` iter1,`` iter2,`
    `...)`, it behaves as if the iterators are zipped together, and the `starmap()`
    function is applied.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of the `map(function,`` iter1,`` iter2,`` iter3)` function as if
    it were `starmap(function,`` zip(iter1,`` iter2,`` iter3))`.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of the `starmap(function,`` some_list)` method is to replace a potentially
    wordy `(function(*args)`` for`` args`` in`` some_list)` generator expression with
    something that avoids the potentially overlooked `*` operator applied to the function
    argument values.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 Cloning iterators with tee()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `tee()` function gives us a way to circumvent one of the important Python
    rules for working with iterables. The rule is so important, we’ll repeat it here:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterators can be used only once.
  prefs: []
  type: TYPE_NORMAL
- en: The `tee()` function allows us to clone an iterator. This seems to free us from
    having to materialize a sequence so that we can make multiple passes over the
    data. Because `tee()` can use a lot of memory, it is sometimes better to materialize
    a list and process it multiple times, rather than trying to use the potential
    simplification of the `tee()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a simple average for an immense dataset could be written in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This would compute an average without appearing to materialize the entire dataset
    in memory. Note that the type hint of `float` doesn’t preclude integers. The mypy
    program is aware of the numeric processing rules, and this definition provides
    a flexible way to specify that either `int` or `float` will work.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 The itertools recipes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Within the itertools chapter of the Python library documentation, there’s a
    subsection called Itertools Recipes, which contains outstanding examples of ways
    to use the various `itertools` functions. Since there’s no reason to reproduce
    these, we’ll reference them here. They should be considered as required reading
    on functional programming in Python.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, visit [https://docs.python.org/3/library/itertools.html#itertools-recipes](https://docs.python.org/3/library/itertools.html#itertools-recipes).
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that these aren’t importable functions in the `itertools`
    modules. A recipe needs to be read and understood and then, perhaps, copied or
    modified before it’s included in an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the recipes involve some of the more advanced techniques shown in the
    next chapter; they’re not in the following table. We’ve preserved the ordering
    of items in the Python documentation, which is not alphabetical. The following
    table summarizes some of the recipes that show functional programming design patterns
    built from the `itertools` basics:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '| Function Name | Arguments | Results |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `take` | `(n,`` iterable)` | Yields the first n items of the iterable as
    a list. This wraps a use of `islice()` in a simple name. |'
  prefs: []
  type: TYPE_TB
- en: '| `tabulate` | `(function,` `start=0)` | Yields `function(0)`, `function(1)`,
    and so on. This is based on a `map(function,`` count())`. |'
  prefs: []
  type: TYPE_TB
- en: '| `consume` | `(iterator,`` n)` | Advance the iterator n steps ahead. If n
    is `None`, it consumes all of the values from the iterator. |'
  prefs: []
  type: TYPE_TB
- en: '| `nth` | `(iterable,`` n,` `default=None)` | Return only the nth item or a
    default value. This wraps the use of `islice()` in a simple name. |'
  prefs: []
  type: TYPE_TB
- en: '| `quantify` | `(iterable,` `pred=bool)` | Returns the count of how many times
    the predicate is true. This uses `sum()` and `map()` and relies on the way a Boolean
    predicate is effectively 1 when converted to an integer value. |'
  prefs: []
  type: TYPE_TB
- en: '| `padnone` | `(iterable)` | Yields the iterable’s elements and then yields
    `None` indefinitely. This can create functions that behave like `zip_longest()`
    or `map()`. |'
  prefs: []
  type: TYPE_TB
- en: '| `ncycles` | `(iterable,`` n)` | Yields the sequence elements n times. |'
  prefs: []
  type: TYPE_TB
- en: '| `dotproduct` | `(vec1,`` vec2)` | A dot product multiplies two vector’s values
    and finds the sum of the result. |'
  prefs: []
  type: TYPE_TB
- en: '| `flatten` | `(listOfLists)` | This function flattens one level of nesting.
    This chains the various lists together into a single list. |'
  prefs: []
  type: TYPE_TB
- en: '| `repeatfunc` | `(func,`` times=` `None,`` *args)` | This calls the given
    function, `func`, repeatedly with specified arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| `grouper` | `(iterable,`` n,` `fillvalue=None)` | Yields the iterable’s elements
    as a sequence of fixed-length chunks or blocks. |'
  prefs: []
  type: TYPE_TB
- en: '| `roundrobin` | `(*iterables)` | Yields values taken from each of the iterables.
    For example, `roundrobin(’ABC’,`` ’D’,`` ’EF’)` is `’A’,`` ’D’,`` ’E’,`` ’B’,`` ’F’,`` ’C’`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `partition` | `(pred,`` iterable)` | This uses a predicate to partition entries
    into `False` entries and `True` entries. The return value is a pair of iterators.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `unique_everseen` | `(iterable,` `key=None)` | Yields the unique elements
    of the source iterable, preserving order. It also remembers all elements ever
    seen. |'
  prefs: []
  type: TYPE_TB
- en: '| `unique_justseen` | `(iterable,` `key=None)` | Yields unique elements, preserving
    order. It remembers only the element most recently seen. This is useful for deduplicating
    or grouping a sorted sequence. |'
  prefs: []
  type: TYPE_TB
- en: '| `iter_except` | `(func,`` exception,` `first=None)` | Yields results of calling
    a function repeatedly until an exception is raised. The exception is silenced.
    This can be used to iterate until `KeyError` or `IndexError`. |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 8.5 Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we’ve looked at a number of functions in the `itertools` module.
    This library module helps us to work with iterators in sophisticated ways.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve looked at the infinite iterators; they repeat without terminating. They
    include the `count()`, `cycle()`, and `repeat()` functions. Since they don’t terminate,
    the consuming function must determine when to stop accepting values.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also looked at a number of finite iterators. Some of them are built-in,
    and some of them are a part of the `itertools` module. They work with a source
    iterable, so they terminate when that iterable is exhausted. These functions include
    `enumerate()`, `accumulate()`, `chain()`, `groupby()`, `zip_longest()`, `zip()`,
    `pairwise()`, `compress()`, `islice()`, `dropwhile()`, `takewhile()`, `filterfalse()`,
    `filter()`, `starmap()`, and `map()`. These functions allow us to replace possibly
    complex generator expressions with simpler-looking functions.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve noted that functions like the `tee()` function are available, and can
    create a helpful simplification. It has the potential cost of using a great deal
    of memory, and needs to be considered carefully. In some cases, materializing
    a list may be more efficient than applying the `tee()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we looked at the recipes from the documentation, which provide
    yet more functions we can study and copy for our own applications. The recipes
    list shows a wealth of common design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](Chapter_09.xhtml#x1-1990009), [Itertools for Combinatorics –
    Permutations and Combinations](Chapter_09.xhtml#x1-1990009), we’ll continue our
    study of the `itertools` module, focusing on permutations and combinations. These
    operations can produce voluminous results. For example, enumerating all possible
    5-card hands from a deck of 52 cards will yield over 3.12 × 10⁸ permutations.
    For small domains, however, it can be helpful to examine all possible orderings
    to understand how well observed samples match the domain of possible values.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6 Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter’s exercises are based on code available from Packt Publishing on
    GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. They serve as hints, allowing the
    reader to explore alternative solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. These are often identical to the unit test cases already provided
    in the GitHub repository. The reader should replace the book’s example function
    name with their own solution to confirm that it works.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6.1 Optimize the find_first() function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Counting with float arguments](#x1-1730002), we defined a `find_first()`
    function to locate the first pair of an iterator that passed a given test criteria.
    In most of the examples, the test was a comparison between values to see if the
    difference between the values was larger than 10^(−12).
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of the `find_first()` function used a simpler recursion. This
    limits the size of the iterable that can be examined: only about 1,000 values
    can be consumed before hitting the stack size limitation.'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a comparison function that will consume enough values to fail
    with a recursion limit exception.
  prefs: []
  type: TYPE_NORMAL
- en: Then, rewrite the `find_first()` function to replace the tail call with iteration
    using the `for` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Using the comparison function found earlier, demonstrate that the revised function
    will readily pass 1,000 elements, looking for the first that matches the revised
    criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6.2 Compare Chapter 4 with the itertools.pairwise() recipe
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    the `legs()` function created overlapping pairs from a source iterable. Compare
    the implementation provided in this book with the `pairwise()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Create a very, very large iterable and compare the performance of the `legs()`
    function and the `pairwise()` function. Which is faster?
  prefs: []
  type: TYPE_NORMAL
- en: 8.6.3 Compare Chapter 4 with itertools.tee() recipe
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the [Using sums and counts for statistics](Chapter_04.xhtml#x1-850001) section
    of [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    a `mean()` function was defined that had a limitation of only working with sequences.
    If `itertools.tee()` is used, a `mean()` function can be written that will apply
    to iterators in general, without being limited to collection objects that can
    produce multiple iterators. Define a `mean_i()` function based on the `itertools.tee()`
    function that works with any iterator. Which variant of mean computations is easier
    to understand?
  prefs: []
  type: TYPE_NORMAL
- en: Create a very, very large iterable and compare the performance of the `mean_i()`
    function and the `mean()` function shown in the text. Which is faster? It takes
    some time to explore, but locating a collection that breaks the `itertools.tee()`
    function while still working with a materialized list object is an interesting
    thing to find.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6.4 Splitting a dataset for training and testing purposes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Given a pool of samples, it’s sometimes necessary to partition the data into
    a subset used for building (or “training”) a model, and a separate subset used
    to test the model’s predictive ability. It’s common practice to use subsets of
    20%, 25%, or even 33% of the source data for testing. Develop a set of functions
    to partition the data into subsets with ratios of 1 : 3, 1 : 4, or 1 : 5 for test
    vs. training data.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.6.5 Rank ordering
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Chapter 7](Chapter_07.xhtml#x1-1530007), [Complex Stateless Objects](Chapter_07.xhtml#x1-1530007),
    we looked at ranking items in a set of data. The approach shown in that chapter
    was to build a dictionary of items with the same key value. This made it possible
    to create a rank that was the mean of the various items. For example, the sequence
    `[0.8,`` 1.2,`` 1.2,`` 2.3,`` 18]` should have rank values of 1, 2.5, 2.5, 4,
    5\. The two matching key values in positions 1 and 2 of the sequence should have
    the midpoint value of 2.5 as their common rank.
  prefs: []
  type: TYPE_NORMAL
- en: This can be computed using `itertools.groupby()`. Each group will have some
    number of members, provided by the `groupby()` function. The sequence of rank
    values for a group of n items with matching keys is r[0],r[0] + 1,r[0] + 2,...,r[0]
    + n. The value of r[0] is the starting rank for the group. The mean of this sequence
    is r[0] + ![n 2](img/file79.jpg). This processing requires creating a temporary
    sequence of values in order to emit each item from the group of values with the
    same key with their matching ranks.
  prefs: []
  type: TYPE_NORMAL
- en: Write this `rank()` function, using the `itertools.groupby()` function. Compare
    the code with the examples in [Chapter 7](Chapter_07.xhtml#x1-1530007), [Complex
    Stateless Objects](Chapter_07.xhtml#x1-1530007). What advantages does the `itertools`
    variant offer?
  prefs: []
  type: TYPE_NORMAL
- en: Join our community Discord space
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and know more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
