- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: The Itertools Module
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Itertools模块
- en: Functional programming emphasizes stateless objects. In Python, this leads us
    to work with generator expressions, generator functions, and iterables, instead
    of large, mutable collection objects. In this chapter, we’ll look at elements
    of the `itertools` library. This library has numerous functions to help us work
    with iterable sequences of objects, as well as collection objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程强调无状态对象。在Python中，这让我们转向使用生成器表达式、生成器函数和可迭代对象，而不是大型可变集合对象。在本章中，我们将探讨`itertools`库的元素。这个库有众多函数帮助我们处理可迭代对象序列以及集合对象。
- en: We introduced iterator functions in [Chapter 3](Chapter_03.xhtml#x1-510003),
    [Functions, Iterators, and Generators](Chapter_03.xhtml#x1-510003). In this chapter,
    we’ll expand on that superficial introduction. We used some related functions
    in [Chapter 5](Chapter_05.xhtml#x1-1000005), [Higher-Order Functions](Chapter_05.xhtml#x1-1000005).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](Chapter_03.xhtml#x1-510003)，[函数、迭代器和生成器](Chapter_03.xhtml#x1-510003)中介绍了迭代器函数。在本章中，我们将在此基础上进行扩展。我们在[第5章](Chapter_05.xhtml#x1-1000005)，[高阶函数](Chapter_05.xhtml#x1-1000005)中使用了相关函数。
- en: 'There are a large number of iterator functions in the `itertools` module. We’ll
    examine the combinatoric functions in the next chapter. In this chapter, we’ll
    look at the following three broad groupings of the remaining iterator functions:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools`模块中有大量的迭代器函数。我们将在下一章中检查组合函数。在本章中，我们将查看以下三个广泛的迭代器函数分组：'
- en: Functions that work with potentially infinite iterators. These can be applied
    to any iterable or an iterator over any collection. For example, the `enumerate()`
    function doesn’t require an upper bound on the number of items in the iterable.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与可能无限迭代器一起工作的函数。这些可以应用于任何可迭代对象或任何集合的迭代器。例如，`enumerate()`函数不需要可迭代对象中项目数量的上限。
- en: Functions that work with finite iterators. Often, these are used to create a
    reduction of the source. For example, grouping the items produced by an iterator
    reduces the source to groups of items with a common key.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与有限迭代器一起工作的函数。通常，这些函数用于创建源数据的简化。例如，将迭代器产生的项目分组可以简化源数据为具有共同键的项目组。
- en: 'The `tee()` iterator function clones an iterator into several copies that can
    each be used independently. This provides a way to overcome the primary limitation
    of Python iterators: they can be used only once. This is memory-intensive, however,
    and redesign is often required.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tee()`迭代器函数可以将一个迭代器克隆成多个副本，每个副本都可以独立使用。这提供了一种克服Python迭代器主要限制的方法：它们只能使用一次。然而，这需要大量内存，并且通常需要重新设计。'
- en: 'We need to emphasize the important limitation of iterables that we’ve touched
    upon in other places: they can only be used once.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要强调我们在其他地方提到的重要限制：它们只能使用一次。
- en: Iterables can be used only once.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代对象只能使用一次。
- en: This can be astonishing because there’s no error exception raised by attempting
    to reuse an iterator that’s been consumed fully. Once exhausted, they appear to
    have no elements and will only raise the `StopIteration` exception every time
    they’re used.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能令人惊讶，因为尝试重复使用已经完全消耗的迭代器不会引发错误异常。一旦耗尽，它们似乎没有元素，并且每次使用时都只会引发`StopIteration`异常。
- en: There are some other features of iterators that don’t involve such profound
    limitations. Note that many Python functions, as well as the `for` statement,
    will use the built-in `iter()` function to create as many iterators as required
    from a collection object.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器还有一些不涉及如此深刻限制的特性。请注意，许多Python函数以及`for`语句都会使用内置的`iter()`函数从一个集合对象创建所需的迭代器数量。
- en: 'Other features of iterators include:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的其他特性包括：
- en: There’s no `len()` function for an iterator.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器没有`len()`函数。
- en: Iterators, a subclass of iterables, can do `next()` operations, unlike a container.
    We’ll often use the built-in `iter()` to create an iterator that has a `next()`
    operation.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器是可迭代子类，可以进行`next()`操作，与容器不同。我们通常会使用内置的`iter()`函数来创建一个具有`next()`操作的迭代器。
- en: The `for` statement makes the distinction between containers and other iterables
    invisible by evaluating the built-in `iter()` function. A container object, for
    example, a list, responds to this function by producing an iterator over the items.
    An iterable object that’s not a collection, for example, a generator function,
    returns itself, since it is designed to follow the `Iterator` protocol.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`语句通过评估内置的`iter()`函数，使得容器和其他可迭代对象之间的区别变得不可见。例如，一个容器对象，如列表，会通过产生一个迭代器来响应这个函数。一个不是集合的可迭代对象，例如生成器函数，会返回自身，因为它被设计成遵循`Iterator`协议。'
- en: These points will provide some necessary background for this chapter. The idea
    of the `itertools` module is to leverage what iterables can do to create succinct,
    expressive applications without the complicated-looking overheads associated with
    the details of managing the iterables.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要点将为本章提供一些必要的背景。`itertools`模块的思路是利用可迭代对象能做什么来创建简洁、表达力强的应用程序，而不需要与可迭代对象管理的细节相关的复杂开销。
- en: 8.1 Working with the infinite iterators
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1 使用无限迭代器
- en: 'The `itertools` module provides a number of functions that we can use to enhance
    or enrich an iterable source of data. We’ll look at the following three functions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools`模块提供了一些函数，我们可以使用这些函数来增强或丰富数据源的可迭代性。我们将查看以下三个函数：'
- en: '`count()`: This is an unlimited version of the `range()` function. An upper
    bound must be imposed by the consumer of this sequence.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count()`: 这是`range()`函数的无限制版本。这个序列的消费者必须指定一个上限。'
- en: '`cycle()`: This will reiterate a cycle of values. The consumer must decide
    when enough values have been produced.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cycle()`: 这个函数将重复一个值的循环。消费者必须决定何时产生足够多的值。'
- en: '`repeat()`: This can repeat a single value an indefinite number of times. The
    consumer must end the repetition.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeat()`: 这个函数可以无限次地重复一个单一值。消费者必须结束重复。'
- en: Our goal is to understand how these various iterator functions can be used in
    generator expressions and with generator functions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是理解如何使用这些不同的迭代器函数在生成器表达式中以及与生成器函数一起使用。
- en: 8.1.1 Counting with count()
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1 使用`count()`进行计数
- en: 'The built-in `range()` function is defined by an upper limit: the lower limit
    and step values are optional. The `count()` function, on the other hand, has a
    start and optional step, but no upper limit.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`range()`函数由一个上限定义：下限和步长值是可选的。另一方面，`count()`函数有一个起始值和可选的步长，但没有上限。
- en: 'This function can be thought of as the primitive basis for a function such
    as the built-in `enumerate()` function. We can define the `enumerate()` function
    in terms of `zip()` and `count()` functions, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以被认为是类似内置的`enumerate()`函数的原生基础。我们可以用`zip()`和`count()`函数定义`enumerate()`函数，如下所示：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `enumerate()` function behaves as if it’s a `zip()` function that uses the
    `count()` function to generate the values associated with some iterable source
    of objects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate()`函数的行为就像是一个使用`count()`函数来生成与某些可迭代对象源相关值的`zip()`函数。'
- en: 'Consequently, the following two expressions are equivalent to each other:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下两个表达式是等价的：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both will emit a sequence of numbers of two-tuples. The first item in each tuple
    is an integer counter. The second item comes from the iterator. In this example,
    the iterator is built from a string of characters.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都会输出一个由二元组组成的序列。每个元组的第一个元素是一个整数计数器。第二个元素来自迭代器。在这个例子中，迭代器是由一个字符序列构建的。
- en: 'Here’s something we can do with the `count()` function that’s difficult to
    do with the `enumerate()` function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们可以用`count()`函数做的一些用`enumerate()`函数难以做到的事情：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The value of `count(b,`` s)` is the sequence of values {b,b + s,b + 2s,b + 3s,...}.
    In this example, it will provide values of 1, 4, 7, 10, and so on as the identifiers
    for each value from the enumerator. The `enumerate()` function doesn’t provide
    a way to change the step.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`count(b, s)`的值是值序列 {b, b + s, b + 2s, b + 3s,...}。在这个例子中，它将提供1, 4, 7, 10等值作为枚举器每个值的标识符。`enumerate()`函数不提供改变步长的方法。'
- en: 'We can, of course, combine generator functions to achieve this result. Here’s
    how changing the step can be done with the `enumerate()` function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以将生成器函数组合起来以实现这个结果。以下是使用`enumerate()`函数改变步长的方法：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This shows how a new value, 1 + 3e, is computed from the source enumeration
    value of e. This behaves like the sequence started at 1 and is incremented by
    3\.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了如何从枚举值的源值e计算出一个新值1 + 3e。这表现得像是从1开始的序列，每次增加3。
- en: 8.1.2 Counting with float arguments
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2 使用浮点数参数进行计数
- en: The `count()` function permits non-integer values. We can use something such
    as the `count(0.5,`` 0.1)` expression to provide floating-point values. This will
    accumulate an error if the increment value doesn’t have an exact representation.
    It’s generally better to use integer `count()` arguments such as `(0.5+x*.1`` for`` x`` in`` count())`
    to ensure that representation errors don’t accumulate.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`count()` 函数允许非整数值。我们可以使用 `count(0.5,`` 0.1)` 这样的表达式来提供浮点值。如果增量值没有精确表示，这将累积误差。通常，使用整数
    `count()` 参数，如 `(0.5+x*.1`` for`` x`` in`` count())`，以确保表示错误不会累积。'
- en: Here’s a way to examine the accumulating error. This exploration of the float
    approximation shows some interesting functional programming techniques.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一种检查累积误差的方法。这种对浮点近似的探索展示了有趣的函数式编程技术。
- en: 'We’ll define a function that will evaluate items from an iterator until some
    condition is met. This is a way to find the first item that meets some criteria
    defined by a function. Here’s how we can define a `find_first()` function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个函数，该函数将评估迭代器中的项，直到满足某个条件。这是一种找到满足由函数定义的某些标准的第一项的方法。以下是如何定义一个 `find_first()`
    函数的示例：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function starts by getting the next value from the iterator object. No
    specific type is provided; the type variable `T` tells mypy that the source iterator
    and the target result will be the same type. If the chosen item passes the test,
    that is, this is the desired value, iteration stops and the return value will
    be of the given type associated with the type variable, `T`. Otherwise, we’ll
    evaluate this function recursively to search for a subsequent value that passes
    the test.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先从迭代器对象中获取下一个值。没有提供特定类型；类型变量 `T` 告诉 mypy 源迭代器和目标结果将是相同类型的。如果选定的项通过了测试，即这是期望的值，迭代将停止，返回值将是与类型变量
    `T` 关联的给定类型。否则，我们将递归地评估这个函数以寻找通过测试的后续值。
- en: Because the tail-call recursion is not replaced with an optimized `for` statement,
    this is limited to iterables with about 1,000 items.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因为尾调用递归没有被替换为优化的 `for` 语句，所以这限制在大约 1,000 个项的迭代器上。
- en: 'If we have some series of values computed by a generator, this will consume
    items from the iterator. Here’s a silly example. Let’s say we have an approximation
    that is a sum of a series of values. One example is this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个由生成器计算的一系列值，这将消耗迭代器中的项。以下是一个愚蠢的例子。假设我们有一个近似值，它是一系列值的和。一个例子是：
- en: '![ ( 1 1 1 ) π = 4 arctan (1) = 4 1− 3-+ 5-− 7-⋅⋅⋅ ](img/file64.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![ ( 1 1 1 ) π = 4 arctan (1) = 4 1− 3-+ 5-− 7-⋅⋅⋅ ](img/file64.jpg)'
- en: 'The terms of this series can be created by a generator function like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列的项可以通过如下生成器函数创建：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will yield values like `Fraction(1,`` 1)`, `Fraction(-1,`` 3)`, `Fraction(1,`` 5)`,
    and `Fraction(-1,`` 7)`. It will yield an infinite number of them. We want values
    up until the first value that meets some criteria. For example, we may want to
    know the first value that will be less than ![1100](img/file65.jpg) (this is pretty
    easy to work out with pencil and paper to check the results):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似 `Fraction(1,`` 1)`，`Fraction(-1,`` 3)`，`Fraction(1,`` 5)`，和 `Fraction(-1,`` 7)`
    这样的值。它将产生无限多个这样的值。我们想要直到第一个满足某些标准的值。例如，我们可能想知道第一个将小于 ![1100](img/file65.jpg) 的值（这用铅笔和纸很容易计算出结果）：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our goal is to compare counting with float values against counting with integer
    values and then applying a scaling factor. We want to define a source that has
    both sequences as pairs. As an introduction to the concept, we’ll look at generating
    pairs from two parallel sources. Then we’ll return to the computation shown above.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将使用浮点值计数与使用整数值计数进行比较，然后应用缩放因子。我们想要定义一个同时包含这两个序列对的源。作为对这个概念的一个介绍，我们将查看从两个并行源生成对。然后我们将回到上面的计算。
- en: 'In the following example, the `source` object is a generator of the pairs of
    pure float and int-to-float values:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`source` 对象是纯浮点值和整型到浮点值对的生成器：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `Pair` tuple will have two float values: one generated by summing float
    values, and the other generated by counting integers and multiplying by a floating-point
    scaling factor.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pair` 元组将包含两个浮点值：一个是通过求和浮点值生成的，另一个是通过计数整数并乘以一个浮点缩放因子生成的。'
- en: The generator, `source`, has provided a type hint on the assignment statement
    to show that it iterates over the pairs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器 `source` 在赋值语句中提供了一个类型提示，以表明它遍历对。
- en: 'When we evaluate the `find_first(not_equal,`` source)` method, we’ll repeatedly
    compare float approximations of decimal values until they differ. One is a sum
    of 0.1 values: 0.1 ×∑ [x∈ℕ]1\. The other is a sum of integer values, weighted
    by 0.1: ∑ [x∈ℕ]0.1\. Viewed as abstract mathematical definitions, there’s no distinction.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估`find_first(not_equal,` `source)`方法时，我们会反复比较十进制值的浮点近似，直到它们不同。一个是0.1值的总和：0.1
    × ∑ [x∈ℕ]1\. 另一个是整数值的总和，乘以0.1：∑ [x∈ℕ]0.1\. 作为抽象的数学定义，它们之间没有区别。
- en: 'We can formalize it as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其形式化为以下内容：
- en: '![ ∑ ∑ 0.1 × 1 ≡ 0.1 x∈ℕ x∈ℕ ](img/file66.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑ ∑ 0.1 × 1 ≡ 0.1 x∈ℕ x∈ℕ ](img/file66.jpg)'
- en: 'With concrete approximations of the abstract numbers, however, the two values
    will differ. The result is as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们对抽象数字进行具体近似时，这两个值将会有所不同。结果如下：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After about 928 iterations, the sum of the error bits has accumulated to 10^(−12).
    Neither value has an exact binary representation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 经过大约928次迭代后，错误位的总和累积到10^(−12)。这两个值都没有确切的二进制表示。
- en: The `find_first()` function example is close to the Python recursion limit.
    We’d need to rewrite the function to use tail-call optimization to locate examples
    with a larger cumulative error value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_first()`函数示例接近Python的递归限制。我们需要重写该函数以使用尾调用优化来定位具有更大累积错误值的示例。'
- en: We’ve left this as change as an exercise for the reader.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此作为练习留给读者。
- en: 'The smallest detectable difference can be computed as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最小可检测的差异可以计算如下：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This uses a simple equality check instead of an error range. After six steps,
    the `count(0,`` 0.1)` method has accumulated a tiny, but measurable, error of
    10^(−16). While small, these error values can accumulate to become more significant
    and visible in a longer computation. When looking at how ![-1 10](img/file69.jpg)
    is represented as a binary value, an infinite binary expansion would be required.
    This is truncated to about 10^(−16) ≈ 2^(−53) from the conceptual value. The magic
    number 53 is the number of bits available in IEEE standard for 64-bit floating-point
    values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了一个简单的相等检查而不是错误范围。经过六步后，`count(0,` `0.1)`方法累积了一个微小但可测量的错误10^(−16)。虽然很小，但这些错误值可能会累积并变得更重要和明显，尤其是在更长的计算中。当查看如何将![−1
    10](img/file69.jpg)表示为二进制值时，需要无限二进制展开。这被截断到大约10^(−16) ≈ 2^(−53)的概念值。神奇的数字53是IEEE标准64位浮点值中可用的位数。
- en: This is why we generally count things with ordinary integers and apply a weighting
    to compute a floating-point value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们通常用普通整数计数，并应用权重来计算浮点值。
- en: 8.1.3 Re-iterating a cycle with cycle()
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3 使用 cycle() 重复周期
- en: The `cycle()` function repeats a sequence of values. This can be used when partitioning
    data into subsets by cycling among the dataset identifiers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`cycle()`函数重复一系列值。这可以在通过在数据集标识符之间循环来划分数据子集时使用。'
- en: We can imagine using it to solve silly fizz-buzz problems. Visit [http://rosettacode.org/wiki/FizzBuzz](http://rosettacode.org/wiki/FizzBuzz)
    for a comprehensive set of solutions to a fairly trivial programming problem.
    Also see [https://projecteuler.net/problem=1](https://projecteuler.net/problem=1)
    for an interesting variation on this theme.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象用它来解决愚蠢的fizz-buzz问题。访问[http://rosettacode.org/wiki/FizzBuzz](http://rosettacode.org/wiki/FizzBuzz)获取一个相当简单编程问题的综合解决方案集。还可以查看[https://projecteuler.net/problem=1](https://projecteuler.net/problem=1)了解这个主题的一个有趣变化。
- en: 'We can use the `cycle()` function to emit sequences of `True` and `False` values
    as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`cycle()`函数来发出`True`和`False`值的序列，如下所示：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These two generator expressions can produce infinite sequences with a pattern
    of `[``True``,` `False``,` `False``,` `True``,` `False``,` `False``,` `...]` or
    `[``True``,` `False``,` `False``,` `False``,` `False``,` `True``,` `False``,`
    `False``,` `False``,` `False``,` `...]`. These are iterators and can only be consumed
    once. They will tend to maintain their internal state. If we don’t consume precisely
    15 values, the least common multiple of their cycles, the next time we consume
    values, they will be in an unexpected, in-between state.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个生成器表达式可以产生具有模式`[True, False, False, True, False, False, ...]`或`[True, False,
    False, False, False, True, False, False, False, False, False, ...]`的无限序列。这些是迭代器，只能消费一次。它们倾向于保持其内部状态。如果我们不精确消费15个值，即它们周期的最小公倍数，下一次我们消费值时，它们将处于一个意外的中间状态。
- en: 'If we zip together a finite collection of numbers and these two derived values,
    we’ll get a set of three-tuples with a number, the multiple of three true-false
    condition, and the multiple of five true-false condition. It’s important to introduce
    a finite iterable to create a proper upper bound on the volume of data being generated.
    Here’s a sequence of values and their multiplier conditions:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将有限集合的数字和这两个导出值一起压缩，我们将得到一个包含数字、三个真-假条件乘数和一个五个真-假条件乘数的三个元组集合。引入一个有限的迭代器来创建数据生成量的适当上限是很重要的。以下是一系列值及其乘数条件：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a generator; we can use `list(multipliers)` to see the resulting object.
    It looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个生成器；我们可以使用 `list(multipliers)` 来查看结果对象。它看起来像这样：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now decompose the triples and use a filter to pass numbers that are
    multiples and reject all others:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以分解三元组，并使用过滤器来传递是倍数的数字，拒绝所有其他数字：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `for` clause decomposes each triple into two parts: the value, `i`, and
    the flags, `multipliers`. If any of the multipliers are true, the value is passed;
    otherwise, it’s rejected.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 子句将每个三元组分解为两部分：值 `i` 和标志 `multipliers`。如果任何一个乘数是真实的，则值会被传递；否则，它会被拒绝。'
- en: The `cycle()` function has another, more valuable, use for exploratory data
    analysis.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`cycle()` 函数在探索性数据分析中还有另一个更有价值的用途。'
- en: Using cycle() for data sampling
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 cycle() 进行数据抽样
- en: We often need to work with samples of large sets of data. The initial phases
    of cleansing and model creation are best developed with small sets of data and
    tested with larger and larger sets of data. We can use the `cycle()` function
    to fairly select rows from within a larger set. This is distinct from making random
    selections and trusting the fairness of the random number generator. Because this
    approach is repeatable and doesn’t rely on a random number generator, it can be
    applied to very large datasets processed by multiple computers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要处理大量数据集的样本。清洗和模型创建的初始阶段最好用小数据集开发，并用越来越大的一组数据集进行测试。我们可以使用 `cycle()` 函数从更大的数据集中公平地选择行。这与随机选择并信任随机数生成器的公平性是不同的。因为这种方法是可重复的，并且不依赖于随机数生成器，所以它可以应用于由多台计算机处理的大型数据集。
- en: 'Given a population size, N[p], and the desired sample size, N[s], this is the
    required size of the cycle, c, that will produce appropriate subsets:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个种群大小，N[p]，和所需的样本大小，N[s]，这是将产生适当子集的周期大小，c：
- en: '![c = Np- Ns ](img/file72.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![c = Np- Ns ](img/file72.jpg)'
- en: 'We’ll assume that the data can be parsed with a common library like the `csv`
    module. This leads to an elegant way to create subsets. Given a value for the
    `cycle_size` and two open files, `source_file` and `target_file`, we can create
    subsets using the following function definition:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设数据可以用像 `csv` 模块这样的通用库解析。这导致了一种创建子集的优雅方法。给定 `cycle_size` 的值和两个打开的文件，`source_file`
    和 `target_file`，我们可以使用以下函数定义来创建子集：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `subset_iter()` function uses a `cycle()` function based on the selection
    factor, `cycle_size`. For example, we might have a population of ten million records;
    a 1,000-record subset would be built with `cycle_size` set to c = ![107 103](img/file73.jpg)
    = 10,000\. We’d keep one record in ten thousand.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`subset_iter()` 函数使用基于选择因子 `cycle_size` 的 `cycle()` 函数。例如，我们可能有一个一千万条记录的种群；一个
    1000 条记录的子集将通过将 `cycle_size` 设置为 c = ![107 103](img/file73.jpg) = 10,000 来构建。我们会保留每万条记录中的一条。'
- en: 'The `subset_iter()` function can be used by a function that reads from a source
    file and writes a subset to a destination file. This processing is part of the
    following function definition:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`subset_iter()` 函数可以被一个从源文件读取并写入目标文件的子集的函数使用。这种处理是以下函数定义的一部分：'
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can use this generator function to filter the data using the `cycle()` function
    and the source data that’s available from the `csv` reader. Since the chooser
    expression and the expression used to write the rows are both non-strict, there’s
    little memory overhead from this kind of processing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个生成器函数通过 `cycle()` 函数和从 `csv` 读取器可用的源数据来过滤数据。由于选择表达式和用于写入行的表达式都不是严格的，这种处理几乎没有内存开销。
- en: We can also rewrite this method to use `compress()`, `filter()`, and `islice()`
    functions, as we’ll see later in this chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将这种方法重写为使用 `compress()`、`filter()` 和 `islice()` 函数，正如我们将在本章后面看到的。
- en: This design can also be used to reformat a file from any non-standard CSV-like
    format into a standardized CSV format. As long as we define a parser function
    that returns consistently defined tuples of strings and write consumer functions
    that write tuples to the target files, we can do a great deal of cleansing and
    filtering with relatively short, clear scripts.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计也可以用来将任何非标准的CSV-like格式重新格式化为标准化的CSV格式。只要我们定义一个解析函数，该函数返回一致定义的字符串元组，并编写将元组写入目标文件的消费者函数，我们就可以用相对简短、清晰的脚本进行大量的清洗和过滤。
- en: 8.1.4 Repeating a single value with repeat()
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.4 使用 repeat() 重复单一值
- en: 'The `repeat()` function seems like an odd feature: it returns a single value
    over and over again. It can serve as an alternative for the `cycle()` function
    when a single value is needed.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat()` 函数看起来像是一个奇特的功能：它反复返回一个单一值。当需要单一值时，它可以作为 `cycle()` 函数的替代。'
- en: The difference between selecting all of the data and selecting a subset of the
    data can be expressed with this. The expression `(x==0`` for`` x`` in`` cycle(range(size)))`
    emits a `[True,`` False,`` False,`` ...]` pattern, suitable for picking a subset.
    The function `(x==0`` for`` x`` in`` repeat(0))` emits a `[True,`` True,`` True,`` ...]`
    pattern, suitable for selecting all of the data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个表达式可以表达选择所有数据与选择数据子集之间的差异。表达式 `(x==0 for x in cycle(range(size)))` 会发出 `[True,
    False, False, ...]` 的模式，适合用于选择子集。函数 `(x==0 for x in repeat(0))` 会发出 `[True, True,
    True, ...]` 的模式，适合选择所有数据。
- en: 'We can think of the following kinds of commands:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以思考以下类型的命令：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This allows us to make a single parameter change, which will either pick all
    data or pick a subset of data. We can also use `cycle([True])` instead of `repeat(True)`;
    the results are identical.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们通过单次参数更改来选择所有数据或选择数据子集。我们还可以使用 `cycle([True])` 而不是 `repeat(True)`；结果相同。
- en: 'This pattern can be extended to randomize the subset chosen. The following
    technique adds an additional kind of choice:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可以扩展到随机化选择的子集。以下技术增加了一种额外的选择方式：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `randomized()` function generates a potentially infinite sequence of random
    numbers over a given range. This fits the pattern of `cycle()` and `repeat()`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`randomized()` 函数在给定范围内生成一个可能无限长的随机数序列。这符合 `cycle()` 和 `repeat()` 的模式。'
- en: 'This allows code such as the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许代码如下：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This provides us the ability to use a variety of techniques for selecting subsets.
    A small change among available functions `all()`, `subset()`, and `randomized()`
    lets us change our sampling approach in a way that seems succinct and expressive.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了使用各种技术选择子集的能力。在 `all()`、`subset()` 和 `randomized()` 等可用函数之间进行的小幅改动，让我们能够以简洁和表达清晰的方式改变我们的采样方法。
- en: 8.2 Using the finite iterators
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2 使用有限迭代器
- en: 'The `itertools` module provides a number of functions that we can use to produce
    finite sequences of values. We’ll look at 10 functions in this module, plus some
    related built-in functions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools` 模块提供了一些函数，我们可以使用这些函数来生成有限值的序列。我们将在这个模块中查看10个函数，以及一些相关的内置函数：'
- en: '`enumerate()`: This function is actually part of the `__builtins__` package,
    but it works with an iterator and is very similar to functions in the `itertools`
    module.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enumerate()`: 这个函数实际上是 `__builtins__` 包的一部分，但它与迭代器一起工作，并且与 `itertools` 模块中的函数非常相似。'
- en: '`accumulate()`: This function returns a sequence of reductions of the input
    iterable. It’s a higher-order function and can do a variety of clever calculations.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accumulate()`: 这个函数返回输入可迭代对象的序列化简。它是一个高阶函数，可以进行各种巧妙的计算。'
- en: '`chain()`: This function combines multiple iterables serially.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chain()`: 这个函数将多个可迭代对象按顺序组合。'
- en: '`groupby()`: This function uses a function to decompose a single iterable into
    a sequence of iterables over subsets of the input data.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupby()`: 这个函数使用一个函数将单个可迭代对象分解成一系列的可迭代对象，这些对象覆盖输入数据的子集。'
- en: '`zip_longest()`: This function combines elements from multiple iterables. The
    built-in `zip()` function truncates the sequence at the length of the shortest
    iterable. The `zip_longest()` function pads the shorter iterables with the given
    fill value.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip_longest()`: 这个函数将多个可迭代对象中的元素组合起来。内置的 `zip()` 函数会在最短的可迭代对象长度处截断序列。`zip_longest()`
    函数会用给定的填充值填充较短的序列。'
- en: '`compress()`: This function filters one iterable based on a second, parallel
    iterable of Boolean values.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compress()`: 这个函数根据第二个布尔值并行可迭代的值过滤一个可迭代对象。'
- en: '`islice()`: This function is the equivalent of a slice of a sequence when applied
    to an iterable.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`islice()`: 当应用于可迭代对象时，这个函数等同于序列的切片。'
- en: '`dropwhile()` and `takewhile()`: Both of these functions use a Boolean function
    to filter items from an iterable. Unlike `filter()` or `filterfalse()`, these
    functions rely on a single `True` or `False` value to change their filter behavior
    for all subsequent values.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filterfalse()`: This function applies a filter function to an iterable. This
    complements the built-in `filter()` function.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`starmap()`: This function maps a function to an iterable sequence of tuples
    using each iterable as an `*args` argument to the given function. The `map()`
    function does a similar thing using multiple parallel iterables.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll start with functions that could be seen as useful for grouping or arranging
    items of an `Iterator`. After that, we’ll look at functions that are more appropriate
    for filtering and mapping the items.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1 Assigning numbers with enumerate()
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the [Using enumerate() to include a sequence number](Chapter_04.xhtml#x1-920007)
    section of [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    we used the `enumerate()` function to make a naive assignment of rank numbers
    to sorted data. We can do things such as pairing up a value with its position
    in the original sequence, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will sort the items in `raw_values` in order, create two-tuples with an
    ascending sequence of numbers, and materialize an object we can use for further
    calculations.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](Chapter_07.xhtml#x1-1530007), [Complex Stateless Objects](Chapter_07.xhtml#x1-1530007),
    we implemented an alternative form of the `enumerate()` function, the `rank()`
    function, which handles ties in a more statistically useful way.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating rows of data is a common feature that is added to a parser to record
    the source data row numbers. In many cases, we’ll create some kind of `row_iter()`
    function to extract the string values from a source file. This may iterate over
    the string values in tags of an XML file or in columns of a CSV file. In some
    cases, we may even be parsing data presented in an HTML file parsed with Beautiful
    Soup.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    we parsed an XML file to create a simple sequence of position tuples. We then
    created legs with a start, end, and distance. We did not, however, assign an explicit
    leg number. If we ever sorted the trip collection, we’d be unable to determine
    the original ordering of the legs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 7](Chapter_07.xhtml#x1-1530007), [Complex Stateless Objects](Chapter_07.xhtml#x1-1530007),
    we expanded on the basic parser to create named tuples for each leg of the trip.
    The output from this enhanced parser looks as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The value of `trip[0]` is quite wide, too wide for the book. To keep the output
    in a form that fits in this book’s pages, we’ve wrapped the string representation
    of the value, and used `pprint` to show the individual lines. The first `Leg`
    object is a short trip between two points on the Chesapeake Bay.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a function that will build a more complex tuple with the input order
    information as part of the tuple. First, we’ll define a slightly more complex
    version of the `Leg` class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一个函数，该函数将构建一个更复杂的元组，其中输入顺序信息作为元组的一部分。首先，我们将定义 `Leg` 类的一个稍微复杂一些的版本：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Leg` definition is similar to the variations shown in [Chapter 7](Chapter_07.xhtml#x1-1530007),
    [Complex Stateless Objects](Chapter_07.xhtml#x1-1530007), specifically the `LegNT`
    definition. We’ll define a function that decomposes pairs and creates `Leg` instances
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Leg` 的定义与 [第 7 章](Chapter_07.xhtml#x1-1530007) 中展示的变体类似，[复杂无状态对象](Chapter_07.xhtml#x1-1530007)，特别是
    `LegNT` 的定义。我们将定义一个函数，该函数分解成对并创建 `Leg` 实例，如下所示：'
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can use this function to enumerate each pair of start and end points. We’ll
    decompose the pair and then re-assemble the `order`, `start`, and `end` parameters
    and the `haversine(start,end)` parameter’s value as a single `Leg` instance. This
    generator function will work with an iterable sequence of pairs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此函数来枚举每个起点和终点对。我们将分解这对，然后重新组装 `order`、`start` 和 `end` 参数以及 `haversine(start,end)`
    参数的值作为一个单一的 `Leg` 实例。这个生成器函数将与成对的迭代序列一起工作。
- en: 'In the context of the preceding explanation, it is used as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的解释背景下，它被如下使用：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We’ve parsed the original file into the path points, created start-end pairs,
    and then created a trip that was built of individual `Leg` objects. The `enumerate()`
    function ensures that each item in the iterable sequence is given a unique number
    that increments from the default starting value of 0\. A second argument value
    to the `enumerate()` function can be given to provide a different starting value.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将原始文件解析为路径点，创建了起点-终点对，然后创建了一个由单个 `Leg` 对象组成的行程。`enumerate()` 函数确保可迭代序列中的每个项目都被赋予一个唯一的数字，该数字从默认的起始值
    0 开始递增。`enumerate()` 函数的第二个参数值可以提供不同的起始值。
- en: 8.2.2 Running totals with accumulate()
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2 使用 accumulate() 计算累计总和
- en: The `accumulate()` function folds a given function into an iterable, accumulating
    a series of reductions. This will iterate over the running totals from another
    iterator; the default function is `operator.add()`. We can provide alternative
    functions to change the essential behavior from sum to product. The Python library
    documentation shows a particularly clever use of the `max()` function to create
    a sequence of maximum values so far.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`accumulate()` 函数将给定的函数折叠到可迭代对象中，累积一系列的减少。这将遍历另一个迭代器的累计总和；默认函数是 `operator.add()`。我们可以提供替代函数来改变从总和到乘积的基本行为。Python
    库文档显示了一个特别巧妙的使用 `max()` 函数来创建迄今为止的最大值序列。'
- en: One application of running totals is quartiling data. The quartile is one of
    many measures of position. The general approach is to multiply a sample’s value
    by a scaling factor to convert it to the quartile number. If values range from
    0 ≤ v[i] < N, we can scale by ⌈![N 4-](img/file74.jpg)⌉ to convert any value,
    v[i], to a value in the range 0 to 3, which map to the various quartiles. The
    `math.ceil()` function is used to round the scaling fraction up to the next higher
    integer. This will ensure that no scaled value will produce a scaled result of
    4, an impossible fifth quartile.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 累计总和的一个应用是四分位数数据。四分位数是许多位置度量之一。一般方法是乘以样本值乘以一个缩放因子，将其转换为四分位数。如果值范围从 0 ≤ v[i]
    < N，我们可以通过 ⌈![N 4-](img/file74.jpg)⌉ 缩放，将任何值 v[i] 转换为 0 到 3 范围内的值，这些值映射到不同的四分位数。`math.ceil()`
    函数用于将缩放分数向上舍入到下一个更高的整数。这将确保没有缩放值会产生缩放结果为 4，这是不可能的第五个四分位数。
- en: If the minimum value of v[i] is not zero, we’ll need to subtract this from each
    value before multiplying by the scaling factor.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 v[i] 的最小值不为零，我们需要在乘以缩放因子之前从每个值中减去这个值。
- en: In the [Assigning numbers with enumerate()](#x1-1780001) section, we introduced
    a sequence of latitude-longitude coordinates that describe a sequence of legs
    on a voyage. We can use the distances as a basis for quartiling the waypoints.
    This allows us to determine the midpoint in the trip.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [使用 enumerate() 分配数字](#x1-1780001) 部分，我们介绍了一系列经纬度坐标，描述了航程上的连续腿。我们可以使用距离作为航点的四分位数的基础。这允许我们确定旅途中的中点。
- en: 'See the previous section for the value of the `trip` variable. The value is
    a sequence of `Leg` instances. Each `Leg` object has a start point, an end point,
    and a distance. The calculation of quartiles looks like the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `trip` 变量的值，请参阅上一节。该值是一个 `Leg` 实例的序列。每个 `Leg` 对象都有一个起点、一个终点和一个距离。四分位数的计算如下代码所示：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We extracted the distance values and computed the accumulated distances for
    each leg. The last of the accumulated distances is the total. The value of the
    `quartiles` variable is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提取了距离值并计算了每条腿的累积距离。累积距离的最后一个值是总和。`quartiles`变量的值如下：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can use the `zip()` function to merge this sequence of quartile numbers with
    the original data points. We can also use functions such as `groupby()` to create
    distinct collections of the legs in each quartile.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`zip()`函数将这个四分位数序列与原始数据点合并。我们还可以使用`groupby()`等函数来创建每个四分位数的腿的独立集合。
- en: 8.2.3 Combining iterators with chain()
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.3 使用`chain()`函数组合迭代器
- en: A collection of iterators can be unified into a single sequence of values via
    the `chain()` function. This can be helpful to combine data that was decomposed
    via the `groupby()` function. We can use this to process a number of collections
    as if they were a single collection.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`chain()`函数将一系列迭代器统一成一个单一的值序列。这有助于将通过`groupby()`函数分解的数据合并。我们可以使用它来处理多个集合，就像它们是一个单一的集合一样。
- en: Python’s `contextlib` offers a clever class, `ExitStack()`, which can be used
    to perform a number of operations at the end of the context in a `with` statement.
    This permits an application to create any number of sub-contexts, all of which
    will have a proper `__enter__()` and `__exit__()` evaluated. This is particularly
    useful when we have an indefinite number of files to open.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`contextlib`提供了一个巧妙的类`ExitStack()`，可以在`with`语句的末尾执行多个操作。这允许应用程序创建任意数量的子上下文，所有这些上下文都将正确评估`__enter__()`和`__exit__()`。这在我们需要打开不定数量的文件时特别有用。
- en: In this example, we can combine the `itertools.chain()` function with a `contextlib.ExitStack`
    object to process—and properly close—a collection of files. Further, the data
    from all of these files will be processed as a single iterable sequence of values.
    Instead of wrapping each individual file operation in a `with` statement, we can
    wrap all of the operations in a single `with` context.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以将`itertools.chain()`函数与`contextlib.ExitStack`对象结合使用，以处理并正确关闭一组文件。此外，所有这些文件的数据将作为一个单独的可迭代值序列进行处理。我们不需要在每个单独的文件操作中包裹`with`语句，而是可以将所有操作包裹在一个单一的`with`上下文中。
- en: 'We can create a single context for multiple files like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样为多个文件创建一个单一的上下文：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We’ve created an `ExitStack` object that can contain a number of individual
    contexts open. When the `with` statement finishes, all items in the `ExitStack`
    object will be closed properly. In the above function, a sequence of open file
    objects is assigned to the `files` variable. The `stack.enter_context()` method
    enters these objects into the `ExitStack` object to be properly closed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个可以包含多个打开的独立上下文的`ExitStack`对象。当`with`语句结束时，`ExitStack`对象中的所有项目都将被正确关闭。在上面的函数中，一系列打开的文件对象被分配给`files`变量。`stack.enter_context()`方法将这些对象进入`ExitStack`对象以进行适当的关闭。
- en: Given the sequence of files in the `files` variable, we created a sequence of
    CSV readers in the `readers` variable. In this case, all of our files have a common
    tab-delimited format, which makes it very pleasant to open them with a simple,
    consistent application of a function to the sequence of files.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`files`变量中的文件序列，我们在`readers`变量中创建了一个CSV读取器的序列。在这种情况下，我们的所有文件都有共同的制表符分隔格式，这使得我们可以通过简单一致地对文件序列应用函数来愉快地打开它们。
- en: Finally, we chained all of the readers into a single iterator with `chain(*readers)`.
    This was used to yield the sequence of rows from all of the files.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`chain(*readers)`将所有读取器链接到一个单一的迭代器中。这被用来产生来自所有文件的行序列。
- en: It’s important to note that we can’t return the `chain(*readers)` object. If
    we do, this would exit the `with` statement context, closing all the source files.
    Instead, we must yield individual rows from the generator so that the `with` statement
    context is kept active until all the rows are consumed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们不能返回`chain(*readers)`对象。如果我们这样做，这将退出`with`语句上下文，关闭所有源文件。相反，我们必须从生成器中产生单个行，以便`with`语句上下文保持活跃，直到所有行都被消耗。
- en: 8.2.4 Partitioning an iterator with groupby()
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.4 使用`groupby()`对迭代器进行分区
- en: We can use the `groupby()` function to partition an iterator into smaller iterators.
    This works by evaluating the given `key` function for each item in the given iterable.
    If the key value matches the previous item’s key, the two items are part of the
    same partition. If the key does not match the previous item’s key, the previous
    partition is ended and a new partition is started. Because the matching is done
    on adjacent items in the iterable, the values must be sorted by the key.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`groupby()`函数将迭代器划分为更小的迭代器。这是通过评估给定可迭代对象中每个项目的给定`key`函数来实现的。如果键值与上一个项目的键匹配，则这两个项目是同一划分的一部分。如果键不匹配上一个项目的键，则上一个划分结束，并开始一个新的划分。因为匹配是在可迭代对象的相邻项上进行的，所以值必须按键排序。
- en: The output from the `groupby()` function is a sequence of two-tuples. Each tuple
    has the group’s key value and an iterable over the items in the group, something
    like `[(key,`` iter(group)),`` (key,`` iter(group)),`` ...]`. Each group’s iterator
    can then be processed to create a materialized collection, or perhaps reduce it
    to some summary value.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby()`函数的输出是一个二元组的序列。每个元组包含组的键值和一个包含组中项目的可迭代器，类似于`[(key, iter(group)),
    (key, iter(group)), ...]`。然后可以处理每个组的迭代器以创建一个具体化的集合，或者可能将其缩减为某些汇总值。'
- en: In the [Running totals with accumulate()](#x1-1790002) section, earlier in the
    chapter, we showed how to compute quartile values for an input sequence. We’ll
    extend that to create groups based on the distance quartiles. Each group will
    be an iterator over legs that fit into the range of distances.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的[使用accumulate()计算累计总和](#x1-1790002)部分，我们展示了如何计算输入序列的四分位数。我们将扩展这一点，根据距离四分位数创建组。每个组将是一个迭代器，包含适合距离范围的腿。
- en: 'Given the `trip` variable with the raw data and the `quartile` variable with
    the quartile assignments, we can group the data using the following commands:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 给定包含原始数据的`trip`变量和包含四分位数分配的`quartile`变量，我们可以使用以下命令来分组数据：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will start by zipping the quartile numbers with the raw trip data, creating
    an iterator over two-tuples with quartile number and leg. The `groupby()` function
    will use the given lambda object to group by the quartile number, `q_raw[0]`,
    in each `q_raw` tuple. We used a `for` statement to examine the results of the
    `groupby()` function. This shows how we get a group key value and an iterator
    over members of each individual group.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将首先将四分位数与原始行程数据配对，创建一个包含四分位数和腿的二元组的迭代器。`groupby()`函数将使用给定的lambda对象按四分位数`q_raw[0]`对每个`q_raw`元组进行分组。我们使用`for`语句来检查`groupby()`函数的结果。这显示了如何获取组键值和每个单独组的成员迭代器。
- en: The input to the `groupby()` function must be sorted by the key values. This
    will ensure that all of the items in a group will be adjacent. For very large
    datasets, this may force us to use the operating system’s sort in the rare cases
    of a file being too large to fit into memory.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby()`函数的输入必须按键值排序。这将确保组内的所有项目都将相邻。对于非常大的数据集，这可能会迫使我们使用操作系统的排序，在文件太大而无法装入内存的罕见情况下。'
- en: 'Note that we can also create groups using a `defaultdict(list)` object. This
    avoids a sort step, but can build a large, in-memory dictionary of lists. The
    function can be defined as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还可以使用`defaultdict(list)`对象来创建组。这避免了排序步骤，但可以构建一个大型、内存中的列表字典。函数可以定义为以下内容：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We created a `defaultdict` object that will use `list()` as the default value
    associated with each new key. The type hints clarify the relationship between
    the `key` function, which emits objects of some arbitrary type associated with
    the type variable `KT`, and the dictionary, which uses the same type, `KT`, for
    the keys.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`defaultdict`对象，它将使用`list()`作为与每个新键关联的默认值。类型提示明确了`key`函数（它发出与类型变量`KT`相关的一些任意类型的对象）与字典之间的关系，该字典使用相同的类型`KT`作为键。
- en: Each item will have the given `key()` function applied to create a key value.
    The item is appended to the list in the `defaultdict` object with the given key.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都将应用给定的`key()`函数以创建键值。项目将附加到具有给定键的`defaultdict`对象中的列表。
- en: Once all of the items are partitioned, we can then return each partition as
    an iterator over the items that share a common key. This will retain all of the
    original values in memory, and introduce a dictionary and a list for each unique
    key value. For very large datasets, this may require more memory than is available
    on the processor.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有项目都被分区，我们就可以返回每个分区作为共享公共键的项目的迭代器。这将保留所有原始值在内存中，并为每个唯一的键值引入一个字典和一个列表。对于非常大的数据集，这可能需要比处理器上可用的更多内存。
- en: 'The type hints clarify that the source is some arbitrary type, associated with
    the variable `DT`. The result will be an iterator that includes iterators of the
    type `DT`. This makes a strong statement that no transformation is happening:
    the range type matches the input domain type.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示明确指出源是某种任意类型，与变量 `DT` 关联。结果将是一个包含类型为 `DT` 的迭代器的迭代器。这强烈表明没有发生转换：范围类型与输入域类型匹配。
- en: 8.2.5 Merging iterables with zip_longest() and zip()
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.5 使用 zip_longest() 和 zip() 合并可迭代对象
- en: 'We saw the `zip()` function in [Chapter 4](Chapter_04.xhtml#x1-740004), [Working
    with Collections](Chapter_04.xhtml#x1-740004). The `zip_longest()` function differs
    from the `zip()` function in an important way: whereas the `zip()` function stops
    at the end of the shortest iterable, the `zip_longest()` function pads short iterables
    with a given value, and stops at the end of the longest iterable.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 4 章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004) 中看到了
    `zip()` 函数。`zip_longest()` 函数与 `zip()` 函数在重要方面有所不同：而 `zip()` 函数在最短可迭代对象结束时停止，`zip_longest()`
    函数使用给定值填充短可迭代对象，并在最长可迭代对象结束时停止。
- en: The `fillvalue=` keyword parameter allows filling with a value other than the
    default value, `None`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillvalue=` 关键字参数允许使用除默认值 `None` 之外的其他值进行填充。'
- en: For most exploratory data analysis applications, padding with a default value
    is statistically difficult to justify. The Python Standard Library document includes
    the `grouper` recipe that can be done with the `zip_longest()` function. It’s
    difficult to expand on this without drifting far from our focus on data analysis.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数探索性数据分析应用，使用默认值进行填充在统计学上很难证明其合理性。Python 标准库文档包括使用 `zip_longest()` 函数可以完成的
    `grouper` 菜谱。在不远离我们数据分析重点的情况下很难进一步扩展这一点。
- en: 8.2.6 Creating pairs with pairwise())
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.6 使用 pairwise() 创建成对元素
- en: The `pairwise()` function consumes a source iterator, emitting the items in
    pairs. See the `legs()` function in [Chapter 4](Chapter_04.xhtml#x1-740004), [Working
    with Collections](Chapter_04.xhtml#x1-740004), for an example of creating pairs
    from a source iterable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`pairwise()` 函数消耗一个源迭代器，以对的形式发出项目。请参阅 [第 4 章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004)
    中的 `legs()` 函数，以了解从源可迭代对象创建对的一个示例。'
- en: 'Here’s a small example of transforming a sequence of characters into adjacent
    pairs of characters:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个将字符序列转换为相邻字符对的简单示例：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This kind of analysis locates letter pairs, called ”bigrams” or ”digraphs.”
    This can be helpful when trying to understand a simple letter substitution cipher.
    The frequency of bigrams in encoded text can suggest possible ways to break the
    cipher.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分析定位字母对，称为“二元组”或“二分图”。在尝试理解简单的字母替换密码时，这可能很有帮助。编码文本中二元组的频率可以暗示可能的解密方法。
- en: In Python 3.10, this function was moved from being a recipe to being a proper
    `itertools` function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.10 中，此函数从菜谱变为正确的 `itertools` 函数。
- en: 8.2.7 Filtering with compress()
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.7 使用 compress() 过滤
- en: The built-in `filter()` function uses a predicate to determine whether an item
    is passed or rejected. Instead of a function that calculates a value, we can use
    a second, parallel iterable to determine which items to pass and which to reject.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `filter()` 函数使用谓词来确定一个项目是否通过或被拒绝。我们不仅可以使用一个计算值的函数，还可以使用第二个并行可迭代对象来确定哪些项目通过，哪些被拒绝。
- en: 'In the [Re-iterating a cycle with cycle()](#x1-1740003) section of this chapter,
    we looked at data selection using a simple generator expression. Its essence was
    as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的 [使用 cycle() 重新迭代循环](#x1-1740003) 部分，我们探讨了使用简单的生成器表达式进行数据选择。其本质如下：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Each value for the rule iterable must be a Boolean value. To choose all items,
    it can repeat a `True` value. To pick a fixed subset, it can cycle among a `True`
    value followed by copies of a `False` value. To pick 1/4 of the items, we could
    use `cycle([True]`` +`` 3*[False])`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 规则可迭代对象的每个值都必须是布尔值。为了选择所有项目，它可以重复 `True` 值。为了选择一个固定的子集，它可以循环一个 `True` 值后跟几个
    `False` 值的副本。为了选择四分之一的项目，我们可以使用 `cycle([True] + 3*[False])`。
- en: 'The list comprehension can be revised as `compress(some_source,`` selectors)`,
    using a function for the `selectors` argument value. If we make that change, the
    processing is simplified:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式可以修改为`compress(some_source, selectors)`，使用一个函数作为`selectors`参数值。如果我们做出这个改变，处理过程将简化：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These examples rely on the alternative selection rules `all_rows()`, `subset()`,
    and `randomized()`, as shown previously. The `subset()` and `randomized()` functions
    must be defined with a proper parameter with the value for c to pick ![1 c](img/file75.jpg)
    of the rows from the source. The `selectors` expression must build an iterable
    over `True` and `False` values based on one of the selection rule functions. The
    rows to be kept are selected by applying the `source` iterable to the row-selection
    iterable.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例依赖于之前展示的替代选择规则`all_rows()`、`subset()`和`randomized()`。`subset()`和`randomized()`函数必须使用适当的参数定义，参数值为c来从源中选择![1
    c](img/file75.jpg)行。`selectors`表达式必须基于某个选择规则函数构建一个包含`True`和`False`值的可迭代对象。要保留的行是通过将`source`可迭代对象应用于行选择可迭代对象来选择的。
- en: Since all of this is done as a lazy evaluation, rows are not read from the source
    until required. This allows us to process very large sets of data efficiently.
    Also, the relative simplicity of the Python code means that we don’t really need
    a complex configuration file and an associated parser to make choices among the
    selection rules. We have the option to use this bit of Python code as the configuration
    for a larger data-sampling application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些都是在惰性评估中完成的，所以只有在需要时才会从源中读取行。这使我们能够高效地处理非常大的数据集。此外，Python代码的相对简单性意味着我们实际上不需要复杂的配置文件和相关解析器来在选择规则之间做出选择。我们有选择使用这段Python代码作为更大数据采样应用程序配置的选项。
- en: 'We can think of the `filter()` function as having the following definition:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`filter()`函数想象成具有以下定义：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We cloned the iterable using the `tee()` function. We’ll look at this function
    in detail later. The `map()` function will generate results of applying the filter
    predicate function, `function()`, to each value in the iterable, yielding a sequence
    of `True` and `False` values. The sequence of Booleans is used to compress the
    original sequence, passing only items associated with `True`. This builds the
    features of the `filter()` function from the `compress()` function.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`tee()`函数克隆了可迭代对象。我们稍后会详细探讨这个函数。`map()`函数将生成应用过滤器谓词函数`function()`到可迭代对象中的每个值的结果，产生一系列`True`和`False`值。这个布尔值序列用于压缩原始序列，只传递与`True`关联的项目。这从`compress()`函数构建了`filter()`函数的特征。
- en: The function’s hint can be broadened to `Callable[[SrcT],`` Any]`. This is because
    the `compress()` function will make use of the truthiness or falsiness of the
    values returned. It seems helpful to emphasize that the values will be understood
    as Booleans, hence the use of `bool` in the type hint, not `Any`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的提示可以扩展到`Callable[[SrcT], Any]`。这是因为`compress()`函数将利用返回值的真值或假值。强调这些值将被理解为布尔值似乎是有帮助的，因此在使用类型提示时使用了`bool`而不是`Any`。
- en: 8.2.8 Picking subsets with islice()
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.8 使用islice()选择子集
- en: 'In [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    we looked at slice notation to select subsets from a collection. Our example was
    to pair up items sliced from a list object. The following is a simple list:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004)中，我们探讨了切片符号来从集合中选择子集。我们的例子是将从列表对象中切片的项目配对。以下是一个简单的列表：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can create pairs using list slices as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下方式使用列表切片创建对：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `islice()` function gives us similar capabilities without the overhead
    of materializing a list object. This will work with an iterable of any size. The
    `islice()` function accepts an `Iterable` source, and the three parameters that
    define a slice: the start, stop, and step values. This means `islice(source,`` 1,`` None,`` 2)`
    is similar to `source[1::2]`. Instead of the slice-like shorthand using `:`, optional
    parameter values are used; the rules match the built-in `range()` function. The
    important difference is that `source[1::2]` only works for a `Sequence` object
    like a list or tuple. The `islice(source,`` 1,`` None,`` 2)` function works for
    any iterable, including an iterator object, or a generator expression.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`islice()`函数提供了类似的功能，但没有创建列表对象的开销。这将与任何大小的可迭代对象一起工作。`islice()`函数接受一个`Iterable`源，以及定义切片的三个参数：起始、停止和步长值。这意味着`islice(source,
    1, None, 2)`类似于`source[1::2]`。与使用`:`的类似切片简写不同，可选参数值被使用；规则与内置的`range()`函数匹配。重要的区别是`source[1::2]`仅适用于列表或元组等`Sequence`对象。`islice(source,
    1, None, 2)`函数适用于任何可迭代对象，包括迭代器对象或生成器表达式。'
- en: 'The following example will create pairs of values of an iterable using the
    `islice()` function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将使用`islice()`函数创建可迭代对象的值对：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We created two independent iterators over a collection of data points in the
    `flat` variable. These could be two separate iterators over an open file or a
    database result set. The two iterators need to be independent to ensure a change
    in one `islice()` source doesn’t interfere with the other `islice()` source.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`flat`变量上创建了两个独立的数据点集合的迭代器。这些可以是打开的文件或数据库结果集上的两个独立的迭代器。这两个迭代器需要是独立的，以确保一个`islice()`源的变化不会干扰另一个`islice()`源。
- en: 'This will produce a sequence of two-tuples from the original sequence:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成从原始序列中得到的二元组序列：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Since `islice()` works with an iterable, this kind of design can work with extremely
    large sets of data. We can use this to pick a subset out of a larger set of data.
    In addition to using the `filter()` or `compress()` functions, we can also use
    the `islice(source,`` 0,`` None,`` c)` method to pick a ![1c](img/file78.jpg)-sized
    subset from a larger set of data.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`islice()`与可迭代对象一起工作，这种设计可以与极其大量的数据集一起工作。我们可以使用它从更大的数据集中选择子集。除了使用`filter()`或`compress()`函数外，我们还可以使用`islice(source,
    0, None, c)`方法从更大的数据集中选择![1c](img/file78.jpg)-大小的子集。
- en: 8.2.9 Stateful filtering with dropwhile() and takewhile()
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.9 使用dropwhile()和takewhile()进行状态性过滤
- en: The `dropwhile()` and `takewhile()` functions are stateful filter functions.
    They start in one mode; the given predicate function is a kind of flip-flop that
    switches the mode. The `dropwhile()` function starts in reject mode; when the
    function becomes `False`, it switches to pass mode. The `takewhile()` function
    starts in pass mode; when the given function becomes `False`, it switches to reject
    mode. Since these are filters, they will consume the entire iterable argument
    value.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`dropwhile()`和`takewhile()`函数是状态性过滤器函数。它们从一个模式开始；给定的谓词函数是一种翻转开关，用于切换模式。`dropwhile()`函数从拒绝模式开始；当函数变为`False`时，它切换到传递模式。`takewhile()`函数从传递模式开始；当给定的函数变为`False`时，它切换到拒绝模式。由于这些是过滤器，它们将消耗整个可迭代参数值。'
- en: 'We can use these to skip header or footer lines in an input file. We use the
    `dropwhile()` function to reject header rows and pass the remaining data. We use
    the `takewhile()` function to pass data and reject trailer rows. We’ll return
    to the simple GPL file format shown in [Chapter 3](Chapter_03.xhtml#x1-510003),
    [Functions, Iterators, and Generators](Chapter_03.xhtml#x1-510003). The file has
    a header that looks as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些方法跳过输入文件中的标题或页脚行。我们使用`dropwhile()`函数来拒绝标题行并传递剩余的数据。我们使用`takewhile()`函数来传递数据并拒绝页脚行。我们将回到第3章中展示的简单GPL文件格式[Chapter 3](Chapter_03.xhtml#x1-510003)，[函数、迭代器和生成器](Chapter_03.xhtml#x1-510003)。文件有一个如下所示的标题：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is followed by rows that look like the following example data:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是类似以下示例数据的行：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Note that there’s an invisible tab character, `\t`, between the RGB color triple
    and the color name. To make it more visible, we can typeset the example like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，RGB颜色三元组和颜色名称之间有一个不可见的制表符字符，`\t`。为了使其更明显，我们可以将示例排版如下：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This little typesetting technique seems a little misleading, since it doesn’t
    look like that in most programming editors.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这种微妙的排版技术似乎有点误导，因为在大多数编程编辑器中看起来并不像这样。
- en: 'We can locate the final line of the headers—the # line—using a parser based
    on the `dropwhile()` function, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以使用基于 `dropwhile()` 函数的解析器来定位标题的最后一行（即 # 行），如下所示：'
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We created a CSV reader to parse the lines based on tab characters. This will
    neatly separate the `color` three-tuple from the name. The three-tuple will need
    further parsing. This will produce an iterator that starts with the `#` line and
    continues with the rest of the file.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 CSV 读取器来根据制表符字符解析行。这将整洁地将 `color` 三元组与名称分开。三元组需要进一步解析。这将生成一个以 `#` 行开始并继续文件其余部分的迭代器。
- en: 'We can use the `islice()` function to discard the first item of an iterable.
    The `islice(rows,`` 1,`` None)` expression is similar to asking for a `rows[1:]`
    slice: the first item is quietly discarded. Once the last of the heading rows
    have been discarded, we can parse the color tuples and return more useful color
    objects.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `islice()` 函数丢弃可迭代对象中的第一个元素。`islice(rows, 1, None)` 表达式类似于请求 `rows[1:]`
    切片：第一个元素被悄悄丢弃。一旦丢弃了最后一行标题行，我们就可以解析颜色三元组并返回更有用的颜色对象。
- en: For this particular file, we can also use the number of columns located by the
    CSV `reader()` function. Header rows only have a single column, allowing the use
    of the `dropwhile(lambda`` row:`` len(row)`` ==`` 1,`` rdr)` expression to discard
    header rows. This isn’t a good approach in general, because locating the last
    line of the headers is often easier than trying to define some general pattern
    that distinguishes all header (or trailer) lines from the meaningful file content.
    In this case, the header rows were distinguishable by the number of columns; this
    is a rarity.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '对于这个特定的文件，我们还可以使用 CSV `reader()` 函数找到的列数。标题行只有一个列，允许使用 `dropwhile(lambda row:
    len(row) == 1, rdr)` 表达式来丢弃标题行。这通常不是一个好的方法，因为定位标题的最后一行通常比尝试定义一些可以区分所有标题（或尾注）行与有意义文件内容的通用模式要容易得多。在这种情况下，标题行可以通过列数来区分；这是一个罕见的情况。'
- en: 8.2.10 Two approaches to filtering with filterfalse() and filter()
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.10 使用 filterfalse() 和 filter() 进行过滤的两种方法
- en: 'In [Chapter 5](Chapter_05.xhtml#x1-1000005), [Higher-Order Functions](Chapter_05.xhtml#x1-1000005),
    we looked at the built-in `filter()` function. The `filterfalse()` function from
    the `itertools` module could be defined from the `filter()` function, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](Chapter_05.xhtml#x1-1000005)，[高阶函数](Chapter_05.xhtml#x1-1000005) 中，我们探讨了内置的
    `filter()` 函数。`itertools` 模块中的 `filterfalse()` 函数可以从 `filter()` 函数定义，如下所示：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As with the `filter()` function, the predicate function can be the `None` value.
    The value of the `filter(None,`` iterable)` method is all the `True` values in
    the iterable. The value of the `filterfalse(None,`` iterable)` method is all the
    `False` values from the iterable:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `filter()` 函数一样，谓词函数可以是 `None` 值。`filter(None, iterable)` 方法的值是可迭代对象中的所有 `True`
    值。`filterfalse(None, iterable)` 方法的值是可迭代对象中的所有 `False` 值：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The point of having the `filterfalse()` function is to promote reuse. If we
    have a succinct function that makes a filter decision, we should be able to use
    that function to partition input to pass as well as reject groups without having
    to fiddle around with logical negation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`filterfalse()` 函数的目的是促进重用。如果我们有一个简洁的函数来做出过滤决策，我们应该能够使用该函数来分区输入，无论是传递还是拒绝组，而无需通过逻辑否定进行繁琐的操作。'
- en: 'The idea is to execute the following commands:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是执行以下命令：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This kind of processing into two subsets will include all items from the source.
    The `rule()` function is unchanged, and we can’t introduce a subtle logic bug
    through improper negation of this function.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将处理分为两个子集的方法将包括源中的所有项。`rule()` 函数保持不变，我们无法通过不正确地否定此函数引入微妙的逻辑错误。
- en: 8.2.11 Applying a function to data via starmap() and map()
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.11 通过 starmap() 和 map() 将函数应用于数据
- en: 'The built-in `map()` function is a higher-order function that applies a function
    to items from an iterable. We can think of the simple version of the `map()` function
    as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `map()` 函数是一个高阶函数，它将函数应用于可迭代对象中的项。我们可以将 `map()` 函数的简单版本想象如下：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This works well when the `arg_iter` parameter is an iterable that provides individual
    values. The actual `map()` function is quite a bit more sophisticated than this,
    and can also work with a number of iterables.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `arg_iter` 参数是一个提供单个值的可迭代对象时，这效果很好。实际的 `map()` 函数比这复杂得多，也可以与多个可迭代对象一起工作。
- en: 'The `starmap()` function in the `itertools` module is the `*args` version of
    the `map()` function. We can imagine the definition as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools` 模块中的 `starmap()` 函数是 `map()` 函数的 `*args` 版本。我们可以想象其定义如下：'
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This reflects a small shift in the semantics of the `map()` function to properly
    handle an iterable-of-tuples structure. Each tuple is decomposed and applied to
    the various positional parameters.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这反映了 `map()` 函数在语义上的微小变化，以正确处理元组可迭代结构。每个元组都被分解并应用于各种位置参数。
- en: When we look at the trip data, from the preceding commands, we can redefine
    the construction of a `Leg` object based on the `starmap()` function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看行程数据时，根据前面的命令，我们可以基于 `starmap()` 函数重新定义 `Leg` 对象的构建。
- en: 'We could use the `starmap()` function to assemble the `Leg` objects, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `starmap()` 函数来组装 `Leg` 对象，如下所示：
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here’s how it looks when we apply this `get_trip_starmap()` function to read
    source data and iterate over the created `Leg` objects:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将这个 `get_trip_starmap()` 函数应用于读取源数据和遍历创建的 `Leg` 对象时，它看起来是这样的：
- en: '[PRE47]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `make_leg()` function accepts a pair of `Point` objects, and returns a `Leg`
    object with the start point, end point, and distance between the two points. The
    `legs()` function from [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with
    Collections](Chapter_04.xhtml#x1-740004), creates pairs of `Point` objects that
    reflect the start and end of a leg of the voyage. The pairs created by `legs()`
    are provided as input to `make_leg()` to create proper `Leg` objects.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_leg()` 函数接受一对 `Point` 对象，并返回一个包含起点、终点和两点之间距离的 `Leg` 对象。来自 [第 4 章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004)
    的 `legs()` 函数创建反映航程一段起止的 `Point` 对象对。`legs()` 创建的这些对作为输入提供给 `make_leg()`，以创建适当的
    `Leg` 对象。'
- en: The `map()` function can also accept multiple iterables. When we use `map(f,`` iter1,`` iter2,`
    `...)`, it behaves as if the iterators are zipped together, and the `starmap()`
    function is applied.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 函数也可以接受多个可迭代对象。当我们使用 `map(f, iter1, iter2, ...)` 时，它表现得好像迭代器被压缩在一起，并应用了
    `starmap()` 函数。'
- en: We can think of the `map(function,`` iter1,`` iter2,`` iter3)` function as if
    it were `starmap(function,`` zip(iter1,`` iter2,`` iter3))`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `map(function, iter1, iter2, iter3)` 函数视为 `starmap(function, zip(iter1,
    iter2, iter3))`。
- en: The benefit of the `starmap(function,`` some_list)` method is to replace a potentially
    wordy `(function(*args)`` for`` args`` in`` some_list)` generator expression with
    something that avoids the potentially overlooked `*` operator applied to the function
    argument values.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`starmap(function, some_list)` 方法的优点是将可能冗长的 `(function(*args) for args in some_list)`
    生成器表达式替换为避免对函数参数值应用可能被忽视的 `*` 操作符。'
- en: 8.3 Cloning iterators with tee()
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3 使用 tee() 克隆迭代器
- en: 'The `tee()` function gives us a way to circumvent one of the important Python
    rules for working with iterables. The rule is so important, we’ll repeat it here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`tee()` 函数为我们提供了一种绕过使用可迭代对象时的重要 Python 规则的方法。这个规则非常重要，所以我们在这里重复一遍：'
- en: Iterators can be used only once.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器只能使用一次。
- en: The `tee()` function allows us to clone an iterator. This seems to free us from
    having to materialize a sequence so that we can make multiple passes over the
    data. Because `tee()` can use a lot of memory, it is sometimes better to materialize
    a list and process it multiple times, rather than trying to use the potential
    simplification of the `tee()` function.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`tee()` 函数允许我们克隆一个迭代器。这似乎让我们免于必须实现一个序列，以便我们可以多次遍历数据。因为 `tee()` 可能会使用很多内存，所以有时最好实现一个列表并多次处理它，而不是试图使用
    `tee()` 函数的潜在简化。'
- en: 'For example, a simple average for an immense dataset could be written in the
    following way:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于庞大的数据集，简单的平均值可以这样编写：
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This would compute an average without appearing to materialize the entire dataset
    in memory. Note that the type hint of `float` doesn’t preclude integers. The mypy
    program is aware of the numeric processing rules, and this definition provides
    a flexible way to specify that either `int` or `float` will work.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这样计算平均值时，看起来并没有在内存中完全实现整个数据集。注意，`float` 类型的类型提示并不排除整数。mypy 程序了解数值处理规则，这个定义提供了一种灵活的方式来指定
    `int` 或 `float` 都可以工作。
- en: 8.4 The itertools recipes
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4 itertools 菜谱
- en: Within the itertools chapter of the Python library documentation, there’s a
    subsection called Itertools Recipes, which contains outstanding examples of ways
    to use the various `itertools` functions. Since there’s no reason to reproduce
    these, we’ll reference them here. They should be considered as required reading
    on functional programming in Python.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 库文档的 itertools 章节中，有一个名为 Itertools Recipes 的子章节，其中包含使用各种 `itertools`
    函数的杰出示例。由于没有必要重新生成这些示例，我们在这里引用它们。它们应被视为 Python 函数式编程的必读内容。
- en: For more information, visit [https://docs.python.org/3/library/itertools.html#itertools-recipes](https://docs.python.org/3/library/itertools.html#itertools-recipes).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请访问 [https://docs.python.org/3/library/itertools.html#itertools-recipes](https://docs.python.org/3/library/itertools.html#itertools-recipes)。
- en: It’s important to note that these aren’t importable functions in the `itertools`
    modules. A recipe needs to be read and understood and then, perhaps, copied or
    modified before it’s included in an application.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这些不是 `itertools` 模块中的可导入函数。需要阅读和理解这些配方，然后可能复制或修改它们，才能将其包含在应用程序中。
- en: 'Some of the recipes involve some of the more advanced techniques shown in the
    next chapter; they’re not in the following table. We’ve preserved the ordering
    of items in the Python documentation, which is not alphabetical. The following
    table summarizes some of the recipes that show functional programming design patterns
    built from the `itertools` basics:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一些配方涉及下一章中展示的一些更高级的技术；它们不在以下表中。我们保留了 Python 文档中项目的顺序，这不是按字母顺序排列的。以下表格总结了显示从
    `itertools` 基础构建的函数式编程设计模式的配方：
- en: '|  |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| Function Name | Arguments | Results |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 函数名称 | 参数 | 结果 |'
- en: '|  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |  |  |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: '|  |  |  |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: '| `take` | `(n,`` iterable)` | Yields the first n items of the iterable as
    a list. This wraps a use of `islice()` in a simple name. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `take` | `(n, iterable)` | 生成可迭代对象的前 n 项作为列表。这封装了 `islice()` 的使用，并赋予了一个简单的名称。|'
- en: '| `tabulate` | `(function,` `start=0)` | Yields `function(0)`, `function(1)`,
    and so on. This is based on a `map(function,`` count())`. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `tabulate` | `(function, start=0)` | 生成 `function(0)`，`function(1)` 等等。这是基于
    `map(function, count())`。|'
- en: '| `consume` | `(iterator,`` n)` | Advance the iterator n steps ahead. If n
    is `None`, it consumes all of the values from the iterator. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `consume` | `(iterator, n)` | 将迭代器向前推进 n 步。如果 n 为 `None`，则消耗迭代器中的所有值。|'
- en: '| `nth` | `(iterable,`` n,` `default=None)` | Return only the nth item or a
    default value. This wraps the use of `islice()` in a simple name. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `nth` | `(iterable, n, default=None)` | 仅返回第 n 项或默认值。这封装了 `islice()` 的使用，并赋予了一个简单的名称。|'
- en: '| `quantify` | `(iterable,` `pred=bool)` | Returns the count of how many times
    the predicate is true. This uses `sum()` and `map()` and relies on the way a Boolean
    predicate is effectively 1 when converted to an integer value. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `quantify` | `(iterable, pred=bool)` | 返回谓词为真的次数。这使用 `sum()` 和 `map()`，并依赖于布尔谓词在转换为整数值时实际上为
    1 的方式。|'
- en: '| `padnone` | `(iterable)` | Yields the iterable’s elements and then yields
    `None` indefinitely. This can create functions that behave like `zip_longest()`
    or `map()`. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `padnone` | `(iterable)` | 生成可迭代对象的元素，然后无限期地生成 `None`。这可以创建类似于 `zip_longest()`
    或 `map()` 的函数。|'
- en: '| `ncycles` | `(iterable,`` n)` | Yields the sequence elements n times. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `ncycles` | `(iterable, n)` | 生成序列元素 n 次。|'
- en: '| `dotproduct` | `(vec1,`` vec2)` | A dot product multiplies two vector’s values
    and finds the sum of the result. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `dotproduct` | `(vec1, vec2)` | 点积将两个向量的值相乘，并找到结果的和。|'
- en: '| `flatten` | `(listOfLists)` | This function flattens one level of nesting.
    This chains the various lists together into a single list. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `flatten` | `(listOfLists)` | 此函数展开一层嵌套。将各种列表连接成一个单一的列表。|'
- en: '| `repeatfunc` | `(func,`` times=` `None,`` *args)` | This calls the given
    function, `func`, repeatedly with specified arguments. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `repeatfunc` | `(func, times=None, *args)` | 重复调用给定的函数 `func`，并使用指定的参数。|'
- en: '| `grouper` | `(iterable,`` n,` `fillvalue=None)` | Yields the iterable’s elements
    as a sequence of fixed-length chunks or blocks. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `grouper` | `(iterable, n, fillvalue=None)` | 生成可迭代对象的元素，作为固定长度的块或序列。|'
- en: '| `roundrobin` | `(*iterables)` | Yields values taken from each of the iterables.
    For example, `roundrobin(’ABC’,`` ’D’,`` ’EF’)` is `’A’,`` ’D’,`` ’E’,`` ’B’,`` ’F’,`` ’C’`.
    |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `roundrobin` | `(*iterables)` | 从每个可迭代对象中取出值。例如，`roundrobin(‘ABC’, ‘D’, ‘EF’)`
    的结果是 `‘A’, ‘D’, ‘E’, ‘B’, ‘F’, ‘C’`。|'
- en: '| `partition` | `(pred,`` iterable)` | This uses a predicate to partition entries
    into `False` entries and `True` entries. The return value is a pair of iterators.
    |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `partition` | `(pred,` `iterable)` | 这使用谓词将条目分为`False`条目和`True`条目。返回值是一对迭代器。|'
- en: '| `unique_everseen` | `(iterable,` `key=None)` | Yields the unique elements
    of the source iterable, preserving order. It also remembers all elements ever
    seen. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `unique_everseen` | `(iterable,` `key=None)` | 产生源可迭代对象的唯一元素，保持顺序。它还记住所有曾经看到的元素。|'
- en: '| `unique_justseen` | `(iterable,` `key=None)` | Yields unique elements, preserving
    order. It remembers only the element most recently seen. This is useful for deduplicating
    or grouping a sorted sequence. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `unique_justseen` | `(iterable,` `key=None)` | 产生唯一元素，保持顺序。它只记住最近看到的元素。这在去重或对排序序列进行分组时很有用。|'
- en: '| `iter_except` | `(func,`` exception,` `first=None)` | Yields results of calling
    a function repeatedly until an exception is raised. The exception is silenced.
    This can be used to iterate until `KeyError` or `IndexError`. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `iter_except` | `(func,` `exception,` `first=None)` | 在引发异常时重复调用函数，直到引发异常。异常被抑制。这可以用来迭代直到`KeyError`或`IndexError`。|'
- en: '|  |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |  |  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: '|  |  |  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: '|  |  |  |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: '|  |  |  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: '|  |  |  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: 8.5 Summary
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5 摘要
- en: In this chapter, we’ve looked at a number of functions in the `itertools` module.
    This library module helps us to work with iterators in sophisticated ways.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了`itertools`模块中的许多函数。这个库模块帮助我们以复杂的方式处理迭代器。
- en: We’ve looked at the infinite iterators; they repeat without terminating. They
    include the `count()`, `cycle()`, and `repeat()` functions. Since they don’t terminate,
    the consuming function must determine when to stop accepting values.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了无限迭代器；它们会重复而不会终止。它们包括`count()`、`cycle()`和`repeat()`函数。由于它们不会终止，消费函数必须确定何时停止接受值。
- en: We’ve also looked at a number of finite iterators. Some of them are built-in,
    and some of them are a part of the `itertools` module. They work with a source
    iterable, so they terminate when that iterable is exhausted. These functions include
    `enumerate()`, `accumulate()`, `chain()`, `groupby()`, `zip_longest()`, `zip()`,
    `pairwise()`, `compress()`, `islice()`, `dropwhile()`, `takewhile()`, `filterfalse()`,
    `filter()`, `starmap()`, and `map()`. These functions allow us to replace possibly
    complex generator expressions with simpler-looking functions.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了多个有限迭代器。其中一些是内置的，还有一些是`itertools`模块的一部分。它们与源可迭代对象一起工作，因此当该可迭代对象耗尽时它们会终止。这些函数包括`enumerate()`、`accumulate()`、`chain()`、`groupby()`、`zip_longest()`、`zip()`、`pairwise()`、`compress()`、`islice()`、`dropwhile()`、`takewhile()`、`filterfalse()`、`filter()`、`starmap()`和`map()`。这些函数允许我们用看起来更简单的函数替换可能复杂的生成器表达式。
- en: We’ve noted that functions like the `tee()` function are available, and can
    create a helpful simplification. It has the potential cost of using a great deal
    of memory, and needs to be considered carefully. In some cases, materializing
    a list may be more efficient than applying the `tee()` function.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经注意到像`tee()`这样的函数是可用的，并且可以创建一个有用的简化。它可能需要大量内存，需要仔细考虑。在某些情况下，将列表具体化可能比应用`tee()`函数更有效。
- en: Additionally, we looked at the recipes from the documentation, which provide
    yet more functions we can study and copy for our own applications. The recipes
    list shows a wealth of common design patterns.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还研究了文档中的配方，这些配方提供了更多我们可以研究和复制到我们自己的应用程序中的函数。配方列表显示了丰富的常见设计模式。
- en: In [Chapter 9](Chapter_09.xhtml#x1-1990009), [Itertools for Combinatorics –
    Permutations and Combinations](Chapter_09.xhtml#x1-1990009), we’ll continue our
    study of the `itertools` module, focusing on permutations and combinations. These
    operations can produce voluminous results. For example, enumerating all possible
    5-card hands from a deck of 52 cards will yield over 3.12 × 10⁸ permutations.
    For small domains, however, it can be helpful to examine all possible orderings
    to understand how well observed samples match the domain of possible values.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](Chapter_09.xhtml#x1-1990009)，[组合学中的迭代器 – 排列和组合](Chapter_09.xhtml#x1-1990009)中，我们将继续研究`itertools`模块，重点关注排列和组合。这些操作可以产生大量结果。例如，从一副52张牌中枚举所有可能的5张牌手牌将产生超过3.12
    × 10⁸个排列。然而，对于小域来说，检查所有可能的排列顺序可以帮助我们了解观察到的样本与可能值的域匹配得有多好。
- en: 8.6 Exercises
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6 练习
- en: This chapter’s exercises are based on code available from Packt Publishing on
    GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习基于Packt Publishing在GitHub上提供的代码。请参阅[https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition)。
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. They serve as hints, allowing the
    reader to explore alternative solutions.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，读者会注意到GitHub上提供的代码包含了一些练习的部分解决方案。它们作为提示，允许读者探索其他解决方案。
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. These are often identical to the unit test cases already provided
    in the GitHub repository. The reader should replace the book’s example function
    name with their own solution to confirm that it works.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，练习需要单元测试用例来确认它们确实解决了问题。这些通常与GitHub仓库中已提供的单元测试用例相同。读者应将书中的示例函数名称替换为自己的解决方案，以确认其工作正常。
- en: 8.6.1 Optimize the find_first() function
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.6.1 优化find_first()函数
- en: In [Counting with float arguments](#x1-1730002), we defined a `find_first()`
    function to locate the first pair of an iterator that passed a given test criteria.
    In most of the examples, the test was a comparison between values to see if the
    difference between the values was larger than 10^(−12).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在[使用浮点数参数计数](#x1-1730002)中，我们定义了一个`find_first()`函数，用于定位通过给定测试标准的迭代器的第一个配对。在大多数示例中，测试是值之间的比较，以查看值之间的差异是否大于10^(−12)。
- en: 'The definition of the `find_first()` function used a simpler recursion. This
    limits the size of the iterable that can be examined: only about 1,000 values
    can be consumed before hitting the stack size limitation.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_first()`函数的定义使用了更简单的递归。这限制了可以检查的可迭代对象的大小：在达到栈大小限制之前，只能消耗大约1,000个值。'
- en: First, create a comparison function that will consume enough values to fail
    with a recursion limit exception.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个比较函数，该函数将消耗足够多的值以失败并抛出递归限制异常。
- en: Then, rewrite the `find_first()` function to replace the tail call with iteration
    using the `for` statement.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新编写`find_first()`函数，用`for`语句替换尾递归。
- en: Using the comparison function found earlier, demonstrate that the revised function
    will readily pass 1,000 elements, looking for the first that matches the revised
    criteria.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前找到的比较函数，证明修改后的函数可以轻松通过1,000个元素，寻找第一个符合修改后的标准。
- en: 8.6.2 Compare Chapter 4 with the itertools.pairwise() recipe
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.6.2 将第4章与itertools.pairwise()配方进行比较
- en: In [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    the `legs()` function created overlapping pairs from a source iterable. Compare
    the implementation provided in this book with the `pairwise()` function.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004)中，`legs()`函数从一个源可迭代对象中创建了重叠的配对。比较本书中提供的实现与`pairwise()`函数的实现。
- en: Create a very, very large iterable and compare the performance of the `legs()`
    function and the `pairwise()` function. Which is faster?
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个非常大的可迭代对象，并比较`legs()`函数和`pairwise()`函数的性能。哪个更快？
- en: 8.6.3 Compare Chapter 4 with itertools.tee() recipe
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.6.3 将第4章与itertools.tee()配方进行比较
- en: In the [Using sums and counts for statistics](Chapter_04.xhtml#x1-850001) section
    of [Chapter 4](Chapter_04.xhtml#x1-740004), [Working with Collections](Chapter_04.xhtml#x1-740004),
    a `mean()` function was defined that had a limitation of only working with sequences.
    If `itertools.tee()` is used, a `mean()` function can be written that will apply
    to iterators in general, without being limited to collection objects that can
    produce multiple iterators. Define a `mean_i()` function based on the `itertools.tee()`
    function that works with any iterator. Which variant of mean computations is easier
    to understand?
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004)的[使用总和和计数进行统计](Chapter_04.xhtml#x1-850001)部分，定义了一个`mean()`函数，该函数的限制是只能与序列一起使用。如果使用`itertools.tee()`，可以编写一个`mean()`函数，该函数将适用于所有迭代器，而不仅限于可以产生多个迭代器的集合对象。基于`itertools.tee()`函数定义一个`mean_i()`函数，该函数可以与任何迭代器一起工作。哪种均值计算变体更容易理解？
- en: Create a very, very large iterable and compare the performance of the `mean_i()`
    function and the `mean()` function shown in the text. Which is faster? It takes
    some time to explore, but locating a collection that breaks the `itertools.tee()`
    function while still working with a materialized list object is an interesting
    thing to find.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个非常大的可迭代对象，并比较文本中显示的 `mean_i()` 函数和 `mean()` 函数的性能。哪个更快？探索需要一些时间，但找到一个既能打破
    `itertools.tee()` 函数又能与具体化列表对象一起工作的集合是件有趣的事情。
- en: 8.6.4 Splitting a dataset for training and testing purposes
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.6.4 用于训练和测试目的的数据集拆分
- en: 'Given a pool of samples, it’s sometimes necessary to partition the data into
    a subset used for building (or “training”) a model, and a separate subset used
    to test the model’s predictive ability. It’s common practice to use subsets of
    20%, 25%, or even 33% of the source data for testing. Develop a set of functions
    to partition the data into subsets with ratios of 1 : 3, 1 : 4, or 1 : 5 for test
    vs. training data.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个样本池，有时有必要将数据分割成用于构建（或“训练”）模型的数据子集，以及用于测试模型预测能力的单独子集。使用源数据的 20%、25% 或甚至 33%
    作为测试数据是常见的做法。开发一组函数，将数据分割成测试数据与训练数据比为 1:3、1:4 或 1:5 的子集。
- en: 8.6.5 Rank ordering
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.6.5 排序排名
- en: In [Chapter 7](Chapter_07.xhtml#x1-1530007), [Complex Stateless Objects](Chapter_07.xhtml#x1-1530007),
    we looked at ranking items in a set of data. The approach shown in that chapter
    was to build a dictionary of items with the same key value. This made it possible
    to create a rank that was the mean of the various items. For example, the sequence
    `[0.8,`` 1.2,`` 1.2,`` 2.3,`` 18]` should have rank values of 1, 2.5, 2.5, 4,
    5\. The two matching key values in positions 1 and 2 of the sequence should have
    the midpoint value of 2.5 as their common rank.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 7 章](Chapter_07.xhtml#x1-1530007)，[复杂无状态对象](Chapter_07.xhtml#x1-1530007)中，我们探讨了在数据集中对项目进行排名的方法。该章节中展示的方法是构建具有相同键值的项的字典。这使得创建一个平均各种项的排名成为可能。例如，序列
    `[0.8,`` 1.2,`` 1.2,`` 2.3,`` 18]` 应该有排名值 1、2.5、2.5、4、5。序列中位置 1 和 2 的两个匹配键值应具有
    2.5 的中间值作为它们的共同排名。
- en: This can be computed using `itertools.groupby()`. Each group will have some
    number of members, provided by the `groupby()` function. The sequence of rank
    values for a group of n items with matching keys is r[0],r[0] + 1,r[0] + 2,...,r[0]
    + n. The value of r[0] is the starting rank for the group. The mean of this sequence
    is r[0] + ![n 2](img/file79.jpg). This processing requires creating a temporary
    sequence of values in order to emit each item from the group of values with the
    same key with their matching ranks.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用 `itertools.groupby()` 来计算。每个组将包含一些成员，这些成员由 `groupby()` 函数提供。具有匹配键的 n
    个项目的组排名值序列是 r[0]，r[0] + 1，r[0] + 2，...，r[0] + n。r[0] 的值是该组的起始排名。这个序列的平均值是 r[0]
    + ![n 2](img/file79.jpg)。这个处理过程需要创建一个临时值序列，以便从具有相同键的值组中按其匹配的排名发出每个项目。
- en: Write this `rank()` function, using the `itertools.groupby()` function. Compare
    the code with the examples in [Chapter 7](Chapter_07.xhtml#x1-1530007), [Complex
    Stateless Objects](Chapter_07.xhtml#x1-1530007). What advantages does the `itertools`
    variant offer?
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这个 `rank()` 函数，使用 `itertools.groupby()` 函数。将代码与[第 7 章](Chapter_07.xhtml#x1-1530007)，[复杂无状态对象](Chapter_07.xhtml#x1-1530007)中的示例进行比较。`itertools`
    变体提供了哪些优势？
- en: Join our community Discord space
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Python Discord workspace to discuss and know more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
