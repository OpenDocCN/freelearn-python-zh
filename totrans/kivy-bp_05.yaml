- en: Chapter 5. Making a Remote Desktop App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：制作远程桌面应用程序
- en: To summarize the networking theme started in the previous chapter, let's build
    another client-server application—a Remote Desktop app. This time our app will
    solve a more complex practical task and communicate using a "real" application-level
    protocol.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结上一章开始的网络主题，让我们构建另一个客户端-服务器应用程序——一个远程桌面应用程序。这次我们的应用程序将解决一个更复杂的实际任务，并使用“真实”的应用层协议进行通信。
- en: 'Let''s discuss the task at hand for a moment. First, the purpose: a typical
    remote desktop program allows users to access other computers remotely via local
    area network or the Internet. It is common to use such apps for ad hoc technical
    support or remote assistance, for example, by IT personnel in a big company.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时讨论一下手头的任务。首先，目的是：一个典型的远程桌面程序允许用户通过局域网或互联网远程访问其他计算机。这种应用程序通常用于临时技术支持或远程协助，例如，大公司中的IT人员。
- en: 'Second, the terminology: the *host* machine is the one being remotely controlled
    (running the remote-control server), and the *client* is the system that controls
    the host. Remote system management is basically the process of user interaction
    with the host machine using another computer system (client) as a proxy.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，关于术语：*主机*机器是被远程控制的那一台（运行远程控制服务器），而*客户端*是控制主机的系统。远程系统管理基本上是用户通过另一台计算机系统（客户端）作为代理与主机机器进行交互的过程。
- en: 'So, this whole endeavor boils down to the following activities:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，整个努力归结为以下活动：
- en: Collect relevant user input (such as mouse and keyboard events) on the client
    and apply it to the host
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端收集相关用户输入（如鼠标和键盘事件）并将其应用于主机
- en: Send any relevant output (most commonly a screen capture, sometimes audio, and
    so on) from the host machine back to the client
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主机机器发送任何相关输出（通常是屏幕截图，有时是音频等）回客户端
- en: These two steps are performed repeatedly until the session ends and the connection
    between machines is closed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤会重复执行，直到会话结束，机器之间的连接关闭。
- en: 'The definition that we discussed earlier is very broad and many commercial
    packages compete on feature completeness, some even allow you to play video games
    remotely—with accelerated graphics and gaming controller input. We are going to
    limit the scope of our work so that the project can be completed within a reasonable
    time:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的定义非常广泛，许多商业软件包在功能完整性上竞争，有些甚至允许你远程玩视频游戏——带有加速图形和游戏控制器输入。我们将限制我们工作的范围，以便项目可以在合理的时间内完成：
- en: For the user input, only clicks (or taps, there is no difference in this context)
    are accepted and sent over.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于用户输入，只接受并发送点击（或轻触，在此上下文中没有区别）。
- en: For the output, just the screen capture is taken, because capturing sound and
    streaming it over the network can be way too challenging for a tutorial.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于输出，只捕获屏幕截图，因为捕获声音并通过网络传输可能对教程来说过于具有挑战性。
- en: Only Windows hosts are supported. Any recent Windows version should be fine;
    Windows 7 or later is recommended. We assume desktop and not WinRT or Windows
    Phone. There are no such restrictions on the client, as it runs a portable Kivy
    app.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅支持Windows主机。任何较新的Windows版本都应没问题；建议使用Windows 7或更高版本。我们假设是桌面操作系统，而不是WinRT或Windows
    Phone。客户端没有这样的限制，因为它运行的是便携式Kivy应用程序。
- en: The last point is unfortunate, but since every system uses different APIs to
    take screenshots and emulate clicks, we should start with the most popular one
    anyway. Support for other host systems can be added to the server later; this
    isn't overly complex *per se*, just very platform-specific.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点是不幸的，但既然每个系统都使用不同的API来截图和模拟点击，我们仍然应该从最流行的一个开始。可以在稍后添加对其他主机系统的支持；这本身并不复杂，只是非常特定于平台。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: 'Regarding the OS choice: if you don''t use the Windows OS, no worries. This
    is the same as with Android earlier: you can easily run Windows inside a virtual
    machine. VirtualBox VM is a go-to solution for desktop virtualization, and it
    is freely available from the official website at [https://www.virtualbox.org/](https://www.virtualbox.org/).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于操作系统选择：如果你不使用Windows操作系统，不用担心。这和之前的Android一样：你可以在虚拟机中轻松运行Windows。VirtualBox
    VM是桌面虚拟化的首选解决方案，并且可以从官方网站免费获取[https://www.virtualbox.org/](https://www.virtualbox.org/)。
- en: On a Mac, Parallels is a better option in terms of usability and the operating
    system integration. The only possible downside is its hefty price tag.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上，Parallels在可用性和操作系统集成方面是一个更好的选择。唯一的可能缺点是它的价格昂贵。
- en: 'In this chapter, we will cover the following topics of interest:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下感兴趣的主题：
- en: Writing an HTTP server in Python with the help of the Flask microframework
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask微框架在Python中编写HTTP服务器
- en: Taking screenshots using the **Python Imaging Library** (**PIL**)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Python Imaging Library**（**PIL**）进行截图
- en: Emulating clicks on Windows, utilizing the WinAPI functionality
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用WinAPI功能在Windows上模拟点击
- en: Prototyping a simple JavaScript client and using it for testing
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个简单的JavaScript客户端并用于测试
- en: Finally, building a Kivy-based HTTP client app for our remote desktop server
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，为我们的远程桌面服务器构建一个基于Kivy的HTTP客户端应用
- en: The server
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器
- en: 'To simplify testing and possible future integration, we want to make our server
    talk a well-established application-level protocol this time. Let''s use **Hypertext
    Transfer Protocol** (**HTTP**); in addition to relative simplicity and ease of
    testing, it has at least two more valuable qualities:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化测试和可能的未来集成，我们希望这次让我们的服务器使用一个成熟的应用层协议。让我们使用**超文本传输协议**（**HTTP**）；除了相对简单和易于测试之外，它还具有至少两个更有价值的特性：
- en: Abundance of libraries to support it, both server- and client-side. This is
    obviously a consequence of HTTP powering the Internet, the largest and most popular
    network to date.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丰富的库支持，包括服务器端和客户端。这显然是HTTP作为互联网（迄今为止最大和最受欢迎的网络）的推动力。
- en: Unlike many other protocols, for HTTP we can write a very simple proof-of-concept
    JavaScript client that runs inside a web browser. This isn't strictly related
    to the topic of the book, but may prove useful in a number of scenarios, especially
    when debugging.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与许多其他协议不同，对于HTTP，我们可以编写一个非常简单的概念验证JavaScript客户端，该客户端在网页浏览器中运行。这虽然与本书的主题没有直接关系，但在许多场景中可能很有用，尤其是在调试时。
- en: The library of choice that we'll utilize to build the server is Flask. There
    is another popular Python web framework, Django, that's also highly recommended.
    However, Django projects generally end up being more heavyweight, so we'll stick
    with Flask for this simplistic server.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用Flask库来构建服务器。还有一个流行的Python网络框架Django，也非常推荐。然而，Django项目通常最终会变得比较庞大，所以我们将坚持使用Flask来构建这个简单的服务器。
- en: 'To install Flask on the server, the following command is sufficient:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要在服务器上安装Flask，以下命令就足够了：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you don't have `pip` installed, try running the `easy_install pip` command
    first. Depending on your Python setup, you may need to run this from a privileged
    user having sufficient permissions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装`pip`，请首先尝试运行`easy_install pip`命令。根据您的Python设置，您可能需要以具有足够权限的特权用户身份运行此命令。
- en: On Windows, Python setup tends to be much more convoluted compared to Mac OS
    or Linux; please see the previous chapter for more extensive details on Python
    package management. Alternatively, you could jump straight to the official pip
    reference, found at [https://pip.pypa.io/en/latest/installing.html](https://pip.pypa.io/en/latest/installing.html).
    This document covers the installation of `pip` across all supported operating
    systems.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，Python的设置通常比Mac OS或Linux复杂得多；请参阅上一章中关于Python包管理的更详细信息。或者，您可以直接跳转到官方pip参考，网址为[https://pip.pypa.io/en/latest/installing.html](https://pip.pypa.io/en/latest/installing.html)。本文件涵盖了在所有支持的操作系统上安装`pip`。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that, similar to the previous project we built (the Chat application from
    the previous chapter), Kivy framework doesn't have to be installed on the server.
    Our server-side code runs headless, without any user interface whatsoever—other
    than perhaps an occasional console output.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与上一章我们构建的项目（聊天应用）类似，Kivy框架不需要在服务器上安装。我们的服务器端代码是无头运行的，没有任何用户界面——除了偶尔的命令行输出。
- en: The Flask web server
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask网络服务器
- en: A web server is usually structured as a series of handlers bound to different
    URLs. Such binding is commonly called *routing*. The goal of Flask, among the
    others, is to obviate this binding and make it easy to add new routes to a program.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网络服务器通常由一系列绑定到不同URL的处理程序组成。这种绑定通常被称为*路由*。Flask（以及其他框架）的目标之一是消除这种绑定，并使向程序添加新路由变得容易。
- en: 'The simplest, one-page Flask server (let''s name it `server.py`) goes like
    this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的单页Flask服务器（让我们称它为`server.py`）如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In Flask, routing is designated with decorators such as `@app.route('/')`, which
    is perfect when you only have a small number of distinct URLs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask中，使用装饰器如`@app.route('/')`来指定路由，当你只有少量不同的URL时，这非常完美。
- en: The `'/'` route is the server root; this is the default when you type a domain
    name into address bar. To open the trivial website we just wrote in your browser,
    just go to http://127.0.0.1:7080 on the same machine (don't forget to start the
    server first). When you do that, a **Hello, Flask** message should appear, confirming
    that our toy HTTP server works.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`''/''` 路由是服务器根目录；当你将域名输入地址栏时，这是默认设置。要在你的浏览器中打开我们刚刚编写的简单网站，只需在同一台机器上访问 http://127.0.0.1:7080（别忘了先启动服务器）。当你这样做时，应该会看到一个
    **Hello, Flask** 消息，确认我们的玩具 HTTP 服务器正在工作。'
- en: '![The Flask web server](img/B01620_05_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Flask 网络服务器](img/B01620_05_01.jpg)'
- en: A minimalistic website powered by Flask
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Flask 驱动的简约网站
- en: Those not familiar with web servers may wonder about the strange argument to
    `app.run()`, the **0.0.0.0** IP address. That's not a valid IP address that you
    can connect to, as it doesn't designate a network interface by itself (it is non-routable).
    In the context of a server, binding to this IP usually means that we want our
    app to listen on all IPv4 network interfaces—that is, respond to requests from
    all the available IP addresses that the machine has.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉网络服务器的人来说，可能会对 `app.run()` 中的奇怪参数感到好奇，即 **0.0.0.0** IP 地址。这不是一个有效的 IP 地址，你可以连接到它，因为它本身并不指定一个网络接口（它是不可路由的）。在服务器的上下文中，绑定到这个
    IP 地址通常意味着我们希望我们的应用程序监听所有 IPv4 网络接口——也就是说，响应来自机器上所有可用 IP 地址的请求。
- en: 'This is different from the default, localhost (or 127.0.0.1) setting: listening
    exclusively on the localhost IP allows connections from the same machine alone,
    therefore, this mode of operation can be helpful for debugging or testing. In
    this example, however, we use a more production-oriented setting, 0.0.0.0—this
    makes the machine accessible from the outside world (typically, the local area
    network). Note that this doesn''t automatically bypass the router; it should work
    for your LAN, but may need additional configuration to be accessible globally.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这与默认的本地主机（或 127.0.0.1）设置不同：仅监听本地主机 IP 允许来自同一台机器的连接，因此，这种操作模式对于调试或测试可能很有帮助。然而，在这个例子中，我们使用了一个更面向生产的设置，0.0.0.0——这使得机器可以从外部世界（通常是局域网）访问。请注意，这并不会自动绕过路由器；它应该适用于您的局域网，但要使其在全球范围内可访问可能需要额外的配置。
- en: Also, don't forget to allow the server through the firewall, as it takes precedence
    over application-level settings.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，别忘了允许服务器通过防火墙，因为它的优先级高于应用程序级别的设置。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Choice of port**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**端口号选择**'
- en: The port number by itself doesn't make much sense; what matters is that you
    use the same number in both server and client, be it a web browser or a Kivy app.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 端口号本身并没有太多意义；重要的是你在服务器和客户端使用相同的数字，无论是网页浏览器还是 Kivy 应用。
- en: Be aware that on almost all systems, ports below 1024 can only be opened by
    a privileged user account (root or Administrator). Many ports in that range are
    already assigned to existing services anyway, so it's not advised to pick port
    numbers under 1024 for the specific needs of your application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在几乎所有的系统中，端口号低于 1024 的端口只能由特权用户账户（root 或管理员）打开。那个范围内的许多端口已经被现有的服务占用，因此不建议为应用程序的特定需求选择低于
    1024 的端口号。
- en: The default port for the HTTP protocol is 80, for example, [http://www.w3.org/](http://www.w3.org/)
    is the same as [http://www.w3.org:80/](http://www.w3.org:80/), and usually you
    don't need to specify it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 协议的默认端口号是 80，例如，[http://www.w3.org/](http://www.w3.org/) 与 [http://www.w3.org:80/](http://www.w3.org:80/)
    相同，通常你不需要指定它。
- en: You might notice that web development in Python is very easy—a Python script
    just a couple of lines long can get you up and running with a dynamic web server.
    Expectedly, not everything is this simple; some things aren't immediately available
    in the form of reusable library.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，Python 的网络开发非常简单——只有几行长的 Python 脚本就可以让你启动一个动态网络服务器。预期的是，并不是所有的事情都是这么简单；一些事情并不是立即以可重用库的形式可用。
- en: 'This can be viewed as a competitive advantage, by the way: if you''re struggling
    with implementation of a non-trivial bit of functionality, chances are that not
    many instances of this thing exist, if at all, which makes your product more unique
    and competitive in the end.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这可以被视为一种竞争优势：如果你在实现一个非平凡的功能时遇到困难，那么这种东西的实例可能不多，甚至没有，这使得你的产品最终更加独特和具有竞争力。
- en: Advanced server functionality – taking screenshots
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级服务器功能 - 截图
- en: 'Once we have decided on a protocol and a server-side toolkit, our next challenges
    involve taking screenshots and simulating clicks that come from the client. Just
    a quick reminder: in this section, we will be covering only a Windows-specific
    implementation; adding Mac and Linux support is left as an exercise for the reader.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了协议和服务器端工具包，接下来的挑战包括从客户端获取截图和模拟点击。快速提醒一下：在本节中，我们将仅涵盖Windows特定的实现；添加Mac和Linux支持留作读者的练习。
- en: Luckily, the PIL has just the function we need; by calling `PIL.ImageGrab.grab()`,
    we get a screenshot of our Windows desktop as an RGB bitmap. All that's left is
    hooking it up to Flask so that the screenshot is properly served over HTTP.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，PIL正好有我们需要的函数；通过调用`PIL.ImageGrab.grab()`，我们得到Windows桌面的RGB位图截图。剩下的只是将其连接到Flask，以便通过HTTP正确提供截图。
- en: We will use a fork of an old and basically unmaintained PIL module called **Pillow**.
    By the way, Pillow is a great open source project used by many developers; if
    you're looking to contribute to Python userland, look no further. A good starting
    point will be the official Pillow documentation at [http://pillow.readthedocs.org/](http://pillow.readthedocs.org/).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个旧的和基本上不再维护的PIL模块的分支，称为**Pillow**。顺便说一句，Pillow是一个许多开发者使用的优秀开源项目；如果你想为Python用户空间做出贡献，那就不用再看了。一个好的起点将是Pillow的官方文档[http://pillow.readthedocs.org/](http://pillow.readthedocs.org/)。
- en: 'Install the library exactly like you installed Flask:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 按照你安装Flask的方式安装库：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Pillow comes with binaries for Windows pre-packaged, so you don't need a compiler
    or a Visual Studio installed on your machine.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Pillow为Windows预包装了二进制文件，因此你不需要在机器上安装编译器或Visual Studio。
- en: 'Now we''re good to go. The following code demonstrates how to serve screenshots
    (or any other PIL bitmaps for that matter) from a Flask server:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备就绪。以下代码演示了如何从Flask服务器提供截图（或任何其他PIL位图）：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you're not familiar with `StringIO`, it's a file-like object that is stored
    in memory and not written to disk. Such "virtual files" are useful when we need
    to use an API that expects a file object on a vanity data. In this example, we
    don't want to store a screenshot, which is temporary and not reusable by definition,
    in a physical file. The sheer overhead of continuously dumping data on disk isn't
    justified; it's usually much better (and way faster) to allocate a chunk of memory
    and immediately free it when the response is sent.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉`StringIO`，它是一个存储在内存中而不是写入磁盘的文件类似对象。这种“虚拟文件”在需要使用期望在虚拟数据上有一个文件对象的API时非常有用。在这个例子中，我们不想将截图存储在物理文件中，因为截图是临时的，按定义不可重复使用。不断将数据写入磁盘的巨大开销是不合理的；通常更好（并且更快）的是分配一块内存，并在响应发送后立即释放它。
- en: The rest of the code should be self-evident. We're getting a `screen` picture
    from a `PIL.ImageGrab.grab()` call, saving it using `screen.save()` to a lossy,
    low-quality JPEG file to save bandwidth, and finally sending the image to user
    with the MIME type of `'image/jpeg'`, so that it will be immediately recognized
    by web browsers as a picture of the correct type.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其他部分应该是显而易见的。我们通过`PIL.ImageGrab.grab()`调用获取`screen`图片，使用`screen.save()`将其保存为有损、低质量的JPEG文件以节省带宽，最后将图像以`'image/jpeg'`的MIME类型发送给用户，这样它将被网络浏览器立即识别为正确类型的图片。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this situation, as in many others, low quality is actually a desirable property
    of the system; we're optimizing for throughput and round-trip speed, not for visual
    quality of each individual frame in a series.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，就像在其他许多情况下一样，低质量实际上是系统的理想属性；我们正在优化吞吐量和往返速度，而不是单个帧的视觉质量。
- en: 'The same goes for the connotation of low-quality code: it''s actually great
    to be able to produce a quick and dirty prototype sometimes, for example, when
    fiddling with a new concept or doing market research.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于低质量代码的含义也是如此：有时能够快速制作一个原型实际上是非常好的，例如，当摆弄新概念或进行市场研究时。
- en: Though it seems strange at first, the `buf.seek(0)` call is needed to *rewind*
    the `StringIO` instance; otherwise, it's at the end of the data stream and won't
    yield anything to `send_file()`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始看起来很奇怪，但`buf.seek(0)`调用是必需的，以*重置*`StringIO`实例；否则，它位于数据流的末尾，不会向`send_file()`提供任何内容。
- en: 'Now you can test the server implementation that we have so far by pointing
    your browser of choice at `http://127.0.0.1:7080/desktop.jpeg` and taking a peek
    on the Windows desktop of the machine where the `server.py` script is running.
    If the code works correctly, it should produce a picture as displayed in the following
    screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过将你的浏览器指向`http://127.0.0.1:7080/desktop.jpeg`来测试我们迄今为止的服务器实现，并查看运行`server.py`脚本的机器的Windows桌面。如果代码正确无误，它应该会产生以下截图所示的图片：
- en: '![Advanced server functionality – taking screenshots](img/B01620_05_02.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![高级服务器功能 – 截图功能](img/B01620_05_02.jpg)'
- en: Windows desktop, as seen by the Flask server (fragment)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Flask服务器看到的Windows桌面（片段）
- en: An interesting part here is the route, **"desktop.jpeg"**. Naming URLs after
    files became somewhat customary because ancient web server tools like **Personal
    Home Page** (**PHP**), a toy programming language suitable for building simple
    dynamic sites, operated on physical files. This means that there was basically
    no concept of routing—you could just enter the name of the script in an address
    bar to run it on the server.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的部分是路由，**"desktop.jpeg"**。根据文件命名URL已经成为一种惯例，因为古老的网络服务器工具，如**个人主页**（**PHP**），一种适合构建简单动态站点的玩具编程语言，是在物理文件上操作的。这意味着基本上没有路由的概念——你只需在地址栏中输入脚本的名称，就可以在服务器上运行它。
- en: Obviously, this created gaping chasms in the web server security, including
    (but not limited to) remotely viewing system configuration files by entering,
    for example, `'/../../etc/passwd'` in place of a URL, and being able to upload
    and run malicious scripts serving as Trojans (backdoors) that are used to eventually
    seize control of the server.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这为网络服务器安全留下了巨大的漏洞，包括（但不限于）通过输入例如`'/../../etc/passwd'`来远程查看系统配置文件，以及能够上传并运行恶意脚本作为特洛伊木马（后门），最终用于控制服务器。
- en: Python web frameworks have mostly learned this lesson. While you can try and
    replicate such an insecure setup using Python, it is both non-trivial to do and
    strongly discouraged. Additionally, Python libraries usually don't come bundled
    with bad PHP-style configurations by default.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Python网络框架大多已经吸取了这个教训。虽然你可以尝试使用Python复制这样一个不安全的设置，但这既不简单，也强烈不建议这样做。此外，Python库通常不会默认捆绑有不良的PHP风格配置。
- en: Today, serving actual files directly from the filesystem isn't unheard of, but
    is used mostly for static files. Still, we sometimes name dynamic routes as if
    they were files (`/index.html`, `/desktop.jpeg`, and so on) to convey the semantics
    of what kind of content users should expect from such URLs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，直接从文件系统中提供实际文件并不罕见，但主要用于静态文件。尽管如此，我们有时会像文件一样命名动态路由（例如`/index.html`、`/desktop.jpeg`等），以传达用户应该从这样的URL中期望的内容类型。
- en: Emulating clicks
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟点击
- en: With the screenshots part finished, the last non-trivial bit of functionality
    that we need to implement on the server is click emulation. For this we won't
    use an external library; we'll employ WinAPI (the underlying programming interface
    that powers, directly or indirectly, all Windows apps) instead, using the built-in
    Python `ctypes` module.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 截图部分完成后，服务器上需要实现的最后一个非平凡的功能是点击模拟。为此，我们不会使用外部库；我们将使用WinAPI（直接或间接为所有Windows应用程序提供动力的底层编程接口），通过内置的Python
    `ctypes`模块来实现。
- en: 'But first we need to get the click coordinates from the URL. Let''s use regular
    `GET` parameters that look like this: `/click?x=100&y=200`. This should be trivial
    to manually test in a browser, as opposed to POST and other HTTP methods that
    may require additional software to emulate.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先我们需要从URL中获取点击坐标。让我们使用类似这样的常规`GET`参数：`/click?x=100&y=200`。在浏览器中手动测试应该很简单，与可能需要额外软件来模拟的POST和其他HTTP方法相比。
- en: 'A parser for simple URL arguments is built into Flask, and they can be accessed
    as shown in the next code snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Flask内置了一个简单的URL参数解析器，它们可以通过以下代码片段访问：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Error handling here, of all places, is recommended when prototyping, because
    it's very easy to forget or send malformed parameters, so we're checking for just
    that— the (in)ability to get numbers from `GET` request args. Responding with
    an obvious error message also helps debugging when (or if) you see this message,
    as it's completely obvious what's going on and where to look for the problem—in
    the code that passed arguments to `/click`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在原型设计时，这里推荐进行错误处理，因为很容易忘记或发送格式不正确的参数，所以我们正在检查这一点——从 `GET` 请求参数中获取数字的能力。如果看到这个明显的错误消息，响应也有助于调试，因为它完全清楚发生了什么以及在哪里查找问题——在传递给
    `/click` 的参数的代码中。
- en: 'After we have the coordinates for a click, an invocation of WinAPI is in order.
    We need two functions, both residing in `user32.dll`: the `SetCursorPos()` that
    moves the mouse pointer, and the `mouse_event()` that simulates a number of mouse-related
    events, for example, the mouse button being pressed or released.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获得点击的坐标后，需要调用 WinAPI。我们需要两个函数，这两个函数都位于 `user32.dll` 中：`SetCursorPos()` 函数用于移动鼠标指针，`mouse_event()`
    函数用于模拟一系列鼠标相关事件，例如鼠标按钮的按下或释放。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By the way, the `32` part in `user32.dll` isn't related to your system being
    32- or 64-bit. The Win32 API first appeared in Windows NT, it predates the AMD64
    (x86_64) architecture by at least 7 years and is called Win32 as opposed to an
    older, 16-bit WinAPI.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，`user32.dll` 中的 `32` 部分与你的系统是 32 位还是 64 位无关。Win32 API 首次出现在 Windows NT
    中，它比 AMD64（x86_64）架构早至少 7 年，被称为 Win32，而不是较旧的 16 位 WinAPI。
- en: 'The first argument to `mouse_event()` is an event type, which is a C enum (in
    other words, a set of integer constants). Let''s define these constants in our
    Python code for the sake of readability, as using literal `2` for **mouse down**
    and `4` for **mouse up** isn''t very readable. This amounts to the following lines:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`mouse_event()` 函数的第一个参数是一个事件类型，它是一个 C 枚举（换句话说，一组整数常量）。为了提高可读性，让我们在我们的 Python
    代码中定义这些常量，因为使用字面量 `2` 表示 **鼠标按下** 和 `4` 表示 **鼠标释放** 并不是很直观。这相当于以下几行代码：'
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'For the full reference on WinAPI functions and constants, please visit the
    **Microsoft Developer Network** (**MSDN**) site, or more specifically the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 WinAPI 函数和常量的完整参考，请访问 **Microsoft 开发者网络**（**MSDN**）网站，或者更具体地说，以下链接：
- en: '`SetCursorPos()`: [http://msdn.microsoft.com/en-us/library/windows/desktop/ms648394%28v=vs.85%29.aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/ms648394%28v=vs.85%29.aspx)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetCursorPos()`：[http://msdn.microsoft.com/en-us/library/windows/desktop/ms648394%28v=vs.85%29.aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/ms648394%28v=vs.85%29.aspx)'
- en: '`mouse_event()`: [http://msdn.microsoft.com/en-us/library/windows/desktop/ms646260%28v=vs.85%29.aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/ms646260%28v=vs.85%29.aspx)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouse_event()`：[http://msdn.microsoft.com/en-us/library/windows/desktop/ms646260%28v=vs.85%29.aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/ms646260%28v=vs.85%29.aspx)'
- en: It isn't feasible to reproduce this content here due to its size, and we won't
    use most of the available functionality anyway; WinAPI is all-encompassing and
    does more or less everything, usually in more than one way.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内容量较大，在这里重现此内容是不可行的，而且我们无论如何也不会使用大多数可用功能；WinAPI 包罗万象，几乎可以做任何事情，通常有多种方式。
- en: 'This is the fun part: we get to actually emulate clicks. (The first part of
    the function, where `x` and `y` are fetched from `GET` parameters, is unchanged.)
    The code is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最有趣的部分：我们实际上可以模拟点击。 (函数的第一部分，其中 `x` 和 `y` 从 `GET` 参数中获取，保持不变。) 代码如下：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This does just what it says if you try reading the code aloud: the function
    moves the mouse to the desired position and then simulates the left mouse button
    click (with button press and release being two separate actions).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试大声阅读代码，这个函数就会做它所说的：该函数将鼠标移动到所需位置，然后模拟左键鼠标点击（按钮按下和释放是两个独立的行为）。
- en: Now, you should be able to manually control the mouse cursor on the host machine.
    Try visiting a URL such as `http://127.0.0.1:7080/click?x=10&y=10` and make sure
    there is something in the top-left corner of the screen. You'll notice how that
    item gets selected.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够手动控制宿主机器上的鼠标光标。尝试访问一个 URL，例如 `http://127.0.0.1:7080/click?x=10&y=10`，并确保屏幕的左上角有东西。你会注意到那个项目是如何被选中的。
- en: You can even perform a double-click if you refresh the page sufficiently fast.
    This may require that you run the browser on another machine; don't forget to
    substitute the real host IP instead of `127.0.0.1`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以快速刷新页面来执行双击。这可能需要你在另一台机器上运行浏览器；别忘了用实际的宿主 IP 地址替换 `127.0.0.1`。
- en: JavaScript client
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 客户端
- en: In this section, we will briefly cover the development of a JavaScript remote
    desktop client mockup, which is feasible mostly because we use the HTTP protocol.
    This uncomplicated client will run in the browser and serve as a prototype of
    the Kivy remote desktop application that we're going to build next.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍JavaScript远程桌面客户端原型开发，这主要是因为我们使用了HTTP协议。这个简单的客户端将在浏览器中运行，并作为我们接下来要构建的Kivy远程桌面应用程序的原型。
- en: If you aren't familiar with JavaScript, don't worry; the language is very easy
    to get into and may even look similar to Python, depending on code style. We are
    also going to use **jQuery** for heavy lifting, such as DOM operations and AJAX
    calls.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉JavaScript，不要担心；这种语言很容易上手，根据代码风格，甚至可能看起来与Python相似。我们还将使用 **jQuery** 来处理重负载，例如DOM操作和AJAX调用。
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In a production setting, jQuery usage may be frowned upon (and rightfully so),
    especially when aiming for a lean, high-performance codebase. However, for quick
    prototyping or vanity web apps, jQuery shines because it facilitates writing functioning,
    albeit suboptimal, code very quickly.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，jQuery的使用可能会受到批评（这是合理的），尤其是在追求精简、高性能的代码库时。然而，对于快速原型设计或虚荣Web应用，jQuery非常出色，因为它可以快速编写出功能性的，尽管不是最优的，代码。
- en: 'For a web app, we need to serve a complete HTML page instead of just **Hello,
    Flask**. To do this, let''s create the `index.html` file that resides in a folder
    named `static`, where Flask expects to find it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个Web应用，我们需要提供一个完整的HTML页面，而不仅仅是 **Hello, Flask**。为此，让我们创建一个名为 `static` 的文件夹中的
    `index.html` 文件，这是Flask期望找到它的位置：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding listing is a very basic HTML5 document. It does nothing special
    at the moment: jQuery is loaded from the official CDN, but that''s it—no moving
    parts yet.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表是一个非常基本的HTML5文档。目前它没有任何特殊功能：jQuery是从官方CDN加载的，但仅此而已——还没有任何动态部分。
- en: 'To serve this new file from Flask, replace the `index()` function in `server.py`
    with the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Flask提供这个新文件，将 `server.py` 中的 `index()` 函数替换为以下代码：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This works just like the `desktop()` function earlier, but reads a real file
    from disk this time.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前提到的 `desktop()` 函数工作原理相同，但这次是从磁盘读取一个真实文件。
- en: Endless loop of screenshots
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无限截图循环
- en: 'To start off, let''s display a continuous screencast: our script is going to
    request a new screenshot every two seconds, and then show it to the user immediately.
    Since we''re writing a web app, all complex stuff is actually handled by the browser:
    an `<img>` tag loads an image and displays it on the screen, with very little
    effort on our part.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们显示一个连续的屏幕录制：我们的脚本将每两秒请求一个新的截图，然后立即显示给用户。由于我们正在编写一个Web应用，所有复杂的事情实际上都是由浏览器处理的：一个
    `<img>` 标签加载图像并在屏幕上显示，我们几乎不需要做任何工作。
- en: 'Here is the algorithm for this functionality:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个功能的算法：
- en: Remove the old `<img>` tag (if any)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除旧的 `<img>` 标签（如果有）
- en: Add a new `<img>` tag
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的 `<img>` 标签
- en: Repeat after 2 seconds
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2秒后重复
- en: 'In JavaScript, this can be implemented as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，可以这样实现：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are two things here that may need some additional insight:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两件事可能需要一些额外的洞察：
- en: The `$()` jQuery function selects elements on the page so that we can perform
    various operations on them, such as `.remove()` or `.insert()`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$()` jQuery函数用于选择页面上的元素，以便我们可以对它们执行各种操作，例如 `.remove()` 或 `.insert()`。'
- en: '`Date.now()` returns the current timestamp, namely, the number of milliseconds
    since January 1, 1970\. We use this number to prevent caching. It will be different
    on every invocation; so when appended to the (otherwise constant) `/desktop.jpeg`
    URL, timestamp will make it unique, as far as the web browser is concerned.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date.now()` 返回当前时间戳，即自1970年1月1日以来的毫秒数。我们使用这个数字来防止缓存。每次调用都会不同；因此，当附加到（否则恒定的）`/desktop.jpeg`
    URL时，时间戳将使其对网络浏览器来说是唯一的。'
- en: 'Let''s also downscale the image so that it doesn''t exceed our browser window''s
    width and remove any margins. This is also very simple to achieve; just add this
    small stylesheet in the `<head>` section of the HTML document:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也将图像缩小，使其不超过浏览器窗口的宽度，并移除任何边距。这也很简单实现；只需在HTML文档的 `<head>` 部分添加这个小样式表：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Try resizing the browser window and notice how the image shrinks to fit.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整浏览器窗口大小，注意图像如何缩小以适应。
- en: '![Endless loop of screenshots](img/B01620_05_03.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![无限截图循环](img/B01620_05_03.jpg)'
- en: Remote desktop viewed in the browser, scaled to the size of the browser window
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看的远程桌面，已缩放到浏览器窗口大小
- en: You may also notice that the image flickers when reloading. This happens because
    we show `desktop.jpeg` to the user immediately, before it is fully loaded. Even
    more problematic than visual glitches is the fixed time frame for download, which
    we arbitrarily chose to be two seconds. In the case of slow network connections,
    users won't be able to complete the download and see the whole picture of their
    desktop.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能注意到，在重新加载时图像闪烁。这是因为我们在图片完全加载之前立即向用户显示 `desktop.jpeg`。比视觉故障更严重的是下载的固定时间框架，我们任意选择为两秒。在慢速网络连接的情况下，用户将无法完成下载并看到他们桌面的完整图片。
- en: We are going to address these problems in the Kivy implementation of the remote
    desktop client.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Kivy 远程桌面客户端的实现中解决这些问题。
- en: Passing clicks to host
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将点击事件传递给主机
- en: 'This is the more interesting part: we are going to capture clicks on the `<img>`
    element and pass them to the server. This is achieved using `.bind()` on (counterintuitively)
    the `<body>` element. This is because we''re constantly adding and removing the
    image, so any events that are bound to an image instance will be lost after the
    next refresh (and constantly rebinding them is just unnecessarily repetitive and
    wrong). The code listing is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更有趣的部分：我们将捕获 `<img>` 元素上的点击事件并将它们传递到服务器。这是通过在（反直觉地）`<body>` 元素上使用 `.bind()`
    实现的。这是因为我们不断地添加和删除图片，所以绑定到图片实例上的任何事件在下次刷新后都会丢失（而且不断地重新绑定它们既是不必要的重复也是错误的）。代码列表如下：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this code, we''re calculating the "real" click coordinates first: the image
    may be shrunk to fit browser width, so we compute the ratio and multiply click
    position by that:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们首先计算“实际”的点击坐标：图片可能被缩小以适应浏览器宽度，所以我们计算比例并将点击位置乘以该比例：
- en: '![Passing clicks to host](img/7849OS_05_04.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![将点击事件传递给主机](img/7849OS_05_04.jpg)'
- en: The `0|expression` syntax in JavaScript is a superior alternative to `Math.floor()`,
    as it is both faster and more concise. There are minor semantic differences too,
    but they aren't important at this point (if at all).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的 `0|expression` 语法是 `Math.floor()` 的更优替代品，因为它既更快又更简洁。还有一些微小的语义差异，但在这个阶段（如果有的话）并不重要。
- en: Now, utilizing the jQuery `$.get()` helper function, we send the result of the
    previous computation to the server. There is no processing of the server's response,
    since we're going to display a new screenshot in a moment anyway—if there was
    any effect to our last action, it will be reflected visually.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，利用 jQuery 的 `$.get()` 辅助函数，我们将前一次计算的结果发送到服务器。由于我们很快就会显示一个新的截图，所以不需要处理服务器的响应——如果我们的最后操作有任何效果，它将通过视觉反映出来。
- en: Using this trivial remote desktop client, we're already able to view the screen
    of the remote host, launch and control programs running on that machine. Now,
    let's re-implement this prototype in Kivy while improving it along the way, in
    particular, making it more suitable for use on mobile devices, adding scrolling
    and removing flicker.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个简单的远程桌面客户端，我们已经有能力查看远程主机的屏幕，启动并控制在该机器上运行的程序。现在，让我们在 Kivy 中重新实现这个原型，并在过程中改进它，特别是使其更适合在移动设备上使用，添加滚动并消除闪烁。
- en: Kivy Remote Desktop app
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kivy 远程桌面应用
- en: 'It''s time to build a fully functional remote desktop client using Kivy. There
    are several things that we can reuse from the previous app, the Chat app from
    [Chapter 4](ch04.html "Chapter 4. Kivy Networking"), *Kivy Networking*. Conceptually,
    these apps are quite similar: they consist of two screens each, with one screen
    resembling a login form with server IP address. Let''s capitalize on this similarity
    and reuse parts of the `chat.kv` file in our brand new `remotedesktop.kv`, in
    particular, the `ScreenManager` setup that is practically unchanged.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候使用 Kivy 构建一个功能齐全的远程桌面客户端了。我们可以从上一个应用程序中重用几个东西，来自 [第 4 章](ch04.html "第 4 章。Kivy
    网络") 的 Chat 应用程序，*Kivy 网络*。从概念上讲，这些应用程序相当相似：每个应用程序都有两个屏幕，其中一个屏幕类似于带有服务器 IP 地址的登录表单。让我们利用这种相似性，并在我们的全新
    `remotedesktop.kv` 文件中重用 `chat.kv` 文件的部分，特别是实际上没有变化的 `ScreenManager` 设置。
- en: The login form
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录表单
- en: 'The following listing defines the login form. It is composed of three elements—field
    caption, input field itself, and a login button—positioned in a row at the top
    of the screen:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表定义了登录表单。它由三个元素组成——字段标题、输入字段本身和登录按钮——位于屏幕顶部的行中：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There is just one input field this time, **Server IP**. In fact, you can also
    enter the hostname if it's resolvable from the given machine, but let's stick
    to this naming as it is less ambiguous. A LAN may not have a DNS server, or it
    may be configured in a way that does not match users' expectations about hostnames.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这次只有一个输入字段，**服务器IP**。实际上，如果你可以从给定的机器解析主机名，你也可以输入它，但让我们坚持这种命名方式，因为它更不模糊。局域网可能没有DNS服务器，或者它可能被配置成不符合用户对主机名的期望。
- en: '![The login form](img/B01620_05_05.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![登录表单](img/B01620_05_05.jpg)'
- en: The simple and unambiguous login form
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 简单且明确的登录表单
- en: It's not that IP addresses are very user-friendly, but we don't have many options
    here—building an autodiscovery network service to avoid this, while very much
    desirable in real-world scenarios, can also be very convoluted (and probably deserves
    its own book anyway due to the sheer number of available techniques and possible
    caveats).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址并不是非常用户友好，但在这里我们没有太多选择——构建一个自动发现网络服务来避免这种情况，虽然在现实场景中非常理想，但也可能非常复杂（而且可能因为可用的技术和可能的注意事项数量众多而值得有自己的书籍）。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You need to understand basic networking in order to address machines in complex
    scenarios such as connecting to a machine sitting behind router. As mentioned
    earlier, this is pretty much out of the scope of this work, but here are some
    quick tips:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在复杂场景中处理机器，例如连接到位于路由器后面的机器，你需要了解基本的网络知识。如前所述，这基本上超出了本工作的范围，但这里有一些快速提示：
- en: It's considerably easier to test network apps when all of your machines are
    sitting in the same network (are connected to the same router, from the same side
    of the router topologically).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有你的机器都坐在同一个网络中（从路由器的同一侧拓扑连接）时，测试网络应用程序要容易得多。
- en: Taking the previous point to the extreme means running every test box inside
    a VM on the same physical machine. This way, you can emulate any network topology
    you want, without the hassle of rearranging physical wires every time you want
    to tweak something.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将前面的观点推向极端意味着在每个物理机器上的VM中运行每个测试盒。这样，你可以模拟你想要的任何网络拓扑，而无需每次想要调整某些东西时重新排列物理线缆。
- en: To see every IP address assigned to every network interface of a computer, run
    `ifconfig` (on a Mac or Linux machine) or `ipconfig` (Windows). Usually, your
    external (Internet) IP is not among those displayed in the output, but your local
    (LAN) network address is.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看分配给计算机每个网络接口的每个IP地址，请在Mac或Linux机器上运行`ifconfig`，或在Windows上运行`ipconfig`。通常，你的外部（互联网）IP地址不会显示在输出中，但你的本地（局域网）网络地址是。
- en: There isn't much else to say about the login screen, as it consists entirely
    of building blocks that we've already discussed during the course of this book.
    Let's move on to the second screen, and ultimately to the source code powering
    the client-server engine.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 关于登录屏幕没有太多可说的，因为它完全由我们在本书的讨论过程中已经讨论过的构建块组成。让我们继续到第二个屏幕，最终到驱动客户端-服务器引擎的源代码。
- en: The remote desktop screen
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程桌面屏幕
- en: This is the second and last screen in our application, the remote desktop screen.
    It will be scrollable in two dimensions, given a big enough screen size on the
    host machine. Since full HD (1080p and more) resolutions aren't uncommon in today's
    mobile devices, let alone desktop computers, it may so happen that we won't need
    any scrolling at all.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的应用程序中的第二个也是最后一个屏幕，远程桌面屏幕。在主机机器屏幕足够大的情况下，它将在两个维度上可滚动。鉴于在今天的移动设备中，全高清（1080p及以上）的分辨率并不罕见，更不用说桌面计算机了，所以我们可能根本不需要滚动。
- en: We can build a scrolling layout based on a similar principle as the chatroom
    pane from the Chat app that we've built in [Chapter 4](ch04.html "Chapter 4. Kivy
    Networking"), *Kivy Networking*. As said earlier, the scrolling will be two-dimensional;
    an additional difference is that we don't want any overscroll (bounce back) effects
    this time to avoid unnecessary confusion. We are presenting a (remote) desktop
    to the user, and the operating system's desktop usually doesn't have this feature.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据与我们在[第4章](ch04.html "第4章。Kivy网络")中构建的聊天室面板相似的原则构建一个可滚动的布局，即*Kivy网络*。如前所述，滚动将是二维的；一个额外的区别是我们这次不想有任何过度滚动（反弹）效果，以避免不必要的混淆。我们向用户展示的是一个（远程）桌面，操作系统的桌面通常没有这个功能。
- en: 'The `remotedesktop.kv` code behind this screen is actually very concise. Let''s
    examine how different parts of it contribute to the task at hand:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕背后的`remotedesktop.kv`代码实际上非常简洁。让我们看看它的不同部分是如何为手头的任务做出贡献的：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To make scrolling work, we combine `ScrollView` with `Image`, which may become
    larger than the available screen space.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使滚动工作，我们将`ScrollView`与`Image`结合使用，这可能会比可用的屏幕空间更大。
- en: 'On `ScrollView`, we set `effect_cls: ScrollEffect` to disable overscroll; if
    you would like to leave the overscroll behavior intact, just remove this line.
    Since the `ScrollEffect` name isn''t imported by default, we''ll have to import
    it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '在`ScrollView`中，我们将`effect_cls: ScrollEffect`设置为禁用越界滚动；如果您希望保留越界滚动行为，只需删除此行。由于`ScrollEffect`名称默认未导入，我们不得不导入它：'
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Setting the `size_hint` property of `Image` to `(None, None)` is crucial; otherwise,
    Kivy will scale the image to fit, which isn't desirable in this case. The `size_hint`
    property set to `None` means *let me set the size manually*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Image`的`size_hint`属性设置为`(None, None)`至关重要；否则，Kivy会缩放图像以适应，这在当前情况下是不希望的。将`size_hint`属性设置为`None`意味着*让我手动设置大小*。
- en: Then, we do just that, binding the `size` property to `self.texture_size`. With
    this setting, the image will be of the same size as a `desktop.jpeg` texture provided
    by the server (it depends on the host machine's physical desktop size, obviously,
    so we cannot hard-code it).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们就是这样做的，将`size`属性绑定到`self.texture_size`。使用此设置，图像将与服务器提供的`desktop.jpeg`纹理大小相同（这显然取决于主机机的物理桌面大小，因此我们无法将其硬编码）。
- en: 'There is also the `nocache: True` property that instructs Kivy to never cache
    the desktop image that is temporary by definition.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '还有`nocache: True`属性，它指示Kivy永远不要缓存由定义是临时的桌面图像。'
- en: Last but not least, an interesting property of `Image` is its `on_touch_down`
    handler. This time, we want to pass the exact coordinates and other properties
    of the touch event, and that's exactly what `args[1]` means. In case you're wondering,
    `args[0]` is the widget being clicked; in this case that's the image itself (we
    have just one `Image` instance, so there's no need to pass it to the event handler).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，`Image`的一个有趣属性是其`on_touch_down`处理程序。这次，我们想要传递触摸事件的精确坐标和其他属性，这正是`args[1]`的含义。如果您在疑惑，`args[0]`是被点击的部件；在这种情况下，那就是图像本身（我们只有一个`Image`实例，因此没有必要将其传递给事件处理程序）。
- en: Loop of screenshots in Kivy
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kivy中的截图循环
- en: Now we're going to assemble everything together in Python. As opposed to the
    JavaScript implementation, we don't get the image loading and related functionality
    entirely for free, so there will be a bit more code; still, it's pretty easy to
    implement these, while maintaining better control over the whole process, as you
    will see shortly.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Python将所有这些组合在一起。与JavaScript实现相比，我们不会完全免费获得图像加载和相关功能，所以代码会多一点；然而，实现这些功能相当简单，同时还能更好地控制整个过程，您很快就会看到。
- en: 'In order to load images asynchronously, we''re going to use the Kivy built-in
    class called `Loader`, from the `kivy.loader` module. The program flow will go
    like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了异步加载图像，我们将使用Kivy内置的`Loader`类，来自`kivy.loader`模块。程序流程将如下所示：
- en: When a user clicks or taps on **Connect** on the login screen after filling
    the **Server IP** field, the `RemoteDesktopApp.connect()` function is invoked.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在填写完**服务器IP**字段后点击或轻触登录屏幕上的**连接**按钮时，将调用`RemoteDesktopApp.connect()`函数。
- en: It passes control to `reload_desktop()`, the function that starts the image
    download from the `/desktop.jpeg` endpoint.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将控制权传递给`reload_desktop()`函数，该函数从`/desktop.jpeg`端点开始下载图像。
- en: When the image is loaded, `Loader` invokes `desktop_loaded()`, which puts the
    image on the screen and schedules the next call of `reload_desktop()`. Thus, we
    get an asynchronous endless loop retrieving screenshots from the host system.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当图像加载完成后，`Loader`调用`desktop_loaded()`，将图像放在屏幕上并安排下一次调用`reload_desktop()`。因此，我们得到一个从主机系统异步无限循环检索截图的循环。
- en: The image is put on the screen *after* it was successfully loaded, so there
    will be no flickering this time like there was in the JavaScript prototype. (It's
    solvable in JS too, certainly, but that's not the goal of this write-up.)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图像在成功加载后放在屏幕上，所以这次不会有像JavaScript原型中那样的闪烁。（在JS中也可以解决，当然，但这不是本文的目的。）
- en: 'Let''s take a closer look at the aforementioned functions in `main.py`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`main.py`中提到的上述函数：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We save `url` (the full location of `/desktop.jpeg` together with the server
    IP) and `send_url` (the location of `/click` endpoint to pass clicks to host),
    and then pass the execution to the `RemoteDesktopApp.reload_desktop()` function,
    which is also very brief:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保存 `url`（`/desktop.jpeg` 的完整位置以及服务器 IP）和 `send_url`（将点击传递给主机的 `/click` 端点位置），然后传递执行到
    `RemoteDesktopApp.reload_desktop()` 函数，这个函数也非常简洁：
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding function, we start downloading the image. When it's complete,
    the freshly loaded image will be passed on to `RemoteDesktopApp.desktop_loaded()`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们开始下载图像。当下载完成时，新加载的图像将被传递到 `RemoteDesktopApp.desktop_loaded()`。
- en: Don't forget to disable the default aggressive caching by passing the `nocache=True`
    argument. Omitting this step will result in the `desktop.jpeg` image loading only
    once, because its URL stays the same. In JavaScript, we solved the same problem
    by appending `?timestamp` to the URL to make it unique, and we could certainly
    mimic such behavior in Python, but that's a hack. Kivy's way of specifying `nocache`
    is cleaner and more readable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记通过传递 `nocache=True` 参数禁用默认的积极缓存。省略此步骤将导致 `desktop.jpeg` 图像只加载一次，因为其 URL
    保持不变。在 JavaScript 中，我们通过在 URL 后追加 `?timestamp` 来解决这个问题，使其变得独特，我们当然可以在 Python 中模仿这种行为，但这是一种黑客行为。Kivy
    指定 `nocache` 的方式更干净、更易读。
- en: 'Here, you can observe the culmination of the image downloading procedure:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以观察到图像下载过程的最终结果：
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function receives the new image, `desktop`. Then, we proceed to replace
    the texture on screen with the freshly loaded one and schedule the next iteration
    of the screenshot loop to occur in a second.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接收新的图像，`desktop`。然后，我们继续用新加载的纹理替换屏幕上的纹理，并安排在下一秒发生截图循环的下一个迭代。
- en: Tip
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `Clock` object was discussed briefly in our first project ([Chapter 1](ch01.html
    "Chapter 1. Building a Clock App"), *Building a Clock App*). There, we used it
    to perform periodical actions by calling `schedule_interval()`, similar to `setInterval()`
    in JavaScript; in this case, we want a one-time invocation, `schedule_once()`,
    along the lines of `setTimeout()` in JS.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个项目中（[第 1 章](ch01.html "第 1 章. 构建时钟应用"), *构建时钟应用*），我们简要讨论了 `Clock` 对象。在那里，我们通过调用
    `schedule_interval()` 来执行周期性操作，类似于 JavaScript 中的 `setInterval()`；在这种情况下，我们想要一次调用，`schedule_once()`，类似于
    JS 中的 `setTimeout()`。
- en: 'Now, it is time to switch screens from login to the remote desktop screen.
    The following screenshot summarizes what we have so far:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候从登录屏幕切换到远程桌面屏幕了。以下截图总结了到目前为止我们所做的工作：
- en: '![Loop of screenshots in Kivy](img/B01620_05_06.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![Kivy 中截图循环](img/B01620_05_06.jpg)'
- en: A read-only (still unable to pass clicks back to host) Remote Desktop app
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个只读（仍然无法将点击传递回主机）的远程桌面应用
- en: Sending clicks
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送点击
- en: 'The remote desktop viewer is ready and features scrolling and instant transition
    between frames (no flickering whatsoever). There is one last thing left to implement:
    sending clicks to host. For this, we will listen to the `on_touch_down` event
    on the image and pass the coordinates of touches to an event handler function,
    `send_click()`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 远程桌面查看器已经准备好，具有滚动和帧之间的即时转换功能（完全没有闪烁）。最后剩下的一件事是实现发送点击到主机。为此，我们将监听图像上的 `on_touch_down`
    事件，并将触摸坐标传递给事件处理函数 `send_click()`。
- en: 'This is where it happens in `remotedesktop.kv`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 `remotedesktop.kv` 中发生的地方：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To put it in context, here is the Python counterpart in `class RemoteDesktopApp`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将其置于上下文中，以下是 `class RemoteDesktopApp` 中的 Python 对应部分：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We gather the click coordinates and feed them to the server via HTTP `GET` request
    using the network-related functions from the Python's standard library.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收集点击坐标，并通过 Python 标准库中的网络相关函数使用 HTTP `GET` 请求将它们发送到服务器。
- en: 'One major caveat here is the coordinate system: in Kivy, the *y* axis is upwards,
    while it''s usually downwards in Windows and elsewhere (for example, in browsers).
    To fix this, we subtract `event.y` from the desktop height.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里一个主要的注意事项是坐标系：在 Kivy 中，*y* 轴向上，而在 Windows 和其他地方（例如，在浏览器中）通常是向下（例如，在浏览器中）。为了解决这个问题，我们从桌面高度中减去
    `event.y`。
- en: 'Another slightly less problematic aspect is the use of Python''s standard library
    across different Python versions: the `urllib[2]` module''s structure was changed
    significantly in transition from Python 2 to Python 3.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个稍微不那么成问题的一面是跨不同 Python 版本使用 Python 的标准库：在从 Python 2 到 Python 3 的过渡中，`urllib[2]`
    模块的结构发生了显著变化。
- en: 'To account for these changes, we can use the following way of doing imports:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些变化，我们可以使用以下方式进行导入：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: While not strikingly beautiful, this approach should help you with the Python
    upgrade, should you attempt it. (Targeting a fixed version of Python is also perfectly
    acceptable, by the way. In fact, many companies do just that at the time of this
    writing, including the very employer of Guido van Rossum, creator of the Python
    programming language.)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个方法并不特别美观，但它应该能帮助你完成Python升级，如果你尝试的话。（实际上，针对固定版本的Python也是完全可以接受的。事实上，在撰写本文时，包括Python编程语言的创造者Guido
    van Rossum的雇主在内的许多公司就是这样做的。）
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this case, the Python standard library is perfectly fine; however, if at
    any time you find yourself writing repetitive, boring, and unimaginative HTTP-related
    code, consider using an excellent **Requests** library by Kenneth Reitz instead.
    Visit [http://python-requests.org/](http://python-requests.org/) for more information
    and examples. It's pretty amazing how concise and to the point its syntax is.
    Wholeheartedly recommended, this library is a work of art.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Python标准库完全足够；然而，如果你在任何时候发现自己正在编写重复、无聊且缺乏想象力的HTTP相关代码，考虑使用Kenneth Reitz的优秀的**Requests**库。访问[http://python-requests.org/](http://python-requests.org/)获取更多信息及示例。它的语法简洁明了，非常出色。强烈推荐，这个库堪称艺术品。
- en: What's next
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么
- en: 'Now, you have a Remote Desktop app that mostly works as intended, especially
    over LAN or a fast Internet connection. As usual, there are many additional problems
    to solve and a lot of new features to implement if you''re interested and willing
    to tackle with this topic some more:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有一个主要按预期工作的远程桌面应用，尤其是在局域网或快速互联网连接下。像往常一样，还有很多额外的问题需要解决，以及许多新功能需要实现，如果你对此感兴趣并且愿意进一步探讨这个话题的话：
- en: Send mouse movement as a separate event. This may also apply to double clicks,
    drag and drop, and so on.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将鼠标移动作为单独的事件发送。这也可能适用于双击、拖放等。
- en: Try to account for network latency. If the user is on a slow connection, you
    can turn image quality further down on the server to compensate. Providing the
    user with a visual clue that something is happening in the background also helps.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试考虑网络延迟。如果用户连接速度慢，你可以在服务器上进一步降低图像质量以补偿。向用户提供视觉线索，表明后台正在发生某些事情，也有帮助。
- en: Make the server cross-platform so that it runs on a Mac, Linux, and maybe even
    Android and Chrome OS.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使服务器跨平台，以便在Mac、Linux上运行，甚至可能在Android和Chrome OS上运行。
- en: Also, remember that this is an industry-strong task. It is objectively hard
    to build such software, let alone make it flawless and blazing fast. Kivy helps
    a great deal on the UI side of things, facilitates image downloading and caching,
    but that's it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，记住这是一个行业强任务。客观上，构建这样的软件就很困难，更不用说让它完美无瑕且速度极快了。Kivy在UI方面有很大帮助，简化了图像下载和缓存，但仅此而已。
- en: So, don't worry if something doesn't work immediately as you implement it—trial
    and error is not at all uncommon in this case. At times, you just need to keep
    putting one foot in front of the other.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你在实施过程中遇到某些东西不能立即工作，不要担心——在这种情况下，试错法并不罕见。有时，你只需要一步一步地前进。
- en: There is much to learn in the field of networking, and engineers knowledgeable
    in this field are few and valued highly, so it certainly pays off to dig into
    the topic of computers communicating with other computers.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络领域有很多东西要学习，而且在这个领域有知识的人很少，而且非常受重视，所以深入研究计算机之间通信的话题肯定是有回报的。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This constitutes the Remote Desktop app walkthrough. The resulting application
    can be actually used for simple tasks, for example, occasionally clicking on the
    **Play** button in iTunes or closing a program. More demanding interactions, in
    particular administrative tasks, may require much more complex software.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这构成了远程桌面应用的使用说明。生成的应用实际上可以用于简单的任务，例如，偶尔点击iTunes中的**播放**按钮或关闭一个程序。更复杂的需求，特别是管理任务，可能需要更复杂的软件。
- en: 'We also built a Flask-powered web server capable of dynamically producing images
    and interacting with the host system. On top of it, we launched a "light" JavaScript
    version of the app featuring pretty much the same functionality. The morale of
    this story is that our Kivy app does not exist in isolation. Far from it, in fact:
    we''ve actually had a server together with the working prototype of a client app—all
    before writing even a single line of Kivy-related code.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还构建了一个由Flask驱动的网络服务器，能够动态生成图像并与主机系统交互。在此基础上，我们还推出了一个具有几乎相同功能的“轻量级”JavaScript版本的应用。这个故事的核心是，我们的Kivy应用并非孤立存在。实际上，我们甚至在与客户端应用的运行原型一起构建服务器——这一切都是在编写任何与Kivy相关的代码之前完成的。
- en: As a general rule, it helps immensely to build your software in such an order
    so that you can test every part of it immediately. I'm not talking about **test-driven
    development** (**TDD**) here, as it's arguable whether full-fledged, exclusively
    test-driven programming helps the cause or not. But even just being able to fiddle
    with each piece of functionality as it comes together is infinitely more productive
    than writing a huge pile of code up front.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条一般规则，按照这样的顺序构建你的软件，以便你可以立即测试其每个部分，这非常有帮助。我这里不是在谈论**测试驱动开发**（**TDD**），因为关于全面、纯粹基于测试的编程是否有助于事业，是有争议的。但即使只是能够调整每个功能组件，也比一开始就编写一大堆代码要高效得多。
- en: Finally, Kivy is well-equipped when it comes to networked GUI apps. For example,
    the Twisted integration that we used in the previous chapter, and the support
    for loading textures over the network—these things help immensely to build multi-user,
    Internet apps.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当涉及到网络GUI应用时，Kivy配置得相当完善。例如，我们在上一章中使用的Twisted集成，以及通过网络加载纹理的支持——这些功能极大地帮助构建多用户、互联网应用。
- en: 'Now, let''s jump to another topic altogether: Kivy game development.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳到另一个完全不同的主题：Kivy游戏开发。
