- en: Chapter 5. Making a Remote Desktop App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To summarize the networking theme started in the previous chapter, let's build
    another client-server application—a Remote Desktop app. This time our app will
    solve a more complex practical task and communicate using a "real" application-level
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss the task at hand for a moment. First, the purpose: a typical
    remote desktop program allows users to access other computers remotely via local
    area network or the Internet. It is common to use such apps for ad hoc technical
    support or remote assistance, for example, by IT personnel in a big company.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, the terminology: the *host* machine is the one being remotely controlled
    (running the remote-control server), and the *client* is the system that controls
    the host. Remote system management is basically the process of user interaction
    with the host machine using another computer system (client) as a proxy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this whole endeavor boils down to the following activities:'
  prefs: []
  type: TYPE_NORMAL
- en: Collect relevant user input (such as mouse and keyboard events) on the client
    and apply it to the host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send any relevant output (most commonly a screen capture, sometimes audio, and
    so on) from the host machine back to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two steps are performed repeatedly until the session ends and the connection
    between machines is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition that we discussed earlier is very broad and many commercial
    packages compete on feature completeness, some even allow you to play video games
    remotely—with accelerated graphics and gaming controller input. We are going to
    limit the scope of our work so that the project can be completed within a reasonable
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: For the user input, only clicks (or taps, there is no difference in this context)
    are accepted and sent over.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the output, just the screen capture is taken, because capturing sound and
    streaming it over the network can be way too challenging for a tutorial.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only Windows hosts are supported. Any recent Windows version should be fine;
    Windows 7 or later is recommended. We assume desktop and not WinRT or Windows
    Phone. There are no such restrictions on the client, as it runs a portable Kivy
    app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last point is unfortunate, but since every system uses different APIs to
    take screenshots and emulate clicks, we should start with the most popular one
    anyway. Support for other host systems can be added to the server later; this
    isn't overly complex *per se*, just very platform-specific.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Regarding the OS choice: if you don''t use the Windows OS, no worries. This
    is the same as with Android earlier: you can easily run Windows inside a virtual
    machine. VirtualBox VM is a go-to solution for desktop virtualization, and it
    is freely available from the official website at [https://www.virtualbox.org/](https://www.virtualbox.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: On a Mac, Parallels is a better option in terms of usability and the operating
    system integration. The only possible downside is its hefty price tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing an HTTP server in Python with the help of the Flask microframework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking screenshots using the **Python Imaging Library** (**PIL**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulating clicks on Windows, utilizing the WinAPI functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototyping a simple JavaScript client and using it for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, building a Kivy-based HTTP client app for our remote desktop server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To simplify testing and possible future integration, we want to make our server
    talk a well-established application-level protocol this time. Let''s use **Hypertext
    Transfer Protocol** (**HTTP**); in addition to relative simplicity and ease of
    testing, it has at least two more valuable qualities:'
  prefs: []
  type: TYPE_NORMAL
- en: Abundance of libraries to support it, both server- and client-side. This is
    obviously a consequence of HTTP powering the Internet, the largest and most popular
    network to date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike many other protocols, for HTTP we can write a very simple proof-of-concept
    JavaScript client that runs inside a web browser. This isn't strictly related
    to the topic of the book, but may prove useful in a number of scenarios, especially
    when debugging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library of choice that we'll utilize to build the server is Flask. There
    is another popular Python web framework, Django, that's also highly recommended.
    However, Django projects generally end up being more heavyweight, so we'll stick
    with Flask for this simplistic server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Flask on the server, the following command is sufficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you don't have `pip` installed, try running the `easy_install pip` command
    first. Depending on your Python setup, you may need to run this from a privileged
    user having sufficient permissions.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, Python setup tends to be much more convoluted compared to Mac OS
    or Linux; please see the previous chapter for more extensive details on Python
    package management. Alternatively, you could jump straight to the official pip
    reference, found at [https://pip.pypa.io/en/latest/installing.html](https://pip.pypa.io/en/latest/installing.html).
    This document covers the installation of `pip` across all supported operating
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that, similar to the previous project we built (the Chat application from
    the previous chapter), Kivy framework doesn't have to be installed on the server.
    Our server-side code runs headless, without any user interface whatsoever—other
    than perhaps an occasional console output.
  prefs: []
  type: TYPE_NORMAL
- en: The Flask web server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A web server is usually structured as a series of handlers bound to different
    URLs. Such binding is commonly called *routing*. The goal of Flask, among the
    others, is to obviate this binding and make it easy to add new routes to a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest, one-page Flask server (let''s name it `server.py`) goes like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In Flask, routing is designated with decorators such as `@app.route('/')`, which
    is perfect when you only have a small number of distinct URLs.
  prefs: []
  type: TYPE_NORMAL
- en: The `'/'` route is the server root; this is the default when you type a domain
    name into address bar. To open the trivial website we just wrote in your browser,
    just go to http://127.0.0.1:7080 on the same machine (don't forget to start the
    server first). When you do that, a **Hello, Flask** message should appear, confirming
    that our toy HTTP server works.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Flask web server](img/B01620_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A minimalistic website powered by Flask
  prefs: []
  type: TYPE_NORMAL
- en: Those not familiar with web servers may wonder about the strange argument to
    `app.run()`, the **0.0.0.0** IP address. That's not a valid IP address that you
    can connect to, as it doesn't designate a network interface by itself (it is non-routable).
    In the context of a server, binding to this IP usually means that we want our
    app to listen on all IPv4 network interfaces—that is, respond to requests from
    all the available IP addresses that the machine has.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is different from the default, localhost (or 127.0.0.1) setting: listening
    exclusively on the localhost IP allows connections from the same machine alone,
    therefore, this mode of operation can be helpful for debugging or testing. In
    this example, however, we use a more production-oriented setting, 0.0.0.0—this
    makes the machine accessible from the outside world (typically, the local area
    network). Note that this doesn''t automatically bypass the router; it should work
    for your LAN, but may need additional configuration to be accessible globally.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, don't forget to allow the server through the firewall, as it takes precedence
    over application-level settings.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Choice of port**'
  prefs: []
  type: TYPE_NORMAL
- en: The port number by itself doesn't make much sense; what matters is that you
    use the same number in both server and client, be it a web browser or a Kivy app.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that on almost all systems, ports below 1024 can only be opened by
    a privileged user account (root or Administrator). Many ports in that range are
    already assigned to existing services anyway, so it's not advised to pick port
    numbers under 1024 for the specific needs of your application.
  prefs: []
  type: TYPE_NORMAL
- en: The default port for the HTTP protocol is 80, for example, [http://www.w3.org/](http://www.w3.org/)
    is the same as [http://www.w3.org:80/](http://www.w3.org:80/), and usually you
    don't need to specify it.
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that web development in Python is very easy—a Python script
    just a couple of lines long can get you up and running with a dynamic web server.
    Expectedly, not everything is this simple; some things aren't immediately available
    in the form of reusable library.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be viewed as a competitive advantage, by the way: if you''re struggling
    with implementation of a non-trivial bit of functionality, chances are that not
    many instances of this thing exist, if at all, which makes your product more unique
    and competitive in the end.'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced server functionality – taking screenshots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have decided on a protocol and a server-side toolkit, our next challenges
    involve taking screenshots and simulating clicks that come from the client. Just
    a quick reminder: in this section, we will be covering only a Windows-specific
    implementation; adding Mac and Linux support is left as an exercise for the reader.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the PIL has just the function we need; by calling `PIL.ImageGrab.grab()`,
    we get a screenshot of our Windows desktop as an RGB bitmap. All that's left is
    hooking it up to Flask so that the screenshot is properly served over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: We will use a fork of an old and basically unmaintained PIL module called **Pillow**.
    By the way, Pillow is a great open source project used by many developers; if
    you're looking to contribute to Python userland, look no further. A good starting
    point will be the official Pillow documentation at [http://pillow.readthedocs.org/](http://pillow.readthedocs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the library exactly like you installed Flask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Pillow comes with binaries for Windows pre-packaged, so you don't need a compiler
    or a Visual Studio installed on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''re good to go. The following code demonstrates how to serve screenshots
    (or any other PIL bitmaps for that matter) from a Flask server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you're not familiar with `StringIO`, it's a file-like object that is stored
    in memory and not written to disk. Such "virtual files" are useful when we need
    to use an API that expects a file object on a vanity data. In this example, we
    don't want to store a screenshot, which is temporary and not reusable by definition,
    in a physical file. The sheer overhead of continuously dumping data on disk isn't
    justified; it's usually much better (and way faster) to allocate a chunk of memory
    and immediately free it when the response is sent.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code should be self-evident. We're getting a `screen` picture
    from a `PIL.ImageGrab.grab()` call, saving it using `screen.save()` to a lossy,
    low-quality JPEG file to save bandwidth, and finally sending the image to user
    with the MIME type of `'image/jpeg'`, so that it will be immediately recognized
    by web browsers as a picture of the correct type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this situation, as in many others, low quality is actually a desirable property
    of the system; we're optimizing for throughput and round-trip speed, not for visual
    quality of each individual frame in a series.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same goes for the connotation of low-quality code: it''s actually great
    to be able to produce a quick and dirty prototype sometimes, for example, when
    fiddling with a new concept or doing market research.'
  prefs: []
  type: TYPE_NORMAL
- en: Though it seems strange at first, the `buf.seek(0)` call is needed to *rewind*
    the `StringIO` instance; otherwise, it's at the end of the data stream and won't
    yield anything to `send_file()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can test the server implementation that we have so far by pointing
    your browser of choice at `http://127.0.0.1:7080/desktop.jpeg` and taking a peek
    on the Windows desktop of the machine where the `server.py` script is running.
    If the code works correctly, it should produce a picture as displayed in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advanced server functionality – taking screenshots](img/B01620_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Windows desktop, as seen by the Flask server (fragment)
  prefs: []
  type: TYPE_NORMAL
- en: An interesting part here is the route, **"desktop.jpeg"**. Naming URLs after
    files became somewhat customary because ancient web server tools like **Personal
    Home Page** (**PHP**), a toy programming language suitable for building simple
    dynamic sites, operated on physical files. This means that there was basically
    no concept of routing—you could just enter the name of the script in an address
    bar to run it on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this created gaping chasms in the web server security, including
    (but not limited to) remotely viewing system configuration files by entering,
    for example, `'/../../etc/passwd'` in place of a URL, and being able to upload
    and run malicious scripts serving as Trojans (backdoors) that are used to eventually
    seize control of the server.
  prefs: []
  type: TYPE_NORMAL
- en: Python web frameworks have mostly learned this lesson. While you can try and
    replicate such an insecure setup using Python, it is both non-trivial to do and
    strongly discouraged. Additionally, Python libraries usually don't come bundled
    with bad PHP-style configurations by default.
  prefs: []
  type: TYPE_NORMAL
- en: Today, serving actual files directly from the filesystem isn't unheard of, but
    is used mostly for static files. Still, we sometimes name dynamic routes as if
    they were files (`/index.html`, `/desktop.jpeg`, and so on) to convey the semantics
    of what kind of content users should expect from such URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Emulating clicks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the screenshots part finished, the last non-trivial bit of functionality
    that we need to implement on the server is click emulation. For this we won't
    use an external library; we'll employ WinAPI (the underlying programming interface
    that powers, directly or indirectly, all Windows apps) instead, using the built-in
    Python `ctypes` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first we need to get the click coordinates from the URL. Let''s use regular
    `GET` parameters that look like this: `/click?x=100&y=200`. This should be trivial
    to manually test in a browser, as opposed to POST and other HTTP methods that
    may require additional software to emulate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A parser for simple URL arguments is built into Flask, and they can be accessed
    as shown in the next code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Error handling here, of all places, is recommended when prototyping, because
    it's very easy to forget or send malformed parameters, so we're checking for just
    that— the (in)ability to get numbers from `GET` request args. Responding with
    an obvious error message also helps debugging when (or if) you see this message,
    as it's completely obvious what's going on and where to look for the problem—in
    the code that passed arguments to `/click`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have the coordinates for a click, an invocation of WinAPI is in order.
    We need two functions, both residing in `user32.dll`: the `SetCursorPos()` that
    moves the mouse pointer, and the `mouse_event()` that simulates a number of mouse-related
    events, for example, the mouse button being pressed or released.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By the way, the `32` part in `user32.dll` isn't related to your system being
    32- or 64-bit. The Win32 API first appeared in Windows NT, it predates the AMD64
    (x86_64) architecture by at least 7 years and is called Win32 as opposed to an
    older, 16-bit WinAPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first argument to `mouse_event()` is an event type, which is a C enum (in
    other words, a set of integer constants). Let''s define these constants in our
    Python code for the sake of readability, as using literal `2` for **mouse down**
    and `4` for **mouse up** isn''t very readable. This amounts to the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the full reference on WinAPI functions and constants, please visit the
    **Microsoft Developer Network** (**MSDN**) site, or more specifically the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetCursorPos()`: [http://msdn.microsoft.com/en-us/library/windows/desktop/ms648394%28v=vs.85%29.aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/ms648394%28v=vs.85%29.aspx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mouse_event()`: [http://msdn.microsoft.com/en-us/library/windows/desktop/ms646260%28v=vs.85%29.aspx](http://msdn.microsoft.com/en-us/library/windows/desktop/ms646260%28v=vs.85%29.aspx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It isn't feasible to reproduce this content here due to its size, and we won't
    use most of the available functionality anyway; WinAPI is all-encompassing and
    does more or less everything, usually in more than one way.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the fun part: we get to actually emulate clicks. (The first part of
    the function, where `x` and `y` are fetched from `GET` parameters, is unchanged.)
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This does just what it says if you try reading the code aloud: the function
    moves the mouse to the desired position and then simulates the left mouse button
    click (with button press and release being two separate actions).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should be able to manually control the mouse cursor on the host machine.
    Try visiting a URL such as `http://127.0.0.1:7080/click?x=10&y=10` and make sure
    there is something in the top-left corner of the screen. You'll notice how that
    item gets selected.
  prefs: []
  type: TYPE_NORMAL
- en: You can even perform a double-click if you refresh the page sufficiently fast.
    This may require that you run the browser on another machine; don't forget to
    substitute the real host IP instead of `127.0.0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will briefly cover the development of a JavaScript remote
    desktop client mockup, which is feasible mostly because we use the HTTP protocol.
    This uncomplicated client will run in the browser and serve as a prototype of
    the Kivy remote desktop application that we're going to build next.
  prefs: []
  type: TYPE_NORMAL
- en: If you aren't familiar with JavaScript, don't worry; the language is very easy
    to get into and may even look similar to Python, depending on code style. We are
    also going to use **jQuery** for heavy lifting, such as DOM operations and AJAX
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a production setting, jQuery usage may be frowned upon (and rightfully so),
    especially when aiming for a lean, high-performance codebase. However, for quick
    prototyping or vanity web apps, jQuery shines because it facilitates writing functioning,
    albeit suboptimal, code very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a web app, we need to serve a complete HTML page instead of just **Hello,
    Flask**. To do this, let''s create the `index.html` file that resides in a folder
    named `static`, where Flask expects to find it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding listing is a very basic HTML5 document. It does nothing special
    at the moment: jQuery is loaded from the official CDN, but that''s it—no moving
    parts yet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To serve this new file from Flask, replace the `index()` function in `server.py`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This works just like the `desktop()` function earlier, but reads a real file
    from disk this time.
  prefs: []
  type: TYPE_NORMAL
- en: Endless loop of screenshots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start off, let''s display a continuous screencast: our script is going to
    request a new screenshot every two seconds, and then show it to the user immediately.
    Since we''re writing a web app, all complex stuff is actually handled by the browser:
    an `<img>` tag loads an image and displays it on the screen, with very little
    effort on our part.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the algorithm for this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the old `<img>` tag (if any)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new `<img>` tag
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat after 2 seconds
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In JavaScript, this can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two things here that may need some additional insight:'
  prefs: []
  type: TYPE_NORMAL
- en: The `$()` jQuery function selects elements on the page so that we can perform
    various operations on them, such as `.remove()` or `.insert()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date.now()` returns the current timestamp, namely, the number of milliseconds
    since January 1, 1970\. We use this number to prevent caching. It will be different
    on every invocation; so when appended to the (otherwise constant) `/desktop.jpeg`
    URL, timestamp will make it unique, as far as the web browser is concerned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s also downscale the image so that it doesn''t exceed our browser window''s
    width and remove any margins. This is also very simple to achieve; just add this
    small stylesheet in the `<head>` section of the HTML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Try resizing the browser window and notice how the image shrinks to fit.
  prefs: []
  type: TYPE_NORMAL
- en: '![Endless loop of screenshots](img/B01620_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Remote desktop viewed in the browser, scaled to the size of the browser window
  prefs: []
  type: TYPE_NORMAL
- en: You may also notice that the image flickers when reloading. This happens because
    we show `desktop.jpeg` to the user immediately, before it is fully loaded. Even
    more problematic than visual glitches is the fixed time frame for download, which
    we arbitrarily chose to be two seconds. In the case of slow network connections,
    users won't be able to complete the download and see the whole picture of their
    desktop.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to address these problems in the Kivy implementation of the remote
    desktop client.
  prefs: []
  type: TYPE_NORMAL
- en: Passing clicks to host
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the more interesting part: we are going to capture clicks on the `<img>`
    element and pass them to the server. This is achieved using `.bind()` on (counterintuitively)
    the `<body>` element. This is because we''re constantly adding and removing the
    image, so any events that are bound to an image instance will be lost after the
    next refresh (and constantly rebinding them is just unnecessarily repetitive and
    wrong). The code listing is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we''re calculating the "real" click coordinates first: the image
    may be shrunk to fit browser width, so we compute the ratio and multiply click
    position by that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing clicks to host](img/7849OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `0|expression` syntax in JavaScript is a superior alternative to `Math.floor()`,
    as it is both faster and more concise. There are minor semantic differences too,
    but they aren't important at this point (if at all).
  prefs: []
  type: TYPE_NORMAL
- en: Now, utilizing the jQuery `$.get()` helper function, we send the result of the
    previous computation to the server. There is no processing of the server's response,
    since we're going to display a new screenshot in a moment anyway—if there was
    any effect to our last action, it will be reflected visually.
  prefs: []
  type: TYPE_NORMAL
- en: Using this trivial remote desktop client, we're already able to view the screen
    of the remote host, launch and control programs running on that machine. Now,
    let's re-implement this prototype in Kivy while improving it along the way, in
    particular, making it more suitable for use on mobile devices, adding scrolling
    and removing flicker.
  prefs: []
  type: TYPE_NORMAL
- en: Kivy Remote Desktop app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to build a fully functional remote desktop client using Kivy. There
    are several things that we can reuse from the previous app, the Chat app from
    [Chapter 4](ch04.html "Chapter 4. Kivy Networking"), *Kivy Networking*. Conceptually,
    these apps are quite similar: they consist of two screens each, with one screen
    resembling a login form with server IP address. Let''s capitalize on this similarity
    and reuse parts of the `chat.kv` file in our brand new `remotedesktop.kv`, in
    particular, the `ScreenManager` setup that is practically unchanged.'
  prefs: []
  type: TYPE_NORMAL
- en: The login form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following listing defines the login form. It is composed of three elements—field
    caption, input field itself, and a login button—positioned in a row at the top
    of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There is just one input field this time, **Server IP**. In fact, you can also
    enter the hostname if it's resolvable from the given machine, but let's stick
    to this naming as it is less ambiguous. A LAN may not have a DNS server, or it
    may be configured in a way that does not match users' expectations about hostnames.
  prefs: []
  type: TYPE_NORMAL
- en: '![The login form](img/B01620_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The simple and unambiguous login form
  prefs: []
  type: TYPE_NORMAL
- en: It's not that IP addresses are very user-friendly, but we don't have many options
    here—building an autodiscovery network service to avoid this, while very much
    desirable in real-world scenarios, can also be very convoluted (and probably deserves
    its own book anyway due to the sheer number of available techniques and possible
    caveats).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You need to understand basic networking in order to address machines in complex
    scenarios such as connecting to a machine sitting behind router. As mentioned
    earlier, this is pretty much out of the scope of this work, but here are some
    quick tips:'
  prefs: []
  type: TYPE_NORMAL
- en: It's considerably easier to test network apps when all of your machines are
    sitting in the same network (are connected to the same router, from the same side
    of the router topologically).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking the previous point to the extreme means running every test box inside
    a VM on the same physical machine. This way, you can emulate any network topology
    you want, without the hassle of rearranging physical wires every time you want
    to tweak something.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To see every IP address assigned to every network interface of a computer, run
    `ifconfig` (on a Mac or Linux machine) or `ipconfig` (Windows). Usually, your
    external (Internet) IP is not among those displayed in the output, but your local
    (LAN) network address is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There isn't much else to say about the login screen, as it consists entirely
    of building blocks that we've already discussed during the course of this book.
    Let's move on to the second screen, and ultimately to the source code powering
    the client-server engine.
  prefs: []
  type: TYPE_NORMAL
- en: The remote desktop screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the second and last screen in our application, the remote desktop screen.
    It will be scrollable in two dimensions, given a big enough screen size on the
    host machine. Since full HD (1080p and more) resolutions aren't uncommon in today's
    mobile devices, let alone desktop computers, it may so happen that we won't need
    any scrolling at all.
  prefs: []
  type: TYPE_NORMAL
- en: We can build a scrolling layout based on a similar principle as the chatroom
    pane from the Chat app that we've built in [Chapter 4](ch04.html "Chapter 4. Kivy
    Networking"), *Kivy Networking*. As said earlier, the scrolling will be two-dimensional;
    an additional difference is that we don't want any overscroll (bounce back) effects
    this time to avoid unnecessary confusion. We are presenting a (remote) desktop
    to the user, and the operating system's desktop usually doesn't have this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `remotedesktop.kv` code behind this screen is actually very concise. Let''s
    examine how different parts of it contribute to the task at hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To make scrolling work, we combine `ScrollView` with `Image`, which may become
    larger than the available screen space.
  prefs: []
  type: TYPE_NORMAL
- en: 'On `ScrollView`, we set `effect_cls: ScrollEffect` to disable overscroll; if
    you would like to leave the overscroll behavior intact, just remove this line.
    Since the `ScrollEffect` name isn''t imported by default, we''ll have to import
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Setting the `size_hint` property of `Image` to `(None, None)` is crucial; otherwise,
    Kivy will scale the image to fit, which isn't desirable in this case. The `size_hint`
    property set to `None` means *let me set the size manually*.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we do just that, binding the `size` property to `self.texture_size`. With
    this setting, the image will be of the same size as a `desktop.jpeg` texture provided
    by the server (it depends on the host machine's physical desktop size, obviously,
    so we cannot hard-code it).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also the `nocache: True` property that instructs Kivy to never cache
    the desktop image that is temporary by definition.'
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, an interesting property of `Image` is its `on_touch_down`
    handler. This time, we want to pass the exact coordinates and other properties
    of the touch event, and that's exactly what `args[1]` means. In case you're wondering,
    `args[0]` is the widget being clicked; in this case that's the image itself (we
    have just one `Image` instance, so there's no need to pass it to the event handler).
  prefs: []
  type: TYPE_NORMAL
- en: Loop of screenshots in Kivy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we're going to assemble everything together in Python. As opposed to the
    JavaScript implementation, we don't get the image loading and related functionality
    entirely for free, so there will be a bit more code; still, it's pretty easy to
    implement these, while maintaining better control over the whole process, as you
    will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to load images asynchronously, we''re going to use the Kivy built-in
    class called `Loader`, from the `kivy.loader` module. The program flow will go
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: When a user clicks or taps on **Connect** on the login screen after filling
    the **Server IP** field, the `RemoteDesktopApp.connect()` function is invoked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It passes control to `reload_desktop()`, the function that starts the image
    download from the `/desktop.jpeg` endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the image is loaded, `Loader` invokes `desktop_loaded()`, which puts the
    image on the screen and schedules the next call of `reload_desktop()`. Thus, we
    get an asynchronous endless loop retrieving screenshots from the host system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The image is put on the screen *after* it was successfully loaded, so there
    will be no flickering this time like there was in the JavaScript prototype. (It's
    solvable in JS too, certainly, but that's not the goal of this write-up.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the aforementioned functions in `main.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We save `url` (the full location of `/desktop.jpeg` together with the server
    IP) and `send_url` (the location of `/click` endpoint to pass clicks to host),
    and then pass the execution to the `RemoteDesktopApp.reload_desktop()` function,
    which is also very brief:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding function, we start downloading the image. When it's complete,
    the freshly loaded image will be passed on to `RemoteDesktopApp.desktop_loaded()`.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to disable the default aggressive caching by passing the `nocache=True`
    argument. Omitting this step will result in the `desktop.jpeg` image loading only
    once, because its URL stays the same. In JavaScript, we solved the same problem
    by appending `?timestamp` to the URL to make it unique, and we could certainly
    mimic such behavior in Python, but that's a hack. Kivy's way of specifying `nocache`
    is cleaner and more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can observe the culmination of the image downloading procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This function receives the new image, `desktop`. Then, we proceed to replace
    the texture on screen with the freshly loaded one and schedule the next iteration
    of the screenshot loop to occur in a second.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Clock` object was discussed briefly in our first project ([Chapter 1](ch01.html
    "Chapter 1. Building a Clock App"), *Building a Clock App*). There, we used it
    to perform periodical actions by calling `schedule_interval()`, similar to `setInterval()`
    in JavaScript; in this case, we want a one-time invocation, `schedule_once()`,
    along the lines of `setTimeout()` in JS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to switch screens from login to the remote desktop screen.
    The following screenshot summarizes what we have so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loop of screenshots in Kivy](img/B01620_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A read-only (still unable to pass clicks back to host) Remote Desktop app
  prefs: []
  type: TYPE_NORMAL
- en: Sending clicks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The remote desktop viewer is ready and features scrolling and instant transition
    between frames (no flickering whatsoever). There is one last thing left to implement:
    sending clicks to host. For this, we will listen to the `on_touch_down` event
    on the image and pass the coordinates of touches to an event handler function,
    `send_click()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where it happens in `remotedesktop.kv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To put it in context, here is the Python counterpart in `class RemoteDesktopApp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We gather the click coordinates and feed them to the server via HTTP `GET` request
    using the network-related functions from the Python's standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'One major caveat here is the coordinate system: in Kivy, the *y* axis is upwards,
    while it''s usually downwards in Windows and elsewhere (for example, in browsers).
    To fix this, we subtract `event.y` from the desktop height.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another slightly less problematic aspect is the use of Python''s standard library
    across different Python versions: the `urllib[2]` module''s structure was changed
    significantly in transition from Python 2 to Python 3.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To account for these changes, we can use the following way of doing imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: While not strikingly beautiful, this approach should help you with the Python
    upgrade, should you attempt it. (Targeting a fixed version of Python is also perfectly
    acceptable, by the way. In fact, many companies do just that at the time of this
    writing, including the very employer of Guido van Rossum, creator of the Python
    programming language.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, the Python standard library is perfectly fine; however, if at
    any time you find yourself writing repetitive, boring, and unimaginative HTTP-related
    code, consider using an excellent **Requests** library by Kenneth Reitz instead.
    Visit [http://python-requests.org/](http://python-requests.org/) for more information
    and examples. It's pretty amazing how concise and to the point its syntax is.
    Wholeheartedly recommended, this library is a work of art.
  prefs: []
  type: TYPE_NORMAL
- en: What's next
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, you have a Remote Desktop app that mostly works as intended, especially
    over LAN or a fast Internet connection. As usual, there are many additional problems
    to solve and a lot of new features to implement if you''re interested and willing
    to tackle with this topic some more:'
  prefs: []
  type: TYPE_NORMAL
- en: Send mouse movement as a separate event. This may also apply to double clicks,
    drag and drop, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to account for network latency. If the user is on a slow connection, you
    can turn image quality further down on the server to compensate. Providing the
    user with a visual clue that something is happening in the background also helps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the server cross-platform so that it runs on a Mac, Linux, and maybe even
    Android and Chrome OS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, remember that this is an industry-strong task. It is objectively hard
    to build such software, let alone make it flawless and blazing fast. Kivy helps
    a great deal on the UI side of things, facilitates image downloading and caching,
    but that's it.
  prefs: []
  type: TYPE_NORMAL
- en: So, don't worry if something doesn't work immediately as you implement it—trial
    and error is not at all uncommon in this case. At times, you just need to keep
    putting one foot in front of the other.
  prefs: []
  type: TYPE_NORMAL
- en: There is much to learn in the field of networking, and engineers knowledgeable
    in this field are few and valued highly, so it certainly pays off to dig into
    the topic of computers communicating with other computers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This constitutes the Remote Desktop app walkthrough. The resulting application
    can be actually used for simple tasks, for example, occasionally clicking on the
    **Play** button in iTunes or closing a program. More demanding interactions, in
    particular administrative tasks, may require much more complex software.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also built a Flask-powered web server capable of dynamically producing images
    and interacting with the host system. On top of it, we launched a "light" JavaScript
    version of the app featuring pretty much the same functionality. The morale of
    this story is that our Kivy app does not exist in isolation. Far from it, in fact:
    we''ve actually had a server together with the working prototype of a client app—all
    before writing even a single line of Kivy-related code.'
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, it helps immensely to build your software in such an order
    so that you can test every part of it immediately. I'm not talking about **test-driven
    development** (**TDD**) here, as it's arguable whether full-fledged, exclusively
    test-driven programming helps the cause or not. But even just being able to fiddle
    with each piece of functionality as it comes together is infinitely more productive
    than writing a huge pile of code up front.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Kivy is well-equipped when it comes to networked GUI apps. For example,
    the Twisted integration that we used in the previous chapter, and the support
    for loading textures over the network—these things help immensely to build multi-user,
    Internet apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s jump to another topic altogether: Kivy game development.'
  prefs: []
  type: TYPE_NORMAL
