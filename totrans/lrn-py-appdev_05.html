<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Unit Testing and Refactoring"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Unit Testing and Refactoring</h1></div></div></div><p>Here is a quick recap of what you have learned so far. You developed a command-line application using the OOP approach, and then learned techniques to make your code robust by handling exceptions. You modularized the code, prepared a distribution, and released it to a broader audience. Finally, you learned about coding standards and documentation.</p><p>So far, we have not paid much attention to testing the application. We relied solely on manual testing, where some features were tested by playing the game. The task of manual testing becomes increasingly difficult with the complexity of the application. Soon you will be overwhelmed, and the bugs will start to creep in. While manual testing may not be avoided completely, we need an automated way to make sure the features work as expected. In this chapter, you will do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn about unittest, the unit testing framework in Python</li><li class="listitem" style="list-style-type: disc">Write some unit tests for our application</li><li class="listitem" style="list-style-type: disc">See how to use the mock library in unit tests</li><li class="listitem" style="list-style-type: disc">Learn how to measure the effectiveness of unit tests (code coverage)</li><li class="listitem" style="list-style-type: disc">Understand what is code refactoring, why, when, and how to do it</li><li class="listitem" style="list-style-type: disc">Come back to the unit testing discussion after doing some code refactoring</li></ul></div><div class="section" title="This is how the chapter is organized"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>This is how the chapter is organized</h1></div></div></div><p>The chapter starts with a game scenario, where a bug slips through to production and stays hidden until a user discovers it. This scenario underlines the need for automated testing, and then leads into a discussion on unit testing framework in Python. You will be introduced to the unittest framework and the mock library in Python. The chapter will demonstrate the use of these libraries by writing a few unit tests for our project.</p><p>Moving ahead, it shows an example where it is difficult to write a unit test without refactoring the code first (see <span class="emphasis"><em>Refactoring preamble</em></span>). This is where we take a detour, learn the basics of refactoring, refactor the code, and then develop the last unit test.</p><div class="section" title="Important housekeeping notes"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Important housekeeping notes</h2></div></div></div><p>These notes will be useful in case you haven't read the earlier chapters. Otherwise, just move on to the next heading. Like every other chapter, this one has its own set of Python source files. The source code can be downloaded from the <span class="emphasis"><em>Packt Publishing</em></span> website. Just follow the instructions mentioned in this book's <span class="emphasis"><em>Preface</em></span>.</p><p>This is the last chapter that depends on the code developed in the earlier chapters. Starting with <a class="link" href="ch06.html" title="Chapter 6. Design Patterns">Chapter 6</a>, <span class="emphasis"><em>Design Patterns</em></span>, we will have independent, simplified examples to demonstrate various concepts. That said, everything will be tied back to the same high fantasy theme.</p></div></div></div>
<div class="section" title="Why test?"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Why test?</h1></div></div></div><p>Did you play the game developed so far? If not, just try playing it once. During the combat with the enemy, the following can be observed. For each attack, either Sir Foo or the enemy sustains injuries. This is indicated by the reduced hit points. For example, in the sample game output shown next, <code class="literal">Sir Foo</code> gets hit in the first attack turn, whereas the enemy is injured in the next two attack turns.</p><div class="mediaobject"><img src="graphics/B05034_05_01.jpg" alt="Why test?"/></div><div class="section" title="A new feature was requested"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec73"/>A new feature was requested</h2></div></div></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>A user requested an enhancement to the combat scenario:</em></span>
</p>
<p>
<span class="emphasis"><em>"During combat, the program asks whether you want to continue attacking the enemy. In each attack move, one of the warriors, the player or the enemy, gets injured. Can you make it more interesting? What if both the warriors escape unhurt sometimes?"</em></span>
</p>
</td></tr></tbody></table></div><div class="mediaobject"><img src="graphics/B05034_05_02.jpg" alt="A new feature was requested"/></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>It will benefit you as well Sir Foo! We will go ahead and implement this minor enhancement. Despite Sir Foo's stiff opposition, you rushed to implement this new feature.</em></span>
</p>
</td></tr></tbody></table></div></div><div class="section" title="You implemented this feature"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec74"/>You implemented this feature</h2></div></div></div><p>Recall that the <code class="literal">gameutils.weighted_random_selection</code> function randomly selects an element from <code class="literal">weighted_list</code>. The list is populated such that, for approximately 30% of the time, the unique identifier of <code class="literal">obj1</code> gets selected, and for the rest of the time, the unique identifier representing <code class="literal">obj2</code> gets chosen. Put another way, the chance of Sir Foo (<code class="literal">obj1</code>) getting injured is approximately 30%, and that of the enemy (<code class="literal">obj2</code>) is nearly 70%.</p><p>To add the likelihood that no one gets hurt, you changed the composition of <code class="literal">weighted_list</code> by adding a new element, <code class="literal">None</code>. The new chances of injury to the warriors are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The chances of the enemy (<code class="literal">obj2</code>) getting hurt are ~ 60%</li><li class="listitem" style="list-style-type: disc">The chances of Sir Foo (<code class="literal">obj1</code>) getting hurt are ~30%</li><li class="listitem" style="list-style-type: disc">Both escaping unhurt (<code class="literal">None</code>) are ~ 10%</li></ul></div><p>The following is the <code class="literal">weighted_random_selection</code> function before and after the aforementioned change:</p><div class="mediaobject"><img src="graphics/B05034_05_03.jpg" alt="You implemented this feature"/></div><p>That was easy, wasn't it? You played the game once to make sure nothing is broken. It looked all fine. Without any delay, you released a new version.</p></div><div class="section" title="But something wasn't right..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec75"/>But something wasn't right...</h2></div></div></div><p>However, soon after release, user complaints started pouring in. This was unexpected. Your commit introduced a new bug!</p><div class="mediaobject"><img src="graphics/B05034_05_04.jpg" alt="But something wasn't right..."/></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>Calm down Sir Foo! You are still in war mode! Relax and take a deep breath. We will address this issue soon.</em></span>
</p>
</td></tr></tbody></table></div><p>So what went wrong? There is no problem with the function you wrote. It is behaving as intended. However, you forgot to make some changes to the code that calls <code class="literal">weighted_random_selection</code>. As a result, the following uncaught exception is seen:</p><div class="mediaobject"><img src="graphics/B05034_05_05.jpg" alt="But something wasn't right..."/></div><p>The error traceback points to the <code class="literal">AbstractGameUnit.attack</code> method. This method calls the <code class="literal">weighted_random_selection</code> function to randomly select an injured unit. The problem occurs when <code class="literal">injured_unit</code> is <code class="literal">None</code>. The trouble-causing line of code is shown in the following code snippet:</p><div class="mediaobject"><img src="graphics/B05034_05_46.jpg" alt="But something wasn't right..."/></div></div><div class="section" title="It required thorough testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec76"/>It required thorough testing</h2></div></div></div><p>You had done basic testing by running the game once. But then why didn't you notice this problem? The chances that the function returns <code class="literal">None</code> are slim. For example, for every 10 calls to the function <code class="literal">weighted_random_selection</code>, the value <code class="literal">None</code> would be on average returned only once. In this case, the testing you did was not enough to reproduce the problem.</p><p>This is just one of the scenarios where thorough testing is required. At the same time, it is prone to human error because of the random nature of the output. If you had some automated means to test this functionality, the bug could have been easily avoided.</p><p>So let's learn how to create automated tests in Python using the unittest framework. After you know how to write a unit test, we will come back and write a unit test for the <code class="literal">weighted_random_selection</code> function that was discussed here.</p></div></div>
<div class="section" title="Unit testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Unit testing</h1></div></div></div><p>In<a id="id320" class="indexterm"/> unit testing, you tinker with a code fragment within the application. The main task is to verify that this piece of code continues to work as expected throughout the life of the application. This is accomplished by writing a test for that functionality.</p><p>A unit test can be better explained with an example. Consider a trivial function that returns the sum of two numbers. In a unit test, you invoke this function by passing two numbers as arguments, and then verify the value returned by the function is indeed the sum of the given numbers.</p><p>There are many<a id="id321" class="indexterm"/> frameworks available for writing unit tests. The examples in this chapter will be based on the built-in unit testing framework called unittest. See the heading <span class="emphasis"><em>Other unit testing tools</em></span>, which gives a very short overview of alternative unit testing tools and frameworks.</p><div class="section" title="Python unittest framework"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec77"/>Python unittest framework</h2></div></div></div><p>The <code class="literal">unittest</code> module<a id="id322" class="indexterm"/> provides the functionality to automate tests. Before we implement any tests for our application, let's first start with the terminology.</p><div class="section" title="Basic terminology"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec38"/>Basic terminology</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Test case</strong></span>: When<a id="id323" class="indexterm"/> you write a unit test, it is referred to as a test case. <code class="literal">TestCase</code> is the superclass for creating different test cases.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Test suite</strong></span>: When<a id="id324" class="indexterm"/> you group together various test cases, it becomes a test suite. A test suite may also represent a collection of other test suites. <code class="literal">unittest.TestSuite</code> provides a superclass for creating a suite. The <code class="literal">TestSuite</code> does not define any unit tests, but it just accumulates the tests or other test suites. This is a major difference between <code class="literal">TestSuite</code> and <code class="literal">TestCase</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Test fixtures</strong></span>: These<a id="id325" class="indexterm"/> are preparatory methods for the smooth running of the unit tests. For example, <code class="literal">TestCase.setUp</code> is called just before executing a test case. It can be used to feed the required data to the test cases. Similarly, <code class="literal">TestCase.tearDown</code> method is called immediately after the test execution. Such methods could be used in combination, for instance to start and stop a service consumed by a unit test.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Test runner</strong></span>: The<a id="id326" class="indexterm"/> runner helps execute a test case or a test suite. It also provides a way to represent the results after running the tests. For example, the results can be displayed on the command line or in some graphical form. The basic implementation is provided by the <code class="literal">unittest.TextTestRunner</code> class.</li></ul></div></div><div class="section" title="Creating tests with unittest.TestCase"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec39"/>Creating tests with unittest.TestCase</h3></div></div></div><p>To<a id="id327" class="indexterm"/> understand the basics of constructing and <a id="id328" class="indexterm"/>running the tests, let's write a trivial program. Observe the following code:</p><div class="mediaobject"><img src="graphics/B05034_05_06.jpg" alt="Creating tests with unittest.TestCase"/></div><p>As <a id="id329" class="indexterm"/>mentioned earlier, the <code class="literal">setUp</code> and <code class="literal">tearDown</code> methods are <a id="id330" class="indexterm"/>known as fixtures. <code class="literal">MyUnitTests.setUp()</code> is called before executing each test. This allows the initialization of some common variables before the test gets executed. The <code class="literal">MyUnitTests.tearDown()</code> method is called after every test.</p><p>When the <code class="literal">unittest.main()</code> program is invoked, the tests defined in the <code class="literal">MyUnitTests</code> class are run one after the other. This program can also accept a test runner as an optional argument (not used in this example). By default, the program loads and runs only the methods that have names starting with <code class="literal">test</code>. In the <code class="literal">MyUnitTests</code> class, the tests defined in the <code class="literal">test_1</code> and <code class="literal">test_2</code> methods will be executed as shown in the following command-line output:</p><div class="mediaobject"><img src="graphics/B05034_05_07.jpg" alt="Creating tests with unittest.TestCase"/></div><p>Now<a id="id331" class="indexterm"/> that we know how the test cases are executed, let's<a id="id332" class="indexterm"/> review one of the methods, which is as follows:</p><div class="informalexample"><pre class="programlisting">def test_2(self):
    print("in test_2")
    self.assertEqual(1+1, 2)</pre></div><p>The <code class="literal">assertEqual</code> method is a built-in method of the <code class="literal">TestCase</code> class. It essentially checks whether the two input arguments are equal, otherwise an assertion error is raised. The test illustrated in the preceding code fragment will pass. Let's review a test that would fail:</p><div class="informalexample"><pre class="programlisting">def test_2(self):
    print("in test_2")
    self.assertEqual(1+1, 3)</pre></div><p>Obviously, <code class="literal">1+1 != 3</code>, so we would expect the test to fail, as shown in the following command-line output. For a failed test, it also prints the letter <code class="literal">F</code> in the output:</p><div class="mediaobject"><img src="graphics/B05034_05_08.jpg" alt="Creating tests with unittest.TestCase"/></div><p>Similarly, the<a id="id333" class="indexterm"/> <code class="literal">unittest.TestCase</code> class defines a bunch <a id="id334" class="indexterm"/>of convenient methods. For example, the <code class="literal">assertTrue</code> and <code class="literal">assertFalse</code> methods verify a condition. Another method, <code class="literal">assertRaises</code>, is used to check whether a certain exception is raised by the code.</p></div><div class="section" title="Controlling test execution"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec40"/>Controlling test execution</h3></div></div></div><p>Is there a way<a id="id335" class="indexterm"/> to run only selected test cases? One way is to use Python <span class="strong"><strong>decorators</strong></span>
<a id="id336" class="indexterm"/> for the tests you want to ignore. Let's add this decorator to both the test cases from the previous example:</p><div class="mediaobject"><img src="graphics/B05034_05_09.jpg" alt="Controlling test execution"/></div><p>Essentially, none of the test cases would be run. The output, after running the code, indicates that these tests have been skipped. For each skipped test, it prints <code class="literal">s</code> in the output:</p><div class="mediaobject"><img src="graphics/B05034_05_10.jpg" alt="Controlling test execution"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip40"/>Tip</h3><p>There are two more decorators not covered here, namely <code class="literal">skipIf</code> and <code class="literal">skipUnless</code>. These decorators are used for the condition-based skipping of the test. See the following documentation page for details: <a class="ulink" href="https://docs.python.org/3/library/unittest.html">https://docs.python.org/3/library/unittest.html</a>.</p></div></div><p>Sometimes, you <a id="id337" class="indexterm"/>do expect a few test cases to fail. For example, a test may fail due to a difference between a development versus a production environment, or due to the presence or absence of expected database content. Such expected failures can be tagged with another decorator. We know that <code class="literal">test_2</code> fails, so let's add the decorator for this test:</p><div class="mediaobject"><img src="graphics/B05034_05_11.jpg" alt="Controlling test execution"/></div><p>For each anticipated <a id="id338" class="indexterm"/>failure, it prints <code class="literal">x</code> in the output. At the end, it summarizes how many tests were expected to fail:</p><div class="mediaobject"><img src="graphics/B05034_05_12.jpg" alt="Controlling test execution"/></div></div><div class="section" title="Using unittest.TestSuite"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec41"/>Using unittest.TestSuite</h3></div></div></div><p>Refer to the<a id="id339" class="indexterm"/> <code class="literal">testsuitedemo.py</code> file in the supporting code bundle for this chapter. The module contains two classes, namely <code class="literal">MyUnitTestA</code> and <code class="literal">MyUnitTestB</code>. Each of these inherit from <code class="literal">unittest.TestCase</code>, and define some trivial methods as unit tests.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip41"/>Tip</h3><p>In <a class="link" href="ch03.html" title="Chapter 3. Modularize, Package, Deploy!">Chapter 3</a>, <span class="emphasis"><em>Modularize, Package, Deploy!</em></span> we created a separate module for each class. Here, the <code class="literal">testsuitedemo.py</code> module contains two classes. As an exercise, you can put these classes in separate modules.</p></div></div><p>The following code snippets show these classes. For compactness, the code comments are omitted here:</p><div class="mediaobject"><img src="graphics/B05034_05_13.jpg" alt="Using unittest.TestSuite"/></div><p>The <code class="literal">makeSuite</code> function<a id="id340" class="indexterm"/> of the <code class="literal">unittest</code> module can be used to create an instance of <code class="literal">TestSuite</code>:</p><div class="informalexample"><pre class="programlisting">suite_a = unittest.makeSuite(MyUnitTestA)</pre></div><p>The preceding line of code will construct a test suite using all the unit tests defined in the <code class="literal">MyUnitTestA</code> class. Only the method names starting with <code class="literal">test*</code> are added to the test suite. In this example, these methods are <code class="literal">test_a2</code> and <code class="literal">test_a1</code>. The third method, <code class="literal">not_called_by_default</code>, will not be automatically considered as a unit test.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip42"/>Tip</h3><p>Non-test methods (such as <code class="literal">not_called_by_default</code> in this example), are often useful for sharing code between the tests.</p></div></div><p>Let's see how to include such methods in the test suite. The code snippet that follows shows a function <code class="literal">suite()</code> defined in this module:</p><div class="mediaobject"><img src="graphics/B05034_05_14.jpg" alt="Using unittest.TestSuite"/></div><p>Let's review the preceding code snippet:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This function<a id="id341" class="indexterm"/> creates two instances of <code class="literal">TestSuite</code>, namely <code class="literal">suite_a</code> and <code class="literal">suite_b</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">MyUnitTest.not_called_by_default</code> method is added as a test case in the test suite using the <code class="literal">addTest</code> method.</li><li class="listitem" style="list-style-type: disc">The function returns a new <code class="literal">TestSuite</code> object. It takes a Python tuple as an argument. In this example, the tuple includes the two instances of <code class="literal">TestSuite</code> created before.</li></ul></div><p>The last part of this module is the execution code:</p><div class="mediaobject"><img src="graphics/B05034_05_15.jpg" alt="Using unittest.TestSuite"/></div><p>Running the <code class="literal">testsuitedemo.py</code> module produces the following output. Observe that it has also executed the test defined in <code class="literal">MyUnitTestB.not_called_by_default</code>:</p><div class="mediaobject"><img src="graphics/B05034_05_16.jpg" alt="Using unittest.TestSuite"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip43"/>Tip</h3><p>Test suites <a id="id342" class="indexterm"/>are also very convenient for grouping test cases, depending on their runtime. For example, you can group together fast-running tests and slow-running tests, and give the test runner script a command-line option to choose which one to run.</p></div></div></div></div></div>
<div class="section" title="Writing unit tests for the application"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Writing unit tests for the application</h1></div></div></div><p>It is time<a id="id343" class="indexterm"/> to write some unit tests for the application. We will make a new subclass of <code class="literal">unittest.TestCase</code> to hold all the unit tests.</p><div class="section" title="Setting up a test package"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec78"/>Setting up a test package</h2></div></div></div><p>As a first step, let's<a id="id344" class="indexterm"/> create a new package for holding the test cases. Create a new directory called <code class="literal">test</code> at the same level where you have the rest of the code. Next, create two new files inside this <code class="literal">test</code> directory, as shown here:</p><div class="mediaobject"><img src="graphics/B05034_05_47_testdir_structure.jpg" alt="Setting up a test package"/></div><p>The <code class="literal">test_wargame.py</code> <a id="id345" class="indexterm"/>module is where new unit tests will be created. To recognize the directory as a Python package, add an empty <code class="literal">__init__.py</code> file.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip44"/>Tip</h3><p>If you haven't already, read <a class="link" href="ch03.html" title="Chapter 3. Modularize, Package, Deploy!">Chapter 3</a>, <span class="emphasis"><em>Modularize, Package, Deploy!</em></span> for details on creating a Python package.</p></div></div></div><div class="section" title="Creating a new class for unit testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec79"/>Creating a new class for unit testing</h2></div></div></div><p>The <code class="literal">test_wargame.py</code> file can also be found in the supporting code. It has all the code to be<a id="id346" class="indexterm"/> discussed next. In the following discussion, it is <a id="id347" class="indexterm"/>assumed that you will code from scratch to an empty file.</p><p>Create a new subclass of <code class="literal">unittest.TestCase</code>, and call it <code class="literal">TestWarGame</code> or any name you like. The class is shown here:</p><div class="mediaobject"><img src="graphics/B05034_05_17.jpg" alt="Creating a new class for unit testing"/></div><p>We start by<a id="id348" class="indexterm"/> making the necessary imports. Recall that the<a id="id349" class="indexterm"/> <code class="literal">setUp()</code> fixture is called immediately before running the unit tests. Inside <code class="literal">setUp</code>, instances of the <code class="literal">Knight</code> and <code class="literal">OrcRider</code> classes are created, and are then used in the unit test we are about to write: <code class="literal">test_injured_unit_selection</code>. As seen before, the call to <code class="literal">unittest.main()</code> will automatically execute methods whose names start with <code class="literal">test</code>. In this example, it will run <code class="literal">test_injured_unit_selection()</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip45"/>Tip</h3><p>You can write the same code without using fixtures as well. Simply create the required instances inside the test you are writing. As you will see next, the <code class="literal">test_injured_unit_selection()</code> unit test uses the objects created in <code class="literal">setUp()</code>. Alternatively, you can create those instances locally, inside the test, like so:</p><div class="informalexample"><pre class="programlisting">def test_injured_unit_selection(self): 
    knight = Knight() 
    enemy = OrcRider() 
    # rest of the test code...</pre></div></div></div></div><div class="section" title="First unit test – Injured unit selection"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec80"/>First unit test – Injured unit selection</h2></div></div></div><p>Let's go back to <a id="id350" class="indexterm"/>the scenario we discussed under the section <span class="emphasis"><em>Why test?</em></span> Recall that you changed the behavior of the <code class="literal">weighted_random_selection</code> function so that it can also return <code class="literal">None</code> (nobody injured). This new feature broke the program, and the application terminated because of an uncaught exception.</p><p>The test we are about to write will verify the original behavior of this function. The original behavior was to select either Sir Foo (the <code class="literal">Knight</code> instance) or the enemy (the <code class="literal">OrcRider</code> instance) as the injured unit. The unit test we are about to write will verify exactly that. Observe the following code:</p><div class="mediaobject"><img src="graphics/B05034_05_18.jpg" alt="First unit test – Injured unit selection"/></div><p>With this preceding function, the chance of <code class="literal">self.enemy</code> getting injured is approximately 70%, and that of <code class="literal">self.knight</code> (Sir Foo) is nearly 30%. The top-level <code class="literal">for</code> loop just ensures it is called <code class="literal">100</code> times to account for the random nature of the function return value. <code class="literal">TestCase.assertInstance()</code> raises an assertion error if <code class="literal">injured_unit</code> is not an instance of <code class="literal">Knight</code> or <code class="literal">OrcRider</code>. Let's run this test now.</p></div><div class="section" title="Running the first unit test"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec81"/>Running the first unit test</h2></div></div></div><p>In a terminal window, run<a id="id351" class="indexterm"/> this test from the top-level <code class="literal">wargame</code> directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd wargame</strong></span>
<span class="strong"><strong>$ python -m unittest test.test_wargame</strong></span>
</pre></div><p>
<code class="literal">-m</code> is a built-in command line option in Python. It allows you to run a library module as a script. In this case, it will run the <code class="literal">unittest</code> module as a script. The argument <code class="literal">test.test_wargame</code> represents the file <code class="literal">test/test_wargame.py</code>. The <code class="literal">unittest</code> script will run the tests defined in this module.</p><p>If the old behavior <a id="id352" class="indexterm"/>of <code class="literal">weighted_random_selection</code> is left unchanged, the test will pass. However, if you implement the new behavior where the function could also return <code class="literal">None</code>, it will fail by raising an <code class="literal">AssertionError</code>, as shown next:</p><div class="mediaobject"><img src="graphics/B05034_05_19.jpg" alt="Running the first unit test"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip46"/>Tip</h3><p>There is no need to run the <code class="literal">for</code> loop <code class="literal">100</code> times. Just make sure to call the function at least 10 times. As an exercise, update the test to verify further details. For example, verify that the function returns the <code class="literal">Knight</code> instance approximately 30% of the time, and so on.</p></div></div></div><div class="section" title="Second unit test – Acquiring the hut"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec82"/>Second unit test – Acquiring the hut</h2></div></div></div><p>Let's pick another functionality for testing. This time, it is a method from the <code class="literal">Hut</code> class:</p><div class="mediaobject"><img src="graphics/B05034_05_20.jpg" alt="Second unit test – Acquiring the hut"/></div><p>In this method, what do you think we can test? The method serves the following purposes: (a) It updates the occupant information, and (b) It sets the <code class="literal">is_acquired</code> flag to <code class="literal">True</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip47"/>Tip</h3><p>
<span class="strong"><strong>Redesign exercise</strong></span>:</p><p>In this application, we assume everything from the context of the player. For example, the <code class="literal">is_acquired</code> flag of the <code class="literal">Hut</code> instance is from the point of view of the player. If it is set to <code class="literal">True</code>, it means the hut is acquired by the player and not the enemy. This is already prone to bugs. Imagine an <code class="literal">OrcRider</code> instance calling this method! You can add assertions to make sure it accepts only the <code class="literal">Knight</code> instance. As an exercise, remove the dependence on the <code class="literal">is_acquired</code> flag from the code.</p></div></div><p>When writing a test, we <a id="id353" class="indexterm"/>will ensure that the new occupant is the same object as the one passed as an argument to the method.</p><div class="mediaobject"><img src="graphics/B05034_05_21.jpg" alt="Second unit test – Acquiring the hut"/></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>Good question Sir Foo. Why write this test if the method is already working fine? Keep in mind the scenario we discussed earlier. An intentional change in the functionality caused us so much trouble. Why wait for such a bug to show up?</em></span>
</p>
<p>
<span class="emphasis"><em>Today, this code is behaving as expected. The unit test is meant for tomorrow. Imagine multiple developers contributing to this application. As a result, more code would get added, and someone may inadvertently introduce code that will break the intended functionality of this method. In such a scenario, how do you ensure that the fundamental behavior remains unchanged? A unit test will notice such changes.</em></span>
</p>
<p>
<span class="emphasis"><em>A future requirement might even change the fundamental behavior of the method. This was illustrated in the scenario under the heading <span class="strong"><strong>Why Test?</strong></span> When that happens, the unit test you wrote would obviously fail. You do expect it to fail now, and that would make it imperative to update the test to match the new requirement.</em></span>
</p>
<p>
<span class="emphasis"><em>In short, a unit test will make sure that accidental changes to the code are captured right away, and don't become your nightmare, such as when someone reports a bug and you learn the hard way that it was caused by a silly mistake in the code you wrote a few months ago.</em></span>
</p>
</td></tr></tbody></table></div><p>Let's write a new <a id="id354" class="indexterm"/>method in the same class, <code class="literal">TestWarGame</code>:</p><div class="mediaobject"><img src="graphics/B05034_05_22.jpg" alt="Second unit test – Acquiring the hut"/></div><p>In the preceding code, we first create an instance of <code class="literal">Hut</code>. In the second line, this hut is acquired by <code class="literal">self.knight</code>. The <code class="literal">TestCase.assertIs</code> checks whether the object representing the hut's occupant is the same as <code class="literal">self.knight</code>, otherwise an <code class="literal">AssertionError</code> is raised.</p><div class="section" title="Running only the second test"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec42"/>Running only the second test</h3></div></div></div><p>If we execute the <a id="id355" class="indexterm"/>following command, it would run all the tests defined in the <code class="literal">test_wargame.py</code> module:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd wargame</strong></span>
<span class="strong"><strong>$ python -m unittest test.test_wargame</strong></span>
</pre></div><p>What if you just want to run <code class="literal">test_acquire_hut</code>? Assuming you are already inside the <code class="literal">wargame</code> directory, here is a command to accomplish this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python -m unittest test.test_wargame.TestWarGame.test_acquire_hut</strong></span>
</pre></div><p>This command-line argument can be read as <code class="literal">package_name.module_name.class_name.method_name</code>.</p><p>The output after running this test is shown here:</p><div class="mediaobject"><img src="graphics/B05034_05_23.jpg" alt="Running only the second test"/></div></div></div><div class="section" title="Creating individual test modules"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec83"/>Creating individual test modules</h2></div></div></div><p>The last unit test<a id="id356" class="indexterm"/> we wrote was meant for testing the functionality in the <code class="literal">Hut</code> class. We created this as a method of the <code class="literal">TestWarGame</code> class in the <code class="literal">test_wargame.py</code> module.</p><p>Do we have to put all the tests for the application inside a single module? No! You can, optionally, create individual test modules for each class.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip48"/>Tip</h3><p>For large applications, it is often convenient to have separate test modules at the class level or the package level. Choose a strategy that best suits your project. If it makes sense, you can also create a test class that clubs together some common functionality in your application.</p></div></div><p>Let's rework the previous example. We will create a new module, <code class="literal">test_hut.py</code>, as a home for a new class, <code class="literal">TestHut</code>. The source code is also available in the supplementary material for this chapter—see <code class="literal">wargame/test/test_hut.py</code>. Next, we will move the <code class="literal">TestWarGame.test_acquire_hut</code> method into this class. This is shown here:</p><div class="mediaobject"><img src="graphics/B05034_05_24.jpg" alt="Creating individual test modules"/></div><p>The syntax to <a id="id357" class="indexterm"/>execute the unit test is similar to the one used before:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd wargame</strong></span>
<span class="strong"><strong>$ python -m unittest test.test_hut</strong></span>
</pre></div></div><div class="section" title="Batch executing unit tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec84"/>Batch executing unit tests</h2></div></div></div><p>If your test directory<a id="id358" class="indexterm"/> contains multiple test modules, how do you run all the<a id="id359" class="indexterm"/> tests at once inside the directory? One option is to write a script listing commands to execute the unit tests one after the other. The <code class="literal">unittest</code> module, however, provides a discover option to batch execute the tests on the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python -m unittest discover</strong></span>
</pre></div><p>The following command-line output shows the batch execution of two test modules inside the <code class="literal">test</code> directory:</p><div class="mediaobject"><img src="graphics/B05034_05_25.jpg" alt="Batch executing unit tests"/></div></div></div>
<div class="section" title="Unit tests using mock library"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Unit tests using mock library</h1></div></div></div><p>The two tests we wrote<a id="id360" class="indexterm"/> earlier were pretty straightforward to implement. Often, it is not trivial to write a test for verifying the functionality. The reasons could vary. In some scenarios, the code is required to be refactored in order to access the functionality you would like to test. In another scenario, the code might have dependencies that require you to write a lot more code than necessary. It is also possible that the functionality to be tested needs time consuming preparatory work such as crunching some numbers. This adds to the total test execution time. We will now learn how to write a unit test in such situations using the mock library. Before working on the actual code, let's understand what functionality this library provides.</p><div class="section" title="Quick introduction to mock"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec85"/>Quick introduction to mock</h2></div></div></div><p>The mock library <a id="id361" class="indexterm"/>provides a flexible way to create dummy objects that can be used to replace some parts in the program that you are testing.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip49"/>Tip</h3><p>Mock is available in the Python standard library ( v3.3 onwards) as <code class="literal">unittest.mock</code>. If you are using a prior distribution, install it using this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pip install mock</strong></span>
</pre></div><p>Visit <a class="ulink" href="https://pypi.python.org/pypi/mock">https://pypi.python.org/pypi/mock</a> for further <a id="id362" class="indexterm"/>information.</p></div></div><p>With a <a id="id363" class="indexterm"/>mock object, you can focus on the main functionality to be tested without worrying much about the things on which this functionality depends. It provides a way to decouple the supporting chunks of code from the functionality being tested. This can be better explained with an example. Refer to the following cartoon:</p><div class="mediaobject"><img src="graphics/B05034_05_26.jpg" alt="Quick introduction to mock"/></div><p>Imagine you are writing a unit test for a function called <code class="literal">compute()</code> that does a lot of scientific computations. Within this function, you are calling other supporting functions that process some data. This is a time-consuming operation. If you know what information is being provided by the supporting functions, you can define their behavior using mock objects.</p></div><div class="section" title="Let's mock!"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec86"/>Let's mock!</h2></div></div></div><p>It's time for some action. Open <a id="id364" class="indexterm"/>your Python interpreter, and start writing the following code. It is assumed that the mock module is already available. If it isn't, install it using pip, as suggested earlier. First, import the <code class="literal">Mock</code> class as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; from unittest.mock import Mock</strong></span>
</pre></div><p>Next, create a <code class="literal">Mock</code> object:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; mockObj = Mock()</strong></span>
</pre></div><p>The object type and its unique ID can be found as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; mockObj </strong></span>
<span class="strong"><strong>&lt;Mock id='140524045365320'&gt; </strong></span>
</pre></div><p>Moving on, type the following code in the Python interpreter:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; mockObj.foo</strong></span>
</pre></div><div class="mediaobject"><img src="graphics/B05034_05_27.jpg" alt="Let's mock!"/></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>Good observation! Apologies for using your name here...that was unintentional. In the developer world, people just love your name! So the question is, would it really give an attribute error? Try it yourself!</em></span>
</p>
</td></tr></tbody></table></div><p>Executing this last line of code will print an output similar to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; mockObj.foo</strong></span>
<span class="strong"><strong>&lt;Mock name='mockObj.foo' id='140524032172664'&gt;</strong></span>
</pre></div><p>This is the interesting <a id="id365" class="indexterm"/>part! It did not complain about the missing attribute; instead, it created a new mock object. You can access any arbitrary attribute of this object as if it was already defined. It will create and return a new <code class="literal">Mock</code> object representing that attribute. Here, <code class="literal">foo</code> is also called a child mock of <code class="literal">mockObj</code>.</p><p>Let's see how to make use of this feature. <code class="literal">Mock.mock_calls</code> can be used to track all the calls of a mock object along with its child mocks. The results are returned as a Python list. Write the following line of code in the Python interpreter:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; mockObj.mock_calls</strong></span>
<span class="strong"><strong>[]</strong></span>
</pre></div><p>Here, it returns an empty Python list, as we have not called the <code class="literal">mockObj</code> or its child mocks.</p><p>Next, let's see how this list gets populated. The <code class="literal">Mock</code> objects are callable. Write the following code to call <code class="literal">mockObj.foo</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; mockObj.foo()</strong></span>
<span class="strong"><strong>&lt;Mock name='mockObj.foo()' id='140524032173280'&gt; </strong></span>
</pre></div><p>We will create and call another new child mock like so:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; mockObj.foo2(return_value = 20) </strong></span>
<span class="strong"><strong>&lt;Mock name='mock.foo2()' id='140271893632056'&gt; </strong></span>
</pre></div><p>Now, let's invoke <code class="literal">mockObj.mock_calls</code> one more time:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; test_call_list = mockObj.mock_calls </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; test_call_list</strong></span>
<span class="strong"><strong>[call.foo(), call.foo2(return_value=20)]</strong></span>
</pre></div><p>The returned list now contains two objects, namely <code class="literal">call.foo()</code> and <code class="literal">call.foo2()</code>. These are the helper objects provided by <code class="literal">unittest.mock.call</code>.</p><p>How do we use this information? When you write a unit test, you can use this list to make assertions on which objects are invoked and in what order. To understand this concept better, we will write a simple unit test in the next section.</p></div><div class="section" title="Using Mock objects in a unit test"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec87"/>Using Mock objects in a unit test</h2></div></div></div><p>Let's write a <a id="id366" class="indexterm"/>unit test for the compute method of a class, <code class="literal">MyClassA</code>. The <a id="id367" class="indexterm"/>class is shown next. You can also download the <code class="literal">wargame/test/mockdemo.py</code> file from the supporting code bundle:</p><div class="mediaobject"><img src="graphics/B05034_05_28.jpg" alt="Using Mock objects in a unit test"/></div><p>This is a trivial<a id="id368" class="indexterm"/> example. The <code class="literal">compute</code> method depends on the <a id="id369" class="indexterm"/>values returned by two methods, <code class="literal">foo</code> and <code class="literal">foo2</code>. It uses these values to compute and return the result. In this example, the methods <code class="literal">foo</code> and <code class="literal">foo2</code> are simple.</p><p>Imagine a scenario where the aforementioned methods perform tasks that take a very long time. Now, to write a unit test that verifies the functionality of the <code class="literal">compute</code> method, you would need to check the final value of <code class="literal">result</code>. Naturally, it would take a long time to finish because of the time spent in <code class="literal">foo</code> and <code class="literal">foo2</code>. If you know the expected outcome of these methods, you can simply replace them with <code class="literal">Mock</code> objects in the test. We can do this because <code class="literal">foo</code> and <code class="literal">foo2</code> are assumed to be the supporting functions, and the main functionality to be tested is the value of result.</p><p>The <code class="literal">Mock</code> objects would behave as if they are the original methods, and return the output you need. But in reality, we bypass the time consuming computations. In this illustration, we already know that <code class="literal">foo</code> is expected to return a value of <code class="literal">100</code>. The return value of the <code class="literal">foo2</code> method depends on the input argument <code class="literal">x</code>. </p><p>Looking at the compute method, we can easily deduce that the return value of <code class="literal">foo2</code> would be <code class="literal">100 + 200 = 300</code>. So let's write a unit test that mocks these method calls. The code is shown here:</p><div class="mediaobject"><img src="graphics/B05034_05_29.jpg" alt="Using Mock objects in a unit test"/></div><p>Let's review the method in the preceding code snippet</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<a id="id370" class="indexterm"/> <code class="literal">a.foo</code> and <code class="literal">a.foo2</code> methods are now<a id="id371" class="indexterm"/> represented by new <code class="literal">Mock</code> objects, <code class="literal">mockObj.foo</code> and <code class="literal">mockObj.foo2</code>, respectively. Inside <code class="literal">a.compute()</code>, the <code class="literal">self.foo()</code> and <code class="literal">self.foo2()</code> calls are now mocked with these new objects.</li><li class="listitem" style="list-style-type: disc">The test verifies the value of the parameter result. This is done by calling <code class="literal">TestCase.assertEqual</code>.</li><li class="listitem" style="list-style-type: disc">The test also verifies which objects are called and the order in which they are called. As seen before, <code class="literal">test_call_list</code> is used to track all the calls to <code class="literal">mockObj</code> and its child mocks. This list is compared with some reference list that stores the expected calling order of the objects. In this example, <code class="literal">reference_call_list</code> stores this information. It expects the <code class="literal">foo</code> and <code class="literal">foo2</code> <a id="id372" class="indexterm"/>methods be called in that order. In future, if someone <a id="id373" class="indexterm"/>tweaks this order in <code class="literal">MyClassA.compute</code>, this test would help catch the change.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>
<span class="strong"><strong>The MagicMock class</strong></span>:</p><p>
<code class="literal">MagicMock</code> is a <a id="id374" class="indexterm"/>subclass of <code class="literal">Mock</code>. It essentially provides all the functionality that you would expect from a <code class="literal">Mock</code> class. Additionally, it provides default implementation for many of the magic methods in Python. A magic method is a special method whose name has double underscores as both prefix and suffix. Some examples of magic methods include <code class="literal">__init__</code> , <code class="literal">__iter__</code>, <code class="literal">__len__</code>, and so on. In the illustrations, you can use <code class="literal">MagicMock</code> instead of the <code class="literal">Mock</code> class. For further details, go to the following page: <a class="ulink" href="https://docs.python.org/3/library/unittest.mock.html">https://docs.python.org/3/library/unittest.mock.html</a>.</p></div></div></li></ul></div></div><div class="section" title="Working with patches"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec88"/>Working with patches</h2></div></div></div><p>Under the previous heading, we <a id="id375" class="indexterm"/>covered some basics of the <code class="literal">Mock</code> class. The mock library provides another important functionality in the form of patch decorators. Patching is a mechanism that allows you to change the behavior of an object temporarily within a test. This is a broad topic. In this book, we will limit our discussion to creating patches using <code class="literal">unittest.mock.patch</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip51"/>Tip</h3><p>Patches can be invoked in four different ways, namely <code class="literal">patch</code>, <code class="literal">patch.object</code> , <code class="literal">patch.dict</code>, and <code class="literal">patch.multiple</code>. For further information, see the documentation at <a class="ulink" href="https://docs.python.org/3/library/unittest.mock.html">https://docs.python.org/3/library/unittest.mock.html</a>.</p></div></div><p>The <code class="literal">patch</code> decorator function takes <code class="literal">target</code> as the required argument, followed by a long list of optional arguments. Only one of the optional arguments (<code class="literal">new</code>) is shown here. Refer to the unittest documentation for information on other optional arguments:</p><div class="informalexample"><pre class="programlisting">patch(target, new=DEFAULT)</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the preceding function, the <code class="literal">target</code> argument is the thing you would like to patch. It can be any function, class method, or an object.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">target</code> is imported, and should be represented by a string, which resembles a typical <code class="literal">import</code> statement (without the keyword <code class="literal">import</code>).</li><li class="listitem" style="list-style-type: disc">For example, if you want to patch a method inside a test case, the <code class="literal">target</code> should be represented like so: <code class="literal">pkg.module.myclass.mymethod</code>.</li><li class="listitem" style="list-style-type: disc">If this method is in the same file where you are creating the patch (for example, the method and its test are in the same Python file), then <code class="literal">target</code> should be written as: <code class="literal">__main__.myclass.mymethod</code>.</li></ul></div><p>Among the<a id="id376" class="indexterm"/> optional arguments, we will only discuss and use <code class="literal">new</code>. The <code class="literal">new</code> argument tells which object would replace the <code class="literal">target</code>. It can be any class or a <code class="literal">Mock</code> object. This can be better understood with an example. See the following line of code:</p><div class="informalexample"><pre class="programlisting">patch('__main__.MyClassA.foo', new=Mock(return_value=500))</pre></div><p>The first argument is <code class="literal">target</code>. It is a method <code class="literal">foo</code> of <code class="literal">MyClassA</code>, whose behavior needs to be changed temporarily within a test. Put another way, this is the method (or <code class="literal">target</code>) that needs to be patched. The <code class="literal">new</code> argument specifies the object that would replace this method. In other words, the <code class="literal">target</code> is patched with the <code class="literal">new</code> object. If you do not specify the <code class="literal">new</code> argument, the <code class="literal">target</code> would be automatically patched with a <code class="literal">MagicMock</code> object.</p><div class="section" title="Using patch in a unit test"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec43"/>Using patch in a unit test</h3></div></div></div><p>To<a id="id377" class="indexterm"/> demonstrate the use of a <code class="literal">patch</code> decorator, we will use the <a id="id378" class="indexterm"/>example discussed under the heading <span class="emphasis"><em>Using Mock objects in a unit test</em></span>. Before reading the following discussion, review the <code class="literal">MyClassA.compute</code> method. It was illustrated in the aforementioned heading, and the code can also be found in the file <code class="literal">wargame/test/mockdemo.py</code>. The following is a unit test written for <code class="literal">MyClassA.compute</code> using patch:</p><div class="mediaobject"><img src="graphics/B05034_05_38.jpg" alt="Using patch in a unit test"/></div><p>In the preceding unit test:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">patch</code> is a context processor invoked using the with statement.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">with</code> keyword cleans up the resources used after the code execution.</li><li class="listitem" style="list-style-type: disc">The method <code class="literal">MyClassA.foo</code> gets replaced with a <code class="literal">Mock</code> object created by the optional argument new.</li><li class="listitem" style="list-style-type: disc">In other words, the call <code class="literal">self.foo()</code> in <code class="literal">MyClassA.compute()</code> is replaced with <code class="literal">return_value</code> of this <code class="literal">Mock</code> object. At runtime, the expression <code class="literal">x = self.foo()</code> becomes <code class="literal">x = 500</code> without actually invoking the method foo.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip52"/>Tip</h3><p>Would the test in the earlier illustration pass? For that, review the code in the <code class="literal">MyClassA.compute</code> method. The <code class="literal">Mock</code> object created by the <code class="literal">new</code> argument returns a value of <code class="literal">500</code>. In the unit test, if the result is not <code class="literal">400</code>, it raises an assertion error. So, this test is expected to fail.</p></div></div></li></ul></div><p>What happens <a id="id379" class="indexterm"/>if you do not specify the <code class="literal">new</code> argument? As mentioned <a id="id380" class="indexterm"/>earlier, <code class="literal">target</code> would automatically get replaced with a new <code class="literal">MagicMock</code> object. Here is another way you can write the same test. As an exercise, run this test, and print <code class="literal">foo_patch.__class__</code> to find out which class it belongs to:</p><div class="mediaobject"><img src="graphics/B05034_05_39.jpg" alt="Using patch in a unit test"/></div><p>With this introduction to the mock library, let's write a unit test for a method in our application using the <code class="literal">patch</code> decorator.</p></div></div><div class="section" title="Third unit test – The play method"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec89"/>Third unit test – The play method</h2></div></div></div><p>In this section, we will use the <a id="id381" class="indexterm"/>mock library to write a unit test for <code class="literal">AttackOfTheOrcs.play</code>. Let's review the method first. You can also find the source code in the <code class="literal">wargame/attackoftheorcs.py</code> file:</p><div class="mediaobject"><img src="graphics/B05034_05_40.jpg" alt="Third unit test – The play method"/></div><p>This preceding method does many things. It starts by creating some necessary objects such as the player and huts. Then the program runs until all the huts are acquired by the player or the player loses the combat. Observe the code closely. It depends on a user input for selecting a hut. This is not the only user input it needs. The call to the <code class="literal">Knight.acquire_hut</code> method would again ask the user whether to continue the attack.</p><p>In an automated test, you cannot expect someone to enter the hut number, and other inputs to continue the execution. So how do we write a unit test for this method? This is where we can use <code class="literal">patch</code> decorators to mimic the user input:</p><div class="mediaobject"><img src="graphics/B05034_05_48.jpg" alt="Third unit test – The play method"/></div><p>What should we test<a id="id382" class="indexterm"/> here? We should test the overall functioning of the method. There are a couple of thing to test here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The winning or losing criterion. The player is declared a winner when all the huts are acquired.</li><li class="listitem" style="list-style-type: disc">For this to happen, the player must also be in good health, meaning the value of <code class="literal">player.health_meter</code> should be greater than zero.</li></ul></div><p>Thus, the winner is declared only when both these conditions are true. Similarly, there will be a losing criterion that you can easily determine. For precise control, you should also write separate unit tests for individual methods invoked within the <code class="literal">play</code> method. For example, there should be a separate test to verify the working of <code class="literal">Knight.acquire_huts</code>.</p><p>Let's write a test to verify the overall functionality. This test will use <code class="literal">patch</code> to handle the user input. As before, you can find this test in the <code class="literal">wargame/test/test_wargame.py</code> module. The following code snippet shows the <code class="literal">TestWarGame.test_play</code> method in this module. At the beginning of the module, the mock library is imported like so:</p><div class="informalexample"><pre class="programlisting">from unittest import mock</pre></div><p>The rest of the code in this module will not be discussed here. Review the aforementioned file for further details:</p><div class="mediaobject"><img src="graphics/B05034_05_41.jpg" alt="Third unit test – The play method"/></div><p>The important part in <a id="id383" class="indexterm"/>the preceding code is <code class="literal">mock.patch</code>. Our first goal is to make sure that the user input is properly handled. Recall that in Python 3, the user input is handled by the built-in function <code class="literal">input()</code>. So, we need to patch this function with something that would simulate the user input. In other words, replace the <code class="literal">builtins.input</code> function with the handling function represented by the <code class="literal">new</code> argument.</p><p>The <code class="literal">self.hut_selection_counter</code> attribute is used as a simple counter to simulate the user input. The rest of the code implements the logic to verify that the winning and losing criteria are honored. The <code class="literal">acquired_hut_list</code> is generated using list comprehension. More on list comprehension later when we talk about the performance improvements. The <code class="literal">all</code> function returns <code class="literal">True</code> if all the list elements are <code class="literal">True</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip53"/>Tip</h3><p>If you are using Python 2.7.9, try replacing <code class="literal">builtins.input</code> with <code class="literal">__builtin__.raw_input</code>. However, this technique does not seem to work well, as it will still prompt you while running the test! With Python 3.5, this is not a problem. As said elsewhere, before Python 3.3, mock was not a built-in module (<code class="literal">unittest.mock</code>). So for Python 2.7.9, you may need to install mock as <code class="literal">pip install mock</code>, and make appropriate changes to the <code class="literal">import</code> statement.</p></div></div><p>Next, we will review<a id="id384" class="indexterm"/> the <code class="literal">user_input_processor</code> that patches the built-in <code class="literal">input</code> function:</p><div class="mediaobject"><img src="graphics/B05034_05_42.jpg" alt="Third unit test – The play method"/></div><p>It takes user <code class="literal">prompt</code> as an argument, and returns an answer (user input) to that prompt. For example, when prompted to enter the hut number, it increments <code class="literal">self.hut_selection_counter</code> by <code class="literal">1</code>, and returns the updated value. This attribute is initialized to <code class="literal">0</code> in the <code class="literal">test_play</code> method. To better understand this code, add some <code class="literal">print</code> statements to these two methods, and execute the test as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd wargame</strong></span>
<span class="strong"><strong>$ python -m unittest test.test_wargame.TestWarGame.test_play</strong></span>
</pre></div><p>The output on executing the test is shown in the following screenshot. Notice that it does not print the user prompts such as Continue attack?(y/n) in the command-line output:</p><div class="mediaobject"><img src="graphics/B05034_05_43.jpg" alt="Third unit test – The play method"/></div></div></div>
<div class="section" title="Is your code covered?"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Is your code covered?</h1></div></div></div><p>Is there a way to check how well you are doing as far as testing is concerned? How much code is covered by the unit tests? For this, you need a Python package called<a id="id385" class="indexterm"/> <code class="literal">coverage</code>. It can be installed using pip as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pip install coverage</strong></span>
</pre></div><p>The preceding command creates an executable called <code class="literal">coverage</code> at the same location as your Python installation. In Linux, if Python 3 is installed in <code class="literal">/usr/bin/</code>, <code class="literal">coverage</code> will be available at the same location as <code class="literal">/use/bin/coverage</code>. In Windows OS, it will be available in the <code class="literal">Scripts</code> directory, at the same location as <code class="literal">pip.exe</code>. Run the <code class="literal">coverage</code> command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd wargame</strong></span>
<span class="strong"><strong>$ coverage run -m test.test_wargame &amp;&amp; coverage report</strong></span>
</pre></div><p>This command is a combination of two commands separated by <code class="literal">&amp;&amp;</code> and executed one after the other. The first command runs the tests: <code class="literal">coverage run -m test.test_wargame</code>. This is similar to how we run the unit tests. The <code class="literal">run</code> option runs a Python program, and measures the code execution. As noted before, the <code class="literal">-m</code> option instructs <code class="literal">coverage</code> to consider the next argument as an importable Python module instead of treating it as a script. This is why we specify the next argument as <code class="literal">test.test_wargame</code> (just like an <code class="literal">import</code> statement) instead of writing <code class="literal">test/test_wargame.py</code>.</p><p>The second command, <code class="literal">coverage report</code>, generates<a id="id386" class="indexterm"/> the report indicating the test coverage. Here is how the coverage report is presented after running this command. For ease of illustration, the output pertaining to the execution of the test cases (the first command) is not shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B05034_05_44.jpg" alt="Is your code covered?"/></div><p>To see a different coverage report, try disabling some tests in <code class="literal">test_wargame.py</code>, and rerun the <code class="literal">coverage</code> command noted earlier.</p><div class="section" title="Resolving import errors, if any"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec90"/>Resolving import errors, if any</h2></div></div></div><p>Read this section only if <a id="id387" class="indexterm"/>you encounter any import errors while executing the coverage. If you run <code class="literal">coverage</code> as instructed, you are unlikely to encounter any import errors such as no module named <code class="literal">knight</code>. In other words, run the test from the top-level directory <code class="literal">wargame</code>, and make sure to run it as a module (the <code class="literal">-m</code> option) instead of a script. If you run <code class="literal">coverage</code> in the following way, you would likely see import errors:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd wargame/test</strong></span>
<span class="strong"><strong>$ coverage run test_wargame.py &amp;&amp; coverage report</strong></span>
</pre></div><p>In the preceding case, it is<a id="id388" class="indexterm"/> unable to find the right <code class="literal">PATH</code> for the modules from the <code class="literal">wargame</code> directory. Make sure that both <code class="literal">wargame</code> and <code class="literal">test</code> directories are in your <code class="literal">sys.path</code>. One quick and dirty hack is to add the following code to <code class="literal">test_wargame.py</code>. Assuming you are running coverage from within the <code class="literal">test</code> directory, add the following code before the <code class="literal">import</code> statements, such as <code class="literal">from knight import Knight</code>:</p><div class="informalexample"><pre class="programlisting">import sys 
# Append the directory one level up to the sys.path . 
# Alternatively specify the full path to that dir.
sys.path.append('../')</pre></div></div></div>
<div class="section" title="Other unit testing tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Other unit testing tools</h1></div></div></div><p>In this chapter, we have <a id="id389" class="indexterm"/>exclusively used the built-in <code class="literal">unittest</code> framework for writing the tests. There are several other tools available for unit testing that were not discussed. The purpose of this section is only to introduce you to the other unit testing tools available out there besides the built-in <code class="literal">unittest</code> module. For instance, there are tools such as nose or pytest that make it easier to write the unit tests to a large extent. Let's briefly review some of these unit testing tools.</p><div class="section" title="Doctest"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec91"/>Doctest</h2></div></div></div><p>This is a built-in <a id="id390" class="indexterm"/>module, which <a id="id391" class="indexterm"/>looks for text that resembles Python code written in an interpreter. Here is a trivial example that shows a docstring with an example usage of the function:</p><div class="informalexample"><pre class="programlisting">def add_nums(a, b): 
    """Return sum of two numbers 

    Example usage: 
    .. doctest:: 

    &gt;&gt;&gt; add_nums(10, 20) 
    30 
    """ 
    return (a + b)</pre></div><p>
<span class="strong"><strong>Doctest</strong></span> identifies such code, and runs it to check if it really does what it says. This is quite an effective way to verify the correctness of the code examples you write in the documentation and/or in the docstrings. While this is very useful, it is worth noting here that the extensive code samples in the docstring could be<a id="id392" class="indexterm"/> distracting. See <a class="ulink" href="https://docs.python.org/3/library/doctest.html#module-doctest">https://docs.python.org/3/library/doctest.html#module-doctest</a> for further details.</p></div><div class="section" title="Nose"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec92"/>Nose</h2></div></div></div><p>Nose <a id="id393" class="indexterm"/>is a popular third-party tool that simplifies writing and running unit tests. Install it using pip as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pip install nose</strong></span>
</pre></div><p>Nose extends <code class="literal">unittest</code>. One of the advantages of using this tool is it doesn't require you to write tests as inherited class methods of <code class="literal">unittest.TestCase</code>. You can even write tests as separate functions. Let's write a simple test, and run it with <code class="literal">nosetests</code>. Create the following <a id="id394" class="indexterm"/>function in a file called <code class="literal">test_nose.py</code>:</p><div class="informalexample"><pre class="programlisting">def test_a(): 
   assert( 1 == 1) </pre></div><p>Run this test from the command line as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nosetests test_nose.py</strong></span>
</pre></div><p>That's all. It will run the test. Obviously, this test will pass. As can be seen, we did not need to put the test inside the subclass of <code class="literal">unittest.TestCase</code>. The function name needs to contain <code class="literal">test</code> or <code class="literal">Test</code>, since we are using the default nose configuration. Try renaming the function so that it does not have the word <code class="literal">test</code>. For example, name it <code class="literal">foo_a</code>. If you run <code class="literal">nosetests</code> again, it will exclude this function. To consider function names that do not have the word <code class="literal">test</code>, use the command-line option <code class="literal">--tests</code> like so:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nosetests --tests foo_a test_nose.py </strong></span>
</pre></div><p>See <a class="ulink" href="https://nose.readthedocs.org">https://nose.readthedocs.org</a> to learn how to use nose<a id="id395" class="indexterm"/> effectively.</p></div><div class="section" title="Pytest"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec93"/>Pytest</h2></div></div></div><p>Pytest<a id="id396" class="indexterm"/> is yet another popular tool that simplifies writing unit tests. It <a id="id397" class="indexterm"/>can be installed using <code class="literal">pip</code> as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pip install pytest</strong></span>
</pre></div><p>You can run the same test we wrote for nose. Let's save the following code in a file, <code class="literal">test_pytest.py</code>:</p><div class="informalexample"><pre class="programlisting">def test_a(): 
   assert( 1 == 1) </pre></div><p>Run the preceding <a id="id398" class="indexterm"/>test from the command line as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ py.test test_pytest.py</strong></span>
</pre></div><p>See <a class="ulink" href="http://pytest.org/">http://pytest.org/</a> to find out <a id="id399" class="indexterm"/>more about this tool.</p></div></div>
<div class="section" title="Refactoring preamble"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Refactoring preamble</h1></div></div></div><p>Let's write one more unit test<a id="id400" class="indexterm"/> for the game. This time we will focus our attention on the main class <code class="literal">AttackOfTheOrcs</code>. When the <code class="literal">play</code> method is called, the first thing it does is to randomly occupy the five huts. We will write a test to verify that there are exactly five huts. Another thing to test is that the hut occupant must be an instance of the class <code class="literal">AbstractGameUnit</code>, or should be of the type <code class="literal">None</code>.</p><p>The <code class="literal">_occupy_hut</code> method has the related code. But this necessitates writing a test for a non-public method (or call it protected or private).</p><div class="mediaobject"><img src="graphics/B05034_05_30.jpg" alt="Refactoring preamble"/></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="emphasis"><em>What you say is right! Although Python does not restrict you from calling methods that start with an underscore, we should be nice to others, and try to avoid calling such methods.</em></span>
</p>
</td></tr></tbody></table></div><p>So how do we handle this situation? Here is a list of the available options:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the test, create an instance of <code class="literal">AttackOfThOrcs</code>, and directly call the protected method.</li><li class="listitem">Transform this method into a <code class="literal">public</code> method (remove the underscore prefix from the name).</li><li class="listitem">Call the <code class="literal">play</code> method, which then calls <code class="literal">_occupy_huts</code>.</li><li class="listitem">Refactor the <code class="literal">play</code> method, and wrap the <code class="literal">_occupy_huts</code> into a <code class="literal">public</code> method that could be tested.</li></ol></div><p>We already have a<a id="id401" class="indexterm"/> moral conflict with the first option, as <code class="literal">_occupy_huts</code> is a non-public method. The second option suggests turning it into a <code class="literal">public</code> method. That is possible, but if this method is not supposed to be called from outside for any reason, we should avoid such a change. We will keep this option in mind, and look for some other alternative.</p><p>The third option needs to call the <code class="literal">play</code> method. We have already done that in the last example using the patch decorator. Although possible, it is inefficient to run a large block of code for testing a small functionality. Let's leave that option aside for now. The fourth option suggests refactoring the code. Let's discuss it further.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip54"/>Tip</h3><p>In the simple application that we have developed, there is no harm in changing <code class="literal">_occupy_huts</code> to a <code class="literal">public</code> method! We could simply rename it <code class="literal">occupy_huts</code> (no underscore prefix), then update the calling code, and happily write a test! In fact, renaming is also a form of refactoring that will be covered next. In the real world, however, you may not have the luxury to transform a protected method to a public one. Keeping this situation in mind, we will refactor the code to illustrate one way of making the code test friendly.</p></div></div><div class="section" title="Take a detour – Refactor for testability"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec94"/>Take a detour – Refactor for testability</h2></div></div></div><p>Step 4 in the<a id="id402" class="indexterm"/> previous section needs us to refactor the play method before writing the test. This refactoring will improve our ability to write cleaner tests. So what is refactoring? How is it performed? The good news is that you have already done a form of refactoring in <a class="link" href="ch01.html" title="Chapter 1. Developing Simple Applications">Chapter 1</a>, <span class="emphasis"><em>Developing Simple Applications</em></span> while transforming the initial command-line script into a set of functions. Let's take a detour and learn some refactoring techniques. We will then come back with the refactored code, and develop the final unit test for our application.</p></div></div>
<div class="section" title="Refactoring"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Refactoring</h1></div></div></div><p>You have already come across the word refactoring in earlier chapters, and might have wondered what it means. An explanation is in order.</p><p>Just look around. Peep inside your closet or open your desk drawer. On day one, everything looks tidy and manageable. The drawer is meant to store all your important financial documents. Things begin to accumulate over time, and the drawer is now stuffed with not just with financial documents, but anything varying from scribbled notes, office documents, to greeting cards. Very soon, you cannot find that important document you need right now. You spend a lot of time digging out what you need.</p><p>The golden moment<a id="id403" class="indexterm"/> finally arrives. You begin the cleanup operation! Several things are found to be useless, and are thrown away. A few other things are still useful, such as tickets to a football game next week. You move this stuff to a different drawer where it really belongs. You also find several papers laying around belonging to a single category: house maintenance bills. You put these papers together inside a single folder. Finally, with all this rearrangement and cleanup, your drawer breathes the new day one!</p><div class="section" title="What is refactoring?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec95"/>What is refactoring?</h2></div></div></div><p>Refactoring is something very similar to your desk drawer. The application code is analogous to the drawer filled with documents. As the code evolves, both the good and bad stuff creeps in. From outside, the behavior of the drawer remains the same. You can still put documents (code) in it, and business goes on as usual. In the absence of refactoring, someday it reaches a tipping point, and becomes non-accommodating to new documents.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>With refactoring, you make internal changes to your code without affecting its external behavior.</p></div></div></div><div class="section" title="Why refactor?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec96"/>Why refactor?</h2></div></div></div><p>The short <a id="id404" class="indexterm"/>answer is, do it if you wish your code a long and healthy life! Timely refactoring is important to keep the code maintainable and extensible. You could rather spend more time working on a cool new feature than burning the midnight oil to fix a petty issue—a bug that could have been fixed within minutes had the code been properly maintained.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>Refactoring should be more of a habit than an obligation.</p></div></div></div><div class="section" title="When to refactor?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec97"/>When to refactor?</h2></div></div></div><p>So when do we refactor the code? You have to seek the optimal balance. If you realize it too late in the development life cycle, it affects productivity, as you would need to spend a considerable amount of time doing the code cleanup. Many times, the project deadline makes you turn your back on refactoring. Unfortunately, the user-visible part of the software wins over the internal cleanup. You only think of the immediate deliverable, and overlook the fact that<a id="id405" class="indexterm"/> refactoring will only help you deliver the product faster.</p><p>One strategy is to review the code at fixed intervals, and allocate some time for refactoring. If you are following a <a id="id406" class="indexterm"/>
<span class="strong"><strong>Scrum</strong></span> methodology, you can devote a sprint to some smaller refactoring projects. Such maintenance sprint will pay off in the long run. If you are staring at a big legacy code that needs immediate refactoring for survival, the required changes could be disruptive. In such situations, consider breaking it down into smaller problems, and use the other strategy discussed in the next paragraph.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>
<span class="strong"><strong>Agile development methodology</strong></span>
</p><p>This is often tied to a set <a id="id407" class="indexterm"/>of non-traditional software development methods for managing a project. In this method, you define targets achievable in a short time duration. There are regular checkpoints known as sprints or iterations. The end of a sprint should result in an incremental and releasable version of the product. This is useful in complex projects, where it is tough to plan the complete project, or predict what to expect next because of the dynamic nature of the project. The methodology adopts an incremental and <a id="id408" class="indexterm"/>iterative approach to handle this task. For further reading, see the following wiki page: <a class="ulink" href="https://en.wikipedia.org/wiki/Agile_software_development">https://en.wikipedia.org/wiki/Agile_software_development</a>.</p><p>
<span class="strong"><strong>Scrum</strong></span>
</p><p>It is a product<a id="id409" class="indexterm"/> development methodology. It is a framework based on the agile development methodology for managing complex systems. It implements an incremental and iterative (sprints) strategy for product development. The following is the link to the wiki for further details: <a class="ulink" href="https://en.wikipedia.org/wiki/Scrum_(software_development)">https://en.wikipedia.org/wiki/Scrum_(software_development)</a>.</p></div></div><p>Another strategy is to take up the refactoring task immediately after a major release. The customers just got what they were asking for. In the absence of any show-stopper bugs, you would typically find some free work cycles during this period. It is a good time for the next release planning and working on code refactoring tasks. This will vary from project to project. It depends on how actively the application is being developed, its size, architecture, and so on.</p></div><div class="section" title="How to refactor?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec98"/>How to refactor?</h2></div></div></div><p>Now that we have seen <a id="id410" class="indexterm"/>what refactoring means, let's see how to do it. The first task is to identify the piece of trouble-making code, and then restructure it. The restructuring should not affect the external behavior of the code. At the same time, it should help make the developer's life easy by simplifying the internal machinery (the code). We will discuss some of the most commonly performed refactoring operations. To help understand these operations, we will use the UML-like representative blocks wherever appropriate.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip55"/>Tip</h3><p>
<span class="strong"><strong>Unified Modeling Language</strong></span> (<span class="strong"><strong>UML</strong></span>)<a id="id411" class="indexterm"/> representation. See <a class="ulink" href="http://www.uml.org">http://www.uml.org</a>.</p></div></div><div class="section" title="Renaming"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec44"/>Renaming</h3></div></div></div><p>Imagine a <a id="id412" class="indexterm"/>developer introducing a new feature in the game <span class="emphasis"><em>Attack of the Orcs</em></span>. Each hut has a secret box. Whenever a unit acquires a hut, the contents of the box are revealed to the new owner as a print statement. This developer has introduced a new method called <code class="literal">showStuff()</code> in the class <code class="literal">Hut</code>. However, the name used here is not intuitive. It is not clear whether it shows what is inside the box, or whether it gives some information about some other stuff in the hut. Renaming such methods is one of the simplest forms of code refactoring. You could rename it to something verbose, such as <code class="literal">show_box_contents</code> or <code class="literal">reveal_box_contents</code>. However, make sure you perform the renaming task thoroughly by renaming all the method calls as well.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip56"/>Tip</h3><p>
<span class="strong"><strong>Coding standards</strong></span>:</p><p>This example brings forward an interesting topic, the Python coding standards. In case you have jumped straight to this chapter, read <a class="link" href="ch04.html" title="Chapter 4. Documentation and Best Practices">Chapter 4</a>, <span class="emphasis"><em>Documentation and Best Practices</em></span> that talks about the coding standards! These standards basically provide a coding style guide for Python programmers. Following these standards and defining your own guidelines for the project would help reduce such renaming tasks.</p></div></div></div><div class="section" title="Extracting"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec45"/>Extracting </h3></div></div></div><p>In <a class="link" href="ch01.html" title="Chapter 1. Developing Simple Applications">Chapter 1</a>, <span class="emphasis"><em>Developing Simple Applications</em></span> we had a single script representing the game. We identified<a id="id413" class="indexterm"/> pieces of code that could be written as individual functions. The name of each function was chosen such that it represented what the function body was supposed to do. This is shown in the following code snippets:</p><div class="mediaobject"><img src="graphics/B05034_05_31.jpg" alt="Extracting"/></div><div class="mediaobject"><img src="graphics/B05034_05_32.jpg" alt="Extracting"/></div><p>This refactoring operation is called <a id="id414" class="indexterm"/>function extraction. Likewise, you can group together relevant code fragments to extract a method within a class or extract a new class.</p></div></div><div class="section" title="Moving"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec99"/>Moving</h2></div></div></div><p>In <a class="link" href="ch03.html" title="Chapter 3. Modularize, Package, Deploy!">Chapter 3</a>, <span class="emphasis"><em>Modularize, Package, Deploy!</em></span> we did yet another type of refactoring operation. Can you guess what it was? The application code was contained within a single file. We <a id="id415" class="indexterm"/>modularized it by moving<a id="id416" class="indexterm"/> each class to its own file, and updating the referenced code.</p><p>Imagine you have a method of Class A, which is used mostly by various features in Class B. Depending on the nature of the problem, see if this method better fits in Class B than in the existing Class A. If it does, moving this method to Class B could be an option.</p><div class="section" title="Pushing down"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec46"/>Pushing down</h3></div></div></div><p>There is a new <a id="id417" class="indexterm"/>feature request. This time it is coming from Sir Foo!</p><div class="mediaobject"><img src="graphics/B05034_05_33.jpg" alt="Pushing down"/></div><p>The <code class="literal">Knight</code> and <code class="literal">OrcRider</code> are mounted units riding a horse and a wild boar-like creature respectively. You<a id="id418" class="indexterm"/> introduced a new method, <code class="literal">unmount</code>, in the superclass <code class="literal">AbstractGameUnit</code>. It gives them the ability to get off the animal they are riding:</p><div class="mediaobject"><img src="graphics/B05034_05_34.jpg" alt="Pushing down"/></div><p>However, you have now introduced several other imaginary characters in the game. For a majority of the characters, the method has become irrelevant. Now it makes sense to push down the <code class="literal">unmount</code> method in the inheritance hierarchy to the subclasses where it is relevant. This is shown in the diagram that follows. The <code class="literal">unmount</code> method is moved to the subclasses <code class="literal">Knight</code> and <code class="literal">OrcRider</code>:</p><div class="mediaobject"><img src="graphics/B05034_05_35.jpg" alt="Pushing down"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip57"/>Tip</h3><p>While pulling <a id="id419" class="indexterm"/>up (see the next heading) or pushing down type of refactoring simplifies things, it may not always serve its purpose. The <code class="literal">unmount</code> method was intended just as an illustration. The horse is associated with movement. One option is to define a move behavior here. For example, move using a horse, move using a wild boar, and so on. Another alternative is to define the unit types as mounted or unmounted. Refer to <a class="link" href="ch06.html" title="Chapter 6. Design Patterns">Chapter 6</a>, <span class="emphasis"><em>Design Patterns</em></span> on design patterns, which shows an elegant way to handle a similar situation.</p></div></div></div><div class="section" title="Pulling up"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec47"/>Pulling up</h3></div></div></div><p>It is the opposite of<a id="id420" class="indexterm"/> pushing down, where we use the inheritance principle. A subclass defines some functionality. The exact same method is defined in other subclasses. This method can be pulled up and defined in the superclass to make it available to all the subclasses.</p></div><div class="section" title="Refactoring tools for Python"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec48"/>Refactoring tools for Python</h3></div></div></div><p>There are tools that <a id="id421" class="indexterm"/>automate <a id="id422" class="indexterm"/>certain types of refactoring. For example, if you want to rename a method, the tool will rename it, and automatically update all the references to the method in the code. Here is a partial list of such tools:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Use a Python IDE</strong></span>: Assuming<a id="id423" class="indexterm"/> you are using an IDE for Python application development, the most convenient option is to use the built-in features of the IDE to refactor the code. IDEs <a id="id424" class="indexterm"/>such as PyCharm provide a menu item for refactoring, and support the most frequently performed refactoring operations, like the ones discussed in previous sections.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rope</strong></span>: Rope<a id="id425" class="indexterm"/> is an open source library for refactoring <a id="id426" class="indexterm"/>Python code. If you are a fan of editors such as vim or emacs, plugins are available to integrate the refactoring feature in the editor. The library <a id="id427" class="indexterm"/>can be installed using pip. For more information, see the GitHub page <a class="ulink" href="https://github.com/python-rope">https://github.com/python-rope</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bicycle repair man</strong></span>: This is <a id="id428" class="indexterm"/>another <a id="id429" class="indexterm"/>refactoring tool <a id="id430" class="indexterm"/>available for Python. The library can be installed using pip. Visit <a class="ulink" href="https://pypi.python.org/pypi/bicyclerepair">https://pypi.python.org/pypi/bicyclerepair</a> for more information.</li></ul></div></div></div></div>
<div class="section" title="Unit testing revisited"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Unit testing revisited</h1></div></div></div><p>Here is a quick recap of <a id="id431" class="indexterm"/>where we left the discussion on unit testing. The intention was to write a unit test for the functionality found in the non-public method, <code class="literal">AttackOfTheOrcs._occupy_huts</code>. One straightforward option was to call this method directly from the unit test. However, calling a non-public method is not considered best practice, so we started looking for alternatives. Another option was to refactor <code class="literal">AttackOfTheOrcs.play</code>, and use an extracted <code class="literal">public</code> method in the unit test. At this point, we took a detour from unit testing and learned the basics of refactoring. Now it is time to refactor <code class="literal">AttackOfTheOrcs.play</code> using the techniques we have just learned.</p><div class="section" title="Refactoring for testability"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec100"/>Refactoring for testability</h2></div></div></div><p>The source code for the <a id="id432" class="indexterm"/>game <span class="emphasis"><em>Attack of the Orcs</em></span> gives enough opportunity for refactoring. The <code class="literal">play</code> method is shown next. The code comments are omitted for the sake of illustration:</p><div class="mediaobject"><img src="graphics/B05034_05_36.jpg" alt="Refactoring for testability"/></div><p>The first part of the<a id="id433" class="indexterm"/> preceding code does some preparatory work to create the objects needed. It creates the <code class="literal">Knight</code> and the <code class="literal">Hut</code> instances, along with the objects that represent the hut occupants. Additionally, it prints some information on the game. As an initial refactoring, we will extract a new <code class="literal">public</code> method, as shown here:</p><div class="mediaobject"><img src="graphics/B05034_05_37.jpg" alt="Refactoring for testability"/></div><p>The new method primarily<a id="id434" class="indexterm"/> improves code readability, and also makes it simpler to write a test.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip58"/>Tip</h3><p>As noted in the <span class="emphasis"><em>Refactoring preamble</em></span> section, this is a toy problem. The refactoring strategy used here is to extract a new method for improved readability and testability. You could refactor this by some other means as well. For example, the setup code creates things such as the player and huts. May be you should also rename <code class="literal">_occupy_huts</code> to <code class="literal">create_huts</code>? Choices may vary, and so do the refactoring strategies. More than answering the question what is the best strategy to refactor here, this section mainly serves as an example of how refactoring could help simplify the task of writing a unit test.</p></div></div><p>This basic refactoring of<a id="id435" class="indexterm"/> the <code class="literal">play</code> method will enable writing a unit test for the <code class="literal">setup_game_scenario</code> method, which in turn, will help test the functionality in <code class="literal">_occupy_huts</code>.</p></div><div class="section" title="Fourth unit test – setup_game_scenario"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec101"/>Fourth unit test – setup_game_scenario</h2></div></div></div><p>As discussed in the <span class="emphasis"><em>Refactoring preamble</em></span> <a id="id436" class="indexterm"/>section, this test will verify the following things: (a) there are exactly five huts, and (b) the hut occupant is an instance of <code class="literal">AbstractGameUnit</code>, or of the type <code class="literal">None</code>.</p><p>This test is shown next. You can also find this test in the supporting code along with the other tests. See the <code class="literal">wargame/test/test_wargame.py</code> file. The code comments should make it self-explanatory:</p><div class="mediaobject"><img src="graphics/B05034_05_45.jpg" alt="Fourth unit test – setup_game_scenario"/></div><p>Run the preceding unit test as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd wargame</strong></span>
<span class="strong"><strong>$ python -m unittest test.test_wargame.TestWarGame.test_occupy_huts</strong></span>
</pre></div></div></div>
<div class="section" title="Exercise"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Exercise</h1></div></div></div><p>Some exercises have already been suggested in various sections of this chapter. Try those exercises. For example, split the unit tests so that you have separate modules for testing functionality from different classes. Add more unit tests to improve the code coverage. Also, try running <code class="literal">nosetests</code> on the tests that we have already written.</p><div class="section" title="Refactoring and redesign exercise"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec102"/>Refactoring and redesign exercise</h2></div></div></div><p>There are several low-hanging fruits for refactoring! Review the <code class="literal">AttackOfTheOrcs._occupy_huts</code> method. It creates hut objects, and puts an occupant in each of them. As the first step, you can rename it <code class="literal">create_huts</code>. The code in this method could be better written. It uses <code class="literal">if...else</code> conditions to decide which occupant to create. Although it works in this simple application, if you add other types of occupant (elves, dwarfs, wizards, and so on) it will become a maintenance headache.</p><p>What could we do here? One strategy is to let the <code class="literal">Hut</code> class manage the creation of the <code class="literal">occupant</code> object. The hut could ask a factory to randomly create an occupant. You will learn about the factory pattern in <a class="link" href="ch06.html" title="Chapter 6. Design Patterns">Chapter 6</a>, <span class="emphasis"><em>Design Patterns</em></span>. Since we are looking at this as a refactoring problem, you could try the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Change the signature of <code class="literal">Hut.__init__</code> so that you can optionally specify the <code class="literal">occupant</code>.</li><li class="listitem" style="list-style-type: disc">Inside the <code class="literal">Hut</code> class, create an <code class="literal">occupant</code> (if not already available) by calling a new utility function, <code class="literal">create_unit</code>. You will need to write this new utility function (the  solution is not provided). The function should not be a method of the class <code class="literal">Hut</code>.</li></ul></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Summary</h1></div></div></div><p>The chapter started by emphasizing the need for testing. It introduced you to the unit testing framework in Python. You learned how to write and execute unit tests. The next topic served as an introduction to Python mock library. The chapter demonstrated the use of <code class="literal">Mock</code> objects in unit tests. Next, it showed an example where it was difficult to write a unit test without refactoring the code first. At this point, you learned the basics of refactoring, refactored the code, and then developed a unit test for this example.</p><p>During development, you often encounter a recurring problem. Often, a general solution (or a recipe) exists that works for this problem. This is often referred to as a design pattern. In the next chapter, we will review a few commonly used design patterns in Python.</p></div></body></html>