<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Distributed Python</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This chapter will introduce some important Python modules for distributed computing. </span><span class="koboSpan" id="kobo.2.2">In particular, we will describe the </span><kbd><span class="koboSpan" id="kobo.3.1">socket</span></kbd><span class="koboSpan" id="kobo.4.1"> module, which allows you to implement simple applications distributed through the client-server model.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Then, we will introduce the Celery module, which is a powerful Python framework that is used to manage distributed tasks. </span><span class="koboSpan" id="kobo.5.2">Finally, we will describe the </span><kbd><span class="koboSpan" id="kobo.6.1">Pyro4</span></kbd><span class="koboSpan" id="kobo.7.1"> module, which allows you to call methods that are used in different processes, potentially on a different machine.</span></p>
<p><span class="koboSpan" id="kobo.8.1">In this chapter, we will cover the following recipes:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Introducing distributed computing</span></li>
<li><span class="koboSpan" id="kobo.10.1">Using the Python</span><span><span class="koboSpan" id="kobo.11.1"> s</span></span><span class="koboSpan" id="kobo.12.1">ocket module</span></li>
<li><span class="koboSpan" id="kobo.13.1">Distributed task management with Celery</span></li>
<li><span class="koboSpan" id="kobo.14.1">Remote Method Invocation</span><span><span class="koboSpan" id="kobo.15.1"> (</span></span><span class="koboSpan" id="kobo.16.1">RMI</span><span><span class="koboSpan" id="kobo.17.1">)</span></span><span class="koboSpan" id="kobo.18.1"> with </span><kbd><span class="koboSpan" id="kobo.19.1">Pyro4</span></kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Introducing distributed computing</span></h1>
                </header>
            
            <article>
                
<p><em><span class="koboSpan" id="kobo.2.1">Parallel</span></em><span class="koboSpan" id="kobo.3.1"> and </span><em><span class="koboSpan" id="kobo.4.1">distributed computing</span></em><span class="koboSpan" id="kobo.5.1"> are similar technologies designed to increase the amount of processing power available for a specific task. </span><span class="koboSpan" id="kobo.5.2">Generally, these methods are used to solve problems that require large computational capabilities.</span></p>
<p><span class="koboSpan" id="kobo.6.1">When the problem is divided into many small pieces, individual sections of the problem can be calculated by many processors simultaneously. </span><span class="koboSpan" id="kobo.6.2">This allows more processing power to be exercised on the problem than can be provided by a single processor.</span></p>
<p><span class="koboSpan" id="kobo.7.1">The main difference between parallel and distributed processing is that parallel configurations include many processors within a single system, while distributed configurations exploit the processing power of many computers simultaneously.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.8.1">Let's look at the other differences:</span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong><span class="koboSpan" id="kobo.9.1">Parallel processing</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.10.1">Distributed processing</span></strong></td>
</tr>
<tr>
<td><span><span class="koboSpan" id="kobo.11.1">Parallel processing has the advantage of providing reliable processing power with a very low degree of latency.</span></span></td>
<td><span class="koboSpan" id="kobo.12.1">Distributed processing is not extremely efficient on a processor-by-processor basis, as the data must travel over the network rather than through the internal connections of a single system.</span></td>
</tr>
<tr>
<td><span><span class="koboSpan" id="kobo.13.1">By concentrating all the processing power in one system, speed loss due to data transfer is minimized.</span></span></td>
<td><span class="koboSpan" id="kobo.14.1">Each processor will contribute much less processing power than any processor in a parallel system since data transfer creates a bottleneck that limits processing power.</span></td>
</tr>
<tr>
<td><span class="koboSpan" id="kobo.15.1">The only real limit is the number of processors incorporated in the system.</span></td>
<td><span class="koboSpan" id="kobo.16.1">The system is almost infinitely scalable since there is no actual upper limit to the number of processors in a distributed system.</span></td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.17.1"> </span></p>
<p class="mce-root"><span><span class="koboSpan" id="kobo.18.1">However, in the context of computer applications, it is customary to distinguish between local and distributed architectures:</span></span></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong><span class="koboSpan" id="kobo.19.1">Local architectures</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.20.1">Distributed architectures</span></strong></td>
</tr>
<tr>
<td><span><span class="koboSpan" id="kobo.21.1">All the components are on the same machine.</span></span></td>
<td><span><span class="koboSpan" id="kobo.22.1">Applications and components can reside on different nodes that are connected by a network.</span></span></td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.23.1"> </span></p>
<p><span class="koboSpan" id="kobo.24.1">The advantages of using distributed computing consist mainly of the possibility of concurrent use of the programs, the centralization of the data, and the distribution of the processing load, which all come at the price of greater complexity, especially with communication between the various components.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Types of distributed applications</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Distributed applications can be classified according to the degree of distribution:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.3.1">Client-server applications</span></strong></li>
<li><strong><span class="koboSpan" id="kobo.4.1">Multi-level applications</span></strong></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Client-server applications</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There are only two levels and the operations are carried out entirely on the server. </span><span class="koboSpan" id="kobo.2.2">As an example, we can mention the classic static or dynamic websites. </span><span class="koboSpan" id="kobo.2.3">The tools for the realization of these types of applications are the network sockets, whose programming is possible in various languages, including C, C ++, Java, and, of course, Python.</span></p>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.3.1">The term </span><em><span class="koboSpan" id="kobo.4.1">client-server system</span></em><span class="koboSpan" id="kobo.5.1"> refe</span><em><span class="koboSpan" id="kobo.6.1">rs</span></em><span class="koboSpan" id="kobo.7.1"> to a network architecture in which a client computer or client terminal is generally connected to a server for the use of a certain service; for example, the sharing of a certain hardware/software resource with other clients, or relying on the underlying protocol architecture.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Client-server architecture</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The client-server architecture is a system that realizes a distribution of both processing and data. </span><span class="koboSpan" id="kobo.2.2">The central element of the architecture is the server. </span><span class="koboSpan" id="kobo.2.3">The server can be considered both from a logical point of view and from a physical point of view. </span><span class="koboSpan" id="kobo.2.4">From the physical point of view—hardware—a server is a machine dedicated to running a software server.</span></p>
<p><span class="koboSpan" id="kobo.3.1">From a logical point of view, a server is software. </span><span class="koboSpan" id="kobo.3.2">The server, as a logical process, provides services to other processes that take on the role of requester or client. </span><span class="koboSpan" id="kobo.3.3">Generally, the server does not send the results to the requester until the results are requested by the client.</span></p>
<p class="CDPAlignLeft CDPAlign"><span class="koboSpan" id="kobo.4.1">A feature that distinguishes the client from its server is that the client can initiate a transaction with the server, while the server can never initiate a transaction with the client on its own initiative:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.5.1"><img src="assets/f9df2fb0-1a78-4826-b494-5e3b43effbf0.png" style="width:36.58em;height:21.08em;"/></span></p>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign"><span class="hps"><span class="koboSpan" id="kobo.6.1">Client-server architecture</span></span></div>
<p><span><span class="koboSpan" id="kobo.7.1">In fact, the specific tasks of the client are to start transactions, request specific services, notify the completion of the service, and receive results from the server, as shown in the preceding diagram.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Client-server communications</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Communication between clients and servers can take place using a variety of mechanisms—from geographic to local networks, up to communication services—between applications at the OS level. </span><span class="koboSpan" id="kobo.2.2">Furthermore, a client-server architecture must be independent of the physical connection method that exists between the client and the server.</span></p>
<p><span class="koboSpan" id="kobo.3.1">It should also be noted that it is not necessary for a client-server process to reside on physically separate systems. </span><span class="koboSpan" id="kobo.3.2">In fact, the server process and the client process can reside on the same computing platform.</span></p>
<p><span class="koboSpan" id="kobo.4.1">The main objective of the client-server architecture, in the context of data management, is to allow client applications to access data managed by the servers. </span><span class="koboSpan" id="kobo.4.2">The server (understood in a logical sense as software) is often running on a remote system (for example, in another city or on a local network).</span></p>
<p><span class="koboSpan" id="kobo.5.1">Therefore, client-server applications are often associated with distributed processing.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">TCP/IP client-server architecture</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The TCP/IP connection establishes a point-to-point connection between two applications. </span><span class="koboSpan" id="kobo.2.2">The extremes of this connection are marked by an IP address, which identifies the workstation by a port number, which makes it possible to have several connections that are connected to independent applications on the same workstation.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Once the connection is established and the protocol can exchange data over it, the underlying TCP/IP protocol takes care of sending this data, divided into packets, from one end </span><span><span class="koboSpan" id="kobo.4.1">of the connection </span></span><span class="koboSpan" id="kobo.5.1">to the other. </span><span class="koboSpan" id="kobo.5.2">In particular, the TCP protocol deals with assembling and disassembling the packets, as well as managing the handshaking that guarantees the reliability of the connection, while the IP protocol takes care of transporting the individual packets and the choice of the best routing of the packets along with the network.</span></p>
<p><span class="koboSpan" id="kobo.6.1">This mechanism underlies the robustness of the TCP/IP </span><span><span class="koboSpan" id="kobo.7.1">protocol</span></span><span class="koboSpan" id="kobo.8.1">, which, in turn, represents one of the reasons for the development of the protocol itself in the military sphere (ARPANET).</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.9.1">The various existing standard applications (such as web browsing, file transfer, </span><span><span class="koboSpan" id="kobo.10.1">and </span></span><span class="koboSpan" id="kobo.11.1">email) use standardized application protocols, </span><span><span class="koboSpan" id="kobo.12.1">such as</span></span><span class="koboSpan" id="kobo.13.1"> HTTP, FTP, POP3, IMAP, and SMTP.</span></p>
<p><span class="koboSpan" id="kobo.14.1">Each specific client-server application must instead define and apply its own proprietary application protocol. </span><span class="koboSpan" id="kobo.14.2">This can involve the exchange of data in blocks of a fixed size (which is the simplest solution).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Multi-level applications</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There are a greater number of levels that enable the processing load of the servers to be alleviated. </span><span class="koboSpan" id="kobo.2.2">Those that are, in fact, subdivided are the functionalities of the server-side, leaving the characteristics of the client part that has the task of hosting the application interface largely unchanged. </span><span class="koboSpan" id="kobo.2.3">An example of this type of architecture is that of the three-tier model, having a structure divided into three layers or levels:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">Frontend or presentation tier or interface</span></li>
<li><span class="koboSpan" id="kobo.4.1">Middle tier or application logic</span></li>
<li><span class="koboSpan" id="kobo.5.1">Backend or data tier or persistent data management</span></li>
</ul>
<p><span class="koboSpan" id="kobo.6.1">This nomenclature is typical of web applications. </span><span class="koboSpan" id="kobo.6.2">More generally, it is possible to refer to a subdivision in three levels that are applicable to any software application, which is the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1"> </span><strong><span class="koboSpan" id="kobo.8.1">Presentation Layer</span></strong><span class="koboSpan" id="kobo.9.1"> (</span><strong><span class="koboSpan" id="kobo.10.1">PL</span></strong><span class="koboSpan" id="kobo.11.1">): This is the visualization part of the data (such as modules</span><span><span class="koboSpan" id="kobo.12.1"> and</span></span><span class="koboSpan" id="kobo.13.1"> controls of input) necessary for the user interface.</span></li>
<li><span class="koboSpan" id="kobo.14.1"> </span><strong><span class="koboSpan" id="kobo.15.1">Business Logic Layer</span></strong><span class="koboSpan" id="kobo.16.1"> (</span><strong><span class="koboSpan" id="kobo.17.1">BLL</span></strong><span class="koboSpan" id="kobo.18.1">): </span><span><span class="koboSpan" id="kobo.19.1">This</span></span><span class="koboSpan" id="kobo.20.1"> is the main part of the application, which defines the various entities and their relationships independently of the methods of presentation available to the user and saved in the archives.</span></li>
<li><strong><span class="koboSpan" id="kobo.21.1">Data Access Layer</span></strong><span class="koboSpan" id="kobo.22.1"> (</span><strong><span class="koboSpan" id="kobo.23.1">DAL</span></strong><span class="koboSpan" id="kobo.24.1">): </span><span><span class="koboSpan" id="kobo.25.1">This</span></span><span class="koboSpan" id="kobo.26.1"> contains everything necessary for the management of persistent data (essentially, database management systems).</span></li>
</ul>
<p><span class="koboSpan" id="kobo.27.1">This chapter will present some of the solutions proposed by Python for the implementation of distributed architectures. </span><span class="koboSpan" id="kobo.27.2">We will begin by describing the </span><kbd><span class="koboSpan" id="kobo.28.1">socket</span></kbd><span class="koboSpan" id="kobo.29.1"> module with which we will implement some examples of the fundamental client-server model.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using the Python socket module</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A socket is a software object that allows data to be sent and received between remote hosts (via a network) or between local processes, such as </span><strong><span class="koboSpan" id="kobo.3.1">Inter-Process Communication</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">IPC</span></strong><span class="koboSpan" id="kobo.6.1">).</span></p>
<p><span class="koboSpan" id="kobo.7.1">Sockets were invented at Berkeley as part of the </span><strong><span class="koboSpan" id="kobo.8.1">BSD Unix</span></strong><span class="koboSpan" id="kobo.9.1"> project. </span><span class="koboSpan" id="kobo.9.2">They are based precisely on the management model of input and output of Unix files. </span><span class="koboSpan" id="kobo.9.3">In fact, the operations of opening, reading, writing, and closing a socket occur in the same way as the management of Unix files, but with the difference that should be considered are the useful parameters for communication, such as addresses, port numbers, and protocols.</span></p>
<p><span class="koboSpan" id="kobo.10.1">The success and spread of socket technology have gone hand in hand with the development of the internet. </span><span class="koboSpan" id="kobo.10.2">In fact, the combination of sockets with the internet has made communication between machines that are of any type, and/or are scattered throughout the world, incredibly easy (at least when compared with other systems).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The socket Python module exposes low-level C </span><span><span class="koboSpan" id="kobo.3.1">API</span></span><span class="koboSpan" id="kobo.4.1">s for communication over a network using the </span><strong><span class="koboSpan" id="kobo.5.1">BSD</span></strong> <em><span class="koboSpan" id="kobo.6.1">(</span></em><span class="koboSpan" id="kobo.7.1">short for </span><span><strong><span class="koboSpan" id="kobo.8.1">Berkeley Software Distribution</span></strong></span><span class="koboSpan" id="kobo.9.1">) socket interface.</span></p>
<p><span class="koboSpan" id="kobo.10.1">This module includes the </span><kbd><span class="koboSpan" id="kobo.11.1">Socket</span></kbd><span class="koboSpan" id="kobo.12.1"> class, which includes the main methods for managing the following tasks:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.13.1">socket ([family [, type [, protocol]]])</span></kbd><span class="koboSpan" id="kobo.14.1">: Builds a socket using the following as arguments:
</span><ul>
<li><span class="koboSpan" id="kobo.15.1">The </span><kbd><span class="koboSpan" id="kobo.16.1">family</span></kbd><span><span class="koboSpan" id="kobo.17.1"> address, which can be </span></span><kbd><span class="koboSpan" id="kobo.18.1">AF_INET (default)</span></kbd><span><span class="koboSpan" id="kobo.19.1">, </span></span><kbd><span class="koboSpan" id="kobo.20.1">AF_INET6</span></kbd><span><span class="koboSpan" id="kobo.21.1">, or </span></span><kbd><span class="koboSpan" id="kobo.22.1">AF_UNIX</span></kbd></li>
<li><span class="koboSpan" id="kobo.23.1">The </span><kbd><span class="koboSpan" id="kobo.24.1">type</span></kbd> <span><span class="koboSpan" id="kobo.25.1">socket, which </span></span><span class="koboSpan" id="kobo.26.1">can be</span><span><span class="koboSpan" id="kobo.27.1"> </span></span><kbd><span class="koboSpan" id="kobo.28.1">SOCK_STREAM (default)</span></kbd><span><span class="koboSpan" id="kobo.29.1">, </span></span><kbd><span class="koboSpan" id="kobo.30.1">SOCK_DGRAM</span></kbd><span><span class="koboSpan" id="kobo.31.1">, or perhaps one of the other </span></span><kbd><span class="koboSpan" id="kobo.32.1">"SOCK_"</span></kbd><span><span class="koboSpan" id="kobo.33.1"> constants</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">The </span><kbd><span class="koboSpan" id="kobo.35.1">protocol</span></kbd><span class="koboSpan" id="kobo.36.1"> number (that is usually zero)</span></li>
</ul>
</li>
<li><kbd><span class="koboSpan" id="kobo.37.1">gethostname()</span></kbd><span class="koboSpan" id="kobo.38.1">: Returns the current IP address of the machine.</span></li>
<li><kbd><span class="koboSpan" id="kobo.39.1">accept ()</span></kbd><span><span class="koboSpan" id="kobo.40.1">: </span></span><span class="koboSpan" id="kobo.41.1">Returns the following pair of values (</span><kbd><span class="koboSpan" id="kobo.42.1">conn</span></kbd><span class="koboSpan" id="kobo.43.1"> and </span><kbd><span class="koboSpan" id="kobo.44.1">address</span></kbd><span class="koboSpan" id="kobo.45.1">), where </span><kbd><span class="koboSpan" id="kobo.46.1">conn</span></kbd><span class="koboSpan" id="kobo.47.1"> is a socket type object (to send/receive data on the connection), while </span><kbd><span class="koboSpan" id="kobo.48.1">address</span></kbd><span class="koboSpan" id="kobo.49.1"> is the address connected to the socket on the other end of the connection.</span></li>
<li><kbd><span class="koboSpan" id="kobo.50.1">bind (address)</span></kbd><span class="koboSpan" id="kobo.51.1">: Associates the socket with the </span><kbd><span class="koboSpan" id="kobo.52.1">address</span></kbd><span class="koboSpan" id="kobo.53.1"> </span><span><span><span class="koboSpan" id="kobo.54.1">server.</span></span></span></li>
</ul>
<div class="packt_infobox"><span class="koboSpan" id="kobo.55.1">This method historically accepted a couple of parameters for the </span><kbd><span class="koboSpan" id="kobo.56.1">AF_INET</span></kbd><span class="koboSpan" id="kobo.57.1"> addresses instead of a single tuple. </span></div>
<ul>
<li><kbd><span class="koboSpan" id="kobo.58.1">close ()</span></kbd><span class="koboSpan" id="kobo.59.1">: Provides the option to clean up the connection once communication with the client is finished. </span><span class="koboSpan" id="kobo.59.2">The sockets are closed and collected by the garbage collector. </span></li>
<li><kbd><span class="koboSpan" id="kobo.60.1">connect</span><em><span class="koboSpan" id="kobo.61.1"> </span></em><span class="koboSpan" id="kobo.62.1">(address)</span></kbd><span class="koboSpan" id="kobo.63.1">: Connects a remote socket to </span><span><span class="koboSpan" id="kobo.64.1">an </span></span><span class="koboSpan" id="kobo.65.1">address. </span><span class="koboSpan" id="kobo.65.2">The </span><kbd><span class="koboSpan" id="kobo.66.1">address</span></kbd><span class="koboSpan" id="kobo.67.1"> format depends on the family address.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In the following example, the server is listening on a default port, and by following a TCP/IP connection, the client sends </span><span><span class="koboSpan" id="kobo.3.1">to the server </span></span><span class="koboSpan" id="kobo.4.1">the date and time </span><span><span class="koboSpan" id="kobo.5.1">that the connection was established.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">Here is the server</span><span><span class="koboSpan" id="kobo.7.1"> implementation for</span></span><span class="koboSpan" id="kobo.8.1"> </span><kbd><span class="koboSpan" id="kobo.9.1">server.py</span></kbd><span class="koboSpan" id="kobo.10.1">:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.11.1">Import the relevant Python modules:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.12.1">import socket</span><br/><span class="koboSpan" id="kobo.13.1">import time</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.14.1">Create a new socket using the given address, socket type, and protocol number:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.15.1">serversocket=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.16.1">Get the local machine name (</span><kbd><span class="koboSpan" id="kobo.17.1">host</span></kbd><span class="koboSpan" id="kobo.18.1">):</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.19.1">host=socket.gethostname()</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.20.1">Set the </span><kbd><span class="koboSpan" id="kobo.21.1">port</span></kbd><span class="koboSpan" id="kobo.22.1"> number:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.23.1">port=9999</span></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.24.1">Connect (bind) the socket to </span><kbd><span class="koboSpan" id="kobo.25.1">host</span></kbd><span class="koboSpan" id="kobo.26.1"> and to </span><kbd><span class="koboSpan" id="kobo.27.1">port</span></kbd><span class="koboSpan" id="kobo.28.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.29.1">serversocket.bind((host,port))</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="6">
<li><span class="koboSpan" id="kobo.30.1">Listen for connections made to the socket. </span><span class="koboSpan" id="kobo.30.2">The argument of </span><kbd><span class="koboSpan" id="kobo.31.1">5</span></kbd><span class="koboSpan" id="kobo.32.1"> specifies the maximum number of connections in the queue. </span><span class="koboSpan" id="kobo.32.2">The maximum value depends on the system (usually, it is </span><kbd><span class="koboSpan" id="kobo.33.1">5</span></kbd><span class="koboSpan" id="kobo.34.1">) and the minimum value is always </span><kbd><span class="koboSpan" id="kobo.35.1">0</span></kbd><span class="koboSpan" id="kobo.36.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.37.1">serversocket.listen(5)</span></pre>
<ol start="7">
<li><span class="koboSpan" id="kobo.38.1">Establish a connection:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.39.1">while True:</span></pre>
<ol start="8">
<li class="CDPAlignLeft CDPAlign"><span class="koboSpan" id="kobo.40.1">Then, the connection is accepted. </span><span class="koboSpan" id="kobo.40.2">The return value is a pair (</span><kbd><span class="koboSpan" id="kobo.41.1">conn</span></kbd><span class="koboSpan" id="kobo.42.1">, </span><kbd><span class="koboSpan" id="kobo.43.1">address</span></kbd><span class="koboSpan" id="kobo.44.1">), where </span><kbd><span class="koboSpan" id="kobo.45.1">conn</span></kbd><span class="koboSpan" id="kobo.46.1"> is a new </span><kbd><span class="koboSpan" id="kobo.47.1">socket</span></kbd><span class="koboSpan" id="kobo.48.1"> object that is used to send and receive data, and </span><kbd><span class="koboSpan" id="kobo.49.1">address</span></kbd><span class="koboSpan" id="kobo.50.1"> is the address linked to the socket. </span><span class="koboSpan" id="kobo.50.2">Once accepted, a new socket is created and it will have its own identifier. </span><span class="koboSpan" id="kobo.50.3">This new socket is </span><span><span class="koboSpan" id="kobo.51.1">only </span></span><span class="koboSpan" id="kobo.52.1">used with this particular client:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.53.1">clientsocket,addr=serversocket.accept()</span></pre>
<ol start="9">
<li><span class="koboSpan" id="kobo.54.1">The address and the port that is connected are printed out:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.55.1">print ("Connected with[addr],[port]%s"%str(addr))</span></pre>
<ol start="10">
<li><kbd><span class="koboSpan" id="kobo.56.1">currentTime</span></kbd><span class="koboSpan" id="kobo.57.1"> is evaluated:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.58.1">currentTime=time.ctime(time.time())+"\r\n"</span></pre>
<ol start="11">
<li><span class="koboSpan" id="kobo.59.1">The following statement sends data to the socket, returning the number of bytes sent:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.60.1">clientsocket.send(currentTime.encode('ascii'))</span></pre>
<ol start="12">
<li><span class="koboSpan" id="kobo.61.1">The following statement indicates the socket closure (that is, the communication channel); all subsequent operations on the socket will fail. </span><span class="koboSpan" id="kobo.61.2">The sockets are automatically closed when they are rejected, but it is always recommended to close them with the </span><kbd><span class="koboSpan" id="kobo.62.1">close()</span></kbd><span><span class="koboSpan" id="kobo.63.1"> operation:</span></span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.64.1">clientsocket.close()</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span><span class="koboSpan" id="kobo.65.1">The code for the client (</span></span><kbd><span class="koboSpan" id="kobo.66.1">client.py</span></kbd><span><span class="koboSpan" id="kobo.67.1">) is as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.68.1">Import the </span><kbd><span class="koboSpan" id="kobo.69.1">socket</span></kbd><span class="koboSpan" id="kobo.70.1"> library:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.71.1">import socket</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.72.1">The </span><kbd><span class="koboSpan" id="kobo.73.1">socket</span></kbd><span class="koboSpan" id="kobo.74.1"> object is then created:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.75.1">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.76.1">Get the local machine name (</span><kbd><span class="koboSpan" id="kobo.77.1">host</span></kbd><span class="koboSpan" id="kobo.78.1">):</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.79.1">host=socket.gethostname()</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.80.1">Set the </span><kbd><span class="koboSpan" id="kobo.81.1">port</span></kbd><span class="koboSpan" id="kobo.82.1"> number:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.83.1">port=9999</span></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.84.1">Set up the connection to </span><kbd><span class="koboSpan" id="kobo.85.1">host</span></kbd><span class="koboSpan" id="kobo.86.1"> and </span><kbd><span class="koboSpan" id="kobo.87.1">port</span></kbd><span class="koboSpan" id="kobo.88.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.89.1">s.connect((host,port))</span></pre>
<div class="packt_infobox"><span class="koboSpan" id="kobo.90.1">The maximum number of bytes that can be received is no more than 1,024 bytes: (</span><kbd><span class="koboSpan" id="kobo.91.1">tm=s.recv(1024)</span></kbd><span class="koboSpan" id="kobo.92.1">).</span></div>
<ol start="6">
<li><span class="koboSpan" id="kobo.93.1">Now, close the connection and finally print out the connection time to the server:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.94.1">s.close()</span><br/><span class="koboSpan" id="kobo.95.1">print ("Time connection server:%s"%tm.decode('ascii'))</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Clients and servers create their respective sockets, and the server listens to them on a port. </span><span class="koboSpan" id="kobo.2.2">The client makes a connection request to the server. </span><span class="koboSpan" id="kobo.2.3">It should be noted that we can have two different port numbers because one could only be dedicated to outgoing traffic, and the other </span><span><span class="koboSpan" id="kobo.3.1">could only be dedicated</span></span><span class="koboSpan" id="kobo.4.1"> to entry. </span><span class="koboSpan" id="kobo.4.2">This depends on the host configuration.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Essentially, the client's local port does not necessarily coincide with the server's remote port. </span><span class="koboSpan" id="kobo.5.2">The server receives the request and, if accepted, a new connection is created. </span><span class="koboSpan" id="kobo.5.3">Now, the client and server communicate through a virtual channel, between the socket and the server, which is created specifically for the data flow of the data socket connection.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.6.1">Consistent with what was mentioned in the first phase, the server creates the data socket because the first one is used exclusively for managing requests. </span><span class="koboSpan" id="kobo.6.2">T</span><span><span class="koboSpan" id="kobo.7.1">herefore, </span></span><span class="koboSpan" id="kobo.8.1">it is possible that there are many clients communicating with the server using the data socket created by the server for them. The TCP protocol is connection-oriented, which means that when there is no longer a need to communicate, the client communicates this to the server and the connection is closed.</span></p>
<p><span class="koboSpan" id="kobo.9.1">To run the example, execute the server: </span></p>
<pre><strong><span class="koboSpan" id="kobo.10.1">C:\&gt;python server.py </span></strong></pre>
<p><span><span class="koboSpan" id="kobo.11.1">Then, execute the client</span></span><span class="koboSpan" id="kobo.12.1"> (in a different Windows terminal):</span></p>
<pre><strong><span class="koboSpan" id="kobo.13.1">C:\&gt;python client.py</span></strong></pre>
<p><span class="koboSpan" id="kobo.14.1">The result on the client side should report the address (</span><kbd><span class="koboSpan" id="kobo.15.1">addr</span></kbd><span class="koboSpan" id="kobo.16.1">) and </span><span><span class="koboSpan" id="kobo.17.1">report</span></span> <kbd><span class="koboSpan" id="kobo.18.1">port</span></kbd><span class="koboSpan" id="kobo.19.1"> as connected:</span></p>
<pre><strong><span class="koboSpan" id="kobo.20.1">Connected with[addr],[port]('192.168.178.11', 58753)</span></strong></pre>
<p><span class="koboSpan" id="kobo.21.1">However, on the server side, the result should be as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.22.1">Time connection server:Sun Mar 31 20:59:38 2019</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">With a small change to the previous code, we can create a simple client-server application for file transfer. </span><span class="koboSpan" id="kobo.2.2">The server instantiates the socket and waits for the connection instance from the client. </span><span class="koboSpan" id="kobo.2.3">Once connected to the server, the client starts the data transfer. </span></p>
<p><span class="koboSpan" id="kobo.3.1">The data to be transferred, which is </span><span><span class="koboSpan" id="kobo.4.1">in the</span></span><span class="koboSpan" id="kobo.5.1"> </span><kbd><span class="koboSpan" id="kobo.6.1">mytext.txt</span></kbd><span class="koboSpan" id="kobo.7.1"> </span><span><span class="koboSpan" id="kobo.8.1">file</span></span><span><span class="koboSpan" id="kobo.9.1">,</span></span> <span><span class="koboSpan" id="kobo.10.1">is</span></span><span class="koboSpan" id="kobo.11.1"> copied byte by byte and sent to the server through the call to the </span><kbd><span class="koboSpan" id="kobo.12.1">conn.send</span></kbd><span class="koboSpan" id="kobo.13.1"> </span><span><span class="koboSpan" id="kobo.14.1">function.</span></span><span class="koboSpan" id="kobo.15.1"> The server then receives the data and writes it to a second file, </span><kbd><span class="koboSpan" id="kobo.16.1">received.txt</span></kbd><span class="koboSpan" id="kobo.17.1">.</span></p>
<p><span class="koboSpan" id="kobo.18.1">The source code for </span><kbd><span class="koboSpan" id="kobo.19.1">client2.py</span></kbd><span class="koboSpan" id="kobo.20.1"> is as follows:</span></p>
<pre><span class="koboSpan" id="kobo.21.1">import socket</span><br/><span class="koboSpan" id="kobo.22.1">s =socket.socket()</span><br/><span class="koboSpan" id="kobo.23.1">host=socket.gethostname()</span><br/><span class="koboSpan" id="kobo.24.1">port=60000</span><br/><span class="koboSpan" id="kobo.25.1">s.connect((host,port))</span><br/><span class="koboSpan" id="kobo.26.1">s.send('HelloServer!'.encode())</span><br/><span class="koboSpan" id="kobo.27.1">with open('received.txt','wb') as f:</span><br/><span class="koboSpan" id="kobo.28.1">    print ('file opened')</span><br/><span class="koboSpan" id="kobo.29.1">    while True :</span><br/><span class="koboSpan" id="kobo.30.1">        print ('receiving data...')</span><br/><span class="koboSpan" id="kobo.31.1">        data=s.recv(1024)</span><br/><span class="koboSpan" id="kobo.32.1">        if not data:</span><br/><span class="koboSpan" id="kobo.33.1">            break</span><br/><span class="koboSpan" id="kobo.34.1">        print ('Data=&gt;',data.decode())</span><br/><span class="koboSpan" id="kobo.35.1">        f.write(data)</span><br/><span class="koboSpan" id="kobo.36.1">f.close()</span><br/><span class="koboSpan" id="kobo.37.1">print ('Successfully get the file')</span><br/><span class="koboSpan" id="kobo.38.1">s.close()</span><br/><span class="koboSpan" id="kobo.39.1">print ('connection closed')</span></pre>
<p><span class="koboSpan" id="kobo.40.1">Here is the source code for </span><kbd><span class="koboSpan" id="kobo.41.1">client.py</span></kbd><span class="koboSpan" id="kobo.42.1">:</span></p>
<pre><span class="koboSpan" id="kobo.43.1">import socket</span><br/><span class="koboSpan" id="kobo.44.1">port=60000</span><br/><span class="koboSpan" id="kobo.45.1">s =socket.socket()</span><br/><span class="koboSpan" id="kobo.46.1">host=socket.gethostname()</span><br/><span class="koboSpan" id="kobo.47.1">s.bind((host,port))</span><br/><span class="koboSpan" id="kobo.48.1">s.listen(15)</span><br/><span class="koboSpan" id="kobo.49.1">print('Server listening....')</span><br/><span class="koboSpan" id="kobo.50.1">while True :</span><br/><span class="koboSpan" id="kobo.51.1">    conn,addr=s.accept()</span><br/><span class="koboSpan" id="kobo.52.1">    print ('Got connection from',addr)</span><br/><span class="koboSpan" id="kobo.53.1">    data=conn.recv(1024)</span><br/><span class="koboSpan" id="kobo.54.1">    print ('Server received',repr(data.decode()))</span><br/><span class="koboSpan" id="kobo.55.1">    filename='mytext.txt'</span><br/><span class="koboSpan" id="kobo.56.1">    f =open(filename,'rb')</span><br/><span class="koboSpan" id="kobo.57.1">    l =f.read(1024)</span><br/><span class="koboSpan" id="kobo.58.1">    while True:</span><br/><span class="koboSpan" id="kobo.59.1">        conn.send(l)</span><br/><span class="koboSpan" id="kobo.60.1">        print ('Sent',repr(l.decode()))</span><br/><span class="koboSpan" id="kobo.61.1">        l =f.read(1024)</span><br/><span class="koboSpan" id="kobo.62.1">        f.close()</span><br/><span class="koboSpan" id="kobo.63.1">        print ('Done sending')</span><br/><span class="koboSpan" id="kobo.64.1">        conn.send('-&gt;Thank you for connecting'.encode())</span><br/><span class="koboSpan" id="kobo.65.1">        conn.close()</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Types of sockets</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We can distinguish between the following three types of sockets, which are characterized by connection modes:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.3.1">Stream sockets</span></strong><span class="koboSpan" id="kobo.4.1">: These are connection-oriented sockets, and they are based on reliable protocols such as TCP or SCTP.</span></li>
<li><strong><span class="koboSpan" id="kobo.5.1">Datagram</span></strong> <strong><span class="koboSpan" id="kobo.6.1">sockets</span></strong><span class="koboSpan" id="kobo.7.1">: </span><span><span class="koboSpan" id="kobo.8.1">These are</span></span><span class="koboSpan" id="kobo.9.1"> not connection-oriented (connectionless) sockets, and are based on the fast but unreliable UDP protocol.</span></li>
<li><strong><span class="koboSpan" id="kobo.10.1">Raw socket</span></strong><span><span class="koboSpan" id="kobo.11.1"> </span></span><span class="koboSpan" id="kobo.12.1">(raw IP): The transport level is bypassed, and the header is accessible at the application level.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Stream sockets</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We will see more in particular of this type of socket</span><span><span class="koboSpan" id="kobo.3.1"> only</span></span><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">Being based on transport layer protocols such as TCP, they guarantee a reliable, full-duplex, and connection-oriented communication, with a variable-length byte stream.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Communication through this socket consists of these phases:</span></p>
<ol>
<li><strong><span class="koboSpan" id="kobo.6.1">Creation of sockets</span></strong><span class="koboSpan" id="kobo.7.1">: Clients and servers create their respective sockets, and the server listens to them on a port. </span><span class="koboSpan" id="kobo.7.2">Since the server can create multiple connections with different clients (but also with the same one), it needs a queue to handle the various requests.</span></li>
<li><strong><span class="koboSpan" id="kobo.8.1">Connection request</span></strong><span class="koboSpan" id="kobo.9.1">: The client requests a connection to the server. </span><span class="koboSpan" id="kobo.9.2">Note that we can have different port numbers because one could only be assigned to the outgoing traffic, and the other only to entry. </span><span class="koboSpan" id="kobo.9.3">This depends on the host configuration. </span><span class="koboSpan" id="kobo.9.4">Essentially, the client's local port does not necessarily coincide with the server's remote port. </span><span class="koboSpan" id="kobo.9.5">The server receives the request and, if accepted, a new connection is created. In the diagram, the port of the client socket is </span><kbd><span class="koboSpan" id="kobo.10.1">8080</span></kbd><span class="koboSpan" id="kobo.11.1">, while for the socket server, the port is </span><kbd><span class="koboSpan" id="kobo.12.1">80</span></kbd><span class="koboSpan" id="kobo.13.1">.</span></li>
<li><strong><span class="koboSpan" id="kobo.14.1">Communication</span></strong><span class="koboSpan" id="kobo.15.1">: Now, the client and server communicate through a virtual channel, between the client's socket, and a new socket (server side)</span><em><span class="koboSpan" id="kobo.16.1">,</span></em><span class="koboSpan" id="kobo.17.1"> created specifically for the data flow of this connection: a data socket. </span><span class="koboSpan" id="kobo.17.2">As it was mentioned in the first phase, the server creates the data socket because the first data socket is used exclusively for managing requests. </span><span class="koboSpan" id="kobo.17.3">T</span><span><span class="koboSpan" id="kobo.18.1">herefore, </span></span><span class="koboSpan" id="kobo.19.1">it is possible that there are many clients communicating with the server, each with the data socket specifically created by the server for them.</span></li>
<li><strong><span class="koboSpan" id="kobo.20.1">Closure of the connection</span></strong><span class="koboSpan" id="kobo.21.1">: Since the TCP is a connection-oriented protocol when there is no longer a need to communicate, the client communicates it to the server, which deallocates the data socket.</span></li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.22.1">The phases of communication through stream sockets are shown in the following diagram:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.23.1"><img src="assets/4a04807a-ed49-44eb-9f21-2346ea59f835.png" style="width:28.83em;height:27.75em;"/></span></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span class="koboSpan" id="kobo.24.1">     S</span><span><span class="koboSpan" id="kobo.25.1">tream socket phases</span></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">More information on Python sockets can be found at </span><a href="https://docs.python.org/3/howto/sockets.html"><span class="koboSpan" id="kobo.3.1">https://docs.python.org/3/howto/sockets.html</span></a><span class="koboSpan" id="kobo.4.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Distributed task management with Celery</span></h1>
                </header>
            
            <article>
                
<p><em><span class="koboSpan" id="kobo.2.1">Celery</span></em><span class="koboSpan" id="kobo.3.1"> is a Python framework that manages distributed tasks by following the</span><em><span class="koboSpan" id="kobo.4.1"> </span></em><span class="koboSpan" id="kobo.5.1">object-oriented middleware approach. </span><span class="koboSpan" id="kobo.5.2">Its main feature is handling many small tasks and distributing them on many computational nodes. </span><span class="koboSpan" id="kobo.5.3">Finally, the result of each task will then be reworked in order to compose the overall solution.</span></p>
<p><span class="koboSpan" id="kobo.6.1">To use Celery, a message broker is required. </span><span class="koboSpan" id="kobo.6.2">This is an independent (from Celery) software component that has the function of middleware, which is used to send and receive messages to distributed task workers</span><span class="hps"><span class="koboSpan" id="kobo.7.1">.</span></span></p>
<p><span class="hps"><span class="koboSpan" id="kobo.8.1">In fact, a message broker—also known as message middleware—deals with the exchange of messages in a communication network.: the addressing scheme of this type of middleware is no longer of the point-to-point </span><span><span class="koboSpan" id="kobo.9.1">type,</span></span><span class="koboSpan" id="kobo.10.1"> but is message-oriented addressing.</span></span></p>
<p><span class="hps"><span class="koboSpan" id="kobo.11.1">The reference architecture, with which the message broker manages the exchange of messages, is based on the so-called publish/subscribe</span></span><span class="koboSpan" id="kobo.12.1"> paradigm, which is </span><span class="hps"><span class="koboSpan" id="kobo.13.1">depicted as follows:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.14.1"><img src="assets/081ba83c-57b4-44c6-aaa5-89f6d9e0989c.png" style="width:41.25em;height:26.58em;"/></span></p>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign"><span class="hps"><span class="koboSpan" id="kobo.15.1">Message broker architecture</span></span></div>
<p><span class="koboSpan" id="kobo.16.1">Celery supports many types of brokers. </span><span class="koboSpan" id="kobo.16.2">However, the more complete ones are RabbitMQ and Redis.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To install Celery, use the </span><kbd><span class="koboSpan" id="kobo.3.1">pip</span></kbd><span class="koboSpan" id="kobo.4.1"> installer as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.5.1">C:\&gt;pip install celery</span></strong></pre>
<p><span class="koboSpan" id="kobo.6.1">Then, a message broker must be installed. </span><span class="koboSpan" id="kobo.6.2">There are several choices available, but for our example, it is recommended to install RabbitMQ from the following link: </span><a href="http://www.rabbitmq.com/download.html"><span class="koboSpan" id="kobo.7.1">http://www.rabbitmq.com/download.html</span></a><span class="koboSpan" id="kobo.8.1">.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.9.1">RabbitMQ </span><span class="hps"><span class="koboSpan" id="kobo.10.1">is </span></span><span class="hps"><span class="koboSpan" id="kobo.11.1">a </span></span><span class="hps"><span class="koboSpan" id="kobo.12.1">message-</span></span><span class="koboSpan" id="kobo.13.1">oriented middleware that implements</span><span class="hps"><span class="koboSpan" id="kobo.14.1"> the</span></span> <strong><span class="koboSpan" id="kobo.15.1">Advanced Message Queuing Protocol</span></strong><span class="koboSpan" id="kobo.16.1"> (</span><strong><span class="koboSpan" id="kobo.17.1">AMQP</span></strong><span class="koboSpan" id="kobo.18.1">). </span><span class="koboSpan" id="kobo.18.2">The RabbitMQ server is written in the Erlang </span><span class="hps"><span class="koboSpan" id="kobo.19.1">programming language, so in order to install it, you need to install Erlang after downloading it from</span></span><span class="koboSpan" id="kobo.20.1"> </span><a href="http://www.erlang.org/download.html"><span class="koboSpan" id="kobo.21.1">http://www.erlang.org/download.html</span></a><span class="koboSpan" id="kobo.22.1">.</span></div>
<div><span class="koboSpan" id="kobo.23.1">The steps involved are as follows:</span></div>
<ol>
<li><span class="koboSpan" id="kobo.24.1">To check the </span><kbd><span class="koboSpan" id="kobo.25.1">celery</span></kbd><span class="koboSpan" id="kobo.26.1"> installation, first start the message broker (for example, RabbitMQ). </span><span class="koboSpan" id="kobo.26.2">Then, type the following:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.27.1">C:\&gt;celery --version</span></strong></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.28.1">The following output, which indicates the </span><kbd><span><span class="koboSpan" id="kobo.29.1">celery</span></span></kbd><span><span class="koboSpan" id="kobo.30.1"> version, is as follows:</span></span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.31.1">4.2.2 (Windowlicker)</span></strong></pre>
<p><span class="koboSpan" id="kobo.32.1">Next, let's learn about how to create and call a task using the </span><span class="hps"><kbd><span class="koboSpan" id="kobo.33.1">celery</span></kbd><span class="koboSpan" id="kobo.34.1"> module.</span></span></p>
<p><kbd><span class="koboSpan" id="kobo.35.1">celery</span></kbd><span class="hps"><span class="koboSpan" id="kobo.36.1"> provides the following two methods to perform a call to a task:</span></span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.37.1">apply_async(args[, kwargs[, ...]])</span></kbd><span class="koboSpan" id="kobo.38.1">: This sends a task message.</span></li>
<li><kbd><span class="koboSpan" id="kobo.39.1">delay(*args, **kwargs)</span></kbd><span class="koboSpan" id="kobo.40.1">: </span><span><span class="koboSpan" id="kobo.41.1">This</span></span><span class="koboSpan" id="kobo.42.1"> is a shortcut to send a task message, but it does not support execution options.</span></li>
</ul>
<div class="packt_infobox"><span class="koboSpan" id="kobo.43.1">The </span><kbd><span class="koboSpan" id="kobo.44.1">delay</span></kbd><span class="koboSpan" id="kobo.45.1"> method is easier to use because it is called as a</span><strong><span><span class="koboSpan" id="kobo.46.1"> </span></span><span class="koboSpan" id="kobo.47.1">regular function</span></strong><span class="koboSpan" id="kobo.48.1">: </span><kbd><span class="koboSpan" id="kobo.49.1">task.delay(arg1, arg2, kwarg1='x', kwarg2='y')</span></kbd><span class="koboSpan" id="kobo.50.1">. </span><span class="koboSpan" id="kobo.50.2">However</span><span class="hps"><span class="koboSpan" id="kobo.51.1">, </span></span><span class="hps"><span class="koboSpan" id="kobo.52.1">for</span></span><span><span class="koboSpan" id="kobo.53.1"> </span></span><kbd><span class="koboSpan" id="kobo.54.1">apply_async</span></kbd><span class="koboSpan" id="kobo.55.1">, </span><span class="hps"><span class="koboSpan" id="kobo.56.1">the syntax is </span></span><kbd><span class="koboSpan" id="kobo.57.1">task.apply_async (args=[arg1,arg2] kwargs={'kwarg1':'x','kwarg2': 'y'})</span></kbd><span class="koboSpan" id="kobo.58.1">.</span></div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Windows setup</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In order to use Celery in a Windows environment, you must perform the following procedure:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.3.1">Go to </span><span class="packt_screen"><span class="koboSpan" id="kobo.4.1">System Properties</span></span><span class="koboSpan" id="kobo.5.1"> | </span><span class="packt_screen"><span class="koboSpan" id="kobo.6.1">Environment Variables</span></span><span class="koboSpan" id="kobo.7.1"> | </span><span class="packt_screen"><span class="koboSpan" id="kobo.8.1">User or System variables</span></span><span class="koboSpan" id="kobo.9.1"> | </span><span class="packt_screen"><span class="koboSpan" id="kobo.10.1">New</span></span><span class="koboSpan" id="kobo.11.1">.</span></li>
<li><span class="koboSpan" id="kobo.12.1">Set the following values:</span></li>
</ol>
<ul>
<li style="padding-left: 30px"><span class="koboSpan" id="kobo.13.1">Variable name: </span><kbd><span class="koboSpan" id="kobo.14.1">FORKED_BY_MULTIPROCESSING</span></kbd></li>
<li style="padding-left: 30px"><span class="koboSpan" id="kobo.15.1">Variable value: </span><kbd><span class="koboSpan" id="kobo.16.1">1</span></kbd></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">The reason for this setup is because of Celery's dependence on the </span><kbd><span class="koboSpan" id="kobo.18.1">billiard</span></kbd><span class="koboSpan" id="kobo.19.1"> package (</span><a href="https://github.com/celery/billiard"><span class="koboSpan" id="kobo.20.1">https://github.com/celery/billiard</span></a><span class="koboSpan" id="kobo.21.1">), which uses the </span><kbd><span class="koboSpan" id="kobo.22.1">FORKED_BY_MULTIPROCESSING</span></kbd><span class="koboSpan" id="kobo.23.1"> </span><span><span class="koboSpan" id="kobo.24.1">variable.</span></span></p>
<p><span><span class="koboSpan" id="kobo.25.1">For more information on Celery's Windows setup, read </span></span><a href="https://www.distributedpython.com/2018/08/21/celery-4-windows/"><span class="koboSpan" id="kobo.26.1">https://www.distributedpython.com/2018/08/21/celery-4-windows/</span></a><span><span class="koboSpan" id="kobo.27.1">.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The task here is a sum of two numbers. </span><span class="koboSpan" id="kobo.2.2">To perform this easy task, we have to compose the </span><kbd><span class="koboSpan" id="kobo.3.1">addTask.py</span></kbd><span class="koboSpan" id="kobo.4.1"> and </span><kbd><span class="koboSpan" id="kobo.5.1">addTask_main.py</span></kbd><span class="koboSpan" id="kobo.6.1"> </span><span><span class="koboSpan" id="kobo.7.1">script files:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.8.1">For </span><kbd><span class="koboSpan" id="kobo.9.1">addTask.py</span></kbd><span class="koboSpan" id="kobo.10.1">, start to import the Celery framework as follows:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.11.1">from celery import Celery</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.12.1">Then, define the task. </span><span class="koboSpan" id="kobo.12.2">In our example, the task is a sum of two numbers:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.13.1">app = Celery('tasks', broker='amqp://guest@localhost//')</span><br/><span class="koboSpan" id="kobo.14.1">@app.task</span><br/><span class="koboSpan" id="kobo.15.1">def add(x, y):</span><br/><span class="koboSpan" id="kobo.16.1">    return x + y</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.17.1">Now, import the </span><kbd><span class="koboSpan" id="kobo.18.1">addTask.py</span></kbd><span class="koboSpan" id="kobo.19.1"> file that was defined previously into </span><kbd><span class="koboSpan" id="kobo.20.1">addtask_main.py</span></kbd><span class="koboSpan" id="kobo.21.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.22.1">import addTask</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.23.1">Then, call </span><kbd><span class="koboSpan" id="kobo.24.1">addTask.py</span></kbd><span class="koboSpan" id="kobo.25.1"> to execute the sum of two numbers:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.26.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.27.1">    result = addTask.add.delay(5,5)</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="hps"><span class="koboSpan" id="kobo.2.1">In order to use Celery, the first thing to do is to run the</span></span><span class="koboSpan" id="kobo.3.1"> RabbitMQ </span><span class="hps"><span class="koboSpan" id="kobo.4.1">service, and then execute the Celery worker server (that is, the</span></span><span class="koboSpan" id="kobo.5.1"> </span><kbd><span class="koboSpan" id="kobo.6.1">addTask.py</span></kbd><span class="koboSpan" id="kobo.7.1"> file script) by </span><span class="hps"><span class="koboSpan" id="kobo.8.1">typing the following:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.9.1">C:\&gt;celery -A addTask worker --loglevel=info</span></strong></pre>
<p><span class="hps"><span class="koboSpan" id="kobo.10.1">The output is as follows:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.11.1">Microsoft Windows [Versione 10.0.17134.648]</span></strong><br/><strong><span class="koboSpan" id="kobo.12.1">(c) 2018 Microsoft Corporation. </span><span class="koboSpan" id="kobo.12.2">Tutti i diritti sono riservati.</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.13.1">C:\Users\Giancarlo&gt;cd C:\Users\Giancarlo\Desktop\Python Parallel Programming CookBook 2nd edition\Python Parallel Programming NEW BOOK\chapter_6 - Distributed Python\esempi</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.14.1">C:\Users\Giancarlo\Desktop\Python Parallel Programming CookBook 2nd edition\Python Parallel Programming NEW BOOK\chapter_6 - Distributed Python\esempi&gt;celery -A addTask worker --loglevel=info</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.15.1"> -------------- celery@pc-giancarlo v4.2.2 (windowlicker)</span></strong><br/><strong><span class="koboSpan" id="kobo.16.1">---- **** -----</span></strong><br/><strong><span class="koboSpan" id="kobo.17.1">--- * *** * -- Windows-10.0.17134 2019-04-01 21:32:37</span></strong><br/><strong><span class="koboSpan" id="kobo.18.1">-- * - **** ---</span></strong><br/><strong><span class="koboSpan" id="kobo.19.1">- ** ---------- [config]</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1">- ** ---------- .&gt; app: tasks:0x1deb8f46940</span></strong><br/><strong><span class="koboSpan" id="kobo.21.1">- ** ---------- .&gt; transport: amqp://guest:**@localhost:5672//</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">- ** ---------- .&gt; results: disabled://</span></strong><br/><strong><span class="koboSpan" id="kobo.23.1">- *** --- * --- .&gt; concurrency: 4 (prefork)</span></strong><br/><strong><span class="koboSpan" id="kobo.24.1">-- ******* ---- .&gt; task events: OFF (enable -E to monitor tasks in this worker)</span></strong><br/><strong><span class="koboSpan" id="kobo.25.1">--- ***** -----</span></strong><br/><strong><span class="koboSpan" id="kobo.26.1"> -------------- [queues]</span></strong><br/><strong><span class="koboSpan" id="kobo.27.1">                .&gt; celery exchange=celery(direct) key=celery</span></strong><br/><strong><span class="koboSpan" id="kobo.28.1">[tasks]</span></strong><br/><strong><span class="koboSpan" id="kobo.29.1">  . </span><span class="koboSpan" id="kobo.29.2">addTask.add</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.30.1">[2019-04-01 21:32:37,650: INFO/MainProcess] Connected to amqp://guest:**@127.0.0.1:5672//</span></strong><br/><strong><span class="koboSpan" id="kobo.31.1">[2019-04-01 21:32:37,745: INFO/MainProcess] mingle: searching for neighbors</span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">[2019-04-01 21:32:39,353: INFO/MainProcess] mingle: all alone</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">[2019-04-01 21:32:39,479: INFO/SpawnPoolWorker-2] child process 10712 calling self.run()</span></strong><br/><strong><span class="koboSpan" id="kobo.34.1">[2019-04-01 21:32:39,512: INFO/SpawnPoolWorker-3] child process 10696 calling self.run()</span></strong><br/><strong><span class="koboSpan" id="kobo.35.1">[2019-04-01 21:32:39,536: INFO/MainProcess] celery@pc-giancarlo ready.</span></strong><br/><strong><span class="koboSpan" id="kobo.36.1">[2019-04-01 21:32:39,551: INFO/SpawnPoolWorker-1] child process 6084 calling self.run()</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">[2019-04-01 21:32:39,615: INFO/SpawnPoolWorker-4] child process 2080 calling self.run()</span></strong></pre>
<p><span class="hps"><span class="koboSpan" id="kobo.38.1">Then, the second script is launched using Python:</span></span></p>
<pre><strong><span class="koboSpan" id="kobo.39.1">C:\&gt;python addTask_main.py</span></strong></pre>
<p><span class="koboSpan" id="kobo.40.1">Finally, the result should be as follows in the first Command Prompt:</span></p>
<pre><strong><span class="koboSpan" id="kobo.41.1">[2019-04-01 21:33:00,451: INFO/MainProcess] Received task: addTask.add[6fc350a9-e925-486c-bc41-c239ebd96041]</span></strong><br/><strong><span class="koboSpan" id="kobo.42.1">[2019-04-01 21:33:00,452: INFO/SpawnPoolWorker-2] Task addTask.add[6fc350a9-e925-486c-bc41-c239ebd96041] succeeded in 0.0s: 10</span></strong></pre>
<p class="packt_figure"><span class="koboSpan" id="kobo.43.1">As you can see, the result is </span><kbd><span class="koboSpan" id="kobo.44.1">10</span></kbd><span class="koboSpan" id="kobo.45.1">. </span><span class="koboSpan" id="kobo.45.2">Let's focus on the first script, </span><kbd><span class="koboSpan" id="kobo.46.1">addTask.py</span></kbd><span class="koboSpan" id="kobo.47.1">: in the first two lines of code, we create a </span><kbd><span class="koboSpan" id="kobo.48.1">Celery</span></kbd><span class="koboSpan" id="kobo.49.1"> application instance that uses the RabbitMQ service broker:</span></p>
<pre><span class="koboSpan" id="kobo.50.1">from celery import Celery</span><br/><span class="koboSpan" id="kobo.51.1">app = Celery('addTask', broker='amqp://guest@localhost//')</span></pre>
<p><span class="koboSpan" id="kobo.52.1">The first argument in the </span><kbd><span class="koboSpan" id="kobo.53.1">Celery</span></kbd><span class="koboSpan" id="kobo.54.1"> function is the name of the current module (</span><kbd><span class="koboSpan" id="kobo.55.1">addTask.py</span></kbd><span class="koboSpan" id="kobo.56.1">), and the second is the broker keyboard argument; this indicates the URL that is used to connect the broker (RabbitMQ).</span></p>
<p><span class="koboSpan" id="kobo.57.1">Now, let's introduce the task to be accomplished.</span></p>
<p><span class="koboSpan" id="kobo.58.1">Each task must be added with the </span><kbd><span class="koboSpan" id="kobo.59.1">@app.task</span></kbd><span class="koboSpan" id="kobo.60.1"> </span><span><span class="koboSpan" id="kobo.61.1">annotation (namely, </span></span><span class="koboSpan" id="kobo.62.1">decorator</span><span><span class="koboSpan" id="kobo.63.1">); </span></span><span class="koboSpan" id="kobo.64.1">the decorator helps </span><kbd><span class="koboSpan" id="kobo.65.1">Celery</span></kbd><span class="koboSpan" id="kobo.66.1"> to identify which functions can be scheduled in the task queue.</span></p>
<p><span class="koboSpan" id="kobo.67.1">After the decorator, we create the task that the workers can execute: this will be a simple function that performs the sum of two numbers:</span></p>
<pre><span class="koboSpan" id="kobo.68.1">@app.task</span><br/><span class="koboSpan" id="kobo.69.1">def add(x, y):</span><br/><span class="koboSpan" id="kobo.70.1">    return x + y</span></pre>
<p><span class="koboSpan" id="kobo.71.1">In the second script, </span><kbd><span class="koboSpan" id="kobo.72.1">addTask_main.py</span></kbd><span class="koboSpan" id="kobo.73.1">, we call our task by using the </span><kbd><span class="koboSpan" id="kobo.74.1">delay()</span></kbd><span class="koboSpan" id="kobo.75.1"> method:</span></p>
<pre><span class="koboSpan" id="kobo.76.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.77.1">    result = addTask.add.delay(5,5)</span></pre>
<p><span class="koboSpan" id="kobo.78.1">Let's remember that this method is a shortcut to the </span><kbd><span class="koboSpan" id="kobo.79.1">apply_async()</span></kbd><span class="koboSpan" id="kobo.80.1"> method, which gives us greater control over the task execution.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Celery usage is very simple. </span><span class="koboSpan" id="kobo.2.2">It can be executed by using the following commands:</span></p>
<pre class="mce-root"><strong><span class="koboSpan" id="kobo.3.1">Usage: celery &lt;command&gt; [options]</span></strong></pre>
<p><span class="koboSpan" id="kobo.4.1">Here, the options are as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.5.1">positional arguments:</span></strong><br/><strong><span class="koboSpan" id="kobo.6.1">  args</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.7.1">optional arguments:</span></strong><br/><strong><span class="koboSpan" id="kobo.8.1">  -h, --help             show this help message and exit</span></strong><br/><strong><span class="koboSpan" id="kobo.9.1">  --version              show program's version number and exit</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.10.1">Global Options:</span></strong><br/><strong><span class="koboSpan" id="kobo.11.1">  -A APP, --app APP</span></strong><br/><strong><span class="koboSpan" id="kobo.12.1">  -b BROKER, --broker BROKER</span></strong><br/><strong><span class="koboSpan" id="kobo.13.1">  --result-backend RESULT_BACKEND</span></strong><br/><strong><span class="koboSpan" id="kobo.14.1">  --loader LOADER</span></strong><br/><strong><span class="koboSpan" id="kobo.15.1">  --config CONFIG</span></strong><br/><strong><span class="koboSpan" id="kobo.16.1">  --workdir WORKDIR</span></strong><br/><strong><span class="koboSpan" id="kobo.17.1">  --no-color, -C</span></strong><br/><strong><span class="koboSpan" id="kobo.18.1">  --quiet, -q</span></strong></pre>
<p style="font-weight: 400"><span class="koboSpan" id="kobo.19.1">The main commands are as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.20.1">+ Main:</span></strong><br/><strong><span class="koboSpan" id="kobo.21.1">| celery worker</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">| celery events</span></strong><br/><strong><span class="koboSpan" id="kobo.23.1">| celery beat</span></strong><br/><strong><span class="koboSpan" id="kobo.24.1">| celery shell</span></strong><br/><strong><span class="koboSpan" id="kobo.25.1">| celery multi</span></strong><br/><strong><span class="koboSpan" id="kobo.26.1">| celery amqp</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.27.1">+ Remote Control:</span></strong><br/><strong><span class="koboSpan" id="kobo.28.1">| celery status</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.29.1">| celery inspect --help</span></strong><br/><strong><span class="koboSpan" id="kobo.30.1">| celery inspect active</span></strong><br/><strong><span class="koboSpan" id="kobo.31.1">| celery inspect active_queues</span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">| celery inspect clock</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">| celery inspect conf [include_defaults=False]</span></strong><br/><strong><span class="koboSpan" id="kobo.34.1">| celery inspect memdump [n_samples=10]</span></strong><br/><strong><span class="koboSpan" id="kobo.35.1">| celery inspect memsample</span></strong><br/><strong><span class="koboSpan" id="kobo.36.1">| celery inspect objgraph [object_type=Request] [num=200 [max_depth=10]]</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">| celery inspect ping</span></strong><br/><strong><span class="koboSpan" id="kobo.38.1">| celery inspect query_task [id1 [id2 [... </span><span class="koboSpan" id="kobo.38.2">[idN]]]]</span></strong><br/><strong><span class="koboSpan" id="kobo.39.1">| celery inspect registered [attr1 [attr2 [... </span><span class="koboSpan" id="kobo.39.2">[attrN]]]]</span></strong><br/><strong><span class="koboSpan" id="kobo.40.1">| celery inspect report</span></strong><br/><strong><span class="koboSpan" id="kobo.41.1">| celery inspect reserved</span></strong><br/><strong><span class="koboSpan" id="kobo.42.1">| celery inspect revoked</span></strong><br/><strong><span class="koboSpan" id="kobo.43.1">| celery inspect scheduled</span></strong><br/><strong><span class="koboSpan" id="kobo.44.1">| celery inspect stats</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.45.1">| celery control --help</span></strong><br/><strong><span class="koboSpan" id="kobo.46.1">| celery control add_consumer &lt;queue&gt; [exchange [type [routing_key]]]</span></strong><br/><strong><span class="koboSpan" id="kobo.47.1">| celery control autoscale [max [min]]</span></strong><br/><strong><span class="koboSpan" id="kobo.48.1">| celery control cancel_consumer &lt;queue&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.49.1">| celery control disable_events</span></strong><br/><strong><span class="koboSpan" id="kobo.50.1">| celery control election</span></strong><br/><strong><span class="koboSpan" id="kobo.51.1">| celery control enable_events</span></strong><br/><strong><span class="koboSpan" id="kobo.52.1">| celery control heartbeat</span></strong><br/><strong><span class="koboSpan" id="kobo.53.1">| celery control pool_grow [N=1]</span></strong><br/><strong><span class="koboSpan" id="kobo.54.1">| celery control pool_restart</span></strong><br/><strong><span class="koboSpan" id="kobo.55.1">| celery control pool_shrink [N=1]</span></strong><br/><strong><span class="koboSpan" id="kobo.56.1">| celery control rate_limit &lt;task_name&gt; &lt;rate_limit (e.g., 5/s | 5/m | </span><br/><span class="koboSpan" id="kobo.57.1">5/h)&gt;</span></strong><br/><strong><span class="koboSpan" id="kobo.58.1">| celery control revoke [id1 [id2 [... </span><span class="koboSpan" id="kobo.58.2">[idN]]]]</span></strong><br/><strong><span class="koboSpan" id="kobo.59.1">| celery control shutdown</span></strong><br/><strong><span class="koboSpan" id="kobo.60.1">| celery control terminate &lt;signal&gt; [id1 [id2 [... </span><span class="koboSpan" id="kobo.60.2">[idN]]]]</span></strong><br/><strong><span class="koboSpan" id="kobo.61.1">| celery control time_limit &lt;task_name&gt; &lt;soft_secs&gt; [hard_secs]</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.62.1">+ Utils:</span></strong><br/><strong><span class="koboSpan" id="kobo.63.1">| celery purge</span></strong><br/><strong><span class="koboSpan" id="kobo.64.1">| celery list</span></strong><br/><strong><span class="koboSpan" id="kobo.65.1">| celery call</span></strong><br/><strong><span class="koboSpan" id="kobo.66.1">| celery result</span></strong><br/><strong><span class="koboSpan" id="kobo.67.1">| celery migrate</span></strong><br/><strong><span class="koboSpan" id="kobo.68.1">| celery graph</span></strong><br/><strong><span class="koboSpan" id="kobo.69.1">| celery upgrade</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.70.1">+ Debugging:</span></strong><br/><strong><span class="koboSpan" id="kobo.71.1">| celery report</span></strong><br/><strong><span class="koboSpan" id="kobo.72.1">| celery logtool</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.73.1">+ Extensions:</span></strong><br/><strong><span class="koboSpan" id="kobo.74.1">| celery flower</span></strong><br/><strong><span class="koboSpan" id="kobo.75.1">-------------------------------------------------------------</span></strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.76.1">Celery protocol can be implemented in any language by using Webhooks (</span><a href="https://developer.github.com/webhooks/"><span class="koboSpan" id="kobo.77.1">https://developer.github.com/webhooks/</span></a><span class="koboSpan" id="kobo.78.1">). </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<ul>
<li><span class="koboSpan" id="kobo.2.1">More information on Celery can be found at </span><a href="http://www.celeryproject.org/"><span class="koboSpan" id="kobo.3.1">http://www.celeryproject.org/</span></a><span class="koboSpan" id="kobo.4.1">.</span></li>
<li><span><span class="koboSpan" id="kobo.5.1">The recommended</span></span><span class="koboSpan" id="kobo.6.1"> message brokers (</span><a href="https://en.wikipedia.org/wiki/Message_broker"><span class="koboSpan" id="kobo.7.1">https://en.wikipedia.org/wiki/Message_broker</span></a><span class="koboSpan" id="kobo.8.1">)</span><span><span class="koboSpan" id="kobo.9.1"> are </span></span><span class="koboSpan" id="kobo.10.1">RabbitMQ (</span><a href="https://en.wikipedia.org/wiki/RabbitMQ"><span class="koboSpan" id="kobo.11.1">https://en.wikipedia.org/wiki/RabbitMQ</span></a><span class="koboSpan" id="kobo.12.1">) </span><span><span class="koboSpan" id="kobo.13.1">or </span></span><span class="koboSpan" id="kobo.14.1">Redis (</span><a href="https://en.wikipedia.org/wiki/Redis"><span class="koboSpan" id="kobo.15.1">https://en.wikipedia.org/wiki/Redis</span></a><span class="koboSpan" id="kobo.16.1">)</span><span><span class="koboSpan" id="kobo.17.1">. </span><span class="koboSpan" id="kobo.17.2">Additionally, there is </span></span><span class="koboSpan" id="kobo.18.1">MongoDB (</span><a href="https://en.wikipedia.org/wiki/MongoDB"><span class="koboSpan" id="kobo.19.1">https://en.wikipedia.org/wiki/MongoDB</span></a><span class="koboSpan" id="kobo.20.1">)</span><span><span class="koboSpan" id="kobo.21.1">,</span></span><span class="koboSpan" id="kobo.22.1"> Beanstalk</span><span><span class="koboSpan" id="kobo.23.1">, </span></span><span class="koboSpan" id="kobo.24.1">Amazon SQS (</span><a href="https://en.wikipedia.org/wiki/Amazon_Simple_Queue_Service"><span class="koboSpan" id="kobo.25.1">https://en.wikipedia.org/wiki/Amazon_Simple_Queue_Service</span></a><span class="koboSpan" id="kobo.26.1">), CouchDB (</span><a href="https://en.wikipedia.org/wiki/Apache_CouchDB"><span class="koboSpan" id="kobo.27.1">https://en.wikipedia.org/wiki/Apache_CouchDB</span></a><span class="koboSpan" id="kobo.28.1">), and IronMQ (</span><a href="https://www.iron.io/mq"><span class="koboSpan" id="kobo.29.1">https://www.iron.io/mq</span></a><span class="koboSpan" id="kobo.30.1">)</span><span><span class="koboSpan" id="kobo.31.1">.</span></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">RMI with Pyro4</span></h1>
                </header>
            
            <article>
                
<p><strong><span class="koboSpan" id="kobo.2.1">Pyro </span></strong><span class="koboSpan" id="kobo.3.1">is short for </span><strong><span class="koboSpan" id="kobo.4.1">Python Remote Objects</span></strong><span class="koboSpan" id="kobo.5.1">. It works exactly like the Java </span><strong><span class="koboSpan" id="kobo.6.1">RMI </span></strong><span class="koboSpan" id="kobo.7.1">(short for </span><strong><span class="koboSpan" id="kobo.8.1">Remote Method Invocation</span></strong><span class="koboSpan" id="kobo.9.1">) allowing to invoke a method of a remote object (belonging to a different process) exactly as if the object were local (belonging to the same process in which the invocation runs).</span></p>
<p><span class="koboSpan" id="kobo.10.1">The use of an RMI mechanism, in an object-oriented system, involves significant advantages of uniformity and symmetry in the project, as this mechanism enables the modelling of interactions between distributed processes using the same conceptual tool. </span></p>
<p><span class="koboSpan" id="kobo.11.1">As you can see from the following diagram, </span><kbd><span class="koboSpan" id="kobo.12.1">Pyro4</span></kbd><span class="koboSpan" id="kobo.13.1"> enables objects to be distributed in a client/server style; this means that the main parts of a </span><kbd><span class="koboSpan" id="kobo.14.1">Pyro4</span></kbd><span class="koboSpan" id="kobo.15.1"> system may switch from a client caller to a remote object, which is called to serve a function:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.16.1"><img src="assets/1782750b-b3f5-4ac1-8274-f01d46cff0ec.png" style="width:35.17em;height:23.33em;"/></span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.17.1">RMI</span></div>
<p><span class="koboSpan" id="kobo.18.1">It is important to note that during the remote calling, there are always two distinct parts: a client and a server that accept and execute the client call.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The entire method of managing this mechanism in a distributed way is provided by </span><kbd><span class="koboSpan" id="kobo.3.1">Pyro4</span></kbd><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">To install the latest release of </span><kbd><span class="koboSpan" id="kobo.5.1">Pyro4</span></kbd><span class="koboSpan" id="kobo.6.1">, use the </span><kbd><span class="koboSpan" id="kobo.7.1">pip</span></kbd><span class="koboSpan" id="kobo.8.1"> installer (Windows installation is used here) and add the following command:</span></p>
<pre><strong><span class="koboSpan" id="kobo.9.1">C:\&gt;pip install Pyro4</span></strong></pre>
<p><span class="koboSpan" id="kobo.10.1">We are using the </span><kbd><span class="koboSpan" id="kobo.11.1">pyro_server.py</span></kbd><span class="koboSpan" id="kobo.12.1"> and </span><kbd><span class="koboSpan" id="kobo.13.1">pyro_client.py</span></kbd> <span><span class="koboSpan" id="kobo.14.1">codes for this recipe.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this example, we'll see how to build and use a simple client-server communication</span><span><span class="koboSpan" id="kobo.3.1"> using the </span><kbd><span class="koboSpan" id="kobo.4.1">Pyro4</span></kbd><span class="koboSpan" id="kobo.5.1"> middleware.</span></span><span><span class="koboSpan" id="kobo.6.1"> </span></span><span><span class="koboSpan" id="kobo.7.1">The code for the client is</span></span> <kbd><span class="koboSpan" id="kobo.8.1">pyro_server.py</span></kbd><span><span class="koboSpan" id="kobo.9.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.10.1">Import the </span><kbd><span class="koboSpan" id="kobo.11.1">Pyro4</span></kbd><span class="koboSpan" id="kobo.12.1"> library:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.13.1">import Pyro4</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.14.1">Define the </span><kbd><span class="koboSpan" id="kobo.15.1">Server</span></kbd><span class="koboSpan" id="kobo.16.1"> class that contains the </span><kbd><span class="koboSpan" id="kobo.17.1">welcomeMessage()</span></kbd><span class="koboSpan" id="kobo.18.1"> method that will be exposed:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.19.1">class Server(object):</span><br/><span class="koboSpan" id="kobo.20.1">    @Pyro4.expose</span><br/><span class="koboSpan" id="kobo.21.1">    def welcomeMessage(self, name):</span><br/><span class="koboSpan" id="kobo.22.1">        return ("Hi welcome " + str (name))</span></pre>
<div class="packt_tip"><span class="koboSpan" id="kobo.23.1">Note that the decorator, </span><kbd><span class="koboSpan" id="kobo.24.1">@Pyro4.expose</span></kbd><span class="koboSpan" id="kobo.25.1">, means that the preceding method will be remotely accessible.</span></div>
<ol start="3">
<li><span class="koboSpan" id="kobo.26.1">The </span><kbd><span class="koboSpan" id="kobo.27.1">startServer</span></kbd><span class="koboSpan" id="kobo.28.1"> </span><span><span class="koboSpan" id="kobo.29.1">function </span></span><span class="koboSpan" id="kobo.30.1">contains all the instructions that are used to start the server:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.31.1">def startServer():</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.32.1">Next, build the </span><kbd><span class="koboSpan" id="kobo.33.1">server</span></kbd><span class="koboSpan" id="kobo.34.1"> </span><span><span class="koboSpan" id="kobo.35.1">instance </span></span><span class="koboSpan" id="kobo.36.1">of the </span><kbd><span class="koboSpan" id="kobo.37.1">Server</span></kbd><span class="koboSpan" id="kobo.38.1"> class:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.39.1">server = Server()</span></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.40.1">Then, define the </span><kbd><span class="koboSpan" id="kobo.41.1">Pyro4</span></kbd><span class="koboSpan" id="kobo.42.1"> daemon: </span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.43.1">daemon = Pyro4.Daemon()</span></pre>
<ol start="6">
<li><span class="koboSpan" id="kobo.44.1">To execute this script, we must run a </span><kbd><span class="koboSpan" id="kobo.45.1">Pyro4</span></kbd><span class="koboSpan" id="kobo.46.1"> statement to locate a nameserver:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.47.1">ns = Pyro4.locateNS()</span></pre>
<ol start="7">
<li><span class="koboSpan" id="kobo.48.1">Register the object server as </span><em><span class="koboSpan" id="kobo.49.1">Pyro object</span></em><span class="koboSpan" id="kobo.50.1">; it will </span><span><span class="koboSpan" id="kobo.51.1">only </span></span><span class="koboSpan" id="kobo.52.1">be known inside the Pyro daemon:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.53.1">uri = daemon.register(server)</span></pre>
<ol start="8">
<li><span class="koboSpan" id="kobo.54.1">Now, we can register the object server with a name in the nameserver:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.55.1">ns.register("server", uri)</span></pre>
<ol start="9">
<li><span class="koboSpan" id="kobo.56.1">The function ends with a call to the daemon's </span><kbd><span class="koboSpan" id="kobo.57.1">requestLoop</span></kbd><span class="koboSpan" id="kobo.58.1"> method. </span><span class="koboSpan" id="kobo.58.2">This starts the event loop of the server and waits for calls:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.59.1">print("Ready. </span><span class="koboSpan" id="kobo.59.2">Object uri =", uri)</span><br/><span class="koboSpan" id="kobo.60.1">daemon.requestLoop()</span></pre>
<ol start="10">
<li><span class="koboSpan" id="kobo.61.1">Finally, call </span><kbd><span class="koboSpan" id="kobo.62.1">startServer</span></kbd><span class="koboSpan" id="kobo.63.1"> via the </span><kbd><span class="koboSpan" id="kobo.64.1">main</span></kbd><span class="koboSpan" id="kobo.65.1"> program:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.66.1">if __name__ == "__main__":</span><br/><span class="koboSpan" id="kobo.67.1">    startServer()</span></pre>
<p><span class="koboSpan" id="kobo.68.1">Here is the code for the client (</span><kbd><span class="koboSpan" id="kobo.69.1">pyro_client.py</span></kbd><span class="koboSpan" id="kobo.70.1">):</span></p>
<ol>
<li><span class="koboSpan" id="kobo.71.1">Import the </span><kbd><span class="koboSpan" id="kobo.72.1">Pyro4</span></kbd><span class="koboSpan" id="kobo.73.1"> library:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.74.1">import Pyro4</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.75.1">The </span><kbd><span class="koboSpan" id="kobo.76.1">Pyro4</span></kbd><span class="koboSpan" id="kobo.77.1"> API enables the developer to distribute objects in a transparent way. </span><span class="koboSpan" id="kobo.77.2">In this example, the client script sends requests to the server program in order to execute the </span><kbd><span class="koboSpan" id="kobo.78.1">welcomeMessage()</span></kbd><span class="koboSpan" id="kobo.79.1"> method:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.80.1">uri = input("What is the Pyro uri of the greeting object? </span><span class="koboSpan" id="kobo.80.2">").strip()</span><br/><span class="koboSpan" id="kobo.81.1">name = input("What is your name? </span><span class="koboSpan" id="kobo.81.2">").strip()</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.82.1">Then, the remote call is created: </span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.83.1">server = Pyro4.Proxy("PYRONAME:server")</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.84.1">Finally, the client calls the server, printing a message:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.85.1">print(server.welcomeMessage(name))</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The preceding example is composed of two main functions: </span><kbd><span class="koboSpan" id="kobo.3.1">pyro_server.py</span></kbd><span class="koboSpan" id="kobo.4.1"> and </span><kbd><span class="koboSpan" id="kobo.5.1">pyro_client.py</span></kbd><span class="koboSpan" id="kobo.6.1">.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.7.1">In </span><kbd><span class="koboSpan" id="kobo.8.1">pyro_server.py</span></kbd><span class="koboSpan" id="kobo.9.1">, the </span><kbd><span class="koboSpan" id="kobo.10.1">Server</span></kbd><span class="koboSpan" id="kobo.11.1"> class object provides the</span><span><span class="koboSpan" id="kobo.12.1"> </span></span><kbd><span class="koboSpan" id="kobo.13.1">welcomeMessage()</span></kbd><span><span class="koboSpan" id="kobo.14.1"> </span></span><span class="koboSpan" id="kobo.15.1">method, returning a string equal to the name inserted in the client session:</span></p>
<pre><span class="koboSpan" id="kobo.16.1">class Server(object):</span><br/><span class="koboSpan" id="kobo.17.1">    @Pyro4.expose</span><br/><span class="koboSpan" id="kobo.18.1">    def welcomeMessage(self, name):</span><br/><span class="koboSpan" id="kobo.19.1">        return ("Hi welcome " + str (name))</span></pre>
<p><kbd><span class="koboSpan" id="kobo.20.1">Pyro4</span></kbd><span class="koboSpan" id="kobo.21.1"> uses daemon objects to dispatch incoming calls to appropriate objects. </span><span class="koboSpan" id="kobo.21.2">A server must create just one daemon that manages everything from its instance. </span><span class="koboSpan" id="kobo.21.3">Each server has a daemon that knows about all the Pyro objects that the server provides:</span></p>
<pre><span class="koboSpan" id="kobo.22.1"> daemon = Pyro4.Daemon()</span></pre>
<p><span class="koboSpan" id="kobo.23.1">As for the </span><kbd><span class="koboSpan" id="kobo.24.1">pyro_client.py</span></kbd><span class="koboSpan" id="kobo.25.1"> function, the remote call is first performed and creates a </span><kbd><span class="koboSpan" id="kobo.26.1">Proxy</span></kbd><span class="koboSpan" id="kobo.27.1"> object. </span><span class="koboSpan" id="kobo.27.2">In particular, the </span><kbd><span class="koboSpan" id="kobo.28.1">Pyro4</span></kbd><span class="koboSpan" id="kobo.29.1"> client uses proxy objects to forward method calls to the remote objects, and then passes the results back to the calling code:</span></p>
<pre><span class="koboSpan" id="kobo.30.1">server = Pyro4.Proxy("PYRONAME:server")</span></pre>
<p><span class="koboSpan" id="kobo.31.1">In order to execute a client-server connection, we need to have a </span><kbd><span class="koboSpan" id="kobo.32.1">Pyro4</span></kbd><span class="koboSpan" id="kobo.33.1"> nameserver running. </span><span class="koboSpan" id="kobo.33.2">In Command Prompt, type the following:</span></p>
<pre><strong><span class="koboSpan" id="kobo.34.1">C:\&gt;python -m Pyro4.naming</span></strong></pre>
<p><span class="koboSpan" id="kobo.35.1">After this, you'll see the following message:</span></p>
<pre><strong><span class="koboSpan" id="kobo.36.1">Not starting broadcast server for localhost.</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">NS running on localhost:9090 (127.0.0.1)</span></strong><br/><strong><span class="koboSpan" id="kobo.38.1">Warning: HMAC key not set. </span><span class="koboSpan" id="kobo.38.2">Anyone can connect to this server!</span></strong><br/><strong><span class="koboSpan" id="kobo.39.1">URI = PYRO:Pyro.NameServer@localhost:9090</span></strong></pre>
<p><span class="koboSpan" id="kobo.40.1">The preceding message means that the name</span><span><span class="koboSpan" id="kobo.41.1">server is running in your network. </span><span class="koboSpan" id="kobo.41.2">Finally, we can start the server and the client scripts in two separate</span></span><span class="koboSpan" id="kobo.42.1"> Windows consoles:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.43.1">To run </span><kbd><span class="koboSpan" id="kobo.44.1">pyro_server.py</span></kbd><span class="koboSpan" id="kobo.45.1">, just type the following:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.46.1">C:\&gt;python pyro_server.py</span></strong></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.47.1">Following that, you'll see something like this:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.48.1">Ready. </span><span class="koboSpan" id="kobo.48.2">Object uri = PYRO:obj_76046e1c9d734ad5b1b4f6a61ee77425@localhost:63269</span></strong></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.49.1">Then, run the client by typing the following:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.50.1">C:\&gt;python pyro_client.py</span></strong></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.51.1">The following message will be printed out:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.52.1">What is your name? </span></strong></pre>
<ol start="5">
<li><span><span class="koboSpan" id="kobo.53.1">Insert a name (for example, </span></span><kbd><span class="koboSpan" id="kobo.54.1">Ruvika</span></kbd><span><span class="koboSpan" id="kobo.55.1">):</span></span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.56.1">What is your name? </span><span class="koboSpan" id="kobo.56.2">Ruvika</span></strong></pre>
<ol start="6">
<li><span class="koboSpan" id="kobo.57.1">The </span><span><span class="koboSpan" id="kobo.58.1">following </span></span><span class="koboSpan" id="kobo.59.1">welcome message will be displayed:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.60.1">Hi welcome Ruvika</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Among the features of </span><kbd><span class="koboSpan" id="kobo.3.1">Pyro4</span></kbd><span class="koboSpan" id="kobo.4.1">, there is the creation of object topologies. </span><span class="koboSpan" id="kobo.4.2">For example, </span><span class="hps"><span class="koboSpan" id="kobo.5.1">let's suppose we want to build a distributed architecture that follows a chain topology, as follows:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.6.1"><img src="assets/7f93a4ab-70f7-4ecb-8a0b-f5633c11bad1.png" style="width:33.75em;height:23.67em;"/></span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="hps"><span class="koboSpan" id="kobo.7.1">Chaining objects with Pyro4</span></span></div>
<p><span class="koboSpan" id="kobo.8.1">The Client makes a request to </span><strong><span class="koboSpan" id="kobo.9.1">Server 1</span></strong><span class="koboSpan" id="kobo.10.1">, and then the request is </span><span><span class="koboSpan" id="kobo.11.1">forwarded </span></span><span class="koboSpan" id="kobo.12.1">to </span><strong><span class="koboSpan" id="kobo.13.1">Server </span><em><span class="koboSpan" id="kobo.14.1">2</span></em></strong><span class="koboSpan" id="kobo.15.1">, which then </span><span><span class="koboSpan" id="kobo.16.1">calls</span></span> <strong><span class="koboSpan" id="kobo.17.1">Server</span></strong> <strong><span class="koboSpan" id="kobo.18.1">3</span></strong><span class="koboSpan" id="kobo.19.1">. </span><span class="koboSpan" id="kobo.19.2">The chain call ends when </span><strong><span class="koboSpan" id="kobo.20.1">Server 3 </span></strong><span class="koboSpan" id="kobo.21.1">calls </span><strong><span class="koboSpan" id="kobo.22.1">Server 1</span></strong><span class="koboSpan" id="kobo.23.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Implementing chain topology</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To implement a chain topology using </span><kbd><span class="koboSpan" id="kobo.3.1">Pyro4</span></kbd><strong><span class="koboSpan" id="kobo.4.1">,</span></strong><span class="koboSpan" id="kobo.5.1"> we need to implement a </span><kbd><span class="koboSpan" id="kobo.6.1">chain</span></kbd><span class="koboSpan" id="kobo.7.1"> object and the </span><kbd><span class="koboSpan" id="kobo.8.1">client</span></kbd><span class="koboSpan" id="kobo.9.1"> and </span><kbd><span class="koboSpan" id="kobo.10.1">server</span></kbd><span class="koboSpan" id="kobo.11.1"> objects. </span><span class="koboSpan" id="kobo.11.2">The </span><kbd><span class="koboSpan" id="kobo.12.1">Chain</span></kbd><span class="koboSpan" id="kobo.13.1"> class allows the call to be </span><span><span class="koboSpan" id="kobo.14.1">redirected to </span></span><span class="koboSpan" id="kobo.15.1">the next server by processing the input message and reconstructing the server address to which the request should be addressed.</span></p>
<p><span class="koboSpan" id="kobo.16.1">Also note, in this case, the </span><kbd><span class="koboSpan" id="kobo.17.1">@Pyro4.expose</span></kbd><span class="koboSpan" id="kobo.18.1"> </span><span><span class="koboSpan" id="kobo.19.1">decorator,</span></span><span class="koboSpan" id="kobo.20.1"> which allows all the methods of the class (</span><kbd><span class="koboSpan" id="kobo.21.1">chainTopology.py</span></kbd><span class="koboSpan" id="kobo.22.1">) to be exposed:</span></p>
<pre><span class="koboSpan" id="kobo.23.1">import Pyro4</span><br/><br/><span class="koboSpan" id="kobo.24.1">@Pyro4.expose</span><br/><span class="koboSpan" id="kobo.25.1">class Chain(object):</span><br/><span class="koboSpan" id="kobo.26.1">    def __init__(self, name, next_server):</span><br/><span class="koboSpan" id="kobo.27.1">        self.name = name</span><br/><span class="koboSpan" id="kobo.28.1">        self.next_serverName = next_server</span><br/><span class="koboSpan" id="kobo.29.1">        self.next_server = None</span><br/>    <br/><span class="koboSpan" id="kobo.30.1">    def process(self, message):</span><br/><span class="koboSpan" id="kobo.31.1">        if self.next_server is None:</span><br/><span class="koboSpan" id="kobo.32.1">            self.next_server = Pyro4.core.Proxy("PYRONAME:example.\</span><br/><span class="koboSpan" id="kobo.33.1">                chainTopology." </span><span class="koboSpan" id="kobo.33.2">+ self.next_serverName)</span></pre>
<p><span class="koboSpan" id="kobo.34.1">If the chain is closed (the last call is done from </span><kbd><span class="koboSpan" id="kobo.35.1">server_chain_3.py</span></kbd><span class="koboSpan" id="kobo.36.1"> to </span><kbd><span class="koboSpan" id="kobo.37.1">server_chain_1.py</span></kbd><span class="koboSpan" id="kobo.38.1">), then a closing message is printed out:</span></p>
<pre><span class="koboSpan" id="kobo.39.1">       if self.name in message:</span><br/><span class="koboSpan" id="kobo.40.1">            print("Back at %s;the chain is closed!" </span><span class="koboSpan" id="kobo.40.2">% self.name)</span><br/><span class="koboSpan" id="kobo.41.1">            return ["complete at " + self.name]</span></pre>
<p><span class="koboSpan" id="kobo.42.1">A forwarding message is printed out if there is a next element in the chain:</span></p>
<pre><span class="koboSpan" id="kobo.43.1">        else:</span><br/><span class="koboSpan" id="kobo.44.1">            print("%s forwarding the message to the object %s" %\ </span><br/><span class="koboSpan" id="kobo.45.1">                (self.name, self.next_serverName))</span><br/><span class="koboSpan" id="kobo.46.1">            message.append(self.name)</span><br/><span class="koboSpan" id="kobo.47.1">            result = self.next_server.process(message)</span><br/><span class="koboSpan" id="kobo.48.1">            result.insert(0, "passed on from " + self.name)</span><br/><span class="koboSpan" id="kobo.49.1">            return result</span></pre>
<p><span class="koboSpan" id="kobo.50.1">Next, we have the source code for the client (</span><kbd><span class="koboSpan" id="kobo.51.1">client_chain.py</span></kbd><span class="koboSpan" id="kobo.52.1">):</span></p>
<pre><span class="koboSpan" id="kobo.53.1">import Pyro4</span><br/><br/><span class="koboSpan" id="kobo.54.1">obj = Pyro4.core.Proxy("PYRONAME:example.chainTopology.1")</span><br/><span class="koboSpan" id="kobo.55.1">print("Result=%s" % obj.process(["hello"]))</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p><span class="koboSpan" id="kobo.56.1">Following this is the source code for the first server (namely, </span><kbd><span class="koboSpan" id="kobo.57.1">server_1</span></kbd><span class="koboSpan" id="kobo.58.1">) in the chain that is called from the client</span><span><span class="koboSpan" id="kobo.59.1"> (</span></span><kbd><span class="koboSpan" id="kobo.60.1">server_chain_1.py</span></kbd><span><span class="koboSpan" id="kobo.61.1">). </span></span><span class="koboSpan" id="kobo.62.1">Here, the relevant libraries are imported. </span><span class="koboSpan" id="kobo.62.2">Note, the import to the </span><kbd><span class="koboSpan" id="kobo.63.1">chainTopology.py</span></kbd> <span><span class="koboSpan" id="kobo.64.1">file that was </span></span><span class="koboSpan" id="kobo.65.1">described previously:</span></p>
<pre><span class="koboSpan" id="kobo.66.1">import Pyro4</span><br/><span class="koboSpan" id="kobo.67.1">import chainTopology</span></pre>
<p><span class="koboSpan" id="kobo.68.1">Note also that the source code for the servers only differs as regards the definitions of the current and the next servers of the chain:</span></p>
<pre><span class="koboSpan" id="kobo.69.1">current_server= "1"</span><br/><span class="koboSpan" id="kobo.70.1">next_server = "2"</span></pre>
<p><span class="koboSpan" id="kobo.71.1">The remaining lines of code define the communication with the next element in the chain:</span></p>
<pre><span class="koboSpan" id="kobo.72.1">servername = "example.chainTopology." </span><span class="koboSpan" id="kobo.72.2">+ current_server</span><br/><span class="koboSpan" id="kobo.73.1">daemon = Pyro4.core.Daemon()</span><br/><span class="koboSpan" id="kobo.74.1">obj = chainTopology.Chain(current_server, next_server)</span><br/><span class="koboSpan" id="kobo.75.1">uri = daemon.register(obj)</span><br/><span class="koboSpan" id="kobo.76.1">ns = Pyro4.locateNS()</span><br/><span class="koboSpan" id="kobo.77.1">ns.register(servername, uri)</span><br/><span class="koboSpan" id="kobo.78.1">print("server_%s started " % current_server)</span><br/><span class="koboSpan" id="kobo.79.1">daemon.requestLoop()</span></pre>
<p><span class="koboSpan" id="kobo.80.1">To execute this example, first run the </span><kbd><span class="koboSpan" id="kobo.81.1">Pyro4</span></kbd><span class="koboSpan" id="kobo.82.1"> nameserver:</span></p>
<pre><strong><span class="koboSpan" id="kobo.83.1">C:\&gt;python -m Pyro4.naming</span></strong><br/><strong><span class="koboSpan" id="kobo.84.1">Not starting broadcast server for localhost.</span></strong><br/><strong><span class="koboSpan" id="kobo.85.1">NS running on localhost:9090 (127.0.0.1)</span></strong><br/><strong><span class="koboSpan" id="kobo.86.1">Warning: HMAC key not set. </span><span class="koboSpan" id="kobo.86.2">Anyone can connect to this server!</span></strong><br/><strong><span class="koboSpan" id="kobo.87.1">URI = PYRO:Pyro.NameServer@localhost:9090</span></strong></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.88.1">Run the three servers in three different terminals, typing each of them respectively  (Windows terminals are used here):</span></p>
<p><span class="koboSpan" id="kobo.89.1">The first server (</span><span><kbd><span class="koboSpan" id="kobo.90.1">server_chain_1.py</span></kbd><span class="koboSpan" id="kobo.91.1">) </span></span><span class="koboSpan" id="kobo.92.1">in the first terminal:</span></p>
<pre><strong><span class="koboSpan" id="kobo.93.1">C:\&gt;python server_chain_1.py</span></strong></pre>
<p><span class="koboSpan" id="kobo.94.1">Followed by the second server (</span><span><kbd><span class="koboSpan" id="kobo.95.1">server_chain_2.py</span></kbd><span class="koboSpan" id="kobo.96.1">) </span></span><span class="koboSpan" id="kobo.97.1">in the second terminal:</span></p>
<pre><strong><span class="koboSpan" id="kobo.98.1">C:\&gt;python server_chain_2.py</span></strong></pre>
<p><span class="koboSpan" id="kobo.99.1">And finally, the third server  (</span><span><kbd><span class="koboSpan" id="kobo.100.1">server_chain_3.py</span></kbd><span class="koboSpan" id="kobo.101.1">) </span></span><span class="koboSpan" id="kobo.102.1">in the third terminal:</span></p>
<pre><strong><span class="koboSpan" id="kobo.103.1">C:\&gt;python server_chain_3.py</span></strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.104.1">Then, run the </span><kbd><span class="koboSpan" id="kobo.105.1">client_chain.py</span></kbd><span class="koboSpan" id="kobo.106.1"> script from another terminal:</span></p>
<pre><strong><span class="koboSpan" id="kobo.107.1">C:\&gt;python client_chain.py</span></strong></pre>
<p><span class="koboSpan" id="kobo.108.1">This is the output, as shown in the Command Prompt:</span></p>
<pre><strong><span class="koboSpan" id="kobo.109.1">Result=['passed on from 1','passed on from 2','passed on from 3','complete at 1']</span></strong></pre>
<p><span class="koboSpan" id="kobo.110.1">The preceding message is displayed as a result of the forwarding request passed across the three servers after it returned the fact that </span><span><span class="koboSpan" id="kobo.111.1">the task is completed</span></span><span class="koboSpan" id="kobo.112.1"> to </span><kbd><span class="koboSpan" id="kobo.113.1">server_chain_1</span></kbd><span class="koboSpan" id="kobo.114.1">.</span></p>
<p><span class="koboSpan" id="kobo.115.1">Also, we can focus on the behavior of the object servers while the request is forwarded to the next object in the chain (refer to the message underneath the start message):</span></p>
<ol>
<li><strong><kbd><span class="koboSpan" id="kobo.116.1">server_ 1</span></kbd></strong><span class="koboSpan" id="kobo.117.1"> is started and the following message is forwarded to </span><kbd><span class="koboSpan" id="kobo.118.1">server_ 2</span></kbd><span class="koboSpan" id="kobo.119.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.120.1">server_1 started</span></strong><br/><strong><span class="koboSpan" id="kobo.121.1">1 forwarding the message to the object 2</span></strong></pre>
<ol start="2">
<li><kbd><span class="koboSpan" id="kobo.122.1">server_</span><strong><span class="koboSpan" id="kobo.123.1"> </span></strong><span class="koboSpan" id="kobo.124.1">2</span></kbd><span class="koboSpan" id="kobo.125.1"> forwards the following message to </span><kbd><span class="koboSpan" id="kobo.126.1">server_</span><strong><span class="koboSpan" id="kobo.127.1"> </span></strong><span class="koboSpan" id="kobo.128.1">3</span></kbd><span class="koboSpan" id="kobo.129.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.130.1">server_2 started</span></strong><br/><strong><span class="koboSpan" id="kobo.131.1">2 forwarding the message to the object 3</span></strong></pre>
<ol start="3">
<li><kbd><span class="koboSpan" id="kobo.132.1">server_ </span><span><span class="koboSpan" id="kobo.133.1">3</span></span></kbd><span class="koboSpan" id="kobo.134.1"> forwards the following message to </span><kbd><span class="koboSpan" id="kobo.135.1">server_</span><strong><span class="koboSpan" id="kobo.136.1"> </span></strong><span class="koboSpan" id="kobo.137.1">1</span></kbd><span class="koboSpan" id="kobo.138.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.139.1">server_3 started</span></strong><br/><strong><span class="koboSpan" id="kobo.140.1">3 forwarding the message to the object 1</span></strong></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.141.1">Finally, the message returns to the starting point (in other words, </span><kbd><span class="koboSpan" id="kobo.142.1">server_1</span></kbd><span><span class="koboSpan" id="kobo.143.1">)</span></span><span class="koboSpan" id="kobo.144.1">, closing the chain :</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.145.1">server_1 started</span></strong><br/><strong><span class="koboSpan" id="kobo.146.1">1 forwarding the message to the object 2</span></strong><br/><strong><span class="koboSpan" id="kobo.147.1">Back at 1; the chain is closed!</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">Pyro4</span></kbd><span class="koboSpan" id="kobo.4.1"> documentation is available at </span><a href="https://buildmedia.readthedocs.org/media/pdf/pyro4/stable/pyro4.pdf"><span class="MsoHyperlink"><span class="koboSpan" id="kobo.5.1">https://buildmedia.readthedocs.org/media/pdf/pyro4/stable/pyro4.pdf</span></span></a><span class="koboSpan" id="kobo.6.1">.</span></p>
<p><span class="koboSpan" id="kobo.7.1">This contains a description and some application examples of the 4.75 release.</span></p>


            </article>

            
        </section>
    </body></html>