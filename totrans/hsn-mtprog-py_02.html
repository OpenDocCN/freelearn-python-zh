<html><head></head><body>
<div><div><h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor014"/>Chapter 1</em>: The Need for and Applications of Metaprogramming</h1>
<p><em class="italic">Metaprogramming with Python</em> is a practical guide to learning metaprogramming in Python. </p>
<p>In today’s programming world, Python is considered one of the easiest languages to learn and use to develop useful applications. Understanding the programming concepts and applying them is easier in Python compared to any other programming language. A Python program can be written simply by adding existing libraries and making use of their inbuilt methods. At the same time, the language also has many powerful features that can help in developing robust libraries and applications. </p>
<p>This book covers the need for one of the most advanced features in Python, called metaprogramming, along with insights into its practical applications. Understanding the concepts of metaprogramming helps in tapping into the advanced features of Python 3 and knowing where to apply them to make Python code more reusable.</p>
<p>Unlike the regular Python-based application development that follows object-oriented programming, metaprogramming covers certain advanced concepts of Python that deal with manipulating the programmable objects of Python, such as its classes, methods, functions, and variables. Throughout this book, we will look at applications and examples that help in understanding these concepts in a user-friendly manner.</p>
<p>In this chapter, we will provide an introduction to metaprogramming and the need to perform metaprogramming using Python 3. We will cover the following topics:</p>
<ul>
<li>An overview of metaprogramming</li>
<li>Understanding why we need metaprogramming</li>
<li>Exploring the applications of metaprogramming</li>
</ul>
<p>By the end of this chapter, you will have a high-level understanding of metaprogramming in Python 3, the need for using it, and know of a few practical examples where it can be applied.</p>
<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Technical requirements</h1>
<p>The code examples in this chapter are available on GitHub repository for this chapter at <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter01">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter01</a>.</p>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>An overview of metaprogramming</h1>
<p><strong class="bold">Metaprogramming</strong> is a <a id="_idIndexMarker000"/>concept widely heard of in other programming languages such as C++, Java, .NET, and Ruby but not so widely heard of in Python. Python<a id="_idIndexMarker001"/> is a programming language that is easy to learn for beginners to programming and efficient to implement for advanced programmers. Therefore, it has an additional advantage in improving efficiency and optimization while developing high-performance applications when techniques such as metaprogramming are blended with the process of application development.</p>
<p>In this book, we will deep dive into the concepts of metaprogramming using Python 3.</p>
<p>The term <strong class="bold">meta</strong>, as the name suggests, is<a id="_idIndexMarker002"/> a process that references itself or its the high-level information. In the context of programming, metaprogramming also describes the similar concept of a program referencing itself or a program object referencing itself. A program referencing itself or its entity gives data on the program or the programming entity that can be used at various levels to perform activities, such as transformations or manipulations, in a programming language.</p>
<p>To understand the term <strong class="bold">meta</strong>, let’s<a id="_idIndexMarker003"/> consider the term <em class="italic">metadata</em>. As an example, let’s look at a Python DataFrame. For those who are not familiar with the term DataFrame, we can use the term <em class="italic">table</em>. The one shown in the following screenshot is called <em class="italic">Employee Data</em>:</p>
<div><div><img alt="Figure 1.1 – Employee Data table " height="138" src="img/B13426_01_01.jpg" width="405"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Employee Data table</p>
<p>This Employee Data table consists of employee information such as the name of the employee, employee ID, qualification, experience, salary, and so on. </p>
<p>All of this information are attributes of single or multiple employees, and it is the data of employees in an organization. So, what will the metadata be? The<strong class="bold"> m</strong><strong class="bold">etadata</strong> is <a id="_idIndexMarker004"/>the data of how employee data is stored in the Employee Data table. </p>
<p>The metadata for the <a id="_idIndexMarker005"/>Employee Data table defines how each column and its values are stored in the table. For example, in the following screenshot, we can see metadata where <strong class="bold">Name</strong> is stored as a string with a length of 64 characters, while <strong class="bold">Salary</strong> is stored as a <strong class="bold">Float</strong> with a length of 12 digits:</p>
<div><div><img alt="Figure 1.2 – Metadata representation for the Employee Data table " height="950" src="img/B13426_01_02.jpg" width="1623"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Metadata representation for the Employee Data table</p>
<p>Accessing, modifying, transforming, and updating the Employee Data table using information such as the name or ID of an employee is data manipulation, while accessing, modifying, transforming, and updating the data type or size of the column name or <a id="_idIndexMarker006"/>employee ID or salary, is metadata manipulation.</p>
<p>With this understanding, let’s look at an example of metaprogramming.</p>
<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Metaprogramming – a practical introduction</h2>
<p>Any programming<a id="_idIndexMarker007"/> language that can be used to write code to perform actions consists of a basic unit or piece of code that can be written to perform an action. This is known as a function.</p>
<p>If we have two numbers stored in two variables, <code>a</code> and <code>b</code>, to perform an <code>add</code> action, you can simply add those two numbers by writing a function, as shown in the following code block:</p>
<pre class="source-code">def add(a,b):    </pre>
<pre class="source-code">    c = a + b    </pre>
<pre class="source-code">    return c  </pre>
<p>Now, if we execute this code, it can go through different scenarios, depending on the input data provided to the <code>add</code> function. Let’s take a close look at each of them. </p>
<p><strong class="bold">Scenario 1</strong></p>
<p>Running the <code>add</code> function with two integers would result in two numbers being added together, as follows:</p>
<pre class="source-code">add(1,3)  </pre>
<pre class="source-code"><strong class="bold">4</strong></pre>
<p><strong class="bold">Scenario 2</strong></p>
<p>Running the <code>add</code> function with two strings would result in the concatenation of two words, as follows:</p>
<pre class="source-code">add('meta','program')   </pre>
<pre class="source-code"><strong class="bold">metaprogram</strong></pre>
<p><strong class="bold">Scenario 3</strong></p>
<p>Let’s take a look at running the <code>add</code> function with one string and one integer:</p>
<pre class="source-code">add('meta',1)  </pre>
<p>The<a id="_idIndexMarker008"/> preceding code would result in the following error:</p>
<div><div><img alt="Figure 1.3 – TypeError " height="241" src="img/B13426_01_03.jpg" width="730"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – TypeError</p>
<p>Let’s examine this error in detail.</p>
<p>The error in the preceding code snippet denotes a <code>TypeError</code>, which was caused by an attempt to add a <code>meta</code> string with an integer of <code>1</code>. The question that may occur to you is, <em class="italic">can we resolve this error using metaprogramming</em>?</p>
<p>The <code>add</code> function in this example denotes a piece of code or program, similar to how the Employee Data table in <em class="italic">Figure 1.1</em> denotes data. In the same line, can we identify the metadata of the <code>add</code> function and use it to resolve the <code>TypeError</code> object returned by <a id="_idIndexMarker009"/>the following code:</p>
<pre class="source-code">add('meta',1)  </pre>
<p>Next, we will look at a practical example of metaprogramming. We will be making use of the metadata of the <code>add</code> function to understand this concept.</p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Metadata of the add function</h2>
<p>A function in<a id="_idIndexMarker010"/> any programming language is written to perform a set<a id="_idIndexMarker011"/> of operations on the input variables; it will return the results as a consequence of the operations performed on them. In this section, we will look at a simple example of a function that adds two variables. This will help us understand that metaprogramming can be applied to functions and manipulate the behavior of the function without modifying the algorithm of the function. We will be adding these two variables by writing an <code>add</code> function. To change the results of the <code>add</code> function, we <a id="_idIndexMarker012"/>will be<a id="_idIndexMarker013"/> manipulating the metadata of its two input variables, thus getting different results each time a different type of input variable is provided to execute the function. Just like we can manipulate what a function should do by writing lines of code to perform various operations, we can also manipulate the function itself by programming its metadata and setting restrictions on what it should and shouldn’t do. Just like a dataset, DataFrame, or table has data and metadata, a program or a function in Python 3 also has data and metadata. In this example, we will be manipulating the actions that are performed by the <code>add</code> function by restricting its behavior – not based on the input data provided to the function but on the <em class="italic">type</em> of input data provided to the <code>add</code> function instead. Take a look at the following screenshot:</p>
<div><div><img alt="Figure 1.4 – Examining the data and metadata of the add function " height="413" src="img/B13426_01_04.jpg" width="1130"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Examining the data and metadata of the add function</p>
<p>The<a id="_idIndexMarker014"/> following code<a id="_idIndexMarker015"/> helps us identify the metadata for each data item in the <code>add</code> function:</p>
<pre class="source-code">def add(a,b):    </pre>
<pre class="source-code">    c = a +  b    </pre>
<pre class="source-code">    print ("Metadata of add", type(add))    </pre>
<pre class="source-code">    print ("Metadata of a", type(a))    </pre>
<pre class="source-code">    print ("Metadata of b", type(b))    </pre>
<pre class="source-code">    print ("Metadata of c", type(c))   </pre>
<p>A<a id="_idIndexMarker016"/> function call to the <a id="_idIndexMarker017"/>preceding function will now return the metadata of the <code>add</code> function instead of its result. Now, let’s call the <code>add</code> method with an integer as input:</p>
<pre class="source-code">add(1,3)  </pre>
<p>We’ll get the following output:</p>
<pre class="source-code"><strong class="bold">Metadata of add &lt;class 'function'&gt;</strong></pre>
<pre class="source-code"><strong class="bold">Metadata of a &lt;class 'int'&gt;</strong></pre>
<pre class="source-code"><strong class="bold">Metadata of b &lt;class 'int'&gt;</strong></pre>
<pre class="source-code"><strong class="bold">Metadata of c &lt;class 'int'&gt;</strong></pre>
<p>Similarly, we can also check the addition of strings, as follows:</p>
<pre class="source-code">add('test','string')</pre>
<p>We’ll get the following output:</p>
<pre class="source-code"><strong class="bold">Metadata of add &lt;class 'function'&gt;</strong></pre>
<pre class="source-code"><strong class="bold">Metadata of a &lt;class 'str'&gt;</strong></pre>
<pre class="source-code"><strong class="bold">Metadata of b &lt;class 'str'&gt;</strong></pre>
<pre class="source-code"><strong class="bold">Metadata of c &lt;class 'str'&gt;</strong></pre>
<p>Python 3 allows us to use the metadata of the code to manipulate it so that it deviates from its actual behavior. This will also provide customized solutions for the problems we are trying to solve.</p>
<p>In the preceding example, we used the <code>type</code> function, a method in Python that returns the class or data type that any object or variable belongs to.</p>
<p>From the<a id="_idIndexMarker018"/> preceding output, it is evident that the <code>a</code> and <code>b</code> variables we passed<a id="_idIndexMarker019"/> to the <code>add</code> function belong to the integer data type, and its result, <code>c</code>, is an integer too. The <code>add</code> function itself is of the <code>function</code> class/type.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Resolving type errors using metaprogramming</h2>
<p>There <a id="_idIndexMarker020"/>are many variations on how we can<a id="_idIndexMarker021"/> resolve the type error from the <code>add</code> function we saw in the previous section using metaprogramming. We will look at this in this section.</p>
<p><strong class="bold">Scenario 1</strong></p>
<p>The following meta-program handles the error and allows the <code>add</code> function to add two strings or two integers. It also suggests that the user enters the input data with the right data types:</p>
<pre class="source-code">def add(a,b):</pre>
<pre class="source-code">    if (type(a) is str and type(b) is int) or\</pre>
<pre class="source-code">        (type(a) is int and type(b) is str):</pre>
<pre class="source-code">        return "Please enter both input values as integers or\</pre>
<pre class="source-code">          string"</pre>
<pre class="source-code">    else:</pre>
<pre class="source-code">        c = a + b</pre>
<pre class="source-code">        return c  </pre>
<p>In the function definition of <code>add</code>, we have added two conditions – one to check if the type of <code>a</code> is a string and the type of <code>b</code> is an int, or if the type of <code>a</code> is an int and the type of <code>b</code> is a string. We are checking the combination of these input variables to handle the type mismatch error and directing the users to provide the right data type for input variables.</p>
<p>The following table shows the various combinations of input variable data types and their corresponding output or results based on the conditions set on the metadata of the <code>add</code> function, based on <strong class="bold">Scenario 1</strong>:</p>
<div><div><img alt="Figure 1.5 – Scenario 1 metadata combinations " height="383" src="img/B13426_01_05.jpg" width="1160"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Scenario 1 metadata combinations</p>
<p>The<a id="_idIndexMarker022"/> following code executes the <code>add</code> function <a id="_idIndexMarker023"/>to reinforce the input-output combinations explained in <em class="italic">Figure 1.5</em>:</p>
<pre class="source-code">add(1,3)  </pre>
<pre class="source-code"><strong class="bold">4</strong></pre>
<pre class="source-code">add('meta','program')  </pre>
<pre class="source-code"><strong class="bold">metaprogram</strong></pre>
<pre class="source-code">add('meta',1)  </pre>
<pre class="source-code"><strong class="bold">'Please enter both input values as integers or string'</strong></pre>
<pre class="source-code">add(1,'meta')  </pre>
<pre class="source-code"><strong class="bold">'Please enter both input values as integers or string'</strong></pre>
<p><strong class="bold">Scenario 2</strong></p>
<p>The following meta-program resolves the type mismatch error by converting the mismatching data types into string variables and performing a string concatenation. It is only logical to concatenate a string and an integer using a <code>+</code> operator as we cannot perform arithmetic addition on these two different data types. Take a look at the following program:</p>
<pre class="source-code">def add(a,b):</pre>
<pre class="source-code">    if type(a) is int and type(b) is int:</pre>
<pre class="source-code">        c = a +  b</pre>
<pre class="source-code">        return c</pre>
<pre class="source-code">    elif type(a) is str and type(b) is int or\</pre>
<pre class="source-code">          type(a) is int and type(b) is str or \</pre>
<pre class="source-code">          type(a) is str and type(b) is str:</pre>
<pre class="source-code">        c = str(a) + str(b)</pre>
<pre class="source-code">        return c</pre>
<pre class="source-code">    else:</pre>
<pre class="source-code">        print("Please enter string or integer")</pre>
<p>Here, no <a id="_idIndexMarker024"/>matter what input we provide for<a id="_idIndexMarker025"/> the <code>a</code> and <code>b</code> variables, they both get converted into string variables and are then concatenated using <code>+</code>, whereas if both the input variables are integers, they get added using arithmetic addition.</p>
<p>The following table shows the various combinations of input variable data types and their corresponding output or results based on the conditions set on the metadata of the <code>add</code> function based on <strong class="bold">Scenario 2</strong>:</p>
<div><div><img alt="Figure 1.6 – Scenario 2 metadata combinations " height="419" src="img/B13426_01_06.jpg" width="596"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Scenario 2 metadata combinations</p>
<p>Executing the following code provides the combinations of output values we saw in the preceding table:</p>
<pre class="source-code">add(1343,35789)  </pre>
<pre class="source-code"><strong class="bold">37132</strong></pre>
<pre class="source-code">add('Meta',' Programming') <a id="_idTextAnchor020"/> </pre>
<pre class="source-code"><strong class="bold">'M<a id="_idTextAnchor021"/>etaProgramming'</strong></pre>
<pre class="source-code">add('meta',157676)  </pre>
<pre class="source-code"><strong class="bold">'meta157676'</strong></pre>
<pre class="source-code">add(65081, 'meta')  </pre>
<pre class="source-code"><strong class="bold">'65081meta'</strong></pre>
<pre class="source-code">add(True, 'meta')</pre>
<pre class="source-code">Please enter string or integer</pre>
<p><strong class="bold">Scenario 3</strong></p>
<p>Now, let’s<a id="_idIndexMarker026"/> go a step further and restrict the<a id="_idIndexMarker027"/> nature of the <code>add</code> function itself to ensure it only performs arithmetic addition and doesn’t accept any other data types or combinations of data types.</p>
<p>In the following code block, we have added another condition to perform a data type check on floating-point values, along with data type checks for the string and integer input values.</p>
<p>This function only accepts numeric values as input and will return a message directing users to input numbers so that only arithmetic addition is performed. Let’s look at the code:</p>
<pre class="source-code">def add(a,b):</pre>
<pre class="source-code">    if type(a) is int and type(b) is int or\</pre>
<pre class="source-code">       type(a) is float and type(b) is float or\</pre>
<pre class="source-code">       type(a) is int and type(b) is float or\</pre>
<pre class="source-code">       type(a) is float and type(b) is int:</pre>
<pre class="source-code">        c = a +  b</pre>
<pre class="source-code">        return c</pre>
<pre class="source-code">    else:</pre>
<pre class="source-code">        return 'Please input numbers'</pre>
<p>The following table shows the various combinations of input variable data types and their corresponding output or results based on the conditions set on the metadata of the <code>add</code> function based on <strong class="bold">Scenario 3</strong>:</p>
<div><div><img alt="Figure 1.7 – Scenario 3 metadata combinations " height="684" src="img/B13426_01_07.jpg" width="892"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Scenario 3 metadata combinations</p>
<p>Executing the <a id="_idIndexMarker028"/>following code provides the<a id="_idIndexMarker029"/> combination of output values shown in <em class="italic">Figure 1.7</em>, including the addition of floating-point values:</p>
<pre class="source-code">add(15443,675683)  </pre>
<pre class="source-code"><strong class="bold">691126</strong></pre>
<pre class="source-code">add(54381,3.7876)  </pre>
<pre class="source-code"><strong class="bold">54384.7876</strong></pre>
<pre class="source-code">add(6.7754,543.76)  </pre>
<pre class="source-code"><strong class="bold">550.5354</strong></pre>
<pre class="source-code">add(79894,0.6568)  </pre>
<pre class="source-code"><strong class="bold">79894.6568</strong></pre>
<pre class="source-code">add('meta',14684)  </pre>
<pre class="source-code"><strong class="bold">'Please input numbers'</strong></pre>
<pre class="source-code">add(6576,'meta')  </pre>
<pre class="source-code"><strong class="bold">'Please input numbers'</strong></pre>
<pre class="source-code">add('meta','program')  </pre>
<pre class="source-code">'Please input numbers'</pre>
<p>These <a id="_idIndexMarker030"/>are some of the approaches <a id="_idIndexMarker031"/>that can be applied to perform simple metaprogramming on a function. However, these are not the only solutions that solve type errors or manipulate a function. There is more than one way or approach to implementing solutions using metaprogramming.</p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor022"/>Understanding why we need metaprogramming</h1>
<p>Considering<a id="_idIndexMarker032"/> what we’ve learned about metaprogramming, we may be wondering the following:</p>
<p>“<em class="italic">Is it always mandatory to apply metaprogramming techniques or to manipulate the metadata of the code while developing applications using Python 3 or above?</em>”</p>
<p>This is a common question that can be asked not only while developing applications using Python 3 or above, but also when using any programming language that supports the techniques of metaprogramming and gives developers the option to apply them in the application development process.</p>
<p>To answer this question, it is important to understand the flexibility of metaprogramming and the techniques that are supported by Python to handle code manipulation, which will be covered throughout this book.</p>
<p>One of the reasons to apply metaprogramming is to avoid repetition in various aspects of the Python-based application development process. We will look at an example of this in the <em class="italic">Don’t Repeat Yourself</em> section.</p>
<p>In other words, introducing concepts such as code generators at the meta level can save development and execution time in functional- or domain-level programming. Domain-level programming corresponds to writing code for a particular domain, such as finance, networking, social media, and so on.</p>
<p>The other need is to increase the abstraction of your code at the program metadata level rather than at the functional level. <strong class="bold">Abstraction</strong> is <a id="_idIndexMarker033"/>the concept of information hiding in the literal sense or in terms of object-oriented programming. Implementing abstraction at the meta-program level would help us decide what information to provide to the next level of coding and what not to provide.</p>
<p>For example, developing a function template at the meta-program level would hide the function definition at the domain or functional level, as well as limit the amount of information that goes to the functional-level code.</p>
<p>Metaprogramming <a id="_idIndexMarker034"/>allows us to manipulate programs using metadata at the meta level, which helps define how the grammar and semantics of your program should be. For example, in the <em class="italic">Resolving type erors using metaprogramming</em> section, we looked at controlling the outcome of the data types of a function by manipulatin<a id="_idTextAnchor023"/>g the function’s variables.</p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor024"/>Don’t Repeat Yourself</h2>
<p>In any application <a id="_idIndexMarker035"/>development process, thousands of lines of code are written. Don’t Repeat Yourself is a principle defined by <em class="italic">Andy Hunt and Dave Thomas</em> in their book <em class="italic">The Pragmatic Programmer</em>. The principle states that “<em class="italic">Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.</em>”</p>
<p>While writing code, there are very high chances of writing multiple functions or methods that perform similar kinds of repetitive tasks, and the functions or methods, in turn, might be repetitive. This leads to redundancy in application development. The greatest disadvantage of redundancy is that when you make any modifications at one location, the implementation, modification, or code fixing needs to be repeated at multiple locations.</p>
<p>Libraries are developed with classes and methods, including object-oriented programming techniques such as abstraction, inheritance, encapsulation, and so on, to avoid redundancy and maintain coding standards as much as possible. Even then, there are chances of repetitive methods being within a class that can still be simplified.</p>
<p>Metaprogramming can help in handling such instances by implementing approaches such as dynamic code generation, dynamic function creation, and more. Throughout this book, we will be looking at various approaches that help you not to repeat yourself while developing applications.</p>
<p>To get a taste of how we can dynamically generate code and avoid repetitions, let’s look at a simple example<a id="_idIndexMarker036"/> where arithmetic operations are implemented as repetitive functions.</p>
<p>The <a id="_idIndexMarker037"/>following code consists of four basic arithmetic operations that can be performed on two numeric variables. We will be declaring and defining four functions that add, subtract, multiply, and divide two variables, <code>a</code> and <code>b</code>, store the result in a variable, <code>c</code>, and return it while the function is executed:</p>
<pre class="source-code">def add(a,b):  </pre>
<pre class="source-code">    c = a + b  </pre>
<pre class="source-code">    return c  </pre>
<pre class="source-code">  </pre>
<pre class="source-code">def sub(a,b):  </pre>
<pre class="source-code">    c = a - b  </pre>
<pre class="source-code">    return c  </pre>
<pre class="source-code">  </pre>
<pre class="source-code">def multiply(a,b):  </pre>
<pre class="source-code">    c = a * b  </pre>
<pre class="source-code">    return c  </pre>
<pre class="source-code">  </pre>
<pre class="source-code">def divide(a,b):  </pre>
<pre class="source-code">    c = a / b  </pre>
<pre class="source-code">    return c  </pre>
<p>Each of the preceding functions needs to be called separately and variables need to be provided as input to execute them individually, as follows:</p>
<pre class="source-code">add(2,5)  </pre>
<pre class="source-code"><strong class="bold">7</strong></pre>
<pre class="source-code">sub(2,5)  </pre>
<pre class="source-code"><strong class="bold">-3</strong></pre>
<pre class="source-code">multiply(2,5)  </pre>
<pre class="source-code"><strong class="bold">10</strong></pre>
<pre class="source-code">divide(2,5)  </pre>
<pre class="source-code"><strong class="bold">0.4</strong></pre>
<p>In this <a id="_idIndexMarker038"/>example, there is only one difference – the arithmetic operator that’s used in the function definition. This code can be simplified without implementing metaprogramming, just by declaring a new function that takes in an additional input variable operator.</p>
<p>Let’s learn how to avoid this repetitive function definition and simplify the logic. The following code block defines one common function that can be reused to perform all four arithmetic operations. Let’s start by importing Python’s inbuilt <code>module</code> operator, which contains methods that support multiple arithmetic operations:</p>
<pre class="source-code">import operator as op</pre>
<pre class="source-code">def arithmetic(a, b, operation):</pre>
<pre class="source-code">    result = operation(a, b)</pre>
<pre class="source-code">    return result</pre>
<p>In this code snippet, we have declared three variables, including the operation in the function arithmetic. Let’s see this in action:</p>
<pre class="source-code">arithmetic('2', '5', op.add) '25'</pre>
<p>Executing this function using input variables would return a concatenated string, <code>25</code>, that will serve the purpose of creating the common <code>arithmetic</code> function to perform multiple operations. We can look at providing various operations as input to see how this one common function serves multiple purposes.</p>
<p>Calling this function with different arithmetic operators would resolve the need for repetitive function definitions:</p>
<pre class="source-code">arithmetic(2, 5, op.add)</pre>
<pre class="source-code"><strong class="bold">7</strong></pre>
<pre class="source-code">arithmetic(2 , 5, op.sub)</pre>
<pre class="source-code"><strong class="bold">-3</strong></pre>
<pre class="source-code">arithmetic(2, 5, op.mul)</pre>
<pre class="source-code"><strong class="bold">10</strong></pre>
<pre class="source-code">arithmetic(2 , 5, op.truediv)</pre>
<pre class="source-code"><strong class="bold">0.4</strong></pre>
<p>This is one approach to resolving code redundancy and avoiding multiple function definitions. But what if we do not want to define the function itself until and unless it is required?</p>
<p>To answer this question, we can implement dynamic function creation using metaprogramming. Dynamic functions are created during the code’s runtime as and when they are required.</p>
<p>Although we<a id="_idIndexMarker039"/> are still in the introductory chapter, we will discuss an example of dynamic function creation next to get a view of what kind of programming will be covered throughout this book.</p>
<h3>Creating dynamic functions</h3>
<p>In this section, we’ll look at <a id="_idIndexMarker040"/>an example of how dynamic functions can be created for the same set of arithmetic operations we discussed earlier in this section.</p>
<p>To create an arithmetic function dynamically, we need to import the library types and the <code>FunctionType</code> type. <code>FunctionType</code> is the type of all user-defined functions created by users during the Python-based application development process:</p>
<pre class="source-code">from types import FunctionType  </pre>
<p>To begin this process, we will create a string variable that is a function definition of the arithmetic function:</p>
<pre class="source-code">functionstring = '''</pre>
<pre class="source-code">def arithmetic(a, b):</pre>
<pre class="source-code">    op = __import__('operator')</pre>
<pre class="source-code">    result = op.add(a, b)</pre>
<pre class="source-code">    return result</pre>
<pre class="source-code">    '''  </pre>
<pre class="source-code">print(functionstring)</pre>
<p>We’ll get the following output:</p>
<pre class="source-code"><strong class="bold"> def arithmetic(a, b):</strong></pre>
<pre class="source-code"><strong class="bold">    op = __import__('operator')</strong></pre>
<pre class="source-code"><strong class="bold">    result = op.add(a, b)</strong></pre>
<pre class="source-code"><strong class="bold">    return result </strong></pre>
<p>Now, we<a id="_idIndexMarker041"/> will create another variable, <code>functiontemplate</code>, and compile <code>'functionstring'</code> into a code object. We will also set the code object to be executed using <code>'exec'</code>. The <code>compile</code> method is used to convert the string in Python into a code object that can be further executed using the <code>exec</code> method:</p>
<pre class="source-code">functiontemplate = compile(functionstring, 'functionstring', 'exec')  </pre>
<pre class="source-code">functiontemplate </pre>
<pre class="source-code"><strong class="bold">&lt;code object &lt;module&gt; at 0x000001E20D498660, file "functionstring", line 1&gt;</strong></pre>
<p>The code object of the function definition arithmetic will be stored in a tuple in <code>functiontemplate</code> and can be accessed as follows:</p>
<pre class="source-code">functiontemplate.co_consts[0]  </pre>
<pre class="source-code"><strong class="bold">&lt;code object arithmetic at 0x000001E20D4985B0, file "functionstring", line 1&gt;</strong></pre>
<p>The next step involves creating a function object using the <code>functiontemplate</code> code object. This can be done using the <code>FunctionType</code> method, which accepts the code object and global variables as input parameters:</p>
<pre class="source-code">dynamicfunction = FunctionType(functiontemplate.co_consts[0], globals(),"add")</pre>
<pre class="source-code">dynamicfunction  </pre>
<pre class="source-code"><strong class="bold">&lt;function _main_.arithmetic(a,b)&gt; </strong></pre>
<p>Upon executing, <code>dynamicfunction</code>, it will behave the same way as the <code>add</code> operation works in the operator module’s <code>add</code> method in the arithmetic function:</p>
<pre class="source-code">dynamicfunction(2,5)  </pre>
<pre class="source-code"><strong class="bold">7</strong></pre>
<p>Now that we<a id="_idIndexMarker042"/> know how to create a function dynamically, we can look at extending it further to create multiple functions, each with a different operation and a different name, dynamically.</p>
<p>To do this, we must create a list of operators and a list of function names:</p>
<pre class="source-code">operator = ['op.add','op.sub','op.mul','op.truediv','op.pow','op.mod', 'op.gt', 'op.lt'] </pre>
<pre class="source-code">functionname = ['add','sub', 'multiply', 'divide', 'power',\</pre>
<pre class="source-code"> 'modulus', 'greaterthan', 'lesserthan']  </pre>
<p>Our earlier list of four functions only contained the add, sub, multiply, and divide operations.</p>
<p>The earlier <code>functionname</code> list contained eight functions. This is the flexibility we get while creating dynamic functions.</p>
<p>For ease of use, let’s also create two input variables, <code>a</code> and <code>b</code>, to be used while executing the function:</p>
<pre class="source-code">a = 2  </pre>
<pre class="source-code">b = 5  </pre>
<p>In the following code, we will be creating a function called <code>functiongenerator()</code> that implements metaprogramming to dynamically generate as many arithmetic functions as we want. This function will take four input parameters – that is, the list’s <code>functionname</code>, <code>operator</code>, <code>a</code>, and <code>b</code>.</p>
<p>Here is the code:</p>
<pre class="source-code">def functiongenerator(functionname, operator, a,b):    </pre>
<pre class="source-code">    from types import FunctionType    </pre>
<pre class="source-code">    functionstring = []    </pre>
<pre class="source-code">    for i in operator:    </pre>
<pre class="source-code">        functionstring.append('''</pre>
<pre class="source-code">def arithmetic(a, b):</pre>
<pre class="source-code">    op = __import__('operator')</pre>
<pre class="source-code">    result = '''+ i + '''(a, b)</pre>
<pre class="source-code">    return result</pre>
<pre class="source-code">    ''')    </pre>
<pre class="source-code">        functiontemplate = []    </pre>
<pre class="source-code">    for i in functionstring:    </pre>
<pre class="source-code">        functiontemplate.append(compile(i, 'functionstring', 'exec'))    </pre>
<pre class="source-code">        dynamicfunction = []    </pre>
<pre class="source-code">    for i,j in zip(functiontemplate,functionname):    </pre>
<pre class="source-code">        dynamicfunction.append(FunctionType(i.co_consts[0], \</pre>
<pre class="source-code">          globals(), j))    </pre>
<pre class="source-code">        functiondict = {}    </pre>
<pre class="source-code">        </pre>
<pre class="source-code">    for i,j in zip(functionname,dynamicfunction):    </pre>
<pre class="source-code">        functiondict[i]=j    </pre>
<pre class="source-code">            </pre>
<pre class="source-code">    for i in dynamicfunction:    </pre>
<pre class="source-code">        print (i(a,b))    </pre>
<pre class="source-code">      </pre>
<pre class="source-code">    return functiondict    </pre>
<p>Within <code>functiongenerator()</code>, the<a id="_idIndexMarker043"/> following occurs:</p>
<ul>
<li>A new <code>functionstring</code> list is created with a function definition for each arithmetic operator provided in the operator list. </li>
<li>A new <code>functiontemplate</code> list is created with a code object for each function definition. </li>
<li>A new <code>dynamicfunction</code> list is created with a function object for each code object.</li>
<li>A new <code>functiondict</code> dictionary is created with a key-value pair of function name-function objects.</li>
<li><code>Functiongenerator</code> returns the generated functions as a dictionary.</li>
<li>Additionally, <code>functiongenerator</code> executes the dynamic functions and prints the results.</li>
</ul>
<p>Executing this function results in the following output:</p>
<pre class="source-code">funcdict = functiongenerator(functionname, operator, a,b)  </pre>
<pre class="source-code"><strong class="bold">7</strong></pre>
<pre class="source-code"><strong class="bold">-3</strong></pre>
<pre class="source-code"><strong class="bold">10</strong></pre>
<pre class="source-code"><strong class="bold">0.4</strong></pre>
<pre class="source-code"><strong class="bold">32</strong></pre>
<pre class="source-code"><strong class="bold">2</strong></pre>
<pre class="source-code"><strong class="bold">False</strong></pre>
<pre class="source-code"><strong class="bold">True</strong></pre>
<pre class="source-code">funcdict  </pre>
<pre class="source-code"><strong class="bold">{'add': &lt;function _main_.arithmetic(a,b)&gt;,</strong></pre>
<pre class="source-code"><strong class="bold"> 'sub': &lt;function _main_.arithmetic(a,b)&gt;,</strong></pre>
<pre class="source-code"><strong class="bold"> 'multiply': &lt;function _main_.arithmetic(a,b)&gt;,</strong></pre>
<pre class="source-code"><strong class="bold"> 'divide': &lt;function _main_.arithmetic(a,b)&gt;,</strong></pre>
<pre class="source-code"><strong class="bold"> 'power': &lt;function _main_.arithmetic(a,b)&gt;,</strong></pre>
<pre class="source-code"><strong class="bold"> 'modulus': &lt;function _main_.arithmetic(a,b)&gt;,</strong></pre>
<pre class="source-code"><strong class="bold"> 'greaterthan': &lt;function _main_.arithmetic(a,b)&gt;,</strong></pre>
<pre class="source-code"><strong class="bold"> 'lesserthan': &lt;function _main_.arithmetic(a,b)&gt;,} </strong></pre>
<p>Any specific function from the preceding generated functions can be called individually and used further, as follows:</p>
<pre class="source-code">funcdict['divide'](a,b)  </pre>
<pre class="source-code"><strong class="bold">0.4</strong></pre>
<p>The following <a id="_idIndexMarker044"/>diagram shows the complete process of metaprogramming to develop these dynamic functions:</p>
<div><div><img alt="Figure 1.8 – Dynamic function generator " height="975" src="img/B13426_01_08.jpg" width="1534"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – Dynamic function generator</p>
<p>Now that we know about dynamic function generators, let’s look at other applications of metaprogramming.</p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor025"/>Exploring the applications of metaprogramming</h1>
<p>Metaprogramming <a id="_idIndexMarker045"/>can be applied to various Python-based application development solutions, such as automated code generators, component-based or flow-based application development, domain-specific language development, and many more.</p>
<p>Any code you develop, be it for a class or a method, internally applies metaprogramming, and its use is inevitable in the Python application development process. However, applying metaprogramming concepts explicitly is a conscious decision-making process and it purely depends on the expected outcome of your application.</p>
<p>In our example of dynamic function creation, we implemented metaprogramming to avoid repetitions and also to ensure the abstraction of the code at the meta-level.</p>
<p>Let’s consider a scenario where we want to develop a functional flow-based application for non-programmers to use. For instance, the application can be a domain-specific data transformation tool that works with high levels of abstraction and does not provide too much design or development-based information to the end users. However, it also helps the end users dynamically create modules that can help in their domain-specific problem solving, without the need to write any programs. In such cases, metaprogramming<a id="_idIndexMarker046"/> comes in handy for the application development process:</p>
<div><div><img alt="Figure 1.9 – Levels of programming " height="540" src="img/B13426_01_9.jpg" width="1435"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9 – Levels of programming</p>
<p>We will look at the case studies and applications of metaprogramming in more detail throughout this book.</p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor026"/>Summary</h1>
<p>In this chapter, we provide a quick overview of the programming paradigm of metaprogramming and looked at an example of solving a type error using metaprogramming in Python 3.</p>
<p>We learned why there is a need to apply metaprogramming techniques in the Python application development process. We also learned about the Don’t Repeat Yourself concept by looking at a practical approach that explains an example implementation of dynamic function creation using metaprogramming, emphasizing the concepts of avoiding repetition and implementing abstraction at the meta level in the code. Finally, we provided a high-level overview of the applications of metaprogramming that we will look at throughout this book. These skills will help us understand how and why to apply metaprogramming in various applications.</p>
<p>In the next chapter, we will review the object-oriented programming concepts of Python. The next chapter is more of a refresher on object-oriented programming concepts and is optional if you are already familiar with those concepts.</p>
</div>
</div></body></html>