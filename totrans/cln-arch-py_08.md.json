["```py\n@dataclass\nclass TaskController:\n    create_use_case: CreateTaskUseCase\n    # ... additional use cases as needed\n    presenter: TaskPresenter\n    def handle_create(\n        self,\n        title: str,\n        description: str\n    ) -> OperationResult[TaskViewModel]:\n        try:\n            request = CreateTaskRequest(\n                title=title,\n                description=description\n            )\n            result = self.create_use_case.execute(request)\n            if result.is_success:\n                view_model = self.presenter.present_task(result.value)\n                return OperationResult.succeed(view_model)\n            error_vm = self.presenter.present_error(\n                result.error.message,\n                str(result.error.code.name)\n            )\n            return OperationResult.fail(error_vm.message, error_vm.code)\n        except ValueError as e:\n            error_vm = self.presenter.present_error(\n                str(e), \"VALIDATION_ERROR\")\n            return OperationResult.fail(error_vm.message, error_vm.code) \n```", "```py\n# Anti-example: Tightly coupled controller\nclass TightlyCoupledTaskController:\n    def __init__(self):\n        # Direct instantiation creates tight coupling\n        self.use_case = TaskUseCase(SqliteTaskRepository())\n        self.presenter = CliTaskPresenter()\n\n    def handle_create(self, title: str, description: str):\n        # Implementation details...\n        pass \n```", "```py\n@dataclass(frozen=True)\nclass CreateTaskRequest:\n    \"\"\"Request data for creating a new task.\"\"\"\n    title: str\n    description: str\n    due_date: Optional[str] = None\n    priority: Optional[str] = None\n    def to_execution_params(self) -> dict:\n        \"\"\"Convert request data to use case parameters.\"\"\"\n        params = {\n            \"title\": self.title.strip(),\n            \"description\": self.description.strip(),\n        }\n        if self.priority:\n            params[\"priority\"] = Priority[self.priority.upper()]\n        return params \n```", "```py\n# In TaskController\ntry:\n    request = CreateTaskRequest(title=title, description=description)\n    # Request is now validated and properly formatted\n    result = self.create_use_case.execute(request)\nexcept ValueError as e:\n    # Handle validation errors before they reach use cases\n    return OperationResult.fail(str(e), \"VALIDATION_ERROR\") \n```", "```py\n@dataclass\nclass TaskController:\n    create_use_case: CreateTaskUseCase  # Application layer interface\n    presenter: TaskPresenter            # Interface layer abstraction \n```", "```py\n# Anti-example: Controller with framework coupling\nclass WebTaskController:\n    def __init__(self, app: FastAPI):\n        self.app = app\n        self.use_case = CreateTaskUseCase()  # Direct instantiation too!\n\n    async def handle_create(self, request: Request):\n        try:\n            data = await request.json()\n            # Controller now tightly coupled to FastAPI\n            return JSONResponse(status_code=201, content={\"task\": result})\n        except ValidationError as e:\n            raise HTTPException(status_code=400, detail=str(e)) \n```", "```py\nclass TaskController:\n\n    def handle_create(\n        self,\n        title: str,\n        description: str\n    ) -> OperationResult[TaskViewModel]: \n```", "```py\n@dataclass\nclass OperationResult(Generic[T]):\n    \"\"\"Represents the outcome of controller operations.\"\"\"\n    _success: Optional[T] = None\n    _error: Optional[ErrorViewModel] = None\n    @classmethod\n    def succeed(cls, value: T) -> 'OperationResult[T]':\n        \"\"\"Create a successful result with the given view model.\"\"\"\n        return cls(_success=value)\n    @classmethod\n    def fail(cls, message: str,\n             code: Optional[str] = None) -> 'OperationResult[T]':\n        \"\"\"Create a failed result with error details.\"\"\"\n        return cls(_error=ErrorViewModel(message, code)) \n```", "```py\n# pseudo-code example of a CLI app working with a OperationResult\nresult = app.task_controller.handle_create(title, description) \nif result.is_success:\n    task = result.success\n    print(f\"{task.status_display} [{task.priority_display}] {task.title}\")\n    return 0\nprint(result.error.message, fg='red', err=True)\n    return 1 \n```", "```py\n# Example transformation flow in TaskController\ndef handle_create(\n    self, title: str, description: str\n) -> OperationResult[TaskViewModel]:\n    try:\n        # 1\\. External input to request model\n        request = CreateTaskRequest(title=title, description=description)\n\n        # 2\\. Request model to domain operations\n        result = self.use_case.execute(request)\n\n        if result.is_success:\n            # 3\\. Domain result to view model\n            view_model = self.presenter.present_task(result.value)\n            return OperationResult.succeed(view_model)\n\n        # 4\\. Error handling and formatting\n        error_vm = self.presenter.present_error(\n            result.error.message,\n            str(result.error.code.name)\n        )\n        return OperationResult.fail(error_vm.message, error_vm.code)\n\n    except ValueError as e:\n        # 5\\. Validation error handling\n        error_vm = self.presenter.present_error(\n            str(e), \"VALIDATION_ERROR\")\n        return OperationResult.fail(error_vm.message, error_vm.code) \n```", "```py\n# Defined in Application layer\nclass TaskRepository(ABC):\n    @abstractmethod\n    def get(self, task_id: UUID) -> Task:\n        \"\"\"Retrieve a task by its ID.\"\"\"\n        pass\n# Implemented directly in Infrastructure layer\nclass SqliteTaskRepository(TaskRepository):\n    def get(self, task_id: UUID) -> Task:\n        # Direct implementation of interface\n        pass \n```", "```py\n# The \"humble\" view - simple, minimal logic, hard to test\ndef display_task(task_vm: TaskViewModel):\n    print(f\"{task_vm.status_display} [{task_vm.priority_display}]\n          {task_vm.title}\")\n    if task_vm.due_date_display:\n        print(f\"Due: {task_vm.due_date_display}\") \n```", "```py\nclass TaskPresenter(ABC):\n    \"\"\"Abstract base presenter for task-related output.\"\"\"\n\n    @abstractmethod\n    def present_task(self, task_response: TaskResponse) -> TaskViewModel:\n        \"\"\"Convert task response to view model.\"\"\"\n        pass\n\n    @abstractmethod\n    def present_error(self, error_msg: str,\n                      code: Optional[str] = None) -> ErrorViewModel:\n        \"\"\"Format error message for display.\"\"\"\n        pass \n```", "```py\n@dataclass(frozen=True)\nclass TaskViewModel:\n    \"\"\"View-specific representation of a task.\"\"\"\n    id: str\n    title: str\n    description: str\n    status_display: str      # Pre-formatted for display\n    priority_display: str    # Pre-formatted for display\n    due_date_display: Optional[str]  # Pre-formatted for display\n    project_display: Optional[str]   # Pre-formatted project context\n    completion_info: Optional[str]   # Pre-formatted completion details \n```", "```py\nclass CliTaskPresenter(TaskPresenter):\n    \"\"\"CLI-specific task presenter.\"\"\"\n    def present_task(self, task_response: TaskResponse) -> TaskViewModel:\n        \"\"\"Format task for CLI display.\"\"\"\n        return TaskViewModel(\n            id=str(task_response.id),\n            title=task_response.title,\n            description=task_response.description,\n            status_display=self._format_status(task_response.status),\n            priority_display=self._format_priority(\n                task_response.priority),\n            due_date_display=self._format_due_date(\n                task_response.due_date),\n            project_display=self._format_project(\n                task_response.project_id),\n            completion_info=self._format_completion_info(\n                task_response.completion_date,\n                task_response.completion_notes\n            )\n        ) \n```", "```py\nclass CliTaskPresenter(TaskPresenter):  # continuing from above\n    def _format_due_date(self, due_date: Optional[datetime]) -> str:\n        \"\"\"Format due date, indicating if task is overdue.\"\"\"\n        if not due_date:\n            return \"No due date\"\n        is_overdue = due_date < datetime.now(timezone.utc)\n        date_str = due_date.strftime(\"%Y-%m-%d\")\n        return (\n            f\"OVERDUE - Due: {date_str}\"\n            if is_overdue else f\"Due: {date_str}\"\n        )\n    def present_error(self, error_msg: str,\n                      code: Optional[str] = None) -> ErrorViewModel:\n        \"\"\"Format error message for CLI display.\"\"\"\n        return ErrorViewModel(message=error_msg, code=code) \n```"]