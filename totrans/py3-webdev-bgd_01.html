<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Choosing Your Tools</h1></div></div></div><div><blockquote class="blockquote"><p>In this chapter, we look at the many aspects of designing web applications. The idea is to provide you with an overview that may help you recognize components in subsequent chapters and give you some insight into the arguments used to decide which tool or library to use.</p></blockquote></div><div><blockquote class="blockquote"><p>Also, as this book covers more than just developing example applications, we illustrate some issues that are relevant when designing an application that does not deal with coding directly, like security or usability.</p></blockquote></div><p>In this chapter, we will be:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Indentifying the components that a web application consists of</li><li class="listitem" style="list-style-type: disc">Choosing suitable tools</li><li class="listitem" style="list-style-type: disc">Considering what designing for maintainability and usability implies</li></ul></div><p>There is a lot of ground to cover, so let's get started.</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec01"/>Identifying the components of a web application</h1></div></div></div><p>A web application is not a monolithic object. In designing such an application, it might help focus if you look at an application as a collection of related objects, each with its well-defined purpose. This can be done with multiple levels of detail and even the mile high view may already give some valuable insights.<a id="id0" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec02"/>Time for action getting an overview of a web application</h1></div></div></div><p>From the following picture shown, it should be clear that a web application is not a singular thing. It consists of parts that reside on a server and parts that run on the computer of the user. Both halves are just as important; although the server may hold the application data and implement the logic to modify that data following requests from the user, the data is displayed by the part of the web application running in the browser on the client computer and the user signals his/her request by interacting with the user interface components in the browser, for example, by clicking on an "OK" button.<a id="id2" class="indexterm"/>
</p><div><img src="img/3746OS_01_01.jpg" height="42" alt="Time for action getting an overview of a web application"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Think about your application and consider both server and client-side. The advantage of looking at the individual halves is that we might make choices that are optimal for the specific half.<a id="id3" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Look at the general requirements for the client half. For example, because we want to offer the user a sophisticated user interface, we opt for the jQuery UI library. This decision does not touch the overall design decision on the server, because apart from delivering the files that the jQuery UI library consists of, the choice of user interface library has no impact on the choice of the database engine or the server operating system for example.<a id="id4" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Look at the requirements for the server half. For example, consider which implementation language to use. We select Python as the language to implement the server-side code but if we had compelling arguments to switch to C#, we could do so without the need to change anything on the client.<a id="id5" class="indexterm"/></li></ul></div><p>If we zoom in on our web application, an image emerges of many interacting layers, each encapsulating a well defined piece of functionality. Everywhere two layers touch, information flows through a well defined interface (API). This helps in the separation of concepts (our application is only talking to the database layer to store and retrieve persistent data and only to the web server to return data upon request) but in practice, the separation between these layers isn't completely clear in all circumstances. For example, the server-side part of our application is actually an integral part of the web server.</p><p>This simple schematic of a web application is virtually identical to a regular client-server architecture. However, when we look more closely at the implementation of the client and the interaction between client and server, differences will emerge as we will see in the next section where we zoom in a bit closer.<a id="id6" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec01"/>What just happened?</h2></div></div></div><p>With both halves of the application identified, we can now zoom in on each individual half.<a id="id7" class="indexterm"/>
</p><p>This will enable us to get a more detailed image, that will help us to make informed decisions regarding the smaller components that make up our application.</p><p>The main components are easy to identify:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The data store holds data on the server (it is often a database engine, sometimes just files on the filesystem).<a id="id8" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">The server-side application services requests that are passed through from the web server.<a id="id9" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">The web server forwards those responses to the client again and may serve static files as well.<a id="id10" class="indexterm"/></li></ul></div><p>The web browser takes care of running the client side of the application, but within the browser, we can identify several layers of activities. These consist of:<a id="id11" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Fetching the content to structure the data (often HTML files)<a id="id12" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Running JavaScript code to enhance the presentation of the data</li><li class="listitem" style="list-style-type: disc">Allowing interaction with the user</li></ul></div><div><img src="img/3746OS_01_02.jpg" width="206" alt="What just happened?"/></div><p>Of course we could zoom in even further to reveal additional detail like the operating system on the client and the server, or even the hardware and the network components and although occasionally useful, this would generally be overkill. With the main components clearly identified, we can take the next step and choose suitable tools to implement these components.<a id="id13" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec03"/>Choosing suitable tools</h1></div></div></div><p>If you want to develop quality applications, you need suitable tools. Tools, of course, do not guarantee quality, but they can make life a lot easier. When developing web applications, there are two kinds of tools you need to consider: the ones you use to design, build, test, and deploy your application, like editors, version management systems, test frameworks, and maybe a package tool, and the tools that deliver your application to the end user. That last set of tools consists of a whole chain of components, from server operating system, web server, and database engine, all the way to the web browser and the JavaScript libraries used to display and interact with the application.<a id="id14" class="indexterm"/>
</p><p>When we start a project, we have to know which tools we need and have to understand the capabilities and limitations of the many variations of these tools. There are, for example, quite a few JavaScript libraries that may be used to provide cross-browser compatible user interaction.</p><p>The trick is to make an informed choice. These choices are not necessarily limited to open source tools. If budget permits, it might be worthwhile to have the benefit of the special features many commercial development tools and libraries offer, but in this book, we limit ourselves to open source and/or free resources. This makes sense as the cost of tooling and licenses in small projects can make a significant dent in a budget.</p><p>The opportunity to use free tools might not exist for the deployment environment. You may well develop your application on your own Linux box, but test and deploy it on a Windows server. The latter needs a license that will not be free, but even open source options are not always free. Many companies nowadays shift to deploying their applications to the cloud and even though these machines might be running an open source operating system, you pay not only for CPU power and bandwidth but also for support, the latter being crucial in applications that will lose you money if they are not running. However, using open source tools in general gives you a much wider choice because many tools run equally well on any platform.</p><p>In the following sections, we will look at the many components that make up the tool chain and will try to show what arguments were used for the choices made for developing the applications in this book and what (if any) viable alternatives are there. Note that some arguments are quite subjective and the choice finally made does not necessarily indicate that the alternative is bad; we certainly are not attempting to start flame wars over which tool is better. We simply list requirements for application development as we see it and try to find the tools suitable for the task. In some situations, another tool might be better, but for this book, we try to find a matching toolset that can be used for all sample applications that are free (as in beer) and easy to learn and use.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec04"/>Time for action choosing a delivery framework, also known as web server</h1></div></div></div><p>In the first section of this chapter, we showed that a web application lives in two realms at the same time, namely, on the server and on the client. In order to deliver information to the client and receive a response in return, our web application needs two important items at the server: a delivery framework and an application to compose content and respond to the request.</p><p>The delivery framework might be a full-fledged general purpose web server such as Apache or Microsoft Information Server, but although these are very versatile and come with many options to tune the web server to your specific needs, they certainly take quite some time to get acquainted with and it takes extra attention to integrate the dynamic content of your application with these servers. If performance is crucial or the requirements for your project include that your application has to be deployed as part of these servers, you may not have a choice, but otherwise its worth looking at the alternatives that are simpler to use or offer integration advantages.<a id="id15" class="indexterm"/>
</p><p>So what do we need?</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A fairly lightweight web server that is easy to configure and maintain</li><li class="listitem" style="list-style-type: disc">That allows for smooth integration of static and dynamic content</li><li class="listitem" style="list-style-type: disc">That comes with reusable components that ease the development process</li><li class="listitem" style="list-style-type: disc">That is actively maintained and developed</li></ul></div><p>Given these requirements, our choice for delivery framework is CherryPy.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec02"/>What just happened?</h2></div></div></div><p>CherryPy fits the bill nicely. Its main advantages are:<a id="id16" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">CherryPy is written in Python and components that deliver dynamic content are written as Python classes that are tightly integrated with CherryPy's core.<a id="id17" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">CherryPy comes with a whole host of<strong> tools</strong>; reusable components that can be used to implement anything from custom error pages to session management.</li><li class="listitem" style="list-style-type: disc">CherryPy has a proven track record as the core web server of the larger TurboGears network.</li><li class="listitem" style="list-style-type: disc">And finally, CherryPy is actively developed and enjoys a large user community.</li></ul></div><p>The disadvantage of being written in Python is that performance might not be top notch, but we will look into that in the next section.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec05"/>Time for action choosing a server-side scripting language</h1></div></div></div><p>When developing web applications, you have a virtually unlimited choice of programming languages you can use, so we have to consider what is important for us in our project and make a tradeoff if necessary.<a id="id18" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Consider how important development time is compared to performance. Compiled languages like C# or C++ might be used if CPU power is scarce or if you do not want to distribute the source code in a readable format. But when development time is at a premium, using scripting languages often saves time as they make it easier to develop applications in an incremental way, even to the point where you can type in commands interactively to see what is possible and later incorporate these trials in your code.<p>Performance is generally not an issue, especially when using scripting languages that are compiled to intermediate byte code, as is the case for languages like Python and Perl, for example. And while it is true that scripted languages are compiled each time they are run, this has a negligible effect when the program is a long running web application.
<a id="id19" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Weigh the importance of debugging. Interpreted languages are often simpler to debug as compiled languages, both because the debugger has access to more information that you may explore interactively if something breaks and because you can try out any modules you have written by interactively calling functions to see what happens.</li><li class="listitem" style="list-style-type: disc">Think beyond the project. Once implemented and deployed, your application might have a long and happy life, but that inevitably means that there will be requests for smaller or larger changes and choosing a suitable language can help to reduce the maintenance effort. Compared to compiled languages that in general have quite low-level instructions and language constructs, interpreted languages have (very) high level constructs that make for condensed code that packs a lot of meaning in a few statements. That is not only easier to read but also faster to interpret and in the end these high level constructs, once interpreted, run at (almost) compiled speed making the performance difference sometimes hard to spot. More meaning and less code do make for easier reading and this is a huge benefit when maintaining code.</li></ul></div><p>In the end, the choice for the language to implement the web application is at least in part a matter of taste, but in this book we opt for Python as it offers an optimal tradeoff between the different considerations.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec03"/>What just happened?</h2></div></div></div><p>Now that we have chosen Python as our server-side scripting language, let's have a good look at the arguments:<a id="id20" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Python is easy to read and therefore easy to learn and maintain. Although Python is relatively unique among programming languages in treating whitespace as meaningful in many places, this does enhance readability quite a lot.<a id="id21" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Python is a very high level language, incorporating concepts like list comprehension and functional programming. This allows for compact programs that pack a lot of functionality in little code, enhancing readability and reducing maintenance.</li><li class="listitem" style="list-style-type: disc">Python comes "batteries included". Python is distributed with a vast amount of well designed and well maintained libraries (modules) that provide anything from access to<code class="literal"> .csv</code> files and parsing XML, to building an HTTP server with a handful of code and these modules are at least as well documented as the language itself. This all means we can cut down on development time as in many cases we do not have to reinvent the wheel ourselves.</li><li class="listitem" style="list-style-type: disc">Python has many third party modules. Even if a module is not included with the distribution, chances are somebody has written just the module you are looking for.</li><li class="listitem" style="list-style-type: disc">Python is an object-oriented language. This is widely regarded as a good thing as it aids in data abstraction but its main attraction to people developing database-driven applications is that it allows for a natural way of mapping tables to types (classes). Records in a table of cars can be mapped to a 'Car' class and instances of this class can then be manipulated in much the same way as native classes like strings or lists. This again makes it easier to read the code and therefore maintain the code.</li><li class="listitem" style="list-style-type: disc">Python is available on many cloud platforms. To run a Python program on the server, you need Python deployed on that server. If you have full access, this might not be an issue and indeed hosting companies provide (virtual) machines with Python already installed but for very lightweight cloud platforms like Google Gears, your choice of available languages might be limited. However, Python (together with Java) is fully supported by Google Gears and although this is not a consideration for the example applications in this book, it might be for your applications.</li></ul></div><p>The version of Python we use in this book is version 3 (version 3.2 at the time of writing). Although not all third party modules are (yet) ported to this new version, it is the best version to use if you want to develop in a future proof way.<a id="id22" class="indexterm"/>
</p><div><h3 class="title"><a id="note02"/>Note</h3><p>Python's multi-threading capabilities at the moment do not allow for optimal usage of multi-core processors. Most implementations of Python do not allow running separate threads truly in parallel. This is by far not as bad as you may think though, as this restriction is mainly valid for interpreted python code, not necessarily for code running in, for example, the OS kernel. And because in a web server a lot of time is spent waiting for packets to be sent or received over the network, this mostly does not affect the performance of your Python code. In the future, the multi-threading implementation of Python may change, but this is a hotly debated subject. More on this subject can be found by searching for "Python 3 GIL".</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec06"/>Time for action choosing a database engine</h1></div></div></div><p>One of the key requirements of any web-application is that is has access to some sort of persistent storage. This might be used to store core data like a catalog of car parts, but a password file also needs a form of persistent storage.<a id="id23" class="indexterm"/>
</p><p>Often it is possible to store the information in files on the filesystem and indeed some of the applications we develop in this book do just that, but if you have a lot of structured data or you find that many people want to access this data at the same time, it is usually a better choice to store this data in a database and access this data through a database engine.</p><p>When choosing a database engine, you should consider the following points:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Does it offer the functionality you need? Database engines are sophisticated pieces of software and in general offer a lot of functionality, often more than you need. Although this may sound like an advantage, all these features must be learned by a developer to take advantage of them and may complicate your code which may increase the effort to maintain an application.<a id="id24" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Is it easy to install and maintain? Database engines often run as separate applications that are accessed over a network. This means that they have to be installed, tested, and maintained separately. This may add significantly to the effort needed to deploy your application. And installation isn't even everything; you will have to consider operational issues as well, for example, how much effort it is to set up a suitable backup scheme or how to monitor the availability of the database.</li><li class="listitem" style="list-style-type: disc">Does it offer an API that is simple to use from your chosen programming language and does this API provide access to all necessary functionality?</li><li class="listitem" style="list-style-type: disc">And finally, does it perform well enough to respond swiftly to the requests of your application, even during peaks?</li></ul></div><p>Python offers a standardized API to access many available database engines, including MySQL and PostgreSQL. Fully in line with its 'batteries included' philosophy, Python also comes included with a database engine and a module to access it. This database is called SQLite and is a so called embedded database: it doesn't run as a standalone process that can be accessed through some means of inter-process communication, but the database engine is an integral part of the program that uses it. Its only external part is a single file containing the data in the database itself and that may be shared by other programs that include the SQLite engine. As it fits our requirements, SQLite will be the database engine we will use for the applications we develop in this book.<a id="id25" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec04"/>What just happened?</h2></div></div></div><p>Our choice for SQLite as the database for many of our applications is easily justified:<a id="id26" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Although not as feature-rich as, for example, MySQL, it does provide the functionality we need.</li><li class="listitem" style="list-style-type: disc">Installation is practically a no brainer as SQLite comes included with Python.</li><li class="listitem" style="list-style-type: disc">The API offered by the<code class="literal"> sqlite3</code> module gives access to all functionality.</li><li class="listitem" style="list-style-type: disc">It performs well enough for our needs (although statements about performance are very difficult to make in advance).</li></ul></div><p>The main arguments supporting the use of SQLite in our applications are not its speed, small memory footprint, or reliability (although these are certainly not drawbacks as SQLite's reputation as database engine of choice for mobile telephone appliances proves) but the fact that because it is embedded in your program, it obviates the need for a separately configured and maintained database engine. This cuts down on maintenance in a serious manner as database engines are demanding beasts that take a lot of care and feeding. Also, because it is included in Python, it reduces the number of external dependencies when deploying an application.</p><p>A final argument is its type system that closely resembles Python's type system; in contrast to many other database engines, SQLite allows you to store any value in a column no matter how this column was typed when it was created, just like you can store a string in a Python variable that was first used to store an integer value. This close correspondence of types allows for an intuitive mapping of Python values to values stored in the database, an advantage that we will study closely when we encounter our first application that uses SQLite.<a id="id27" class="indexterm"/>
</p><div><h3 class="title"><a id="tip01"/>Tip</h3><p>The integration with Python is so close that it is possible to use Python functions within the SQL expressions used to query SQLite. The native set of functions in SQLite is quite small compared to other database engines but the ability to use Python functions removes this limitation completely. It is, for example, straightforward to add a hash function from Python's<code class="literal"> hashlib</code> module, that is very convenient when implementing a password database.</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec07"/>Time for action deciding on object relational mappers</h1></div></div></div><p>Relational database engines like SQLite use tables consisting of rows and columns as their primary data abstraction model. Object-oriented languages like Python define classes to instantiate objects that have attributes. There is a fair amount of correspondence between these concepts as class definitions mimic table definitions where object instances with attributes relate to records with columns but maintaining the integrity of that relation is not so straightforward.<a id="id28" class="indexterm"/>
</p><p>The problem not only lies in the different languages used to define tables and classes. The main issue in relational databases is maintaining referential integrity. If you have, for example, a record representing a car part that references a record in a different table that represents a car type, then a relational database lets you define explicit actions to execute if, for example, the record representing the car type is deleted. These constraints are of course possible to implement in Python data structures as well, but it does take serious effort to implement.</p><p>Finally, most database engines require fixed data types for each column whereas Python variables and attributes may refer to any kind of data type. This restriction is not present in SQLite but even SQLite cannot store everything without conversion. A Python variable, for example, may refer to a list of objects, something that cannot be stored in a single column of a relational database.</p><p>Still, we would very much like to have a way to store object instances in a relational database or at least the data contained in those object instances, and have the means to define the relation between classes and tables in a maintainable way. To this end, many people have designed solutions in the form of object relational mappers. For Python, quite a few exist that are both mature and robust tools (like SQLAlchemy).<a id="id29" class="indexterm"/>
</p><p>When deciding which tool to use, you should at least consider the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How much time it will cost to learn to use it. Those tools are usually very versatile and quite often require a considerable amount of effort to learn.</li><li class="listitem" style="list-style-type: disc">How will it affect development and maintenance? Complex tools may help to solve the challenge of creating an effective and efficient mapping between classes and tables, but may require an idiom that detracts from a clear overview of your implementation. This may well be worth it, if your data model consists of many classes and performance is an important consideration, but for smaller projects the added complexity might be too great of a disadvantage when it impacts significantly on the development time.</li></ul></div><p>Because the focus in this book is on understanding the choices in implementing web applications and persistent storage, using a complex tool like an object relational mapper may hide all kinds of aspects necessary to gain understanding.</p><p>Therefore, we will not use a third party object relational mapper in the examples in this book but implement increasingly versatile storage solutions in each chapter, tackling specific requirements as we encounter them. We will see that in many situations an object relational mapper is superfluous, but in the final chapters, we will build a simple framework ourselves to give us not only a tool but an insight into the intricacies of mapping complex assemblies of classes to tables in a database as well.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Time for action choosing a presentation framework</h1></div></div></div><p>Web applications might be all about accessing and manipulating data from within a web browser but the way the application looks and feels to the user is just as important. A user interface that is non-intuitive, sluggish, or fails to work on some mainstream browser will not invite users to use your application again.<a id="id30" class="indexterm"/>
</p><p>HTML, the markup language commonly used to display content, does allow for some interaction through the use of<code class="literal">&lt;form&gt;</code> elements and the way a page is presented can be styled with cascading style sheets, but its use has some major drawbacks:<a id="id31" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It is quite difficult to create user interface components from basic building blocks that resemble commonly used applications.</li><li class="listitem" style="list-style-type: disc">The use of HTML feels sluggish because each form, when submitted, fetches a completely new page.</li></ul></div><p>Fortunately, all major browsers support JavaScript and that language can be used to add a whole new level of interactivity. However, in order to smooth out all inconsistencies between browsers, you can save a lot of development time when you use a JavaScript library that takes care of those inconsistencies and adds cross browser compatible user interface components (widgets).</p><p>Although such libraries are used client side, HTML pages can be composed in a way that instructs the browser to fetch these libraries from a central source, for example, the same server that serves the web application. This way, the use of these libraries imposes no extra requirements on the browser.<a id="id32" class="indexterm"/>
</p><p>Some points to consider when choosing a suitable library are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Is it really cross browser compatible? Not all libraries support each and every browser. This might be important if your application still needs to work with a fairly old browser.</li><li class="listitem" style="list-style-type: disc">Does it offer the graphical components and functionality you need?</li><li class="listitem" style="list-style-type: disc">Is it well designed and documented, extensible, and consistently implemented? After all, such a library should be fairly easy to learn and as no library can offer everything, extensibility and especially how easy it is to extend it are important considerations.</li><li class="listitem" style="list-style-type: disc">Does it have an active user community? All the more important here because such a community may not only provide answers to your questions, but may be a good source of reusable components.</li></ul></div><p>Based on these considerations, we choose to use two intimately connected JavaScript libraries: jQuery and jQuery UI.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec05"/>What just happened?</h2></div></div></div><p>Let's have a look at why jQuery and jQuery UI are such a good choice.<a id="id33" class="indexterm"/>
</p><p>jQuery provides the functionality to select and manipulate HTML elements on a page and jQuery UI provides a number of sophisticated widgets and effects. Together, they offer many advantages:<a id="id34" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">jQuery not only hides browser inconsistencies, but its methods take CSS3 compatible selectors even on browsers that do not support CSS3 in the style sheet they accept.<a id="id35" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Both libraries are widely used, actively maintained, free, and are distributed as small files. The latter is important when you consider that these files need to be transferred from server to client so any bandwidth saved is good.</li><li class="listitem" style="list-style-type: disc">jQuery UI offers a rich set of well designed and professional looking graphical components and effects.</li></ul></div><p>Other advantages of the wide adoption of these libraries are that there are many resources available to get you started and that many people have written plugins that extend the usability of these libraries even more. As we will see on many occasions, the essence of developing a good application efficiently is often choosing the right plugin for the job.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Designing for maintainability and usability</h1></div></div></div><p>It is one thing to come up with a great idea on how to implement some web application but yet another to design an application in such a way that it will be easy to maintain and use. Designing with these considerations in mind will make all the difference between a professional application and a mediocre one.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Testing</h2></div></div></div><p>Everybody will agree that it makes sense to test an application before it is deployed but thorough testing requires some serious effort. Testing is also often considered as boring or even detracting from the 'real' development work and shares this aura with writing documentation.<a id="id36" class="indexterm"/>
</p><p>However, testing gives you a better feel for the quality of the application you deliver and a test framework, however simple, is always better than none, especially for the kind of small to medium web applications we look at in this book, as these tend to be written by very small teams that quickly prototype and often change the code as insight progresses and customer requirements change. Having a test suite at hand ensures that at least the parts of the code that don't change keep on performing as expected.</p><p>Of course, not everything can be tested and the tools needed to test part of your code should be simple to use, otherwise there is no incentive to keep on using them. We will look at<strong> unit tests</strong> for a number of modules we develop in Python. Unit testing is an approach where we try to define the behavior of an isolated piece of code (for example, a single method) and check whether this code produces the expected results. If the implementation of the code changes but the tests still show no failure, we know that the new implementation can be used safely.<a id="id37" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Time for action choosing a test framework</h1></div></div></div><p>When choosing a test framework, ask yourself the following questions:<a id="id38" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What do I want to test? You cannot test everything and developing tests takes time.</li><li class="listitem" style="list-style-type: disc">How easy is it to write and maintain the tests? This question is just as relevant for developing tests as it is for developing code in general.</li><li class="listitem" style="list-style-type: disc">How much effort is needed to perform the tests? If it is easy to automate the tests, they can, for example, be run as part of the deployment as an extra check.</li></ul></div><p>Just for Python alone there are quite a few testing frameworks available, but we will choose the<code class="literal"> unittest</code> module distributed with Python. Note that although we choose to write only automated test for the Python parts of the applications, this doesn't mean we have not tested the JavaScript parts, but user interactions tend to lend themselves less to an automated way of testing so we do not address that in this book.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>What just happened?</h2></div></div></div><p>For the Python unit tests, we restrict ourselves to the<code class="literal"> unittest</code> module that is distributed with Python, as this will not introduce any new dependencies on external tools but also because:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It is fairly simple to learn and use.</li><li class="listitem" style="list-style-type: disc">It produces clear messages if a test fails.</li><li class="listitem" style="list-style-type: disc">It is easy to automate and may easily be integrated with, for example, a setup script.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Version management</h2></div></div></div><p>A version management tool is normally not part of a web application and not strictly required to develop one. However, when you want to keep track of changes in your code, especially when the number of files keeps on growing, a version management tool is invaluable.<a id="id39" class="indexterm"/>
</p><p>Most come with integrated functionality to show the differences between versions and all have the possibility to annotate a version or revision in order to clearly mark it. Widely used open source solutions are<strong> git</strong> and<strong> svn</strong>.<a id="id40" class="indexterm"/>
</p><p>Both may operate as a server that can be accessed through a web browser but command-line tools are available as well and svn even has a very user-friendly integration within Windows' file explorer. Both have their strengths and weaknesses and it is hard to declare a clear winner. This book and its accompanying examples were all maintained in svn, primarily because of the ease of use of the Windows client.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Usability</h2></div></div></div><p>Web applications are built for end users, not for developers. It is not always easy to design an interface that is easy to use. In fact, designing really good interfaces is difficult and takes considerable skill and knowledge. However, this does not mean that there aren't any rules of thumb that can help you prevent usability disasters. We look at some of them in the following sections.<a id="id41" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Good looking adhering to common GUI paradigms</h3></div></div></div><p>Applications are easier to use if the interface components are already familiar. Therefore, it is generally a good idea to look at applications that are successful and used by many people.<a id="id42" class="indexterm"/>
</p><p>A common concern in many applications is the need to present a lot of information in a small amount of space. It is therefore no wonder that many modern applications use accordion menus and/or a tabbed interface to structure that data, such as the following screenshots:</p><div><img src="img/3746_1_006.jpg" width="215" alt="Good looking adhering to common GUI paradigms"/></div><p>An accordion menu is great for displaying a fair amount of information in a side bar but even more information can be presented in tabs:<a id="id43" class="indexterm"/>
</p><div><img src="img/3746_1_005.jpg" height="130" alt="Good looking adhering to common GUI paradigms"/></div><p>Examples are found in all recent editions of common office productivity software, web browser, and CRM applications. Having a good look at the ones you like working with yourself might be a good start. In the larger applications developed in this book, we will certainly refer to some key applications that may be used as an inspiration.<a id="id44" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Themable</h3></div></div></div><p>Choosing a consistent and pleasing color scheme and font makes an application more coherent and therefore more pleasurable to use. An overload of information can baffle people and using a wild color scheme or many different fonts will not help in getting an overview of the data that is presented.</p><p>But whether your user interface supports the concept of a theme that is easy to change plays an important role in other areas as well. You probably want your web application to blend in well with the rest of your website or to convey some sort of company or brand identity. Using a consistent color scheme will help. It might even be desirable to offer a choice of themes to the end user, for example, to provide people with visual impairments with high contrast themes for better legibility. The library fully supports the use of themes and makes it simple to extend this themability to widgets we design ourselves.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Cross-browser compatible</h3></div></div></div><p>Web applications are often geared to a specific audience, so it might be possible that the requirements specify only a single browser, but in general, we don't want to deny the user his/her favorite browser. jQuery takes away most of the pain in supporting more than one browser. Our apps are designed for Internet Explorer 8, Firefox 3.x, and Google Chrome, but probably will run on most other browsers as well. Note that 'probably' might not be good enough and it is always a good idea to test your application specifically on any required platform!<a id="id45" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Cross-platform compatible</h3></div></div></div><p>Client-side, the web browser is the key component in our chain to watch out for and therefore, the operating system it is running on will quite likely not be a source of problems.<a id="id46" class="indexterm"/>
</p><p>Server-side, we want to keep our options open as well. Fortunately, Python is a cross platform solution, so any Python program that runs on Windows will normally run on GNU/Linux as well and vice versa.</p><p>We should be careful though when using modules that are not distributed with Python and are not pure Python. These might be available on every platform but it is better to check beforehand. The applications in this book use only modules provided in the standard Python distribution, with the exception of CherryPy, which is a pure Python module and should run on every platform.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Maintainability</h2></div></div></div><p>Writing code is hard work, maintaining it can be even harder. We briefly touched upon this subject earlier when we discussed the use of a testing framework, but maintaining code is more than being able to test it.<a id="id47" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Standards compliant</h3></div></div></div><p>An important concept in creating code that is easy to maintain is being standards compliant. Adhering to standards means that other people stand a greater chance in understanding your code.<a id="id48" class="indexterm"/>
</p><p>SQL, for example, is a query language that most database engines understand. Therefore, it is less relevant which engine we use for people maintaining the code as they do not have to learn an obscure query language.<a id="id49" class="indexterm"/>
</p><p>Another example is communication between client and server. We can devise our own protocol to construct requests in JavaScript and respond to those requests in Python, but it is a lot less error prone to use documented standards like AJAX to communicate and JSON to encode data. It also saves on documentation as people can be referred to any number of books, if they want to learn more about those standards.</p><div><h3 class="title"><a id="note03"/>Note</h3><p>Standard does not necessarily mean 'approved by some independent organization'. Many standards are informal but work because everybody uses them and writes about them. Both AJAX and JSON are examples of that. Also the Python programming language is a de facto standard but JavaScript enjoys a formal standard (which doesn't mean all implementations adhere to the standard).</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Security</h2></div></div></div><p>Security is often regarded as an obscure or arcane subject, but security covers many practical issues that play a role in even the smallest web application. We wouldn't want anyone to access a paid-for web application, for example. However, security is more than just access control and we touch briefly on some aspects of security in the next sections.<a id="id50" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Reliable</h3></div></div></div><p>A web application should be reliable in its use. Nothing is more annoying than being presented with a server-side error halfway in the process of filling in a mortgage application, for example. As a developer and tester, you take care of testing the software thoroughly in the hope of catching any bugs but before implementing the application, the reliability of the software and libraries it uses should be taken into consideration.<a id="id51" class="indexterm"/>
</p><p>You should especially be wary of using the latest and greatest nifty feature of some library in production software. This might be fun when whipping up some mock up or concept application, but do ask yourself if your customer really needs this bleeding edge feature and if he's/she's not better off with a tried and tested version.</p><p>Many open source projects (including Python) develop and maintain both a so called stable branch and a development branch to show off new features. The former you should use in production applications and the latter should be tried elsewhere.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Robust</h3></div></div></div><p>Applications should not only be as bug-free as possible, but should also perform nicely under stress as well. The performance should be as high as possible under load, but just as important you should know what to expect when the load reaches some threshold.<a id="id52" class="indexterm"/>
</p><p>Unfortunately, tuning for performance is one of the trickiest jobs imaginable because all components in the chain may play a role. Server-side considerations are the performance of the database engine used, the scripting language, and the web server.</p><p>Client-side, the quality of the presentation framework and the overall performance of the web browser are important and in between the server and client is the great unknown of the characteristics of the underlying network.<a id="id53" class="indexterm"/>
</p><p>With so many variables, it is not easy to design an optimal solution in advance. However, we can test the performance of individual components and see if the component is a bottle neck. For example, if it takes three seconds to refresh a page provided by a web application you can rule out the database engine as a bottleneck if you can time the database access independently. The knowledge gained creating unit tests can be reused here because we already know how to isolate some functionality, and adding a timer and asserting that the response for a query is fast enough can be made a test itself.</p><p>It is also quite feasible to separately measure the time it takes to fetch a web component and to render it in the browser with a tool like Firebug and get an idea whether the client or the server is the bottleneck. (Firebug is a Firefox extension and can be found at<a class="ulink" href="http://getfirebug.com/)"> http://getfirebug.com/)</a>.<a id="id54" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec08"/>Access control and authentication</h3></div></div></div><p>In almost every application that we develop in this book, we implement some sort of authentication scheme. Most of the time, we will use a simple username/password combination to verify that the user is who he/she claims to be. Once the user is authenticated, we can then decide to serve only certain information, for example, just a list of the tasks belonging to him/her, but no tasks of any other user.<a id="id55" class="indexterm"/>
</p><p>However, whether access to information is allowed, isn't always that basic. Even in simple applications, there might be a user who should be allowed more than others, for example, adding new users or resetting passwords. If the number of different things a user is allowed to do is small, this is straightforward to implement, but if the situation is more complex, it is not that easy to implement, let alone to maintain.</p><p>In the more elaborate applications featured in the later chapters of this book, we will therefore adopt the concept of role based access. The idea is to define roles that describe which actions are allowed when assuming a role. In a customer relations management application, for example, there might be three roles: a sales person, who is only allowed to access information for his customers, the sales manager who may access all information, and an administrator who may not access any information, but is allowed to back up and restore information, for example.</p><p>Once the rights of these roles are clear, we can associate any or all of these roles with specific persons. A small organization, for example, may have a technically savvy sales person who can also assume the admin role, yet still be unable to access information about customers other than his own this way.</p><p>If rights associated with a certain role are changed, we do not have to repeat this information for each and every person that may assume that role, thus making administration that much simpler.<a id="id56" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec09"/>Confidentiality</h3></div></div></div><p>In some applications, we may want to make sure no one is listening in on the data transferred between the browser and web server. After all, in general you do not know which path your data takes, as it is routed across the Internet and at any point there might be someone who can intercept your data.<a id="id57" class="indexterm"/>
</p><p>The easiest way to ensure confidentiality is to use connection level encryption and the HTTPS protocol does just that. The web server we use, CherryPy, is certainly capable of serving requests over HTTPS and configuring it to do so is quite simple but it involves creating signed certificates which is a bit out of the scope of this book. Refer to<a class="ulink" href="http://www.cherrypy.org/wiki/ServerObject"> http://www.cherrypy.org/wiki/ServerObject</a> for more information.<a id="id58" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec10"/>Integrity</h3></div></div></div><p>The last aspect of security we talk about in this context is data integrity. Corruption of data may not always be prevented, but wholesale destruction may be guarded against with proper backup and restore protocols.<a id="id59" class="indexterm"/>
</p><p>However, data corruption lurks in very small corners too. One of the trickiest things that can happen is the possibility of inserting data that is wrong. For example, if it is possible to input a date with a month outside the range 1-12, very strange things might happen if the application relies elsewhere on dates having the correct format.</p><p>It is, therefore, important to prevent the user entering wrong data by building in some sort of client-side validation. An excellent example is jQuery UI's<code class="literal"> datepicker</code> widget that we will encounter in<a class="link" href="ch03.html" title="Chapter 3. Tasklist I: Persistence"> Chapter 3</a>,<em> Tasklist I: Persistence</em>. If a text input field is adorned with a<code class="literal"> datepicker</code>, the user can only enter dates by selecting dates from the<code class="literal"> datepicker</code>. This is a great aid to the end-user, but we should never rely on client-side validation because our client-side validation might be inadequate (because it contains a bug or doesn't check all cases) and certainly cannot prevent malicious users from connecting to the server and actively inserting wrong data. We do need server-side input validation as well to prevent this and we will encounter some examples of it.<a id="id60" class="indexterm"/>
</p><p>The key thing is to provide both: server-side validation as a last resort and client-side as an aid to the user.<a id="id61" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec11"/>A final word on security</h3></div></div></div><p>Security is complex and tricky and details may be overlooked easily. You might know you have a front door made of 10 centimeter oak with state of the art steel locks, but if you forget to lock the backdoor all that oak and steel serves no purpose. Of all the subjects touched upon in this book, security is the one that you should always talk over with an expert. Even an expert cannot give you guarantees but taking a fresh look at the security requirements might keep you out of trouble. Make sure that you run the sample applications provided in this book in a secure environment behind a well managed firewall.<a id="id62" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Help, I am confused!</h2></div></div></div><p>Reading this chapter, you may get the feeling that developing web applications is horribly complex, even if you use the right tools. So many things may play a role! Do not despair though.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Time for action maintaining overview</h1></div></div></div><p>If you take a close look, you will see that none of it is rocket science, the most it takes is common sense and attention for detail, and in every chapter, we highlight the relevant issues in a straightforward language where it is relevant. Remember that this is a practical book, there will be many working examples that are examined in close detail and we won't inundate you with theory, but give you just enough to get things done.</p><p>At every step in the development process, ask yourself the following questions?</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What needs to be done? There is no need to work on all things at the same time, indeed this is practically impossible. Allow yourself to form a high level idea first and identify the components in the next level down. Don't get bogged down with details when the outline is not clear yet.</li><li class="listitem" style="list-style-type: disc">Which components of the application are involved? Identify the specific components involved when you develop a piece of functionality. The whole idea of identifying layers and components is to be able concentrate on a limited part of the application when developing.<p>This might not always work perfectly, but it certainly helps in maintaining focus. For example, when developing parts of the presentation layer, you may find that additional content is needed that should be provided by the delivery layer. Instead of immediately switching focus to that delivery layer, it's often simpler to define what is needed and complete the part of the presentation layer you are working on.
</p></li><li class="listitem" style="list-style-type: disc">What are the requirements? There is no need to implement stuff that is not needed. This may sound obvious, but many developers nevertheless fall into this trap. It is tempting of course to design your code to be as flexible as possible but it takes a lot of time, and as requirements change, it is unlikely that it'll prove flexible enough. Instead, the effort is better spent on writing code that is easy to understand so that the inevitable changes in requirements take less time to process.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>What just happened?</h2></div></div></div><p>When asking those questions and given the choices we made in this chapter, it might be helpful to draw a new picture that illustrates the technologies we will use:</p><div><img src="img/3746OS_01_03.jpg" width="156" alt="What just happened?"/></div><p>The different components between the server and client that together make up the web application can be pictured as a layered stack. For each layer, we have chosen one or a few technologies, as illustrated in the following diagram:</p><div><img src="img/3746OS_01_04.jpg" width="174" alt="What just happened?"/></div><p>Each application we encounter will be based on this model, so it might help to refer to this diagram once in a while if you feel you have lost track.</p><p>After reading this book, you will be left with the feeling that writing good, useable web applications is maybe a little bit more involved than you might have thought at first, but that is certainly within the reach of even the smallest of teams. Armed with all the fresh knowledge and practical experience, you will not have to compromise on quality, not even in the smallest project.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Summary</h1></div></div></div><p>This chapter gave us a head start in providing an overview of the components and techniques involved in creating a quality web application. Specifically, we looked at:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The components that make up a web application.</li><li class="listitem" style="list-style-type: disc">The technologies we choose to implement these components.</li><li class="listitem" style="list-style-type: disc">Which other issues play a role in the design, like security and usability.</li></ul></div><p>With this extra knowledge, nothing can hold us back from writing our first web application in Python and that is exactly what we will do in the next chapter.</p></div></div>
</body></html>