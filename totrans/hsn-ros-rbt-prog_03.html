<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Unit Testing of GoPiGo3</h1>
                </header>
            
            <article>
                
<p>After finishing the assembly of the hardware, in this chapter, you will get familiar with how GoPiGo3 works using the JupyterLab environment, a friendly interface that takes the structure of a notebook composed of human-readable paragraphs followed by Python code snippets. You will produce two versions of each test program: the JupyterLab notebook and the pure Python script.</p>
<p>Using these programming tools, you will test each sensor/actuator individually and check that they're working properly while learning about the technology behind each of them.</p>
<p><span>We will be covering the following topics:</span></p>
<ul>
<li>Getting started with Python programming under the user-friendly environment Jupyterlab</li>
<li>Testing the robot perception: distance sensor, line follower, and 2D</li>
<li>Testing the robot actuation: motors and encoders</li>
</ul>
<p>If you follow the practical exercises, you'll learn how the different packages (sensors, motors, and so on) build up the whole robot, what is measured with sensors, and how to systematically test sensors and actuators at the unit level.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The code for the first section, <em>Getting started with Python and Jupyterlab</em>, is included within the image of <em>DexterOS</em>, the custom operating system supplied by the manufacturer of GoPiGo3. In <a href="9bb411d1-934c-4497-aad4-7ad770d3783c.xhtml" target="_blank">Chapter 1</a><em>, Assembling the Robot</em>, we explained how to get this image and burn it to an SD card. This was explained in the <em>Quick hardware testing</em> <span>section in the </span><em>Getting started with DexterOS</em> <span>sub-section</span>.</p>
<p>The code for this chapter is in the GitHub repository of the book, located at <a href="https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter2_Unit_Tests">https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter2_Unit_Tests. </a>At the beginning of the <em>Unit testing of sensors and drives</em> section, we explain how to clone the code locally in the Raspberry Pi.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with Python and JupyterLab</h1>
                </header>
            
            <article>
                
<p><strong>JupyterLab</strong> is a very extensive tool in the Python community because it lets you write a program as if you were solving a mathematics problem in a school class. That is to say, you write the heading, then the problem statement and the initial data. After this declaration, you write a paragraph explaining the operation that you are going to perform, and then you write the Python line(s) that perform such operation in a <em>code cell</em>. For every operation you repeat the same steps:</p>
<ol>
<li>A human-readable paragraph explaining the next operation, which is formatted with the well-known <em>markdown syntax</em> <a href="https://commonmark.org/help/">https://commonmark.org/help/</a>.</li>
<li>A code cell with the lines of Python that perform the operation.</li>
<li>Repeat steps 1 and 2 for every code snippet that perform a single operation. The final one will provide the solution to the problem..</li>
</ol>
<p>Here's a self-explaining example for reading the distance sensor of GoPiGo3:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1351 image-border" src="assets/c8c23cb7-4fd9-4da5-84a8-a8c43a474b81.png" style="width:59.50em;height:52.92em;"/></p>
<p>Next, we are going to explain how to launch JupyterLab for GoPiGo3.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Launching JupyterLab for GoPiGo3</h1>
                </header>
            
            <article>
                
<p>In DexterOS, you have two lessons that explain both Jupyter notebooks and controlling the robot with <span>Python</span><span>:</span></p>
<ol>
<li>You can access them by <span>n</span><span>avigating to </span><kbd>http://mygopigo.com</kbd> or <kbd>http://10.10.10.10</kbd><span>, and click on <span class="packt_screen">LEARN</span>, then <span class="packt_screen">Lessons in Python</span>: </span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1352 image-border" src="assets/c4b8cba5-bd1c-4606-8156-2005494a8a57.png" style="width:44.42em;height:11.42em;"/></p>
<p style="padding-left: 60px"><span>The JupyterLab environment is then launched, and in the left part of the window you will see two files:</span></p>
<ul>
<li style="list-style-type: none">
<ul>
<li><kbd>1_Moving_Around.ipynb</kbd> is a Jupyter notebook that explains step-by-step how to move the robot forward and rotate it. Follow the instructions given in the notebook to execute the commands.</li>
<li><kbd>2_The_Environment.ipynb</kbd> is another example that explains how to deal with JupyterLab: run a cell, stop the execution, and so on. If you got stuck in the previous notebook, follow this one and return to the first afterward.</li>
</ul>
</li>
</ul>
<p class="mce-root"/>
<ol start="2">
<li>Now let's try <kbd>1_Moving_Around.ipynb</kbd>. The following command makes the robot go forward 10 cm:</li>
</ol>
<pre style="padding-left: 60px">my_gopigo.drive_cm(10)</pre>
<ol start="3">
<li>If you prefer to work in inches, use this command:</li>
</ol>
<pre style="padding-left: 60px">my_gopigo.drive_inches(10)</pre>
<ol start="4">
<li>If you execute both in the same code cell, you will notice a small gap before the execution of the second command:</li>
</ol>
<pre style="padding-left: 60px">my_gopigo.drive_cm(10)<br/>my_gopigo.drive_inches(10)</pre>
<p>Now let's perform a physical test with the robot:</p>
<ol>
<li>Mark a sign on the floor in the starting point, drive 10 cm forward and 10 cm backward and find how precise the motion <span>is</span>:</li>
</ol>
<pre style="padding-left: 60px"># Forward<br/>my_gopigo.drive_cm(10)<br/>my_gopigo.drive_inches(10)<br/><br/># Backward<br/>my_gopigo.drive_cm(-10)<br/>my_gopigo.drive_inches(-10)</pre>
<p style="padding-left: 60px">You should find that it returns exactly to the starting point. Errors that we measured with a micrometer (three times) were +1.29 mm, -0.76 mm, and +2.16 mm. Positive means that it passed over the starting point when driving back, and negative means that it did not arrive at the starting point.</p>
<ol start="2">
<li>If you add the distances <span>(10 cm + 10 inches = 35.4 cm) </span>into one <span>forward command</span>, and then make another command for moving back the same distance, t<span>he errors we measured were </span><span>(</span><span>again, we did it three times)</span> -0.01 mm, -1.40 mm, and -0.72 mm<span>:</span></li>
</ol>
<pre style="padding-left: 60px"># Forward<br/>my_gopigo.drive_cm(+35.4)<br/><br/># Backward<br/>my_gopigo.drive_cm(-35.4)</pre>
<p style="padding-left: 60px">You can see that the pause caused by using two commands introduces an error that is in the order of 1 mm. Using only one command for forward and one for backward substantially <span>reduces </span>the error.</p>
<ol start="3">
<li>We can perform a similar test for turning:</li>
</ol>
<pre style="padding-left: 60px"># Turn clockwise (right)<br/>my_gopigo.turn_degrees(90)<br/><br/># Turn counterclockwise (left)<br/>my_gopigo.turn_degrees(-90)</pre>
<ol start="4">
<li>Other useful commands are as follows:</li>
</ol>
<pre style="padding-left: 60px">my_gopigo.forward()<br/>my_gopigo.backward()<br/>my_gopigo.right()<br/>my_gopigo.left()<strong><br/></strong></pre>
<ol start="5">
<li>To stop the robot, use this command:</li>
</ol>
<pre style="padding-left: 60px"><strong>my_gopigo.stop()</strong></pre>
<ol start="6">
<li>It is crucial to note that software flow may not be compatible with robot physics. Try this sequence and observe what GoPiGo3 does:</li>
</ol>
<pre style="padding-left: 60px">my_gopigo.forward()<br/>my_gopigo.backward()<br/>my_gopigo.right()<br/>my_gopigo.left()</pre>
<p>It seems that only the last line is executed, which is <span><kbd>my_gopigo.left()</kbd>. What is actually happening is that the commands execute so quickly (a few milliseconds each) that the robot's inertia does not allow enough time for GoPiGo to move forward, backward, or right. Remove the last line to check it: the only command you see physically executed is now </span><kbd>my_gopigo.right()</kbd>.</p>
<div class="packt_tip">One of the most challenging issues when programming a robot is understanding its dynamics, because something that may seem to be a software bug may be an unexpected physical response of the robot. So, prior to developing the software, you must make sure you understand the physics of the problem, including its mass (inertia), friction forces, the maximum load on the motors, the power supply limit, and the battery level. The list of variables coming from the physical world can be endless, and you should apply your knowledge of mechanics and electricity to successfully develop functional software.</div>
<p>A possible solution for this simple case is to specify in the sequence the distance or angle you want it to move:</p>
<pre>my_gopigo.drive_cm(-10) # Forward<br/>my_gopigo.drive_cm(10) # Backward<br/>my_gopigo.turn_degrees(90) # Right (clockwise)<br/>my_gopigo.turn_degrees(-90) # Left (counterclockwise)</pre>
<p>To save your work in DexterOS, you have to do it from the <kbd>~/.lessons_python</kbd> folder. This is owned by <kbd>pi:users</kbd>, while the DexterOS user is <kbd>jupyter</kbd> (issue the <kbd>$ whoami</kbd> <span>comm</span><span>and </span>in a terminal or just see it in the prompt). Go one level above in the tree, and create a folder <span>there </span>with any name you wish. Then save your changes in that location with <span class="packt_screen">File</span> | <span class="packt_screen">Save Notebook As...</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hardware testing</h1>
                </header>
            
            <article>
                
<p>To access these notebooks in DexterOS outside of the LEARN environment, n<span>avigate t</span>o <a href="http://mygopigo.com/">http://mygopigo.com</a><span> </span><span>or</span><span> </span><kbd>http://10.10.10.10</kbd><span>, and click on <span class="packt_screen">Code in Python</span>. JupyterLab will be launched:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1353 image-border" src="assets/e6cd7f57-e741-4fdc-85ec-25dbde6eac35.png" style="width:58.00em;height:22.00em;"/></p>
<p>In the file manager view on the left side of the screen, you will find these two notebooks:</p>
<ul>
<li>One of them is <kbd>First Ride Around.ipynb</kbd>, which<strong> </strong>provides a widget to drive the robot with a visual panel:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1354 image-border" src="assets/bbd195b6-163a-44d5-831d-b2a51b8d2f57.png" style="width:26.00em;height:8.58em;"/></p>
<ul>
<li><span>The other notebook is </span><kbd>Hardware Testing.ipynb</kbd>, which runs specific tests for batteries, LEDs, and encoders. What we should expect in terms of GoPiGo3's behavior is addressed in the following subsection. </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing battery, LEDs, and motors/encoders</h1>
                </header>
            
            <article>
                
<p>Open the notebook and go through each cell to understand what it does.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Battery level</h1>
                </header>
            
            <article>
                
<p>The following command reads and displays the current battery voltage<em>.</em> It should be above 9 V for GoPiGo3 to work properly. When the batteries are not charged enough, you will lose the Wi-Fi connection with the robot and you will have to recharge them or replace them with new batteries:</p>
<pre style="padding-left: 30px">print("Battery voltage : ", GPG.get_voltage_battery() )<br/><br/>OUTPUT ===&gt; Battery voltage : 9.114<em><br/></em></pre>
<p>Next, we will look at hardware information and voltage levels.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hardware information and current voltage levels</h1>
                </header>
            
            <article>
                
<p>The next block of commands prints information of the manufacturer, hardware and firmware versions, and battery levels. The following relates to the output:</p>
<ul>
<li><em>Battery voltage</em> is the same as before. The measurement gives a slightly different value, 9.294V, and it is OK.</li>
<li><em>5V voltage</em> is that of the power supply to the Raspberry Pi through its GPIO. GoPiGo red board has a power regulator that transforms the 9V raw input to a regulated 5V. If the batteries are properly charged, this value should be very close to 5V as shown here:</li>
</ul>
<pre style="padding-left: 60px">print("Manufacturer : ", GPG.get_manufacturer() )<br/>print("Board : ", GPG.get_board() )<br/>print("Serial Number : ", GPG.get_id() )<br/>print("Hardware version: ", GPG.get_version_hardware())<br/>print("Firmware version: ", GPG.get_version_firmware())<br/>print("Battery voltage : ", GPG.get_voltage_battery() )<br/>print("5v voltage : ", GPG.get_voltage_5v() )<br/><br/>OUTPUT ===&gt; <br/>Manufacturer    :  Dexter Industries
Board           :  GoPiGo3
Serial Number   :  F92DD433514E343732202020FF112535
Hardware version:  3.x.x
Firmware version:  1.0.0
Battery voltage :  9.294
5v voltage      :  4.893</pre>
<p>Next, we will check the LEDs and blinkers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">LEDs and blinkers</h1>
                </header>
            
            <article>
                
<p>There are two LEDs on top of the board that simulate GoPiGo3's eyes. By running the following block of code, they will change their color:</p>
<pre class="mce-root"><span>colors = [ (255,0,0), (255,255,0), (255,255,255), (0,255,0), (0,255,255), (0,0,255), (0,0,0)]</span><br/><span>for color in colors:</span><br/><span>    GPG.set_eye_color(color)</span><br/><span>    GPG.open_eyes()</span><br/><span>    time.sleep(0.5)</span></pre>
<p>The blinkers are two small red LEDs underneath the red board at the front. The following code makes them blink 5 times:</p>
<pre>for i in range(5):<br/> GPG.led_on("left")<br/> GPG.led_on("right")<br/> time.sleep(0.5)<br/> GPG.led_off("left")<br/> GPG.led_off("right")<br/> time.sleep(0.5)</pre>
<p><span>Check it visually, and be aware that no message appears in the console.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Motors and encoders test</h1>
                </header>
            
            <article>
                
<p>The following cell will run for approximately 5 seconds and will report encoder readings:</p>
<pre>GPG.set_motor_dps(GPG.MOTOR_LEFT | GPG.MOTOR_RIGHT, 100)<br/>start = time.time()<br/>lapse = 0<br/><br/>while lapse &lt; 5:<br/>   lapse = time.time() - start<br/>   time.sleep(0.5)<br/>   print("LEFT: {} RIGHT:{}".format(GPG.get_motor_status(GPG.MOTOR_LEFT),GPG.get_motor_status(GPG.MOTOR_RIGHT)))<br/><br/>passed_test = GPG.get_motor_status(GPG.MOTOR_LEFT)[0]==0 and GPG.get_motor_status(GPG.MOTOR_RIGHT)[0]==0<br/>GPG.set_motor_dps(GPG.MOTOR_LEFT | GPG.MOTOR_RIGHT, 0)<br/><br/>if passed_test:<br/>   print("Test passed.")<br/>else:<br/>   print("Test failed.")</pre>
<p>And these are the results:</p>
<pre><strong>LEFT: [0, 26, 3095, 101]  RIGHT:[0, 26, 4806, 101]</strong><br/><strong>LEFT: [0, 26, 3146, 101]  RIGHT:[0, 28, 4856, 101]</strong><br/><strong>LEFT: [0, 26, 3196, 101]  RIGHT:[0, 28, 4906, 101]</strong><br/><strong>LEFT: [0, 26, 3246, 101]  RIGHT:[0, 26, 4957, 96]</strong><br/><strong>LEFT: [0, 26, 3296, 101]  RIGHT:[0, 26, 5007, 101]</strong><br/><strong>LEFT: [0, 26, 3347, 101]  RIGHT:[0, 28, 5057, 101]</strong><br/><strong>LEFT: [0, 24, 3397, 105]  RIGHT:[0, 26, 5107, 96]</strong><br/><strong>LEFT: [0, 21, 3447, 96]  RIGHT:[0, 26, 5158, 101]</strong><br/><strong>LEFT: [0, 26, 3497, 101]  RIGHT:[0, 21, 5208, 101]</strong><br/><strong>LEFT: [0, 28, 3547, 96]  RIGHT:[0, 28, 5258, 96]</strong><br/><strong>LEFT: [0, 33, 3598, 101]  RIGHT:[0, 33, 5308, 101]</strong><br/><strong>Test passed.</strong></pre>
<p>We should see the message at the end telling if the test has passed. Do not worry at the moment about understanding the numbers: it is an internal test in which GoPiGo3 checks itself and reports whether it passed or failed.</p>
<p>If it's successful, you can go ahead with the following test. GoPiGo3 will drive forward for 10 cm and the output value at the end should be approximately 10. Should this test fail, you can stop the robot by clicking the red <strong>Stop</strong> button at the top:</p>
<pre>GPG.reset_encoders()<br/>#GPG.set_speed(GPG.DEFAULT_SPEED)<br/>GPG.drive_cm(10)<br/>encoders_read = round(GPG.read_encoders_average())<br/>print("Drove {:.2f} cm".format(encoders_read))<br/>if encoders_read == 10:<br/> print("Test passed.")<br/>else:<br/> print("Test failed.")</pre>
<p>If everything goes well, you will obtain this message:</p>
<pre><strong><span>Drove 10.00 cm Test passed.</span></strong></pre>
<p><span>Again, should this test fail you can stop the robot by pressing the red</span> <strong>Stop</strong> <span>button at the top. </span>After these basic tests, we have enough understanding of GoPiGo3's hardware and software to perform the unit testing, which is the main goal of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit testing of sensors and drives</h1>
                </header>
            
            <article>
                
<p>In this section, we will run some simple scripts in Python by using Jupyter Notebooks. From a terminal in your laptop, clone the book repository and go into the <kbd>Chapter2_Unit_Tests</kbd> <span>folder </span>to access the files for this chapter:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming</strong><br/><strong>$ cd Hands-On-ROS-for-Robotics-Programming/Chapter2_Unit_Tests</strong></pre>
<p>For completeness, we have included the notebooks used in the previous section inside the <kbd>lessons_GettingStarted</kbd> <span>folder.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Quick start with sensors and motors</h1>
                </header>
            
            <article>
                
<p>To enter the Python environment of your robot, switch on the red board and connect to the <em>GoPiGo</em> Wi-Fi network from your laptop. Then, visit the following URL in the browser:</p>
<p><kbd>http://10.10.10.10/python</kbd></p>
<p>In JupyterLab, focus on the left-hand side, where the file storage is shown. To run any of the examples, you will have to manually upload to the location where you want to place it in the robot storage. Create a folder named  <kbd>Chapter2_Unit_Tests</kbd><strong><span> </span></strong><span>and upload the required files. We will indicate at the beginning of each exercise which file we will use.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Driving around</h1>
                </header>
            
            <article>
                
<p>The files in this sub-section are in the <kbd>./Chapter2_Unit_Tests/drivingAround</kbd> <span>folder </span>of the repository. You can upload them one by one. Afterward, launch a shell session in JupyterLab by opening a launcher tab:</p>
<ol>
<li><span>Select the <span class="packt_screen">Terminal</span> icon from the tab, as shown in the following screenshot:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/19f1b176-6d0b-4600-9925-74a082473008.png" style="width:41.75em;height:37.67em;"/></p>
<ol start="2">
<li>Execute the scripts from the terminal by changing to their location:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd<span>./Chapter2_Unit_Tests/</span>drivingAround</strong><br/><strong>$ python &lt;name_of_script.py&gt;</strong></pre>
<p>The first script is <kbd>1-easyMotors.py</kbd>, and it plays a very simple sequence:</p>
<ol>
<li><span>Move the motors forward for 1 second.</span></li>
<li>Stop the motors for 1 second.</li>
<li>Drive the robot for 50 cm and then stop.</li>
<li>Turn right for 1 second.</li>
<li>Turn left for 1 second.</li>
<li>Stop.</li>
</ol>
<p>You can see the first part of the script in the following code listing, which shows the commands to move forward for 1 second, and then stop for another second:</p>
<pre># import the time library for the sleep function<br/><strong>import time</strong><br/># import the GoPiGo3 drivers<br/><strong>from easygopigo3 import EasyGoPiGo3</strong><br/><br/># Create an instance of the GoPiGo3 class.<br/># GPG will be the GoPiGo3 object.<br/><strong>gpg = EasyGoPiGo3()</strong><br/><br/><strong>print("Move the motors forward freely for 1 second.")</strong><br/><strong>gpg.forward()</strong><br/><strong>time.sleep(1)</strong><br/><strong>gpg.stop()</strong><br/>print("Stop the motors for 1 second.")<br/>time.sleep(1)</pre>
<p>The second part is shown here, and it includes the commands to drive forward 50 cm, then turn right for 1 second, and then turn left for 1 second:</p>
<pre><strong>print("Drive the motors 50 cm and then stop.")</strong><br/><strong>gpg.drive_cm(50, True)</strong><br/><strong>time.sleep(1)</strong><br/><br/>print("Turn right 1 second.")<br/>gpg.right()<br/>time.sleep(1)<br/><strong>print("Turn left 1 second.")</strong><br/><strong>gpg.left()</strong><br/><strong>time.sleep(1)</strong><br/><br/>print("Stop!")<br/>gpg.stop()<br/>print("Done!")</pre>
<p>The next script is <kbd>2-driveSquare.py</kbd>, and it does what it says: it draws a square on the floor. If we use a <kbd>for</kbd> loop that makes a 90º rotation after each 30 cm drive, we get a program with very few lines:</p>
<pre>from easygopigo3 import EasyGoPiGo3<br/><br/>gpg = EasyGoPiGo3()<br/><strong>length = 30</strong><br/><br/>for i in range(4):<br/>  <strong>gpg.drive_cm(length)</strong> # drive forward for length cm<br/>  <strong>gpg.turn_degrees(90)</strong> # rotate 90 degrees to the right</pre>
<p>The <kbd>3-circularMoves.py</kbd> <span>Python script </span>makes GoPiGo3 travel a semicircle in one direction, and then in the opposite, returning to the starting point<span>:</span></p>
<pre>from easygopigo3 import EasyGoPiGo3<br/><br/>gpg = EasyGoPiGo3()<br/><br/><strong>gpg.orbit(180, 50)</strong> # draw half a circle<br/><strong>gpg.turn_degrees(180)</strong> # rotate the GoPiGo3 around<br/><strong>gpg.orbit(-180, 50)</strong> # return on the initial path<br/><strong>gpg.turn_degrees(180)</strong> # and put it in the initial position</pre>
<p>The program <kbd>4-drawEight.py</kbd><strong> </strong>combines arcs and straight paths to draw an 8 shape on the floor:</p>
<pre><span class="kn">from</span> <span class="nn">easygopigo3</span> <span class="kn">import</span> <span class="n">EasyGoPiGo3<br/></span><span class="n"><br/>gpg</span> <span class="o">=</span> <span class="n">EasyGoPiGo3</span><span class="p">()<br/></span><strong><span class="n">radius</span> <span class="o">=</span> <span class="mi">30<br/></span><span class="n"><br/>gpg</span><span class="o">.</span><span class="n">orbit</span><span class="p">(</span><span class="o">-</span><span class="mi">270</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span></strong> <span class="c1"># to rotate to the left<br/></span><strong><span class="n">gpg</span><span class="o">.</span><span class="n">drive_cm</span><span class="p">(</span><span class="n">radius</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span></strong> <span class="c1"># move forward<br/></span><strong><span class="n">gpg</span><span class="o">.</span><span class="n">orbit</span><span class="p">(</span><span class="mi">270</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span></strong> <span class="c1"># to rotate to the right<br/></span><strong><span class="n">gpg</span><span class="o">.</span><span class="n">drive_cm</span><span class="p">(</span><span class="n">radius</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span></strong> <span class="c1"># move forward</span></pre>
<p>Finally, the program <kbd>5-accelerateForward.py</kbd> illustrates how to accelerate the robot. The sequence is pretty simple:</p>
<ol>
<li>Set an initial speed and an end speed.</li>
<li>Calculate a step by dividing the interval between them by 20.</li>
<li>Run a loop that increases the speed in the step value in each iteration.</li>
<li>Perform one iteration every 0.1 seconds.</li>
<li>After 2 seconds, GoPiGo3 will reach the end speed and will stop:</li>
</ol>
<pre><span class="kn">from</span> <span class="nn">easygopigo3</span> <span class="kn">import</span> <span class="n">EasyGoPiGo3<br/></span><span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span><span class="p">,</span> <span class="n">sleep<br/><br/></span><span class="n">gpg</span> <span class="o">=</span> <span class="n">EasyGoPiGo3</span><span class="p">()<br/></span><span class="c1"><br/># setting speed to lowest value and</span><span class="c1"> calculating the step increase in speed<br/></span><strong><span class="n">current_speed</span> <span class="o">=</span> <span class="mi">50<br/></span><span class="n">end_speed</span> <span class="o">=</span> <span class="mi">400<br/></span></strong><span class="n">step</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_speed</span> <span class="o">-</span> <span class="n">current_speed</span><span class="p">)</span> <span class="o">/</span> <span class="mi">20<br/></span><strong><span class="n">gpg</span><span class="o">.</span><span class="n">set_speed</span><span class="p">(</span><span class="n">current_speed</span><span class="p">)<br/><br/></span></strong><span class="c1"># start moving the robot at an ever increasing speed<br/></span><span class="n">gpg</span><span class="o">.</span><span class="n">forward</span><span class="p">()<br/></span><strong><span class="k">while</span> <span class="n">current_speed</span> <span class="o">&lt;=</span> <span class="n">end_speed</span><span class="p">:<br/></span></strong>  <span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)<br/></span><strong>  <span class="n">gpg</span><span class="o">.</span><span class="n">set_speed</span><span class="p">(</span><span class="n">current_speed</span><span class="p">)<br/></span>  <span class="n">current_speed</span> <span class="o">+=</span> <span class="n">step<br/><br/></span></strong><span class="c1"># and then stop it<br/></span><strong><span class="n">gpg</span><span class="o">.</span><span class="n">stop</span><span class="p">()<br/></span></strong></pre>
<p>Let's now test all of the sensors with which we have equipped the robot.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Distance sensor</h1>
                </header>
            
            <article>
                
<p class="mce-root">To communicate with the sensors, we will use the DI-sensors Python library <a href="https://github.com/DexterInd/DI_Sensors">https://github.com/DexterInd/DI_Sensors</a>.</p>
<p class="mce-root">First of all, we need to revise the port connections. This is what we will review now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Check port connections</h1>
                </header>
            
            <article>
                
<p>The following diagram should be of great help when connecting sensors to GoPiGo3 ports, in order to make sure that the hardware is correctly wired:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1355 image-border" src="assets/112f7869-1ea5-484f-9787-b236220fef92.png" style="width:38.67em;height:24.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Image courtesy: Dexter Industries:</span> https://gopigo3.readthedocs.io/en/master/_images/gpg3_ports.jpg</div>
<p>From the previous chapter, you should remember the purpose of each port:</p>
<ul>
<li class="mce-root">Ports <strong>AD1</strong> and <strong>AD2</strong> are general-purpose <em>input/output</em> ports.</li>
<li class="mce-root">Ports <strong>SERVO1</strong> and <strong>SERVO2</strong> are the servo controller ports.</li>
<li class="mce-root">The <strong>I2C</strong> <span>ports are</span> where you connect <em>I2C-enabled</em> devices.</li>
<li class="mce-root">The <strong>SERIAL</strong> <span>port </span>is where you can connect <em>UART-enabled</em> devices.</li>
</ul>
<p>Given this description, check that sensors are connected as we described in the first chapter:</p>
<ul>
<li>The <strong>Distance sensor</strong><span> should be </span>plugged into<span> </span><strong>I2C-1</strong>, the I2C port on the left side of GoPiGo3.</li>
<li>The Servo package should be connected to <strong>SERVO1</strong>.</li>
<li>The <strong>Line follower</strong><span> should be plugged in</span>to<span> </span><strong>I2C-2</strong>, the I2C port on the right side.</li>
<li>The <strong>IMU</strong><span> </span>sensor should be connected to<span> </span><strong>AD1</strong><span> </span>(on the left side).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Distance sensor unit test</h1>
                </header>
            
            <article>
                
<p><span>Although you have connected the distance sensor to the </span><strong>I2C-1</strong><span> port, be aware that GoPiGo3 software libraries will not require you to specify in the script which of the two ports you are using. It will be automatically detected.</span></p>
<p>The files for testing are located in the <kbd><span>./Chapter2_Unit_Tests/</span><span>DI-distance</span></kbd> <span>folder </span>of the repository. You can upload them one by one to DexterOS:</p>
<ul>
<li><kbd>di-distance_cm.py</kbd></li>
<li><kbd>di-distance-easygopigo_mm.py</kbd></li>
</ul>
<p>Afterward, open a shell session in <span>JupyterLab by opening a launcher window and selecting the terminal icon from it. Execute the scripts from the terminal by moving to their location</span>:</p>
<pre><strong>$ cd<span>./Chapter2_Unit_Tests/</span>DI-distance</strong><br/><strong>$ python &lt;script.py&gt;</strong></pre>
<p>The first script is <kbd>di-distance_cm.py</kbd>. It takes a reading at a fixed time rate:</p>
<pre># import the modules<br/>from di_sensors.easy_distance_sensor import EasyDistanceSensor<br/>from time import sleep<br/><br/># instantiate the distance object<br/>my_sensor = EasyDistanceSensor()<br/><br/># and read the sensor iteratively<br/>while True:<br/>  read_distance = my_sensor.read()<br/>  print("distance from object: {} cm".format(read_distance))<br/><br/>  sleep(0.1)<strong><br/></strong></pre>
<p>The publishing interval is 0.1 seconds, as specified in the line <kbd>sleep(0.1)</kbd>. The detailed specification of the distance sensor API can be found at <a href="https://di-sensors.readthedocs.io/en/master/api-basic.html#easydistancesensor">https://di-sensors.readthedocs.io/en/master/api-basic.html#easydistancesensor</a>. The <kbd>my_sensor.read()</kbd> <span>method provides </span>the distance in centimeters, but there are an other two methods if you prefer to use other units:</p>
<ul>
<li><kbd>my_sensor.read_mm()</kbd> is for millimeters.</li>
<li><kbd>my_sensor.read_inch()</kbd> is for inches.</li>
</ul>
<p>The second script, <kbd>di-distance-easygopigo_mm.py</kbd>, imports the GoPiGo3 library as per <a href="https://github.com/DexterInd/GoPiGo3">https://github.com/DexterInd/GoPiGo3</a>, which implicitly includes the sensor library, <a href="https://github.com/DexterInd/DI_Sensors">https://github.com/DexterInd/DI_Sensors</a>. You can see that it uses the same class methods to take readings. In this case, the function that reads the distance in millimeters is used:</p>
<pre># import the GoPiGo3 drivers<br/><strong>import time</strong><br/><strong>import easygopigo3 as easy</strong><br/><br/># This example shows how to read values from the Distance Sensor<br/><br/># Create an instance of the GoPiGo3 class.<br/># GPG will be the GoPiGo3 object.<br/><strong>gpg = easy.EasyGoPiGo3()</strong><br/><br/># Create an instance of the Distance Sensor class.<br/># I2C1 and I2C2 are just labels used for identifyng the port on the GoPiGo3 board.<br/># But technically, I2C1 and I2C2 are the same thing, so we don't have to pass any port to the constructor.<br/><strong>my_distance_sensor = gpg.init_distance_sensor()</strong><br/><br/>while True:<br/>    # Directly print the values of the sensor.<br/><strong>    print("Distance Sensor Reading (mm): " + str(my_distance_sensor.read_mm()))</strong></pre>
<p>For completeness, we have included in the folder of this chapter the two libraries:</p>
<ul>
<li><kbd>easysensors.py</kbd> for the sensors</li>
<li><kbd>easygopigo3.py</kbd> for the robots</li>
</ul>
<p>If you inspect the latter, you will see this <kbd>import</kbd> line at the beginning of the file:</p>
<div>
<pre><span>import <strong>easysensors</strong><br/>...<br/>try</span><span>:<br/></span><span> </span><span>from</span><strong><span> di_sensors </span></strong><span>import</span><strong><span> easy_distance_sensor</span></strong></pre></div>
<p>This way, we can incorporate the DI sensors you need to increase the perception capabilities of your robot. Let's go through an example to better understand the libraries provided by Dexter Industries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GoPiGo3 API library</h1>
                </header>
            
            <article>
                
<p>The main class of the robot is <kbd>GoPiGo3</kbd>, and you can see the class structure in the following diagram. The <strong>easysensors</strong> l<span>ibrary </span>is imported (inherited) by the <kbd>EasyGoPiGo3</kbd><strong> </strong>class, and so has access to all sensor methods. <span>The </span><span>class structure is shown in the following diagram:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1356 image-border" src="assets/64a7a7d3-b3ea-40f2-abe7-c754fa52aa5e.png" style="width:42.75em;height:34.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Image courtesy: Dexter Industries: https://gopigo3.readthedocs.io/en/master/_images/inheritance-e4cb3d2ae1367b2d98aab1a112a1c8e1b7cd9e47.png</span></div>
<p>A summarized table with all the functions of the class is available at <a href="https://gopigo3.readthedocs.io/en/master/api-basic/structure.html#functions-short-list">https://gopigo3.readthedocs.io/en/master/api-basic/structure.html#functions-short-list</a>. The API library is covered in detail at <a href="https://gopigo3.readthedocs.io/en/master/api-basic/easygopigo3.html">https://gopigo3.readthedocs.io/en/master/api-basic/easygopigo3.html</a></p>
<p>Hence, using the <kbd>easygopigo3.py</kbd> library, you create an instance of your <span>robot</span> and initialize the sensors you need. For example, the distance sensor is initiated with this method of the class:</p>
<pre>easygopigo3.EasyGoPiGo3.init_distance_sensor([port])</pre>
<p>In our script, this is accomplished in three lines:</p>
<pre>import easygopigo3 as easy<br/>gpg = easy.EasyGoPiGo3()<br/>my_distance_sensor = gpg.init_distance_sensor()</pre>
<p>In the first line, you import the <kbd>easygopigo3</kbd> library. In the second line, you instantiate a robot object, and in the third line, you initialize the distance sensor. <span>Then you are ready to acquire data from the sensor:</span></p>
<pre>my_distance_sensor.read_mm()</pre>
<p><span>In short, if you use the </span><kbd>easygopigo3.py</kbd> lib<span>rary, </span><em>the top-level object is the robot itself</em><span>. On the other hand, i</span>f you were using the sensors in a custom project that doesn't deal with GoPiGo, the top-level object is yet to be created unless you already have <span>the corresponding library </span>available. If you don't, <span>it is your task to define a class that represents that entity (a weather station, for example)</span> and import the DI sensors library<span>. </span>This is the topic of the next sub-section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DI sensors API library</h1>
                </header>
            
            <article>
                
<p>Each sensor type has its own class and methods. In the <kbd>./Chapter2_Unit_Tests/DI-distance/di-distance_cm.py</kbd> script, we were using the DI-sensors library. The <span>class structure is shown in the following screenshot and explained at <a href="https://di-sensors.readthedocs.io/en/master/structure.html#library-structure">https://di-sensors.readthedocs.io/en/master/structure.html#library-structure</a>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1357 image-border" src="assets/4f7277c6-10ae-4f61-b525-128cd404e13c.png" style="width:45.83em;height:29.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Image courtesy: Dexter Industries: https://di-sensors.readthedocs.io/en/master/_images/inheritance-a8243413ad98ddae26cdf121c775ad137c7f2e30.png</span></div>
<p><span>Summarized tables with methods for all DI sensors are shown at </span><a href="https://di-sensors.readthedocs.io/en/master/structure.html#functions-short-list">https://di-sensors.readthedocs.io/en/master/structure.html#functions-short-list</a>. You will find two alternatives of usage for each sensor:</p>
<ul>
<li>The <strong>easy methods</strong> – prepended with the <kbd>easy</kbd><em> </em>prefix – are for quick usage and provide top-level functionalities. You can see the syntax on the right-hand side of the preceding diagram.</li>
</ul>
<ul>
<li>The <strong>advanced methods</strong> without the <kbd>easy</kbd> prefix are for developer use and provide low-level control.</li>
</ul>
<p>The distance sensor is managed with the following class:</p>
<pre>di_sensors.easy_distance_sensor.EasyDistanceSensor([…])</pre>
<p>In our script,the sensor is initialized as follows::</p>
<div>
<pre><span>from</span><strong><span> di_sensors.</span></strong><span>easy_</span><strong><span>distance_sensor </span></strong><span>import</span><span> Easy<strong>DistanceSensor</strong><br/></span>my_sensor <span>=</span><span> EasyDistanceSensor()</span></pre></div>
<p class="mce-root">The preceding lines are described as follows:</p>
<ul>
<li><span>On the first line, you import the class of the distance sensor. Be aware that you need to import just the <kbd>EasyDistanceSensor</kbd> class from </span><kbd>di_sensors.easy_distance_sensor</kbd>.</li>
<li><span>On the second line, you instantiate the distance sensor object with the</span> <kbd>Easy</kbd><span> class.</span></li>
</ul>
<p><span>Then you are ready to acquire data from the sensor:</span></p>
<pre>read_distance <span>=</span><span> my_sensor.read()<br/></span></pre>
<p>Compare with the case of not using the <kbd>easy</kbd> option. The syntax is similar, the only difference being the removal of the <kbd>_easy</kbd> and <kbd>Easy</kbd> <span>prefixes:</span></p>
<pre>from <strong>di_sensors.distance_sensor</strong> import <strong>DistanceSensor<br/></strong>my_sensor <span>=</span><span><strong> DistanceSensor</strong>()<br/></span>read_distance <span>=</span><span> my_sensor.read()<br/></span></pre>
<p>The same scheme will apply to the other sensors we will cover later, specifically, the line follower and the IMU.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Servo package</h1>
                </header>
            
            <article>
                
<p>The servo package consists of a <span><strong>Pulse Width Modulation</strong> (<strong>PWM</strong>) </span>servomotor. It is controlled in an open loop by applying a voltage that produces a proportional rotation of the motor shaft in a 180° amplitude coverage. In the following image there is a small rod that lets us visualize the rotation. In our GoPiGo3 assembly, we will see rotating the distance sensor:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bff8792a-e5b6-45d2-a7f3-6d260758da89.png" style="width:41.75em;height:34.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Image courtesy: Dexter Industries: https://www.dexterindustries.com/wp-content/uploads/2017/06/GoPiGo3-Servo-Assembly-11-600x338.jpg</span></div>
<p>The servo package is part of the GoPiGo3 API library described in the <em>Distance sensor unit test</em> section. Its API methods are detailed at <a href="https://gopigo3.readthedocs.io/en/master/api-basic/sensors.html#servo">https://gopigo3.readthedocs.io/en/master/api-basic/sensors.html#servo</a>.</p>
<p>Next, we will carry out some unit tests to check that it rotates properly. Since we have mounted the <span>distance sensor with</span> the servo package, we can measure the distance to obstacles in a 180º field of view by rotating the servo. In the test, we will also calibrate the actual field of view your robot will be able to cover.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Servo package unit test</h1>
                </header>
            
            <article>
                
<p>The test consists of placing the distance sensor with respect to the servomotor shaft in an angular position that covers the entire front view of GoPiGo3, from left to right. All the explanations and code are in a Jupyter notebook located at <kbd><span>./Chapter2_Unit_Tests/DI-servo_package/servoCalibration.ipynb</span></kbd>:</p>
<ol>
<li>First, we create the servo object from the <kbd>EasyGoPiGo3</kbd> class. To do this, we need to import the library and instantiate <kbd>GoPiGo3</kbd>:</li>
</ol>
<pre style="padding-left: 60px">import easygopigo3 as easy<br/>my_gpg3 = easy.EasyGoPiGo3()</pre>
<ol start="2">
<li>Then we initiate the servo:</li>
</ol>
<pre style="padding-left: 60px">servo = my_gpg3.init_servo()</pre>
<ol start="3">
<li>We check that we are able to fully rotate the servo. You should have unmounted the sensor to prevent collisions with the robot's chassis:</li>
</ol>
<pre style="padding-left: 60px">servo.rotate_servo(0)   # This is 0º position<br/>servo.rotate_servo(180) <span># This is 180º position</span></pre>
<ol start="4">
<li>Then, move the servo to the middle of the interval, 90º, and attach the sensor so that it faces forward:</li>
</ol>
<pre style="padding-left: 60px"><span>servo.rotate_servo(90)</span></pre>
<ol start="5">
<li>Adjust the angle so that the sensor faces exactly forward. In our case, this angle is 95°. You should find out what yours is:</li>
</ol>
<pre style="padding-left: 60px"><span>servo.rotate_servo(95)</span></pre>
<ol start="6">
<li>Once we have checked the reference position, let's set up the actual limits. To do that, find the angles that preclude any interference with the sensor by the robot chassis. In our case, these angles are 30º and 160º. Again, y<span>ou should find what yours are:</span></li>
</ol>
<pre style="padding-left: 60px">servo.rotate_servo(30)<br/>servo.rotate_servo(160)</pre>
<p>That's all for the setup of the servo package with sensor distance.</p>
<p>For advanced users, there is another API library, <strong>gopigo3</strong>, that provides low-level access to the hardware in order for you to take full control of it. Although <span>covering such low-level programming</span> is not in the scope of the book, you are provided with a Python script, <kbd>Servo.py</kbd>, that briefly illustrates the usage of one of its methods. This script sets the rotation in terms of <em>counts</em> instead of <em>rotation angle</em>. We perform a loop when the counts go from 1000 to 2001.</p>
<p>This way, you have access to the full resolution of the servomotor, and you should have an idea of the size of the rotation steps it can provide.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Line follower</h1>
                </header>
            
            <article>
                
<p><span>As mentioned in the first chapter, the line follower is composed of six pairs of emitter-receivers to sense six aligned points on the floor in order to determine how decentered the robot is with respect to the black line it will be following.</span></p>
<p>The line follower is also part of the GoPiGo3 API library. Its methods are <span>detailed at</span> <a href="https://di-sensors.readthedocs.io/en/master/api-basic.html#easylinefollower">https://di-sensors.readthedocs.io/en/master/api-basic.html#easylinefollower</a>. The unit test we are going to perform consists of validating that the sensor can tell which side of a black line the robot is.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Line follower unit test</h1>
                </header>
            
            <article>
                
<p>The Jupyter notebook for the test is <kbd>./CH2-uniTests/di-lineFollower/lineFollower_libraries.ipynb</kbd>. This notebook also shows you both the easy library, <kbd>di_sensors.easy_line_follower</kbd>, and the advanced version, <kbd>di_sensors.line_follower</kbd>, <span>in action.</span></p>
<p>When the sensor reports <em>center</em>, this is because the robot is well centered on the black line, as shown in the next image. This means that the two external emitter-receiver <span>pairs </span>report <em>white</em>, while the pairs between them report <em>black</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1358 image-border" src="assets/c6db1ce0-ec37-449c-ad10-38d40b8b1ac5.png" style="width:32.58em;height:43.42em;"/></p>
<p><span>When the sensor reports</span> <em>left</em><span>, it means that the line is slightly to the left of the robot, as shown in the following photo. This means that the left-most pair reports <em>black</em>, the central ones <em>black</em>, and the rest <em>white</em>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1359 image-border" src="assets/22e7c9e2-97d0-4b17-acf4-488e0250178f.png" style="width:32.75em;height:43.75em;"/></p>
<p><span>If the robot ends up completely off the line, all the pairs report <em>white</em> and the line follower throws <em>white</em> overall. The opposite is also true: if all the pairs report <em>black</em>, it may be because the black line is too wide or the robot has been placed on a dark surface.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inertial Measurement Unit (IMU)</h1>
                </header>
            
            <article>
                
<p>With the supplied IMU, we have the following sensors:</p>
<ul>
<li>Magnetometer, three axes</li>
<li>
<div>
<div><span>Gyroscope</span><span>, three axes</span></div>
</div>
</li>
<li>
<div>
<div><span>Accelerometer</span><span>, three axes</span></div>
</div>
</li>
</ul>
<p>As explained in the previous chapter, with these three sensors – once their calibration setup is complete – it is possible to obtain the absolute orientation of the robot in the 3D space, quantified in terms of <span>Euler angles. Additionally, we also have the t</span><span>emperature because the DI IMU ships with a temperature sensor.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IMU unit test</h1>
                </header>
            
            <article>
                
<p>The Jupyter notebook for the test is <kbd>./Chapter2_Unit_Tests/DI-IMU/IMU_reading.ipynb</kbd>. The corresponding DI sensor API library is documented at <a href="https://di-sensors.readthedocs.io/en/master/examples/imu.html">https://di-sensors.readthedocs.io/en/master/examples/imu.html</a>.</p>
<p>When running the notebook, you can check that the reported Euler angles are OK.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Raspberry Pi</h1>
                </header>
            
            <article>
                
<p>Pi is an essential perception device for any robot. Take into account that about 80% of the perception data that the human brain processes comes from vision. In this section, we are only going to test that Pi is able to take photos to check that it works properly. In <em><a href="https://cdp.packtpub.com/hands_on_ros_for_robotics_programming/wp-admin/post.php?post=33&amp;action=edit">Chapter 10</a>, Applying Machine Learning in Robotics</em>, we will use object recognition algorithms on images captured <span>by the camera</span>. Hence, <span>the robot will exhibit </span><span>smarter behavior and will be able to recognize colors, shapes, faces, and so on.</span></p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pi unit test</h1>
                </header>
            
            <article>
                
<p><span>The Jupyter notebook for the test is <kbd>./Chapter2_Unit_Tests/PiCamera/Taking_Photos.ipynb</kbd></span><span>. This simple example takes a photo and creates a histogram, that is, a chart showing how many colors and the amount of each color that is present in the image.</span></p>
<p>So, let's take an image with few colors to make it easier to understand the information from the histogram. The following photo, taken with the GoPiGo3 , has the characteristics we need:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/968ed72c-ad85-41e9-a1f1-d20db6c041f6.png" style="width:28.08em;height:20.00em;"/></p>
<p>This is accomplished with the following code <span>snippet:</span></p>
<ol>
<li>First, we take the photo. Then we convert it to a JPG image format and save it, and, finally, we show the result on the screen:</li>
</ol>
<pre style="padding-left: 60px">with picamera.PiCamera() as camera:<br/> camera.resolution = (640, 480)<br/> camera.capture(output, format = 'rgb', use_video_port = True)<br/><br/>img = Image.fromarray(output)<br/>img.save("../photo.jpg")<br/><br/>plt.imshow(output)</pre>
<ol start="2">
<li>Finally, we draw the histogram with this simple command:</li>
</ol>
<pre style="padding-left: 60px">img = Image.open("../photo.jpg")<br/>histogram = img.histogram()<br/>plt.plot(histogram)</pre>
<p style="padding-left: 60px">And this is the result:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1360 image-border" src="assets/8c1d340e-d957-489c-8842-a74eae31dbb3.png" style="width:33.17em;height:20.75em;"/></p>
<p>You may see that colors are concentrated into three points. The scale of the <em>x</em> axis goes from 0 (black) to 768 (white). This interval is explained by taking into account that 24-bit RGB pixels have values that go up to 768. Let's see what each vertical line means:</p>
<ul>
<li>The line at <em>x</em> = 0 represents the zones that are black.</li>
<li>The line at <em>x</em> = 525 represents the more shiny area, which is the light bulb.</li>
<li>Finally, it is easy to infer that <em>x</em> = 250 corresponds to the lighter areas around the monitor, which appear to have a gray tone.</li>
</ul>
<p>With this last test, we have validated that our robot has all of its sensors and drives working properly and we are ready to proceed to the next step, building functional behaviors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GoPiGo3 projects</h1>
                </header>
            
            <article>
                
<p>The official GoPiGo3 software hosted on Github at <a href="https://github.com/DexterInd/GoPiGo3">https://github.com/DexterInd/GoPiGo3</a> provides several interesting projects. At this point, we recommend you clone the repository and upload some of these projects to the robot running DexterOS. The projects are located in this folder of the repository: <a href="https://github.com/DexterInd/GoPiGo3/tree/master/Projects">https://github.com/DexterInd/GoPiGo3/tree/master/Projects</a>.</p>
<p>You can try, for example, the <em>Basic Robot Control </em><span>project</span>, located at <a href="https://github.com/DexterInd/GoPiGo3/tree/master/Projects/BasicRobotControl">https://github.com/DexterInd/GoPiGo3/tree/master/Projects/BasicRobotControl</a>. You have the means to get full control of the drives, LEDs, and blinkers using the keys of your wireless keyboard that's connected to the robot:</p>
<pre>[key w ] : Move the GoPiGo3 forward<br/>[key s ] : Move the GoPiGo3 backward<br/>[key a ] : Turn the GoPiGo3 to the left<br/>[key d ] : Turn the GoPiGo3 to the right<br/>[key &lt;SPACE&gt; ] : Stop the GoPiGo3 from moving<br/>[key &lt;F1&gt; ] : Drive forward for 10 centimeters<br/>[key &lt;F2&gt; ] : Drive forward for 10 inches<br/>[key &lt;F3&gt; ] : Drive forward for 360 degrees (aka 1 wheel rotation)<br/>[key 1 ] : Turn ON/OFF left blinker of the GoPiGo3<br/>[key 2 ] : Turn ON/OFF right blinker of the GoPiGo3<br/>[key 3 ] : Turn ON/OFF both blinkers of the GoPiGo3<br/>[key 8 ] : Turn ON/OFF left eye of the GoPiGo3<br/>[key 9 ] : Turn ON/OFF right eye of the GoPiGo3<br/>[key 0 ] : Turn ON/OFF both eyes of the GoPiGo3<br/>[key &lt;INSERT&gt;] : Change the eyes' color on the go<br/>[key &lt;ESC&gt; ] : Exit</pre>
<p>Up to this point, you may argue that the method we have used to put new files in the robot is tedious<span>. We have used DexterOS so that you be able to start quickly, without having to deal with Linux issues.</span></p>
<p><span>From the next chapter, we will use Ubuntu 16.04 on your laptop and a full Linux desktop, Ubuntu 18.04, inside GoPiGo3 . This will allow the robot to connect to the internet, and this will let you clone repositories directly into the robot.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span>In this chapter, we have familiarized ourselves with the GoPiGo3 Python environment by running simple programs that allow us to test robot sensors and actuators. We have checked them one by one in what is formally known as </span><em>unit testing</em><span>. This has served two goals: getting started with Python programming and functionally validating your robot hardware.</span></p>
<p><span>Next, we will leave the robot for one chapter, and we will discuss the core software concepts of ROS that we will later use to program GoPiGo3.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>   If you have this sequence of Python commands, what will GoPiGo3 do?</li>
</ol>
<pre style="padding-left: 60px"><strong>my_gopigo.drive_cm(10)</strong><br/><strong>my_gopigo.turn_degrees(90)</strong></pre>
<p class="mce-root" style="padding-left: 60px">A) It will drive 10 cm forward and then turn 90º to the right <br/>
<span>B) It will drive 10 cm forward and then turn 90º to the left<br/></span><span><strong>C</strong>) It will turn 90º</span></p>
<ol start="02">
<li>What is the battery level required for GoPiGo3 to work properly?</li>
</ol>
<p class="mce-root" style="padding-left: 60px"><strong>A</strong>) Slightly above 9V is enough.<br/>
<span>B) 5V, the same that the Raspberry Pi needs.<br/></span><span>C) There is no minimum. If the voltage is low, the robot will drive slowly.</span></p>
<ol start="3">
<li>Which set of commands will make GoPiGo3 draw a right angle arc 60 cm in diameter?</li>
</ol>
<p class="mce-root" style="padding-left: 60px">A) <kbd>gpg.orbit(90, 60)<br/></kbd><span><strong>B</strong>) </span><kbd>gpg.orbit(90, 30)<br/></kbd><span>C) </span><kbd>gpg.orbit(180, 30)</kbd></p>
<ol start="4">
<li>What combination of the six sensor signals of the line follower does not correspond to GoPiGo3 being to the right of the black line? (w: white, b: black)</li>
</ol>
<p class="mce-root" style="padding-left: 60px"><strong>A</strong>) b-b-b-b-w<br/>
<span>B) w-b-b-b-w<br/></span><span>C) b-b-b-w-w</span></p>
<ol start="5">
<li>If you have a histogram of an image that consists of two vertical lines of equal height at <em>x</em> = 0 and <em>x</em> = 768, given that the color range of <em>x</em> is from 0 to 768, what colors are present in the image?</li>
</ol>
<p class="mce-root" style="padding-left: 60px">A) Gray, because it is the result of mixing black and white in equal proportions.<br/>
<span><strong>B</strong>) Half of the image is black and the other half is white.<br/></span><span>C) It is not possible to get a histogram like that.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>To delve deeper into the technical aspects of GoPiGo3, you have very detailed information in the official guides listed here:</p>
<ul>
<li>Dexter Industries GoPiGo3 Documentation: <a href="https://gopigo3.readthedocs.io">https://gopigo3.readthedocs.io</a></li>
<li>Dexter Industries DI-Sensors Documentation: <a href="https://di-sensors.readthedocs.io">https://di-sensors.readthedocs.io</a></li>
<li>Pi camera documentation: <a href="https://picamera.readthedocs.io/">https://picamera.readthedocs.io/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>