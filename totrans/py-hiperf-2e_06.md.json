["```py\n    import time\n\n    def network_request(number):\n        time.sleep(1.0)\n        return {\"success\": True, \"result\": number ** 2}\n\n```", "```py\n    def fetch_square(number):\n        response = network_request(number)\n        if response[\"success\"]:\n            print(\"Result is: {}\".format(response[\"result\"]))\n\n    fetch_square(2)\n    # Output:\n    # Result is: 4\n\n```", "```py\n    fetch_square(2)\n    fetch_square(3)\n    fetch_square(4)\n    # Output:\n    # Result is: 4\n    # Result is: 9\n    # Result is: 16\n\n```", "```py\n    def wait_and_print(msg):\n        time.sleep(1.0)\n        print(msg)\n\n```", "```py\n    import threading\n\n    def wait_and_print_async(msg):\n        def callback():\n            print(msg)\n\n        timer = threading.Timer(1.0, callback)\n        timer.start()\n\n```", "```py\n    # Syncronous\n    wait_and_print(\"First call\")\n    wait_and_print(\"Second call\")\n    print(\"After call\")\n    # Output:\n    # <wait...>\n    # First call  \n    # <wait...>\n    # Second call\n    # After call\n    # Async\n    wait_and_print_async(\"First call async\")\n    wait_and_print_async(\"Second call async\")\n    print(\"After submission\")\n    # Output:\n    # After submission \n    # <wait...>\n    # First call\n    # Second call\n\n```", "```py\n    def network_request_async(number, on_done):\n\n        def timer_done():\n            on_done({\"success\": True, \n                     \"result\": number ** 2})\n\n        timer = threading.Timer(1.0, timer_done)\n        timer.start()\n\n```", "```py\n    def on_done(result):\n        print(result)\n\n    network_request_async(2, on_done)\n\n```", "```py\n    network_request_async(2, on_done)\n    network_request_async(3, on_done)\n    network_request_async(4, on_done)\n    print(\"After submission\")\n\n```", "```py\n    def fetch_square(number):\n        def on_done(response):\n            if response[\"success\"]:\n                print(\"Result is: {}\".format(response[\"result\"]))\n\n        network_request_async(number, on_done)\n\n```", "```py\n    fut = Future()\n    # Result:\n    # <Future at 0x7f03e41599e8 state=pending>\n\n```", "```py\n    fut.set_result(\"Hello\")\n    # Result:\n    # <Future at 0x7f03e41599e8 state=finished returned str>\n\n    fut.result()\n    # Result:\n    # \"Hello\"\n\n```", "```py\n    fut = Future()\n    fut.add_done_callback(lambda future: print(future.result(), flush=True))\n    fut.set_result(\"Hello\")\n    # Output:\n    # Hello\n\n```", "```py\n    from concurrent.futures import Future\n\n    def network_request_async(number):\n        future = Future()\n        result = {\"success\": True, \"result\": number ** 2}\n        timer = threading.Timer(1.0, lambda: future.set_result(result))\n        timer.start()\n        return future\n\n    fut = network_request_async(2)\n\n```", "```py\n    def fetch_square(number):\n        fut = network_request_async(number)\n\n        def on_done_future(future):\n            response = future.result()\n            if response[\"success\"]:\n                print(\"Result is: {}\".format(response[\"result\"]))\n\n        fut.add_done_callback(on_done_future)\n\n```", "```py\n    class Timer:\n\n        def __init__(self, timeout):\n            self.timeout = timeout\n            self.start = time.time()\n\n        def done(self):\n            return time.time() - self.start > self.timeout\n\n```", "```py\n    timer = Timer(1.0)\n\n    while True:\n        if timer.done():\n            print(\"Timer is done!\")\n            break\n\n```", "```py\n    class Timer:\n       # ... previous code \n       def on_timer_done(self, callback):\n            self.callback = callback\n\n```", "```py\n    timer = Timer(1.0)\n    timer.on_timer_done(lambda: print(\"Timer is done!\"))\n\n    while True:\n        if timer.done():\n            timer.callback()\n            break\n\n```", "```py\n    timers = []\n\n    timer1 = Timer(1.0)\n    timer1.on_timer_done(lambda: print(\"First timer is done!\"))\n\n    timer2 = Timer(2.0)\n    timer2.on_timer_done(lambda: print(\"Second timer is done!\"))\n\n    timers.append(timer1)\n    timers.append(timer2)\n\n    while True:\n        for timer in timers:\n            if timer.done():\n                timer.callback()\n                timers.remove(timer)\n        # If no more timers are left, we exit the loop \n        if len(timers) == 0:\n            break\n\n```", "```py\n    import asyncio\n\n    loop = asyncio.get_event_loop()\n\n    def callback():\n        print(\"Hello, asyncio\")\n        loop.stop()\n\n    loop.call_later(1.0, callback)\n    loop.run_forever()\n\n```", "```py\n    def range_generator(n):\n        i = 0\n        while i < n:\n            print(\"Generating value {}\".format(i))\n            yield i\n            i += 1\n\n```", "```py\n    generator = range_generator(3)\n    generator\n    # Result:\n    # <generator object range_generator at 0x7f03e418ba40>\n\n```", "```py\n    next(generator)\n    # Output:\n    # Generating value 0\n\n    next(generator)\n    # Output:\n    # Generating value 1\n\n```", "```py\n    def parrot():\n        while True:\n            message = yield\n            print(\"Parrot says: {}\".format(message))\n\n    generator = parrot()\n    generator.send(None)\n    generator.send(\"Hello\")\n    generator.send(\"World\")\n\n```", "```py\n    async def hello():\n        print(\"Hello, async!\")\n\n    coro = hello()\n    coro\n    # Output:\n    # <coroutine object hello at 0x7f314846bd58>\n\n```", "```py\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(coro)\n\n```", "```py\n    async def wait_and_print(msg):\n        await asyncio.sleep(1)\n        print(\"Message: \", msg)\n\n    loop.run_until_complete(wait_and_print(\"Hello\"))\n\n```", "```py\n    async def network_request(number):\n         await asyncio.sleep(1.0)\n         return {\"success\": True, \"result\": number ** 2}\n\n```", "```py\n    async def fetch_square(number):\n         response = await network_request(number)\n         if response[\"success\"]:\n             print(\"Result is: {}\".format(response[\"result\"]))\n\n```", "```py\n    loop.run_until_complete(fetch_square(2))\n    loop.run_until_complete(fetch_square(3))\n    loop.run_until_complete(fetch_square(4))\n\n```", "```py\n    asyncio.ensure_future(fetch_square(2))\n    asyncio.ensure_future(fetch_square(3))\n    asyncio.ensure_future(fetch_square(4))\n\n    loop.run_forever()\n    # Hit Ctrl-C to stop the loop\n\n```", "```py\n    from concurrent.futures import ThreadPoolExecutor\n    executor = ThreadPoolExecutor(max_workers=3)\n\n    def wait_and_return(msg):\n        time.sleep(1)\n        return msg\n\n    executor.submit(wait_and_return, \"Hello. executor\")\n    # Result:\n    # <Future at 0x7ff616ff6748 state=running>\n\n```", "```py\n    fut = loop.run_in_executor(executor, wait_and_return, \"Hello, asyncio \n    executor\")\n    # <Future pending ...more info...>\n\n```", "```py\n    loop.run_until_complete(fut)\n    # Result:\n    # 'Hello, executor'\n\n```", "```py\n    import requests\n\n    async def fetch_urls(urls):\n        responses = []\n        for url in urls:\n            responses.append(await loop.run_in_executor\n                                (executor, requests.get, url))\n        return responses\n\n    loop.run_until_complete(fetch_ruls(['http://www.google.com', \n                                        'http://www.example.com',\n                                        'http://www.facebook.com']))\n    # Result\n    # []\n\n```", "```py\n    def fetch_urls(urls):\n        return asyncio.gather(*[loop.run_in_executor\n                                 (executor, requests.get, url) \n                                 for url in urls])\n\n```", "```py\n    from rx import Observable\n    obs = Observable.from_iterable(range(4))\n\n```", "```py\n    obs.subscribe(print)\n    # Output:\n    # 0\n    # 1\n    # 2\n    # 3\n\n```", "```py\n    collection = list([1, 2, 3, 4, 5])\n    iterator = iter(collection)\n\n    print(\"Next\")\n    print(next(iterator))\n    print(next(iterator))\n\n    print(\"For loop\")\n    for i in iterator:\n         print(i)\n\n    # Output:\n    # Next\n    # 1\n    # 2\n    # For loop\n    # 3\n    # 4\n    # 5\n\n```", "```py\n    obs = Observable.from_iter(range(4))\n    obs.subscribe(on_next=lambda x: print(on_next=\"Next item: {}\"),\n                  on_completed=lambda: print(\"No more data\"))\n    # Output:\n    # Next element: 0\n    # Next element: 1\n    # Next element: 2\n    # Next element: 3\n    # No more data\n\n```", "```py\n    obs = Observable.from_iterable(range(100000))\n    obs2 = obs.take(4)\n\n    obs2.subscribe(print)\n    # Output:\n    # 0\n    # 1\n    # 2\n    # 3\n\n```", "```py\n    (Observable.from_iterable(range(4))\n               .map(lambda x: x**2)\n               .subscribe(print))\n    # Output:\n    # 0\n    # 1\n    # 4\n    # 9\n\n```", "```py\n    obs = (Observable.from_range(range(4))\n                     .group_by(lambda x: x % 2))\n\n```", "```py\n    obs.subscribe(print)\n    # <rx.linq.groupedobservable.GroupedObservable object at 0x7f0fba51f9e8>\n    # <rx.linq.groupedobservable.GroupedObservable object at 0x7f0fba51fa58>\n\n```", "```py\n    obs.subscribe(lambda x: print(\"group key: \", x.key))\n    # Output:\n    # group key:  0\n    # group key:  1\n    obs.take(1).subscribe(lambda x: x.subscribe(print))\n    # Output:\n    # 0\n    # 2\n\n```", "```py\n    obs.merge_all().subscribe(print)\n    # Output\n    # 0\n    # 1\n    # 2\n    # 3\n\n```", "```py\n    def make_replay(a):\n        result = a.replay(None)\n        result.connect()\n        return result\n\n    obs.map(make_replay).concat_all().subscribe(print)\n    # Output\n    # 0\n    # 2\n    # 1\n    # 3\n\n```", "```py\n    obs = Observable.interval(1000)\n    obs.take(4).subscribe(print)\n    # Output:\n    # 0\n    # 1\n    # 2\n    # 3\n\n```", "```py\n    import time\n\n    start = time.time()\n    obs = Observable.interval(1000).map(lambda a: \n                                           (a, time.time() - start))\n\n    # Let's wait 2 seconds before starting the subscription\n    time.sleep(2)\n    obs.take(4).subscribe(print)\n    # Output:\n    # (0, 3.003735303878784)\n    # (1, 4.004871129989624)\n    # (2, 5.005947589874268)\n    # (3, 6.00749135017395)\n\n```", "```py\n    start = time.time()\n    obs = Observable.interval(1000).map(lambda a: \n                                           (a, time.time() - start))\n\n    # Let's wait 2 seconds before starting the subscription\n    time.sleep(2)\n    obs.take(4).subscribe(lambda x: print(\"First subscriber: \n                                             {}\".format(x)))\n    time.sleep(0.5)\n    obs.take(4).subscribe(lambda x: print(\"Second subscriber: \n                                             {}\".format(x)))\n    # Output:\n    # First subscriber: (0, 3.0036110877990723)\n    # Second subscriber: (0, 3.5052847862243652)\n    # First subscriber: (1, 4.004414081573486)\n    # Second subscriber: (1, 4.506155252456665)\n    # First subscriber: (2, 5.005316972732544)\n    # Second subscriber: (2, 5.506817102432251)\n    # First subscriber: (3, 6.0062034130096436)\n    # Second subscriber: (3, 6.508296489715576)\n\n```", "```py\n    start = time.time()\n    obs = Observable.interval(1000).map(lambda a: (a, time.time() - \n    start)).publish()\n    obs.take(4).subscribe(lambda x: print(\"First subscriber: \n                                             {}\".format(x)))\n obs.connect() # Data production starts here \n    time.sleep(2)\n    obs.take(4).subscribe(lambda x: print(\"Second subscriber: \n                                             {}\".format(x)))\n    # Output:\n    # First subscriber: (0, 1.0016899108886719)\n    # First subscriber: (1, 2.0027990341186523)\n    # First subscriber: (2, 3.003532648086548)\n    # Second subscriber: (2, 3.003532648086548)\n    # First subscriber: (3, 4.004265308380127)\n    # Second subscriber: (3, 4.004265308380127)\n    # Second subscriber: (4, 5.005320310592651)\n    # Second subscriber: (5, 6.005795240402222)\n\n```", "```py\n    import time\n\n    start = time.time()\n    obs = Observable.interval(1000).map(lambda a: (a, time.time() - \n    start)).replay(None)\n    obs.take(4).subscribe(lambda x: print(\"First subscriber: \n                                             {}\".format(x)))\n obs.connect()\n\n    time.sleep(2)\n    obs.take(4).subscribe(lambda x: print(\"Second subscriber: \n                                             {}\".format(x)))\n\n    First subscriber: (0, 1.0008857250213623)\n    First subscriber: (1, 2.0019824504852295)\n Second subscriber: (0, 1.0008857250213623)\n    Second subscriber: (1, 2.0019824504852295)    First subscriber: (2, 3.0030810832977295)\n    Second subscriber: (2, 3.0030810832977295)\n    First subscriber: (3, 4.004604816436768)\n    Second subscriber: (3, 4.004604816436768)\n\n```", "```py\n    s = Subject()\n    s.subscribe(lambda a: print(\"Subject emitted value: {}\".format(x))\n    s.on_next(1)\n    # Subject emitted value: 1\n    s.on_next(2)\n    # Subject emitted value: 2\n\n```", "```py\n    import psutil\n    psutil.cpu_percent()\n    # Result: 9.7\n\n```", "```py\n    cpu_data = (Observable\n                .interval(100) # Each 100 milliseconds\n                .map(lambda x: psutil.cpu_percent())\n                .publish())\n    cpu_data.connect() # Start producing data\n\n```", "```py\n    cpu_data.take(4).subscribe(print)\n    # Output:\n    # 12.5\n    # 5.6\n    # 4.5\n    # 9.6\n\n```", "```py\n    import numpy as np\n    from matplotlib import pyplot as plt\n\n    def monitor_cpu(npoints):\n        lines, = plt.plot([], [])\n        plt.xlim(0, npoints) \n        plt.ylim(0, 100) # 0 to 100 percent\n\n        cpu_data_window = cpu_data.buffer_with_count(npoints, 1)\n\n        def update_plot(cpu_readings):\n            lines.set_xdata(np.arange(npoints))\n            lines.set_ydata(np.array(cpu_readings))\n            plt.draw()\n\n        cpu_data_window.subscribe(update_plot)\n\n        plt.show()\n\n```", "```py\n    alertpoints = 4    \n    high_cpu = (cpu_data\n                .buffer_with_count(alertpoints, 1)\n                .map(lambda readings: all(r > 20 for r in readings)))\n\n```", "```py\n    label = plt.text(1, 1, \"normal\")\n    def update_warning(is_high):\n        if is_high:\n            label.set_text(\"high\")\n        else:\n            label.set_text(\"normal\")\n    high_cpu.subscribe(update_warning)\n\n```"]