- en: Chapter 8. Testing and Deploying an API with Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will configure, write, and execute unit tests and learn
    a few things related to deployment. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a database for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a first round of unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run unit tests and check testing coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve testing coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand strategies for deployments and scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use `nose2` to make it easier to discover and run unit tests. We will
    measure test coverage, and therefore, we will install the necessary package to
    allow us to run coverage with `nose2`. First, we will install the `nose2` and
    `cov-core` packages in our virtual environment. The `cov-core` package will allow
    us to measure test coverage with `nose2`. Then, we will create a new PostgreSQL
    database that we will use for testing. Finally, we will create the configuration
    file for the testing environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you quit the Flask''s development server. Remember that you just
    need to press ***Ctrl*** + ***C*** in the terminal or the Command Prompt window
    in which it is running. We just need to run the following command to install the
    `nose2` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The last lines of the output will indicate that the `django-nose` package has
    been successfully installed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need to run the following command to install the `cov-core` package
    that will also install the `coverage` dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate that the `django-nose` package
    has been successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will create the PostgreSQL database that we will use as a repository
    for our testing environment. You will have to download and install a PostgreSQL
    database, in case you aren't already running it on the testing environment on
    your computer or in a testing server.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to make sure that the PostgreSQL bin folder is included in the `PATH`
    environmental variable. You should be able to execute the `psql` command-line
    utility from your current Terminal or Command Prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the PostgreSQL command-line tools to create a new database named
    `test_messages`. In case you already have a PostgreSQL database with this name,
    make sure that you use another name in all the commands and configurations. You
    can perform the same task with any PostgreSQL GUI tool. In case you are developing
    on Linux, it is necessary to run the commands as the `postgres` user. Run the
    following command in macOS or Windows to create a new database named `test_messages`.
    Note that the command won''t generate any output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In Linux, run the following command to use the `postgres` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will use the `psql` command-line tool to run some SQL statements to
    grant privileges on the database to a user. In case you are using a different
    server than the development server, you will have to create the user before granting
    privileges. In macOS or Windows, run the following command to launch psql:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In Linux, run the following command to use the postgres user
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the following SQL statements and finally enter \q to exit the psql
    command-line tool. Replace user_name with your desired user name to use in the
    new database and password with your chosen password. We will use the user name
    and password in the Flask testing configuration. You don''t need to run the steps
    in case you are already working with a specific user in PostgreSQL and you have
    already granted privileges to the database for the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `test_config.py` file within the `api` folder. The following lines
    show the code that declares variables that determine the configuration for Flask
    and SQLAlchemy for our testing environment. The `SQL_ALCHEMY_DATABASE_URI` variable
    generates a SQLAlchemy URI for the PostgreSQL database that we will use to run
    all the migrations before starting tests and we will drop all the elements after
    executing all the tests. Make sure you specify the desired test database name
    in the value for `DB_NAME` and that you configure the user, password, host, and
    port based on your PostgreSQL configuration for the testing environment. In case
    you followed the previous steps, use the settings specified in these steps. The
    code file for the sample is included in the `restful_python_chapter_08_01` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we did with the similar test file we created for our development environment,
    we will specify the previously created module as an argument to a function that
    will create a Flask app that we will use for testing. This way, we have one module
    that specifies all the values for the different configuration variables for our
    testing environment and another module that creates a *Flask* app for our testing
    environment. It is also possible to create a class hierarchy with one class for
    each environment we want to use. However, in our sample case, it is easier to
    create a new configuration file for our testing environment.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a first round of unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will write a first round of unit tests. Specifically, we will write
    unit tests related to the user and message category resources: `UserResource`,
    `UserListResource`, `CategoryResource`, and `CategoryListResource`. Create a new
    `tests` sub-folder within the `api` folder. Then, create a new `test_views.py`
    file within the new `api/tests` sub-folder. Add the following lines, that declare
    many `import` statements and the first methods for the `InitialTests` class. The
    code file for the sample is included in the `restful_python_chapter_08_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `InitialTests` class is a subclass of `unittest.TestCase`. The class overrides
    the `setUp` method that will be executed before each test method runs. The method
    calls the `create_app` function, declared in the `app` module, with `'test_config'`
    as an argument. The function will set up a Flask app with this module as the configuration
    file, and therefore, the app will use the previously created configuration file
    that specifies the desired values for our testing database and environment. Then,
    the code sets the testing attribute for the recently created `app` to `True` in
    order for the exception to propagate to the test client.
  prefs: []
  type: TYPE_NORMAL
- en: The next line calls the `self.app.test_client` method to create a test client
    for the previously created Flask application and saves the test client in the
    `test_client` attribute. We will use the test client in our test methods to easily
    compose and send requests to our API. Then, the code saves and pushes the application
    context and creates two attributes with the user name and password we will use
    for our tests. Finally, the method calls the `db.create_all` method to create
    all the necessary tables in our test database configured in the `test_config.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The `InitialTests` class overrides the `tearDown` method that will be executed
    after each test method runs. The code removes the SQLAlchemy session, drops all
    the tables that we created in the test database before starting the execution
    of the tests, and pops the application context. This way, after each test finishes
    its execution, the test database will be empty again.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_accept_content_type_headers` method builds and returns a dictionary
    (`dict`) with the values of the `Accept` and `Content-Type` header keys set to
    `'application/json'`. We will call this method in our tests whenever we have to
    build a header to compose our requests without authentication.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_authentication_headers` method calls the previously explained `get_accept_content_type_headers`
    method to generate the header key-value pairs without authentication. Then, the
    code adds the necessary value to the `Authorization` key with the appropriate
    encoding to provide the user name and password received in the `username` and
    `password` arguments. The last line returns the generated dictionary that includes
    authentication information. We will call this method in our tests whenever we
    have to build a header to compose our requests with authentication. We will use
    the user name and password we stored in attributes the `setUp` method.
  prefs: []
  type: TYPE_NORMAL
- en: Open the previously created `test_views.py` file within the new `api/tests`
    sub-folder. Add the following lines that declare many methods for the `InitialTests`
    class. The code file for the sample is included in the `restful_python_chapter_08_01`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `test_request_without_authentication` method tests whether we have been
    rejected access to a resource that requires authentication when we don't provide
    an appropriate authentication header with the request. The method uses the test
    client to compose and send an HTTP `GET` request to the URL generated for the
    `'api.messagelistresource'` resource to retrieve the list of messages. We need
    an authenticated request to retrieve the list of messages. However, the code calls
    the `get_authentication_headers` method to set the value for the headers argument
    in the call to `self.test_client.get`, and therefore, the code generates a request
    without authentication. Finally, the method uses `assertTrue` to check that the
    `status_code` for the response is HTTP 401 Unauthorized (`status.HTTP_401_UNAUTHORIZED`).
  prefs: []
  type: TYPE_NORMAL
- en: The `create_user` method uses the test client to compose and send an HTTP `POST`
    request to the URL generated for the `'api.userlistresource'` resource to create
    a new user with the name and password received as arguments. We don't need an
    authenticated request to create a new user, and therefore, the code calls the
    previously explained `get_accept_content_type_headers` method to set the value
    for the headers argument in the call to `self.test_client.post`. Finally, the
    code returns the response from the `POST` request. Whenever we have to create
    an authenticated request, we will call the `create_user` method to create a new
    user.
  prefs: []
  type: TYPE_NORMAL
- en: The `create_category` method uses the test client to compose and send an HTTP
    `POST` request to the URL generated for the `'api.categorylistresource'` resource
    to create a new `Category` with the name received as an argument. We need an authenticated
    request to create a new `Category`, and therefore, the code calls the previously
    explained `get_authentication_headers` method to set the value for the headers
    argument in the call to `self.test_client.post`. The user name and password are
    set to `self.test_user_name` and `self.test_user_password`. Finally, the code
    returns the response from the `POST` request. Whenever we have to create a category,
    we will call the `create_category` method after the appropriate user that authenticates
    the request has been created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `test_create_and_retrieve_category` method tests whether we can create
    a new `Category` and then retrieve it. The method calls the previously explained
    `create_user` method to create a new user and then use it to authenticate the
    HTTP `POST` request generated in the `create_game_category` method. Then, the
    code composes and sends an HTTP `GET` method to retrieve the recently created
    Category with the URL received in the response of the previous HTTP `POST` request.
    The method uses `assertEqual` to check for the following expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: The `status_code` for the HTTP `POST` response is HTTP 201 Created (`status.HTTP_201_CREATED`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total number of `Category` objects retrieved from the database is `1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `status_code` for the HTTP `GET` response is HTTP 200 OK (`status.HTTP_200_OK`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value for the `name` key in the HTTP `GET` response is equal to the name
    specified for the new category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the previously created `test_views.py` file within the new `api/tests`
    sub-folder. Add the following lines that declare many methods for the `InitialTests`
    class. The code file for the sample is included in the `restful_python_chapter_08_01`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The class declares the following methods whose name start with the `test_`
    prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test_create_duplicated_ category`: Tests whether the unique constraints don''t
    make it possible for us to create two categories with the same name or not. The
    second time we compose and send an HTTP `POST` request with a duplicate category
    name, we must receive an HTTP 400 Bad Request status code (`status.HTTP_400_BAD_REQUEST`)
    and the total number of `Category` objects retrieved from the database must be
    `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_retrieve_categories_list`: Tests whether we can retrieve the categories
    list or not. First, the method creates two categories and then it makes sure that
    the retrieved list includes the two created categories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_update_game_category`: Tests whether we can update a single field for
    a category, specifically, its name field. The code makes sure that the name has
    been updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that each test that requires a specific condition in the database must
    execute all the necessary code for the database to be in this specific condition.
    For example, in order to update an existing category, first we must create a new
    category and then we can update it. Each test method will be executed without
    data from the previously executed test methods in the database, that is, each
    test will run with a database cleaned of data from previous tests.
  prefs: []
  type: TYPE_NORMAL
- en: Running unit tests with nose2 and checking testing coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, run the following command to create all the necessary tables in our test
    database and use the `nose2` test running to execute all the tests we created.
    The test runner will execute all the methods for our `InitialTests` class that
    start with the `test_` prefix and will display the results.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tests won't make changes to the database we have been using when working
    on the API. Remember that we configured the `test_messages` database as our test
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the `api.py` file we created in the previous chapter from the `api`
    folder because we don''t want the tests coverage to take into account this file.
    Go to the `api` folder and run the following command within the same virtual environment
    that we have been using. We will use the `-v` option to instruct `nose2` to print
    test case names and statuses. The `--with-coverage` option turns on test coverage
    reporting generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the sample output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By default, `nose2` looks for modules whose names start with the `test` prefix.
    In this case, the only module that matches the criteria is the `test_views` module.
    In the modules that match the criteria, `nose2` loads tests from all the subclasses
    of `unittest.TestCase` and the functions whose names start with the `test` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: The output provides details indicating that the test runner discovered and executed
    five tests and all of them passed. The output displays the method name and the
    class name for each method in the `InitialTests` class that started with the `test_`
    prefix and represented a test to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test code coverage measurement report provided by the `coverage` package
    uses the code analysis tools and the tracing hooks included in the Python standard
    library to determine which lines of code are executable and have been executed.
    The report provides a table with the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Name`: The Python module name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stmts`: The count of executable statements for the Python module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Miss`: The number of executable statements missed, that is, the ones that
    weren''t executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cover`: The coverage of executable statements expressed as a percentage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We definitely have a very low coverage for `views.py` and `helpers.py` based
    on the measurements shown in the report. In fact, we just wrote a few tests related
    to categories and users, and therefore, it makes sense that the coverage is really
    low for the views. We didn't create tests related to messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the `coverage` command with the `-m` command-line option to display
    the line numbers of the missing statements in a new `Missing` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will use the information from the last execution and will display
    the missing statements. The next lines show a sample output that corresponds to
    the previous execution of the unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following command to get annotated HTML listings detailing missed
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `index.html` HTML file generated in the `htmlcov` folder with your
    Web browser. The following picture shows an example report that coverage generated
    in HTML format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running unit tests with nose2 and checking testing coverage](img/image_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click or tap `views.py` and the Web browser will render a Web page that displays
    the statements that were run, the missing ones and the excluded, with different
    colors. We can click or tap on the **run**, **missing** and **excluded** buttons
    to show or hide the background color that represents the status for each line
    of code. By default, the missing lines of code will be displayed with a pink background.
    Thus, we must write unit tests that target these lines of code to improve our
    test coverage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running unit tests with nose2 and checking testing coverage](img/image_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Improving testing coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will write additional unit tests to improve the testing coverage. Specifically,
    we will write unit tests related to messages and users. Open the existing `api/tests/test_views.py`
    file and insert the following lines after the last line, within the `InitialTests`
    class. We need a new `import` statement and we will declare the new `PlayerTests`
    class. The code file for the sample is included in the `restful_python_chapter_08_02`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code adds many methods to the `InitialTests` class. The `create_message`
    method receives the desired `message`, `duration`, and `category` (category name)
    for the new message as arguments. The method builds the URL and the data dictionary
    to compose and send an HTTP `POST` method, create a new message, and return the
    response generated by this request. Many test methods will call the `create_message`
    method to create a message and then compose and send other HTTP requests to the
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class declares the following methods whose names start with the `test_`
    prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test_create_and_retrieve_message`: Tests whether we can create a new `Message`
    and then retrieve it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_create_duplicated_message`: Tests whether the unique constraints don''t
    make it possible for us to create two messages with the same message. The second
    time we compose and send an HTTP `POST` request with a duplicate message, we must
    receive an `HTTP 400 Bad Request` status code (`status.HTTP_400_BAD_REQUEST`)
    and the total number of `Message` objects retrieved from the database must be
    `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open the existing `api/tests/test_views.py` file and insert the following lines
    after the last line, within the `InitialTests` class. The code file for the sample
    is included in the `restful_python_chapter_08_02` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The previous code added a `test_retrieve_messages_list` method to the `InitialTests`
    class. This method tests whether we can retrieve the paginated messages list.
    First, the method creates two messages and then it makes sure that the retrieved
    list includes the two created messages in the first page. In addition, the method
    makes sure that the second page doesn't include any message and that the value
    for the previous page includes the URL for the first page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the existing `api/tests/test_views.py` file and insert the following lines
    after the last line, within the `InitialTests` class. The code file for the sample
    is included in the `restful_python_chapter_08_02` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The previous code added the following two methods to the `InitialTests` class-`test_update_message`-tests
    whether we can update more than one fields for a message, specifically, the values
    for the `printed_times` and `printed_once` fields. The code makes sure that both
    fields have been updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_create_and_retrieve_user`: Tests whether we can create a new `User` and
    then retrieve it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We just coded a few tests related to messages and one test related to users
    in order to improve test coverage and notice the impact on the test coverage report.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following command within the same virtual environment we have
    been using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The output provided details indicating that the test runner executed `10` tests
    and all of them passed. The test code coverage measurement report provided by
    the `coverage` package increased the `Cover` percentage of the `views.py` module
    from `47%` in the previous run to `68%`. In addition, the percentage of the `helpers.py`
    module increased from `22%` to `96%` because we wrote tests that used pagination.
    The new additional tests we wrote executed additional code in different modules,
    and therefore, there is an impact in the coverage report.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We just created a few unit tests to understand how we can code them. However,
    of course, it would be necessary to write more tests to provide an appropriate
    coverage of all the featured and execution scenarios included in the API.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding strategies for deployments and scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask is a lightweight microframework for the Web. However, as happens with
    Django, one of the biggest drawbacks related to Flask and Flask-RESTful is that
    each HTTP request is blocking. Thus, whenever the Flask server receives an HTTP
    request, it doesn't start working on any other HTTP requests in the incoming queue
    until the server sends the response for the first HTTP request it received.
  prefs: []
  type: TYPE_NORMAL
- en: We used Flask to develop a RESTful Web Service. They key advantage of these
    kind of Web Services is that they are stateless, that is, they shouldn't keep
    a client state on any server. Our API is a good example of a stateless RESTful
    Web Service with Flask and Flask RESTful. Thus, we can make the API run on as
    many servers as necessary to achieve our scalability goals. Obviously, we must
    take into account that we can easily transform the database server in our scalability
    bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nowadays, we have a huge number of cloud-based alternatives to deploy a RESTful
    Web Service that uses Flask and Flask-RESTful and make it extremely scalable.
  prefs: []
  type: TYPE_NORMAL
- en: We always have to make sure that we profile the API and the database before
    we deploy the first version of our API. It is very important to make sure that
    the generated queries run properly on the underlying database and that the most
    popular queries do not end up in sequential scans. It is usually necessary to
    add the appropriate indexes to the tables in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have been using basic HTTP authentication. We can improve it with a token-based
    authentication. We must make sure that the API runs under HTTPS in production
    environments. In addition, we must make sure that we change the following line
    in the `api/config.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We must always turn off debug mode in production, and therefore, we must replace
    the previous line with the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is convenient to use a different configuration file for production. However,
    another approach that is becoming extremely popular, especially for cloud-native
    applications, is to store configuration in the environment. If we want to deploy
    cloud-native RESTful Web Services and follow the guidelines established in the
    twelve-factor App, we should store config in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Each platform includes detailed instructions to deploy our application. All
    of them will require us to generate the `requirements.txt` file that lists the
    application dependencies together with their versions. This way, the platforms
    will be able to install all the necessary dependencies listed in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Run the following `pip freeze` to generate the `requirements.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the contents of a sample generated `requirements.txt`
    file. However, bear in mind that many packages increase their version number quickly
    and you might see different versions in your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, `nose2` looks for modules whose names start with the following
    prefix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`test`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`run`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`unittest`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, `nose2` loads tests from all the subclasses of the following class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`unittest.Test`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`unittest.TestCase`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`unittest.RunTest`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `setUp` method in a subclass of `unittest.TestCase`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is executed before each test method runs.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Is executed only once before all the tests start their execution.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Is executed only once after all the tests finish their execution.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `tearDown` method in a subclass of `unittest.TestCase`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is executed after each test method runs.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Is executed before each test method runs.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Is executed after a test method only when it fails.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we declare a `get_accept_content_type_headers` method within a subclass
    of `unittest.TestCase`, by default, `nose2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Will load this method as a test.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Will load this method as the `setUp` method for each test.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Won't load this method as a test.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we set up a testing environment. We installed nose2 to make
    it easy to discover and execute unit tests, and we created a new database to be
    used for testing. We wrote a first round of unit tests, measured test coverage,
    and then we wrote additional unit tests to improve test coverage. Finally, we
    understood many considerations for deployment and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built a complex API with Flask combined with Flask RESTful,
    and we tested it, we will move to another popular Python Web framework, Tornado,
    which is what we are going to discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
