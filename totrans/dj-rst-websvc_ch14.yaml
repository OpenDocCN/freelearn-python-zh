- en: Using Generalized Behavior from the APIView Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will improve our simple RESTful Web Service. We will make
    it possible for it to work with diverse content types without writing a huge amount
    of code. We will take advantage of advanced features and generalized behaviors
    included in the Django REST framework to enable multiple parsers and renderers.
    We will gain an understanding of:'
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of model serializers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding accepted and returned content types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making unsupported HTTP OPTIONS requests with command-line tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding decorators that work as wrappers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using decorators to enable different parsers and renderers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking advantage of content negotiation classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making supported HTTP OPTIONS requests with command-line tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with different content types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending HTTP requests with unsupported HTTP verbs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking advantage of model serializers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](dj-rst-websvc_ch11.html), *Installing the Required Software and
    Tools*, we created the toy model (the `Toy` class) and its serializer (the `ToySerializer`
    class). When we wrote the code for the `ToySerializer` class, we had to declare
    many attributes with the same names that we used in the `Toy` class. The `ToySerializer`
    class is a subclass of the `rest_framework.serializers.Serializer` superclass;
    it declares attributes that we manually mapped to the appropriate types, and overrides
    the `create` and `update` methods. However, we repeated a lot of code and information
    that was already included in the toy model, such as the types and the `max_length`
    values that specify the maximum length for each string field.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will take advantage of model serializers to simplify code and to avoid
    repeating information that is already included in the model. We will create a
    new version of the existing `ToySerializer` class that will inherit from the `rest_framework.serializers.ModelSerializer`
    superclass instead of inheriting from the `rest_framework.serializers.ModelSerializer`
    superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The `ModelSerializer` class automatically populates a set of default fields
    and default validators by retrieving metadata from the related model class that
    we must specify. In addition, the `ModelSerializer` class provides default implementations
    for the `create` and `update` methods. In this case, we will take advantage of
    these default implementations because they will be suitable to provide our necessary
    `create` and `update` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `restful01/toys` folder and open the `serializers.py` file. The code
    file for the sample is included in the `hillar_django_restful_04_01` folder, in
    the `restful01/toys/serializers.py` file. Replace the code in this file with the
    following code that declares the new version of the `ToySerializer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The new version of the `ToySerializer` class declares a `Meta` inner class
    that declares the following two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`model`: This attribute specifies the model related to the serializer, that
    is, the `Toy` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields`: This attribute specifies a tuple of `string` whose values indicate
    the field names that we want to include in the serialization from the related
    model (the `Toy` class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new version of the `ToySerializer` class doesn't need to override either
    the `create` or `update` methods because the generic behavior provided by the
    `ModelSerializer` class will be enough in this case. The `ModelSerializer` superclass
    provides implementations for both methods.
  prefs: []
  type: TYPE_NORMAL
- en: With the changes we have made, we removed a nice amount of code from the `ToySerializer`
    class. In the new version, we just had to specify the related model and the desired
    set of fields in a tuple. Now, the types and `max_length` values related to the
    toy fields are only included in the `Toy` class.
  prefs: []
  type: TYPE_NORMAL
- en: If you have previous experience with the Django Web framework, you will realize
    that the `Serializer` and `ModelSerializer` classes in the Django REST framework
    are similar to the `Form` and `ModelForm` classes in Django.
  prefs: []
  type: TYPE_NORMAL
- en: You can press *Ctrl* + *C* to quit Django's development server and execute the
    command that we learned in [Chapter 3](dj-rst-websvc_ch13.html), *Creating API
    Views*, to run the server to start it again. In this case, we just edited one
    file, and in case you didn't stop the development server, Django will detect the
    changes when we save the changes to the file and it will automatically restart
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show sample output that you will see after you save the
    changes in the edited Python file. The lines indicate that Django has restarted
    the development server and successfully performed a system check that identified
    no issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can use the command-line and GUI tools we used in [Chapter 3](dj-rst-websvc_ch13.html),
    *Creating API Views*, to test the new version of our RESTful Web Service that
    takes advantage of model serializers. The behavior will be the same as in the
    previous version. However, we definitely have less code to maintain and we have
    removed duplicated data.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding accepted and returned content types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, our RESTful Web Service has been working with JSON for the response
    body. The code we wrote in the `toys/views.py` file in [Chapter 3](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=61&action=edit#post_56), *Creating
    API Views*, declares a `JSONResponse` class and two function-based views. These
    functions return a `JSONResponse` when it is necessary to return JSON data and
    a `django.Http.Response.HttpResponse` instance when the response is just an HTTP
    status code. No matter the accepted content type specified in the HTTP request
    header, the view functions always provide the same content in the response body:
    JSON.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to retrieve all the toys with the `Accept` request
    header key set to `text/html`. Remember that the virtual environment we have created
    in [Chapter 3](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=61&action=edit#post_56), *Creating
    API Views*, must be activated in order to run the next `http` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/toys/`. These commands specify the `text/html` value for
    the `Accept` key in the request header. This way, the HTTP request indicates that
    it accepts a response of `text/html`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The header response for the request will include the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the following command to retrieve all the toys with different values
    with the `Accept` request header key set to `text/html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to retrieve all the toys with the `Accept` request
    header key set to `application/json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/toys/`. These commands specify the `application/json` value
    for the `Accept` key in the request header. This way, the HTTP request indicates
    that it accepts a response of `application/json`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The header response for the request will include the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first group of commands defined the `text/html` value for the `Accept` request
    header key. The second group of commands defined the `application/json` value
    for the `Accept` request header key. However, both produced the same results and
    the responses were always in the JSON format. The view functions don't take into
    account the value specified for the `Accept` request header key in the HTTP requests.
    No matter the value indicated for the `Accept` request header key, the response
    is always in the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: We want to provide support for other formats. However, we don't want to write
    a huge amount of code to do so. Thus, we will take advantage of additional features
    included in the Django REST framework that will make it easy for us to support
    additional formats for our RESTful Web Service.
  prefs: []
  type: TYPE_NORMAL
- en: Making unsupported HTTP OPTIONS requests with command-line tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we don't know which are the HTTP methods or verbs that a resource
    or resource collection supports in a RESTful Web Service. In order to provide
    a solution to this problem, we can compose and send an HTTP request with the `OPTIONS`
    HTTP verb and the URL for the resource or the resource collection.
  prefs: []
  type: TYPE_NORMAL
- en: If the RESTful Web Service implements the `OPTIONS` HTTP verb for a resource
    or resource collection, it will build a response with an `Allow` key in the response
    header. The value for this key will include a comma-separated list of HTTP verbs
    or methods that it supports. In addition, the response header will include additional
    information about other supported options, such as the content type it is capable
    of parsing from the request and the content type it is capable of rendering in
    the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to know which HTTP verbs the toys collection supports,
    we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the command will generate an error in the Django development server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `OPTIONS
    http://localhost:8000/toys/`. The request specifies `/toys/`, and therefore, it
    will match the `''^toys/$''` regular expression and run the `views.toy_list` function,
    that is, the `toy_list` function declared within the `toys/views.py` file. This
    function only runs code when the `request.method` is equal to either `''GET''`
    or `''POST''`. In this case, `request.method` is equal to `''OPTIONS''`, and therefore,
    the function won''t run any code. The function won''t return the expected `HttpResponse`
    instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The lack of the expected `HttpResponse` instance generates an internal server
    error in Django''s development server. The console output for the development
    server will display details about the internal server error and a traceback similar
    to the one shown in the next screenshot. The last lines indicate that there is
    a `ValueError` because the `toys_list` function didn''t return an `HttpResponse`
    instance and returned `None` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55ab16b6-55f0-468f-9018-5fb984162f02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following lines show the header for the output displayed as a result of
    the HTTP request. The response also includes a detailed HTML document with a huge
    amount of information about the error because the debug mode is activated for
    Django. We receive an HTTP `500 Internal Server Error` status code. Obviously,
    we don''t want all this information to be provided in a production-ready web service,
    in which we will deactivate the debug mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We don't want our web service to provide a response with an HTTP `500 Internal
    Server Error status` code when we receive a request with the `OPTIONS` verb to
    either a valid resource or resource collection. Obviously, we want to provide
    a more consistent web service and we want to provide an accurate response when
    we receive a request with the `OPTIONS` verbs, for either a toy resource or the
    toys collection.
  prefs: []
  type: TYPE_NORMAL
- en: If we compose and send an HTTP request with the `OPTIONS` verb for an existing
    toy resource, we will see the same error in the console output for the development
    server and a similar response with the HTTP `500 Internal Server Error status`
    code. The `views.toy_detail` function only runs code when the `request.method`
    is equal to `'GET'`, `'PUT',` or `'DELETE'`. Thus, as happened with the previous
    case, the `toys_detail` function won't return an `HttpResponse` instance and it
    will return `None` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands will produce the explained error when we try to see
    the options offered for the toy resource whose `id` or primary key is equal to
    `2`. Make sure you replace `2` with a primary key value of an existing toy in
    your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the details of the internal server error and
    a traceback displayed in the console output for the development server after we
    run the previous HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a26ced03-ebeb-4d84-ae13-0a5cdc08ec29.png)'
  prefs: []
  type: TYPE_IMG
- en: Understanding decorators that work as wrappers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will make a few changes to the code in the `toys/views.py` file to provide
    support for the `OPTIONS` verb in our RESTful Web Service. Specifically, we will
    take advantage of a decorator provided by the Django REST framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `@api_view` decorator that is declared in the `rest_framework.decorators`
    module. We will apply this decorator to our function-based views: `toys_list`
    and `toys_detail`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `@api_view` decorator allows us to specify which are the HTTP verbs that
    the function to which it is applied can process. If the request that has been
    routed to the view function has an HTTP verb that isn't included in the string
    list specified as the `http_method_names` argument for the `@api_view` decorator,
    the default behavior returns a response with an HTTP `405 Method Not Allowed`
    status code.
  prefs: []
  type: TYPE_NORMAL
- en: This way, we make sure that whenever the RESTful Web Service receives an HTTP
    verb that isn't considered within our function views, we won't generate an unexpected
    and undesired error in Django. The decorator generates the appropriate response
    for the unsupported HTTP verbs or methods. In addition, by reading the declaration
    of our function views, we can easily understand which HTTP verbs are handled by
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to understand what happens under the hood whenever we use
    the `@api_view` decorator. This decorator is a wrapper that converts a function-based
    view into a subclass of the `rest_framework.views.APIView` class. This class is
    the base class for all the views in the Django REST framework.
  prefs: []
  type: TYPE_NORMAL
- en: We will work with class-based views in the forthcoming examples and we will
    have the same benefits we have analyzed for the function-based views that use
    the decorator.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the decorator uses the string list we specify with the supported
    HTTP verbs to build the response for a request with the `OPTIONS` HTTP verb. The
    automatically generated response includes the supported method, and the parser
    and the render capabilities. In other words, the response includes the format
    that the function is capable of understanding and the format that the function
    can generate for the response.
  prefs: []
  type: TYPE_NORMAL
- en: As previously explained, the current version of our RESTful Web Service is only
    capable of rendering JSON as its output. The usage of the decorator makes sure
    that we always receive an instance of the `rest_framework.request.Request` class
    in the `request` argument when Django calls our view function. In addition, the
    decorator handles the `ParserError` exceptions when our function views access
    the `request.data` attribute and there are parsing problems.
  prefs: []
  type: TYPE_NORMAL
- en: Using decorators to enable different parsers and renderers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will make changes to just one file. After you save the changes, Django's
    development server will automatically restart. However, you can decide to stop
    Django's development server and start it again after you finish all the necessary
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: We will make the necessary changes to use the previously introduced `@api_view`
    decorator to make it possible for the RESTful Web Service to work with different
    parsers and renderers, by taking advantage of generalized behaviors provided by
    the `APIView` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go to the `restful01/toys` folder and open the `views.py` file. Replace
    the code in this file with the following lines. However, take into account that
    many lines have been removed, such as the lines that declared the `JSONResponse`
    class. The code file for the sample is included in the `hillar_django_restful_04_02`
    folder, in the `restful01/toys/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The new code applies the `@api_view` decorator for the two functions: `toy_list`
    and `toy_detail`. In addition, the new code removes the `JSONResponse` class and
    uses the more generic `rest_framework.response.Response` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We had to remove the usage of the `rest_framework.parsers.JSONParser` class
    in the functions to make it possible to work with different parsers. This way,
    we stopped working with a parser that only works with JSON. In the older version
    of the code, the `toy_list` function executed the following two lines when the
    `request.method` attribute was equal to `''POST''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the new code, we removed the first line that called the `JSONParser().parse`
    method that was only capable of parsing JSON content. The new code replaces the
    two previous lines with the following single line that passes `request.data` as
    the `data` argument to create a new `ToySerializer` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the older version of the code, the `toy_detail` function executed the following
    two lines when the `request.method` attribute was equal to `''PUT''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We made edits that are similar to the changes done for the code in the `toy_list`
    function. We removed the first line that called the `JSONParser().parse` method
    that was only capable of parsing JSON content. The new code replaces the two previous
    lines with the following single line that passes `toy` as the first argument and
    `request.data` as the `data` argument to create a new `ToySerializer` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Taking advantage of content negotiation classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `APIView` class defines default settings for each view that we can override
    by specifying the desired values in the settings module, that is, the `restful01/settings.py`
    file. It is also possible to override the class attributes in subclasses. In this
    case, we won't make changes in the settings module, but we have to understand
    which are the default settings that the `APIView` class uses. We added the  `@api_view`
    decorator, and it automatically makes the `APIView` use these settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value for the `DEFAULT_PARSER_CLASSES` setting key specifies a tuple of
    string whose values indicate the default classes that we want to use for parsing
    backends. The following lines show the default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use the `@api_view` decorator, the RESTful Web Service will be able
    to handle any of the following content types through the appropriate parsers.
    Thus, we will be able to work with the `request.data` attribute to retrieve the
    keys and values for each of these content types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`application/json`: Parsed by the `rest_framework.parsers.JSONParser` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application/x-www-form-urlencoded`: Parsed by the `rest_framework.parsers.FormParser`
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multipart/form-data`: Parsed by the `rest_framework.parsers.MultiPartParser`
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we access the `request.data` attribute in the functions, the Django REST
    framework examines the value for the `Content-Type` header in the incoming request
    and determines the appropriate parser to parse the request content. If we use
    the previously explained default values, the Django REST Framework will be able
    to parse all of the previously listed content types. Notice that the request must
    specify the appropriate value for the `Content-Type` key in the request header.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value for the `DEFAULT_RENDERER_CLASSES` setting key specifies a tuple
    of string whose values indicate the default classes that we want to use for rendering
    backends. The following lines show the default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use the `@api_view` decorator, the RESTful Web Service will be able
    to render any of the following content types through the appropriate renderers.
    We made the necessary changes to work with a `rest_framework.response.Response`
    instance to be able to work with these content types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`application/json`: Rendered by the `rest_framework.response.JSONRenderer`
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text/html`: Rendered by the `rest_framework.response.BrowsableAPIRenderer`
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we understand the default settings for parsers and renderers. There
    is an additional part of this puzzle that must select the appropriate renderer
    for the response based on the requirements specified in the incoming request.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the value for the `DEFAULT_CONTENT_NEGOTIATION_CLASS` is the `rest_framework.negotiation.DefaultContentNegotiation`
    class. When we use the decorator, the web service will use this content negotiation
    class to select the appropriate renderer for the response, based on the incoming
    request. This way, when a request specifies that it will accept `text/html`, the
    content negotiation class selects the `rest_framework.renderers.BrowsableAPIRenderer`
    to render the response and generate `text/html` instead of `application/json`.
  prefs: []
  type: TYPE_NORMAL
- en: In the old version of the code, we used the `JSONResponse` and `HttpResponse`
    classes in the functions. The new version replaced the usages of both classes
    with the `rest_framework.response.Response` class. This way, the code takes advantage
    of the content negotiation features. The `Response` class renders the provided
    data into the appropriate content type and returns it to the client that made
    the request.
  prefs: []
  type: TYPE_NORMAL
- en: Making supported HTTP OPTIONS requests with command-line tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will take advantage of all the changes we've made in the code and we
    will compose and send HTTP requests to make our RESTful Web Service work with
    different content types. Make sure you've saved all the changes. In case you stopped
    Django's development server, you will have to start it again as we learned in
    [Chapter 3](dj-rst-websvc_ch13.html), *Creating API Views*, in the section *Launching
    Django's development server*, to start running the Django development server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to know which HTTP verbs the toys, collection supports, that is, we
    want to take advantage of the `OPTIONS` verb. Run the following command. This
    time, the command won''t produce errors. Remember that the virtual environment
    we have created in the previous chapters must be activated in order to run the
    next `http` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `OPTIONS
    http://localhost:8000/toys/`. The request will end up running the `views.toy_list`
    function, that is, the `toy_list` function declared within the `toys/views.py`
    file. We added the `@api_view` decorator to this function, and therefore, the
    function is capable of determining the supported HTTP verbs, the enabled parsing
    and rendering options. The following lines show the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The response header includes an `Allow` key with a comma-separated list of
    HTTP verbs supported by the resource collection as its value: `POST, OPTIONS,
    GET`. Our request didn''t specify the allowed content type, and therefore, the
    function rendered the response with the default `application/json` content type.'
  prefs: []
  type: TYPE_NORMAL
- en: The response body specifies the `Content-type` that the resource collection
    is capable of parsing in the values for the `"parses"` key and the `Content-type`
    that the resource collection is capable of rendering in the values for the `"renders"`
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to compose and send an HTTP request with the `OPTIONS`
    verb for a toy resource. Don''t forget to replace `2` with a primary key value
    of an existing toy in your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `OPTIONS
    http://localhost:8000/toys/2`. The request will end up running the `views.toy_detail`
    function, that is, the `toy_detail` function declared within the `toys/views.py`
    file. We also added the `@api_view` decorator to this function, and therefore,
    it is capable of determining the supported HTTP verbs, the enabled parsing and
    rendering options. The following lines show a sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The response header includes an `Allow` key with a comma-separated list of
    HTTP verbs supported by the resource as its value: `DELETE, PUT, OPTIONS, GET`.
    The response body specifies the `Content-type` that the resource is capable of
    parsing in the values for the `"parses"` key and the `Content-type` that the resource
    collection is capable of rendering in the values for the `"renders"` key. The
    resource and the resource collection can parse and render the same content types
    because everything is handled by the decorator and the `APIView` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with different content types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](dj-rst-websvc_ch13.html)*, Creating API Views*, when we composed
    and sent `POST` and `PUT` commands, we had to use the use the `-H "Content-Type:
    application/json"` option to indicate curl to send the data specified after the
    `-d` option as `application/json`. We had to use this option because the default
    content-type in curl is `application/x-www-form-urlencoded`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, our RESTful Web Service goes beyond JSON and it can also parse `application/x-www-form-urlencoded`
    and `multipart/form-data` data specified in the `POST` and `PUT` requests. Hence,
    we can compose and send a `POST` command that sends the data as `application/x-www-form-urlencoded`.
  prefs: []
  type: TYPE_NORMAL
- en: We will compose and send an HTTP request to create a new toy. In this case,
    we will use the `-f` option for HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'This option serializes data items from the command line as form fields and
    sets the `Content-Type` header key to the `application/x-www-form-urlencoded`
    value. Run the next command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command that creates a new toy. Notice
    that we don''t use the `-H` option and curl will send the data in the default
    `application/x-www-form-urlencoded`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `POST
    http://localhost:8000/toys/` with the `Content-Type` header key set to the `application/x-www-form-urlencoded`
    value and the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The request specifies `/toys/`, and therefore, it will match the `'^toys/$'`
    regular expression and Django will run the `views.toy_list` function, that is,
    the updated `toy_detail` function declared within the `toys/views.py` file. The
    HTTP verb for the request is `POST`, and therefore, the `request.method` property
    is equal to `'POST'`. The function will execute the code that creates a `ToySerializer`
    instance and passes `request.data` as the `data` argument to create the new instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rest_framework.parsers.FormParser` class will parse the data received
    in the request, the code creates a new `Toy` and, if the data is valid, it saves
    the new `Toy`. If the new `Toy` instance was successfully persisted in the database,
    the function returns an HTTP `201 Created` status code and the recently persisted
    `Toy` serialized to JSON in the response body. The following lines show an example
    response for the HTTP request, with the new `Toy` object in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Sending HTTP requests with unsupported HTTP verbs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will compose and send HTTP requests with an HTTP verb that isn''t supported
    for the toys resource collection. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `PATCH
    http://localhost:8000/toys/`. The request will try to run the `views.toy_list`
    function, that is, the `toy_list` function declared within the `toys/views.py`
    file. The `@api_view` decorator we added to this function doesn''t include `''PATCH''`
    in the string list with the allowed HTTP verbs. The default behavior when this
    happens in the `APIView` class is to return an HTTP `405 Method Not Allowed` status
    code. The following lines show a sample output with the response from the previous
    request. A JSON content provides a `detail` key with a string value that indicates
    the `PATCH` method is not allowed in the response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@api_view` decorator declared in the `rest_framework.decorators` module
    allows you to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify which is the model related to the function based view
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify which are the HTTP verbs that the function based view to which it is
    applied can process
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify which is the serializer related to the function based view
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `@api_view` decorator is a wrapper that converts a function based view
    into a subclass of which of the following classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`django.Http.Response.HttpResponse`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rest_framework.views.APIView`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rest_framework.serializers.Serializer`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following settings key in the REST_FRAMEWORK dictionary allows
    you to override the global setting with a tuple of string whose values indicate
    the default classes that you want to use for parsing backends:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''DEFAULT_PARSER_CLASSES''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''GLOBAL_PARSER_CLASSES''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''REST_FRAMEWORK_PARSING_CLASSES''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following classes is able to parse application/json content type
    when we work with the `@api_view` decorator and its default settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`django.parsers.JSONParser`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rest_framework.classes.JSONParser`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rest_framework.parsers.JSONParser`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following classes is able to parse application/x-www-form-urlencoded
    content type when we work with the `@api_view` decorator and its default settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`django.parsers.XWWWUrlEncodedParser`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rest_framework.classes.XWWWUrlEncodedParser`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rest_framework.parsers.FormParser`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The rights answers are included in the [Appendix](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&action=edit#post_454), *Solutions*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we improved our simple Django RESTful Web Service. We took
    advantage of many features included in the Django REST framework to remove duplicate
    code and to add many features for the web service. We just needed to edit a few
    lines of code to enable an important amount of features.
  prefs: []
  type: TYPE_NORMAL
- en: First, we took advantage of model serializers. Then, we understood the different
    accepted and returned content types and the importance of providing accurate responses
    to the HTTP OPTIONS requests.
  prefs: []
  type: TYPE_NORMAL
- en: We incorporated the `@api_view` decorator and made the necessary changes to
    the existing code to enable diverse parsers and renderers. We understood how things
    worked under the hood in the Django REST framework. We worked with different content
    types and noticed the improvement of the RESTful Web Service compared with its
    previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand how easy it is to work with different content types
    with the Django REST framework, we will work with one of the most interesting
    and powerful features: the browsable API. We will cover this topic in [Chapter
    5](dj-rst-websvc_ch15.html), *Understanding and Customizing the Browsable API
    Feature*.'
  prefs: []
  type: TYPE_NORMAL
