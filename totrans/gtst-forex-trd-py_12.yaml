- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sample Strategy – Trend-Following
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we developed two trading applications: one to use
    in production and another one to facilitate the testing and research of trading
    strategies. Better said, these are two versions of the same application, with
    different data processing modules. We designed them so that the trading logic
    developed in the backtesting app could be used in the production one without modifications
    (or with just minimal modifications in complex cases). We also tested the code
    using a sample "*strategy"* and saw that the code worked correctly, but the "*strategy"*
    was steadily losing money – fortunately only on paper (and that’s why I consistently
    put this word in "italics").'
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to learn the process of researching and developing one of the
    most popular classical trading strategies applied to the FX market. We already
    discussed it earlier in the book, but only from a qualitative, not a quantitative,
    perspective. Now we will suggest a formal mathematical model and implement it
    in code. And, of course, we will backtest and check whether the result can be
    used for live trading.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will consider trend-following strategies and learn about
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Trend-following revisited – trading setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the market and preparing data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trend-following strategy – implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trend-following revisited – trading setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 9*](B19145_09.xhtml#_idTextAnchor152), *Trading Strategies and
    Their Core Elements*, we considered trend-following and came to the conclusion
    that although it is one of the simplest and most intuitive trading strategies,
    we still need a set of rules that determine the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether there is a trend in the market
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the trend goes north or south (up or down, that is)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it’s time to join the trend (buy or sell respectively)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it’s time to exit the existing position (so we expect the trend to end
    and/or reverse)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s understand more in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Determining a trend, part 1 – market model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If I ask you whether it’s sunny or rainy outdoors, I’m sure you won’t hesitate
    with an answer in most cases. You can easily tell one from another because you
    are very familiar with a number of attributes that help you make the decision.
    Indeed, it’s easy to tell light from darkness, warmth from cold, moisture from
    dryness, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, say I ask you whether it’s slightly rainy or foggy and do so in the middle
    of the night. I imagine you’d have a really hard time telling one from another.
    Most likely, you would even go outside, try to feel the air on your skin and smell
    the air, and finally return with something such as *“well, it seems to be rain.”*
    In this case, you had to do several tests and use their results to make your judgment.
  prefs: []
  type: TYPE_NORMAL
- en: Why were you able to do these tests and use their results?
  prefs: []
  type: TYPE_NORMAL
- en: Because you have a *model* in your mind, a model of the weather. You wouldn’t
    think about it unless it’s your profession and, in most cases, you make decisions
    intuitively and instantly. However, if put under pressure, you can find some more
    or less formal attributes – such as humidity, temperature, and wind – to decide
    upon the weather, again within the framework of the weather model.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now develop a model of market trends following the same example with the
    weather.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, and above all, we should decide whether trends are something that always
    exists or occurs only at times. If we compare both models (permanent trends and
    occasional trends) with our weather example, we will see the following parallels:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Market** | **Weather** |'
  prefs: []
  type: TYPE_TB
- en: '| The market is always in an uptrend or downtrend. Trends may be more or less
    visible. | The wind blows all the time, only sometimes stronger and other times
    weaker. |'
  prefs: []
  type: TYPE_TB
- en: '| The market can be in *trend mode* or *non-trend* mode. | Sometimes the wind
    blows and other times the wind doesn’t blow at all. |'
  prefs: []
  type: TYPE_TB
- en: Table 12.1 – Drawing parallels between market trends and the weather
  prefs: []
  type: TYPE_NORMAL
- en: Despite looking quite simple, this table perfectly illustrates the fundamental
    difference in approaches to modeling the process (market or weather). It is up
    to the model’s developer to decide either that the observed process can only be
    in one state (only in trend; only wind blowing) or that it can be in multiple
    states (trend or non-trend in the market example; windy or not windy in the weather
    example).
  prefs: []
  type: TYPE_NORMAL
- en: This said, we come to a very important conclusion.
  prefs: []
  type: TYPE_NORMAL
- en: There is no such thing as a *true* or *false* model. A model only tries to explain
    the observed phenomena with certain precision and serves the purpose of making
    decisions.
  prefs: []
  type: TYPE_NORMAL
- en: So, the ability of a model to help make a practical decision is the only criterion
    of the model’s validity. If looking outside the window is enough to know how to
    dress for the day, then the weather model is valid. If you make decisions whether
    to take an umbrella with you by consulting sophisticated equipment and still regularly
    get wet to the skin, most likely, the model used in this sophisticated equipment
    is not valid.
  prefs: []
  type: TYPE_NORMAL
- en: In the market, the situation is similar. If we can suggest a simplistic market
    model that nevertheless is able to consistently outperform a benchmark (see [*Chapter
    9*](B19145_09.xhtml#_idTextAnchor152), *Trading Strategies and Their Core Elements*),
    then this is an acceptable model. At the same time, we may have an extremely sophisticated
    model that uses artificial intelligence and quantum mechanics, but if in the long
    run it doesn’t beat the market, then it may only be interesting from an academic
    standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: As we’re making our first steps in algo trading, let’s start with something
    simple. We can make our model more complicated later if a simplistic model doesn’t
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our present case, we should make a decision regarding how we model the market
    from a trending standpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: The market is always in a trend, up or down; it’s just the duration of these
    trends that may be long or short
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The market is in either a trend or non-trend state, and we should distinguish
    between the two before determining an uptrend or downtrend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, the first model is simpler: we don’t need to suggest a method to
    tell trend from non-trend, focusing now only on technical setups that tell an
    uptrend from a downtrend. Again, if this approach doesn’t work, we can return
    to this decision point, change our model, and start the research all over.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have decided upon the first point in our checklist: we choose the *always-in-trend*
    market model for further research.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have decided upon the market model, let’s move on to finding a
    proper tool to distinguish an uptrend from a downtrend. Again, we start this step
    with the simplest solution: moving averages.'
  prefs: []
  type: TYPE_NORMAL
- en: Determining a trend, part 2 – moving averages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the classical technical analysis studies typically used to determine
    trends is the moving average. In [*Chapter 7*](B19145_07.xhtml#_idTextAnchor114),
    *Technical Analysis and Its Implementation in Python*, we already considered moving
    averages and found that they act as digital filters that eliminate higher frequencies
    (short-term price fluctuations) and keep lower frequencies, which we consider
    as dominating long-term tendencies in price movements. Let’s quickly refresh our
    knowledge of this by plotting a 20-period moving average (MA20) over a price chart.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – 20-period moving average on top of a 1-minute chart of EURJPY.
    Chart by Multicharts](img/B19145_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – 20-period moving average on top of a 1-minute chart of EURJPY.
    Chart by Multicharts
  prefs: []
  type: TYPE_NORMAL
- en: We can see that sometimes, the bars’ closing prices tend to remain above the
    MA20, while sometimes they are below it. It is reasonable to suppose that as long
    as these closing prices remain above the MA20, the market is in an uptrend, and
    while they remain below it, it is in a downtrend.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this technical setup is that sometimes prices remain above
    or below a moving average for too short a period of time. We already agreed that
    in our model the market is always in trend and we do not separate any special
    non-trending condition. However, maybe there’s a better technical setup, something
    that would better indicate an uptrend or downtrend without so many *short-term
    trends*, which we intuitively wouldn’t like to even call *trends*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, there is, and this is one of the oldest classical technical trading setups:
    we use two moving averages, one with a short period and another one with a long
    period. Then, we consider an uptrend only when both of the following two conditions
    are met:'
  prefs: []
  type: TYPE_NORMAL
- en: The price is above the short-period moving average
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The short-period moving average is itself above the long-period moving average
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is similar for downtrends:'
  prefs: []
  type: TYPE_NORMAL
- en: The price is below the short-term moving average
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The short-period moving average is itself below the long-period moving average
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see what it may look like on a chart.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Adding a longer-term moving average helps exclude unwanted
    situations](img/B19145_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Adding a longer-term moving average helps exclude unwanted situations
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, I added a 50-period moving average (MA50) to the existing
    MA20 and zoomed the figure in to see more details. The area encompassed by a dotted
    oval illustrates how adding the second moving average may filter out certain (but,
    of course, not all) unwanted situations. If we decide whether it’s an uptrend
    or a downtrend only by closing prices being above or below MA20, then during the
    phase shown in *Figure 12**.2*, we would have to decide whether there was a downtrend.
    However, if we use a setup with both requirements as we suggested previously (that
    the price should be below MA20 and MA20 should be below MA50), then we can qualify
    it neither as an uptrend nor as a downtrend. So, in the trade logic, we simply
    skip this interval – and then we can see that the following price movement develops
    into a *true* uptrend.
  prefs: []
  type: TYPE_NORMAL
- en: Great, now we have covered two points in our list– we know when there’s a trend
    in the market and know its direction. Now we need to decide when we actually enter
    and exit a position in the market.
  prefs: []
  type: TYPE_NORMAL
- en: Entry and exit rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After all the elements of a technical trading setup are determined, the key
    question remains of when to actually enter and exit a position. In some cases,
    it may be a non-trivial question and the answer to it may seriously affect the
    resulting performance of a strategy. However, within our simplistic model, we
    can assume that we can enter the market as soon as the trend conditions are met.
    This means that we open a new long position when the following apply:'
  prefs: []
  type: TYPE_NORMAL
- en: The bar’s closing price is above the short-period moving average
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The short-period moving average is above the long-period moving average
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently, we don’t have a long position in the market (so we don’t add to an
    existing position, and we don’t buy more if we’re already long)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As to exiting from an open position – again, within our market model there’s
    no need to actually exit a position because the model assumes that the market
    is always in a trend. So, we exit a long position only when we open a short position
    and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we plan a strategy that is *always in the market* and changes
    the trade’s direction as soon as the change in the trend is detected.
  prefs: []
  type: TYPE_NORMAL
- en: As with the market model, we can change this approach later, if testing the
    current simplistic model doesn’t produce acceptable results.
  prefs: []
  type: TYPE_NORMAL
- en: Money management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Money management** means how much you trade with each new order. There are
    many money management theories and techniques, from very simple to quite sophisticated.
    Unfortunately, we cannot really cover all of them in one chapter – it would require
    a separate book! But since we are keeping things simple at the moment and are
    more interested in learning how the trade logic works in general, let’s use the
    most simplistic money management concept as well: we will use the same constant
    trading size for all trades, doubling it when we should make a reversal from long
    to short or from short to long. We already did that in the previous chapter when
    we developed our backtesting platform.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rule of thumb is: if your strategy performs acceptably well with a constant
    trading size, its performance may be improved with money management. If the strategy
    doesn’t perform well with constant trading size then attempts to improve its performance
    by using various money management rules fail most of the time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have successfully covered the four key points that we outlined at the
    beginning of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We know when the market is in trend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know the trend’s direction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know when to enter the market
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know when to exit it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plus, we also know how much we have at stake with each trade.
  prefs: []
  type: TYPE_NORMAL
- en: Great, now we can proceed to choose the market we’re going to trade using trend-following
    and prepare the data.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the market and preparing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one very common misconception regarding systematic trading: it is
    believed that a technical trading strategy should work in any market. I hope that
    the previous chapters have already dispelled this myth. Just as an example, let’s
    recall the famous EURCHF market while the Swiss national bank was keeping the
    rate of the Swiss franc pegged to the euro (see [*Chapter 9*](B19145_09.xhtml#_idTextAnchor152),
    *Trading Strategies and Their Core Elements*) – go and trade it using trend-following
    if the price virtually doesn’t move at all!'
  prefs: []
  type: TYPE_NORMAL
- en: Even if we set aside such extreme examples, anyway, choosing the market can
    be a non-trivial task. Most of the time, we have to try many markets even if we
    can make an educated guess about which should perform better with a specific kind
    of strategy. However, there are some general guidelines that we are going to use
    now.
  prefs: []
  type: TYPE_NORMAL
- en: First, since we’re focused on trend-following, we would like to trade a market
    that is full of trends (however much it may sound like a truism). If we are in
    the FX domain, we may want to focus on currency pairs with the greatest difference
    in the interest rates between the two currencies (see the *Fundamental analysis*
    section of [*Chapter 6*](B19145_06.xhtml#_idTextAnchor101), *Basics of Fundamental
    Analysis and Its Possible Use in FX Trading*, for a brief discussion on interest
    rates and carry trading) because this is one of the very few factors that may
    lead to forming a more or less long-term trend. So, pairs with currencies such
    as the Australian dollar or the New Zealand dollar versus the Japanese yen or
    even the US dollar (especially when the US rates were low) may be good to start
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to choose the Australian dollar for trading with a trend-following
    strategy is that the Australian economy is dependent on gold production, much
    like the Canadian economy depends on oil (though perhaps to a lesser extent).
    As a result, the rate of the Australian dollar is prone to corresponding changes
    in the price of gold and other export commodities. Since commodity prices exhibit
    cyclic behavior due to manufacturing cycles, we can see this reflected in AUDUSD
    or AUDJPY. Therefore, with these two considerations in mind, choosing AUDUSD as
    the first currency pair to try a trend-following strategy seems like a natural
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we should decide upon the timeframe or data resolution. Although the
    previous sample charts with moving averages were made using a resolution of 1
    minute, intraday data is not really good for trend-following strategies. The reason
    is that intraday the FX market exhibits strongly cyclical behavior in volatility
    patterns (see the *Liquidity and volatility – how one transforms into another*
    section of [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044), *FX Market Overview
    from a Developer’s Standpoint*). These markets are active during the daytime and
    slow during the night. This periodicity will produce many *false trends* and make
    the task of determining a *true trend* significantly more difficult. At the same
    time, the daily timeframe is free from this feature and we may expect more steady
    trending behavior with this data resolution (of course, depending on whether the
    market is prone to trending at all). So, when we have a choice of making our model
    more complicated by adding a module to the trading logic, which would distinguish
    between *true* and *false* trends, we’d rather use data with higher resolution
    to eliminate the problem completely.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we have decided upon the market (let’s start with AUDUSD) and the data
    resolution (daily). As always, let me note that if we get unsatisfactory results,
    we can try different markets and timeframes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have settled upon all the prerequisites, let’s get to coding.
  prefs: []
  type: TYPE_NORMAL
- en: Compressing data to a daily timeframe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with writing a simple utility that would compress the market data
    to the required resolution and convert it into the desired format, compatible
    with our backtesting and live trading code (see [*Chapter 11*](B19145_11.xhtml#_idTextAnchor186),
    *Backtesting and Theoretical Performance*). We will use the `getBarRealtime()`
    function from the live version and slightly adapt it as a stand-alone utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'This utility should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the source data file (tick or 1-minute bars)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregate data into any greater timeframe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save data to disk using a format compatible with the backtester
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As always, we start with imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a sliding window class similar to the one we used in [*Chapter 6*](B19145_06.xhtml#_idTextAnchor101),
    *Basics of Fundamental Analysis and Its Possible Use in FX Trading*, but we will
    use it in a bit of a different way: to store values of any parameter (price, time,
    volume, or whatever) on the current bar and the previous bar. Thus, we add two
    respective methods to quickly retrieve these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we specify the source file and the destination file and read the saved
    data (tick or 1 minute) – pretty much like we did in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We immediately write the first line to the destination file – this line will
    act as a header for further processing the file as a CSV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create an instance of the `slidingWindow` class and initiate the first
    bar, which we’re going to aggregate and then save to the destination file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we start iterating over all samples in the source file, convert the data,
    and add the timestamp to the timestamp sliding window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The header format of the source file may be different. In the files that I
    use in this book, there are at least two different formats: plain words (`''Open''`,
    `''High''`, etc.) and words in triangle brackets (`<Open>`, etc.). Be careful
    and don’t forget to adapt this piece of code to the source data you’re going to
    use yourself!'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the date of the timestamp is not equal to that of the previous timestamp
    – meaning that a new day had started – we save the updated daily bar to the destination
    file and reinitialize the bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we update the currently forming bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t forget to close the destination file after the `for` loop has finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code using the same AUDUSD 1-minute historical data as I used
    (you can find it on GitHub along with the code), you will get a CSV file with
    daily bars where the `''Time''` column features two different times: `17:00` and
    `23:59`. Why is that?'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this is a very important question that deserves an insightful answer.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful with time!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No, this doesn’t mean that you should be looking at your watch every other minute.
    It means that when working with market data, time is the very thing that leads
    to confusion, especially in cases where you work with data from decentralized
    markets such as forex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with data from a centralized exchange is somewhat easier: in this case,
    we always know in which time zone the exchange is located and its working hours.
    So, in any market data from that exchange, all timestamps will be in the same
    time zone as the exchange and only between market open and close.'
  prefs: []
  type: TYPE_NORMAL
- en: With forex, it’s different. We know that there’s no single exchange in this
    market and that it works almost 24 hours, 5 days a week.
  prefs: []
  type: TYPE_NORMAL
- en: '*Almost*, mind you.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we must consider time zones. Every FX data vendor and every FX broker
    may deliver data in any time zone they think is correct. Most frequently used
    are GMT (UTC) or BST (UTC+1) for London, CET (UTC+1) or CEST (UTC+2) for Frankfurt,
    and EST (UTC-5) or EDT (UTC-4) for New York. You should check the data source
    about the time zone used before you do any manipulations with timestamps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, we must consider working hours. Most FX trading venues open on Sunday
    at around 5 p.m. New York time (New York bank settlement time; see the *FX instruments*
    section of [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044), *FX Market Overview
    from a Developer’s Standpoint*), but some may open at a later time. Same with
    the market close before the weekend: most venues close on Friday at that same
    time of 5 p.m. in New York, but some even offer weekend trading. We can’t consider
    this weekend trading seriously because the trading volume for weekend deals is
    negligible, but you may get hold of market data from a venue which provides weekend
    trading and this weekend data will add quite some confusion to your research process.
    If you plan to trade exotic currencies, most likely they will only be traded during
    the work hours of the respective state central bank or just a bit longer.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides regular working hours, there are exceptions, mostly around holidays.
    For example, don’t be surprised if you see an early close before or a late open
    after Christmas.
  prefs: []
  type: TYPE_NORMAL
- en: Third, we must consider how 0:00 time is interpreted. Some data providers treat
    this time as the start of a new day, while others believe it refers to the previous
    day. Moreover, some data providers even don’t have such a timestamp and the last
    time of the day in their data is 23:59 (for 1-minute data).
  prefs: []
  type: TYPE_NORMAL
- en: This 0:00 time is quite confusing. When we work with data compressed in bars,
    the bar’s timestamp means the time when the bar closes. Therefore, 0:00 means
    that the bar closed at midnight. But it still represents price movements that
    happened before midnight, so they belong to the day that just finished! So, if
    you want to be absolutely precise when working with time, you may want to add
    some additional checks to your code that take into account the issues we’ve just
    discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the data we used in our example and see what we actually
    did. This data is in the New York time zone, so the last time of the week is 17:00
    – and this is what we see in the compressed daily data for every Friday. This
    data provider treats 0:00 as the first time of the new day, so since we divide
    days by date and do not take time into consideration, the last time of a day is
    now 23:59.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may want to modify the new day conditions in the code of the bar-making
    utility. One of the possible solutions could be a condition like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If we now run the modified code, we get correctly compressed data, but keep
    in mind that 0:00 timestamps now denote the end of the day, not its beginning!
  prefs: []
  type: TYPE_NORMAL
- en: Now we have all the data prepared and it’s time to try writing the code for
    our first strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Trend-following strategy – implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we’re going to use the backtesting code that we developed in the previous
    chapter (see the *Backtesting platform with historical data feed* section in [*Chapter
    11*](B19145_11.xhtml#_idTextAnchor186), *Backtesting and Theoretical Performance*),
    we need to add only small pieces of code that support the required objects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to change the data source to the file with the daily AUDUSD data
    that we’ve just created!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with adding the `slidingWindow` class to implement moving averages.
    Obviously, we copy it from the code in the preceding section. The code (as usual
    with class declaration) goes somewhere after the imports and before the declaration
    of the first function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you progress in developing various strategies, sooner or later you will find
    that many classes or functions are used in most strategies, so you can move them
    to a separate module and import the module into any strategy prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add two sliding windows to implement moving averages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Why `5` and `20` for periods of moving averages? Well, no real reason in particular:
    when we work with daily data, `5` is usually used to represent a work week and
    `20` a work month. These values can often be found in technical analysis studies.
    Other popular periods are `50` (for a quarter) and `200` (for a year). In any
    case, this is only a draft, so we will be able to modify these values later, after
    having evaluated the strategy performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we have the function that actually calculates a moving average:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'All that we need to modify now is part of the `tradeLogic()` function. It is
    the block of code between the `trade logic starts here` and `trade logic ends`
    `here` comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, we retrieve a new closing price and add it to both sliding windows.
    Then we calculate the moving averages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the main part: the entry condition. We sell if the close is below the short-period
    MA and the short-period MA is below the long-period MA. Don’t forget that we do
    that only if we don’t have an open short position already (see the *Trading application
    with live data feed* section in [*Chapter 11*](B19145_11.xhtml#_idTextAnchor186),
    *Backtesting and* *Theoretical Performance*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the trade logic code in the `''Sell''` clause remains untouched,
    and I have reproduced it here only to maintain integrity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And symmetrical for a buy order: we buy when the close is greater than the
    short-period MA and the short-period MA is greater than the long-period MA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is it. Nothing else needs any modification.
  prefs: []
  type: TYPE_NORMAL
- en: Are you ready to test your first trading strategy? Let’s run the code and look
    at the equity curve.
  prefs: []
  type: TYPE_NORMAL
- en: If you did everything correctly so far, you should see an equity curve similar
    to the one shown in *Figure 12**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Equity curve of the backtest of the trend-following strategy
    using AUDUSD daily data](img/B19145_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Equity curve of the backtest of the trend-following strategy using
    AUDUSD daily data
  prefs: []
  type: TYPE_NORMAL
- en: Not a bad start! In [*Chapter 11*](B19145_11.xhtml#_idTextAnchor186), *Backtesting
    and Theoretical Performance*, we talked about the equity curve and noted that
    traders (and investors, above all!) are looking for strategies that demonstrate
    consistent growth over time. Since our equity curve is a representation of our
    trend-following strategy PnL day by day, we can agree that this strategy indeed
    demonstrates growth in equity.
  prefs: []
  type: TYPE_NORMAL
- en: However, this result raises further questions. What is the meaning of the numbers
    on the *x* and *y* axes? How do we interpret this result in terms of money or
    percent growth? Can we say that the growth demonstrated by the backtest is consistent?
    These and other questions will be discussed in the very next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s quickly recap what we learned in this chapter. It indeed is the ultimate
    point where all the knowledge and skills we obtained in previous chapters unite
    and transform into a working trading application. More than that, in fact, we’ve
    got now a scalable *trading platform* suitable for both research and live trading.
    We suggested a robust design of the platform that keeps the architecture modular
    and scalable. We learned how to synchronize threads to ensure the correct order
    of execution of the platform modules while keeping these modules isolated. We
    saw practical examples of using various data sources that allow the platform to
    work with both live data feeds and historical data. We completely isolated the
    trade logic from the rest of the app so now we can develop a strategy using a
    backtest and then immediately copy and paste the code into the production version
    of our platform. Finally, using our knowledge of FX markets from previous chapters,
    we developed a simple trend-following strategy, tested it, and saw a promising
    result.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to analyze our result to get a full understanding of the strategy’s
    behavior and performance.
  prefs: []
  type: TYPE_NORMAL
