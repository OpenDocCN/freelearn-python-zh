- en: Function and Scope of Variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about control statements and loops. We learned
    about various types of control statements such as `if` statement, `if...else`
    statement, and `if...elif...else` statement. Next, we saw two main categories
    of loops, that is, definite and infinite loops. Under definite loops, we saw the
    working of for loop and we learned about two utility functions that are provided
    by Python, which can generate a list on-the-fly. They are `range()` and `xrange()`.
    Next, we learned about infinite loops, where we saw the working principle of the
    while loop. Then, we learned about nested loops along with break and continue
    statements. In this chapter, we will be covering functions, functions with arguments,
    functions with arguments and return value, functions with default arguments, functions
    with variable length arguments, key-value pairs as variable length arguments to
    the function, and finally we will be discussing on the scope of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The big question arising in the minds of the beginner would be, "What are functions?"
    and "Why are they necessary in any programming language?"
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions are nothing but a small programming unit inside a big programming
    construct that generates a designated output. Let''s try to understand with real-world
    scenario. It''s difficult to think of a scenario where someone may not have access
    to television. What do you observe inside a normal television? On broader classification,
    considering a normal viewer, it has three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: It has a display unit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a volume control unit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a channel tuning setup embedded inside the electronic circuitry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although modern smart televisions have more complex functions, we will restrict
    our example to three main functions explained.
  prefs: []
  type: TYPE_NORMAL
- en: The display unit works differently from the other two functional units and its
    sole purpose is to put up a display to the user. Similarly, the volume control
    unit has its sole purpose to fine-tune the volume of the television, and, finally,
    channel tuning has the main function to have different channels loaded in the
    memory. Functions in programming language also work in a similar fashion, each
    has its own purpose defined. Some examples can be `calculateMonthSalary()`, `calculateTotalBill()`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: A method is an identical function in terms of name except that it is called
    on object and passed on the data, whereas a function is called directly by name
    and passed on the data to operate. A method is something that belongs to an object
    or in object-oriented programming class which contains the method. In this chapter,
    we will study more about functions.
  prefs: []
  type: TYPE_NORMAL
- en: Categories of functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions in any programming language can fall into two broad categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-defined functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: They are predefined by programming languages and each serves a specific purpose.
    While some built-in functions cannot be customized, some can be customized as
    per the programming guidelines laid down by a specific programming languages.
    The Python language also comes with a set of built-in functions such as `len()` and `cmp()`.
    You can get details about built-in functions from the Python documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The Python documentation can be found at [https://docs.python.org](https://docs.python.org).
  prefs: []
  type: TYPE_NORMAL
- en: User-defined functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: They are defined by users as per their programming requirement. Functions can
    be created or can exist in various forms in any programming language. In this
    section, we will learn in depth about various ways in which we can create a function.
  prefs: []
  type: TYPE_NORMAL
- en: Function definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some simple rules to define a function in Python. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `def` keyword followed by function name with parentheses `()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any argument to the function must be placed within these parentheses `()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code block must start with a colon `:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code within the function must be indented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The syntax for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is the syntax of any function definition in Python. If there are any arguments,
    they are written inside the parentheses and if the function has any return value
    that would be the last statement in any function code block or function body.
    The function code block or function body starts immediately after colon (`:`)
    and ends with return value if there is any return value. In Python, the body of
    any code block which starts after a colon (`:`) must be indented using spaces
    (preferably) or else with a tab. This eliminates indentation errors, which the
    interpreter might throw while running the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'More on indentation is available at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.python.org/dev/peps/pep-0008/#tabs-or-spaces](https://www.python.org/dev/peps/pep-0008/#tabs-or-spaces).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to call a function in a program.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be wondering what is *calling a function*. Now, let's suppose you
    wrote some business logic about washing instructions to be embedded inside an
    automatic washing machine. Let's say you want to time sequence for rinsing of
    clothes immediately after wash. In programming language, you don't want to get
    lost writing a big chunk of program, so, in order to make things easy, you write
    your business logic inside a function. This function has to be called when you
    want that particular sequence to be timed right after the washing sequence finishes.
    There you pass the execution of instruction to the function written for timing
    of sequence. This is achieved by calling the function at an appropriate time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax block of code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A function can be called within a programming construct similar to the built-in
    function. Use the name of the function followed by a set of parentheses. A function
    can be called any number of times within the same programming file, or another,
    or can be called within another function. Yes you got it right: a function can
    call another function. Let''s learn from an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define the `helloWorld()` function and we give a body, which has a
    comment and a print statement. Finally, we simply call the function by merely
    typing the name of the function followed by parentheses. When the program is run,
    we get the output as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image1-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are various ways in which a function can be written or exists in any programming
    language. We will discuss various ways in which a function can be formed in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Function with arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we saw a function which had no arguments, now we will learn about functions
    with arguments. A function can contain any number of arguments depending on the
    business requirement. Let''s try to understand with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `func` function accepts one argument which has
    a data type string. We create a variable `str` with a certain string statement
    assigned and then we call the `func` function and thereby pass the value of `str`.
    Finally, the output will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image2-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, what will happen if we do not pass any argument to
    the function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It will simply throw a `TypeError` as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image3-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hence, it becomes mandatory to pass an argument to the function during function
    calling after the function has been defined to accept arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Function with an argument and return type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, it may be necessary to return any specific datatype or value from
    a function which takes any arbitrary number of arguments. Let''s evaluate this
    scenario with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define the function, which accepts two arguments and the body evaluates
    their sum with return type as value of the sum, which is denoted by the `return
    c` statement. We then call the function in the print statement and pass the value
    of variable `x` and variable `y`. This will give us the output as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image4-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Function with default argument
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you will be presented with a condition where there has to be some
    value assigned to the argument, which will be called as the default argument.
    Let''s try to understand with real-life scenario. Most of us fill in certain forms
    for job application online. Now, in the form, there is a section for gender selection.
    In this case, programmers have inserted a default value as female. By default
    your sex will be set to female if you do not specifically change this value. Same
    is the case with the function with default arguments. Let''s try to understand
    this with a small code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `info` function takes two arguments `name` and `age`. The `age` is
    the argument with the default value `50`. In this case, during the calling of
    the `info` function, if `age` is not provided, then the function will set the
    value of `age` as `50`. We have called the `info` function twice. In the first
    call, we pass the value of `"John"` and `age` as `28`, while in the second call,
    we just pass the value of `name` as `"James"`. We will get output as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image5-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Function with variable length argument
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There might be a scenario where you need to pass more arguments than specified
    during the function definition. In this case, variable length arguments can be
    passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `arg` means normal argument which is passed to the function. The `*var`
    refers to the variable length argument. This is will be more clear through the
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we define a function which takes two arguments, where the second
    argument is the variable length argument. When we call the function for the first
    time, we pass only `60` as the value to the argument and the function takes it
    as the first argument. During our second call to the function, we pass five numbers,
    so the function takes them as variable length argument. Depending on the nature
    of arguments passed, the function either considers the first argument or the variable
    length argument. Finally, we could see a different output based on our passing
    of different values as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image6-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Key-value pair as variable length argument
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Under certain circumstances, there might be a situation, where the key-value
    pair needs to be passed as the variable length argument to the function. Let''s
    take one example here. In the given example, the key-value pairs are passed as
    variable length arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a for loop we print out each key-value pair that is passed to the function.
    On the first call, we pass only few key-value pairs, while in the second call
    to the function, we pass a bit more key-value pairs and we get the output as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image7-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pass by reference versus pass by value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Pass by reference** is the term used in some programming languages, where
    values to the argument of the function are passed by reference, that is, the address
    of the variable is passed and then the operation is done on the value stored at
    these addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pass by value** means that the value is directly passed as the value to the
    argument of the function. In this case, the operation is done on the value and
    then the value is stored at the address.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python arguments, the values are passed by reference. During the function
    call, the called function uses the value stored at the address passed to it and
    any changes to it also affect the source variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in the function definition, we pass the list to the `pass_ref` function
    and then we extend the list to add two more numbers to the list and then print
    its value. The list extends inside the function, but the change is also reflected
    back in the calling function. We finally get the output by printing out different
    representations of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image8-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at another scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example might make you think it is called by value, as the change
    happening inside the Python function does not get reflected back in the calling
    function. It is still a pass by reference, as, in this situation inside the function,
    we made new assignment, that is, `a= a+4`. Although you might think that `a =
    a + 4` is changing the number stored in `a`, but it is actually reassigning a
    to point to a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image9-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Scope of variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This could be an intriguing topic for you to understand for the first time.
    But it is actually a very simple topic. Let''s try to understand this with a real-life
    situation. You might be aware of two types of airlines: domestic and international
    carriers. The scope of domestic carriers will be restricted to a particular country''s
    operation only, while an international carrier has the scope to operate on an
    international border. Same is the case with variables. The scope on the broader
    aspect defines the access level for specific variable. There are two basic scopes
    of variables in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: Local variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A local variable is defined inside the Python function. Local variables are
    only accessible within their local scope. A global variable is defined outside
    the Python function. Global variables are only accessible throughout the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image11-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, the variable `k` with value `4` is an example of a global variable, while
    the `list1` variable is an example of a local variable. The area marked in green
    inside the `main()` function shows the scope of the `list1` variable, while the
    area marked in yellow shows the scope within the `add()` function, and this scope
    is valid until the end of the `add()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The succeeding example will explain both these types of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Variable a is a global variable; its value remains the same outside the function
    compared to the value inside the function, where it is acting as a local variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image10-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s analyze another situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have declared variable a whose scope is local to the `func()` function.
    As we try to access the local variable, the interpreter does not support us on
    this and will tell you something as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image11-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'But this situation can be overcome using the `global` keyword, as we will use
    in our next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we declare the `k` variable as global using the `global` keyword
    inside the function. We can now access it from anywhere. The `global` keyword
    tells the interpreter that the variable is global and it should stop searching
    across all the functions or local scopes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image12-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is quite a fascinating topic and is also a big pain for any programmer
    who has to deal with memory-related issues such as memory leakage issues. However,
    since it is a big topic which needs to be covered at the intermediate stage, we
    will try to explain the very basics of the topic. In the earlier days, memory
    management used to be handled manually by all the programmers. Who could better
    understand manual memory management than C/C++ language programmers. New and modern
    programming languages such as Java and others are coming loaded with more advanced
    memory management mechanism, so programmers have to worry less in this area as
    every issue is taken care by the language garbage collection facility. We have
    already covered what is local scope and what is global scope are. Local scope
    of the function, contains parameters and variables. The complete local scope must
    be stored somewhere in the RAM of the computer. Language divides the RAM into
    two parts called run-time stack and the heap. Memory is divided into two parts
    in any programming language:'
  prefs: []
  type: TYPE_NORMAL
- en: Stack or run-time stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The heap is a specific area of RAM where all values (objects) are stored. The
    run-time stack never contains the object. The run-time stack store only references
    pointing toward the values stored in the heap. Let''s try to understand with an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: During execution of lines 5, 6, and 7 of the code, the run-time stack looks
    as shown in the next figure. There are three activation records present on run-time
    stack. The interpreter first puts the **module Activation Record**. While executing
    the module, the interpreter goes from top to bottom and places the variable definition
    of the module scope into the activation record of the module. The activation record
    of the module consists of the reference **k** to the value **4**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Stackheap.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about functions and how to define a function. Then
    we discussed various types of functions such as built-in and user-defined functions.
    We saw various examples of user-defined functions, where we explained functions
    with no arguments and no return type, functions with arguments, functions with
    arguments and return type, functions with default arguments, and functions with
    variable length arguments. We also learned about key-value pairs being passed
    as a variable length argument to the function. We came across the scope of the
    variable and, finally, we examined the basic concepts of memory management where
    we learned about two types of memory, namely, stack and heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter we will learn about quite an interesting topic: collections.'
  prefs: []
  type: TYPE_NORMAL
