<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
<meta charset="utf-8"/>
<meta name="generator" content="packt"/>
<title>7 Dealing with Security Concerns</title>
<link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css"/>
<link rel="stylesheet" type="text/css" href="../styles/stylesheet2.css"/>

</head>
<body>
<section id="dealing-with-security-concerns" class="level1 pkt" data-number="8">
<h1 data-number="8">7 Dealing with Security Concerns</h1>
<p>When building a web application, it might be very tempting to sit down, plan out your functionality, build it, test it, and only then come back to think about security. For example, when building a single-page application, you might not even consider CORS until the first time you see this message in the browser while testing:</p>
<pre><code>Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite.</code></pre>
<p>To a large extent, this is how we have been building in this book. We see a feature and build it. Anytime we have run up against a potential security issue in this book, we have pushed it off to a later date. We finally are at this point where we will learn how to deal with security issues in Sanic. The topic of web security is, of course, extremely broad, and it is beyond the scope of this book to be an exhaustive study.</p>
<p>Instead, in this chapter we will explore:</p>
<ul>
<li>Setting up an effective CORS policy</li>
<li>Protecting applications from CSRF</li>
<li>Protecting your Sanic app with authentication</li>
</ul>
<p>In particular, we want to gain a basic understanding of the security issues so we can build Sanic solutions to solve them. The bigger takeaway from this Chapter will be to make you feel comfortable enough with these topics that they do not become the after-thought. When these issues are broken down, we can see that building them into application design from the beginning will make them more effective and less burdensome to implement.</p>
<section id="technical-requirements-6" class="level2" data-number="8.1">
<h2 data-number="8.1">Technical requirements</h2>
<p>The requirements for this chapter will again build upon what we have been using in previous chapters. Since web security often includes the interaction between frontend Javascript applications and backend Python applications, we may see some examples that use Javascript that is widely available in major web browsers. You can find all of the source code for this chapter at: <a href="https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/07">https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/07</a>.</p>
<p>In addition, we are going to use three common (and battle tested) security libraries: <code>cryptography</code>, <code>bcrypt</code>, and <code>pyjwt</code>. If you do not already have them installed in your virtual environment, you can add them now:</p>
<pre><code>$ pip install cryptography bcrypt pyjwt</code></pre>
</section>
<section id="setting-up-an-effective-cors-policy" class="level2" data-number="8.2">
<h2 data-number="8.2">Setting up an effective CORS policy</h2>
<p>If you are building a web application where the server exclusively responds to requests on a single computer, and that computer is physically disconnected from the Internet, perhaps this section is not as relevant to you. For anyone else, pay attention! To be clear, you are part of “anyone else”. This is important stuff.</p>
<p>In simple terms, <strong>cross-origin resource sharing (CORS)</strong> is a fancy way of saying <em>accessing one domain from another domain with a browser</em>. Without an effective strategy for handling this, your application could open up a security risk for your users.</p>
<section id="what-is-the-security-issue-with-ineffective-cors" class="level3" data-number="8.2.1">
<h3 data-number="8.2.1">What is the security issue with ineffective CORS?</h3>
<p>The modern web uses a lot of Javascript in web browsers. It, of course, enables all kinds of interactive and quality user experiences. One of those capabilities is to issue requests for data on behalf of the user without them knowing about it. This feature is one of the biggest differentiators between web applications today and web applications from the late ’90s. Requesting data while the user is on a website is what makes web pages feel like applications. That is to say that it makes them interactive and engaging.</p>
<p>So imagine that you have a hypothetical application that appears to the user as: <code>https://superawesomecatvideos.com</code>. It is a super successful website, and lots of people like to come to visit it to see their favorite car videos. If it starts requesting information in the background (because of a hacker attack, or otherwise) from <code>https://mybank.com</code>, well, we of course do not want to allow that to succeed. There is no reason that the Super Awesome Cat Videos website should be able to access anything from My Bank, especially if I have an authenticated web session at My Bank’s website.</p>
<p>For this reason, web browsers will not allow this by default because of the <strong>same-origin policy</strong>. This means that web applications may only interact with resources that are of the same-origin. An origin is comprised of:</p>
<ul>
<li>The HTTP scheme</li>
<li>The domain</li>
<li>The port</li>
</ul>
<p>Let’s look at some examples of URLs that are and are not considered to be same-origin:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>URL A</strong></td>
<td><strong>URL B</strong></td>
<td><strong>Same-origin?</strong></td>
</tr>
<tr class="even">
<td><a href="http://sacv.com"><code>http://sacv.com</code></a></td>
<td><a href="http://sacv.com"><code>http://sacv.com</code></a></td>
<td>Yes</td>
</tr>
<tr class="odd">
<td><a href="http://sacv.com"><code>http://sacv.com</code></a></td>
<td><a href="http://sacv.com"><code>http://sacv.com</code></a> <code>/about</code></td>
<td>Yes, path does not matter</td>
</tr>
<tr class="even">
<td><a href="http://sacv.com"><code>http://sacv.com</code></a></td>
<td><a href="https://sacv.com"><code>https://sacv.com</code></a></td>
<td>No, different HTTP schemes</td>
</tr>
<tr class="odd">
<td><a href="http://sacv.com"><code>http://sacv.com</code></a></td>
<td><a href="http://sacv.com"><code>http://sacv.com</code></a> <code>:8080</code></td>
<td>NO, different ports</td>
</tr>
<tr class="even">
<td><a href="http://sacv.com"><code>http://sacv.com</code></a></td>
<td><a href="http://api.sacv.com"><code>http://api.sacv.com</code></a></td>
<td>No, different domains</td>
</tr>
</tbody>
</table>
Table 7.1 - Comparison of URLs and their same-origin status
<p>We’ll assume that our Super Awesome Cat Video website also has the domain: sacv.com. For example, if <code>https://superawesomecatvideos.com</code> wants to load: <code>https://superawesomecatvideos.com/catvid1234.mp4</code>, that is fine. When the only difference is the path or resource being loaded, the URLs are considered same-origin. In our example, both URLs contain the same HTTP scheme, domain, and port designation. But, when the same website <a href="https://superawesomecatvideos">https://superawesomecatvideos</a> tries to fetch data from <code>https://api.superawesomecatvideos.com/videos</code>, uh oh, error time. These are the sorts of potential attack vectors that the same-origin policy is meant to protect from. So, the question becomes: how can we allow legitimate cross-origin requests, without allowing <em>all</em> cross-origin requests? The answer is that we essentially need to create a whitelist and let the browser know which origins our server will accept requests from.</p>
<p>Let’s build a super simple example that will show us the problem. We are going to build two webservers here. One will be a stand-in for the frontend application, and the other will be the backend meant to feed data to the frontend.</p>
<p>We begin by building and running a simple API endpoint that looks no different than anything we have seen before. Stand up the application using the same method we have already used. Here is what your endpoint can look like:</p>
<pre><code>@app.get(&quot;/&lt;name&gt;&quot;)
async def handler(request, name):
    return text(f&quot;Hi {name}&quot;)</code></pre>
<p>You should now have a Sanic server running on port <code>7777</code> using what we have already learned. You can test it out by accessing: <code>http://localhost:7777/Adam</code>.</p>
<ol>
<li><p>Create a directory somewhere and add this file called <code>index.html</code> to it. For my example it will be <code>/path/to/directory</code>:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
        &lt;title&gt;CORS issue&lt;/title&gt;
    &lt;body&gt;
        &lt;h1&gt;Loading...&lt;/h1&gt;
        &lt;script&gt;
            const element = document.querySelector(&quot;h1&quot;)
            fetch(&quot;http://localhost:7777/Adam&quot;)
            .then(async response =&gt; {
                const text = await response.text()
                element.innerHTML = text
            })
        &lt;/script&gt;
    &lt;/body&gt;</code></pre>
<p>As you can see, this application will run a background request to our application that is running on <code>http://localhost:7777</code>. After it gets the content, it will dump it on the screen in place of the <code>Loading ...</code> text.</p></li>
<li><p>To run this application, we are going to use a neat little trick that Sanic includes called “<em>Sanic Simple Server</em>”. Instead of building a Sanic application, we will point the Sanic CLI at a directory and it will serve that for us as a website:</p>
<pre><code>$ sanic -s /path/to/directory</code></pre>
<blockquote>
<p><strong>Tip</strong></p>
<p>This is a super helpful tool to keep in your back pocket, even when not building a Sanic application. In the course of development, I often find a need to quickly standup a web application to view static content in a browser. This could be useful when building an application that uses only static content, or when building a Javascript application and you need a development server.</p>
</blockquote></li>
<li>Open up a web browser and go to this application that should be running at <a href="http://localhost:8000">http://localhost:8000</a>. You should see something like this:</li>
</ol>
<figure>
<img src="../media/file8.png" alt="Figure 3.1 - Screenshot of the web application with CORS issue" /><figcaption aria-hidden="true">Figure 3.1 - Screenshot of the web application with CORS issue</figcaption>
</figure>
<p>Uh oh, something went wrong. Our application is throwing an error:</p>
<pre><code>Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at http://localhost:7777/Adam. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing).</code></pre>
<p>For most of us getting into web development, this experience would be our first with CORS. What on Earth does this mean? What is a “<em>Cross-Origin Request</em>”, and why is it blocked? What is a CORS header? And, most importantly, how do I make this go away?! This last question is the one that bothers me. We are not going to “<em>make it go away</em>”, we are going to understand what this means, why the browser decided to throw up a road block, and then move on to creating a solution.</p>
<p>The naive web developer upon seeing this error will immediately go online to search how to deal with this, find a mess of partial or way-too-in-depth information, and then move on without ever understanding the actual issue. Making it go away will get you back to developing since the error is no longer blocking your progress, but it will not solve the problem. In fact, you just created a new one. To become a better developer, we are not going to just implement an off-the-shelf solution without understanding it. Instead we will pause to learn what is happening and why. Maybe you have come up against this issue yourself, if not, you surely will at some point. Whether you have or have not “solved” this problem in the past, we are going to take some time to learn the rationale behind this error before coming up with an appropriate—or rather, <em>obvious</em>—solution. Once you peel back the layers of CORS, you will see that it starts to make a lot of sense and can become simple to master.</p>
<p>I was one such naive person that searched this error, clicked the first link, copied and pasted a solution that made the error go away, and then moved on with life not giving it another thought. The browser no longer complained: problem solved. At least that is what I thought. I did not think about the consequences of my action and the security hole I had introduced. What was that security hole masquerading as a fix? The solution I found was to add a simple header, and I gave it no further thought: <code>Access-Control-Allow-Origin: *</code>. <em>DO NOT DO THIS!</em> I did not know any better and I moved on never thinking twice about CORS, except that it was the pesky thing in browsers that seemed to cause me problems.</p>
<p>The issue here is that the frontend application is trying to access details from another origin: hence <em>cross origin</em>. When I added that header, I was effectively disabling the same-origin protection that the browser was creating. The <code>*</code> means: <em>allow this application to request any cross origin information it wants</em>.</p>
<p>My browser had created a castle for protection. Rather than learn about how to effectively handle CORS, I decided to drop the drawbridge, open all of the gates, and send the guards home to their beds.</p>
<p>What should I have done? Let’s find out.</p>
<section id="developing-a-strategy-for-effectively-dealing-with-cors" class="level4" data-number="8.2.1.1">
<h4 data-number="8.2.1.1">Developing a strategy for effectively dealing with CORS</h4>
<p>Obviously, my strategy to completely disable the browser defenses was not the best approach. It was the easy way out, the lazy way out, and the irresponsible way out. What I should have done is go to a resource like the one that Mozilla provides and read up on the issue: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</a>. If I did, then this would have caught my attention:</p>
<p><em>Who should read this article?</em></p>
<p><em>Everyone, really.</em></p>
<p>Oh, <em>everyone</em> should read it? If you have not read it, you have the opportunity now to take a different path than me, and to go read it now. I am not kidding. Please do yourself a favor: put a bookmark in this book and go read that webpage. Then come back here. I promise we will wait for you. It is written in fairly simple terms to understand and is an authoritative resource to keep in your back pocket.</p>
<p>According to the official HTTP specification, the <code>OPTIONS </code>method <em>allows a client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action</em> (<a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.7">https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.7</a>). In other words, it gives an HTTP client the ability to check what an endpoint might require from it before sending an actual request. If you have ever built a browser-based web application, or if you intend to, this method is extremely important. Therefore, as we dive into what the CORS headers are, we will also revisit and heavily make use of our <code>OPTIONS </code>handler from back in <em>Chapter 3</em>, <em>Routing and intaking HTTP requests</em>. Take a flip back to that section to reacquaint yourself with how we will automatically attach <code>OPTIONS </code>handlers for all of our routes.</p>
<section id="understanding-cors-headers" class="level5" data-number="8.2.1.1.1">
<h5 data-number="8.2.1.1.1">Understanding CORS headers</h5>
<p>Solving these cross origin access issues is accomplished through the application of response headers. Therefore, we will need to learn what some of these headers are and when they should be applied and used. Our job in this section will be to build HTTP responses with some basic CORS headers that we can use in our applications. We, of course, could take the easy way out and install one of the third-party packages on PyPI that will automatically add the headers for us.</p>
<p>In actuality, I do suggest that you do this for a production application. CORS issues can be complex, and implementing a <em>trusted</em> solution should bring some level of comfort and peace of mind. However, relying upon one of these packages without knowing the basics is only slightly better than my first solution of disabling the same-origin policy completely.</p>
<p>Here are some of the common CORS response headers we should know about:</p>
<ul>
<li><strong>Access-Control-Allow-Origin</strong>: This is used by the server to tell the client which origins it will and will not accept cross-origin requests from;</li>
<li><strong>Access-Control-Expose-Headers</strong>: This is used by the server to tell the browser which HTTP headers it can allow Javascript to access safely (meaning it does not contain sensitive data);</li>
<li><strong>Access-Control-Max-Age</strong>: This is used by the server to tell the client how long it could cache the results of a <strong>preflight request</strong> (see the next section to learn what a preflight request is);</li>
<li><strong>Access-Control-Allow-Credentials</strong>: This is used by the server to tell the client whether it can or cannot include credentials when sending in requests;</li>
<li><strong>Access-Control-Allow-Methods</strong>: This is used by the server in preflight requests to tell the client what HTTP methods it will accept on a given endpoint;</li>
<li><strong>Access-Control-Allow-Headers</strong>: This is used by the server in preflight requests to tell the client which HTTP headers it will allow it to add.</li>
</ul>
</section>
<section id="understanding-preflight-requests" class="level5" data-number="8.2.1.1.2">
<h5 data-number="8.2.1.1.2">Understanding preflight requests</h5>
<p>In certain scenarios, before a browser tries to access a cross-origin <em>something</em>, it will issue what is known as a <strong>preflight request</strong>. This is a request to the same domain and endpoint as the intended resource that happens before the actual call, except with an <code>OPTIONS </code>HTTP method. The goal of this request is to get access to the CORS headers to learn what the server will and will not allow. If the browser determines that the response is not “safe”, it will not allow it.</p>
<p>When will a browser decide to issue a preflight request? Mozilla provides a great overview on their CORS page (<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests</a>). In summary, a preflight request will <em>not</em> be issued by the browser when:</p>
<p>It is a <code>GET</code>, <code>HEAD</code>, or <code>POST</code></p>
<p>Does not contain any manually set headers, except for <code>Accept</code>, <code>Accept-Language</code>, <code>Content-Language</code>, or <code>Content-Type</code></p>
<p>The request headers include <code>Content-Type</code>, and it is set to one of <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, or <code>text/plain</code></p>
<p>There are no Javascript event listeners on the request</p>
<p>The response is not going to be streamed by the client</p>
<p>These requests are generally meant to cover the scenarios encountered by <em>normal</em> web traffic: navigating to a page, submitting an HTML form, and basic AJAX requests. As soon as your application starts adding in functionality that is typical of most single-page web applications, you will begin to notice your browser issuing preflight requests. In this context, the two most common types of requests that trigger preflight are:</p>
<p>JS applications that inject custom headers (<code>Authorization</code>, <code>X-XSRF-Token</code>, <code>Foobar</code>, etc)</p>
<p>JS applications that submit JSON data using <code>Content-Type</code>: <code>application/json</code></p>
<p>You may be wondering: why does this matter? It is important to understand this so that we know when we need to respond with each of the six CORS response headers we saw in the last section.</p>
</section>
</section>
<section id="solving-for-cors-with-sanic" class="level4" data-number="8.2.1.2">
<h4 data-number="8.2.1.2">Solving for CORS with Sanic</h4>
<p>Up until this point, we have entirely avoided the usage of any third-party plugins. That is, to say that we have steered away from any implementation that would require us to <code>pip install </code>a solution. This has been a conscious decision so that we learn the principles needed to build our web applications before we just outsource the solution to someone else. While this is still valid here and is the reason we are about to handle CORS requests by hand, it is also important to point out that this is a problem that has been solved already. The officially supported <code>sanic-ext </code>package and the community-supported <code>sanic-cors </code>package are both reputable options for implementing CORS protection.</p>
<p>With that said, let’s think about each of the six (6) response headers and <em>when</em> and how we will need to implement them. We have some headers we want to add regardless of the type of request, and some that will <code>only </code>be added on preflight requests. We will need a standard and repeatable method for adding response headers in these two scenarios. What is our go-to strategy for that? Middleware.</p>
<p>Let’s start with this basic middleware and add code to it:</p>
<pre><code>def is_preflight(request: Request):
    return (
        request.method == &quot;OPTIONS&quot;
        and &quot;access-control-request-method&quot; in request.headers
    )
@app.on_response
async def add_cors_headers(request: Request, response: HTTPResponse) -&gt; None:
    # Add headers here on all requests
    if is_preflight(request):
        # Add headers here for preflight requests
        ...</code></pre>
<p>We are doing two things to determine that a request is indeed a preflight request:</p>
<ol>
<li>First, we know that the browser will always issue it as an <code>OPTIONS</code> request</li>
<li>Second, the browser will always attach a request header called <code>Access-Control-Request-Method</code> with the value of the type of HTTP request that it is about to send</li>
</ol>
<p>To simulate a preflight request, we will use the following curl request that adds the two headers we need to trigger the preflight request response (the <code>Origin </code>header and the <code>Access-Control-Request-Method</code> header):</p>
<pre><code>$ curl localhost:7777 -X OPTIONS -H &quot;Origin: http://mysite.com&quot; -H &quot;Access-Control-Request-Method: GET&quot; -i</code></pre>
<p>The last thing we need is some ability for adding <code>OPTIONS</code> as a viable HTTP method for every existing route in our application. This is something that <code>sanic-ext</code> adds, and we will learn an easy way to accomplish this in <em>Chapter 11</em>, <em>A complete real-world example</em>, using that package. But first, you might recall that this is something that we built way back in <em>Chapter 3</em>, <em>Routing and intaking HTTP requests</em>. We will reuse the code that looped through all of our defined routes and added an <code>OPTIONS</code> endpoint. You can find it in that chapter in the <em>Blanket support for OPTIONS and HEAD</em> section.</p>
<p>With this established, we will look at each response header to understand them more completely.</p>
<section id="access-control-allow-origin" class="level5" data-number="8.2.1.2.1">
<h5 data-number="8.2.1.2.1">Access-Control-Allow-Origin</h5>
<p>This header alone is arguably the most important one to add. It is also the one that is most tempting to be the nuclear option and just disable CORS protection completely as discussed earlier. Unless you have a specific reason to accept requests from any browser origin, you should avoid <code>*</code>.</p>
<p>The value should, instead, be the address that you anticipate requests coming from. You should <em>NOT</em> just recycle the incoming request’s <code>Origin </code>header and apply that. This is effectively the same as <code>*</code>. Instead, it is a good practice to have a predefined list of allowed origins and cross-reference the incoming <code>Origin </code>with those. If there is not a match, simply do not add any CORS headers.</p>
<p>Here is the first snippet we will add to our middleware to do that:</p>
<pre><code>origin = request.headers.get(&quot;origin&quot;)
if not origin or origin not in request.app.config.ALLOWED_ORIGINS:
    return
response.headers[&quot;access-control-allow-origin&quot;] = origin</code></pre>
<p>Make sure that you set the configuration <code>ALLOWED_ORIGINS</code> value as well. This could be done wherever you create your app instance.</p>
<pre><code>app = Sanic(__name__)
app.config.ALLOWED_ORIGINS = [&quot;http://mysite.com&quot;]</code></pre>
<p>As you can see, we will add this to all responses that are coming from the browser. How do we know it is a browser request? Because we can expect that browsers will add the <code>Origin </code>header.</p>
</section>
<section id="access-control-expose-headers" class="level5" data-number="8.2.1.2.2">
<h5 data-number="8.2.1.2.2">Access-Control-Expose-Headers</h5>
<p>The <code>Access-Control-Expose-Headers</code> header provides the server with the ability to control which headers are exposed to Javascript access. It is a security measure to provide a whitelist control of what information is available to the in-browser application.</p>
<p>Let’s start adding some tests into the browser. For these examples, we will use a similar basic HTML structure as before.</p>
<ol>
<li><p>We start by setting up our HTML. The goal here is to read the header <code>foobar</code> in Javascript and output it on the screen:</p>
<pre><code>&lt;body&gt;
    &lt;h1&gt;CORS Testing&lt;/h1&gt;
    &lt;h2 id=&quot;foobar&quot;&gt;Loading...&lt;/h2&gt;
    &lt;script&gt;
        const element = document.querySelector(&quot;#foobar&quot;)
        fetch(&quot;http://localhost:7777/&quot;).then(async response =&gt; {
            const text = await response.text()
            element.innerHTML = `foobar=&#39;${response.headers.get(&quot;foobar&quot;)}&#39;`
        })
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<p>We need to set up our application to see the HTML and add the header:</p>
<pre><code>@app.get(&quot;/&quot;)
async def handler(request):
    response = text(&quot;Hi&quot;)
    response.headers[&quot;foobar&quot;] = &quot;hello, 123&quot;
    return response
app.static(&quot;/test&quot;, &quot;./test.html&quot;)</code></pre></li>
<li><p>To verify our curiosity, we will double-check the response with <code>curl</code> to make sure the header is actually being sent:</p>
<pre><code>$ curl localhost:7777 -i
HTTP/1.1 200 OK
foobar: hello, 123
content-length: 2
connection: keep-alive
content-type: text/plain; charset=utf-8
Hi</code></pre></li>
<li><p>Now, open your browser to <code>http://127.0.0.1:7777/test</code>. You should see:</p>
<pre><code>CORS Testing
foobar=‘null’</code></pre>
<p>What happened is that the browser was blocked from accessing the header. If we want to allow it, then we need to be explicit.</p></li>
<li><p>Therefore, heading back to the <code>add_cors_headers</code> middleware that we were building, let’s add the following snippet:</p>
<pre><code>response.headers[&quot;access-control-expose-headers&quot;] = &quot;foobar&quot;</code></pre>
<p>Do not forget that since we are actually testing this on a browser, we need to set the <code>ALLOWED_ORIGINS</code> configuration value appropriately:</p>
<pre><code>app.config.ALLOWED_ORIGINS = [&quot;http://mysite.com&quot;, &quot;http://127.0.0.1:7777&quot;]</code></pre>
<p>This time when you access the browser, you should see that the Javascript was able to reach in and get the value from the <code>Foobar </code>header:</p>
<pre><code>CORS Testing
foobar=‘hello, 123’</code></pre></li>
</ol>
<p>Therefore, if you intend to use any sort of meta-data on the client-side of your application, you will need to properly use <code>access-control-expose-headers</code>.</p>
</section>
<section id="access-control-max-age" class="level5" data-number="8.2.1.2.3">
<h5 data-number="8.2.1.2.3">Access-Control-Max-Age</h5>
<p>When a browser <em>does</em> issue a preflight request, it has the ability to cache that response so that the next time it makes the same request it does not need to hit the server. This performance improvement can be controlled (to some extent) by the server using the <code>Access-Control-Max-Age</code>, which specifies the length of time (in seconds) that the preflight request can be cached.</p>
<p>Typically, web browsers will set a maximum value for this. If you tried to set it to some absurdly large number, they will drop it down to their predefined maximum value. For this reason, I usually recommend going with a value that is around 10 minutes. Some browsers will allow you to go up to 24 hours, but that is probably about the maximum allowed.</p>
<p>We will see this now in our middleware:</p>
<pre><code>response.headers[&quot;access-control-max-age&quot;] = 60 * 10</code></pre>
</section>
<section id="access-control-allow-credentials" class="level5" data-number="8.2.1.2.4">
<h5 data-number="8.2.1.2.4">Access-Control-Allow-Credentials</h5>
<p>This header is for preflight requests only. So, the snippet we will add here needs to go inside our <code>is_preflight(request)</code> block.</p>
<p>When a Javascript application makes a request, it must <em>explicitly</em> make the call allowing for credentials to be sent. If not, then the browser will not include them in the request. The server can then play its part to tell the browser that this request that includes credentials is—or is not—safe to expose to the Javascript application.</p>
<p>To allow it, we set the header like this:</p>
<pre><code>response.headers[&quot;access-control-allow-credentials&quot;] = &quot;true&quot;</code></pre>
</section>
<section id="access-control-allow-methods" class="level5" data-number="8.2.1.2.5">
<h5 data-number="8.2.1.2.5">Access-Control-Allow-Methods</h5>
<p>Up until this point, there really has not been a need for any plugins. Adding these CORS headers has been fairly straightforward. The next part, however, is something that could become a little more tricky.</p>
<p>The <code>Access-Control-Allow-Methods </code>header is meant to be a warning to the browser during the preflight request about what HTTP methods the browser is allowed to send to the endpoint cross-origin. A lot of applications disable this protection by allowing everything:</p>
<pre><code>response.headers[
    &quot;access-control-allow-methods&quot;
] = &quot;get,post,delete,head,patch,put,options&quot;</code></pre>
<p>This certainly is a simple solution. It is less harmful than that first CORS solution I came across that allowed any origin. But, we can still do better.</p>
<p>To accomplish the ability to have dynamic methods that match the <em>actual</em> endpoint possibilities, we are going to change some things around in our code.</p>
<ol>
<li><p>Remember how we are defining a request as preflight? Let’s do that up front in the request middleware.</p>
<pre><code>@app.on_request
async def check_preflight(request: Request) -&gt; None:
    request.ctx.preflight = is_preflight(request)</code></pre></li>
<li><p>Next, when we generate the handlers for <code>OPTIONS </code>requests, we will inject a list of all of the allowed methods like this:</p>
<pre><code>from functools import partial
@app.before_server_start
def add_info_handlers(app: Sanic, _):
    app.router.reset()
    for group in app.router.groups.values():
        if &quot;OPTIONS&quot; not in group.methods:
            app.add_route(
                handler=partial(
                    options_handler,
                    methods=group.methods
                ),
                uri=group.uri,
                methods=[&quot;OPTIONS&quot;],
                strict_slashes=group.strict,
                name=&quot;options_handler&quot;,
            )
    app.router.finalize()</code></pre></li>
<li><p>Now that we have access to the preflight check in our options handler, we can do our check and add the headers there. We also can take the list of methods that were passed in and concatenate them into a comma-delimited list. This should now provide an automated set of <code>OPTIONS </code>endpoints with exactly the HTTP methods that will be used.</p>
<pre><code>async def options_handler(request, methods):
    resp = response.empty()
    if request.ctx.preflight:
        response.headers[&quot;access-control-allow-credentials&quot;] = &quot;true&quot;
        resp.headers[&quot;access-control-allow-methods&quot;] = &quot;,&quot;.join(methods)
    return resp</code></pre></li>
<li><p>We will look at the preflight response using curl to see all of our headers:</p>
<pre><code>$ curl localhost:7777 -X OPTIONS -H &quot;Origin: http://mysite.com&quot; -H &quot;Access-Control-Request-Method: GET&quot; -i    
HTTP/1.1 204 No Content
access-control-allow-credentials: true
access-control-allow-methods: GET,PATCH,POST
vary: origin
access-control-allow-origin: http://mysite.com
access-control-expose-headers: foobar
connection: keep-alive</code></pre></li>
</ol>
</section>
<section id="access-control-request-headers" class="level5" data-number="8.2.1.2.6">
<h5 data-number="8.2.1.2.6">Access-Control-Request-Headers</h5>
<p>The final header we are concerned with here is <code>Access-Control-Request-Headers</code>, and is also one that should be sent in preflight responses. It is an indication to the browser which non-standard headers can be sent in the cross-origin request.</p>
<p>If the Javascript wanted to send a header called <em>counting</em>, then it would do this:</p>
<pre><code>fetch(&quot;http://localhost:7777/&quot;, {
    headers: {counting: &quot;1 2 3&quot;}
})</code></pre>
<p>However, because this would trigger a preflight request, the browser will fail with a CORS error because the server has not explicitly allowed counting as an acceptable header.</p>
<p>To do that, we enable it in our preflight block:</p>
<pre><code>resp.headers[&quot;access-control-allow-headers&quot;] = &quot;counting&quot;</code></pre>
<p>Our review of CORS headers has added a lot of code. To see the completed version, please checkout the GitHub repository: <a href="https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/07/corsissue">https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/07/corsissue</a>. Now that we have completed our CORS review, we are onto the next topic that is similarly related: CSRF</p>
</section>
</section>
</section>
</section>
<section id="protecting-applications-from-csrf" class="level2" data-number="8.3">
<h2 data-number="8.3">Protecting applications from CSRF</h2>
<p>The next step in our journey is handling cross-site request forgery (CSRF). It should also be noted that this often also carries the acronym XSRF. If you see these two on the web, they refer to the same issue. So, what is the issue?</p>
<p>You know that suspiciously awkward email that you received that says “click here to claim your $500 prize”? Likely that link brings you to a malicious website controlled by someone that is trying to hack you. They may have placed some links or caused you to do something on their site that sends off a background request to a legitimate website to do something bad. If your application is not protected from CSRF attacks like this, it could be possible for that bad actor to induce your users to changing their passwords without them even knowing it!</p>
<p>Thwarting these attacks can be done on both sides. Your users could, of course, take better care not to open their email in the Spam box. But you, as a responsible web application developer, also have a responsibility to protect your users.</p>
<section id="solutions-that-do-not-work" class="level3" data-number="8.3.1">
<h3 data-number="8.3.1">Solutions that do not work</h3>
<p>Cookies. You may be surprised if you skipped ahead to peak at the solution that I offer you will see that it does include cookies. Indeed, cookies can play a part in solving the problem. However, they are a flawed security measure and <em>cannot</em> be the answer to the CSRF problem by themselves.</p>
<p>How would this even work? Imagine that you set a session ID in a cookie. It is a decently good mixture of random characters so that it would be impractical for someone to guess it correctly. The problem is that cookies are sent with every request based not upon where the request is initiated, but where it is headed. So, if your browser sees that it has a cookie in storage for <code>yourapplication.com</code>, then even if the request was initiated at <code>h4ck3rsp4r4d1se.com</code>, the browser would send the cookies.</p>
<p>It also should be noted that introducing TLS and reading the Origin header are not sufficient solutions either. Of course, these are useful and valid things your application should be done, but alone they do not add protection from CSRF. The <code>Origin</code> header, for example, could easily be spoofed.</p>
</section>
<section id="solutions-that-do-work" class="level3" data-number="8.3.2">
<h3 data-number="8.3.2">Solutions that do work</h3>
<p>Now that we know what will not protect us from CSRF attacks, we can look into a few solutions that will work and help protect our web applications. These are not mutually exclusive, and I suggest you consider implementing them all in one form or another. Your decision will be contextual, of course, but here are some good practices to keep in mind while protecting your application from CSRF attacks.</p>
<section id="do-not-change-state-on-get" class="level4" data-number="8.3.2.1">
<h4 data-number="8.3.2.1">Do not change state on <code>GET</code></h4>
<p>This is incredibly important. We discussed the issue back in <em>Chapter 3</em>, but <code>GET</code> requests should not be state-changing. That means that the application should not take any direction from a <code>GET </code>request to go do something. These should be for information only. By removing <code>GET </code>from the hackers’ arsenal, we are forcing them into using Javascript exploits on their malicious websites.</p>
<p>The reason that we want to allow this is because the browser has some built-in security measures we know about and can use to our advantage. First, from within the browser, the Origin header cannot be spoofed.</p>
<p>Let’s say our bad website had this code in it:</p>
<pre><code>fetch(&quot;http://localhost:7777/&quot;, {
    headers: {origin: &quot;http://localhost:7777&quot;}
})</code></pre>
<p>If you went to <code>somebadwebsite.com</code>, the origin would still be <code>http://somebadwebsite.com</code>. That is why CORS protection works. By disallowing stateful changes from <code>GET </code>requests, we make it so that a hack like this will not work:</p>
<pre><code>&lt;img src=&quot;http://yourapplication.com/changepassword?password=kittens123&quot;&gt;</code></pre>
<p>Forcing the hacker into Javascript—especially Javascript requests that are forced into issuing preflight requests—gives us some more control as we are about to see.</p>
</section>
<section id="cookies" class="level4" data-number="8.3.2.2">
<h4 data-number="8.3.2.2">Cookies</h4>
<p>The next helpful solution involves cookies.</p>
<p>Wait? Cookies were in the <em>do not work</em> solution category, what gives?</p>
<p>We just said that we want to force malicious attackers to use Javascript in their exploits. This is because we also know that browser cookies have a feature that we can control: <code>HttpOnly</code>. When a server creates a cookie, it can decide whether or not Javascript should be able to access that cookie. This means that the cookie will continue to be sent on every web request when enabled, but it will be inaccessible to any Javascript code. This makes it an ideal location for storing secure credentials like session tokens. Absent this, cookies are subject to what is known as Cross-Site Scripting attacks (aka “XSS”). This is an attack where some hacker is able to extract secure details from a frontend browser using Javascript.</p>
<blockquote>
<p><strong>Important Note</strong></p>
<p>If your browser application can access some piece of information with Javascript, so can a hacker.</p>
</blockquote>
<p>We also mentioned that there was a problem that cookies for <code>yourapplication.com</code> can still be sent unknowingly from <code>h4ck3rsp4r4d1se.com</code>. Since Javascript ,when it is allowed to access cookie,s can only do so on the current domain, we have another tool in our belt we can use while building our solution.</p>
<p>When a user logs in, if we set two cookies (one for the session and one for the CSRF protection) we can set the <code>HttpOnly </code>value based upon the intended usage. The session cookie remains inaccessible, and the cookie that is set aside for CSRF protection could be Javascript accessible. We then could require that the Javscript uses that cookie’s value when sending in a request. This will work because the Javascript that is running on <code>h4ck3rsp4r4d1se.com</code> will not be able to access cookies that are marked for another domain.</p>
<p>What should the value of this cookie be? Well, really anything that could be impossible to guess. It is best to keep that value user specific so that you are able to verify its contents and be assured that the token is authentic. Also, the value should change and not be static. This will help make it more difficult for any would-be attackers. This dual cookie method is not 100% fault-proof. But it should be reasonably secure for most applications' needs. The problem comes when your users start accidentally downloading malware that is capable of circumventing the browser protections. We’ll leave that issue aside as it is an issue outside our ability to control, and a much more in-depth conversation beyond the scope of this book.</p>
<p>It should be noted that we do not necessarily care that the CSRF token could be compromised and used by a bad actor. That is fine. Because even if they could access it, they have no way to then send with both: the correct origin, and the correct session token.</p>
</section>
<section id="form-fields" class="level4" data-number="8.3.2.3">
<h4 data-number="8.3.2.3">Form fields</h4>
<p>There is another form of CSRF protection that other frameworks use. For example, Django made popular the idea of injecting some hidden HTML onto the page:</p>
<pre><code>&lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;SOMETOKEN&quot; /&gt;</code></pre>
<p>This value would then be included in form responses, or read into the request in some expected way. This is essentially the exact same idea that I am proposing here. The only difference is that instead of injecting the value into a hidden—although Javascript accessible location—input, we are storing it in a cookie. Both solutions will ultimately depend upon what happens in the next section when that value is sent back to the server.</p>
</section>
<section id="putting-a-solution-into-practice" class="level4" data-number="8.3.2.4">
<h4 data-number="8.3.2.4">Putting a solution into practice</h4>
<p>Now that we have a general idea of our approach let’s recap to be clear. We want to allow stateful changes in our application to authenticated users only. To achieve confidence that the changes are coming from our users and not hackers, we will allow the change when:</p>
<ul>
<li>The HTTP method is <code>POST</code>, <code>PATCH</code>, <code>PUT</code>, or <code>DELETE</code></li>
<li>The origin of the incoming request matches what we would expect</li>
<li>The incoming request has a cookie that was stored with <code>HttpOnly</code></li>
<li>The incoming request has a valid CSRF token</li>
</ul>
<p>To accomplish our goal, we need to decide where we will put our code that is going to accomplish this goal. We, therefore, come back to the debate we have seen a few times already: decorators or middleware. There is not a correct choice, and the answer will, of course, depend upon what you are building.</p>
<p>For our example, we will build it as a decorator. When we come to authentication in the next section, it will become more clear why we are using the decorator pattern here. If you think middleware works for you, go ahead and try to rebuild this as middleware. Both options are legitimate patterns and may serve your needs in different circumstances. To be honest, however, I usually find the decorator pattern to be more easily adoptable with a broader set of use cases. Here are the steps:</p>
<ol>
<li><p>To start, we will make a barebones decorator. To make the job easier, you can grab a decorator template from the Sanic User Guide: <a href="https://sanicframework.org/en/guide/best-practices/decorators.html#templates">https://sanicframework.org/en/guide/best-practices/decorators.html#templates</a>.</p>
<pre><code>def csrf_protected(func):
    def decorator(f):
        @wraps(f)
        async def decorated_function(request, *args, **kwargs):
            response = f(request, *args, **kwargs)
            if isawaitable(response):
                response = await response
            return response
        return decorated_function
    return decorator(func)</code></pre>
<p>When there is a CSRF failure, the correct response should be a <code>403 Forbidden</code>. We will make a custom exception that we can raise whenever this happens:</p>
<pre><code>from sanic.exceptions import Forbidden
class CSRFFailure(Forbidden):
    message = &quot;CSRF Failure. Missing or invalid CSRF token.&quot;</code></pre></li>
<li><p>Thinking about our goals and our requirements, we want to somehow determine that the request is coming from a browser. This is because a browser request will be subject to CSRF protection. There is no need to implement it on direct access API requests. Personally, I like to do this by adding a <code>HttpOnly </code>cookie on every request if it does not exist. The value is completely irrelevant. The only thing we care about is that the value was sent. The same is with the origin header. If an <code>Origin </code>was sent, we will assume it is a browser request and subject it to the stiffer requirements we will impose next. This is, for sure, a belt and suspenders approach since they are a bit duplicative. It does still, however, give you an idea of the types of strategies you should be thinking about when designing your own solutions.</p>
<pre><code>@app.on_request
async def check_request(request: Request):
    request.ctx.from_browser = (
        &quot;origin&quot; in request.headers or
        &quot;browser_check&quot; in request.cookies
    )
@app.on_response
async def mark_browser(_, response: HTTPResponse):
    response.cookies[&quot;browser_check&quot;] = &quot;1&quot;
    response.cookies[&quot;browser_check&quot;][&quot;domain&quot;] = &quot;mydomain.com&quot;
    response.cookies[&quot;browser_check&quot;][&quot;httponly&quot;] = True</code></pre>
<blockquote>
<p><strong>TIP</strong></p>
<p>Marking the <code>browser_check </code>cookie on every request is overkill. I generally recommend doing this on a landing page. Or, in someway catching the case when there is an <code>Origin </code>and no cookie to set it then. I will leave this to your discretion to determine an appropriate place and method to setting this cookie. If you control the frontend application, you might even consider setting it there. The point of this cookie is just to give us an additional indication that this is not a direct access API request.</p>
</blockquote></li>
<li><p>Looking at our list of requirements again, let’s add some code into the decorated_function of our decorator that makes sure that the origin matches. This is necessary because as we already know when the request is coming from the browser’s Javascript, this value cannot be spoofed:</p>
<pre><code>origin = request.headers.get(&quot;origin&quot;)
if request.ctx.from_browser and origin not in app.config.ALLOWED_ORIGINS:
    raise CSRFFailure</code></pre></li>
<li><p>The next requirement that we have is to make sure an <code>HttpOnly </code>token is present. For now, we will just use our <code>browser_check</code> cookie. This could also be satisfied with a session cookie if you have one:</p>
<pre><code>origin = request.headers.get(&quot;origin&quot;)
if request.ctx.from_browser and (
    origin not in app.config.ALLOWED_ORIGINS
    or &quot;browser_check&quot; not in request.cookies
):
    raise CSRFFailure</code></pre></li>
<li><p>Lastly, we need to verify our CSRF token. I know we have not discussed what that is, how to generate it, so of course we have not gotten to the verification bit yet. We will get there momentarily. Until then, let’s simply add a function to round out our decorator:</p>
<pre><code>origin = request.headers.get(&quot;origin&quot;)
if request.ctx.from_browser and (
    origin not in app.config.ALLOWED_ORIGINS
    or &quot;browser_check&quot; not in request.cookies
    or not csrf_check(request)
):
    raise CSRFFailure</code></pre></li>
</ol>
<p>We now finally turn to CSRF tokens. For our implementation we are going to use a Fernet token. This is a method of encrypting some bit of text with a secret key so that it cannot be changed or read without that key. We are going to set this token in a cookie that will explicitly <em>not</em> be <code>HttpOnly</code>. We want the frontend Javascript application to read this value and send it back in the application via the headers. When the potentially harmful state-changing request comes in, we will verify that the header and the cookie match. We also will extract the payload of the Fernet token and validate its contents. The actual value of that token we will store in a second cookie that will be <code>HttpOnly</code>. The purpose of this dual cookie, and dual submit verification is to protect our applications from various types of attacks that might otherwise compromise our strategy. The solution might sound much more complicated than it actually is, so let’s look at some code to start piecing this together:</p>
<ol>
<li><p>We will begin by setting up some configuration values that we will need.</p>
<pre><code>app.config.CSRF_REF_PADDING = 12
app.config.CSRF_REF_LENGTH = 18
app.config.CSRF_SECRET = &quot;DZsM9KOs6YAGluhGrEo9oWw4JKTjdiOot9Z4gZ0dGqg=&quot;</code></pre>
<blockquote>
<p><strong>IMPORTANT NOTE</strong></p>
<p>It should come as no surprise that you should never, <em>never</em>, <em>NEVER</em> hard code a secret like this in your applications. This is for example purposes only. Instead, you should be injecting secret values via environment variables or some other more secure method than this.</p>
</blockquote></li>
<li><p>We need a function that will generate our CSRF reference value and token. To accomplish this, we will use the cryptography library mentioned at the beginning of this chapter. It is battle tested and reliable. It should be the obvious first place to turn for all cryptographic needs in Python. Here’s the code:</p>
<pre><code>from base64 import b64encode
from cryptography.fernet import Fernet
def generate_csrf(secret, ref_length, padding) -&gt; Tuple[str, str]:
    cipher = Fernet(secret)
    ref = os.urandom(ref_length)
    pad = os.urandom(padding)
    pretoken = cipher.encrypt(ref)
    return ref.hex(), b64encode(pad + pretoken).decode(&quot;utf-8&quot;)</code></pre>
<p>As you can see, this is fairly simple. We create the cipher object using our secret. Then, as per the recommendation from the cryptography library, we use the operating system’s random generator logic with <code>os.urandom</code> to make our reference value, and some extra fluff. The reference is encrypted, and our token is then padded and returned along with the reference value.</p></li>
<li><p>Creating the reverse for verifying our token is a matter of performing these steps in reverse, and then comparing the encrypted value to the passed referenced value:</p>
<pre><code>def verify_csrf(secret, padding, ref, token):
    if not ref or not token:
        raise InvalidToken(&quot;Token is incorrect&quot;)
    cipher = Fernet(secret)
    raw = b64decode(token.encode(&quot;utf-8&quot;))
    pretoken = raw[padding:]
    encoded_ref = cipher.decrypt(pretoken)
    if ref != encoded_ref.hex():
        raise InvalidToken(&quot;Token is incorrect&quot;)</code></pre></li>
<li><p>We will need a way to make sure these values exist as cookies. Therefore, we will generate them in middleware for this example. However, it might be logical to instead perform this function on a login endpoint:</p>
<pre><code>@app.on_response
async def inject_csrf_token(request: Request, response: HTTPResponse):
    if (
        &quot;csrf_token&quot; not in request.cookies
         or &quot;ref_token&quot; not in request.cookies
    ):
        ref, token = generate_csrf(
            request.app.config.CSRF_SECRET,
            request.app.config.CSRF_REF_LENGTH,
            request.app.config.CSRF_REF_PADDING,
        )
        response.cookies[&quot;ref_token&quot;] = ref
        response.cookies[&quot;ref_token&quot;][&quot;domain&quot;] = &quot;localhost&quot;
        response.cookies[&quot;ref_token&quot;][&quot;httponly&quot;] = True
        response.cookies[&quot;csrf_token&quot;] = token
        response.cookies[&quot;csrf_token&quot;][&quot;domain&quot;] = &quot;localhost&quot;</code></pre>
<p>Remember, the plan is for the <code>csrf_token</code> to be Javascript accessible. We want the incoming request to not only include this in a cookie value but also have this value injected in the HTTP headers. This can only be done by Javascript running on our applications because of the same-origin policy. CORS to the rescue. This means, do not forget to whitelabel our request header that we will see next: <code>X-XSRF-Token</code>.</p></li>
</ol>
<p>Remember back in our <code>@csrf_protected</code> decorator, one of the checks was <code>csrf_check(request)</code>. We will finally now uncover what that function is:</p>
<pre><code>def csrf_check(request: Request):
    csrf_header = request.headers.get(&quot;x-xsrf-token&quot;)
    csrf_cookie = request.cookies.get(&quot;csrf_token&quot;)
    ref_token = request.cookies.get(&quot;ref_token&quot;)
    if csrf_header != csrf_cookie:
        raise CSRFFailure
    
    try:
        verify_csrf(
            request.app.config.CSRF_SECRET,
            request.app.config.CSRF_REF_PADDING,
            ref_token,
            csrf_cookie,
        )
    except InvalidToken as e:
        raise CSRFFailure from e
    return True</code></pre>
<p>There should be three values that we care about: the two cookies we just set, and the incoming <code>X-XSRF-Token</code> header. This header as we know will be generated on the client-side by extracting the cookie and injecting the value in the header. It should now be simply a matter of verifying that:</p>
<ul>
<li>The cookie and the header match</li>
<li>The protected <code>HttpOnly </code>reference value is the same as the encrypted value</li>
</ul>
<p>If that all checks out, we can be confident that the request is genuine.</p>
<blockquote>
<p><strong>TIP</strong></p>
<p>You may be wondering why I chose XSRF here instead of <code>X-CSRF-Token</code>, or even just <code>CSRF-Token</code> for the header name. The reason is that there are some frontend frameworks that automatically add this header injection for you client side. Since it is not important from our perspective what the header is called, we might as well play nice with some other tooling that likes it named this way.</p>
</blockquote>
</section>
</section>
<section id="samesite-cookies" class="level3" data-number="8.3.3">
<h3 data-number="8.3.3">Samesite cookies</h3>
<p>You may be familiar with a newer concept in CSRF protection known as <strong>samesite</strong> cookies. This is a value that can be appended to the cookie that provides extra directions to the browser about how to treat that cookie. In short, by setting this value on the cookies on the server, we allow the application to dictate to the browser when it is and is not acceptable to send the cookie. This alone <em>nearly</em> mitigates the issues with CSRF, but it should <em>NOT</em> be used by itself as the solution.</p>
<p>In fact, the <strong>Open Web Application Security Project (OWASP)</strong>—a nonprofit foundation that promotes the enhancement of security practices online—specifically states that the samesite attribute “<em>should not replace having a CSRF Token. Instead, it should co-exist with that token in order to protect the user in a more robust way.</em>” <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#samesite-cookie-attribute">https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#samesite-cookie-attribute</a></p>
<p>We will now learn about samesite cookie protection, and how to integrate it into our solution. There are three allowed values: <code>None</code>, <code>Lax</code>, and <code>Strict</code></p>
<section id="samesitenone" class="level4" data-number="8.3.3.1">
<h4 data-number="8.3.3.1">Samesite=None</h4>
<p>Cookies that use <code>Samesite=None</code> should be considered only for non-security related cookies. This is because they will be sent with every request, no matter what site they are originating from. Therefore, if you are on the hacker’s website, that hacker will be able to submit requests on your behalf to other sites that you have visited and making use of the cookies you have on your computer. Not cool.</p>
<p>But, for the right kind of cookies, this is not really an issue. As long as the value has nothing to do with security or sessions, this is acceptable. It should be also noted, however, that for this to work it will also only be allowed when the cookie is marked Secure. That is to say that it is only allowed to be passed across <code>https </code>requests. In your production level code, you should be doing this regardless. You are using TLS encryption right? If not, we will see super simple solution to this in Chapters 8 and 10.</p>
<p>Setting <code>Samesite=None </code>is as simple as the following:</p>
<pre><code>response.cookies[&quot;myfavorite&quot;] = &quot;chocolatechip&quot;
response.cookies[&quot;myfavorite&quot;][&quot;domain&quot;] = &quot;mydomain.com&quot;
response.cookies[&quot;myfavorite&quot;][&quot;samesite&quot;] = None
response.cookies[&quot;myfavorite&quot;][&quot;secure&quot;] = True</code></pre>
<p>This will result in the following cookie:</p>
<pre><code>Set-Cookie: myfavorite=chocolatechip; Path=/; Domain=mydomain.com; SameSite=None; Secure</code></pre>
</section>
<section id="samesitelax" class="level4" data-number="8.3.3.2">
<h4 data-number="8.3.3.2">Samesite=Lax</h4>
<p>This is the default in most modern web browsers now. You should not, however, rely upon that fact, and it is certainly still best practice to do so explicitly.</p>
<p>What does this value mean? It means that the cross-site <code>POST </code>requests we have been worried about will not include the cookies (which is a big part of CSRF protection). However, it will allow them in some contexts. To be sent in a cross-site request, the request must be a top-level navigation (think of this as the address bar in the browser), and the HTTP method must be <code>GET </code>or <code>HEAD</code>.</p>
<p>This basically boils down to protection from AJAX requests, but allowing the cookie to be sent when someone navigates to the site from a third-party link. This actually makes a lot of sense and is probably what you want to use for a lot of your cookies.</p>
<p>For example, if your session cookies were <em>not</em> set to Lax (and instead were <code>Strict</code>) when someone clicked a link from another website that brought them to your site, they would not appear as logged in. However, once they started clicking around, suddenly their session would appear. This might be an awkward experience for the user. Therefore, it is suggested that session management and authentication cookies should be <code>Lax </code>for most typical applications. If you are building a secured banking application, you probably have no use for someone to link to a secured banking page, and maybe <code>Lax </code>is not the right answer. However, it is generally acceptable to use Lax for authentication.</p>
<p>As mentioned, you do not need to explicitly state the samesite attribute anymore, but explicit is better than implicit.</p>
<pre><code>response.cookies[&quot;session_token&quot;] = session_token
response.cookies[&quot;session_token&quot;][&quot;domain&quot;] = &quot;localhost&quot;
response.cookies[&quot;session_token&quot;][&quot;httponly&quot;] = True
response.cookies[&quot;session_token&quot;][&quot;samesite&quot;] = &quot;lax&quot;
response.cookies[&quot;session_token&quot;][&quot;secure&quot;] = True</code></pre>
<p>This will generate a cookie that looks like this:</p>
<pre><code>Set-Cookie: session_token=&lt;TOKEN&gt;; Path=/; Domain=localhost; HttpOnly; SameSite=lax; Secure</code></pre>
</section>
<section id="samesitestrict" class="level4" data-number="8.3.3.3">
<h4 data-number="8.3.3.3">Samesite=Strict</h4>
<p>As alluded to in the last section, a <code>Strict </code>cookie will only be sent when the request originated from the correct site. This means that the user must first be on your application, and <em>then</em> submit the request. In my opinion, this really sounds like the type of request that would be performed that is state-changing. Do you see where I am headed with this?</p>
<p>In my opinion (and you will undoubtedly come across different opinions), CSRF protection cookies should be <code>Samesite=Strict</code>. There is no legitimate use case (at least not in my applications) where I can think that I would not want my user to be on my application first before initiating the types of requests that I am trying to protect. You may have different needs, and this might not work for you. If <code>Lax </code>makes sense, then go with it. I’ll stick to this:</p>
<pre><code>response.cookies[&quot;ref_token&quot;] = ref
response.cookies[&quot;ref_token&quot;][&quot;domain&quot;] = &quot;localhost&quot;
response.cookies[&quot;ref_token&quot;][&quot;httponly&quot;] = True
response.cookies[&quot;ref_token&quot;][&quot;samesite&quot;] = &quot;strict&quot;
response.cookies[&quot;ref_token&quot;][&quot;secure&quot;] = True
response.cookies[&quot;csrf_token&quot;] = token
response.cookies[&quot;csrf_token&quot;][&quot;domain&quot;] = &quot;localhost&quot;
response.cookies[&quot;csrf_token&quot;][&quot;samesite&quot;] = &quot;strict&quot;
response.cookies[&quot;csrf_token&quot;][&quot;secure&quot;] = True</code></pre>
<p>As you can probably guess, our cookies now look like this:</p>
<pre><code>Set-Cookie: ref_token=&lt;TOKEN&gt;; Path=/; Domain=localhost; HttpOnly; SameSite=strict; Secure
Set-Cookie: csrf_token=&quot;&lt;TOKEN&gt;&quot;; Path=/; Domain=localhost; SameSite=strict; Secure</code></pre>
<blockquote>
<p><strong>IMPORTANT NOTE</strong></p>
<p>As mentioned, support for samesite cookies is not universal. You should check a website like CanIUse to see if any browsers you are targetting do not implement it: <a href="https://caniuse.com/same-site-cookie-attribute">https://caniuse.com/same-site-cookie-attribute</a>. Also, a “same” site in this context does include subdomains. There is a public list of addresses that are considered “top-level” for this context, which does not completely line up with .com, .org, io, etc. For example, two websites on github.io are not considered samesite. For the full list, check it out here: <a href="https://publicsuffix.org">https://publicsuffix.org</a>.</p>
</blockquote>
<p>In our review of CSRF, there was a lot of mention of session tokens and authentication, but we have not looked at that yet. While this is an incredibly deep topic by itself, we will explore how you can implement authentication on your applications using Sanic.</p>
</section>
</section>
</section>
<section id="protecting-your-sanic-app-with-authentication" class="level2" data-number="8.4">
<h2 data-number="8.4">Protecting your Sanic app with authentication</h2>
<p>When many people think about a web application, what comes to mind is some type of a platform on the web where they login to do… <em>something</em>. The activity is not what we care about here. When you are done reading this book, you are going to go off and build some amazing applications. What we care about is the journey and the process. And, the part of the process that we care about right now is: login.</p>
<p>To be more specific and correct, what we are about to look is <strong>authentication</strong> and not so much about <strong>authorization</strong>. While these two ideas are very closely related, they are not the same and are not interchangeable. In fact, authorization usually presumes that authentication already happened.</p>
<p>What’s the difference?</p>
<ul>
<li><strong>Authentication</strong>: answers the question: who are you?</li>
<li><strong>Authorization</strong>: answers the question: what are you allowed to do?</li>
</ul>
<p>To confuse matters even more, a failure of <strong>authentication</strong> is a <code>401 Unauthorized</code> response. This is super unfortunate naming from the early days of the Internet. A failure of <strong>authorization</strong> is a <code>403 Forbidden</code> response.</p>
<p>In 2020, I spoke at EuroPython about access control issues. The slides and a link to the YouTube presentation are on my GitHub page: <a href="https://github.com/ahopkins/europython2020-overcoming-access-control">https://github.com/ahopkins/europython2020-overcoming-access-control</a>. If you have about 30 minutes to watch a riveting presentation about this thrilling topic, its “don’t miss” opportunity.</p>
<p>The presentation covers this authentication/authorization topic, but also largely tries to answer the question: “what are the different methods for protecting my API?” It answers this by comparing session-based authentication with non-session based (aka stateless). We will review both of these strategies here, but also include how to implement API keys (which is not covered in that presentation).</p>
<p>To do this, there is a set of questions that need to be answered. Before we dive into how to implement some of the common strategies with Sanic, we will review some of the questions that you should ask yourself before deciding upon a strategy.</p>
<ol>
<li>Who will consume the API?You should think about whether the API is going to be used by other applications or scripts, or by actual people. Will it be used by programmers who are integrating it into their applications? Or, will it be used to power a mobile application? Does a frontend Javascript application need to access it?The reason you should care is you must have an understanding of the technical abilities, but also the weaknesses of your intended use case. If your API will only ever be consumed by other backend scripts and applications, then you will have an easier time securing it. Most of that stuff we talked about cookies is highly irrelevant; and CORS is a non-issue.On the other hand, if you intend to power a browser-based single page application, then you likely need a more robust authentication strategy than simple API keys.</li>
<li>Do you have control over the client?The core of this question is whether you (or your organization) will be the consumer of the API. Contrast this with an API that is meant to be consumed by integrations and other applications, and you should see that this can have a difference on how you control access. For example, if you are building a microservice that is not exposed to the Internet, but only exists within a highly controlled network, you obviously have a different set of security concerns than the API that powers your bank’s website.</li>
<li>Will this power a web browser frontend application?This is a bit of a subset of the first question, but it is important enough to think about on its own. The reason that this is so much of an issue is that the browser is flawed. When the Internet was first created and web browsers were first being released, no one could quite predict the direction and level of importance that would become of the Internet. The security concerns—and the solutions to mitigate them—were born out of years of hackers attempting to exploit a system that was never really designed with a security first mindset.For example, the fact that non-encrypted <code>http://</code> websites even exist in today’s world is really mind-boggling. This Chapter devoted a lot of energy so far to how to deal with certain security concerns that only exist because the web browser is broken. Therefore, knowing that there is even a possibility of frontend usage for your application should trigger warning bells early on that you <strong>must</strong> dedicate time and attention to this topic.</li>
</ol>
<p>With those three questions in our mind, we will now look at three potential schemes for authenticating users. But first, another reminder that just because I do something some way here does not mean you should as well. Use your skills to take what is provided to build the solutions you need for your application. We are talking security, so maybe you should be careful before you stray too far. If you ever have a question about whether a strategy, feel free to bring the question to the community on Discord or in the Forums.</p>
<p>Next, we will explore <em>some</em> of the strategies you may find.</p>
<section id="using-api-keys" class="level3" data-number="8.4.1">
<h3 data-number="8.4.1">Using API Keys</h3>
<p>By far, API keys are the simplest authentication scheme. They are easy to set up and easy for the end-user to implement. It also means that they offer lesser security. That does not mean they should be overlooked. In the right context, API keys can be the exact right tool to get the job done, provided you take measures to mitigate any security concerns.</p>
<p>API keys go by many names, but they boil down to a simple concept: your application provides a secure persistent token. When the request is accompanied by that token, it works. If not, it fails. It is as simple as that. One of the main benefits—besides simplicity—is that the keys are easy to invalidate. Since you are storing the keys <em>somewhere</em>, all you need to do is change the stored value or remove it and that key will no longer work.</p>
<p>The reason that API keys are more susceptible to attacks is that they are a single, persistent value. This means that it is in theory easier for the value to be brute force attacked. A hacker could set up a machine and try every single combination until one worked. Therefore, the first step in making sure that your API scheme is secure is to <strong>use strong keys</strong>. This means a high amount of entropy.</p>
<p>Once a sufficiently complex API key has been generated, it should be hashed before storing. <strong>Do not encrypt</strong> your keys. What is the difference between hashing and encrypting? When you “encrypt” data, it can be reversed. Like we saw with Fernet encryption, we were able to reverse the process and decrypt the original value. This is a no-no for API keys. Hashing, on the other hand, is a one-way street. Once it is hashed, there is no way to recover the original value. Therefore, to validate a value against it, you need to hash the incoming value using the same strategy, and compare the result to the stored hash.</p>
<p>This might sound to you like password management, right? That is because you should basically treat an API key exactly as you would a password. This brings up the second potential security pitfall when using API keys: storage. <strong>Never</strong> store it in plain text, <strong>never</strong> store it in a format where the original value can be retrieved, and <strong>never</strong> store it so that the hashed value can easily be predicted.</p>
<p>Once you have the value of a newly generated key, you will add a “salt” before storing it. A password salt is a random bit of text that is added to a password so that when the password is hashed, it is done so in an unpredictable format. If you do not salt the password, then the hashed value can be cracked by comparing to known hashes for common passwords. Hackers keep databases of the hashed values of common passwords for this reason. Even though they might not be able to decrypt a hashed value, if you fail to salt it, then it is super simple for them to backwards engineer the value by simply looking at known values. Luckily, the <code>bcrypt </code>module makes this easy. Let’s dive into some code.</p>
<ol>
<li><p>We will begin by creating a function to generate an API key. To do this, we will use the <code>secrets </code>module that comes from the Python standard library. In our example, we will use <code>secrets.token_urlsafe</code> to generate the value. You also could use <code>secrets.token_hex</code>, but it will produce a slightly longer string to represent the same value. The reason I suggest using this library with its default settings is that the maintainers of Python will change the amount of entropy needed based upon current best practices. As of the time of this writing, the default is 32 bytes. If you feel more is required, feel free to increase that value:</p>
<pre><code>from secrets import token_urlsafe
from bcrypt import hashpw, gensalt
def generate_token():
    api_key = token_urlsafe()
    hashed_key = hashpw(api_key.encode(&quot;utf-8&quot;), gensalt())
    return api_key, hashed_key</code></pre>
<p>We also used the <code>bcrypt </code>module for generating a salt. What this does is adds random text, creates a hash, and then repeats the cycle several times. By folding the hashed value with multiple rounds of salting, it becomes more difficult to compare against a known value (it also becomes computationally more expensive, so setting the value too high might be super-time consuming). We will use <code>gensalt </code>with the default value of 12 rounds.</p></li>
<li><p>You will need some endpoint that generates and stores these values. A typical implementation will have a frontend UI where the user clicks a button to generate the API key. The value is returned on screen just long enough for them to copy it. Once they navigate away, that value is gone and cannot be recovered. In the backend, this means that we need an endpoint that uses the <code>generate_token</code>, sends the API key to the user, and stores the hashed key in the database:</p>
<pre><code>@app.post(&quot;/apikey&quot;)
async def gen_handler(request):
    api_key, hased_key = generate_token()
    user = await get_user_from_request(request)
    await store_hashed_key(user, hased_key)
    return json({&quot;api_key&quot;: api_key})</code></pre>
<p>As a reminder, you can look back to <em>Chapter 4</em> for strategies on how to extract data from the request to get the user, for example. In the above, <code>get_user_from_request</code> is a stand-in to show that you would be pulling the user information based upon the incoming request. Similarly, since we have not looked at how to interact with databases yet, <code>store_hashed_key</code> is just a stand-in to show that you would need to use the user and the hashed key to <em>somehow</em> store the value.</p></li>
<li><p>We will create a new decorator to protect endpoints with our API key. In this decorator, we will extract the user from the request, and compare the hashed key to whatever the user has sent:</p>
<pre><code>from bcrypt import checkpw
from sanic.exceptions import Unauthorized
def api_key_required(
    maybe_func=None,
    *,
    exception=Unauthorized,
    message=&quot;Invalid or unknown API key&quot;
):
    def decorator(f):
        @wraps(f)
        async def decorated_function(request, *args, **kwargs):
            user = await get_user_from_request(request)
            is_valid = checkpw(request.token.encode(&quot;utf-8&quot;), user.hashed_key)
            if not is_valid:
                raise exception(message)
            response = f(request, *args, **kwargs)
            if isawaitable(response):
                response = await response
            return response
        return decorated_function
    return decorator(maybe_func) if maybe_func else decorator</code></pre>
<p>One thing that is helpful to point out here is that Sanic will extract a token from the <code>Authorization</code> header for us. It is a very common scheme to send tokens in headers as so-called <strong>bearer tokens</strong>. They look like this:</p>
<pre><code>Authorization: Bearer &lt;token_here&gt;</code></pre>
<p>Or:</p>
<pre><code>Authorization: Token &lt;token_here&gt;</code></pre>
<p>Therefore, to get access to that token valued, all you need to use is <code>request.token </code>and Sanic will find it from either location.</p></li>
<li><p>Now, to implement this, all we need to do is wrap our endpoints:</p>
<pre><code>@app.get(&quot;/protected&quot;)
@api_key_required
async def protected_handler(request):
    return text(&quot;hi&quot;)</code></pre></li>
</ol>
<p>Another thing to point out is the inherent security leak in failing to use the correct status codes and exception messages when something goes wrong. We mentioned this back in <em>Chapter 6</em>, and it is worth seeing how to address the concern here. You may have noticed that we are allowing our decorator to pass in an Exception class and message. This is so that we have control over what information is sent to the end-user.</p>
<p>Now that we have seen how easy it is to implement <em>proper</em> API keys, the only remaining question is: when is it appropriate to use them?</p>
<p><em>Never use an API key to secure a browser-based UI</em>.</p>
<p>The security afforded by the API key is not sufficient to handle all of the issues that the browser raises by virtue of storage of credentials. This is really only appropriate for integrations coming from outside scripts or applications.</p>
<p>Because of that reason, I like to use <code>check_request</code> middleware we created earlier in this Chapter in conjunction with my authorization decorator. Since <code>@api_key_required</code> should never be valid for a request from the browser, I like to change:</p>
<pre><code>if not is_valid:
    raise exception(message)</code></pre>
<p>to this:</p>
<pre><code>if request.ctx.from_browser or not is_valid:
    raise exception(message)</code></pre>
<p>Now that we know how and when to use API keys, let’s look at approaches to handling authentication in a scenario that is appropriate for web applications.</p>
</section>
<section id="understanding-session-versus-non-session-based-authentication" class="level3" data-number="8.4.2">
<h3 data-number="8.4.2">Understanding session versus non-session based authentication</h3>
<p>User sessions are perhaps the most common approach to handling authentication in web applications. A more recent strategy employs tokens known as <strong>JSON Web Tokens (JWT)</strong>. In most other contexts, you will hear about these referred to as <em>stateful</em> versus <em>stateless</em>. User sessions are <em>stateful</em> and JWTs are <em>stateless</em>. This is all true, but I like to refer to them as <strong>session based</strong> and <strong>non-session based</strong>. Call me a rebel, but I think that this more clearly describes what we are trying to achieve.</p>
<p>First, what is a session? If a user logs into your application, and you record that login in your database so that it can be invalidated at will, then you are creating a session. This means that so long as that record exists in your database, there is an active session that can be authenticated against that particular user.</p>
<p>Session-based authentication is very simple to implement on both the frontend and the backend. And, because it offers a high degree of security, it is the reason that it has become a default approach for many web applications. One of its huge benefits is that any active session can be inactivated at any time. Have you ever been on a web application (perhaps your email provider) that lists out everywhere you are logged in? With a click of a button, you can log out the other locations. This is really helpful in case a session is compromised or hacked.</p>
<p>On the other hand, non-session based authentication provides a great deal more flexibility. The typical example of a non-session based token is a JWT. So even though I am talking specifically about JWTs, they are not the only way to handle non-session based authentication. The most critical component that is offered by this strategy is that the token itself is self-authentication. That means that a server only needs to look at the token to determine if it is genuine, and if it has been tampered with.</p>
<p>Because of this, authenticating a JWT becomes highly portable. You can have one microservice that handles authentication and generating tokens, and then other services can verify them without having to involve the authentication service at all! This allows for very scalable architectures. This also highlights another benefit. Every time a session token is received, in order to authenticate it you <em>must</em> make a round-trip to your storage engine. This means every single API call includes at least one more network call to the database. This is completely avoided with self-authenticating tokens, and can lead to overall performance benefits.</p>
<p>JWTs specifically also carry the benefit that they can be embedded with non-secret payloads. This often means that you can include a list of permissions, or meta information about a user that the frontend application can make use of.</p>
<p>That all sounds great, but the downside to JWTs is that once issued they cannot be invalidated. When they are created, they are given an expiration time. The token will remain valid until that time expires. This is the reason why these expiration times are usually quite short, and usually measured in minutes (not hours or days as may be typical of sessions). If a token expires every ten (10) minutes, it would be super inconvenient for a web application user to need to login again so frequently. Therefore, JWTs are often accompanied by a refresh token. This token is a value that allows a user to exchange an expired JWT for a fresh new one.</p>
<p>Furthermore, session-based tokens are generally easier to protect from XSS attacks using the <code>HttpOnly</code> cookies as we saw earlier. Since JWTs are usually sent as a bearer token like API keys, implementing them also means revisiting how we are going to protect them inside the browser. If your head is starting to spin thinking about all of the concerns that exist with trying to implement JWTs as both a secure and user-friendly approach, then you are not alone. Adding JWTs to an application is certainly much more involved than sessions. Therefore, you must think about your specific application needs when deciding which strategy to use.</p>
<p>“<em>Hold up!</em>” You might be saying to yourself. “<em>If JWTs have so many benefits, why not just treat them like session tokens and store them as cookies? Also, we can get around invalidating tokens by comparing them against a black list! Then, we can make them longer and just add them to the blacklist when we want to logout or invalidate them. Both problems solved.</em>”</p>
<p>Yes, that is true. Let’s look at both of those proposals in turn.</p>
<p>First, storing JWTs as a cookie like a session token does work. But, you now lose out on one of its big benefits: the authenticated payload. Remember that one of its benefits is that they can carry meta details that your frontend application could use. If they are stuck inside of an <code>HttpOnly </code>cookie, then that information is not available. (We will look at a way to address this when we look at JWT implementations).</p>
<p>Second, if you are maintaining a blacklist of tokens to allow a token to be <em>revoked</em> or <em>invalidated</em>, then you no longer are using non-session based authentication. Instead, you are using JWTs in a session based scheme. This is acceptable and people do it. However, it makes your tokens less portable since they require a centralized store to be validated, and also include additional network calls. Implement at your own risk.</p>
<p>We now turn to implementation strategies within Sanic. Because we have not looked at database implementation, we will still use some stand-in functions for getting and storing information when needed. Try to look over those details for now since we are focusing more upon how to handle authentication not persisting data. If you look on the GitHub repository at these examples, there will be some dummy versions of these functions just to make the examples operational. Try not to get hung up on those details right now.</p>
</section>
<section id="using-sessions" class="level3" data-number="8.4.3">
<h3 data-number="8.4.3">Using sessions</h3>
<p>You have decided after reading the <em>Session v. non-session based authentication</em> section that stateful sessions are the right options for your application. Super, you really already know just about everything you need.</p>
<p>We have already seen how to handle passwords (the same as API keys). Therefore, implementing a login route should be simple.</p>
<p>We already know that the session token needs to <em>not</em> be accessible from Javascript to combat XSS. Therefore, we will use <code>HttpOnly </code>cookies.</p>
<p>We also know that using an <code>HttpOnly </code>cookie by itself leaves an application vulnerable to CSRF attacks. Therefore, we will couple our implementation with the CSRF protection scheme we came up with earlier.</p>
<p>What’s left? Not much. We need endpoints for:</p>
<p>registering a use (which will be responsible for storing the password securely);</p>
<p>logging in (which takes a username and password and verifies it, just like in the API key example, creates a session key, stores it, and sets it as a cookie); and</p>
<p>logging out (which deletes the session from the database).</p>
<p>This is a great opportunity for you to take these requirements and try and build your own solution. Put the book down and build these three endpoints. If you get stuck, there is an example solution in the GitHub repository.</p>
<p>In order to protect your endpoints, we will have a similar approach with a decorator. Do you remember the <code>@csrf_protected </code>decorator we built earlier? If you are using session-based authentication, then I suggest combining that decorator with the one we are building here. They compliment each other nicely and then it makes it easier for you to properly protect your endpoints.</p>
<ol>
<li><p>Here is how we will rebuild it. We are adding a similar block to our decorator like the API key decorator that will raise an exception if session verification fails:</p>
<pre><code>def session_protected(
    maybe_func=None,
    *,
    exception=Unauthorized,
    message=&quot;Invalid or unknown API key&quot;
):
    def decorator(f):
        @wraps(f)
        async def decorated_function(request, *args, **kwargs):
            origin = request.headers.get(&quot;origin&quot;)
            if request.ctx.from_browser and (
                origin not in app.config.ALLOWED_ORIGINS
                or &quot;browser_check&quot; not in request.cookies
                or not csrf_check(request)
            ):
                raise CSRFFailure
            session_token = request.cookies.get(&quot;session_token&quot;)
            if not session_token or not await verify_session(session_token):
                raise exception(message)
            response = f(request, *args, **kwargs)
            if isawaitable(response):
                response = await response
            return response
        return decorated_function
    return decorator(maybe_func) if maybe_func else decorator</code></pre></li>
<li><p>The verification of the session does depend upon your database implementation. But, in general, it should look something like this:</p>
<pre><code>async def verify_session(session_token):
    try:
        await get_session_from_database(session_token):
    except NotFound:
        return False
    return True</code></pre></li>
</ol>
<p>If the session token exists, then we can proceed. If it does not, then return False.</p>
<p>As you can see, sessions tend to be easy to implement once you have the basic functionality for storing and retrieving data from a database. We now turn to the more complicated alternative.</p>
</section>
<section id="jwt-json-web-token" class="level3" data-number="8.4.4">
<h3 data-number="8.4.4">JWT (JSON Web Token)</h3>
<p>So, you have read the section on <em>Session v. non-session based authentication</em> and decided to implement JWTs. Now what? The problem that we need to solve is that to use them to their full capacity within a frontend application poses two problems:</p>
<ul>
<li>How to store and send them to not compromise on functionality or security?</li>
<li>How to maintain a reasonable user experience without sacrificing security?</li>
</ul>
<p>We will address these questions in turn, and then develop a solution that gives us satisfaction on both.</p>
<section id="to-cookie-or-not-to-cookie" class="level4" data-number="8.4.4.1">
<h4 data-number="8.4.4.1">To cookie, or not to cookie?</h4>
<p>There are two competing interests when deciding how to send the access token (please note that from here on out access token is synonymous with JWT): usability and security. If we send the token via the headers, it would look like this:</p>
<pre><code>Authentication: Bearer &lt;JWT&gt;</code></pre>
<p>To accomplish this, we need some client-side Javascript to read the value and inject it into our request:</p>
<pre><code>const accessToken = document.cookie
    .split(&#39;; &#39;)
    .find(row =&gt; row.startsWith(&#39;access_token=&#39;))
    .split(&#39;=&#39;)[1]
fetch(url, {headers: {Authorization: `Bearer ${accessToken}`}})</code></pre>
<p>You should (by now) already be suspecting the problem with this: XSS vulnerability! If our frontend application can access the token from Javascript, then that means that any bad script can as well. Bummer.</p>
<blockquote>
<p><strong>IMPORTANT NOTE</strong></p>
<p>You may be thinking to yourself, why is the JWT being stored client-side in a cookie and not in web storage (either localStorage or sessionStorage)? The reason is that both of those solutions are great for handling non-sensitive details. They are subject to the XSS attacks we are trying to prevent. You may see a lot of advice online suggesting that you use these for JWTs. <em>Don’t do it!</em> <strong></strong> The solution that is offered here will be much more secure and still not sacrifice on usability. All it takes is a little extra work server-side, so please be patient and do not rush off to this sub-standard alternative.</p>
</blockquote>
<p>To fix the problem we use <code>HttpOnly </code>and let our application just send the cookie back by itself. In this situation we will rely on the server to write and read the cookie as needed. But, in doing this, we cannot access the JWT payload. There also is the problem of CSRF that we have seen a few times already, but by now you should already understand how to solve that problem. If not, please go back to read the section <em>Protecting applications from CSRF</em> in this Chapter.</p>
<p>One option might be to return the payload of the access token when you first login. These details you could store in web storage safely and use them whenever you want. That might look something like this on the server:</p>
<pre><code>@app.post(&quot;/login&quot;)
async def login(request):
    user = await authenticate_login_credentials(
        request.json[&quot;username&quot;],
        request.json[&quot;password&quot;],
    )
    access_token = generate_access_token(user)
    response = json({&quot;payload&quot;: access_token.payload})
    response.cookies[&quot;access_token&quot;] = access_token
    response.cookies[&quot;access_token&quot;][&quot;domain&quot;] = &quot;localhost&quot;
    response.cookies[&quot;access_token&quot;][&quot;httponly&quot;] = True
    response.cookies[&quot;access_token&quot;][&quot;samesite&quot;] = &quot;lax&quot;
    response.cookies[&quot;access_token&quot;][&quot;secure&quot;] = True
    return response</code></pre>
<p>I support this approach, and it certainly will work. You gain access to the payload, and you have a secure way to transport and store the access token.</p>
<p>A second option would be to use split cookies. More on that in just a bit. Feel free to skip ahead, or go back and reference that EuroPython talk I mentioned at the beginning of the Chapter where I discussed this approach.</p>
</section>
<section id="your-session-expired-after-10-minutes-please-login-again" class="level4" data-number="8.4.4.2">
<h4 data-number="8.4.4.2">“Your session expired after 10 minutes, please login again?”</h4>
<p>Have you ever been on a website that does this? Usually, it is banking or financial applications because they are concerned about a user standing up from their computer and walking away to leave a logged in session. Maybe this is your need, so great! You can rest comfortably with JWTs as a solution and expire your tokens often with no concern.</p>
<p>For most applications, however, this would lead to a terrible user experience.</p>
<p>Remember, the reason we are expiring our access tokens at such a short interval is to reduce the potential attack surface. If a token were to fall into the wrong hands, it can only be used for a very small window. The shorter the expiration, the more secure the token.</p>
<p>The solution to the problem requires a little bit of frontend complexity. But, I think it is worth the protection it affords. There are actually two solutions that you can choose from:</p>
<p>Use Javascript’s <code>setInterval </code>to periodically send a request to refresh the token in the background unknown to the user</p>
<p>Wrap your Javascript fetch call with a proper exception handler. It catches the scenario where an expired token was submitted, sends a request to refresh the token, and then retries the original request with the new token</p>
<p>Feel free to choose the approach that works for you. The GitHub repository has some sample Javascript for implementing each strategy.</p>
<p>To implement a refresh token, we will borrow some of the concepts we used earlier for making the API token. When a user performs a login, we will continue to generate the access token, but we will also generate and store a refresh token by reusing the API token logic.</p>
<ol>
<li><p>Create a login endpoint that also generates and stores a refresh token:</p>
<pre><code>@app.post(&quot;/login&quot;)
async def login(request):
    user = await authenticate_login_credentials(
        request.json[&quot;username&quot;],
        request.json[&quot;password&quot;],
    )
    
    access_token = generate_access_token(user)
    refresh_token, hased_key = generate_token()
    await store_refresh_token(user, hased_key)
    
    response = json({&quot;payload&quot;: access_token.payload})
    response.cookies[&quot;access_token&quot;] = access_token
    response.cookies[&quot;access_token&quot;][&quot;domain&quot;] = &quot;localhost&quot;
    response.cookies[&quot;access_token&quot;][&quot;httponly&quot;] = True
    response.cookies[&quot;access_token&quot;][&quot;samesite&quot;] = &quot;lax&quot;
    response.cookies[&quot;access_token&quot;][&quot;secure&quot;] = True
    response.cookies[&quot;refresh_token&quot;] = refresh_token
    response.cookies[&quot;refresh_token&quot;][&quot;domain&quot;] = &quot;localhost&quot;
    response.cookies[&quot;refresh_token&quot;][&quot;httponly&quot;] = True
    response.cookies[&quot;refresh_token&quot;][&quot;samesite&quot;] = &quot;strict&quot;
    response.cookies[&quot;refresh_token&quot;][&quot;secure&quot;] = True
    
    return response</code></pre>
<p>Go back to the <em>Using API Keys</em> section to see the <code>generate_token</code> function.</p></li>
<li><p>To issue a new access token, we need to create a new endpoint that will validate the refresh token (like we did the API token). As an added level of security (since a single point of authentication from the browser is not a good idea), we also will require a previously issued access token even if it is already expired:</p>
<pre><code>from bcrypt import checkpw
from sanic.exceptions import Forbidden
from sanic.response import empty
@app.post(&quot;/refresh&quot;)
async def refresh_access_token(request):
    user = await get_user_from_request(request)
    access_token = request.cookies[&quot;access_token&quot;]
    refresh_token = request.cookies[&quot;refresh_token&quot;]
    
    is_valid_refresh = checkpw(
        refresh_token.encode(&quot;utf-8&quot;),
        user.refresh_hash
    )
    is_valid_access = check_access_token(access_token, allow_expired=True)
    if not is_valid_refresh or not is_valid_access:
        return Forbidden(&quot;Invalid request&quot;)
    access_token = generate_access_token(user)
    response = empty()
    response.cookies[&quot;access_token&quot;] = access_token
    response.cookies[&quot;access_token&quot;][&quot;domain&quot;] = &quot;localhost&quot;
    response.cookies[&quot;access_token&quot;][&quot;httponly&quot;] = True
    response.cookies[&quot;access_token&quot;][&quot;samesite&quot;] = &quot;lax&quot;
    response.cookies[&quot;access_token&quot;][&quot;secure&quot;] = True
    return response</code></pre></li>
</ol>
<p>We have not seen how to validate JWT yet, so do not worry that you are not sure how to implement <code>check_access_token</code>. We will do that next.</p>
</section>
<section id="solving-for-jwts-in-browser-based-applications" class="level4" data-number="8.4.4.3">
<h4 data-number="8.4.4.3">Solving for JWTs in browser-based applications</h4>
<p>By now we generally have an understanding of what we want to achieve. What we need to look at now is:</p>
<ul>
<li>How to generate the access token</li>
<li>How to verify the access token (both with and without expiration)</li>
<li>How to “split” the token to make it usable and secure</li>
</ul>
<p>To generate the token, we will use <code>pyjwt</code>. The first thing we will need to do is create an application with secret. Just like before, I will hardcode it in my example, but you will get the value from an environment variable or other secure method.</p>
<ol>
<li><p>Set the secret and some other configuration values that we will need:</p>
<pre><code>from datetime import timedelta
app.config.JWT_SECRET = &quot;somesecret&quot;
app.config.JWT_EXPIRATION = timedelta(minutes=10)
app.config.REFRESH_EXPIRATION = timedelta(hours=24)
app.config.COOKIE_DOMAIN = &quot;127.0.0.1&quot;</code></pre></li>
<li><p>Create a model that will hold our JWT details:</p>
<pre><code>from dataclasses import dataclass
@dataclass
class AccessToken:
    payload: Dict[str, Any]
    token: str
    def __str__(self) -&gt; str:
        return self.token
    @property
    def header_payload(self):
        return self._parts[0]
    @property
    def signature(self):
        return self._parts[0]
    @property
    def _parts(self):
        return self.token.rsplit(&quot;.&quot;, maxsplit=1)</code></pre></li>
<li><p>Generate the token with some payload. In JWT-speak, a payload is essentially just a dictionary of values. It can contain a “claim” which is a special key-value pair that can be used in authenticating a token. If you get into JWT, I suggest you dig deeper into some of the standard claims. In our example, the only one we are using is the expiration claim: <code>exp</code>. Other than that, feel free to add whatever you want to the payload:</p>
<pre><code>import jwt
def generate_access_token(user: User, secret: str, exp: int) -&gt; AccessToken:
    payload = {
        &quot;whatever&quot;: &quot;youwant&quot;,
        &quot;exp&quot;: exp,
    }
    raw_token = jwt.encode(payload, secret, algorithm=&quot;HS256&quot;)
    access_token = AccessToken(payload, raw_token)
    return access_token
To verify the token, we can do the reverse. We do have a use case for when we will accept an expired token (when using the refresh token). Therefore, we need a flag to allow us to skip the check of the exp claim.
def check_access_token(
    access_token: str, secret: str, allow_expired: bool = False
) -&gt; bool:
    try:
        jwt.decode(
            access_token,
            secret,
            algorithms=[&quot;HS256&quot;],
            require=[&quot;exp&quot;],
            verify_exp=(not allow_expired),
        )
    except jwt.exceptions.InvalidTokenError as e:
        error_logger.exception(e)
        return False</code></pre></li>
<li><p>Once you have generated the <code>AccessToken </code>object, it will be super easy to split it up into two cookies. One of them will be Javascript accessible, and one of them will be <code>HttpOnly</code>. We also want the refresh token to be <code>HttpOnly</code>. Your login handler would have something like this:</p>
<pre><code>access_token_exp = datetime.now() + request.app.config.JWT_EXPIRATION
refresh_token_exp = datetime.now() + request.app.config.REFRESH_EXPIRATION
access_token = generate_access_token(
    user,
    request.app.config.JWT_SECRET,
    int(access_token_exp.timestamp()),
)
refresh_token, hased_key = generate_token()
await store_refresh_token(user, hased_key)
response = json({&quot;payload&quot;: access_token.payload})</code></pre></li>
<li><p>We then set all of our cookies with a convenience function. Pay careful attention to the how these cookies are set with respect to <code>httponly </code>and <code>samesite</code>:</p>
<pre><code>set_cookie(
    response,
    &quot;access_token&quot;,
    access_token.header_payload,
    httponly=False,
    domain=request.app.config.COOKIE_DOMAIN,
    exp=access_token_exp,
)
set_cookie(
    response,
    &quot;access_token&quot;,
    access_token.signature,
    httponly=True,
    domain=request.app.config.COOKIE_DOMAIN,
    exp=access_token_exp,
)
set_cookie(
    response,
    &quot;refresh_token&quot;,
    refresh_token,
    httponly=True,
    samesite=&quot;strict&quot;,
    domain=request.app.config.COOKIE_DOMAIN,
    exp=refresh_token_exp,
)</code></pre></li>
</ol>
<p>We now have all the building blocks needed to build out our endpoints and our decorator. It is time for you to put your skills to the test and try and piece together the endpoints from the knowledge in this chapter. Don’t worry, there is a full solution in the GitHub repository, including the <code>set_cookie</code> convenience function used above.</p>
<p>A bit of self-promotion here: one of the first libraries I built for Sanic was a package to handle authentication and authorization for Sanic using JWTs. It allows for handling this split token approach and includes all other sorts of goodies and protections. If you do not want to roll your own solution, it has become widely adopted within the community. Check out my personal GitHub page for more details: <a href="https://github.com/ahopkins/sanic-jwt">https://github.com/ahopkins/sanic-jwt</a>.</p>
</section>
</section>
</section>
<section id="summary-6" class="level2" data-number="8.5">
<h2 data-number="8.5">Summary</h2>
<p>This Chapter has covered a <em>lot</em> of material. Even still, it has only scratched the surface of Web security. To truly raise the security bar, you should continue to do some of your own research. There are some other common headers like: <code>Content-Security-Policy</code>, <code>X-Content-Type-Options</code>, and <code>X-Frame-Options</code> that we did not have a chance to cover. Nonetheless, with the information you have gathered here, and with your own self-ingenuity, you should be able to implement—for example—a <code>Content-Security-Policy</code> that works for your application. The first place I look for this kind of material is Mozilla’s MDN website: <a href="https://developer.mozilla.org/en-US/.">https://developer.mozilla.org/en-US/.</a> I highly recommend you visit it to learn about web standards and practices.</p>
<p>So, what did we cover?</p>
<p>You should be familiar with the concept of same-origin, and how to develop a CORS policy to defeat both CSRF and XSS attacks. We also looked at three common schemes for authenticating users: API keys, session tokens, and JWT. And, of course, by looking through all of the examples you should be learning how to use the Sanic tool belt to craft your own unique and <em>obvious</em> patterns to serve your applications’ needs. At this point in the book, we really have covered most of what you will need in order to build a web application. You should be familiar with all of the basic building blocks, and start to have some ideas on how to piece them together to build solutions.</p>
<p>What we are missing now is knowledge on how to deploy our applications and run them. This is what we will cover next.</p>
</section>
</section>
</body>
</html>
