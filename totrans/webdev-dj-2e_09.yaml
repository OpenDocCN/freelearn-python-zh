- en: 9\. Sessions and Authentication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 会话和认证
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter begins with a brief introduction to **middleware** before delving
    into the concepts of **authentication models** and **session engines**. You will
    implement Django's authentication model to restrict permissions to only a specific
    set of users. Then, you will see how you can leverage Django authentication to
    provide a flexible approach to application security. After that, you will learn
    how Django supports multiple session engines to retain user data. By the end of
    the chapter, you will be proficient at using sessions to retain information on
    past user interactions and to maintain user preferences for when pages are revisited.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先简要介绍**中间件**，然后深入探讨**认证模型**和**会话引擎**的概念。您将实现Django的认证模型以限制权限仅限于特定用户集。然后，您将了解如何利用Django认证提供灵活的应用安全方法。之后，您将学习Django如何支持多个会话引擎以保留用户数据。到本章结束时，您将熟练使用会话来保留过去用户交互的信息，并在页面被重新访问时维护用户偏好。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Up until now, we have used Django to develop dynamic applications that allow
    users to interact with application models, but we have not attempted to secure
    these applications from unwanted use. For example, our Bookr app allows unauthenticated
    users to add reviews and upload media. This is a critical security issue for any
    online web app as it leaves the site open to the posting of spam or other inappropriate
    material and the vandalism of existing content. We want the creation and modification
    of content to be strictly limited to authenticated users who have registered with
    the site.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用Django开发允许用户与应用模型交互的动态应用，但我们尚未尝试保护这些应用免受未经授权的使用。例如，我们的Bookr应用允许未经认证的用户添加评论和上传媒体。这对任何在线Web应用都是一个关键的安全问题，因为它使网站容易受到垃圾邮件或其他不适当内容的发布以及现有内容的破坏。我们希望内容的创建和修改严格限于已在网站上注册的认证用户。
- en: The **authentication app** supplies Django with the models for representing
    users, groups, and permissions. It also provides middleware, utility functions,
    decorators, and mixins that help integrate user authentication into our apps.
    Furthermore, the authentication app allows grouping and naming certain sets of
    users.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证应用**为Django提供了表示用户、组和权限的模型。它还提供了中间件、实用函数、装饰器和混入，这些可以帮助将用户认证集成到我们的应用中。此外，认证应用允许对某些用户集进行分组和命名。'
- en: 'In *Chapter 4*, *Introduction to Django Admin*, we used the Admin app to create
    a help desk user group with the permissions "Can view log entry," "Can view permission,"
    "Can change user," and "Can view user." Those permissions could be referenced
    in our code using their corresponding codenames: `view_logentry`, `view_permissions`,
    `change_user`, and `view_user`. In this chapter, we will learn how to customize
    Django behavior based on specific user permissions.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4章*，*Django Admin简介*中，我们使用Admin应用创建了一个帮助台用户组，具有“可以查看日志条目”、“可以查看权限”、“可以更改用户”和“可以查看用户”的权限。这些权限可以通过它们对应的名称引用：`view_logentry`、`view_permissions`、`change_user`和`view_user`。在本章中，我们将学习如何根据特定的用户权限自定义Django行为。
- en: Permissions are directives that delineate what is permissible by classes of
    users. Permissions can be assigned either to groups or directly to individual
    users. From an administrative point of view, it is cleaner to assign permissions
    to groups. Groups make it easier to model roles and organizational structures.
    If a new permission is created, it is less time-consuming to modify a few groups
    than to remember to assign it to a subset of users.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 权限是定义用户类别可以做什么的指令。权限可以分配给组或直接分配给单个用户。从管理角度来看，将权限分配给组更清晰。组使得建模角色和组织结构更容易。如果创建了一个新的权限，修改几个组比记住将其分配给用户子集要节省时间。
- en: We are already familiar with creating users and groups and assigning permissions
    using several methods, such as the option of instantiating users and groups through
    the model using scripts and the convenience of creating them through the Django
    Admin app. The authentication app also offers us programmatic ways of creating
    and deleting users, groups, and permissions and assigning relations between them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了使用多种方法创建用户和组以及分配权限，例如通过脚本使用模型实例化用户和组，以及通过Django Admin应用创建它们的便利性。认证应用还提供了创建和删除用户、组和权限以及分配它们之间关系的编程方式。
- en: As we go through this chapter, we'll learn how to use authentication and permissions
    to implement application security and how to store user-specific data to customize
    the user's experience. This will help us secure the `bookr` project from unauthorized
    content changes and make it contextually relevant for different types of users.
    Adding this basic security to our `bookr` project is crucial before we consider
    deploying it on the internet.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入本章，我们将学习如何使用身份验证和权限来实现应用安全，以及如何存储特定于用户的数据以定制用户的体验。这将帮助我们保护 `bookr` 项目免受未经授权的内容更改，并使其对不同类型的用户具有上下文相关性。在我们考虑将其部署到互联网之前，向
    `bookr` 项目添加这种基本安全措施至关重要。
- en: Authentication, as well as session management (which we'll learn about in the
    *Sessions* section), is handled by something known as a `bookr` project, let's
    learn a bit about this middleware stack and its modules.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证以及会话管理（我们将在 *会话* 部分中学习），由一个名为 `bookr` 项目的组件处理，让我们了解一下这个中介栈及其模块。
- en: Middleware
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中介模块
- en: In *Chapter 3*, *URL Mapping, Views, and Templates*, we discussed Django's implementation
    of the request/response process along with its view and rendering functionality.
    In addition to these, another feature that plays an extremely important role when
    it comes to Django's core web processing is **middleware**. Django's middleware
    refers to a variety of software components that intervene in this request/response
    process to integrate important functionalities such as security, session management,
    and authentication.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 3 章*，*URL 映射、视图和模板* 中，我们讨论了 Django 对请求/响应过程的实现，以及其视图和渲染功能。除了这些之外，另一个在 Django
    核心网络处理中起着极其重要作用的特性是 **中介**。Django 的中介指的是各种软件组件，它们介入这个请求/响应过程以集成重要的功能，如安全、会话管理和身份验证。
- en: So, when we write a view in Django, we don't have to explicitly set a series
    of important security features in the response header. These additions to the
    response object are automatically made by the `SecurityMiddleware` instance after
    the view returns its response. As middleware components wrap the view and perform
    a series of pre-processes on the request and post-processes on the response, the
    view is not cluttered with a lot of repetitive code and we can concentrate on
    coding application logic rather than worrying about low-level server behavior.
    Rather than building these functionalities into the Django core, Django's implementation
    of a middleware stack allows these components to be both optional and replaceable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们用 Django 编写视图时，我们不需要在响应头中显式设置一系列重要的安全功能。这些添加到响应对象中的功能是由 `SecurityMiddleware`
    实例在视图返回其响应后自动完成的。由于中介组件封装视图并在请求上执行一系列预处理以及在响应上执行一系列后处理，因此视图不会充斥着大量重复的代码，我们可以专注于编写应用逻辑而不是担心低级服务器行为。而不是将这些功能构建到
    Django 核心中，Django 的中介栈实现允许这些组件既可选又可替换。
- en: Middleware Modules
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中介模块
- en: 'When we run the `startproject` subcommand, a default list of middleware modules
    is added to the `MIDDLEWARE` variable in the `<project>/settings.py` file, as
    follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `startproject` 子命令时，默认的中介模块列表会被添加到 `<project>/settings.py` 文件中的 `MIDDLEWARE`
    变量中，如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is a minimal middleware stack that is suitable for most Django applications.
    The following list elaborates on the general purpose of each module:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个适合大多数 Django 应用的最小化中介栈。以下列表详细说明了每个模块的通用目的：
- en: '`SecurityMiddleware` provides common security enhancements such as handling
    SSL redirects and adding response headers to prevent common hacks.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SecurityMiddleware` 提供了常见的安全增强功能，例如处理 SSL 重定向和添加响应头以防止常见的攻击。'
- en: '`SessionMiddleware` enables session support and seamlessly associates a stored
    session with the current request.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SessionMiddleware` 启用会话支持，并无缝地将存储的会话与当前请求关联起来。'
- en: '`CommonMiddleware` implements a lot of miscellaneous features, such as rejecting
    requests from the `DISALLOWED_USER_AGENTS` list, implementing URL rewrite rules,
    and setting the `Content-Length` header.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommonMiddleware` 实现了许多杂项功能，例如拒绝来自 `DISALLOWED_USER_AGENTS` 列表的请求，实现 URL 重写规则，并设置
    `Content-Length` 头。'
- en: '`CsrfViewMiddleware` adds protection against **Cross-Site Request Forgery** (**CSRF**).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CsrfViewMiddleware` 添加了对 **跨站请求伪造**（**CSRF**）的保护。'
- en: '`AuthenticationMiddleware` adds the `user` attribute to the `request` object.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthenticationMiddleware` 将 `user` 属性添加到 `request` 对象中。'
- en: '`MessageMiddleware` adds "flash" message support.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MessageMiddleware` 添加了 "闪存" 消息支持。'
- en: '`XFrameOptionsMiddleware` protects against `X-Frame-Options` header clickjacking
    attacks.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XFrameOptionsMiddleware`可以防止`X-Frame-Options`头部点击劫持攻击。'
- en: The middleware modules are loaded in the order that they appear in the `MIDDLEWARE`
    list. This makes sense because we want to call the middleware that deals with
    initial security issues first so that dangerous requests are rejected before further
    processing occurs. Django also comes with several other middleware modules that
    perform important functions, such as using `gzip` file compression, redirect configuration,
    and web cache configuration.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件模块按照它们在`MIDDLEWARE`列表中出现的顺序加载。这样做是有道理的，因为我们希望首先调用处理初始安全问题的中间件，以便在进一步处理之前拒绝危险请求。Django还附带了一些执行重要功能的其他中间件模块，例如使用`gzip`文件压缩、重定向配置和网页缓存配置。
- en: This chapter is devoted to discussing two important aspects of stateful application
    development that are implemented as middleware components – `SessionMiddleware`
    and `AuthenticationMiddleware`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于讨论作为中间件组件实现的状态感知应用程序开发的两个重要方面——`SessionMiddleware`和`AuthenticationMiddleware`。
- en: The `process_request` method of `SessionMiddleware` adds a `session` object
    as an attribute of the `request` object. The `process_request` method of `AuthenticationMiddleware`
    adds a `user` object as an attribute of the `request` object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`SessionMiddleware`的`process_request`方法将一个`session`对象作为`request`对象的属性添加。`AuthenticationMiddleware`的`process_request`方法将一个`user`对象作为`request`对象的属性添加。'
- en: 'It is possible to write a Django project without these layers of the middleware
    stack if a project does not require user authentication or a means of preserving
    the state of individual interactions. However, most of the default middleware
    plays an important role in application security. If you don''t have a good reason
    for changing the middleware components, it is best to maintain these initial settings.
    In fact, the Admin app requires `SessionMiddleware`, `AuthenticationMiddleware`,
    and `MessageMiddleware` to run, and the Django server will throw errors such as
    these if the Admin app is installed without them:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目不需要用户认证或保存单个交互状态的方法，则可以编写不包含这些中间件堆栈层的Django项目。然而，大多数默认中间件在应用程序安全方面都发挥着重要作用。如果没有充分的理由更改中间件组件，最好是保持这些初始设置。实际上，Admin应用需要`SessionMiddleware`、`AuthenticationMiddleware`和`MessageMiddleware`才能运行，如果Admin应用安装了这些中间件，Django服务器将抛出如下错误：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we know about the middleware modules, let's look at one approach to
    enable authentication in our project using the authentication app's views and templates.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了中间件模块，让我们看看一种使用认证应用视图和模板在我们的项目中启用认证的方法。
- en: Implementing Authentication Views and Templates
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现认证视图和模板
- en: We have already encountered the login form on the Admin app in *Chapter 4*,
    *Introduction to Django Admin*. This is the authentication entry point for staff
    users who have access to the Admin app. We also need to create a login capability
    for ordinary users who want to give book reviews. Fortunately, the authentication
    app comes with the tools to make this possible.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在*第4章，Django Admin简介*中遇到了登录表单。这是访问Admin应用的员工用户的认证入口点。我们还需要为想要撰写书评的普通用户创建登录功能。幸运的是，认证应用提供了实现这一功能的工具。
- en: As we work through the forms and views of the authentication app, we encounter
    a lot of flexibility in its implementation. We are free to implement our own login
    pages, define either very simple or fine-grained security policies at the view
    level, and authenticate against external authorities.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们处理认证应用的表单和视图的过程中，我们遇到了其在实现上的很多灵活性。我们可以自由地实现自己的登录页面，在视图级别定义非常简单或细粒度的安全策略，并对外部权威机构进行认证。
- en: The authentication app exists to accommodate a lot of different approaches to
    authentication so that Django doesn't rigidly enforce a single mechanism. For
    a first-time user encountering the documentation, this can be quite bewildering.
    For the most part in this chapter, we will follow Django's defaults, but some
    of the important configuration options will be noted.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 认证应用旨在适应许多不同的认证方法，以便Django不会严格强制执行单一机制。对于第一次遇到文档的用户来说，这可能会相当令人困惑。在本章的大部分内容中，我们将遵循Django的默认设置，但会注意一些重要的配置选项。
- en: A Django project's `settings` object contains attributes for login behavior.
    `LOGIN_URL` specifies the URL of the login page. `'/accounts/login/'` is the default
    value. `LOGIN_REDIRECT_URL` specifies the path where a successful login is redirected
    to. The default path is `'/accounts/profile/'`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Django项目的`settings`对象包含登录行为的属性。`LOGIN_URL`指定登录页面的URL。默认值是`'/accounts/login/'`。`LOGIN_REDIRECT_URL`指定成功登录后重定向的路径。默认路径是`'/accounts/profile/'`。
- en: The authentication app supplies standard forms and views for carrying out typical
    authentication tasks. The forms are located in `django.contrib.auth.forms` and
    the views are in `django.contrib.auth.views`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 认证应用提供执行典型认证任务的标准表单和视图。表单位于`django.contrib.auth.forms`，视图位于`django.contrib.auth.views`。
- en: 'The views are referenced by these URL patterns present in `django.contrib.auth.urls`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 视图通过`django.contrib.auth.urls`中存在的这些URL模式进行引用：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If this style of views looks unfamiliar, it is because they are class-based
    views rather than the function-based views that we have previously encountered.
    We will learn more about class-based views in *Chapter 11*, *Advanced Templates
    and Class-Based Views*. For now, note that the authentication app makes use of
    class inheritance to group the functionality of views and prevent a lot of repetitive
    coding.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种视图风格看起来不熟悉，那是因为它们是基于类的视图，而不是我们之前遇到过的基于函数的视图。我们将在*第11章*，*高级模板和基于类的视图*中了解更多关于基于类的视图。现在，请注意，认证应用利用类继承来分组视图的功能，以避免大量的重复编码。
- en: If we want to maintain the default URLs and views that are presupposed by the
    authentication app and Django settings, we can include the authentication app's
    URLs in our project's `urlpatterns`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想保持认证应用和Django设置预设的默认URL和视图，我们可以在项目的`urlpatterns`中包含认证应用的URL。
- en: 'By taking this approach, we have saved a lot of work. We need only include
    the authentication app''s URLs to our `<project>/urls.py` file and assign it the
    `''accounts''` namespace. Designating this namespace ensures that our reverse
    URLs correspond to the default template values of the views:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采取这种方法，我们节省了大量工作。我们只需要将认证应用的URL包含到我们的`<project>/urls.py`文件中，并分配给它`'accounts'`命名空间。指定这个命名空间确保我们的反向URL与视图的默认模板值相对应：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Though the authentication app comes with its own forms and views, it lacks the
    templates needed to render these components as HTML. *Figure 9.1* lists the templates
    that we require to implement the authentication functionality in our project.
    Fortunately, the Admin app does implement a set of templates that we can utilize
    for our purposes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然认证应用自带了其自己的表单和视图，但它缺少将这些组件渲染为HTML所需的模板。*图9.1*列出了我们为实现项目中认证功能所需的模板。幸运的是，管理应用实现了一套模板，我们可以用于我们的目的。
- en: We could just copy the template files from the Django source code in the `django/contrib/admin/templates/registration`
    directory and `django/contrib/admin/templates/admin/login.html` to our project's
    `templates/registration` directory.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接从Django源代码的`django/contrib/admin/templates/registration`目录和`django/contrib/admin/templates/admin/login.html`复制模板文件到我们的项目`templates/registration`目录。
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'When we say Django source code, it''s the directory where your Django installation
    resides. If you installed Django in a virtual environment (as detailed in the
    *Preface*), you can find these template files at the following path: `<name of
    your virtual environment>/lib/python3.X/site-packages/django/contrib/admin/templates/registration/`.
    Provided your virtual environment is activated and Django is installed in it,
    you can also retrieve the complete path to the `site-packages` directory by running
    the following command in a terminal: `python -c "import sys; print(sys.path)"`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说Django源代码时，指的是你的Django安装所在的目录。如果你在虚拟环境中安装了Django（如*前言*中详细说明），你可以找到这些模板文件在以下路径：`<你的虚拟环境名称>/lib/python3.X/site-packages/django/contrib/admin/templates/registration/`。如果你的虚拟环境已激活且Django已安装在其中，你还可以通过在终端运行以下命令来检索`site-packages`目录的完整路径：`python
    -c "import sys; print(sys.path)"`。
- en: '![Figure 9.1: Default paths for authentication templates'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1：认证模板的默认路径'
- en: '](img/B15509_09_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_09_01.jpg)'
- en: 'Figure 9.1: Default paths for authentication templates'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：认证模板的默认路径
- en: Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We need only copy the templates that are dependencies for the views and should
    avoid copying the `base.html` or `base_site.html` files.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要复制视图的依赖模板，并应避免复制`base.html`或`base_site.html`文件。
- en: 'This gives a promising result at first, but as they stand, the admin templates
    do not meet our precise needs as we can see from the login page (*Figure 9.2*):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这一开始给出了一个有希望的结果，但正如我们所看到的，管理员模板并不完全符合我们的精确需求，正如登录页面（*图9.2*）所示：
- en: '![Figure 9.2: A first attempt at a user login screen'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2：用户登录屏幕的第一次尝试'
- en: '](img/B15509_09_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_09_02.jpg]'
- en: 'Figure 9.2: A first attempt at a user login screen'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：用户登录屏幕的第一次尝试
- en: 'As these authentication pages inherit from the Admin app''s `admin/base_site.html`
    template, they follow the style of the Admin app. We would prefer for these pages
    to follow the style of the `bookr` project that we have developed. We can do this
    by following these three steps on each Django template that we have copied from
    the Admin app to our project:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些认证页面继承自Admin应用的`admin/base_site.html`模板，它们遵循Admin应用的风格。我们更希望这些页面遵循我们开发的`bookr`项目的风格。我们可以通过在每个从Admin应用复制到我们项目的Django模板上遵循以下三个步骤来实现这一点：
- en: The first change that needs to be made is to replace the `{% extends "admin/base_site.html"
    %}` tag with `{% extends "base.html" %}`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要做的第一个更改是将`{% extends "admin/base_site.html" %}`标签替换为`{% extends "base.html"
    %}`。
- en: Given that `template/base.html` only contains the following block definitions
    – `title`, `brand`, and `content` – we should remove all other block substitutions
    from our templates in the `bookr` folder. We are not using the content from the
    `userlinks` and `breadcrumbs` blocks in our app, so these blocks can be removed
    entirely.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`template/base.html`仅包含以下块定义——`title`、`brand`和`content`——因此我们应该从`bookr`文件夹中的模板中移除所有其他块替换。在我们的应用中，我们没有使用`userlinks`和`breadcrumbs`块的内容，因此这些块可以被完全移除。
- en: Some of these blocks, such as `content_title` and `reset_link`, contain HTML
    content that is relevant to our application. We should strip the block from around
    this HTML and put it inside the content block.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中一些块，如`content_title`和`reset_link`，包含与我们的应用相关的HTML内容。我们应该从这些HTML内容周围移除块，并将其放入内容块中。
- en: 'For example, the `password_change_done.html` template contains an extensive
    number of blocks:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，`password_change_done.html`模板包含大量的块：
- en: '[PRE4]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It will be simplified to this template in the `bookr` project:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`bookr`项目中，它将被简化为以下模板：
- en: '[PRE5]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Likewise, there are reverse URL patterns that need to change to reflect the
    current path, so `{% url 'login' %}` gets replaced by `{% url 'accounts:login'
    %}`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，需要更改反向URL模式以反映当前路径，因此`{% url 'login' %}`被替换为`{% url 'accounts:login' %}`。
- en: Given these considerations, the next exercise will focus on transforming the
    Admin app's login template into a login template for the `bookr` project.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些因素，下一个练习将专注于将Admin应用的登录模板转换为`bookr`项目的登录模板。
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `i18n` module is used for creating multilingual content. If you intend to
    develop multilingual content for your website, leave the `i18n` import, `trans`
    tags, and `transblock` statements in the templates. For brevity, we will not be
    covering those in detail in this chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`i18n`模块用于创建多语言内容。如果您打算为您的网站开发多语言内容，请在模板中保留`i18n`导入、`trans`标签和`transblock`语句。为了简洁，我们将在本章中不详细讨论这些内容。'
- en: 'Exercise 9.01: Repurposing the Admin App Login Template'
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.01：重新利用Admin应用登录模板
- en: 'We started this chapter without a login page for our project. By adding the
    URL patterns for authentication and copying the templates from the Admin app to
    our own project, we can implement the functionality of a login page. But this
    login page is not satisfactory as it is directly copied from the Admin app and
    is disconnected from the Bookr design. In this exercise, we will follow the steps
    needed to repurpose the Admin app''s login template for our project. The new login
    template will need to inherit its style and format directly from the `bookr` project''s
    `templates/base.html`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在项目中没有登录页面的情况下开始了这一章。通过添加认证的URL模式并从Admin应用复制模板到我们的项目，我们可以实现登录页面的功能。但是，这个登录页面并不令人满意，因为它直接从Admin应用复制而来，并且与Bookr设计不匹配。在这个练习中，我们将遵循将Admin应用的登录模板重新用于我们项目的步骤。新的登录模板需要直接从`bookr`项目的`templates/base.html`继承其样式和格式：
- en: Create a directory inside your project for `templates/registration`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目中创建一个名为`templates/registration`的目录。
- en: 'The Admin login template is located in the Django source directory at the `django/contrib/admin/templates/admin/login.html`
    path. It begins with an `extends` tag, a `load` tag, the importing of the `i18n`
    and `static` modules, and a series of block extensions that over-ride the blocks
    defined in the child template, `django/contrib/admin/templates/admin/base.html`.
    A truncated snippet of the `login.html` file is shown in the following code block:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理员登录模板位于Django源目录的`django/contrib/admin/templates/admin/login.html`路径。它以一个`extends`标签、一个`load`标签、导入`i18n`和`static`模块以及一系列覆盖子模板`django/contrib/admin/templates/admin/base.html`中定义的块的块扩展开始。以下是一个`login.html`文件的截断片段：
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Copy this Admin login template, `django/contrib/admin/templates/admin/login.html`,
    into `templates/registration` and begin editing the file using PyCharm.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此管理员登录模板`django/contrib/admin/templates/admin/login.html`复制到`templates/registration`，然后使用PyCharm开始编辑文件。
- en: 'As the login template you are editing is located at `templates/registration/login.html`
    and extends the base template (`templates/base.html`), replace the argument of
    the `extends` tag at the top of `templates/registration/login.html`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于您正在编辑的登录模板位于`templates/registration/login.html`，并且扩展了基本模板（`templates/base.html`），因此请替换`templates/registration/login.html`顶部`extends`标签的参数：
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We don''t need most of the contents of this file. Just retain the `content`
    block, which contains the login form. The remainder of the template will consist
    of loading the `i18n` and `static` tag libraries:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要这个文件的大部分内容。只需保留包含登录表单的`content`块。模板的其余部分将包括加载`i18n`和`static`标签库：
- en: '[PRE8]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now you must replace the paths and reverse URL patterns in `templates/registration/login.html`
    with ones that are appropriate to your project. As you don''t have an `app_path`
    variable defined in your template, it needs to be replaced with the reverse URL
    for the login, `''accounts:login''`. So, consider the following line:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您必须将`templates/registration/login.html`中的路径和反向URL模式替换为适合您项目的模式。由于您在模板中没有定义`app_path`变量，它需要被替换为登录的反向URL，即`'accounts:login'`。因此，请考虑以下行：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This line changes as follows:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一行将按以下方式更改：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is no `'admin_password_reset'` defined in your project paths, so it will
    be replaced with `'accounts:password_reset'`.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在您的项目路径中没有定义`'admin_password_reset'`，因此它将被替换为`'accounts:password_reset'`。
- en: 'Consider the following line:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑以下行：
- en: '[PRE11]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This line changes as follows:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一行将按以下方式更改：
- en: '[PRE12]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Your login template will look as follows:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的登录模板将如下所示：
- en: '[PRE13]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To use the standard Django authentication views, we must add the URLs mapping
    to them. Open the `urls.py` file in the `bookr` project directory, then add this
    URL pattern:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用标准的Django认证视图，我们必须将URL映射添加到它们中。打开`bookr`项目目录中的`urls.py`文件，然后添加以下URL模式：
- en: '[PRE14]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now when you visit the login link at `http://127.0.0.1:8000/accounts/login/`,
    you will see this page:![Figure 9.3: The Bookr login page'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在当您访问`http://127.0.0.1:8000/accounts/login/`的登录链接时，您将看到这个页面：![图9.3：Bookr登录页面
- en: '](img/B15509_09_03.jpg)'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.3：Bookr登录页面](img/B15509_09_03.jpg)'
- en: 'Figure 9.3: The Bookr login page'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：Bookr登录页面
- en: By completing this exercise, you have created the template required for non-admin
    authentication in your project.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您已经创建了项目所需的非管理员认证模板。
- en: Note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before you proceed, you''ll need to make sure the rest of the templates in
    the `registration` directory follow the `bookr` project''s style; that is, they
    inherit from the Admin app''s `admin/base_site.html` template. You''ve already
    seen this done with `password_change_done.html` and the `login.html` templates.
    Go ahead and apply what you''ve learned in this exercise (and the section before
    it) to the rest of the files in the `registration` directory. Alternatively, you
    may download the modified files from the GitHub repo: [http://packt.live/3s4R5iU](http://packt.live/3s4R5iU).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在您继续之前，您需要确保`registration`目录中的其余模板遵循`bookr`项目的风格；也就是说，它们继承自管理员应用的`admin/base_site.html`模板。您已经看到了`password_change_done.html`和`login.html`模板是如何做到这一点的。现在将您在这个练习（以及之前的章节）中学到的知识应用到`registration`目录中的其余文件上。或者，您也可以从GitHub仓库下载修改后的文件：[http://packt.live/3s4R5iU](http://packt.live/3s4R5iU)。
- en: Password Storage in Django
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django中的密码存储
- en: 'Django does not store passwords in plain text form in the database. Instead,
    passwords are digested with a hashing algorithm, such as **PBKDF2/SHA256**, **BCrypt**/**SHA256**,
    or **Argon2**. As hashing algorithms are a one-way transformation, this prevents
    a user''s password from being decrypted from the hash stored in the database.
    This often comes as a surprise to users who expect a system administrator to retrieve
    their forgotten password, but it is best practice in security design. So, if we
    query the database for the password, we will see something like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Django不会以纯文本形式在数据库中存储密码。相反，密码会与哈希算法（如**PBKDF2/SHA256**、**BCrypt/**SHA256**或**Argon2**）进行散列。由于哈希算法是一种单向转换，这可以防止从数据库中存储的哈希中解密用户的密码。这对于期望系统管理员检索他们忘记的密码的用户来说可能是个惊喜，但在安全设计中这是最佳实践。因此，如果我们查询数据库以获取密码，我们将看到如下内容：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The components of this string are `<algorithm>$<iterations>$<salt>$<hash>`.
    As several hashing algorithms have been compromised over time and we sometimes
    need to work with mandated security requirements, Django is flexible enough to
    accommodate new algorithms and can maintain data encrypted in multiple algorithms.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此字符串的组成部分是`<algorithm>$<iterations>$<salt>$<hash>`。由于随着时间的推移，几个哈希算法已被破坏，并且我们有时需要与强制性的安全要求一起工作，Django足够灵活，可以适应新的算法，并可以维护使用多种算法加密的数据。
- en: The Profile Page and the request.user Object
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人资料页面和request.user对象
- en: When a login is successful, the login view redirects to `/accounts/profile`.
    However, this path is not included in the existing `auth.url` nor does the authentication
    app provide a template for it. To avoid a `Page not Found` error, a view and an
    appropriate URL pattern are required.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当登录成功时，登录视图将重定向到`/accounts/profile`。然而，此路径未包含在现有的`auth.url`中，认证应用程序也没有提供相应的模板。为了避免“页面未找到”错误，需要一个视图和适当的URL模式。
- en: Each Django request has a `request.user` object. If the request is made by an
    unauthenticated user, `request.user` will be an `AnonymousUser` object. If the
    request is made by an authenticated user, then `request.user` will be a `User`
    object. This makes it easy to retrieve personalized user information in a Django
    view and render it in a template.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Django请求都有一个`request.user`对象。如果请求是由未经认证的用户发起的，则`request.user`将是一个`AnonymousUser`对象。如果请求是由认证用户发起的，则`request.user`将是一个`User`对象。这使得在Django视图中检索个性化用户信息并在模板中渲染它变得容易。
- en: In the next exercise, we will add a profile page to our `bookr` project.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将向我们的`bookr`项目添加一个个人资料页面。
- en: 'Exercise 9.02: Adding a Profile Page'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.02：添加个人资料页面
- en: 'In this exercise, we will add a profile page to our project. To do so, we need
    to include the path to it in our URL patterns and also include it in our views
    and templates. The profile page will simply display the following attributes from
    the `request.user` object:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将向我们的项目添加一个个人资料页面。为此，我们需要在URL模式中包含其路径，并在我们的视图和模板中包含它。个人资料页面将简单地显示`request.user`对象中的以下属性：
- en: '`username`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username`'
- en: '`first_name` and `last_name`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first_name`和`last_name`'
- en: '`date_joined`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date_joined`'
- en: '`email`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`'
- en: '`last_login`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last_login`'
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'Add `bookr/views.py` to the project. It needs a trivial profile function to
    define our view:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`bookr/views.py`添加到项目中。它需要一个简单的个人资料函数来定义我们的视图：
- en: '[PRE16]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the templates folder of your main `bookr` project, create a new file called
    `profile.html`. In this template, the attributes of the `request.user` object
    can easily be referenced by using a notation such as `{{ request.user.username
    }}`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主`bookr`项目的模板文件夹中，创建一个名为`profile.html`的新文件。在这个模板中，可以使用类似`{{ request.user.username
    }}`的表示法轻松引用`request.user`对象的属性：
- en: '[PRE17]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Also, we added a block containing profile details of the user. More importantly,
    we made sure that `profile.html` extends `base.html`.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我们还添加了一个包含用户个人资料详情的块。更重要的是，我们确保`profile.html`扩展了`base.html`。
- en: 'Finally, this path needs to be added to the top of the `urlpatterns` list in
    `bookr/urls.py`. First, import the new views and then add a path linking the URL
    `accounts/profile/` to `bookr.views.profile`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，需要将此路径添加到`bookr/urls.py`中的`urlpatterns`列表顶部。首先，导入新的视图，然后添加一个将URL `accounts/profile/`链接到`bookr.views.profile`的路径：
- en: '[PRE18]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Figure 9:4: Alice visits her user profile'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：爱丽丝访问她的用户资料
- en: We've seen how we can redirect a user to their profile page, once they've successfully
    logged in. Let's now discuss how we can give content access to specific users
    only.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何将用户重定向到他们的个人资料页面，一旦他们成功登录。现在让我们讨论如何仅向特定用户提供内容访问。
- en: Authentication Decorators and Redirection
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证装饰器和重定向
- en: Now that we have learned how to allow ordinary users to log in to our project,
    we can discover how to restrict content to authenticated users. The authentication
    module comes with some useful decorators that can be used to secure views according
    to the current user's authentication or access.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何允许普通用户登录到我们的项目，我们可以发现如何将内容限制为认证用户。认证模块附带了一些有用的装饰器，可以根据当前用户的认证或访问权限来保护视图。
- en: 'Unfortunately, if, say, a user named Alice was to log out of Bookr, the profile
    page would still render and display empty details. Instead of this happening,
    it would be preferable for any unauthenticated visitor to be directed to the login
    screen:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果比如说用户Alice要从Bookr注销，资料页面仍然会渲染并显示空详情。为了避免这种情况，我们更希望任何未经认证的访客被引导到登录界面：
- en: '![Figure 9.5: An unauthenticated user visits a user profile'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5：一个未认证的用户访问用户资料'
- en: '](img/B15509_09_05.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_09_05.jpg)'
- en: 'Figure 9.5: An unauthenticated user visits a user profile'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：一个未认证的用户访问用户资料
- en: 'The authentication app comes with useful decorators for adding authentication
    behavior to Django views. In this situation of securing our profile view, we can
    use the `login_required` decorator:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 认证应用附带了一些有用的装饰器，可以用于向Django视图添加认证行为。在这种情况下，为了保护我们的资料视图，我们可以使用`login_required`装饰器：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now if an unauthenticated user visits the `/accounts/profile` URL, they will
    be redirected to `http://localhost:8000/accounts/login/?next=/accounts/profile/`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果一个未认证的用户访问`/accounts/profile` URL，他们将被重定向到`http://localhost:8000/accounts/login/?next=/accounts/profile/`。
- en: 'This URL takes the user to the login URL. The `next` parameter in the `GET`
    variables tells the login view where to redirect to after a successful login.
    The default behavior is to redirect back to the current view, but this can be
    overridden by specifying the `login_url` argument to the `login_required` decorator.
    For example, if we had some need to redirect to a different page after login,
    we could have explicitly stated it in the decorator call like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个URL会将用户带到登录URL。`GET`变量中的`next`参数告诉登录视图在登录成功后重定向到哪里。默认行为是重定向回当前视图，但可以通过指定`login_required`装饰器的`login_url`参数来覆盖这个行为。例如，如果我们需要登录后重定向到不同的页面，我们可以在装饰器调用中明确指出，如下所示：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we had rewritten our login view to expect the redirection URL to be specified
    in a different URL argument to `''next''`, we could explicate this in the decorator
    call with the `redirect_field_name` argument:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重写了登录视图，使其期望重定向URL在`'next'`参数之外的其他URL参数中指定，我们可以在装饰器调用中使用`redirect_field_name`参数来明确这一点：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are often situations where a URL should be restricted to users or groups
    holding a specific condition. Consider the case where we have a page for staff
    users to view any user profile. We don''t want this URL to be accessible to all
    users, so we want to limit this URL to users or groups with the `''view_user''`
    permission and to forward the unauthorized requests to the login URL:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 经常会有这样的情况，一个URL应该限制给满足特定条件的用户或组。考虑这样一个情况，我们有一个页面供员工用户查看任何用户资料。我们不希望这个URL对所有用户都可用，因此我们希望将这个URL限制为具有`'view_user'`权限的用户或组，并将未经授权的请求转发到登录URL：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So with this decorator applied on our `user_profile` view, an unauthorized user
    visiting `http://localhost:8000/accounts/users/123/profile/` would be redirected
    to `http://localhost:8000/accounts/login/?next=/accounts/users/123/profile/`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的`user_profile`视图上应用了这个装饰器后，访问`http://localhost:8000/accounts/users/123/profile/`的未经授权的用户将被重定向到`http://localhost:8000/accounts/login/?next=/accounts/users/123/profile/`。
- en: 'Sometimes, though, we need to structure more subtle conditional permissions
    that don''t fall into the scope of these two directors. For this purpose, Django
    provides a custom decorator that takes an arbitrary function as an argument. The
    `user_passes_test` decorator requires a `test_func` argument:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们需要构建更微妙的条件权限，这些权限不适用于这两个导演。为此，Django提供了一个自定义装饰器，它接受一个任意函数作为参数。`user_passes_test`装饰器需要一个`test_func`参数：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here''s an example where we have a view, `veteran_features`, that is only available
    to users who have been registered on the site for more than a year:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，我们有一个视图`veteran_features`，这个视图只对在网站上注册超过一年的用户可用：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Sometimes the logic in our views cannot be handled with one of these decorators
    and we need to apply the redirect within the control flow of the view. We can
    do this using the `redirect_to_login` helper function. It takes the same arguments
    as the decorators, as shown in the following snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们视图中的逻辑无法用这些装饰器处理，我们需要在视图的控制流中应用重定向。我们可以使用`redirect_to_login`辅助函数来完成此操作。它接受与装饰器相同的参数，如下面的代码片段所示：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Exercise 9.03: Adding Authentication Decorators to the Views'
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.03：向视图添加认证装饰器
- en: 'Having learned about the flexibility of the authentication app''s permission
    and authentication decorators, we will now set about putting them to use in the
    Reviews app. We need to ensure that only authenticated users can edit reviews
    and that only staff users can edit publishers. There are several ways of doing
    this, so we will attempt a few approaches. All the code in these steps is in the
    `reviews/views.py` file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了认证应用的权限和认证装饰器的灵活性之后，我们现在将着手在“评论”应用中使用它们。我们需要确保只有经过认证的用户可以编辑评论，只有工作人员用户可以编辑出版商。有几种实现方式，因此我们将尝试几种方法。这些步骤中的所有代码都在`reviews/views.py`文件中：
- en: 'Your first instinct to solve this problem would be to think that the `publisher_edit`
    method needs an appropriate decorator to enforce that the user has `edit_publisher`
    permission. For this, you could easily do something like this:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决这个问题的第一直觉可能是认为`publisher_edit`方法需要一个适当的装饰器来强制用户具有`edit_publisher`权限。为此，你可以轻松地做如下操作：
- en: '[PRE26]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using this method is fine and it''s one way to add permissions checking to
    a view. You can also use a slightly more complicated but more flexible method.
    Instead of using a permission decorator to enforce permission rights on the `publisher_edit`
    method, you will create a test function that requires a staff user and apply this
    test function to `publisher_edit` with the `user_passes_test` decorator. Writing
    a test function allows more customization on how you validate users'' access rights
    or permissions. If you made changes to your `views.py` file in *step 1*, feel
    free to comment the decorator out (or delete it) and write the following test
    function instead:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这种方法是可以的，这是向视图添加权限检查的一种方法。您还可以使用一种稍微复杂但更灵活的方法。不是使用权限装饰器来强制`publisher_edit`方法的权限，而是创建一个需要工作人员用户的测试函数，并使用`user_passes_test`装饰器将此测试函数应用于`publisher_edit`。编写测试函数允许在验证用户访问权或权限方面进行更多定制。如果您在*步骤1*中对`views.py`文件进行了更改，请随意取消注释（或删除）装饰器，并编写以下测试函数代替：
- en: '[PRE27]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Ensure that login is required for the `review_edit` and `book_media` functions
    by adding the appropriate decorator:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加适当的装饰器来确保`review_edit`和`book_media`函数需要登录：
- en: '[PRE28]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `review_edit` method, add logic to the view that requires that the user
    be either a staff user or the owner of the review. The `review_edit` view controls
    the behavior of both review creation and review updates. The constraint that we
    are developing only applies to the case where an existing review is being updated.
    So, the place to add code is after a `Review` object has been successfully retrieved.
    If the user is not a staff account or the review''s creator doesn''t match the
    current user, we need to raise a `PermissionDenied` error:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`review_edit`方法中，向视图中添加逻辑，要求用户必须是工作人员用户或评论的所有者。`review_edit`视图控制评论创建和评论更新的行为。我们正在开发的约束仅适用于正在更新现有评论的情况。因此，添加代码的位置是在成功检索到`Review`对象之后。如果用户不是工作人员账户或评论的创建者与当前用户不匹配，我们需要抛出一个`PermissionDenied`错误：
- en: '[PRE29]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, when a non-staff user attempts to edit another user''s review, a `Forbidden`
    error will be thrown, as in *Figure 9.6*. In the next section, we will look at
    applying conditional logic in templates so that users aren''t taken to pages that
    they don''t have sufficient permission to access:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，当非工作人员用户尝试编辑其他用户的评论时，将会抛出一个`Forbidden`错误，如*图9.6*所示。在下一节中，我们将探讨在模板中应用条件逻辑，以便用户不会被带到他们没有足够权限访问的页面：
- en: '![Figure 9.6: Access is forbidden to non-staff users'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.6：非工作人员用户无法访问]'
- en: '](img/B15509_09_06.jpg)'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_09_06.jpg)'
- en: 'Figure 9.6: Access is forbidden to non-staff users'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：非工作人员用户无法访问
- en: In this exercise, we have used authentication decorators to secure views in
    a Django app. The authentication decorators that were applied provided a simple
    mechanism to restrict views from users lacking necessary permissions, non-staff
    users, and unauthenticated users. Django's authentication decorators provide a
    robust mechanism that follows Django's role and permission framework, while the
    `user_passes_test` decorator provides an option to develop custom authentication.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了认证装饰器来保护 Django 应用中的视图。所应用的认证装饰器提供了一个简单的机制来限制缺乏必要权限的用户、非工作人员用户和未认证用户的视图。Django
    的认证装饰器提供了一个遵循 Django 角色和权限框架的强大机制，而 `user_passes_test` 装饰器提供了一个开发自定义认证的选项。
- en: Enhancing Templates with Authentication Data
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用认证数据增强模板
- en: 'In *Exercise 9.02*, *Adding a Profile Page*, we saw that we can pass the `request.user`
    object to the template to render the current user''s attributes in the HTML. We
    can also take the approach of giving different template renderings according to
    the user type or permissions held by a user. Consider that we want to add an edit
    link that only appears to staff users. We might apply an `if` condition to achieve
    this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *练习 9.02*，*添加个人资料页面* 中，我们了解到我们可以将 `request.user` 对象传递到模板中，以在 HTML 中渲染当前用户的属性。我们还可以根据用户的类型或权限采取不同的模板渲染方法。假设我们想要添加一个仅对工作人员用户显示的编辑链接。我们可能使用
    `if` 条件来实现这一点：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If we didn't take the time to conditionally render links based on permissions,
    users would have a frustrating experience navigating the application as many of
    the links that they click on would lead to `403 Forbidden` pages. The following
    exercise will show how we can use templates and authentication to present contextually
    appropriate links in our project.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有花时间根据权限条件渲染链接，用户在导航应用程序时会感到沮丧，因为他们点击的许多链接都会导致 `403 禁止访问` 页面。接下来的练习将展示我们如何使用模板和认证在我们的项目中呈现上下文相关的链接。
- en: 'Exercise 9.04: Toggling Login and Logout Links in the Base Template'
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.04：在基础模板中切换登录和登出链接
- en: 'In the `bookr` project''s base template, located in `templates/base.html`,
    we have a placeholder logout link in the header. It is coded in HTML as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `bookr` 项目的基模板中，位于 `templates/base.html`，我们在页眉中有一个占位符登出链接。它用以下 HTML 编码：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We don''t want the logout link to appear after a user has logged out. So, this
    exercise aims to apply conditional logic in the template so that `Login` and `Logout`
    links are toggled depending on whether the user is authenticated:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望在用户登出后显示登出链接。因此，这个练习的目的是在模板中应用条件逻辑，以便根据用户是否认证来切换 `登录` 和 `登出` 链接：
- en: 'Edit the `templates/base.html` file. Copy the structure of the `Logout` list
    element and create a `Login` list element. Then, replace the placeholder links
    with the correct URLs for the `Logout` and `Login` pages – `/accounts/logout`
    and `/accounts/login`, respectively – as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `templates/base.html` 文件。复制 `登出` 列表元素的架构，创建一个 `登录` 列表元素。然后，将占位符链接替换为 `登出`
    和 `登录` 页面的正确 URL - 分别为 `/accounts/logout` 和 `/accounts/login` - 如下所示：
- en: '[PRE32]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now put our two `li` elements inside an `if … else … endif` conditional block.
    The logic condition that we are applying is `if user.is_authenticated`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将我们的两个 `li` 元素放入一个 `if … else … endif` 条件块中。我们正在应用的逻辑条件是 `if user.is_authenticated`：
- en: '[PRE33]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now visit the user profile page at `http://localhost:8000/accounts/profile/`.
    When authenticated, you will see the `Logout` link:![Figure 9.7: An authenticated
    user sees the Logout link'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在访问用户个人资料页面，网址为 `http://localhost:8000/accounts/profile/`。当您登录后，您将看到 `登出` 链接：![图
    9.7：已认证用户看到的登出链接
- en: '](img/B15509_09_07.jpg)'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_09_07.jpg)'
- en: 'Figure 9.7: An authenticated user sees the Logout link'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.7：已认证用户看到的登出链接
- en: 'Now click the `Logout` link; you will be taken to the `/accounts/logout` page.
    The `Login` link appears in the menu, confirming that the link is contextually
    dependent on the authentication state of the user:![Figure 9.8: An unauthenticated
    user sees the Login link'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击 `登出` 链接；您将被带到 `/accounts/logout` 页面。`登录` 链接出现在菜单中，确认该链接是依赖于用户认证状态的：![图
    9.8：未认证用户看到的登录链接
- en: '](img/B15509_09_08.jpg)'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_09_08.jpg)'
- en: 'Figure 9.8: An unauthenticated user sees the Login link'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8：未认证用户看到的登录链接
- en: This exercise was a simple example of how Django templates can be used with
    authentication information to create a stateful and contextual user experience.
    We also do not want to provide links that a user does not have access to or actions
    that are not permissible for the user's permission level. The following activity
    will use this templating technique to fix some of these problems in Bookr.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习是一个简单的例子，说明了Django模板如何与认证信息一起使用，以创建有状态和上下文化的用户体验。我们也不希望提供用户无权访问的链接或用户权限级别不允许的操作。以下活动将使用这种模板技术来解决Bookr中的一些问题。
- en: 'Activity 9.01: Authentication-Based Content Using Conditional Blocks in Templates'
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动九.01：使用模板中的条件块进行基于认证的内容
- en: 'In this activity, you will apply conditional blocks in templates that modify
    content based on user authentication and user status. Users should not be presented
    with links that they are not permitted to visit or actions that they are not authorized
    to carry out. The following steps will help you complete this activity:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将在模板中应用条件块，根据用户认证和用户状态修改内容。不应向用户提供他们无权访问的链接或他们无权执行的操作。以下步骤将帮助你完成这个活动：
- en: In the `book_detail` template, in the file at `reviews/templates/reviews/book_detail.html`,
    hide the `Add Review` and `Media` buttons from non-authenticated users.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`book_detail`模板中，在`reviews/templates/reviews/book_detail.html`文件中，隐藏非认证用户的“添加评论”和“媒体”按钮。
- en: Also, hide the heading that says "*Be the first one to write a review*," as
    that is not an option for non-authenticated users.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，隐藏标题“*成为第一个写评论的人*”，因为这不是非认证用户的选项。
- en: 'In the same template, make the `Edit Review` link only appear for the staff
    or the user that wrote the review. The conditional logic for the template block
    is very similar to the conditional logic that we used in the `review_edit` view
    in the previous section:![Figure 9.9: The Edit Review link appears on Alice''s
    review when Alice is logged in'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的模板中，使“编辑评论”链接仅对工作人员或撰写评论的用户显示。模板块的条件逻辑与我们在上一节中使用的`review_edit`视图中的条件逻辑非常相似：![图9.9：当爱丽丝登录时，爱丽丝的评论中会出现“编辑评论”链接
- en: '](img/B15509_09_09.jpg)'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_09_09.jpg)'
- en: 'Figure 9.9: The Edit Review link appears on Alice''s review when Alice is logged
    in'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.9：当爱丽丝登录时，爱丽丝的评论中会出现“编辑评论”链接
- en: '![Figure 9.10: There is no Edit Review link on Alice''s review when Bob is
    logged in'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.10：当鲍勃登录时，爱丽丝的评论中没有“编辑评论”链接'
- en: '](img/B15509_09_10.jpg)'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_09_10.jpg)'
- en: 'Figure 9.10: There is no Edit Review link on Alice''s review when Bob is logged
    in'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.10：当鲍勃登录时，爱丽丝的评论中没有“编辑评论”链接
- en: Modify `template/base.html` so that it displays the currently authenticated
    user's username to the right of the search form in the header, linking to the
    user profile page.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`template/base.html`，使其在页眉中搜索表单的右侧显示当前已认证用户的用户名，并链接到用户个人资料页面。
- en: 'By completing this activity, you will have added dynamic content to the template
    that reflects the authentication state and identity of the current user, as can
    be seen from the following screenshot:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过完成这个活动，你将在模板中添加反映当前用户认证状态和身份的动态内容，如下面的截图所示：
- en: '![Figure 9.11: An authenticated user''s name appears after the search form'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.11：搜索表单之后显示已认证用户的名称'
- en: '](img/B15509_09_11.jpg)'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_09_11.jpg)'
- en: 'Figure 9.11: An authenticated user''s name appears after the search form'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：搜索表单之后显示已认证用户的名称
- en: Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在[http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ)找到。
- en: Sessions
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话
- en: It is worth looking at some theory to understand why sessions are a common solution
    in web applications for managing user content. The HTTP protocol defines the interactions
    between a client and a server. It is said to be a "stateless" protocol as no stateful
    information is retained by the server between requests. This protocol design worked
    well for delivering hypertextual information in the early days of the World Wide
    Web, but it did not suit the needs of secured web applications delivering customized
    information to specific users.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 值得研究一些理论来了解为什么会话是Web应用程序中管理用户内容的一种常见解决方案。HTTP协议定义了客户端和服务器之间的交互。它被称为“无状态”协议，因为服务器在请求之间不保留任何有状态信息。这种协议设计在万维网早期很好地用于传递超文本信息，但它不适合需要向特定用户交付定制信息的受保护Web应用程序的需求。
- en: We are now acquainted with seeing websites adapt to our personal viewing habits.
    Shopping sites recommend similar products to the ones that we have recently viewed
    and tell us about products that are popular in our region. These features all
    required a stateful approach to website development. One of the most common ways
    to implement a stateful web experience is through **sessions**. A session refers
    to a user's current interaction with a web server or application and requires
    that data is persisted for the duration of the interaction. This may include information
    about the links that the user has visited, the actions that they have performed,
    and the preferences that they have made in their interactions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经习惯了看到网站适应我们的个人浏览习惯。购物网站推荐与我们最近浏览过的类似产品，并告诉我们在我们地区受欢迎的产品。所有这些功能都需要一种有状态的网站开发方法。实现有状态网络体验最常见的方法之一是通过**会话**。会话指的是用户与网络服务器或应用的当前交互，并要求在交互期间持续存储数据。这可能包括用户访问的链接、他们执行的操作以及他们在交互中做出的偏好。
- en: If a user sets a blogging site to a dark theme on one page, there is an expectation
    that the next page will use the same theme as well. We describe this behavior
    as "maintaining state." A session key is stored client-side as a browser cookie,
    which can be identified with server-side information that persists while the user
    is logged in.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在一页上将博客网站的配色方案设置为深色主题，那么人们会期待下一页也会使用相同的主题。我们将这种行为描述为“保持状态”。会话密钥存储在客户端作为浏览器cookie，并且可以通过在用户登录期间持续存在的服务器端信息进行识别。
- en: In Django, sessions are implemented as a form of middleware. When we initially
    created the app in *Chapter 4*, *Introduction to Django Admin*, session support
    was activated by default.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中，会话被实现为一种中间件形式。当我们最初在*第4章*，*Django Admin简介*中创建应用时，会话支持默认激活。
- en: The Session Engine
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 会话引擎
- en: Information about current and expired sessions needs to be stored somewhere.
    In the early days of the World Wide Web, this was done through saving session
    information in files on the server, but as web server architectures have become
    more elaborate and their performance demands have increased, other more efficient
    strategies such as a database or in-memory storage have become the norm. By default,
    in Django, session information is stored in a project's database.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将当前和已过期的会话信息存储在某个地方。在万维网早期，这是通过在服务器上保存会话信息到文件中实现的，但随着网络服务器架构变得更加复杂以及性能需求的增加，其他更高效的策略，如数据库或内存存储，已成为标准。默认情况下，在Django中，会话信息存储在项目数据库中。
- en: 'This is a reasonable default for most small projects. However, Django''s middleware
    implementation of sessions gives us the flexibility to store our project''s session
    information in a variety of ways to suit our system architecture and performance
    requirements. Each of these different implementations is called a session engine.
    If we want to change the session configuration, we need to specify the `SESSION_ENGINE`
    setting in the project''s `settings.py` file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于大多数小型项目来说是一个合理的默认设置。然而，Django的会话中间件实现为我们提供了灵活性，可以根据我们的系统架构和性能需求以多种方式存储我们的项目会话信息。这些不同的实现方式被称为会话引擎。如果我们想更改会话配置，我们需要在项目的`settings.py`文件中指定`SESSION_ENGINE`设置：
- en: '`django.contrib.sessions.backends.cache` and `django.contrib.sessions.backends.cached_db`
    session engines for this purpose.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于此目的的`django.contrib.sessions.backends.cache`和`django.contrib.sessions.backends.cached_db`会话引擎。
- en: '**File-based sessions**: As stated earlier, this is a somewhat antiquated way
    of maintaining session information but may suit some sites where performance is
    not an issue and there are reasons not to store dynamic information in a database.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于文件的会话**：如前所述，这是一种相对过时的维护会话信息的方式，但可能适合一些性能不是问题且没有理由在数据库中存储动态信息的网站。'
- en: '**Cookie-based sessions**: Rather than keeping session information server-side,
    you can keep them entirely in the web browser client by serializing the contents
    of the session as JSON and storing it in a browser-based cookie.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于cookie的会话**：而不是在服务器端保持会话信息，你可以通过将会话内容序列化为JSON并存储在基于浏览器的cookie中，将它们完全保存在网络浏览器客户端。'
- en: Do You Need to Flag Cookie Content?
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你需要标记cookie内容吗？
- en: All of Django's implementations of sessions require storing a session ID in
    a cookie on the user's web browser.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Django的所有会话实现都需要在用户的网络浏览器中存储一个会话ID到cookie中。
- en: Regardless of the session engine employed, all these middleware implementations
    involve storing a site-specific cookie in the web browser. In the early days of
    web development, it was not uncommon to pass session IDs as URL arguments, but
    this approach has been eschewed in Django for reasons of security.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 不论使用哪种会话引擎，所有这些中间件实现都涉及在Web浏览器中存储特定于网站的cookie。在Web开发的早期，将会话ID作为URL参数传递并不罕见，但出于安全考虑，Django已经放弃了这种方法。
- en: In many jurisdictions, including the European Union, websites are legally required
    to warn users if the site sets cookies in their browsers. If there are such legislative
    requirements in the region where you intend to operate your site, it is your responsibility
    to ensure that the code meets these obligations. Be sure to use up-to-date implementations
    and avoid using abandoned projects that have not kept pace with legislative changes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多司法管辖区，包括欧盟，网站在用户浏览器中设置cookie时，在法律上必须警告用户。如果您打算在某个地区运营网站，并且该地区有此类立法要求，您有责任确保代码符合这些义务。请确保使用最新的实现，并避免使用未跟上立法变化的废弃项目。
- en: Note
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To cater to these changes and legislative requirements, there are many useful
    apps, such as **Django Simple Cookie Consent** and **Django Cookie Law**, that
    are designed to work with several legislative frameworks. You can find more by
    going to the following links:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应这些变化和立法要求，有许多有用的应用程序，如**Django Simple Cookie Consent**和**Django Cookie Law**，它们旨在与多个立法框架一起工作。您可以通过以下链接了解更多信息：
- en: '[https://pypi.org/project/django-simple-cookie-consent/](https://pypi.org/project/django-simple-cookie-consent/)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://pypi.org/project/django-simple-cookie-consent/](https://pypi.org/project/django-simple-cookie-consent/)'
- en: '[https://github.com/TyMaszWeb/django-cookie-law](https://github.com/TyMaszWeb/django-cookie-law)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/TyMaszWeb/django-cookie-law](https://github.com/TyMaszWeb/django-cookie-law)'
- en: Many JavaScript modules exist that implement similar cookie consent mechanisms.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多JavaScript模块实现了类似的cookie同意机制。
- en: Pickle or JSON storage
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pickle或JSON存储
- en: Python provides the **pickle** module in its standard library for serializing
    Python objects into a byte stream representation. A pickle is a binary structure
    that has the benefit of being interoperable between different architectures and
    different versions of Python, so that a Python object can be serialized to a pickle
    on a Windows PC and deserialized to a Python object on a Linux Raspberry Pi.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Python在其标准库中提供了**pickle**模块，用于将Python对象序列化为字节流表示。pickle是一种二进制结构，具有在不同架构和不同版本的Python之间互操作的优势，因此Python对象可以在Windows
    PC上序列化为pickle，并在Linux Raspberry Pi上反序列化为Python对象。
- en: 'This flexibility comes with security vulnerabilities and it is not recommended
    that it is used to represent untrusted data. Consider the following Python object,
    which contains several types of data. It can be serialized using `pickle`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性伴随着安全漏洞，因此不建议用它来表示不受信任的数据。考虑以下Python对象，它包含多种类型的数据。它可以使用`pickle`进行序列化：
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Using the `dumps` (dump string) method of the `pickle` module, we can serialize
    the data object to produce a byte representation:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pickle`模块的`dumps`（导出字符串）方法，我们可以将数据对象序列化以生成字节表示：
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`pickle` format:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle`格式：'
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Because data contains Python `datetime` and `set` objects, which aren''t serializable
    with JSON, when we attempt to serialize the structure a type error will be thrown:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数据包含Python的`datetime`和`set`对象，这些对象不能与JSON序列化，当我们尝试序列化结构时，会抛出类型错误：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For serializing to JSON, we could convert the `datetime` objects to `string`
    and `set` to a list:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将数据序列化为JSON，我们可以将`datetime`对象转换为`string`，将`set`转换为列表：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As JSON data is human readable, it is easy to examine:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JSON数据是可读的，因此很容易检查：
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Note that we had to explicitly convert the `datetime` and `set` objects, but
    the tuple is automatically converted to a list by the JSON. Django ships with
    `PickleSerializer` and `JSONSerializer`. If the situation arises where the serializer
    needs to be altered, it can be changed by setting the `SESSION_SERIALIZER` variable
    in the project''s `settings.py` file:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不得不显式地将`datetime`和`set`对象转换为，但JSON会自动将元组转换为列表。Django附带`PickleSerializer`和`JSONSerializer`。如果需要更改序列化器，可以通过在项目的`settings.py`文件中设置`SESSION_SERIALIZER`变量来实现：
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Exercise 9.05: Examining the Session Key'
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.05：检查会话密钥
- en: 'The purpose of this exercise is to query the project''s SQLite database and
    perform queries on the session table, so as to become familiar with how session
    data is stored. You will then create a Python script for examining session data
    that is stored using `JSONSerializer`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是查询项目的SQLite数据库并对会话表进行查询，以便熟悉会话数据的存储方式。然后，您将创建一个用于检查使用 `JSONSerializer`
    存储的会话数据的Python脚本：
- en: 'At a command prompt, open the project database using this command:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符下，使用以下命令打开项目数据库：
- en: '[PRE41]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Use the `.schema` directive to observe the structure of the `django_session`
    table as follows:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `.schema` 指令来观察 `django_session` 表的结构如下：
- en: '[PRE42]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Query the data in the `django_session` table by using the SQL command `select
    * from django_session;`:![Figure 9.12: Querying data in the django_session table'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用SQL命令 `select * from django_session;` 查询 `django_session` 表中的数据：![图9.12：查询django_session表中的数据
- en: '](img/B15509_09_12.jpg)'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_09_12.jpg)'
- en: 'Figure 9.12: Querying data in the django_session table'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.12：查询django_session表中的数据
- en: Note
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To exit `sqlite3`, hit *Ctrl* + *D* on Linux and macOS or *Ctrl* + *Z* and *Enter*
    on Windows.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要退出 `sqlite3`，在Linux和macOS上按 *Ctrl* + *D*，或在Windows上按 *Ctrl* + *Z* 然后按 *Enter*。
- en: 'We have observed that the session data is encoded in `base64` format. We can
    decrypt this data at the Python command line using the `base64` module. Once decoded
    from `base64`, the `session_key` data contains a `binary_key` and a JSON payload
    separated by a colon:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们观察到会话数据以 `base64` 格式编码。我们可以在Python命令行中使用 `base64` 模块解密此数据。一旦从 `base64` 解码，`session_key`
    数据包含一个 `binary_key` 和一个由冒号分隔的JSON有效载荷：
- en: '[PRE43]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This Python code shows how to obtain the payload:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段Python代码展示了如何获取有效载荷：
- en: '![Figure 9.13: Decoding the session key with the Python shell'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.13：使用Python shell解码会话密钥'
- en: '](img/B15509_09_13.jpg)'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_09_13.jpg)'
- en: 'Figure 9.13: Decoding the session key with the Python shell'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.13：使用Python shell解码会话密钥
- en: We can see the structure that is encoded in the payload. The payload represents
    the minimal data stored in a session. It contains keys for `_auth_user_id`, `_auth_user_backend`,
    and `_auth_user_hash` with values obtained from `User.id`, the `ModelBackend`
    class name, and the hash that is derived from the user's for password information.
    We will learn how to add additional data in the next section.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到有效载荷中编码的结构。有效载荷表示会话中存储的最小数据。它包含 `_auth_user_id`、`_auth_user_backend` 和
    `_auth_user_hash` 键，其值分别来自 `User.id`、`ModelBackend` 类名和从用户的密码信息中派生的哈希值。我们将在下一节学习如何添加额外的数据。
- en: 'We will develop a simple Python utility for decrypting this session information.
    It requires modules that we have used as well as `pprint` for formatting output
    and the `sys` module for checking command-line arguments:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将开发一个简单的Python实用程序来解密此会话信息。它需要我们使用的模块以及用于格式化输出的 `pprint` 模块和用于检查命令行参数的 `sys`
    模块：
- en: '[PRE44]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After the `import` statements, write a function that decodes the session key
    and loads the JSON payload as a Python dictionary:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `import` 语句之后，编写一个函数来解码会话密钥并加载JSON有效载荷作为Python字典：
- en: '[PRE45]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add a code block so that when this utility is run, it takes a `session_key`
    argument specified at the command line and converts it to a dictionary using the
    `get_session_dictionary` function. Then, use the `pprint` module to print an indented
    version of the dictionary structure:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个代码块，以便当运行此实用程序时，它接受命令行中指定的 `session_key` 参数，并使用 `get_session_dictionary`
    函数将其转换为字典。然后，使用 `pprint` 模块打印字典结构的缩进版本：
- en: '[PRE46]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now you can use this Python script to examine session data that is stored in
    the database. You can call it on the command line by passing the session data
    as an argument as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您可以使用这个Python脚本来检查存储在数据库中的会话数据。您可以通过以下方式在命令行中调用它，将会话数据作为参数传递：
- en: '[PRE47]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It will be useful for debugging session behavior when you attempt the final activity:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您尝试最终活动时，这将有助于调试会话行为：
- en: '![Figure 9.14: Python script'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.14：Python脚本'
- en: '](img/B15509_09_14.jpg)'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_09_14.jpg)'
- en: 'Figure 9.14: Python script'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14：Python脚本
- en: 'This script outputs the decoded session information. At present, the session
    only contains three keys:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本输出解码后的会话信息。目前，会话只包含三个键：
- en: '`_auth_user_backend` is a string representation of the class of the user backend.
    As our project stores user credentials in the model, `ModelBackend` is used.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`_auth_user_backend` 是用户后端类的字符串表示。由于我们的项目在模型中存储用户凭据，因此使用 `ModelBackend`。'
- en: '`_auth_user_hash` is a hash of the user''s password.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`_auth_user_hash` 是用户密码的哈希值。'
- en: '`_auth_user_id` is the user ID obtained from the model''s `User.id` attribute.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`_auth_user_id`是从模型的`User.id`属性中获取的用户ID。'
- en: This exercise helped you become familiar with how session data is stored in
    Django. We will now turn our attention to adding additional information to Django
    sessions.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习帮助你熟悉了Django中会话数据是如何存储的。现在，我们将把注意力转向向Django会话添加更多信息。
- en: Storing Data in Sessions
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在会话中存储数据
- en: 'We''ve covered the way sessions are implemented in Django. Now we are going
    to briefly examine some of the ways that we can make use of sessions to enrich
    our user experience. In Django, the session is an attribute of the `request` object.
    It is implemented as a dictionary-like object. In our views, we can assign keys
    to the `session` object like a typical dictionary, as here:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了Django中会话的实现方式。现在，我们将简要探讨一些我们可以利用会话来丰富用户体验的方法。在Django中，会话是`request`对象的一个属性。它被实现为一个类似字典的对象。在我们的视图中，我们可以像典型的字典一样向`session`对象分配键，如下所示：
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'But there are some restrictions. First, the keys in the session must be strings,
    so integers and timestamps are not allowed. Secondly, keys starting with an underscore
    are reserved for internal system use. Data is limited to values that can be encoded
    as JSON, so some byte sequences that can''t be decoded as UTF-8, such as the `binary_key`
    listed previously, can''t be stored as JSON data. The other warning is to avoid
    reassigning `request.session` to a different value. We should only assign or delete
    keys. So, don''t do this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一些限制。首先，会话中的键必须是字符串，因此不允许整数和时间戳。其次，以下划线开头的键是为内部系统使用保留的。数据限于可以编码为JSON的值，因此一些无法解码为UTF-8的字节序列，如之前列出的`binary_key`，不能作为JSON数据存储。另一个警告是避免将`request.session`重新赋值为不同的值。我们只应分配或删除键。所以，不要这样做：
- en: '[PRE49]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Instead, do this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 而应该这样做：
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: With those restrictions in mind, we will investigate the use that we can make
    of session data in our Reviews application.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些限制，我们将研究在我们的评论应用中可以如何使用会话数据。
- en: 'Exercise 9.06: Storing Recently Viewed Books in Sessions'
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.06：将最近浏览的书籍存储在会话中
- en: 'The purpose of this exercise is to use the session to keep information about
    the `10` books that have been most recently browsed by the authenticated user.
    This information will be displayed on the profile page of the `bookr` project.
    When a book is browsed, the `book_detail` view is called. In this exercise, we
    will edit `reviews/views.py` and add some additional logic to the `book_detail`
    method. We will add a key to the session called `viewed_books`. Using basic knowledge
    of HTML and CSS, the page can be created to show the profile details and viewed
    books stored in separate divisions of the page, as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是使用会话来保存已认证用户最近浏览的`10`本书的信息。这些信息将在`bookr`项目的个人资料页上显示。当浏览一本书时，会调用`book_detail`视图。在本练习中，我们将编辑`reviews/views.py`文件，并向`book_detail`方法添加一些额外的逻辑。我们将向会话中添加一个名为`viewed_books`的键。利用基本的HTML和CSS知识，可以创建页面以显示个人资料详情和存储在页面不同部分的已浏览书籍，如下所示：
- en: '![Figure 9.15: The Profile page incorporating Viewed Books'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.15：包含已浏览书籍的个人资料页面'
- en: '](img/B15509_09_15.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_09_15.jpg)'
- en: 'Figure 9.15: The Profile page incorporating Viewed Books'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15：包含已浏览书籍的个人资料页面
- en: 'Edit `reviews/views.py` and the `book_detail` method. We are only interested
    in adding session information for authenticated users, so add a conditional statement
    to check whether the user is authenticated and set `max_viewed_books_length`,
    the maximum length of the viewed books list, to `10`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`reviews/views.py`和`book_detail`方法。我们只对为已认证用户添加会话信息感兴趣，因此添加一个条件语句来检查用户是否已认证，并将`max_viewed_books_length`（已浏览书籍列表的最大长度）设置为`10`：
- en: '[PRE51]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Within the same conditional block, add code to retrieve the current value of
    `request.session[''viewed_books'']`. If this key isn''t present in the session,
    start with an empty list:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的条件块中，添加代码以检索当前`request.session['viewed_books']`的值。如果此键不在会话中，则从一个空列表开始：
- en: '[PRE52]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If the current book''s primary key is already present in `viewed_books`, the
    following code will remove it:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前书籍的主键已经在`viewed_books`中，以下代码将删除它：
- en: '[PRE53]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following code inserts the current book''s primary key to the start of
    the `viewed_books` list:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码将当前书籍的主键插入到`viewed_books`列表的开头：
- en: '[PRE54]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add the following key to only keep the first 10 elements of the list:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下键以仅保留列表的前10个元素：
- en: '[PRE55]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The following code will add our `viewed_books` back to `session[ ''viewed_books'']`,
    so that it is available in subsequent requests:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As before, at the end of the `book_detail` function, render the `reviews/book_detail.html`
    template given the request and context data:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Once complete, the `book_detail` view will have this conditional block:'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Modify the page layout and CSS of `templates/profile.html` to accommodate the
    viewed book division. As we may add more divisions to this page in the future,
    one convenient layout concept is the `div` instances that will be arranged horizontally
    on the page. We will refer to the internal `div` instances as `infocell` instances
    and style them with green borders and rounded edges:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Modify the `Viewed Books` `div` in `templates/profile.html` so that if there
    are books present, their titles are displayed, linked to the individual book detail
    pages. This will be rendered as follows:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'There should be a message displayed if the list is empty. The entire `div`,
    including the iteration through `request.session.viewed_books`, will look like
    this:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This will be the complete profile template once all these changes have been
    incorporated:'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This exercise has enhanced the profile page by adding a list of recently viewed
    books. Now when you visit the login link at `http://127.0.0.1:8000/accounts/profile/`,
    you will see this page:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16: Recently viewed books'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_09_16.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.16: Recently viewed books'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `session_info.py` script that we developed in *Exercise 9.04*,
    *Toggling Login and Logout Links in the Base Template*, to examine the user''s
    session once this feature is implemented. It can be called on the command line
    by passing the session data as an argument:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can see that the book IDs and titles are listed in the `viewed_books` key.
    Remember that the encoded data is obtained by querying the `django_session` table
    in the SQLite database:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17: The viewed books are stored in the session data'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_09_17.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.17: The viewed books are stored in the session data'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have used Django's session mechanism to store ephemeral
    information about user interactions with the Django project. We have learned how
    this information can be retrieved from the user session and be displayed in a
    view that informs users about their recent activity.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.02: Using Session Storage for the Book Search Page'
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sessions are a useful way to store short-lived information that assists in
    maintaining a stateful experience on a site. Users frequently revisit pages such
    as search forms, and it would be convenient to store their most recently used
    form settings when they return to those pages. In *Chapter 3*, *URL Mapping, Views,
    and Templates*, we developed a book search feature for the `bookr` project. The
    book search page has two options for `Search in` – `Title` and `Contributor`.
    Currently, each time the page is visited, it defaults to `Title`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18: The Search and Search in fields of the book search form'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_09_18.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.18: The Search and Search in fields of the book search form'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'In this activity, you will use session storage so that when the book search
    page, `/book-search`, is visited, it will default to the most recently used search
    option. You will also add a third `infocell` to the profile page that contains
    a list of links to the most recently used search terms. These are the steps that
    you need to complete this activity:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Edit the `book_search` view and retrieve `search_history` from the session.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the form has received valid input and a user is logged in, append the search
    option and search text to the session's search history list.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the case that the form hasn''t been filled (for example, when the page is
    first visited), render the form with the previously used `Search in` option selected,
    that is, either `Title` or `Contributor` (*Figure 9.19*):'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.19: Selecting Contributor in the search page'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_09_19.jpg)'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.19: Selecting Contributor in the search page'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the profile template, include an additional `infocell` division for `Search History`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'List the search history as a series of links to the book search page. The links
    will take this form: `/book-search?search=Python&search_in=title`.'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This activity will challenge you to apply session data to solve a usability
    issue in a web form. This approach will have applicability in many real-world
    situations and will give you some idea of the use of sessions in creating a stateful
    web experience. After completing this activity, the profile page will contain
    the third `infocell` as in *Figure 9.20*:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20: The profile page with the Search History infocell'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_09_20.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.20: The profile page with the Search History infocell'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have examined Django's middleware implementation of authentication
    and sessions. We have learned how to incorporate authentication and permission
    logic into views and templates. We can set permissions on specific pages and limit
    their access to authenticated users. We have also examined how to store data in
    a user's session and render it in subsequent pages.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Now you have the skills to customize a Django project to deliver a personalized
    web experience. You can limit the content to authenticated or privileged users
    and you can personalize a user's experience based on their prior interactions.
    In the next chapter, we will revisit the Admin app and learn some advanced techniques
    to customize our user model and apply fine-grained changes to the admin interface
    for our models.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
