- en: 9\. Sessions and Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter begins with a brief introduction to **middleware** before delving
    into the concepts of **authentication models** and **session engines**. You will
    implement Django's authentication model to restrict permissions to only a specific
    set of users. Then, you will see how you can leverage Django authentication to
    provide a flexible approach to application security. After that, you will learn
    how Django supports multiple session engines to retain user data. By the end of
    the chapter, you will be proficient at using sessions to retain information on
    past user interactions and to maintain user preferences for when pages are revisited.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have used Django to develop dynamic applications that allow
    users to interact with application models, but we have not attempted to secure
    these applications from unwanted use. For example, our Bookr app allows unauthenticated
    users to add reviews and upload media. This is a critical security issue for any
    online web app as it leaves the site open to the posting of spam or other inappropriate
    material and the vandalism of existing content. We want the creation and modification
    of content to be strictly limited to authenticated users who have registered with
    the site.
  prefs: []
  type: TYPE_NORMAL
- en: The **authentication app** supplies Django with the models for representing
    users, groups, and permissions. It also provides middleware, utility functions,
    decorators, and mixins that help integrate user authentication into our apps.
    Furthermore, the authentication app allows grouping and naming certain sets of
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 4*, *Introduction to Django Admin*, we used the Admin app to create
    a help desk user group with the permissions "Can view log entry," "Can view permission,"
    "Can change user," and "Can view user." Those permissions could be referenced
    in our code using their corresponding codenames: `view_logentry`, `view_permissions`,
    `change_user`, and `view_user`. In this chapter, we will learn how to customize
    Django behavior based on specific user permissions.'
  prefs: []
  type: TYPE_NORMAL
- en: Permissions are directives that delineate what is permissible by classes of
    users. Permissions can be assigned either to groups or directly to individual
    users. From an administrative point of view, it is cleaner to assign permissions
    to groups. Groups make it easier to model roles and organizational structures.
    If a new permission is created, it is less time-consuming to modify a few groups
    than to remember to assign it to a subset of users.
  prefs: []
  type: TYPE_NORMAL
- en: We are already familiar with creating users and groups and assigning permissions
    using several methods, such as the option of instantiating users and groups through
    the model using scripts and the convenience of creating them through the Django
    Admin app. The authentication app also offers us programmatic ways of creating
    and deleting users, groups, and permissions and assigning relations between them.
  prefs: []
  type: TYPE_NORMAL
- en: As we go through this chapter, we'll learn how to use authentication and permissions
    to implement application security and how to store user-specific data to customize
    the user's experience. This will help us secure the `bookr` project from unauthorized
    content changes and make it contextually relevant for different types of users.
    Adding this basic security to our `bookr` project is crucial before we consider
    deploying it on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication, as well as session management (which we'll learn about in the
    *Sessions* section), is handled by something known as a `bookr` project, let's
    learn a bit about this middleware stack and its modules.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 3*, *URL Mapping, Views, and Templates*, we discussed Django's implementation
    of the request/response process along with its view and rendering functionality.
    In addition to these, another feature that plays an extremely important role when
    it comes to Django's core web processing is **middleware**. Django's middleware
    refers to a variety of software components that intervene in this request/response
    process to integrate important functionalities such as security, session management,
    and authentication.
  prefs: []
  type: TYPE_NORMAL
- en: So, when we write a view in Django, we don't have to explicitly set a series
    of important security features in the response header. These additions to the
    response object are automatically made by the `SecurityMiddleware` instance after
    the view returns its response. As middleware components wrap the view and perform
    a series of pre-processes on the request and post-processes on the response, the
    view is not cluttered with a lot of repetitive code and we can concentrate on
    coding application logic rather than worrying about low-level server behavior.
    Rather than building these functionalities into the Django core, Django's implementation
    of a middleware stack allows these components to be both optional and replaceable.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we run the `startproject` subcommand, a default list of middleware modules
    is added to the `MIDDLEWARE` variable in the `<project>/settings.py` file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a minimal middleware stack that is suitable for most Django applications.
    The following list elaborates on the general purpose of each module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SecurityMiddleware` provides common security enhancements such as handling
    SSL redirects and adding response headers to prevent common hacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SessionMiddleware` enables session support and seamlessly associates a stored
    session with the current request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CommonMiddleware` implements a lot of miscellaneous features, such as rejecting
    requests from the `DISALLOWED_USER_AGENTS` list, implementing URL rewrite rules,
    and setting the `Content-Length` header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CsrfViewMiddleware` adds protection against **Cross-Site Request Forgery** (**CSRF**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthenticationMiddleware` adds the `user` attribute to the `request` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MessageMiddleware` adds "flash" message support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XFrameOptionsMiddleware` protects against `X-Frame-Options` header clickjacking
    attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The middleware modules are loaded in the order that they appear in the `MIDDLEWARE`
    list. This makes sense because we want to call the middleware that deals with
    initial security issues first so that dangerous requests are rejected before further
    processing occurs. Django also comes with several other middleware modules that
    perform important functions, such as using `gzip` file compression, redirect configuration,
    and web cache configuration.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is devoted to discussing two important aspects of stateful application
    development that are implemented as middleware components – `SessionMiddleware`
    and `AuthenticationMiddleware`.
  prefs: []
  type: TYPE_NORMAL
- en: The `process_request` method of `SessionMiddleware` adds a `session` object
    as an attribute of the `request` object. The `process_request` method of `AuthenticationMiddleware`
    adds a `user` object as an attribute of the `request` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to write a Django project without these layers of the middleware
    stack if a project does not require user authentication or a means of preserving
    the state of individual interactions. However, most of the default middleware
    plays an important role in application security. If you don''t have a good reason
    for changing the middleware components, it is best to maintain these initial settings.
    In fact, the Admin app requires `SessionMiddleware`, `AuthenticationMiddleware`,
    and `MessageMiddleware` to run, and the Django server will throw errors such as
    these if the Admin app is installed without them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know about the middleware modules, let's look at one approach to
    enable authentication in our project using the authentication app's views and templates.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Authentication Views and Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already encountered the login form on the Admin app in *Chapter 4*,
    *Introduction to Django Admin*. This is the authentication entry point for staff
    users who have access to the Admin app. We also need to create a login capability
    for ordinary users who want to give book reviews. Fortunately, the authentication
    app comes with the tools to make this possible.
  prefs: []
  type: TYPE_NORMAL
- en: As we work through the forms and views of the authentication app, we encounter
    a lot of flexibility in its implementation. We are free to implement our own login
    pages, define either very simple or fine-grained security policies at the view
    level, and authenticate against external authorities.
  prefs: []
  type: TYPE_NORMAL
- en: The authentication app exists to accommodate a lot of different approaches to
    authentication so that Django doesn't rigidly enforce a single mechanism. For
    a first-time user encountering the documentation, this can be quite bewildering.
    For the most part in this chapter, we will follow Django's defaults, but some
    of the important configuration options will be noted.
  prefs: []
  type: TYPE_NORMAL
- en: A Django project's `settings` object contains attributes for login behavior.
    `LOGIN_URL` specifies the URL of the login page. `'/accounts/login/'` is the default
    value. `LOGIN_REDIRECT_URL` specifies the path where a successful login is redirected
    to. The default path is `'/accounts/profile/'`.
  prefs: []
  type: TYPE_NORMAL
- en: The authentication app supplies standard forms and views for carrying out typical
    authentication tasks. The forms are located in `django.contrib.auth.forms` and
    the views are in `django.contrib.auth.views`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The views are referenced by these URL patterns present in `django.contrib.auth.urls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If this style of views looks unfamiliar, it is because they are class-based
    views rather than the function-based views that we have previously encountered.
    We will learn more about class-based views in *Chapter 11*, *Advanced Templates
    and Class-Based Views*. For now, note that the authentication app makes use of
    class inheritance to group the functionality of views and prevent a lot of repetitive
    coding.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to maintain the default URLs and views that are presupposed by the
    authentication app and Django settings, we can include the authentication app's
    URLs in our project's `urlpatterns`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By taking this approach, we have saved a lot of work. We need only include
    the authentication app''s URLs to our `<project>/urls.py` file and assign it the
    `''accounts''` namespace. Designating this namespace ensures that our reverse
    URLs correspond to the default template values of the views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Though the authentication app comes with its own forms and views, it lacks the
    templates needed to render these components as HTML. *Figure 9.1* lists the templates
    that we require to implement the authentication functionality in our project.
    Fortunately, the Admin app does implement a set of templates that we can utilize
    for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: We could just copy the template files from the Django source code in the `django/contrib/admin/templates/registration`
    directory and `django/contrib/admin/templates/admin/login.html` to our project's
    `templates/registration` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'When we say Django source code, it''s the directory where your Django installation
    resides. If you installed Django in a virtual environment (as detailed in the
    *Preface*), you can find these template files at the following path: `<name of
    your virtual environment>/lib/python3.X/site-packages/django/contrib/admin/templates/registration/`.
    Provided your virtual environment is activated and Django is installed in it,
    you can also retrieve the complete path to the `site-packages` directory by running
    the following command in a terminal: `python -c "import sys; print(sys.path)"`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Default paths for authentication templates'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_09_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.1: Default paths for authentication templates'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We need only copy the templates that are dependencies for the views and should
    avoid copying the `base.html` or `base_site.html` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives a promising result at first, but as they stand, the admin templates
    do not meet our precise needs as we can see from the login page (*Figure 9.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: A first attempt at a user login screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_09_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.2: A first attempt at a user login screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'As these authentication pages inherit from the Admin app''s `admin/base_site.html`
    template, they follow the style of the Admin app. We would prefer for these pages
    to follow the style of the `bookr` project that we have developed. We can do this
    by following these three steps on each Django template that we have copied from
    the Admin app to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: The first change that needs to be made is to replace the `{% extends "admin/base_site.html"
    %}` tag with `{% extends "base.html" %}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given that `template/base.html` only contains the following block definitions
    – `title`, `brand`, and `content` – we should remove all other block substitutions
    from our templates in the `bookr` folder. We are not using the content from the
    `userlinks` and `breadcrumbs` blocks in our app, so these blocks can be removed
    entirely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some of these blocks, such as `content_title` and `reset_link`, contain HTML
    content that is relevant to our application. We should strip the block from around
    this HTML and put it inside the content block.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, the `password_change_done.html` template contains an extensive
    number of blocks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It will be simplified to this template in the `bookr` project:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Likewise, there are reverse URL patterns that need to change to reflect the
    current path, so `{% url 'login' %}` gets replaced by `{% url 'accounts:login'
    %}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given these considerations, the next exercise will focus on transforming the
    Admin app's login template into a login template for the `bookr` project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `i18n` module is used for creating multilingual content. If you intend to
    develop multilingual content for your website, leave the `i18n` import, `trans`
    tags, and `transblock` statements in the templates. For brevity, we will not be
    covering those in detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.01: Repurposing the Admin App Login Template'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We started this chapter without a login page for our project. By adding the
    URL patterns for authentication and copying the templates from the Admin app to
    our own project, we can implement the functionality of a login page. But this
    login page is not satisfactory as it is directly copied from the Admin app and
    is disconnected from the Bookr design. In this exercise, we will follow the steps
    needed to repurpose the Admin app''s login template for our project. The new login
    template will need to inherit its style and format directly from the `bookr` project''s
    `templates/base.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory inside your project for `templates/registration`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Admin login template is located in the Django source directory at the `django/contrib/admin/templates/admin/login.html`
    path. It begins with an `extends` tag, a `load` tag, the importing of the `i18n`
    and `static` modules, and a series of block extensions that over-ride the blocks
    defined in the child template, `django/contrib/admin/templates/admin/base.html`.
    A truncated snippet of the `login.html` file is shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Copy this Admin login template, `django/contrib/admin/templates/admin/login.html`,
    into `templates/registration` and begin editing the file using PyCharm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As the login template you are editing is located at `templates/registration/login.html`
    and extends the base template (`templates/base.html`), replace the argument of
    the `extends` tag at the top of `templates/registration/login.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We don''t need most of the contents of this file. Just retain the `content`
    block, which contains the login form. The remainder of the template will consist
    of loading the `i18n` and `static` tag libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you must replace the paths and reverse URL patterns in `templates/registration/login.html`
    with ones that are appropriate to your project. As you don''t have an `app_path`
    variable defined in your template, it needs to be replaced with the reverse URL
    for the login, `''accounts:login''`. So, consider the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This line changes as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is no `'admin_password_reset'` defined in your project paths, so it will
    be replaced with `'accounts:password_reset'`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Consider the following line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This line changes as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your login template will look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use the standard Django authentication views, we must add the URLs mapping
    to them. Open the `urls.py` file in the `bookr` project directory, then add this
    URL pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now when you visit the login link at `http://127.0.0.1:8000/accounts/login/`,
    you will see this page:![Figure 9.3: The Bookr login page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_09_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.3: The Bookr login page'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you have created the template required for non-admin
    authentication in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you proceed, you''ll need to make sure the rest of the templates in
    the `registration` directory follow the `bookr` project''s style; that is, they
    inherit from the Admin app''s `admin/base_site.html` template. You''ve already
    seen this done with `password_change_done.html` and the `login.html` templates.
    Go ahead and apply what you''ve learned in this exercise (and the section before
    it) to the rest of the files in the `registration` directory. Alternatively, you
    may download the modified files from the GitHub repo: [http://packt.live/3s4R5iU](http://packt.live/3s4R5iU).'
  prefs: []
  type: TYPE_NORMAL
- en: Password Storage in Django
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django does not store passwords in plain text form in the database. Instead,
    passwords are digested with a hashing algorithm, such as **PBKDF2/SHA256**, **BCrypt**/**SHA256**,
    or **Argon2**. As hashing algorithms are a one-way transformation, this prevents
    a user''s password from being decrypted from the hash stored in the database.
    This often comes as a surprise to users who expect a system administrator to retrieve
    their forgotten password, but it is best practice in security design. So, if we
    query the database for the password, we will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The components of this string are `<algorithm>$<iterations>$<salt>$<hash>`.
    As several hashing algorithms have been compromised over time and we sometimes
    need to work with mandated security requirements, Django is flexible enough to
    accommodate new algorithms and can maintain data encrypted in multiple algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The Profile Page and the request.user Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a login is successful, the login view redirects to `/accounts/profile`.
    However, this path is not included in the existing `auth.url` nor does the authentication
    app provide a template for it. To avoid a `Page not Found` error, a view and an
    appropriate URL pattern are required.
  prefs: []
  type: TYPE_NORMAL
- en: Each Django request has a `request.user` object. If the request is made by an
    unauthenticated user, `request.user` will be an `AnonymousUser` object. If the
    request is made by an authenticated user, then `request.user` will be a `User`
    object. This makes it easy to retrieve personalized user information in a Django
    view and render it in a template.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will add a profile page to our `bookr` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.02: Adding a Profile Page'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will add a profile page to our project. To do so, we need
    to include the path to it in our URL patterns and also include it in our views
    and templates. The profile page will simply display the following attributes from
    the `request.user` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`username`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first_name` and `last_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`date_joined`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last_login`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `bookr/views.py` to the project. It needs a trivial profile function to
    define our view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the templates folder of your main `bookr` project, create a new file called
    `profile.html`. In this template, the attributes of the `request.user` object
    can easily be referenced by using a notation such as `{{ request.user.username
    }}`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Also, we added a block containing profile details of the user. More importantly,
    we made sure that `profile.html` extends `base.html`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, this path needs to be added to the top of the `urlpatterns` list in
    `bookr/urls.py`. First, import the new views and then add a path linking the URL
    `accounts/profile/` to `bookr.views.profile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Figure 9:4: Alice visits her user profile'
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how we can redirect a user to their profile page, once they've successfully
    logged in. Let's now discuss how we can give content access to specific users
    only.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication Decorators and Redirection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have learned how to allow ordinary users to log in to our project,
    we can discover how to restrict content to authenticated users. The authentication
    module comes with some useful decorators that can be used to secure views according
    to the current user's authentication or access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, if, say, a user named Alice was to log out of Bookr, the profile
    page would still render and display empty details. Instead of this happening,
    it would be preferable for any unauthenticated visitor to be directed to the login
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5: An unauthenticated user visits a user profile'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_09_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.5: An unauthenticated user visits a user profile'
  prefs: []
  type: TYPE_NORMAL
- en: 'The authentication app comes with useful decorators for adding authentication
    behavior to Django views. In this situation of securing our profile view, we can
    use the `login_required` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now if an unauthenticated user visits the `/accounts/profile` URL, they will
    be redirected to `http://localhost:8000/accounts/login/?next=/accounts/profile/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This URL takes the user to the login URL. The `next` parameter in the `GET`
    variables tells the login view where to redirect to after a successful login.
    The default behavior is to redirect back to the current view, but this can be
    overridden by specifying the `login_url` argument to the `login_required` decorator.
    For example, if we had some need to redirect to a different page after login,
    we could have explicitly stated it in the decorator call like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we had rewritten our login view to expect the redirection URL to be specified
    in a different URL argument to `''next''`, we could explicate this in the decorator
    call with the `redirect_field_name` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There are often situations where a URL should be restricted to users or groups
    holding a specific condition. Consider the case where we have a page for staff
    users to view any user profile. We don''t want this URL to be accessible to all
    users, so we want to limit this URL to users or groups with the `''view_user''`
    permission and to forward the unauthorized requests to the login URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So with this decorator applied on our `user_profile` view, an unauthorized user
    visiting `http://localhost:8000/accounts/users/123/profile/` would be redirected
    to `http://localhost:8000/accounts/login/?next=/accounts/users/123/profile/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, though, we need to structure more subtle conditional permissions
    that don''t fall into the scope of these two directors. For this purpose, Django
    provides a custom decorator that takes an arbitrary function as an argument. The
    `user_passes_test` decorator requires a `test_func` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example where we have a view, `veteran_features`, that is only available
    to users who have been registered on the site for more than a year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes the logic in our views cannot be handled with one of these decorators
    and we need to apply the redirect within the control flow of the view. We can
    do this using the `redirect_to_login` helper function. It takes the same arguments
    as the decorators, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 9.03: Adding Authentication Decorators to the Views'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having learned about the flexibility of the authentication app''s permission
    and authentication decorators, we will now set about putting them to use in the
    Reviews app. We need to ensure that only authenticated users can edit reviews
    and that only staff users can edit publishers. There are several ways of doing
    this, so we will attempt a few approaches. All the code in these steps is in the
    `reviews/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your first instinct to solve this problem would be to think that the `publisher_edit`
    method needs an appropriate decorator to enforce that the user has `edit_publisher`
    permission. For this, you could easily do something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using this method is fine and it''s one way to add permissions checking to
    a view. You can also use a slightly more complicated but more flexible method.
    Instead of using a permission decorator to enforce permission rights on the `publisher_edit`
    method, you will create a test function that requires a staff user and apply this
    test function to `publisher_edit` with the `user_passes_test` decorator. Writing
    a test function allows more customization on how you validate users'' access rights
    or permissions. If you made changes to your `views.py` file in *step 1*, feel
    free to comment the decorator out (or delete it) and write the following test
    function instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure that login is required for the `review_edit` and `book_media` functions
    by adding the appropriate decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `review_edit` method, add logic to the view that requires that the user
    be either a staff user or the owner of the review. The `review_edit` view controls
    the behavior of both review creation and review updates. The constraint that we
    are developing only applies to the case where an existing review is being updated.
    So, the place to add code is after a `Review` object has been successfully retrieved.
    If the user is not a staff account or the review''s creator doesn''t match the
    current user, we need to raise a `PermissionDenied` error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when a non-staff user attempts to edit another user''s review, a `Forbidden`
    error will be thrown, as in *Figure 9.6*. In the next section, we will look at
    applying conditional logic in templates so that users aren''t taken to pages that
    they don''t have sufficient permission to access:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.6: Access is forbidden to non-staff users'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_09_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.6: Access is forbidden to non-staff users'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have used authentication decorators to secure views in
    a Django app. The authentication decorators that were applied provided a simple
    mechanism to restrict views from users lacking necessary permissions, non-staff
    users, and unauthenticated users. Django's authentication decorators provide a
    robust mechanism that follows Django's role and permission framework, while the
    `user_passes_test` decorator provides an option to develop custom authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing Templates with Authentication Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Exercise 9.02*, *Adding a Profile Page*, we saw that we can pass the `request.user`
    object to the template to render the current user''s attributes in the HTML. We
    can also take the approach of giving different template renderings according to
    the user type or permissions held by a user. Consider that we want to add an edit
    link that only appears to staff users. We might apply an `if` condition to achieve
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If we didn't take the time to conditionally render links based on permissions,
    users would have a frustrating experience navigating the application as many of
    the links that they click on would lead to `403 Forbidden` pages. The following
    exercise will show how we can use templates and authentication to present contextually
    appropriate links in our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.04: Toggling Login and Logout Links in the Base Template'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `bookr` project''s base template, located in `templates/base.html`,
    we have a placeholder logout link in the header. It is coded in HTML as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t want the logout link to appear after a user has logged out. So, this
    exercise aims to apply conditional logic in the template so that `Login` and `Logout`
    links are toggled depending on whether the user is authenticated:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `templates/base.html` file. Copy the structure of the `Logout` list
    element and create a `Login` list element. Then, replace the placeholder links
    with the correct URLs for the `Logout` and `Login` pages – `/accounts/logout`
    and `/accounts/login`, respectively – as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now put our two `li` elements inside an `if … else … endif` conditional block.
    The logic condition that we are applying is `if user.is_authenticated`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now visit the user profile page at `http://localhost:8000/accounts/profile/`.
    When authenticated, you will see the `Logout` link:![Figure 9.7: An authenticated
    user sees the Logout link'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_09_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.7: An authenticated user sees the Logout link'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now click the `Logout` link; you will be taken to the `/accounts/logout` page.
    The `Login` link appears in the menu, confirming that the link is contextually
    dependent on the authentication state of the user:![Figure 9.8: An unauthenticated
    user sees the Login link'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_09_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.8: An unauthenticated user sees the Login link'
  prefs: []
  type: TYPE_NORMAL
- en: This exercise was a simple example of how Django templates can be used with
    authentication information to create a stateful and contextual user experience.
    We also do not want to provide links that a user does not have access to or actions
    that are not permissible for the user's permission level. The following activity
    will use this templating technique to fix some of these problems in Bookr.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.01: Authentication-Based Content Using Conditional Blocks in Templates'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, you will apply conditional blocks in templates that modify
    content based on user authentication and user status. Users should not be presented
    with links that they are not permitted to visit or actions that they are not authorized
    to carry out. The following steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `book_detail` template, in the file at `reviews/templates/reviews/book_detail.html`,
    hide the `Add Review` and `Media` buttons from non-authenticated users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, hide the heading that says "*Be the first one to write a review*," as
    that is not an option for non-authenticated users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the same template, make the `Edit Review` link only appear for the staff
    or the user that wrote the review. The conditional logic for the template block
    is very similar to the conditional logic that we used in the `review_edit` view
    in the previous section:![Figure 9.9: The Edit Review link appears on Alice''s
    review when Alice is logged in'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_09_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.9: The Edit Review link appears on Alice''s review when Alice is logged
    in'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.10: There is no Edit Review link on Alice''s review when Bob is
    logged in'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_09_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.10: There is no Edit Review link on Alice''s review when Bob is logged
    in'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Modify `template/base.html` so that it displays the currently authenticated
    user's username to the right of the search form in the header, linking to the
    user profile page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By completing this activity, you will have added dynamic content to the template
    that reflects the authentication state and identity of the current user, as can
    be seen from the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.11: An authenticated user''s name appears after the search form'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_09_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.11: An authenticated user''s name appears after the search form'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  prefs: []
  type: TYPE_NORMAL
- en: Sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is worth looking at some theory to understand why sessions are a common solution
    in web applications for managing user content. The HTTP protocol defines the interactions
    between a client and a server. It is said to be a "stateless" protocol as no stateful
    information is retained by the server between requests. This protocol design worked
    well for delivering hypertextual information in the early days of the World Wide
    Web, but it did not suit the needs of secured web applications delivering customized
    information to specific users.
  prefs: []
  type: TYPE_NORMAL
- en: We are now acquainted with seeing websites adapt to our personal viewing habits.
    Shopping sites recommend similar products to the ones that we have recently viewed
    and tell us about products that are popular in our region. These features all
    required a stateful approach to website development. One of the most common ways
    to implement a stateful web experience is through **sessions**. A session refers
    to a user's current interaction with a web server or application and requires
    that data is persisted for the duration of the interaction. This may include information
    about the links that the user has visited, the actions that they have performed,
    and the preferences that they have made in their interactions.
  prefs: []
  type: TYPE_NORMAL
- en: If a user sets a blogging site to a dark theme on one page, there is an expectation
    that the next page will use the same theme as well. We describe this behavior
    as "maintaining state." A session key is stored client-side as a browser cookie,
    which can be identified with server-side information that persists while the user
    is logged in.
  prefs: []
  type: TYPE_NORMAL
- en: In Django, sessions are implemented as a form of middleware. When we initially
    created the app in *Chapter 4*, *Introduction to Django Admin*, session support
    was activated by default.
  prefs: []
  type: TYPE_NORMAL
- en: The Session Engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Information about current and expired sessions needs to be stored somewhere.
    In the early days of the World Wide Web, this was done through saving session
    information in files on the server, but as web server architectures have become
    more elaborate and their performance demands have increased, other more efficient
    strategies such as a database or in-memory storage have become the norm. By default,
    in Django, session information is stored in a project's database.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a reasonable default for most small projects. However, Django''s middleware
    implementation of sessions gives us the flexibility to store our project''s session
    information in a variety of ways to suit our system architecture and performance
    requirements. Each of these different implementations is called a session engine.
    If we want to change the session configuration, we need to specify the `SESSION_ENGINE`
    setting in the project''s `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`django.contrib.sessions.backends.cache` and `django.contrib.sessions.backends.cached_db`
    session engines for this purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File-based sessions**: As stated earlier, this is a somewhat antiquated way
    of maintaining session information but may suit some sites where performance is
    not an issue and there are reasons not to store dynamic information in a database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cookie-based sessions**: Rather than keeping session information server-side,
    you can keep them entirely in the web browser client by serializing the contents
    of the session as JSON and storing it in a browser-based cookie.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do You Need to Flag Cookie Content?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of Django's implementations of sessions require storing a session ID in
    a cookie on the user's web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the session engine employed, all these middleware implementations
    involve storing a site-specific cookie in the web browser. In the early days of
    web development, it was not uncommon to pass session IDs as URL arguments, but
    this approach has been eschewed in Django for reasons of security.
  prefs: []
  type: TYPE_NORMAL
- en: In many jurisdictions, including the European Union, websites are legally required
    to warn users if the site sets cookies in their browsers. If there are such legislative
    requirements in the region where you intend to operate your site, it is your responsibility
    to ensure that the code meets these obligations. Be sure to use up-to-date implementations
    and avoid using abandoned projects that have not kept pace with legislative changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To cater to these changes and legislative requirements, there are many useful
    apps, such as **Django Simple Cookie Consent** and **Django Cookie Law**, that
    are designed to work with several legislative frameworks. You can find more by
    going to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://pypi.org/project/django-simple-cookie-consent/](https://pypi.org/project/django-simple-cookie-consent/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/TyMaszWeb/django-cookie-law](https://github.com/TyMaszWeb/django-cookie-law)'
  prefs: []
  type: TYPE_NORMAL
- en: Many JavaScript modules exist that implement similar cookie consent mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Pickle or JSON storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python provides the **pickle** module in its standard library for serializing
    Python objects into a byte stream representation. A pickle is a binary structure
    that has the benefit of being interoperable between different architectures and
    different versions of Python, so that a Python object can be serialized to a pickle
    on a Windows PC and deserialized to a Python object on a Linux Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'This flexibility comes with security vulnerabilities and it is not recommended
    that it is used to represent untrusted data. Consider the following Python object,
    which contains several types of data. It can be serialized using `pickle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `dumps` (dump string) method of the `pickle` module, we can serialize
    the data object to produce a byte representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`pickle` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Because data contains Python `datetime` and `set` objects, which aren''t serializable
    with JSON, when we attempt to serialize the structure a type error will be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For serializing to JSON, we could convert the `datetime` objects to `string`
    and `set` to a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As JSON data is human readable, it is easy to examine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we had to explicitly convert the `datetime` and `set` objects, but
    the tuple is automatically converted to a list by the JSON. Django ships with
    `PickleSerializer` and `JSONSerializer`. If the situation arises where the serializer
    needs to be altered, it can be changed by setting the `SESSION_SERIALIZER` variable
    in the project''s `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 9.05: Examining the Session Key'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of this exercise is to query the project''s SQLite database and
    perform queries on the session table, so as to become familiar with how session
    data is stored. You will then create a Python script for examining session data
    that is stored using `JSONSerializer`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At a command prompt, open the project database using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `.schema` directive to observe the structure of the `django_session`
    table as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Query the data in the `django_session` table by using the SQL command `select
    * from django_session;`:![Figure 9.12: Querying data in the django_session table'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_09_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.12: Querying data in the django_session table'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To exit `sqlite3`, hit *Ctrl* + *D* on Linux and macOS or *Ctrl* + *Z* and *Enter*
    on Windows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We have observed that the session data is encoded in `base64` format. We can
    decrypt this data at the Python command line using the `base64` module. Once decoded
    from `base64`, the `session_key` data contains a `binary_key` and a JSON payload
    separated by a colon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This Python code shows how to obtain the payload:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.13: Decoding the session key with the Python shell'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_09_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.13: Decoding the session key with the Python shell'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can see the structure that is encoded in the payload. The payload represents
    the minimal data stored in a session. It contains keys for `_auth_user_id`, `_auth_user_backend`,
    and `_auth_user_hash` with values obtained from `User.id`, the `ModelBackend`
    class name, and the hash that is derived from the user's for password information.
    We will learn how to add additional data in the next section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will develop a simple Python utility for decrypting this session information.
    It requires modules that we have used as well as `pprint` for formatting output
    and the `sys` module for checking command-line arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the `import` statements, write a function that decodes the session key
    and loads the JSON payload as a Python dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a code block so that when this utility is run, it takes a `session_key`
    argument specified at the command line and converts it to a dictionary using the
    `get_session_dictionary` function. Then, use the `pprint` module to print an indented
    version of the dictionary structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you can use this Python script to examine session data that is stored in
    the database. You can call it on the command line by passing the session data
    as an argument as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It will be useful for debugging session behavior when you attempt the final activity:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.14: Python script'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_09_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.14: Python script'
  prefs: []
  type: TYPE_NORMAL
- en: 'This script outputs the decoded session information. At present, the session
    only contains three keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_auth_user_backend` is a string representation of the class of the user backend.
    As our project stores user credentials in the model, `ModelBackend` is used.'
  prefs: []
  type: TYPE_NORMAL
- en: '`_auth_user_hash` is a hash of the user''s password.'
  prefs: []
  type: TYPE_NORMAL
- en: '`_auth_user_id` is the user ID obtained from the model''s `User.id` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: This exercise helped you become familiar with how session data is stored in
    Django. We will now turn our attention to adding additional information to Django
    sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Data in Sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve covered the way sessions are implemented in Django. Now we are going
    to briefly examine some of the ways that we can make use of sessions to enrich
    our user experience. In Django, the session is an attribute of the `request` object.
    It is implemented as a dictionary-like object. In our views, we can assign keys
    to the `session` object like a typical dictionary, as here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'But there are some restrictions. First, the keys in the session must be strings,
    so integers and timestamps are not allowed. Secondly, keys starting with an underscore
    are reserved for internal system use. Data is limited to values that can be encoded
    as JSON, so some byte sequences that can''t be decoded as UTF-8, such as the `binary_key`
    listed previously, can''t be stored as JSON data. The other warning is to avoid
    reassigning `request.session` to a different value. We should only assign or delete
    keys. So, don''t do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: With those restrictions in mind, we will investigate the use that we can make
    of session data in our Reviews application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.06: Storing Recently Viewed Books in Sessions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of this exercise is to use the session to keep information about
    the `10` books that have been most recently browsed by the authenticated user.
    This information will be displayed on the profile page of the `bookr` project.
    When a book is browsed, the `book_detail` view is called. In this exercise, we
    will edit `reviews/views.py` and add some additional logic to the `book_detail`
    method. We will add a key to the session called `viewed_books`. Using basic knowledge
    of HTML and CSS, the page can be created to show the profile details and viewed
    books stored in separate divisions of the page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15: The Profile page incorporating Viewed Books'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_09_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.15: The Profile page incorporating Viewed Books'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `reviews/views.py` and the `book_detail` method. We are only interested
    in adding session information for authenticated users, so add a conditional statement
    to check whether the user is authenticated and set `max_viewed_books_length`,
    the maximum length of the viewed books list, to `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the same conditional block, add code to retrieve the current value of
    `request.session[''viewed_books'']`. If this key isn''t present in the session,
    start with an empty list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the current book''s primary key is already present in `viewed_books`, the
    following code will remove it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code inserts the current book''s primary key to the start of
    the `viewed_books` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following key to only keep the first 10 elements of the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code will add our `viewed_books` back to `session[ ''viewed_books'']`,
    so that it is available in subsequent requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As before, at the end of the `book_detail` function, render the `reviews/book_detail.html`
    template given the request and context data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once complete, the `book_detail` view will have this conditional block:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the page layout and CSS of `templates/profile.html` to accommodate the
    viewed book division. As we may add more divisions to this page in the future,
    one convenient layout concept is the `div` instances that will be arranged horizontally
    on the page. We will refer to the internal `div` instances as `infocell` instances
    and style them with green borders and rounded edges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `Viewed Books` `div` in `templates/profile.html` so that if there
    are books present, their titles are displayed, linked to the individual book detail
    pages. This will be rendered as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There should be a message displayed if the list is empty. The entire `div`,
    including the iteration through `request.session.viewed_books`, will look like
    this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will be the complete profile template once all these changes have been
    incorporated:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This exercise has enhanced the profile page by adding a list of recently viewed
    books. Now when you visit the login link at `http://127.0.0.1:8000/accounts/profile/`,
    you will see this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16: Recently viewed books'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_09_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.16: Recently viewed books'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `session_info.py` script that we developed in *Exercise 9.04*,
    *Toggling Login and Logout Links in the Base Template*, to examine the user''s
    session once this feature is implemented. It can be called on the command line
    by passing the session data as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the book IDs and titles are listed in the `viewed_books` key.
    Remember that the encoded data is obtained by querying the `django_session` table
    in the SQLite database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17: The viewed books are stored in the session data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_09_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.17: The viewed books are stored in the session data'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have used Django's session mechanism to store ephemeral
    information about user interactions with the Django project. We have learned how
    this information can be retrieved from the user session and be displayed in a
    view that informs users about their recent activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.02: Using Session Storage for the Book Search Page'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sessions are a useful way to store short-lived information that assists in
    maintaining a stateful experience on a site. Users frequently revisit pages such
    as search forms, and it would be convenient to store their most recently used
    form settings when they return to those pages. In *Chapter 3*, *URL Mapping, Views,
    and Templates*, we developed a book search feature for the `bookr` project. The
    book search page has two options for `Search in` – `Title` and `Contributor`.
    Currently, each time the page is visited, it defaults to `Title`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18: The Search and Search in fields of the book search form'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_09_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.18: The Search and Search in fields of the book search form'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this activity, you will use session storage so that when the book search
    page, `/book-search`, is visited, it will default to the most recently used search
    option. You will also add a third `infocell` to the profile page that contains
    a list of links to the most recently used search terms. These are the steps that
    you need to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit the `book_search` view and retrieve `search_history` from the session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the form has received valid input and a user is logged in, append the search
    option and search text to the session's search history list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the case that the form hasn''t been filled (for example, when the page is
    first visited), render the form with the previously used `Search in` option selected,
    that is, either `Title` or `Contributor` (*Figure 9.19*):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.19: Selecting Contributor in the search page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_09_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.19: Selecting Contributor in the search page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the profile template, include an additional `infocell` division for `Search History`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'List the search history as a series of links to the book search page. The links
    will take this form: `/book-search?search=Python&search_in=title`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This activity will challenge you to apply session data to solve a usability
    issue in a web form. This approach will have applicability in many real-world
    situations and will give you some idea of the use of sessions in creating a stateful
    web experience. After completing this activity, the profile page will contain
    the third `infocell` as in *Figure 9.20*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20: The profile page with the Search History infocell'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_09_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.20: The profile page with the Search History infocell'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have examined Django's middleware implementation of authentication
    and sessions. We have learned how to incorporate authentication and permission
    logic into views and templates. We can set permissions on specific pages and limit
    their access to authenticated users. We have also examined how to store data in
    a user's session and render it in subsequent pages.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have the skills to customize a Django project to deliver a personalized
    web experience. You can limit the content to authenticated or privileged users
    and you can personalize a user's experience based on their prior interactions.
    In the next chapter, we will revisit the Admin app and learn some advanced techniques
    to customize our user model and apply fine-grained changes to the admin interface
    for our models.
  prefs: []
  type: TYPE_NORMAL
