- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: General Traits of Good Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优秀代码的一般特性
- en: This is a book about software construction with Python. Good software is built
    from a good design. By saying things such as clean code, you may be thinking that
    we will explore good practices that relate only to the implementation details
    of the software, instead of its design. However, this assumption would be wrong
    since the code is not something different from the design—the code *is* the design.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本关于使用Python进行软件构建的书。优秀的软件是由良好的设计构建的。通过说诸如“干净代码”之类的话，你可能认为我们将探讨仅与软件实现细节相关的良好实践，而不是其设计。然而，这种假设是错误的，因为代码并不是与设计不同的东西——代码*就是*设计。
- en: The code is probably the most detailed representation of the design. In the
    first two chapters, we discussed why structuring the code in a consistent way
    was important, and we have seen idioms for writing more compact and idiomatic
    code. Now it's time to understand that clean code is that, and much more—the ultimate
    goal is to make the code as robust as possible, and to write it in a way that
    minimizes defects or makes them utterly evident, should they occur.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能是设计最详细的表示。在前两章中，我们讨论了为什么以一致的方式结构化代码很重要，并看到了编写更紧凑和惯用代码的惯用语。现在，我们需要理解干净代码就是那样，而且更多——最终目标是使代码尽可能稳健，并以最小化缺陷或使缺陷显而易见的方式编写，如果它们发生的话。
- en: This chapter, and the one following, is focused on design principles at a higher
    level of abstraction. I will present the general principles of software engineering
    that are applied in Python.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以及下一章将专注于更高层次的抽象设计原则。我将介绍在Python中应用的软件工程的一般原则。
- en: In particular, for this chapter, we will review different principles that make
    for good software design. Good quality software should be built around these ideas,
    and they will serve as design tools. That does not mean that all of them should
    always be applied; in fact, some of them represent different points of view (such
    is the case with the **Design by Contract** (**DbC**) approach, as opposed to
    defensive programming). Some of them depend on the context and are not always
    applicable.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是对于本章，我们将回顾不同的原则，这些原则有助于良好的软件设计。高质量的软件应该围绕这些想法构建，并将作为设计工具。这并不意味着它们应该始终应用；实际上，其中一些代表不同的观点（例如，与**设计由合同**（**DbC**）方法相比，防御性编程）。其中一些取决于上下文，并不总是适用。
- en: High-quality code is a concept that has multiple dimensions. We can think of
    this similarly to how we think about the quality attributes of a software architecture.
    For example, we want our software to be secure and to have good performance, reliability,
    and maintainability, to name just a few attributes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 高质量代码是一个具有多个维度的概念。我们可以将其与我们思考软件架构质量属性的方式类似。例如，我们希望我们的软件是安全的，并且具有良好的性能、可靠性、可维护性，仅举几个属性。
- en: 'The goals of this chapter are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标如下：
- en: To understand the concepts behind robust software
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解稳健软件背后的概念
- en: To learn how to deal with erroneous data during the workflow of the application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在应用程序的工作流程中处理错误数据
- en: To design maintainable software that can easily be extended and adapted to new
    requirements
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计可维护的软件，使其易于扩展和适应新的需求
- en: To design reusable software
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计可重用的软件
- en: To write effective code that will keep the productivity of the development team
    high
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写有效的代码，以保持开发团队的生产力
- en: Design by contract
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计由合同
- en: Some parts of the software we are working on are not meant to be called directly
    by users, but instead by other parts of the code. Such is the case when we divide
    the responsibilities of the application into different components or layers, and
    we have to think about the interaction between them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在开发的软件的一些部分并不是直接由用户调用的，而是由代码的其他部分调用。当我们将应用程序的责任划分为不同的组件或层时，这种情况就会发生，我们必须考虑它们之间的交互。
- en: We have to encapsulate some functionality behind each component and expose an
    interface to clients who are going to use that functionality, namely, an **Application
    Programming Interface** (**API**). The functions, classes, or methods we write
    for that component have a particular way of working under certain considerations
    that, if they are not met, will make our code crash. Conversely, clients calling
    that code expect a particular response, and any failure of our function to provide
    this would represent a defect.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在每个组件后面封装一些功能，并向将使用该功能的客户端公开接口，即**应用程序编程接口**（**API**）。我们为该组件编写的函数、类或方法在特定考虑下有特定的工作方式，如果这些考虑不满足，将使我们的代码崩溃。相反，调用该代码的客户端期望得到特定的响应，而我们函数未能提供这种响应的任何失败都代表了一个缺陷。
- en: That is to say that if, for example, we have a function that is expected to
    work with a series of parameters of type integers, and some other function invokes
    ours by passing strings, it is clear that it should not work as expected, but
    in reality, the function should not run at all because it was called incorrectly
    (the client made a mistake). This error should not pass silently.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们有一个期望与一系列整数类型的参数一起工作的函数，而另一个函数通过传递字符串来调用我们的函数，那么很明显，它不应该按预期工作，但事实上，该函数根本不应该运行，因为它被错误地调用了（客户端犯了错误）。这种错误不应该无声地通过。
- en: Of course, when designing an API, the expected input, output, and side effects
    should be documented. But documentation cannot enforce the behavior of the software
    at runtime. These rules, what every part of the code expects in order to work
    properly and what the caller is expecting from them, should be part of the design,
    and here is where the concept of a **contract** comes into place.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在设计API时，应该记录预期的输入、输出和副作用。但文档不能强制软件在运行时的行为。这些规则，即代码的每个部分为了正常工作所期望的内容以及调用者从它们期望得到的内容，应该是设计的一部分，这就是**合同**概念发挥作用的地方。
- en: The idea behind the DbC approach is that, instead of implicitly placing in the
    code what every party is expecting, both parties agree on a contract that, if
    violated, will raise an exception, clearly stating why it cannot continue.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: DbC（Design by Contract）方法背后的理念是，我们不是隐式地在代码中放置各方期望的内容，而是双方同意一个合同，如果违反该合同，将引发异常，并清楚地说明为什么它不能继续。
- en: 'In our context, a contract is a construction that enforces some rules that
    must be honored during the communication of software components. A contract entails
    mainly preconditions and postconditions, but in some cases, invariants, and side
    effects are also described:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的上下文中，合同是一种强制执行某些规则的结构，这些规则必须在软件组件的通信过程中得到遵守。合同主要涉及先决条件和后置条件，但在某些情况下，也会描述不变性和副作用：
- en: '**Preconditions**: We can say that these are all the checks the code will perform
    before running. It will check for all the conditions that have to be made before
    the function can proceed. In general, it''s implemented by validating the dataset
    provided in the parameters passed, but nothing should stop us from running all
    sorts of validations (for example, validating a set in a database, a file, or
    another method that was called before) if we consider that their side effects
    are overshadowed by the importance of such validations. Note that this imposes
    a constraint on the caller.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**先决条件**：我们可以将这些检查称为代码在运行之前将执行的所有检查。它将检查在函数可以继续之前必须满足的所有条件。通常，这是通过验证在参数中提供的数据集来实现的，但如果我们认为这些验证的副作用被这种验证的重要性所掩盖，那么我们不应该停止运行各种验证（例如，验证数据库中的集合、文件或之前调用的其他方法）。请注意，这会对调用者施加约束。'
- en: '**Postconditions**: The opposite of preconditions, here, the validations are
    done after the function call is returned. Postcondition validations are run to validate
    what the caller is expecting from this component.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后置条件**：与先决条件相反，在这里，验证是在函数调用返回后进行的。后置条件验证是运行以验证调用者从这个组件期望得到的内容。'
- en: '**Invariants**: Optionally, it would be a good idea to document, in the docstring
    of a function, the invariants, the things that are kept constant while the code
    of the function is running, as an expression of the logic of the function to be
    correct.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不变性**：在函数的文档字符串中，记录不变性是一个好主意，即函数运行期间保持不变的事物，这可以作为函数逻辑正确性的表达。'
- en: '**Side effects**: Optionally, we can mention any side effects of our code in
    the docstring.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**副作用**：在文档字符串中，我们可以选择提及我们代码的任何副作用。'
- en: While conceptually, all of these items form part of the contract for a software
    component, and this is what should go to the documentation of such a piece, only
    the first two (preconditions and postconditions) are to be enforced at a low level
    (code).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从概念上讲，所有这些项目都是软件组件合同的一部分，这也是应该写入此类组件文档的内容，但只有前两个（预设条件和后置条件）需要在低级别（代码）强制执行。
- en: The reason why we would design by contract is that if errors occur, they must
    be easy to spot (and by noticing whether it was either the precondition or postcondition
    that failed, we will find the culprit much more easily) so that they can be quickly
    corrected. More importantly, we want critical parts of the code to avoid being
    executed under the wrong assumptions. This should help to clearly mark the limits
    for the responsibilities and errors if they occur, as opposed to something saying
    that this part of the application is failing. But the caller code provided the
    wrong arguments, so where should we apply the fix?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以会按合同设计，是因为如果出现错误，它们必须容易发现（通过注意到是预设条件还是后置条件失败，我们将更容易找到罪魁祸首），以便它们可以迅速纠正。更重要的是，我们希望代码的关键部分避免在错误假设下执行。这应该有助于清楚地标记责任和错误的界限，如果发生错误，而不是说这个应用程序的部分失败了。但是，调用代码提供了错误的参数，那么我们应该在哪里应用修复？
- en: The idea is that preconditions bind the client (they have an obligation to meet
    them if they want to run some part of the code), whereas postconditions bind the
    component in relation to some guarantees that the client can verify and enforce.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，预设条件将客户端（如果它们想要运行代码的某些部分，就有义务满足它们），而后置条件将组件与客户端可以验证和执行的某些保证联系起来。
- en: This way, we can quickly identify responsibilities. If the precondition fails,
    we know it is due to a defect on the client. On the other hand, if the postcondition
    check fails, we know the problem is in the routine or class (supplier) itself.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以快速识别责任。如果预设条件失败，我们知道这是由于客户端的缺陷造成的。另一方面，如果后置条件检查失败，我们知道问题在于程序或类（供应商）本身。
- en: Specifically, regarding preconditions, it is important to highlight that they
    can be checked at runtime, and if they occur, the code that is being called should
    not be run at all (it does not make sense to run it because its conditions do
    not hold, and doing so might end up making things worse).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，关于预设条件，重要的是要强调它们可以在运行时进行检查，如果它们发生，被调用的代码根本不应该运行（因为它的条件不成立，这样做可能会使事情变得更糟）。
- en: Preconditions
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预设条件
- en: Preconditions are all of the guarantees a function or method expects to receive
    in order to work correctly. In general programming terms, this usually means providing
    data that is properly formed, for example, objects that are initialized, non-null
    values, and many more. For Python, in particular, being dynamically typed, this
    also means that sometimes we need to check for the exact type of data that is
    provided. This is not exactly the same as type checking, the `mypy` kind would
    do this, but rather verify the exact values that are needed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 预设条件是函数或方法为了正确工作而期望接收的所有保证。在一般编程术语中，这通常意味着提供正确形成的数据，例如，初始化的对象、非空值等等。对于Python来说，特别是动态类型，这也意味着有时我们需要检查提供的数据的确切类型。这并不完全等同于类型检查，`mypy`这样的工具会做这种检查，而是验证所需的精确值。
- en: Part of these checks can be detected early on by using static analysis tools,
    such as `mypy`, which we already introduced in *Chapter 1*, *Introduction, Code
    Formatting, and Tools*, but these checks are not enough. A function should have
    proper validation for the information that it is going to handle.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些检查的一部分可以通过使用静态分析工具（如`mypy`）在早期检测到，我们在*第一章*，*介绍、代码格式化和工具*中已经介绍了它，但这些检查是不够的。一个函数应该对其将要处理的信息进行适当的验证。
- en: Now, this poses the question of where to place the validation logic, depending
    on whether we let the clients validate all the data before calling the function,
    or allow this one to validate everything that it received prior to running its
    own logic. The former equates to a tolerant approach (because the function itself
    is still allowing any data, potentially malformed data as well), whereas the latter
    equates to a demanding approach.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这提出了一个问题，即验证逻辑应该放在哪里，这取决于我们是否让客户端在调用函数之前验证所有数据，或者允许它在运行自己的逻辑之前验证它所接收到的所有内容。前者等同于宽容的方法（因为函数本身仍然允许任何数据，包括潜在的不规范数据），而后者等同于严格的方法。
- en: For the purposes of this analysis, we prefer a demanding approach when it comes
    to DbC because it is usually the safest choice in terms of robustness, and usually
    the most common practice in the industry.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次分析中，我们倾向于对 DbC 采用严格的方法，因为它在稳健性方面通常是最佳选择，并且在行业中通常是最常见的实践。
- en: Regardless of the approach we decide to take, we should always keep in mind
    the non-redundancy principle, which states that the enforcement of each precondition
    for a function should be done by only one of the two parts of the contract, but
    not both. This means that we put the validation logic on the client, or we leave
    it to the function itself, but in no case should we duplicate it (which also relates
    to the DRY principle, which we will discuss later on in this chapter).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们决定采取哪种方法，我们都应该始终牢记非冗余原则，该原则指出，对于函数的每个先决条件的执行，应由合同的任一部分而不是两部分来完成。这意味着我们将验证逻辑放在客户端，或者将其留给函数本身，但在任何情况下都不应该重复它（这也与DRY原则相关，我们将在本章后面讨论）。
- en: Postconditions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后置条件
- en: Postconditions are the part of the contract that is responsible for enforcing
    the state after the method or function has returned.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 后置条件是合同的一部分，负责在方法或函数返回后强制执行状态。
- en: Assuming that the function or method has been called with the correct properties
    (that is, with its preconditions met), then the postconditions will guarantee
    that certain properties are preserved.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设函数或方法已经以正确的属性（即，满足其先决条件）被调用，那么后置条件将保证某些属性得到保留。
- en: The idea is to use postconditions to check and validate everything that a client
    might need. If the method executed properly, and the postcondition validations
    pass, then any client calling that code should be able to work with the returned
    object without problems, as the contract has been fulfilled.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是使用后置条件来检查和验证客户端可能需要的所有内容。如果方法执行得当，后置条件验证通过，那么任何调用该代码的客户端都应该能够无问题地与返回的对象一起工作，因为合同已经得到履行。
- en: Pythonic contracts
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pythonic contracts
- en: At the time of writing this book, a PEP-316, named *Programming by Contract
    for Python*, is deferred. That doesn't mean that we cannot implement it in Python
    because, as introduced at the beginning of the chapter, this is a general design
    principle.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，一个名为 PEP-316 的名为 *Programming by Contract for Python* 的提案已被推迟。这并不意味着我们不能在
    Python 中实现它，因为，如本章开头所述，这是一个通用设计原则。
- en: Probably the best way to enforce this is by adding control mechanisms to our
    methods, functions, and classes, and if they fail, raise a `RuntimeError` exception
    or `ValueError`. It's hard to devise a general rule for the correct type of exception,
    as that would pretty much depend on the application in particular. These previously
    mentioned exceptions are the most common types of exception, but if they don't
    fit accurately with the problem, creating a custom exception would be the best
    choice.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最好的强制执行方式是在我们的方法、函数和类中添加控制机制，如果它们失败，则抛出 `RuntimeError` 异常或 `ValueError`。很难制定一个关于正确异常类型的通用规则，因为这很大程度上取决于特定的应用程序。前面提到的异常是最常见的异常类型，但如果它们与问题不精确匹配，创建一个自定义异常将是最佳选择。
- en: We would also like to keep the code as isolated as possible. That is, the code
    for the preconditions in one part, the one for the postconditions in another,
    and the core of the function separated. We could achieve this separation by creating
    smaller functions, but in some cases implementing a decorator would be an interesting
    alternative.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望尽可能地将代码隔离。也就是说，前置条件的代码在一个部分，后置条件的代码在另一个部分，函数的核心分开。我们可以通过创建更小的函数来实现这种分离，但在某些情况下，实现一个装饰器可能是一个有趣的替代方案。
- en: Design by contract – conclusions
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计原则——结论
- en: The main value of this design principle is to effectively identify where the
    problem is. By defining a contract, when something fails at runtime, it will be
    clear what part of the code is broken, and what broke the contract.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计原则的主要价值是有效地识别问题所在。通过定义合同，当运行时出现问题时，将清楚地知道是代码的哪个部分出了问题，以及是什么破坏了合同。
- en: As a result of following this principle, the code will be more robust. Each
    component is enforcing its own constraints and maintaining some invariants, and
    the program can be proven correct as long as these invariants are preserved.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这一原则的结果是代码将更加稳健。每个组件都在执行自己的约束并保持一些不变性，只要这些不变性得到保持，程序就可以被证明是正确的。
- en: It also serves the purpose of clarifying the structure of the program better.
    Instead of trying to run ad hoc validations, or trying to surmount all possible
    failure scenarios, the contracts explicitly specify what each function or method
    expects to work properly, and what is expected from them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 它还起到了更好地阐明程序结构的作用。而不是尝试运行临时的验证，或者尝试克服所有可能的失败场景，合约明确指定了每个函数或方法期望正常工作的内容，以及期望从它们那里得到的内容。
- en: Of course, following these principles also adds extra work, because we are not
    just programming the core logic of our main application, but also the contracts.
    In addition, we might want to consider adding unit tests for these contracts as
    well. However, the quality gained by this approach pays off in the long run; hence,
    it is a good idea to implement this principle for critical components of the application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，遵循这些原则也会增加额外的工作，因为我们不仅正在编写主应用程序的核心逻辑，还在编写合约。此外，我们可能还想考虑为这些合约添加单元测试。然而，这种方法获得的质量在长期来看是值得的；因此，为应用程序的关键组件实现这一原则是一个好主意。
- en: Nonetheless, for this method to be effective, we should carefully think about
    what we are willing to validate, and this has to be a meaningful value. For example,
    it would not make much sense to define contracts that only check for the correct
    data types of the parameters provided to a function. Many programmers would argue
    that this would be like trying to make Python a statically typed language. Regardless
    of this, tools such as `mypy`, in combination with the use of annotations, would
    serve this purpose much better and with less effort. With that in mind, design
    contracts so that there is actually value in them, checking, for example, the
    properties of the objects being passed and returned, the conditions they have
    to abide by, and so on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了使这种方法有效，我们应该仔细思考我们愿意验证的内容，这必须是一个有意义的值。例如，定义仅检查传递给函数的参数的正确数据类型的合约并没有太多意义。许多程序员会认为这就像试图将Python变成一种静态类型语言。不管怎样，结合使用注解的工具，如`mypy`，将更好地实现这一目的，并且更加省力。考虑到这一点，设计合约，以便它们确实具有价值，例如检查传递和返回的对象的性质，它们必须遵守的条件，等等。
- en: Defensive programming
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防御性编程
- en: Defensive programming follows a somewhat different approach to DbC. Instead
    of stating all conditions that must be held in a contract, which, if unmet, will
    raise an exception and make the program fail, this is more about making all parts
    of the code (objects, functions, or methods) able to protect themselves against
    invalid inputs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编程遵循与DbC略有不同的方法。它不是在合约中声明所有必须满足的条件，如果未满足，将引发异常并使程序失败，而是更多地使代码的各个部分（对象、函数或方法）能够保护自己免受无效输入的影响。
- en: Defensive programming is a technique that has several aspects, and it is particularly
    useful if it is combined with other design principles (this means that the fact
    that it follows a different philosophy to DbC does not mean that it is a case
    of either one or the other—it could mean that they might complement one another).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编程是一种具有多个方面的技术，如果与其他设计原则相结合（这意味着它遵循与DbC不同的哲学并不意味着它只能是其中之一——它可能意味着它们可能相互补充）特别有用。
- en: The main ideas on the subject of defensive programming are how to handle errors
    for scenarios that we might expect to occur, and how to deal with errors that
    should never occur (when impossible conditions happen). The former will fall into
    error handling procedures, while the latter will be the case for assertions. Both
    topics are explored in the following sections.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编程的主要思想是如何处理我们可能预期发生的场景的错误，以及如何处理不应该发生的错误（当不可能的条件发生时）。前者将落入错误处理程序，而后者将是断言的情况。这两个主题将在以下章节中探讨。
- en: Error handling
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: In our programs, we resort to error handling procedures for situations that
    we anticipate as prone to cause errors. This is usually the case for data input.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，我们求助于错误处理程序来处理我们预期可能导致错误的场景。这通常适用于数据输入。
- en: The idea behind error handling is to gracefully respond to these expected errors
    in an attempt to either continue our program execution or decide to fail if the
    error turns out to be insurmountable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理的理念是在尝试继续我们的程序执行或决定失败的情况下优雅地响应这些预期的错误。
- en: 'There are different approaches by which we can handle errors on our programs,
    but not all of them are always applicable. Some of these approaches are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过不同的方法来处理程序中的错误，但并非所有方法都总是适用。以下是一些方法：
- en: Value substitution
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值替换
- en: Error logging
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误记录
- en: Exception handling
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: In the next two sections, we'll focus on value substitution and exception handling,
    because these forms of error handling provide more interesting analysis. Error
    logging is a complementary practice (and a good one; we should always log errors),
    but most of the time we only log when there's nothing else to be done, so the
    other methods provide more interesting alternatives.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我们将重点关注值替换和异常处理，因为这些形式的错误处理提供了更有趣的分析。错误记录是一种补充实践（而且是一个好的实践；我们应该始终记录错误），但大多数时候我们只有在没有其他事情可做时才记录，所以其他方法提供了更有趣的替代方案。
- en: Value substitution
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值替换
- en: In some scenarios, when there is an error and there is a risk of the software
    producing an incorrect value or failing entirely, we might be able to replace
    the result with another, safer value. We call this value substitution, since we
    are, in fact, replacing the actual erroneous result for a value that is to be
    considered non-disruptive (it could be a default, a well-known constant, a sentinel
    value, or simply something that does not affect the result at all, such as returning
    zero in a case where the result is intended to be applied to a sum).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，当出现错误并且有软件产生不正确值或完全失败的风险时，我们可能能够用另一个更安全的值替换结果。我们称之为值替换，因为我们实际上是在用要考虑为非破坏性的值（它可能是一个默认值、一个已知的常量、一个哨兵值，或者简单地是根本不影响结果的东西，例如在结果打算应用于求和的情况下返回零）来替换实际错误的结果。
- en: Value substitution is not always possible, however. This strategy has to be
    carefully chosen for cases where the substituted value is a safe option. Making
    this decision is a trade-off between robustness and correctness. A software program
    is robust when it does not fail, even in the presence of an erroneous scenario.
    But this is not correct either.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 值替换并不总是可行的。然而，对于替换的值是安全选项的情况，这种策略必须谨慎选择。做出这个决定是在鲁棒性和正确性之间进行权衡。一个软件程序在存在错误场景的情况下不会失败，这就是它的鲁棒性。但这也不完全正确。
- en: This might not be acceptable for some kinds of software. If the application
    is critical, or the data being handled is too sensitive, this is not an option,
    since we cannot afford to provide users (or other parts of the application) with
    erroneous results. In these cases, we opt for correctness, rather than let the
    program explode when yielding the wrong results.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些类型的软件，这可能是不被接受的。如果应用程序是关键的，或者处理的数据过于敏感，这不是一个选择，因为我们无法承担向用户提供（或应用程序的其他部分）错误结果的风险。在这些情况下，我们选择正确性，而不是让程序在产生错误结果时崩溃。
- en: A slightly different, and safer, version of this decision is to use default
    values for data that is not provided. This can be the case for parts of the code
    that can work with a default behavior, for example, default values for environment
    variables that are not set, for missing entries in configuration files, or for
    parameters of functions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微不同且更安全的决策版本是为未提供的数据使用默认值。这可能适用于可以与默认行为一起工作的代码部分，例如，未设置的环境变量的默认值、配置文件中的缺失条目或函数的参数。
- en: 'We can find examples of Python supporting this throughout different methods
    of its API, for example, dictionaries have a `get` method, whose (optional) second
    parameter allows you to indicate a default value:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Python的API的不同方法中找到支持这一点的例子，例如，字典有一个`get`方法，它的（可选的）第二个参数允许你指定一个默认值：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Environment variables have a similar API:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量有类似的API：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In both previous examples, if the second parameter is not provided, `None`
    will be returned because it''s the default value those functions are defined with.
    We can also define default values for the parameters of our own functions:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个例子中，如果第二个参数没有提供，`None`将被返回，因为这是这些函数定义时的默认值。我们也可以为我们的函数参数定义默认值：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In general, replacing missing parameters with default values is acceptable,
    but substituting erroneous data with legal close values is more dangerous and
    can mask some errors. Take this criterion into consideration when deciding on
    this approach.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，用默认值替换缺失的参数是可以接受的，但用合法的近似值替换错误数据更危险，可能会掩盖一些错误。在决定采用这种方法时，请考虑这一标准。
- en: Exception handling
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常处理
- en: In the presence of incorrect or missing input data, sometimes it is possible
    to correct the situation with some examples, such as the ones mentioned in the
    previous section. In other cases, however, it is better to stop the program from
    continuing to run with the wrong data than to leave it computing under erroneous
    assumptions. In those cases, failing and notifying the caller that something is
    wrong is a good approach, and this is the case for a precondition that was violated,
    as we saw in DbC.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在存在不正确或缺失的输入数据的情况下，有时可以通过一些示例来纠正这种情况，例如前一个章节中提到的。然而，在其他情况下，停止程序继续运行以避免使用错误数据，而不是让它基于错误假设进行计算，可能更好。在这些情况下，失败并通知调用者有问题是一个好的方法，正如我们在DbC中看到的那样。
- en: Nonetheless, erroneous input data is not the only possible way in which a function
    can go wrong. After all, functions are not just about passing data around; they
    also have side effects and connect to external components.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，错误输入数据并不是函数出错的可能方式中唯一的一种。毕竟，函数不仅仅是关于传递数据；它们还有副作用并连接到外部组件。
- en: It could be possible that a fault in a function call is due to a problem on
    one of these external components, and not in our function itself. If that is the
    case, our function should communicate this properly. This will make it easier
    to debug. The function should clearly, and unambiguously, notify the rest of the
    application regarding errors that cannot be ignored so that they can be addressed
    accordingly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用中的错误可能是由这些外部组件中的一个出现问题造成的，而不是我们自己的函数本身。如果是这种情况，我们的函数应该适当地传达这一点。这将使调试更容易。函数应该明确且无歧义地通知应用程序的其他部分有关无法忽略的错误，以便它们可以相应地处理。
- en: The mechanism for accomplishing this is an exception. It is important to emphasize
    that this is what exceptions should be used for—clearly announcing an exceptional
    situation, and not altering the flow of the program according to business logic.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一机制的是异常。重要的是要强调，这就是异常应该被用于——明确宣布一个异常情况，而不是根据业务逻辑改变程序的流程。
- en: If the code tries to use exceptions to handle expected scenarios or business
    logic, the flow of the program will become harder to read. This will lead to a
    situation where exceptions are used as a sort of `go-to` statement, which (to
    make things worse) could span multiple levels on the call stack (up to caller
    functions), violating the encapsulation of the logic into its correct level of
    abstraction. The case could get even worse if these `except` blocks are mixing
    business logic with truly exceptional cases that the code is trying to defend
    against; in that case, it will be harder to distinguish between the core logic
    we have to maintain and the errors to be handled.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码试图使用异常来处理预期的场景或业务逻辑，程序的流程将变得难以阅读。这会导致异常被用作一种“跳转”语句，这（更糟糕的是）可能会跨越调用栈的多个级别（直到调用函数），违反了逻辑封装到正确抽象级别的原则。如果这些`except`块将业务逻辑与代码试图防御的真正异常情况混合在一起，情况可能会变得更糟；在这种情况下，将难以区分我们必须维护的核心逻辑和要处理的问题。
- en: Do not use exceptions as a `go-to` mechanism for business logic. Raise exceptions
    when there is something wrong with the code that callers need to be aware of.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将异常作为业务逻辑的“万能”机制。当代码出现调用者需要了解的问题时，才抛出异常。
- en: This last concept is an important one; exceptions are usually about notifying
    the caller about something amiss. This means that exceptions should be used carefully
    because they weaken encapsulation. The more exceptions a function has, the more
    the caller function will have to anticipate, therefore knowing about the function
    it is calling. And if a function raises too many exceptions, this means that it
    is not so context-free, because every time we want to invoke it, we will have
    to keep all of its possible side effects in mind.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的概念非常重要；异常通常是为了通知调用者出现了某些问题。这意味着异常应该谨慎使用，因为它们会削弱封装性。一个函数拥有的异常越多，调用函数就需要越多的预期，因此需要了解它所调用的函数。如果一个函数抛出了太多的异常，这意味着它不是那么上下文无关的，因为每次我们想要调用它时，我们都需要记住它所有的可能副作用。
- en: This can be used as a heuristic to tell when a function is not sufficiently
    cohesive and has too many responsibilities. If it raises too many exceptions,
    it could be a sign that it has to be broken down into multiple, smaller ones.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用作一种启发式方法来判断一个函数是否不够内聚并且承担了过多的职责。如果它抛出了太多的异常，这可能是一个信号，表明它需要被分解成多个更小的部分。
- en: Here are some recommendations that relate to exceptions in Python.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些与 Python 中的异常相关的建议。
- en: Handling exceptions at the right level of abstraction
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在适当的抽象级别处理异常
- en: Exceptions are also part of the principal functions that do one thing, and one
    thing only. The exception the function is handling (or raising) has to be consistent
    with the logic encapsulated on it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 异常也是那些只做一件事的主要函数的一部分。函数处理（或引发）的异常必须与封装在其上的逻辑一致。
- en: 'In the following example, we can see what we mean by mixing different levels
    of abstractions. Imagine an object that acts as a transport for some data in our
    application. It connects to an external component where the data is going to be
    sent upon decoding. In the following listing, we will focus on the `deliver_event`
    method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们可以看到我们所说的不同抽象层次混合的含义。想象一个对象，它在我们的应用程序中充当某些数据传输的角色。它连接到外部组件，数据在解码后将被发送。在下面的列表中，我们将关注
    `deliver_event` 方法：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For our analysis, let's zoom in and focus on how the `deliver_event()` method
    handles exceptions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的分析，让我们聚焦于 `deliver_event()` 方法如何处理异常。
- en: What does `ValueError` have to do with `ConnectionError`? Not much. By looking
    at these two highly different types of error, we can get an idea of how responsibilities
    should be divided.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueError` 与 `ConnectionError` 有什么关系？不多。通过观察这两种高度不同的错误类型，我们可以了解责任应该如何划分。'
- en: '`ConnectionError` should be handled inside the `connect` method. This allows
    a clear separation of behavior. For example, if this method needs to support retries,
    then handling said exception would be a way of doing it.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConnectionError` 应该在 `connect` 方法内部处理。这允许行为有清晰的分离。例如，如果这个方法需要支持重试，那么处理这个异常就是一种实现方式。'
- en: Conversely, `ValueError` belongs to the `decode` method of the event. With this
    new implementation (shown in the next example), this method does not need to catch
    any exception—the exceptions we were worrying about before are either handled
    by internal methods or deliberately left to be raised.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`ValueError` 属于事件的 `decode` 方法。在这个新的实现（在下一个示例中展示）中，这个方法不需要捕获任何异常——我们之前担心的异常要么被内部方法处理，要么被故意留下以引发。
- en: 'We should separate these fragments into different methods or functions. For
    the connection management, a small function should be enough. This function will
    be in charge of trying to establish the connection, catching exceptions (should
    they occur), and logging them accordingly:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将这些片段分离成不同的方法或函数。对于连接管理，一个小函数就足够了。这个函数将负责尝试建立连接，捕获异常（如果发生），并相应地记录：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we will call this function in our method. As for the `ValueError` exception
    on the event, we could separate it with a new object and do composition, but for
    this limited case it would be overkill, so just moving the logic to a separate
    method would be enough. With these two considerations in place, the new version
    of the method looks much more compact and easier to read:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在我们的方法中调用这个函数。至于事件上的 `ValueError` 异常，我们可以通过一个新的对象将其分离，并进行组合，但在这个有限的案例中，这将是过度设计，所以只需将逻辑移动到单独的方法就足够了。有了这两个考虑因素，方法的新版本看起来更加紧凑，更容易阅读：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See now how the separation of the exception classes also delimits a separation
    in responsibilities. In the first example shown, everything was mixed, and there
    wasn't a clear separation of concerns. Then we decided the connection as a concern
    on itself, so in the next example, the `connect_with_retry` function was created,
    and `ConnectionError` was being handled as part of this function, if we needed
    to modify that function (as we had). On the other hand, the `ValueError` wasn't
    part of that same logic, so it was left in the `send` method where it belongs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看异常类的分离如何也界定了责任的分离。在第一个示例中，一切都被混合在一起，没有明确的关注点分离。然后我们决定将连接作为一个单独的关注点，所以在下一个示例中，创建了
    `connect_with_retry` 函数，并且 `ConnectionError` 作为这个函数的一部分被处理，如果我们需要修改这个函数（就像我们做的那样）。另一方面，`ValueError`
    不属于那个相同的逻辑，所以它被留在了 `send` 方法中，那里才是它应该存在的地方。
- en: Exceptions carry a meaning. For that reason, it's important to handle each type
    of exception at its right level of abstraction (that means, depending on the layer
    of our application they belong to). But they can also carry important information
    sometimes. And since this information might be sensitive, we don't want it to
    fall into the wrong hands, so in the next section we'll discuss the security implications
    of exceptions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 异常具有意义。因此，处理每种类型的异常都应在适当的抽象级别上进行（这意味着，根据它们属于我们应用程序的哪一层）。但它们有时也可能携带重要信息。由于这些信息可能敏感，我们不希望它们落入错误的手中，因此在下节中，我们将讨论异常的安全影响。
- en: Do not expose tracebacks to end users
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不要向最终用户暴露回溯信息
- en: This is a security consideration. When dealing with exceptions, it might be
    acceptable to let them propagate if the error is too important, and maybe even
    let the program fail if this is the decision for that particular scenario and
    correctness was favored over robustness.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个安全考虑。在处理异常时，如果错误非常重要，可能甚至允许程序在这种情况下失败，因为正确性被优先于鲁棒性。
- en: When there is an exception that denotes a problem, it's important to log in
    with as much detail as possible (including the traceback information, message,
    and all we can gather) so that the issue can be corrected efficiently. At the
    same time, we want to include as much detail as possible for ourselves—we don't
    want any of this becoming visible to users.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在表示问题的异常时，重要的是尽可能详细地记录（包括回溯信息、消息以及我们能收集到的所有信息），以便可以有效地纠正问题。同时，我们希望尽可能详细地记录给自己——我们不希望任何这些信息对用户可见。
- en: In Python, tracebacks of exceptions contain very rich and useful debugging information.
    Unfortunately, this information is also very useful for attackers or malicious
    users who want to try and harm the application, not to mention that the leak would
    represent an important information disclosure, jeopardizing the intellectual property
    of your organization (as parts of the code will be exposed).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，异常的回溯包含非常丰富和有用的调试信息。不幸的是，这些信息对攻击者或恶意用户来说也非常有用，他们试图尝试并损害应用程序，更不用说这种泄露会代表重要的信息泄露，危害你组织的知识产权（因为代码的一部分将被暴露）。
- en: If you choose to let exceptions propagate, make sure not to disclose any sensitive
    information. Also, if you have to notify users about a problem, choose generic
    messages (such as `Something went wrong`, or `Page not found`). This is a common
    technique used in web applications that display generic informative messages when an
    HTTP error occurs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择让异常传播，确保不要泄露任何敏感信息。另外，如果你必须通知用户有关问题，请选择通用的消息（例如“出了点问题”，或“页面未找到”）。这是在发生HTTP错误时，显示通用信息性消息的Web应用程序中常用的一种技术。
- en: Avoid empty except blocks
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 避免空异常块
- en: This was even referred to as the most diabolical Python anti-pattern (REAL 01).
    While it is good to anticipate and defend our programs against some errors, being
    too defensive might lead to even worse problems. In particular, the only problem
    with being too defensive is that there is an empty `except` block that silently
    passes without doing anything.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至被称为最邪恶的Python反模式（REAL 01）。虽然预测并防御程序中的某些错误是好的，但过于防御可能会带来更糟糕的问题。特别是，过于防御的唯一问题是存在一个空的`except`块，它默默地通过而不做任何事情。
- en: 'Python is so flexible that it allows us to write code that can be faulty and
    yet, will not raise an error, like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Python非常灵活，允许我们编写即使有缺陷也不会引发错误的代码，如下所示：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The problem with this is that it will not fail, ever, even when it should. It
    is also non-Pythonic if you remember from the Zen of Python that errors should
    never pass silently.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在于它永远不会失败，即使它应该失败。如果你还记得Python的禅宗，错误永远不应该默默通过，这也是非Pythonic的。
- en: Configure your continuous integration environment (by using tools such as those
    explored in *Chapter 1*, *Introduction, Code Formatting, and Tools*) to automatically
    report on empty exception blocks.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 配置你的持续集成环境（通过使用在*第一章*、*简介、代码格式化和工具*中探讨的工具），以自动报告空异常块。
- en: In the event of an exception, this block of code will not fail, which might
    be what we wanted in the first place. But what if there is a defect? There might
    occur an actual failure when the `process_data()` function runs, and we would
    like to know if there is an error in our logic in order to be able to correct
    it. Writing blocks such as this one will mask problems, making things harder to
    maintain.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在发生异常的情况下，这段代码将不会失败，这可能正是我们最初想要的。但如果有缺陷呢？当`process_data()`函数运行时可能会发生实际失败，我们希望知道我们的逻辑中是否存在错误，以便能够纠正它。编写这样的代码块将掩盖问题，使维护变得更加困难。
- en: 'There are two alternatives:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种替代方案：
- en: Catch a more specific exception (not too broad, such as an `Exception`). In
    fact, some linting tools and IDEs will warn you in some cases when the code is
    handling too broad an exception.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获更具体的异常（不要太宽泛，例如`Exception`）。实际上，在某些情况下，一些代码检查工具和IDE会警告你代码处理了过于宽泛的异常。
- en: Perform some actual error handling on the `except` block.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`except`块上执行一些实际的错误处理。
- en: The best thing to do would be to apply both recommendations. Handling a more
    specific exception (for example, `AttributeError` or `KeyError`) will make the
    program more maintainable because the reader will know what to expect and can
    get an idea of the *why* of it. It will also leave other exceptions free to be
    raised, and if that happens, this probably means a bug, only this time it can
    be discovered.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是应用这两项建议。处理更具体的异常（例如，`AttributeError`或`KeyError`）将使程序更易于维护，因为读者将知道期望什么，并且可以了解其*原因*。它还将使其他异常能够被引发，如果发生这种情况，这通常意味着一个错误，但这次可以被发现。
- en: Handling the exception itself can mean multiple things. In its simplest form,
    it could be just about logging the exception (make sure to use `logger.exception`
    or `logger.error` to provide the full context of what happened). Other alternatives
    could be to return a default value (substitution, only that in this case after
    detecting an error, not prior to causing it), or raising a different exception.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常本身可能意味着多种情况。在其最简单的形式中，它可能只是关于记录异常（确保使用`logger.exception`或`logger.error`来提供发生事件的完整上下文）。其他替代方案可能包括返回默认值（替换，只是在检测到错误后，而不是在引发错误之前），或者引发不同的异常。
- en: If you choose to raise a different exception, include the original exception
    that caused the problem (see the next section).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择引发不同的异常，包括导致问题的原始异常（参见下一节）。
- en: 'Another reason to avoid having an empty `except` block (using `pass`) is the
    implicitness of it: it doesn''t tell readers of the code that we actually expect
    that exception to be ignored. A more explicit way of doing so would be to use
    the `contextlib.suppress` function, which can accept all exceptions as arguments
    that are to be ignored, and it can be used as a context manager.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用空的`except`块（使用`pass`）的另一个原因是它的隐含性：它没有告诉代码的读者我们实际上期望忽略该异常。一个更明确的方法是使用`contextlib.suppress`函数，它可以接受所有要忽略的异常作为参数，并且可以用作上下文管理器。
- en: 'In our example, it might look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，它可能看起来像这样：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Again, as with the previous case, try to avoid passing the general `Exception`
    to this context manager, because the effect will be the same.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，正如前一个案例一样，尽量避免将通用的`Exception`传递给这个上下文管理器，因为效果将是相同的。
- en: Include the original exception
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 包含原始异常
- en: As part of our error handling logic, we might decide to raise a different one,
    and maybe even change its message. If that is the case, it is recommended to include
    the original exception that led to that.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们错误处理逻辑的一部分，我们可能会决定引发不同的异常，甚至可能更改其消息。如果是这种情况，建议包括导致该异常的原始异常。
- en: We can use the `raise <e> from <original_exception>` syntax (PEP-3134). When
    using this construction, the original traceback will be embedded into the new
    exception, and the original exception will be set in the `__cause__` attribute
    of the resulting one.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`raise <e> from <original_exception>`语法（PEP-3134）。当使用这种结构时，原始的堆栈跟踪将被嵌入到新的异常中，原始异常将被设置在结果异常的`__cause__`属性中。
- en: 'For example, if we desire to wrap default exceptions with custom ones internally
    to our project, we could still do that while including information about the root
    exception:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们希望将默认异常包装成我们项目内部的定制异常，我们仍然可以这样做，同时包括关于根异常的信息：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Always use the `raise <e> from <o>` syntax when changing the type of the exception.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改异常类型时，始终使用`raise <e> from <o>`语法。
- en: Using this syntax will make the tracebacks contain more information about the
    exception or the error that has just occurred, which will help significantly when
    debugging.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种语法将使回溯包含更多关于刚刚发生的异常或错误的信息，这将在调试时非常有帮助。
- en: Using assertions in Python
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Python中使用断言
- en: Assertions are to be used for situations that should never happen, so the expression
    on the `assert` statement has to mean an impossible condition. Should this condition
    happen, it means there is a defect in the software.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 断言应该用于那些永远不会发生的情况，因此`assert`语句上的表达式必须意味着一个不可能的条件。如果这个条件发生，这意味着软件中存在缺陷。
- en: In contrast to the error handling approach, there are situations in which we
    don't want our program to continue its execution if a particular error occurred.
    This is because, in some cases, the error cannot be surmounted, and our program
    cannot correct its course of execution (or self-heal), so it's better to fail
    fast, and let the error be noticed, so it can be corrected with the next version
    upgrade.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与错误处理方法相反，有些情况下我们不希望程序在发生特定错误时继续执行。这是因为，在某些情况下，错误无法克服，我们的程序无法纠正其执行路径（或自我修复），因此最好是快速失败，让错误被注意到，以便在下一个版本升级时得到纠正。
- en: The idea of using assertions is to prevent the program from causing further
    damage if such an invalid scenario is presented. Sometimes, it is better to stop
    and let the program crash rather than let it continue processing under the wrong
    assumptions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用断言的目的是防止程序在出现此类无效场景时造成进一步损害。有时，停止程序并让它崩溃比让它基于错误假设继续处理要好。
- en: By definition, an assertion is a Boolean condition in the code that must hold
    true for the program to be correct. If the program fails because of an `AssertionError`,
    it means a defect has just been uncovered.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，断言是代码中的一个布尔条件，程序必须为真才能正确运行。如果程序因`AssertionError`而失败，这意味着刚刚发现了一个缺陷。
- en: 'For this reason, assertions should not be mixed with the business logic, or
    used as control flow mechanisms for the software. The following example is a bad
    idea:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，断言不应该与业务逻辑混合，或者用作软件的控制流机制。以下是一个坏主意：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Do not catch the `AssertionError` exception because it might be confusing for
    readers of the code. If you're expecting some part of your code to raise an exception,
    try to use a more specific one.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 不要捕获`AssertionError`异常，因为这可能会让代码的读者感到困惑。如果你期望代码的某个部分抛出异常，尝试使用更具体的一个。
- en: The previous advice of catching the `AssertionError` goes along the lines of
    not letting your program fail silently. But it could fail gracefully. So, instead
    of letting the application have a hard crash, you can catch the `AssertionError`
    and show a generic error message, while still logging all the internal error details
    to the logging platform of your company. The point is not exactly about whether
    or not to catch this exception, but that assertion errors are a valuable source
    of information that will help you improve the quality of your software.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 之前关于捕获`AssertionError`的建议是不要让你的程序无声失败。但它可以优雅地失败。所以，与其让应用程序硬崩溃，不如捕获`AssertionError`并显示一个通用的错误消息，同时仍然将所有内部错误细节记录到公司的日志平台。关键不在于是否捕获这个异常，而在于断言错误是宝贵的信息来源，这将帮助你提高软件的质量。
- en: Make sure that the program terminates when an assertion fails. This means that
    assertions are usually put in the code to identify erroneous parts of the program.
    There's a tendency in many programming languages to think that assertions can
    be suppressed when the program is running in production, but that defeats its
    purpose, because the point of them is to precisely let us know about those parts
    of the program that need to be fixed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 确保断言失败时程序终止。这意味着断言通常被放在代码中以识别程序中的错误部分。在许多编程语言中存在一种趋势，认为当程序在生产环境中运行时可以抑制断言，但这违背了其目的，因为它们的目的正是让我们确切地知道那些需要修复的程序部分。
- en: In Python, in particular, running with the `–O` flag will suppress the `assert`
    statements, but this is discouraged for the aforementioned reasons.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，特别是，使用`–O`标志将抑制`assert`语句，但出于上述原因，这被劝阻。
- en: Do not run your production programs with `python –O` … as you'd like to take
    advantage of the assertions in the code to correct defects.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用`python –O`运行你的生产程序，因为你想利用代码中的断言来纠正缺陷。
- en: Include a descriptive error message in the assertion statement and log the errors
    to make sure that you can properly debug and correct the problem later on.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在断言语句中包含一个描述性的错误消息，并将错误记录下来，以确保你可以正确地调试和纠正问题。
- en: Another important reason why the previous code is a bad idea is that besides
    catching `AssertionError`, the statement in the assertion is a function call.
    Function calls can have side effects, and they aren't always repeatable (we don't
    know if calling `condition.holds()` again will yield the same result). Moreover,
    if we stop the debugger at that line, we might not be able to conveniently see
    the result that causes the error, and, again, even if we call that function again,
    we don't know if that was the offending value.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的原因是，之前的代码方案不好，除了捕获`AssertionError`之外，断言中的语句还是一个函数调用。函数调用可能会有副作用，并且它们并不总是可重复的（我们不知道再次调用`condition.holds()`是否会得到相同的结果）。此外，如果我们在这个语句处停止调试器，我们可能无法方便地看到导致错误的那个结果，而且，即使我们再次调用该函数，我们也不知道那个值是否是导致错误的原因。
- en: 'A better alternative requires a few more lines of code, but provides more useful
    information:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的替代方案需要更多的代码行，但提供了更有用的信息：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When using assertions, try to avoid using function calls directly, and write
    the expression in terms of local variables.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用断言时，尽量避免直接使用函数调用，而是用局部变量的形式来编写表达式。
- en: What's the relationship between assertions and exception handling? Some might
    ask if assertions are moot, in the light of exception handling. Why would you
    want to assert for a condition if we can check that with an `if` statement and
    raise an exception? There's a subtle difference, though. In general, exceptions
    are for handling unexpected situations in relation to the business logic that
    our program will want to consider, whereas assertions are like self-checking mechanisms
    put in the code, to validate (assert) its correctness.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 断言和异常处理之间有什么关系？有些人可能会问，在异常处理的光照下，断言是否已经没有意义了。如果我们可以用`if`语句检查并抛出异常，为什么还要断言一个条件呢？尽管如此，这里有一个细微的区别。一般来说，异常是用来处理与程序业务逻辑相关的意外情况，而断言则像是代码中的自我检查机制，用来验证（断言）其正确性。
- en: 'For this reason, exception raising will be much more common than having `assert`
    statements. Typical uses of `assert` are situations where an algorithm maintains
    an invariant logic that must be kept at all times: in that case, you might want
    to assert for the invariant. If this is broken at some point, it means either
    the algorithm is wrong or poorly implemented.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，抛出异常会比使用`assert`语句更为常见。`assert`的典型用途是在算法维护一个必须始终保持的不变量逻辑的情况下：在这种情况下，你可能想要断言该不变量。如果这一点在某些地方被破坏，这意味着算法是错误的或者实现得不好。
- en: We have explored defensive programming in Python, and some related topics regarding
    exception handling. Now, we move on to the next big topic, as the next section
    discusses the separation of concerns.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了Python中的防御性编程，以及一些与异常处理相关的话题。现在，我们继续讨论下一个重要主题，因为下一节将讨论关注点的分离。
- en: Separation of concerns
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关注点的分离
- en: This is a design principle that is applied at multiple levels. It is not just
    about the low-level design (code), but it is also relevant at a higher level of
    abstraction, so it will come up later when we talk about architecture.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在多个层面上应用的设计原则。它不仅关乎低级设计（代码），而且在更高层次上的抽象也很相关，因此我们将在讨论架构时再次提到它。
- en: Different responsibilities should go into different components, layers, or modules
    of the application. Each part of the program should only be responsible for a
    part of the functionality (what we call its concerns) and should know nothing
    about the rest.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的职责应该分配到应用程序的不同组件、层或模块中。程序的每一部分只应负责其功能的一部分（我们称之为关注点），并且对其他部分一无所知。
- en: The goal of separating concerns in software is to enhance maintainability by
    minimizing ripple effects. A **ripple** effect means the propagation of a change
    in the software from a starting point. This could be the case of an error or exception
    triggering a chain of other exceptions, causing failures that will result in a
    defect on a remote part of the application. It can also be that we have to change
    a lot of code scattered through multiple parts of the code base, as a result of
    a simple change in a function definition.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 软件中分离关注点的目标是通过对最小化涟漪效应来提高可维护性。涟漪效应意味着软件中从起点传播的变化。这可能是一个错误或异常触发一系列其他异常，导致在应用程序的远程部分产生缺陷的情况。也可能是因为我们对函数定义的简单更改，我们必须在代码库的多个部分中更改大量的代码。
- en: Clearly, we do not want these scenarios to happen. The software has to be easy
    to change. If we have to modify or refactor some part of the code, this has to
    have a minimal impact on the rest of the application, and the way to achieve this
    is through proper encapsulation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不希望出现这些场景。软件必须易于更改。如果我们必须修改或重构代码的一部分，这必须对应用程序的其他部分产生最小的影响，而实现这一点的方法是通过适当的封装。
- en: In a similar way, we want any potential errors to be contained so that they
    don't cause major damage.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们希望任何潜在的错误都被包含起来，以免造成重大损害。
- en: This concept is related to the DbC principle in the sense that each concern
    can be enforced by a contract. When a contract is violated, and an exception is
    raised as a result of such a violation, we know what part of the program has the
    failure, and what responsibilities failed to be met.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念与DbC原则相关，因为每个关注点都可以通过合同强制执行。当合同被违反，并因此引发异常时，我们知道程序中的哪个部分出现了故障，以及哪些责任未能满足。
- en: Despite this similarity, separation of concerns goes further. We normally think
    of contracts between functions, methods, or classes, and while this also applies
    to responsibilities that have to be separated, the idea of the separation of concerns
    also applies to Python modules, packages, and basically any software component.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这种相似性，关注点的分离更进一步。我们通常认为函数、方法或类之间的合同，虽然这也适用于必须分离的责任，但关注点分离的概念也适用于Python模块、包以及基本上任何软件组件。
- en: Cohesion and coupling
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 凝聚力和耦合
- en: These are important concepts for good software design.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是良好软件设计的重要概念。
- en: On the one hand, `cohesion` means that objects should have a small and well-defined
    purpose, and they should do as little as possible. It follows a similar philosophy
    as Unix commands that do only one thing and do it well. The more cohesive our
    objects are, the more useful and reusable they become, making our design better.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，`凝聚力`意味着对象应该有一个小而明确的目的，并且它们应该尽可能少地做事情。它遵循与Unix命令类似的哲学，这些命令只做一件事情，并且做得很好。我们的对象越具有凝聚力，它们就越有用和可重用，从而使我们的设计更佳。
- en: 'On the other hand, `coupling` refers to the idea of how two or more objects
    depend on each other. This dependency poses a limitation. If two parts of the
    code (objects or methods) are too dependent on each other, they bring with them
    some undesired consequences:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`耦合`指的是两个或多个对象相互依赖的想法。这种依赖关系提出了一个限制。如果代码的两个部分（对象或方法）过于依赖彼此，它们会带来一些不希望的结果：
- en: '**No code reuse**: If one function depends too much on a particular object,
    or takes too many parameters, it''s coupled with this object, which means that
    it will be really difficult to use that function in a different context (to do
    so, we will have to find a suitable parameter that complies with a very restrictive
    interface).'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无代码重用**：如果一个函数过多地依赖于某个特定对象，或者接受太多的参数，它就与这个对象耦合在一起，这意味着在另一个上下文中使用该函数将非常困难（为了这样做，我们必须找到一个符合非常严格接口的合适参数）。'
- en: '**Ripple effects**: Changes in one of the two parts will certainly impact the
    other, as they are too close.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**涟漪效应**：两个部分中的任何一个部分的更改肯定会影响另一个部分，因为它们太接近了。'
- en: '**Low level of abstraction**: When two functions are so closely related, it
    is hard to see them as different concerns resolving problems at different levels
    of abstraction.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低抽象级别**：当两个函数关系非常紧密时，很难将它们视为在不同抽象级别上解决不同关注点的不同问题。'
- en: 'Rule of thumb: Well-defined software will achieve high cohesion and low coupling.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则：定义良好的软件将实现高凝聚力和低耦合。
- en: Acronyms to live by
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生存的缩写词
- en: In this section, we will review some principles that yield some good design
    ideas. The point is to quickly relate to good software practices by acronyms that
    are easy to remember, working as a sort of mnemonic rule. If you keep these words
    in mind, you will be able to associate them with good practices more easily and
    finding the right idea behind a particular line of code that you are looking at
    will be faster.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾一些产生良好设计思路的原则。目的是通过易于记忆的缩写词快速关联到良好的软件实践，作为一种记忆规则。如果你记住这些词，你将能够更容易地将它们与良好实践联系起来，并且查找你正在查看的特定代码行背后的正确想法将会更快。
- en: These are by no means formal or academic definitions, but more like empirical
    ideas that emerged from years of working in the software industry. Some of them
    do appear in books, as they were coined by important authors (see the references
    to investigate them in more detail), and others have their roots probably in blog
    posts, papers, or conference talks.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绝对不是正式或学术定义，而更像是从多年在软件行业工作过程中产生的经验性想法。其中一些确实出现在书中，因为它们是由重要作者提出的（参见参考文献以更详细地调查它们），而另一些可能起源于博客文章、论文或会议演讲。
- en: DRY/OAOO
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DRY/OAOO
- en: The ideas of **Don't Repeat Yourself** (**DRY**) and **Once and Only Once**
    (**OAOO**) are closely related, so they were included together here. They are
    self-explanatory, and you should avoid duplication at all costs.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: “不要重复自己”（DRY）和“一次且仅一次”（OAOO）的想法密切相关，因此它们在这里一起被包括。它们是自我解释的，你应该不惜一切代价避免重复。
- en: Things in the code, knowledge, have to be defined only once and in a single
    place. When you have to make a change to the code, there should be only one rightful
    location to modify. Failure to do so is a sign of a poorly designed system.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的事物，即知识，必须只定义一次，并且在一个地方。当你需要更改代码时，应该只有一个合适的地点进行修改。未能做到这一点是设计不良系统的标志。
- en: 'Code duplication is a problem that directly impacts maintainability. It is
    very undesirable to have code duplication because of its many negative consequences:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重复是一个直接影响可维护性的问题。由于它的许多负面影响，代码重复是非常不希望的：
- en: '**It''s error prone**: When some logic is repeated multiple times throughout
    the code, and this needs to change, it means we depend on efficiently correcting
    all the instances with this logic, without forgetting any of them, because in
    that case there will be a bug.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于出错**：当某些逻辑在代码中多次重复，并且需要更改时，这意味着我们必须高效地纠正所有这些实例，不能遗漏任何一个，因为在那种情况下会出现错误。'
- en: '**It''s expensive**: Linked to the previous point, making a change in multiple
    places takes much more time (development and testing effort) than if it was defined
    only once. This will slow the team down.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本高昂**：与前面的点相关，在多个地方进行更改比只定义一次需要更多的时间（开发和测试工作量）。这将减慢团队的工作进度。'
- en: '**It''s unreliable**: Also linked to the first point, when multiple places
    need to be changed for a single change in the context, you rely on the person
    who wrote the code to remember all the instances where the modification has to
    be made. There is no single source of truth.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可靠**：这也与第一个点相关，当需要更改多个地方以进行单个更改时，你依赖于编写代码的人记住所有需要进行修改的实例。没有单一的真实来源。'
- en: Duplication is often caused by ignoring (or forgetting) that code represents
    knowledge. By giving meaning to certain parts of the code, we are identifying
    and labeling that knowledge.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 重复通常是由于忽略了（或忘记了）代码代表知识。通过给代码的某些部分赋予意义，我们正在识别和标记这种知识。
- en: 'Let''s see what this means with an example. Imagine that, in a study center,
    students are ranked by the following criteria: 11 points per exam passed, minus
    five points per exam failed, and minus two per year in the institution. The following
    is not actual code, but just a representation of how this might be scattered in
    a real code base:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看这意味着什么。想象在一个学习中心，学生根据以下标准进行排名：每通过一次考试获得11分，每失败一次考试减去5分，每在机构待一年减去2分。以下代码并非实际代码，而只是表示这种可能在实际代码库中分散的方式：
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice how the lambda, which is in the key of the sorted function, represents
    some valid knowledge from the domain problem, yet it doesn't reflect it (it doesn't
    have a name, a proper and rightful location, there is no meaning assigned to that
    code, nothing). This lack of meaning in the code leads to the duplication we find
    when the score is printed out while listing the raking.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到lambda表达式，它在排序函数的键中，代表了领域问题中的一些有效知识，但它并没有反映出来（它没有名字，没有合适的位置，这段代码没有赋予任何意义，什么都没有）。这种代码中的意义缺失导致了在列出排名时打印分数时出现的重复。
- en: 'We should reflect our knowledge of our domain problem in our code, and our
    code will then be less likely to suffer from duplication and will be easier to
    understand:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在代码中反映我们对领域问题的了解，这样我们的代码就很少会遭受重复，并且更容易理解：
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A fair disclaimer: This is just an analysis of one of the traits of code duplication.
    In reality, there are more cases, types, and taxonomies of code duplication. Entire
    chapters could be dedicated to this topic, but here we focus on one particular
    aspect to make the idea behind the acronym clear.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个公正的免责声明：这仅仅是对代码重复的一个特性的分析。实际上，还有更多的情况、类型和代码重复的分类。可以专门用整章来讨论这个话题，但在这里我们专注于一个特定的方面，以使缩写的含义清晰。
- en: 'In this example, we have taken what is probably the simplest approach to eliminating
    duplication: creating a function. Depending on the case, the best solution would
    be different. In some cases, there might be an entirely new object that has to
    be created (maybe an entire abstraction was missing). In other cases, we can eliminate
    duplication with a context manager. Iterators or generators (described in *Chapter
    7*, *Generators, Iterators, and Asynchronous Programming*) could also help to
    avoid repetition in the code, and decorators (explained in *Chapter 5*, *Using
    Decorators to Improve Our Code*) will also help.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们采取了可能是消除重复最简单的方法：创建一个函数。根据具体情况，最佳解决方案可能会有所不同。在某些情况下，可能需要创建一个全新的对象（可能整个抽象都缺失）。在其他情况下，我们可以通过上下文管理器来消除重复。迭代器或生成器（在第7章*生成器、迭代器和异步编程*中描述）也可以帮助避免代码中的重复，装饰器（在第5章*使用装饰器改进我们的代码*中解释）也将有所帮助。
- en: Unfortunately, there is no general rule or pattern to tell you which of the
    features of Python are the most suitable when it comes to addressing code duplication,
    but hopefully, after seeing the examples in this book, and how the elements of
    Python are used, the reader will be able to develop their own intuition.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有普遍的规则或模式可以告诉你Python中哪些特性在解决代码重复问题时最为合适，但希望读者在阅读本书中的示例以及Python元素的使用方式后，能够发展出自己的直觉。
- en: YAGNI
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: YAGNI
- en: '**YAGNI** (short for **You Ain''t Gonna Need It**) is an idea you might want
    to keep in mind very often when writing a solution if you do not want to over-engineer
    it.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**YAGNI**（缩写为**You Ain''t Gonna Need It**）是一个你可能在编写解决方案时经常需要记住的想法，如果你不想过度设计它的话。'
- en: We want to be able to easily modify our programs, so we want to make them future-proof.
    In line with that, many developers think that they have to anticipate all future
    requirements and create solutions that are very complex, and so create abstractions
    that are hard to read, maintain, and understand. Sometime later, it turns out
    that those anticipated requirements do not show up, or they do but in a different
    way (surprise!), and the original code that was supposed to handle precisely that
    does not work.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够轻松修改我们的程序，因此我们希望使它们具有前瞻性。与此一致，许多开发者认为他们必须预测所有未来的需求，并创建非常复杂的解决方案，从而创建难以阅读、维护和理解的抽象。后来，发现那些预期的需求并没有出现，或者它们出现了，但以不同的方式（惊喜！），而原本应该处理这种情况的原始代码却不起作用。
- en: The problem is that now it is even harder to refactor and extend our programs.
    What happened was that the original solution did not handle the original requirements
    correctly, and neither do the current ones, simply because it is the wrong abstraction.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于现在甚至更难重构和扩展我们的程序。发生的事情是原始解决方案没有正确处理原始需求，当前解决方案也没有，仅仅是因为这是一个错误的抽象。
- en: Having maintainable software is not about anticipating future requirements (do
    not do futurology!). It is about writing software that only addresses current
    requirements in such a way that it will be possible (and easy) to change later
    on. In other words, when designing, make sure that your decisions don't tie you
    down, and that you will be able to keep on building, but do not build more than
    what's necessary.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有可维护的软件并不是关于预测未来需求（不要做未来学！），而是编写只解决当前需求的软件，这样将来修改起来既可能又容易。换句话说，在设计时，确保你的决策不会限制你，并且你将能够继续构建，但不要构建超过必要性的东西。
- en: It's usually tempting to not follow this idea in some cases in which we're aware
    of principles that we think might apply or save time for us. For example, later
    in the book, we'll review design patterns, which are common solutions for typical
    situations of object-oriented design. While it's important to study design patterns,
    we must refuse the temptation to apply them prematurely as it might fall into
    a violation of the YAGNI principle.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们可能会在某些情况下不遵循这个理念，因为我们知道一些我们认为可能适用或为我们节省时间的原则。例如，在本书的后面，我们将回顾设计模式，它们是面向对象设计典型情况下的常见解决方案。虽然研究设计模式很重要，但我们必须拒绝过早应用它们的诱惑，因为这可能会违反YAGNI原则。
- en: For example, imagine you're creating a class to encapsulate the behavior of
    a component. You know it's needed, but then you think that more (and similar)
    requirements will come in the future, so it might be tempting to create a base
    class (as to define an interface with the methods that must be implemented), and
    then make the class you were just creating a subclass that implement that interface.
    This would be wrong for several reasons. First, all you need now is the class
    that was being created in the first place (investing more time in over-generalizing
    a solution that we don't know we'll need is not a good way of managing our resources).
    And then, that base class is being biased by the current requirements, so it'll
    likely not be the correct abstraction.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象你正在创建一个类来封装组件的行为。你知道它是必要的，但后来你想到将来可能会有更多（和类似的）需求，所以可能会有创建一个基类的诱惑（为了定义必须实现的方法的接口），然后使你刚刚创建的类成为实现该接口的子类。这会有几个错误的原因。首先，你现在需要的只是最初创建的那个类（在我们不知道是否需要的情况下，投入更多时间来过度泛化解决方案并不是管理资源的好方法）。然后，那个基类被当前需求所偏颇，所以它可能不是正确的抽象。
- en: 'The best approach would be to write only what''s needed now in a way that doesn''t
    hinder further improvements. If, later on, more requirements come in, we can think
    about creating a base class, abstract some methods, and perhaps we will discover
    a design pattern that emerged for our solution. This is also the way object-oriented
    design is supposed to work: bottom-up.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳的方法是只编写现在需要的，同时不阻碍未来的改进。如果将来有更多需求，我们可以考虑创建一个基类，抽象一些方法，也许我们会发现为我们的解决方案出现的某种设计模式。这也是面向对象设计应该工作的方式：自下而上。
- en: Finally, I wanted to emphasize that YAGNI is an idea that also applies to software
    architecture (not just detailed code).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想强调YAGNI这个理念也适用于软件架构（而不仅仅是详细代码）。
- en: KIS
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KIS
- en: '**KIS** (stands for **Keep It Simple**) relates very much to the previous point.
    When you are designing a software component, avoid over-engineering it. Ask yourself
    if your solution is the minimal one that fits the problem.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**KIS**（代表**保持简单**）与前面的观点非常相关。当你设计一个软件组件时，避免过度设计。问问自己你的解决方案是否是满足问题的最小方案。'
- en: Implement minimal functionality that correctly solves the problem and does not
    complicate your solution more than is necessary. Remember, the simpler the design,
    the more maintainable it will be.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 实现最小功能，正确解决问题，并且不会使你的解决方案比必要的更复杂。记住，设计越简单，可维护性就越高。
- en: This design principle is an idea we will want to keep in mind at all levels
    of abstraction, whether we are thinking of a high-level design, or addressing
    a particular line of code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计原则是我们希望在所有抽象级别都牢记在心的一个理念，无论是思考高级设计，还是处理特定的代码行。
- en: At a high level, think about the components we are creating. Do we really need
    all of them? Does this module actually require being utterly extensible right
    now? Emphasize the last part—maybe we want to make that component extensible,
    but now is not the right time, or it is not appropriate to do so because we still
    do not have enough information to create the proper abstractions, and trying to
    come up with generic interfaces at this point will only lead to even worse problems.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，考虑我们正在创建的组件。我们真的需要所有这些吗？这个模块现在真的需要完全可扩展吗？强调最后一点——也许我们想要使该组件可扩展，但现在不是做这件事的正确时间，或者由于我们还没有足够的信息来创建适当的抽象，尝试在这个阶段提出通用接口只会导致更糟糕的问题。
- en: In terms of code, keeping it simple usually means using the smallest data structure
    that fits the problem. You will most likely find it in the standard library.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，保持简单通常意味着使用最适合问题的最小数据结构。你很可能会在标准库中找到它。
- en: 'Sometimes, we might over-complicate code, creating more functions or methods
    than are necessary. The following class creates a namespace from a set of keyword
    arguments that have been provided, but it has a rather complicated code interface:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可能会过度复杂化代码，创建比必要的更多函数或方法。以下类从一个提供的关键字参数集合中创建一个命名空间，但它有一个相当复杂的代码接口：
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Having an extra class method for initializing the object doesn''t seem necessary.
    Then, the iteration and the call to `setattr` inside it make things even more
    strange, and the interface that is presented to the user is not very clear:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为初始化对象添加一个额外的类方法似乎并不必要。然后，其中的迭代和 `setattr` 调用使得事情变得更加奇怪，提供给用户的接口也不是很清晰：
- en: '[PRE14]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The user has to know of the existence of this other method, which is not convenient.
    It would be better to keep it simple, and just initialize the object as we initialize
    any other object in Python (after all, there is a method for that) with the `__init__`
    method:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 用户必须知道存在这种其他方法，这并不方便。最好是保持简单，就像我们在 Python 中初始化任何其他对象一样（毕竟，有这样一个方法），使用 `__init__`
    方法来初始化对象：
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Remember the Zen of Python: Simple is better than complex.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 Python 的禅意：简单胜于复杂。
- en: 'There are many scenarios in Python in which we would like to keep our code
    simple. One of them relates to something we''ve explored before: code duplication.
    A common way to abstract code in Python is by using decorators (which we''ll see
    later on, in *Chapter 5*, *Using Decorators to Improve Our Code*). But what if
    we''re trying to avoid duplication of a small section, let''s say three lines
    of code? In that case, writing the decorator would probably take more lines and
    be more trouble for the simple duplicated lines we''re trying to solve. In this
    case, apply common sense and be pragmatic. Accept that a small amount of duplication
    might be better than a complicated function (that is, of course, unless you find
    an even simpler way of removing the duplication and keeping the code simple!).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中有许多场景，我们希望保持代码的简单性。其中之一与我们之前探讨过的问题相关：代码重复。在 Python 中抽象代码的常见方法是通过使用装饰器（我们将在第
    5 章 *使用装饰器改进我们的代码* 中看到）。但如果我们在尝试避免一小段代码的重复，比如说三行代码呢？在这种情况下，编写装饰器可能需要更多的行数，并且对于我们要解决的简单重复行来说，可能更加麻烦。在这种情况下，运用常识和实用主义。接受一小部分重复可能比一个复杂的函数（当然，除非你找到了一个更简单的方法来消除重复并保持代码简单）要好。
- en: As part of keeping the code simple, I would recommend avoiding advanced features
    of Python, like meta-classes (or anything related to meta-programming in general),
    because not only are these features hardly required (there are very special justifications
    for their use!), but also, they make the code much more complicated to read, and
    harder to maintain.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 作为保持代码简单的一部分，我建议避免使用 Python 的高级特性，如元类（或与元编程相关的一切），因为这些特性几乎很少需要（它们的使用有非常特殊的理由！），而且它们使得代码的阅读和维护变得更加复杂。
- en: EAFP/LBYL
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EAFP/LBYL
- en: '**EAFP** stands for **Easier to Ask Forgiveness than Permission**, while **LBYL**
    stands for **Look Before You Leap**.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**EAFP** 代表 **Easier to Ask Forgiveness than Permission**（请求原谅比请求许可更容易），而 **LBYL**
    代表 **Look Before You Leap**（三思而后行）。'
- en: The idea of EAFP is that we write our code so that it performs an action directly,
    and then we take care of the consequences later in case it doesn't work. Typically,
    this means try running some code, expecting it to work, but catching an exception
    if it doesn't, and then handling the corrective code on the `except` block.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: EAFP的思想是，我们编写代码使其直接执行一个操作，然后如果它不起作用，我们稍后处理后果。通常这意味着尝试运行一些代码，期望它能工作，但如果它不起作用，就捕获异常，然后在`except`块中处理纠正代码。
- en: 'This is the opposite of LBYL. As its name says, in the *look before you leap*
    approach, we first check what we are about to use. For example, we might want
    to check whether a file is available before trying to operate with it:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这与LBYL相反。正如其名所示，在“先检查后跳”方法中，我们首先检查我们即将使用的内容。例如，我们可能想在尝试操作文件之前检查文件是否可用：
- en: '[PRE16]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The EAFP version of the previous code would look like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的EAFP版本看起来会是这样：
- en: '[PRE17]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you are coming from other languages, such as C, which doesn't have exceptions,
    then it's logical that will find the LBYL approach of more use. And in other languages
    such as C++, there is some discouragement towards the use of exceptions due to
    performance considerations, but this doesn't generally hold true in Python.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自没有异常处理的语言，例如C语言，那么发现LBYL（先检查后执行）方法更有用是合乎逻辑的。在其他语言，如C++中，由于性能考虑，对异常的使用存在一些反对意见，但在Python中这通常并不成立。
- en: Particular cases might of course apply, but most of the time, you'll find the
    EAFP version to be more intention-revealing. The code written this way would be
    easier to read, because it goes directly to the task needed instead of preventively
    checking conditions. Put another way, in the last example, you'll see a part of
    the code that tries to open a file and then process it. If the file doesn't exist,
    then we handle that case. In the first example, we'll see a function checking
    whether a file exists, and then trying to do something. You might argue that this
    is also clear, but we don't know for sure. Maybe the file being asked about is
    a different one or is a function that belongs to a different layer of the program,
    or a leftover, and such like. The second approach is less error-prone when you
    look at the code at first glance.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，特定情况可能适用，但大多数时候，你会发现EAFP版本更能揭示意图。这样编写的代码更容易阅读，因为它直接进行所需任务，而不是预防性地检查条件。换句话说，在最后一个例子中，你会看到尝试打开文件并处理它的代码部分。如果文件不存在，我们将处理这种情况。在第一个例子中，我们会看到一个检查文件是否存在并尝试做某事的函数。你可能认为这也是清晰的，但我们不能确定。也许被询问的文件是另一个文件，或者是一个属于程序不同层的函数，或者是一个遗留的文件，等等。当你第一次看代码时，第二种方法更不容易出错。
- en: You can apply both ideas as they make sense in your particular code, but in
    general, code written in an EAFP fashion would be easier to pick at first glance,
    so in case of doubt, I'd recommend you choose this variant.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据你的代码需要应用这两种思想，但一般来说，以EAFP（先做后检查）风格编写的代码在第一眼看起来会更易于理解，所以如果有疑问，我建议你选择这个变体。
- en: Inheritance in Python
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的继承
- en: In object-oriented software design, there are often discussions as to how to
    address some problems by using the main ideas of the paradigm (polymorphism, inheritance,
    and encapsulation).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的软件开发设计中，经常会有关于如何通过使用范式的主要思想（多态性、继承和封装）来解决某些问题的讨论。
- en: Probably the most commonly used of these ideas is inheritance—developers often
    start by creating a class hierarchy with the classes they are going to need and
    decide the methods each one should implement.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些想法中最常用的是继承——开发者通常会从创建所需的类层次结构开始，并决定每个类应该实现的方法。
- en: While inheritance is a powerful concept, it does come with its perils. The main
    one is that every time we extend a base class, we are creating a new one that
    is tightly coupled with the parent. As we have already discussed, coupling is
    one of the things we want to reduce to a minimum when designing software.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管继承是一个强大的概念，但它确实有其风险。主要的风险是，每次我们扩展基类时，我们都在创建一个新的类，它与父类紧密耦合。正如我们已经讨论过的，耦合是我们设计软件时希望减少到最小的事情之一。
- en: One of the main scenarios developers relate inheritance with is code reuse.
    While we should always embrace code reuse, it is not a good idea to force our
    design to use inheritance to reuse code just because we get the methods from the
    parent class for free. The proper way to reuse code is to have highly cohesive
    objects that can be easily composed and that could work on multiple contexts.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者将继承与代码重用联系起来的主要场景之一是。虽然我们应该始终欢迎代码重用，但仅仅因为我们可以免费从父类获得方法，就强迫我们的设计使用继承来重用代码并不是一个好主意。正确重用代码的方式是拥有高度内聚的对象，它们可以轻松组合，并且可以在多个上下文中工作。
- en: When inheritance is a good decision
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当继承是一个好的决定时
- en: We have to be careful when creating a derived class because this is a double-edged
    sword—on the one hand, it has the advantage that we get all the code of the methods
    from the parent class for free, but on the other hand, we are carrying all of
    them to a new class, meaning that we might be placing too much functionality in
    a new definition.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建派生类时，我们必须小心，因为这把双刃剑——一方面，它有优势，我们可以免费获得父类中所有方法的代码，但另一方面，我们将它们全部带到新的类中，这意味着我们可能在新的定义中放置了过多的功能。
- en: 'When creating a new subclass, we have to think if it is actually going to use
    all of the methods it has just inherited, as a heuristic to see whether the class
    is correctly defined. If instead, we find out that we do not need most of the
    methods, and have to override or replace them, this is a design mistake that could
    be caused by a number of reasons:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新的子类时，我们必须考虑它是否真的会使用它刚刚继承的所有方法，作为一个启发式方法来查看类是否定义正确。如果我们发现我们不需要大多数方法，并且必须覆盖或替换它们，那么这是一个由多种原因造成的设计错误：
- en: The superclass is vaguely defined and contains too much responsibility, instead
    of a well-defined interface
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超类定义得比较模糊，并且承担了过多的责任，而不是一个明确的接口
- en: The subclass is not a proper specialization of the superclass it is trying to
    extend
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类并不是它试图扩展的超类的适当专门化
- en: A good case for using inheritance is the type of situation when you have a class
    that defines certain components with its behavior that are defined by the interface
    of this class (its `public` methods and attributes), and then you need to specialize
    this class in order to create objects that do the same but with something else
    added, or with some particular parts of its behavior changed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承的一个好例子是，当你有一个类定义了某些组件及其行为（由这个类的接口定义，即其`public`方法和属性），然后你需要专门化这个类以创建执行相同操作但添加了其他内容或改变了某些行为特定部分的对象。
- en: You can find examples of good uses of inheritance in the Python standard library
    itself. For example, in the `http.server` package ([https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler](https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler)),
    we can find a base class such as `BaseHTTPRequestHandler`, and subclasses such
    as `SimpleHTTPRequestHandler`, that extend this one by adding or changing part
    of its base interface.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python标准库本身中找到继承的好用例。例如，在`http.server`包（[https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler](https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler)）中，我们可以找到一个基类，如`BaseHTTPRequestHandler`，以及扩展这个基类的子类，如`SimpleHTTPRequestHandler`，通过添加或改变其部分基接口来实现。
- en: Speaking of interface definition, this is another good use of inheritance. When
    we want to enforce the interface of some objects, we can create an abstract base
    class that does not implement the behavior itself, but instead just defines the
    interface—every class that extends this one will have to implement these to be
    a proper subtype.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到接口定义，这也是继承的另一个好用途。当我们想要强制某些对象的接口时，我们可以创建一个不实现行为本身但仅定义接口的抽象基类——每个扩展这个基类的类都必须实现这些接口才能成为适当的子类型。
- en: Finally, another good case for inheritance is exceptions. We can see that the
    standard exception in Python derives from `Exception`. This is what allows you
    to have a generic clause such as `except Exception`, which will catch every possible
    error. The important point is the conceptual one; they are classes derived from
    `Exception` because they are more specific exceptions. This also works in well-known
    libraries such as `requests`, for instance, in which an `HTTPError` is a `RequestException`,
    which, in turn, is an `IOError`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，继承的另一个好例子是异常。我们可以看到，Python中的标准异常`Exception`是继承自`Exception`的。这就是允许你有一个通用的子句，如`except
    Exception`，它可以捕获每一个可能的错误。重要的是概念上的一个点；它们是继承自`Exception`的类，因为它们是更具体的异常。这在像`requests`这样的知名库中也同样适用，例如，其中的`HTTPError`是`RequestException`，而`RequestException`又是`IOError`。
- en: Anti-patterns for inheritance
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承的反模式
- en: If the previous section had to be summarized in a single word, it would be *specialization*.
    The correct use of inheritance is to specialize objects and create more detailed
    abstractions starting from base ones.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将前面的部分总结成一个词，那将是*专业化*。正确使用继承是为了使对象专业化，并从基类创建更详细的抽象。
- en: The parent (or base) class is part of the `public` definition of the new derived
    class. This is because the methods that are inherited will be part of the interface
    of this new class. For this reason, when we read the `public` methods of a class,
    they have to be consistent with what the parent class defines.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 父类（或基类）是新派生类`public`定义的一部分。这是因为继承的方法将成为这个新类接口的一部分。因此，当我们阅读一个类的`public`方法时，它们必须与父类定义的内容保持一致。
- en: For example, if we see that a class derived from `BaseHTTPRequestHandler` implements
    a method named `handle()`, it would make sense because it is overriding one of
    the parents. If it had any other method whose name relates to an action that has
    to do with an HTTP request, then we could also think that is correctly placed
    (but we would not think that if we found something called `process_purchase()`
    on that class).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们看到从`BaseHTTPRequestHandler`派生的类实现了一个名为`handle()`的方法，那么这是有意义的，因为它覆盖了父类中的一个方法。如果它有任何其他与HTTP请求相关的动作名称相关的方法，那么我们也可以认为它是正确放置的（但如果我们在该类中找到名为`process_purchase()`的方法，我们不会这样认为）。
- en: The previous illustration might seem obvious, but it is something that happens
    very often, especially when developers try to use inheritance with the sole goal
    of reusing code. In the next example, we will see a typical situation that represents
    a common anti-pattern in Python—there is a domain problem that has to be represented,
    and a suitable data structure is devised for that problem, but instead of creating
    an object that uses such a data structure, the object becomes the data structure
    itself.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的说明可能看起来很明显，但它是非常常见的事情，尤其是在开发者试图仅为了重用代码而使用继承时。在下一个例子中，我们将看到一个典型的场景，它代表了Python中常见的反模式——有一个需要表示的领域问题，为此设计了一个合适的数据结构，但不是创建一个使用这种数据结构的对象，而是使对象本身成为数据结构。
- en: Let's see these problems more concretely through an example. Imagine we have
    a system for managing insurance, with a module in charge of applying policies
    to different clients. We need to keep in memory a set of customers that are being
    processed at the time in order to apply those changes before further processing
    or persistence. The basic operations we need are to store a new customer with
    its records as satellite data, apply a change to a policy, or edit some of the
    data, to name but a few. We also need to support a batch operation. That is, when
    something on the policy itself changes (the one this module is currently processing),
    we have to apply these changes overall to customers on the current transaction.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子更具体地看看这些问题。想象我们有一个管理保险的系统，其中有一个模块负责将政策应用于不同的客户。我们需要在内存中保持一组正在处理的客户，以便在进一步处理或持久化之前应用这些更改。我们需要的基本操作包括存储带有其记录的新客户作为卫星数据，对政策进行更改，或编辑一些数据，仅举几例。我们还需要支持批量操作。也就是说，当政策本身发生变化（这个模块目前正在处理的政策）时，我们必须将这些更改整体应用于当前事务中的客户。
- en: 'Thinking in terms of the data structure we need, we realize that accessing
    the record for a particular customer in constant time is a nice trait. Therefore,
    something like `policy_transaction[customer_id]` looks like a nice interface.
    From this, we might think that a `subscriptable` object is a good idea, and further
    on, we might get carried away into thinking that the object we need is a dictionary:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们需要的数据结构的角度思考，我们意识到以恒定时间访问特定客户的记录是一个很好的特性。因此，像`policy_transaction[customer_id]`这样的接口看起来很合理。从这个角度来看，我们可能会认为一个`subscriptable`对象是一个好主意，并且进一步地，我们可能会陷入认为我们需要的对象是一个字典的思考中：
- en: '[PRE18]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With this code, we can get information about a policy for a customer by its
    identifier:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们可以通过标识符获取关于客户政策的详细信息：
- en: '[PRE19]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Sure, we achieved the interface we wanted in the first place, but at what cost?
    Now, this class has a lot of extra behavior from carrying out methods that weren''t
    necessary:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们最初实现了我们想要的接口，但代价是什么？现在，这个类因为执行了一些不必要的操作而拥有很多额外的行为：
- en: '[PRE20]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are (at least) two major problems with this design. On the one hand, the
    hierarchy is wrong. Creating a new class from a base one conceptually means that
    it's a more specific version of the class it's extending (hence the name). How
    is it that a `TransactionalPolicy` is a dictionary? Does this make sense? Remember,
    this is part of the public interface of the object, so users will see this class
    and its hierarchy and will notice such an odd specialization as well as its public
    methods.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计至少有两个主要问题。一方面，层级结构是错误的。从一个基类创建一个新的类在概念上意味着它是它所扩展的类的更具体版本（因此得名）。那么，一个`TransactionalPolicy`怎么是一个字典呢？这有意义吗？记住，这是对象公共接口的一部分，所以用户会看到这个类及其层级结构，并会注意到这种异常的专门化以及其公共方法。
- en: This leads us to the second problem—coupling. The interface of the transactional
    policy now includes all methods from a dictionary. Does a transactional policy
    really need methods such as `pop()` or `items()`? However, there they are. They
    are also `public`, so any user of this interface is entitled to call them, with
    whatever undesired side effect they may carry. More on this point—we don't really
    gain much by extending a dictionary. The only method it actually needs to update
    for all customers affected by a change in the current policy (`change_in_policy()`)
    is not on the base class, so we will have to define it ourselves either way.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致我们面临第二个问题——耦合。事务策略的接口现在包括了字典的所有方法。事务策略真的需要像`pop()`或`items()`这样的方法吗？然而，它们就在那里。它们也是`public`的，所以任何使用这个接口的用户都有权调用它们，无论它们可能带来什么不期望的副作用。关于这一点，我们通过扩展字典实际上并没有获得太多好处。实际上需要更新的唯一方法是针对所有受当前策略变化影响（`change_in_policy()`）的客户的基础类，所以无论如何我们都需要自己定义它。
- en: This is a problem of mixing implementation objects with domain objects. A dictionary
    is an implementation object, a data structure, suitable for certain kinds of operation,
    and with a trade-off like all data structures. A transactional policy should represent
    something in the domain problem, an entity that is part of the problem we are
    trying to solve.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将实现对象与领域对象混合的问题。字典是一个实现对象，一种数据结构，适用于某些类型的操作，并且像所有数据结构一样有其权衡。事务策略应该代表领域问题中的某个东西，一个是我们试图解决的问题的组成部分。
- en: Don't mix implementation data structures with business domain classes in the
    same hierarchy.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在同一层级中将实现数据结构与业务领域类混合。
- en: Hierarchies like this one are incorrect, and just because we get a few magic
    methods from a base class (to make the object subscriptable by extending a dictionary)
    is not reason enough to create such an extension. Implementation classes should
    be extended solely when creating other, more specific, implementation classes.
    In other words, extend a dictionary if you want to create another (more specific,
    or slightly modified) dictionary. The same rule applies to classes of the domain
    problem.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的层级结构是不正确的，仅仅因为从基类中获取了一些魔法方法（通过扩展字典来使对象可索引）并不足以成为创建这种扩展的理由。实现类应该仅在创建其他更具体的实现类时进行扩展。换句话说，如果你想创建另一个（更具体或略有修改的）字典，就扩展一个字典。同样的规则也适用于领域问题的类。
- en: 'The correct solution here is to use composition. `TransactionalPolicy` is not
    a dictionary—it uses a dictionary. It should store a dictionary in a `private`
    attribute, and implement `__getitem__()` by proxying from that dictionary and
    then only implementing the rest of the `public` method it requires:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的正确解决方案是使用组合。`TransactionalPolicy`不是一个字典——它使用一个字典。它应该在`private`属性中存储一个字典，并通过代理从该字典实现`__getitem__()`，然后只实现它需要的其余`public`方法：
- en: '[PRE21]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This way is not only conceptually correct, but also more extensible. If the
    underlying data structure (which, for now, is a dictionary) is changed in the
    future, callers of this object will not be affected, so long as the interface
    is maintained. This reduces coupling, minimizes ripple effects, allows for better
    refactoring (unit tests ought not to be changed), and makes the code more maintainable.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不仅在概念上是正确的，而且更具可扩展性。如果底层数据结构（目前是字典）在未来发生变化，只要接口保持不变，调用此对象的人就不会受到影响。这减少了耦合，最小化了连锁反应，允许更好的重构（单元测试不应该改变），并使代码更易于维护。
- en: Multiple inheritance in Python
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的多重继承
- en: Python supports multiple inheritance. As inheritance, when improperly used,
    leads to design problems, you could also expect that multiple inheritance will
    also yield even bigger problems when it's not correctly implemented.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Python支持多重继承。正如继承在不正确使用时会导致设计问题一样，你也可以预期，如果多重继承没有被正确实现，它将产生更大的问题。
- en: Multiple inheritance is, therefore, a double-edged sword. It can also be very
    beneficial in some cases. Just to be clear, there is nothing wrong with multiple
    inheritance—the only problem it has is that when it's not implemented correctly,
    it will multiply the problems.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，多重继承是一把双刃剑。在某些情况下，它也可能非常有益。为了明确起见，多重继承本身并没有错——它的问题仅仅在于当它没有被正确实现时，它将放大问题。
- en: Multiple inheritance is a perfectly valid solution when used correctly, and
    this opens up new patterns (such as the adapter pattern we discussed in *Chapter
    9*, *Common Design Patterns*) and mixins.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承在正确使用时是一个完全有效的解决方案，这开辟了新的模式（例如我们在*第9章*，*常见设计模式*中讨论的适配器模式）和混入。
- en: One of the most powerful applications of multiple inheritance is perhaps that
    which enables the creation of mixins. Before exploring mixins, we need to understand
    how multiple inheritance works, and how methods are resolved in a complex hierarchy.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承最强大的应用之一可能是它能够创建混入。在探索混入之前，我们需要了解多重继承是如何工作的，以及方法在复杂层次结构中是如何解析的。
- en: Method Resolution Order (MRO)
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法解析顺序（MRO）
- en: 'Some people don''t like multiple inheritance because of the constraints it
    has in other programming languages, for instance, the so-called diamond problem.
    When a class extends from two or more classes, and all of those classes also extend
    from other base classes, the bottom ones will have multiple ways to resolve the
    methods coming from the top-level classes. The question is: Which of these implementations
    is used?'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人不喜欢多重继承，因为它在其他编程语言中存在约束，例如所谓的菱形问题。当一个类从两个或更多类扩展，并且所有这些类也扩展自其他基类时，底层类将有多种方式解析来自顶层类的方法。问题是：这些实现中的哪一个将被使用？
- en: Consider the following diagram, which has a structure with multiple inheritance.
    The top-level class has a class attribute and implements the `__str__` method.
    Think of any of the concrete classes, for example, `ConcreteModuleA12`—it extends
    from `BaseModule1` and `BaseModule2`, and each one of them will take the implementation
    of `__str__` from `BaseModule`. Which of these two methods is going to be the
    one for `ConcreteModuleA12`?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下具有多重继承结构的图，顶层类有一个类属性并实现了`__str__`方法。想想任何具体的类，例如，`ConcreteModuleA12`——它从`BaseModule1`和`BaseModule2`扩展，并且它们中的每一个都将从`BaseModule`获取`__str__`的实现。这两个方法中的哪一个将被用于`ConcreteModuleA12`？
- en: '![Picture 1](img/B16567_03_01.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/B16567_03_01.png)'
- en: 'Figure 3.1: Method Resolution Order'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：方法解析顺序
- en: 'With the value of the class attribute, this will become evident:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类的属性值，这一点将变得明显：
- en: '[PRE22]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s test this to see what method is being called:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下看看调用的是哪个方法：
- en: '[PRE23]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There is no collision. Python resolves this by using an algorithm called C3
    linearization or MRO, which defines a deterministic way in which methods are going
    to be called.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 没有冲突。Python通过使用称为C3线性化或MRO的算法来解决冲突，该算法定义了方法调用的确定性方式。
- en: 'In fact, we can specifically ask the class for its resolution order:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以具体询问类的解析顺序：
- en: '[PRE24]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Knowing about how the method is going to be resolved in a hierarchy can be used
    to our advantage when designing classes because we can make use of mixins.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 了解方法在层次结构中如何被解决，在设计类时可以为我们带来好处，因为我们可以利用混入。
- en: Mixins
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混入
- en: A mixin is a base class that encapsulates some common behavior with the goal
    of reusing code. Typically, a mixin class is not useful on its own, and extending
    this class alone will certainly not work, because most of the time it depends
    on methods and properties that are defined in other classes. The idea is to use
    mixin classes along with other ones, through multiple inheritance, so that the
    methods or properties used on the mixin will be available.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 混入（mixin）是一个封装了一些常见行为的基础类，目的是为了重用代码。通常，混入类本身并不有用，仅仅扩展这个类肯定不会起作用，因为大多数时候它依赖于定义在其他类中的方法和属性。想法是使用混入类与其他类一起，通过多重继承，这样混入类上使用的方
    法或属性将可用。
- en: 'Imagine we have a simple parser that takes a `string` and provides iteration
    over it by its values separated by hyphens (`-`):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个简单的解析器，它接受一个`string`并通过其由连字符（`-`）分隔的值提供迭代：
- en: '[PRE25]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is quite straightforward:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当直接：
- en: '[PRE26]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'But now we want the values to be sent in uppercase, without altering the base
    class. For this simple example, we could just create a new class, but imagine
    that a lot of classes are already extending from `BaseTokenizer`, and we don''t
    want to replace all of them. We can mix a new class into the hierarchy that handles
    this transformation:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们希望值以大写形式发送，而不改变基类。对于这个简单的例子，我们可能只需要创建一个新的类，但想象一下，有很多类已经从`BaseTokenizer`扩展出来，我们不想替换它们中的所有类。我们可以将一个新的类混合到处理这种转换的层次结构中：
- en: '[PRE27]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The new `Tokenizer` class is really simple. It doesn't need any code because
    it takes advantage of the mixin. This type of mixin acts as a sort of decorator.
    Based on what we just saw, `Tokenizer` will take `__iter__` from the mixin, and
    this one, in turn, delegates to the next class on the line (by calling `super()`),
    which is `BaseTokenizer`, but it converts its values to uppercase, thereby creating
    the desired effect.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`Tokenizer`类非常简单。它不需要任何代码，因为它利用了混入。这种类型的混入充当了一种装饰器。基于我们刚才看到的，`Tokenizer`将从混入中获取`__iter__`，然后这个混入，反过来，通过调用`super()`将任务委托给行上的下一个类（即`BaseTokenizer`），但它将值转换为大写，从而产生预期的效果。
- en: As we have discussed inheritance in Python, we've seen topics such as cohesion
    and coupling that are important to the design of our software. These concepts
    appear repeatedly in software design, and they can also be analyzed from the lens
    of functions and their arguments, which we explore in the next section.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在Python中讨论了继承，我们已经看到了诸如内聚性和耦合性这样的主题，这些主题对于我们的软件设计非常重要。这些概念在软件设计中反复出现，并且也可以从函数及其参数的角度进行分析，我们将在下一节中探讨这一点。
- en: Arguments in functions and methods
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和方法中的参数
- en: In Python, functions can be defined to receive arguments in several different
    ways, and these arguments can also be provided by callers in multiple ways.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，函数可以定义为以几种不同的方式接收参数，并且这些参数也可以以多种方式由调用者提供。
- en: There is also an industry-wide set of practices for defining interfaces in software
    engineering that closely relate to the definition of arguments in functions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，定义接口有一套行业通用的实践，这与函数中参数的定义密切相关。
- en: In this section, we will first explore the mechanics of arguments in Python
    functions and then review the general principles of software engineering that
    relate to good practices regarding this subject to finally relate both concepts.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先探讨Python函数中参数的机制，然后回顾与该主题相关的软件工程的一般原则，最后将这两个概念联系起来。
- en: How function arguments work in Python
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中函数参数的工作原理
- en: First, let's review the particularities of how arguments are passed to functions
    in Python.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下在Python中如何将参数传递给函数的特定之处。
- en: By first understanding the possibilities that Python offers for handling parameters,
    we will be able to assimilate general rules more easily, and the idea is that
    after having done so, we can easily draw conclusions on what good patterns or
    idioms are when handling arguments. Then, we can identify in which scenarios the
    Pythonic approach is the correct one, and in which cases we might be abusing the features
    of the language.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先了解Python提供的处理参数的可能性，我们将能够更容易地吸收一般规则，并且想法是，在这样做之后，我们可以轻松地得出关于处理参数时哪些是良好模式或习惯用法的结论。然后，我们可以确定在哪些场景下Python方法学是正确的，在哪些情况下我们可能会滥用语言的功能。
- en: How arguments are copied to functions
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数是如何传递给函数的
- en: The first rule in Python is that all arguments are passed by a value. Always.
    This means that when passing values to functions, they are assigned to the variables
    on the signature definition of the function to be later used on it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Python的第一条规则是所有参数都是通过值传递的。总是这样。这意味着当将值传递给函数时，它们被分配给函数签名定义中的变量，以便稍后使用。
- en: You will notice that a function may or may not mutate the parameters it receives,
    depending on their type. If we are passing `mutable` objects, and the body of
    the function modifies this, then of course, we have the side effect that they
    will have been changed by the time the function returns.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，一个函数可能会也可能不会根据其类型修改它接收的参数。如果我们传递的是`可变`对象，并且函数体修改了它，那么当然，我们会有副作用，即它们在函数返回时已经被改变。
- en: 'In the following, we can see the difference:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下内容中，我们可以看到差异：
- en: '[PRE28]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This might look like an inconsistency, but it's not. When we pass the first
    argument, a `string`, this is assigned to the argument on the `function`. Since
    `string` objects are immutable, a statement such as `argument += <expression>`
    will, in fact, create the new object, `argument + <expression>`, and assign that
    back to the argument. At that point, an argument is just a local variable inside
    the scope of the function and has nothing to do with the original one in the caller.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是不一致性，但实际上并不是。当我们传递第一个参数，一个`字符串`时，它被分配给`函数`上的参数。由于`字符串`对象是不可变的，一个如`argument
    += <expression>`的语句实际上会创建新的对象`argument + <expression>`，并将其分配回参数。在那个点上，参数只是函数作用域内的一个局部变量，与调用者中的原始参数无关。
- en: 'On the other hand, when we pass `list`, which is a `mutable` object, then that
    statement has a different meaning (it is equivalent to `calling .extend()` on
    that `list`). This operator acts by modifying the `list` in place over a variable
    that holds a reference to the original `list` object, hence modifying it. What
    happened in this second case is that the `list`''s reference was passed by a value
    to the function. But since it''s a reference, it is mutating the original `list`
    object, so we see the mutation after the function has finished. It''s roughly
    equivalent to this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们传递`列表`，这是一个`可变`对象时，这个语句有不同的含义（它相当于在`列表`上调用`.extend()`）。这个操作符通过修改一个持有原始`列表`对象引用的变量来就地修改`列表`。在这个第二种情况下，`列表`的引用是通过值传递给函数的。但由于它是一个引用，它正在修改原始`列表`对象，所以我们看到函数完成后发生了修改。这大致相当于这样：
- en: '[PRE29]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have to be careful when dealing with `mutable` objects because it can lead
    to unexpected side effects. Unless you are absolutely sure that it is correct
    to manipulate `mutable` arguments in this way, I would recommend avoiding it and
    going for alternatives without these problems.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理`可变`对象时，我们必须小心，因为它可能导致意外的副作用。除非你绝对确定以这种方式操作`可变`参数是正确的，否则我建议避免这样做，寻找没有这些问题的替代方案。
- en: Don't mutate function arguments. In general, try to avoid unnecessary side effects
    in functions as much as possible.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 不要修改函数参数。一般来说，尽可能避免在函数中产生不必要的副作用。
- en: Arguments in Python can be passed by position, as in many other programming
    languages, but also by keyword. This means that we can explicitly tell the function
    which values we want for which of its parameters. The only caveat is that after
    a parameter is passed by a keyword, the rest that follow must also be passed this
    way, otherwise, `SyntaxError` will be raised.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的参数可以通过位置传递，就像许多其他编程语言一样，也可以通过关键字传递。这意味着我们可以明确地告诉函数我们想要哪些参数值。唯一的注意事项是，在通过关键字传递一个参数之后，接下来的参数也必须以这种方式传递，否则将引发`SyntaxError`。
- en: Variable number of arguments
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变数量的参数
- en: Python, as well as other languages, has built-in functions and constructions
    that can take a variable number of arguments. Consider, for example, `string`
    interpolation functions (whether it be by using the `%` operator or the `format`
    method for strings), which follow a similar structure to the `printf` function
    in C, a first positional parameter with the `string` format, followed by any number
    of arguments that will be placed on the markers of that formatting string.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Python，以及其他语言，都有内置的函数和构造，可以接受可变数量的参数。例如，考虑`字符串插值`函数（无论是使用`%`运算符还是字符串的`format`方法），它们的结构类似于C语言中的`printf`函数，第一个位置参数是`字符串`格式，后面跟着任意数量的将被放置在该格式化字符串标记上的参数。
- en: Besides taking advantage of these functions that are available in Python, we
    can also create our own, which will work in a similar fashion. In this section,
    we will cover the basic principles of functions with a variable number of arguments,
    along with some recommendations, so that in the next section, we can explore how
    to use these features to our advantage when dealing with common problems, issues,
    and constraints that functions might have if they have too many arguments.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 除了利用Python中可用的这些函数外，我们还可以创建自己的函数，它们将以类似的方式工作。在本节中，我们将介绍具有可变数量参数的函数的基本原则，以及一些建议，以便在下一节中，我们可以探索如何利用这些特性来处理函数可能遇到的常见问题、问题和约束，如果函数有太多参数的话。
- en: For a variable number of `positional` arguments, the star symbol (`*`) is used,
    preceding the name of the variable that is packing those arguments. This works
    through the packing mechanism of Python.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可变数量的`位置参数`，使用星号符号（`*`），在变量名之前，该变量将打包这些参数。这是通过Python的打包机制实现的。
- en: Let's say there is a function that takes three positional arguments. In one
    part of the code, we conveniently happen to have the arguments we want to pass
    to the function inside a `list`, in the same order as they are expected by the
    function.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个函数接受三个位置参数。在代码的一部分中，我们方便地发现我们想要传递给函数的参数在一个`列表`中，并且按照函数期望的顺序排列。
- en: 'Instead of passing them one by one by the position (that is, `list[0]` to the
    first element, `list[1]` to the second, and so on), which would be really un-Pythonic,
    we can use the packing mechanism and pass them all together in a single instruction:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是逐个按位置传递（即`list[0]`到第一个元素，`list[1]`到第二个，以此类推），这会非常不符合Python风格，我们可以使用打包机制，并在一个指令中一起传递所有这些参数：
- en: '[PRE30]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The nice thing about the packing mechanism is that it also works the other
    way around. If we want to extract the values of a `list` to variables, by their
    respective position, we can assign them like this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 打包机制的好处在于它也可以反过来工作。如果我们想根据各自的`位置`提取`列表`的值到变量中，我们可以这样赋值：
- en: '[PRE31]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Partial unpacking is also possible. Let''s say we are just interested in the
    first values of a sequence (this can be a `list`, `tuple`, or something else),
    and after some point we just want the rest to be kept together. We can assign
    the variables we need and leave the rest under a packaged `list`. The order in
    which we unpack is not limited. If there is nothing to place in one of the unpacked
    subsections, the result will be an empty `list`. Try the following examples on
    a Python terminal and also explore how unpacking works with generators as well:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 部分解包也是可能的。假设我们只对序列（这可以是`列表`、`元组`或其他东西）的第一个值感兴趣，并且从某个点开始，我们只想将剩余的部分一起保留。我们可以赋值所需的变量，并将剩余的值放在一个打包的`列表`下。我们解包的顺序不受限制。如果没有东西可以放在解包的子部分中，结果将是一个空的`列表`。在Python终端上尝试以下示例，并探索解包与生成器一起工作的情况：
- en: '[PRE32]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'One of the best uses for unpacking variables can be found in iteration. When
    we have to iterate over a sequence of elements, and each element is, in turn,
    a sequence, it is a good idea to unpack at the same time each element is being
    iterated over. To see an example of this in action, we are going to pretend that
    we have a function that receives a `list` of database rows, and that it is in
    charge of creating users out of that data. The first implementation takes the
    values to construct the user with from the position of each column in the row,
    which is not idiomatic at all. The second implementation uses unpacking while
    iterating:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 解包变量的最佳用途之一可以在迭代中找到。当我们必须遍历一个元素序列时，并且每个元素本身也是一个序列，同时解包每个正在遍历的元素是一个好主意。为了展示这个例子，我们将假装我们有一个接收数据库行`列表`的函数，并且它负责从这些数据中创建用户。第一个实现从每行的列位置中获取构建用户的值，这根本不符合习惯。第二个实现使用解包进行迭代：
- en: '[PRE33]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that the second version is much easier to read. In the first version
    of the function (`bad_users_from_rows`), we have data expressed in the form `row[0]`,
    `row[1]`, and `row[2]`, which doesn't tell us anything about what they are. On
    the other hand, variables such as `user_id`, `first_name`, and `last_name` speak
    for themselves.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第二种版本更容易阅读。在函数的第一个版本（`bad_users_from_rows`）中，我们以`row[0]`、`row[1]`和`row[2]`的形式表达数据，这并没有告诉我们它们是什么。另一方面，像`user_id`、`first_name`和`last_name`这样的变量则不言自明。
- en: 'We could also use the star operator to pass all the `positional` parameters
    from the `tuple` when constructing the `User` object:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用星号运算符在构造`User`对象时传递所有`positional`参数：
- en: '[PRE34]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can leverage this kind of functionality to our advantage when designing our
    own functions.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这种功能来设计我们自己的函数。
- en: 'An example of this that we can find in the standard library lies in the `max`
    function, which is defined as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在标准库中找到一个这样的例子，那就是`max`函数，它定义如下：
- en: '[PRE35]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There is a similar notation, with two stars (`**`) for keyword arguments. If
    we have a dictionary and we pass it with a double star to a function, what it
    will do is pick the keys as the name for the parameter, and pass the `value` for
    that `key` as the `value` for that `parameter` in that function.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个类似的表示法，用于关键字参数，有两个星号（`**`）。如果我们有一个字典，并且用双星号将其传递给一个函数，它将执行的操作是选择键作为参数的名称，并将该`key`的`value`作为该函数中该参数的`value`传递。
- en: 'For instance, check this out:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看这个：
- en: '[PRE36]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It is the same as the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下内容相同：
- en: '[PRE37]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Conversely, if we define a function with a parameter starting with two star
    symbols, the opposite will happen—keyword-provided parameters will be packed into
    a dictionary:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果我们定义一个以两个星号符号开始的参数的函数，则会发生相反的情况——关键字提供的参数将被打包到一个字典中：
- en: '[PRE38]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This feature of Python is really powerful as it lets us choose dynamically the
    values we want to pass to a function. However, abusing this functionality, and
    making excessive use of it, will render the code harder to understand.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Python的这个特性真的很强大，因为它让我们可以动态地选择我们想要传递给函数的值。然而，过度使用这个功能，将使代码更难以理解。
- en: When we define a function as in the previous example, on which one of its parameters
    has a double star, meaning that arbitrary keyword arguments are allowed, Python
    will place them in a dictionary that we can access at our discretion. From the
    previously defined function, the `kwargs` argument is a dictionary. A good recommendation
    is to not use this dictionary to extract particular values from it.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们像上一个例子那样定义一个函数，其中一个参数带有双星号，这意味着允许任意关键字参数时，Python会将它们放置在一个我们可以随意访问的字典中。从之前定义的函数来看，`kwargs`参数是一个字典。一个好的建议是不要使用这个字典来从中提取特定的值。
- en: Namely, don't look for particular keys of the dictionary. Instead, extract these
    arguments directly on the function definition.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，不要寻找字典的特定键。相反，直接在函数定义中提取这些参数。
- en: 'For example, instead of doing something like this:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们不必这样做：
- en: '[PRE39]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let Python do the unpacking and set the default argument at the signature:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让Python进行解包，并在签名处设置默认参数：
- en: '[PRE40]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this example, timeout is not strictly keyword-only. We'll see how to make
    keyword-only arguments in a few sections, but the idea that should prevail is
    to not manipulate the `kwargs` dictionary, and instead execute proper unpacking
    at the signature level.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，timeout不是严格的位置唯一。我们将在接下来的几个部分中看到如何创建关键字唯一参数，但应该占主导地位的想法是不要操作`kwargs`字典，而是在签名级别执行适当的解包。
- en: Before diving into keyword-only arguments, let's start with those that are positional-only
    first.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨关键字唯一参数之前，让我们先从位置唯一参数开始。
- en: Positional-only parameters
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置唯一参数
- en: As we have seen already, positional arguments (variable or not) are those that
    are first provided to functions in Python. The values for these arguments are
    interpreted based on the position they're provided to the function, meaning they're
    assigned respectively to the parameters in the function's definition.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，位置参数（可变或不可变）是那些首先提供给Python函数的参数。这些参数的值根据它们提供给函数的位置来解释，这意味着它们分别分配给函数定义中的参数。
- en: 'If we don''t make use any special syntax when defining the function arguments,
    by default, they can be passed by position or keyword. For example, in the following
    function, all calls to the function are equivalent:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在定义函数参数时不使用任何特殊语法，默认情况下，它们可以通过位置或关键字传递。例如，在以下函数中，对函数的所有调用都是等效的：
- en: '[PRE41]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This means, in the first case, we pass the values `1` and `2`, and by their
    position, they're assigned to the parameters `x` and `y`, respectively. With this
    syntax, nothing stops us from passing the same arguments with their keyword (even
    in reverse order), should that be needed (for example, to be more explicit). The
    only constraint here is that if we pass one argument as a keyword, all the following
    ones must be provided as a keyword as well (the last example wouldn't work with
    the parameters reversed).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，在第一种情况下，我们传递值`1`和`2`，根据它们的位置，分别分配给参数`x`和`y`。使用这种语法，没有任何阻止我们以关键字（甚至以相反的顺序）传递相同的参数，如果需要的话（例如，为了更明确）。这里的唯一约束是，如果我们以关键字传递一个参数，所有后续的参数也必须以关键字提供（最后一个例子不能使用参数的相反顺序）。
- en: 'However, starting from Python 3.8 (PEP-570), new syntax was introduced that
    allows parameters to be defined that are strictly positional (meaning we can''t
    provide their name when passing values by). To use this, a `/` must be added to
    the end of the last positional-only argument). For example:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从 Python 3.8（PEP-570）版本开始，引入了新的语法，允许定义严格的位置参数（这意味着在通过传递值时我们不能提供它们的名称）。要使用这个功能，必须在最后一个仅位置参数的末尾添加一个斜杠（/）。例如：
- en: '[PRE42]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note how the first invocation of the function worked (just as before), but from
    now on, any attempt to pass a keyword argument will fail. The exception that is
    raised will tell us in its message the positional-only parameters that attempted
    to be passed as keyword-only. In general, using keyword arguments makes the code
    more readable because you'll know at all times which values are provided for which
    arguments, but there could be situations in which this syntax is useful, for example,
    in cases where the names of the arguments aren't meaningful (because they can't
    be, not because we did a poor job on naming them!), and attempting to use their
    name would be counterproductive.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数的第一个调用是如何工作的（就像之前一样），但从现在开始，任何尝试传递关键字参数的尝试都将失败。抛出的异常将在其消息中告诉我们尝试以关键字参数传递的位置参数。一般来说，使用关键字参数使代码更易读，因为你可以随时知道哪些值是为哪些参数提供的，但可能存在某些情况下这种语法是有用的，例如，在参数名称没有意义的情况下（因为它们不能有意义，不是因为我们在命名时做得不好！），尝试使用它们的名称将是徒劳的。
- en: To give a really simple example, imagine a function to check whether two words
    are anagrams. That function takes two strings and does some processing. It doesn't
    really matter how we name those two strings (and frankly their order doesn't matter,
    it would just be a first word and a second word). Trying to come up with good
    names for those arguments wouldn't make much sense, nor would assigning their
    keyword values when calling the function.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个非常简单的例子来说明，想象一个检查两个单词是否为同音异义词的函数。该函数接受两个字符串并执行一些处理。我们实际上并不关心这两个字符串的命名（坦白地说，它们的顺序也不重要，它们只是第一词和第二词）。试图为这些参数想出好的名称并没有太多意义，在调用函数时分配它们的关键字值也没有意义。
- en: For the rest of the cases, this should be avoided.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他情况，应避免使用。
- en: Don't force meaningful arguments to be positional-only.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 不要强迫有意义的参数仅作为位置参数。
- en: In very particular cases, positional-only parameters might be a good idea, but
    most of the time this shouldn't be required. But in general, this isn't a feature
    you'd want to use many times because we can take advantage of passing arguments
    as keywords, because that will make it easier to understand which values are being
    passed to which parameters. For that reason, the opposite case is something you'd
    want to do more often, making the arguments keyword-only, as we'll discuss in
    the next section.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常特殊的情况下，仅位置参数可能是个好主意，但大多数时候这并不是必需的。但一般来说，这不是你希望多次使用的功能，因为我们可以利用传递关键字参数的优势，因为这将使理解传递给哪个参数的值变得更容易。因此，相反的情况是你更愿意经常做的，即只使用关键字参数，正如我们将在下一节讨论的。
- en: Keyword-only arguments
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅关键字参数
- en: Analogous to the previous feature is the possibility of making some arguments
    keyword-only. This probably makes more sense, because we can find meaning when
    assigning the keyword argument on a function call, and now we can enforce this
    explicitness.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的功能类似，还有可能使一些参数仅作为关键字使用。这更有意义，因为当我们在一个函数调用中分配关键字参数时，我们可以找到其含义，现在我们可以强制执行这种明确性。
- en: In this case (and contrary to the previous one), we use the `*` symbol to signal
    when the keyword-only arguments start. In the function signature, everything that
    comes after the variable number of positional arguments (`*args`) will be keyword-only.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下（与上一个情况相反），我们使用`*`符号来表示关键字参数的开始。在函数签名中，所有在可变数量的位置参数（`*args`）之后的内容都将被定义为关键字参数。
- en: 'For example, the following definition takes two positional arguments, then
    any number of positional parameters, and then two final arguments, which are to
    be passed as keyword-only. The last one has a default value (although this is
    not mandatory, as in the third case):'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下定义接受两个位置参数，然后是任意数量的位置参数，最后是两个最终参数，这些参数需要作为关键字参数传递。最后一个参数有一个默认值（尽管这不是强制性的，就像第三个例子一样）：
- en: '[PRE43]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The function calls make it clear how this behaves. If we didn't want any number
    of positional arguments after the first two, we can simply put `*` instead of
    `*args`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用清楚地说明了这种行为。如果我们不想在第一个两个参数之后有任何数量的位置参数，我们只需简单地用`*`代替`*args`。
- en: This functionality is useful for extending functions or classes that are already
    defined (and being used) in a backward-compatible fashion. If, for example, you
    have a function that takes two arguments, and it's being called several times
    throughout the code (sometimes with the parameters by position, sometimes by keyword),
    and you'd want to add a third parameter, you'd have to set a default for it, if
    you want the current calls to keep working. But even better would be to make this
    last parameter keyword-only, so new calls have to make it explicit that they intend
    to use the new definition.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能对于以向后兼容的方式扩展已经定义（并且正在使用）的函数或类非常有用。例如，如果你有一个接受两个参数的函数，它在代码中多次被调用（有时按位置传递参数，有时按关键字传递），而你又想添加一个第三个参数，那么你需要为它设置一个默认值，这样当前的调用才能继续工作。但更好的做法是将最后一个参数设置为关键字参数，这样新的调用就必须明确表示它们打算使用新的定义。
- en: 'Along the same lines, this functionality is also useful when refactoring and
    keeping compatibility. Imagine you have a function that you''re replacing with
    a new implementation, but you keep the original function as a wrapper, in order
    to preserve compatibility. Let''s analyze the difference between a function call
    such as the following:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当重构并保持兼容性时，这个功能也非常有用。想象一下，你有一个函数，你正在用新的实现来替换它，但你保留原始函数作为包装器，以保持兼容性。让我们分析以下函数调用之间的差异：
- en: '[PRE44]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And another call as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个调用如下：
- en: '[PRE45]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It's clear that the second example is much more explicit, and you get a clear
    idea of what's going on as soon as you glance at the function call. For that reason,
    it makes sense to make the new parameter (which determines which implementation
    to use) keyword-only.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，第二个例子更加明确，你只需瞥一眼函数调用就能清楚地了解正在发生的事情。因此，将新参数（确定使用哪个实现）设置为关键字参数是有意义的。
- en: In cases like this, where there's an argument that really needs context in order
    to be understood, making that parameter keyword-only is a good idea.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果确实需要上下文才能理解某个参数，将其参数设置为关键字参数是一个好主意。
- en: These are the basics in terms of how arguments and parameters work in Python
    functions. Now we can use that knowledge to discuss this in terms of good design
    ideas.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是关于Python函数中参数和参数如何工作的基础知识。现在我们可以利用这些知识来讨论良好的设计理念。
- en: The number of arguments in functions
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数中的参数数量
- en: In this section, we agree on the idea that having functions or methods that
    take too many arguments is a sign of bad design (a code smell). Then, we propose
    ways of dealing with this issue.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们同意这样一个观点：拥有接受过多参数的函数或方法是设计不良（代码异味）的标志。然后，我们提出处理这个问题的方法。
- en: The first alternative is a more general principle of software design—reification
    (creating a new object for all of those arguments that we are passing, which is
    probably the abstraction we are missing). Compacting multiple arguments into a
    new object is not a solution specific to Python, but rather something that we
    can apply in any programming language.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个替代方案是一个更通用的软件设计原则——具体化（为所有传递的参数创建一个新对象，这可能是我们缺少的抽象）。将多个参数压缩到一个新对象中并不是Python特有的解决方案，而是一种我们可以应用于任何编程语言的解决方案。
- en: Another option would be to use the Python-specific features we saw in the previous
    section, making use of variable positional and keyword arguments to create functions
    that have a dynamic signature. While this might be a Pythonic way of proceeding,
    we have to be careful not to abuse the feature, because we might be creating something
    that is so dynamic that it is hard to maintain. In this case, we should take a
    look at the body of the function. Regardless of the signature, and whether the
    parameters seem to be correct, if the function is doing too many different things
    responding to the values of the parameters, then it is a sign that it has to be
    broken down into multiple smaller functions (remember, functions should do one
    thing, and one thing only!).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用我们在上一节中看到的Python特定功能，利用变量位置和关键字参数创建具有动态签名的函数。虽然这可能是一种Python风格的方法，但我们必须小心不要滥用这个特性，因为我们可能会创建出过于动态以至于难以维护的东西。在这种情况下，我们应该查看函数的主体。无论签名如何，无论参数看起来是否正确，如果函数正在执行太多不同的事情以响应参数的值，那么这是一个迹象，表明它必须被分解成多个更小的函数（记住，函数应该只做一件事，而且只做一件事！）。
- en: Function arguments and coupling
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数参数和耦合
- en: The more arguments a function signature has, the more likely this one is going
    to be tightly coupled with the caller function.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名中的参数越多，它与调用函数的耦合性就越强。
- en: Let's say we have two functions, `f1`, and `f2`, and the latter takes five parameters.
    The more parameters `f2` takes, the more difficult it would be for anyone trying
    to call that function to gather all that information and pass it along so that
    it can work properly.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个函数，`f1`和`f2`，后者需要五个参数。`f2`的参数越多，尝试调用该函数的人就越难收集所有这些信息并传递它们，以便它能够正常工作。
- en: Now, `f1` seems to have all of this information because it can call it correctly.
    From this, we can derive two conclusions. First, `f2` is probably a leaky abstraction,
    which means that since `f1` knows everything that `f2` requires, it can pretty
    much figure out what it is doing internally and will be able to do it by itself.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`f1`似乎拥有所有这些信息，因为它可以正确地调用它。由此，我们可以得出两个结论。首先，`f2`可能是一个有缺陷的抽象，这意味着由于`f1`知道`f2`所需的所有信息，它几乎可以自己推断出内部操作，并且能够独立完成。
- en: So, all in all, `f2` is not abstracting that much. Second, it looks like `f2`
    is only useful to `f1`, and it is hard to imagine using this function in a different
    context, making it harder to reuse.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说，`f2`并没有进行太多的抽象。其次，看起来`f2`只对`f1`有用，很难想象在另一个上下文中使用这个函数，这使得它更难以重用。
- en: When functions have a more general interface and are able to work with higher-level
    abstractions, they become more reusable.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数具有更通用的接口并且能够与更高级的抽象一起工作时，它们变得更加可重用。
- en: This applies to all sorts of functions and object methods, including the `__init__`
    method for classes. The presence of a method like this could generally (but not
    always) mean that a new higher-level abstraction should be passed instead, or
    that there is a missing object.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于所有类型的函数和对象方法，包括类的`__init__`方法。这样的方法的存在通常（但不总是）意味着应该传递一个新的更高级的抽象，或者可能缺少一个对象。
- en: If a function needs too many parameters to work properly, consider it a code
    smell.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数需要太多的参数才能正常工作，那么将其视为代码异味。
- en: In fact, this is such a design problem that static analysis tools such as `pylint`
    (discussed in *Chapter 1*, *Introduction, Code Formatting, and Tools*) will, by
    default, raise a warning when they encounter such a case. When this happens, don't
    suppress the warning—refactor it instead.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这是一个如此的设计问题，以至于静态分析工具，如`pylint`（在第1章的*介绍、代码格式化和工具*中讨论），默认情况下，在遇到这种情况时会发出警告。当这种情况发生时，不要抑制警告——而是重构它。
- en: Compact function signatures that take too many arguments
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过于紧凑的函数签名，参数过多
- en: Suppose we find a function that requires too many parameters. We know that we
    cannot leave the code base like that, and a refactor process is imperative. But
    what are the options?
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们找到一个需要太多参数的函数。我们知道我们不能让代码库保持原样，重构过程是必不可少的。但有哪些选择呢？
- en: Depending on the case, some of the following rules might apply. This is by no
    means extensive, but it does provide an idea of how to solve some scenarios that
    occur quite often.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 根据具体情况，以下的一些规则可能适用。这绝非详尽无遗，但它确实提供了一种解决一些经常出现的场景的方法的思路。
- en: 'Sometimes, there is an easy way to change parameters if we can see that most
    of them belong to a common object. For example, consider a function call like
    this one:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果我们能看出大多数参数属于一个共同的对象，我们可以很容易地更改参数。例如，考虑一个这样的函数调用：
- en: '[PRE46]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, the function might or might not take additional arguments, but something
    is really obvious here: All of the parameters depend upon `request`, so why not
    pass the `request` object instead? This is a simple change, but it significantly
    improves the code. The correct function call should be `track_request(request)`—not
    to mention that, semantically, it also makes much more sense.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，函数可能或可能不接收额外的参数，但这里有一个非常明显的事实：所有参数都依赖于`request`，那么为什么不传递`request`对象呢？这是一个简单的改动，但它显著提高了代码质量。正确的函数调用应该是`track_request(request)`——更不用说，从语义上讲，这也更有意义。
- en: While passing around parameters like this is encouraged, in all cases where
    we pass `mutable` objects to functions, we must be really careful about side effects.
    The function we are calling should not make any modifications to the object we
    are passing because that will mutate the object, creating an undesired side effect.
    Unless this is actually the desired effect (in which case, it must be made explicit),
    this kind of behavior is discouraged. Even when we actually want to change something
    on the object we are dealing with, a better alternative would be to copy it and
    return a (new) modified version of it.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然传递这类参数是被鼓励的，但在所有我们将`可变`对象传递给函数的情况下，我们必须非常小心副作用。我们调用的函数不应该对我们传递的对象进行任何修改，因为这将会改变对象，产生不期望的副作用。除非这确实是期望的效果（在这种情况下，它必须明确表示），否则这种做法是不被推荐的。即使我们实际上想要改变我们处理的对象上的某些内容，更好的选择是复制它并返回其（新的）修改版本。
- en: Work with immutable objects and avoid side effects as much as possible.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地与不可变对象一起工作，并尽量避免副作用。
- en: This brings us to a similar topic—grouping parameters. In the previous example,
    the parameters were already grouped, but the group (in this case, the `request`
    object) was not being used. But other cases are not as obvious as that one, and
    we might want to group all the data in the parameters in a single object that
    acts as a `container`. Needless to say, this grouping has to make sense. The idea
    here is to *reify*: Create the abstraction that was missing from our design.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们来到了一个类似的话题——参数分组。在前面的例子中，参数已经被分组，但这个组（在这种情况下，`request`对象）没有被使用。但其他情况并不像那个那么明显，我们可能想要将所有参数中的数据分组到一个充当`容器`的单个对象中。不言而喻，这种分组必须是有意义的。这里的想法是*具体化*：创建我们设计中缺失的抽象。
- en: If the previous strategies don't work, as a last resort we can change the signature
    of the function to accept a variable number of arguments. If the number of arguments
    is too big, using `*args` or `**kwargs` will make things harder to follow, so
    we have to make sure that the interface is properly documented and correctly used,
    but in some cases, this is worth doing.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的策略不起作用，作为最后的手段，我们可以更改函数的签名以接受可变数量的参数。如果参数的数量太多，使用`*args`或`**kwargs`会使事情更难以追踪，因此我们必须确保接口得到适当的文档记录和正确使用，但在某些情况下，这样做是值得的。
- en: It's true that a function defined with `*args` and `**kwargs` is really flexible
    and adaptable, but the disadvantage is that it loses its signature, and with that,
    part of its meaning, and almost all of its legibility. We have seen examples of
    how names for variables (including function arguments) make the code much easier
    to read. If a function will take any number of arguments (positional or keyword),
    we might find out that when we want to take a look at that function in the future,
    we probably won't know exactly what it was supposed to do with its parameters,
    unless it has a very good docstring.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 事实确实如此，使用`*args`和`**kwargs`定义的函数非常灵活和适应性强，但缺点是它失去了其签名，以及与之相关的部分意义和几乎所有的可读性。我们已经看到了变量名（包括函数参数）如何使代码更容易阅读的例子。如果一个函数将接受任意数量的参数（位置或关键字），我们可能会发现，当我们将来想要查看该函数时，我们可能不知道它原本打算如何处理其参数，除非它有一个非常好的文档字符串。
- en: Try to only define functions with the most generic arguments (`*args`, `**kwargs`)
    when you want a perfect wrapper over another function (for example, a method that
    will call `super()`, or a decorator).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想完美地包装另一个函数（例如，将调用`super()`的方法或装饰器）时，尽量只定义具有最通用参数（`*args`，`**kwargs`）的函数。
- en: Final remarks on good practices for software design
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于软件设计良好实践的最终评论
- en: Good software design involves a combination of following good practices of software
    engineering and taking advantage of most of the features of the language. There
    is great value in using everything that Python has to offer, but there is also
    a great risk of abusing this and trying to fit complex features into simple designs.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的软件设计涉及结合遵循软件工程的良好实践和利用语言的大部分功能。充分利用Python提供的一切具有很大的价值，但同时也存在着滥用这种能力并试图将复杂特性纳入简单设计的巨大风险。
- en: In addition to this general principle, it would be good to add some final recommendations.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个一般原则之外，添加一些最终的建议会更好。
- en: Orthogonality in software
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件中的正交性
- en: This word is very general and can have multiple meanings or interpretations.
    In math, orthogonal means that two elements are independent. If two vectors are
    orthogonal, their scalar product is zero. It also means they are not related at
    all. A change in one of them doesn't affect the other one at all. That's the way
    we should think about our software.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这个词非常通用，可以有多个含义或解释。在数学中，正交意味着两个元素是独立的。如果两个向量是正交的，它们的标量积为零。这也意味着它们之间没有任何关系。其中一个的变化根本不影响另一个。这就是我们应该思考我们软件的方式。
- en: Changing a module, class, or function should have no impact on the outside world
    to that component that is being modified. This is, of course, highly desirable,
    but not always possible. But even for cases where it's not possible, a good design
    will try to minimize the impact as much as possible. We have seen ideas such as
    separation of concerns, cohesion, and isolation of components.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 修改模块、类或函数不应该对该组件的外部世界产生影响。这当然是高度期望的，但并不总是可能的。但即使在不可能的案例中，良好的设计也会尽可能地最小化影响。我们已经看到了一些想法，比如关注点的分离、内聚和组件的隔离。
- en: In terms of the runtime structure of software, orthogonality can be interpreted
    as the process of making changes (or side effects) local. This means, for instance,
    that calling a method on an object should not alter the internal state of other
    (unrelated) objects. We have already (and will continue to do so) emphasized in
    this book the importance of minimizing side effects in our code.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件的运行时结构方面，正交性可以解释为使更改（或副作用）局部化的过程。这意味着，例如，调用一个对象上的方法不应该改变其他（无关）对象的内部状态。我们已经在本书中（并将继续这样做）强调了最小化代码中副作用的重要性。
- en: In the example with the mixin class, we created a tokenizer object that returned
    an `iterable`. The fact that the `__iter__` method returned a new generator increases
    the chances that all three classes (the base, the mixing, and the concrete class)
    are orthogonal. If this had returned something in concrete (a `list`, let's say),
    this would have created a dependency on the rest of the classes, because when
    we changed the `list` to something else, we might have needed to update other
    parts of the code, revealing that the classes were not as independent as they
    should be.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在混入类示例中，我们创建了一个返回`iterable`的标记化对象。`__iter__`方法返回一个新的生成器的事实增加了所有三个类（基类、混入类和具体类）正交的可能性。如果这返回了具体的东西（比如一个`list`），这将导致对其他类的依赖，因为当我们把`list`改为其他东西时，我们可能需要更新代码的其他部分，揭示出这些类并不像它们应该的那样独立。
- en: 'Let''s show you a quick example. Python allows passing functions by parameter
    because they are just regular objects. We can use this feature to achieve some
    orthogonality. We have a function that calculates a price, including taxes and
    discounts, but afterward we want to format the final price that''s obtained:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给你一个快速示例。Python允许通过参数传递函数，因为它们只是常规对象。我们可以利用这个特性来实现一些正交性。我们有一个计算价格（包括税费和折扣）的函数，但之后我们想要格式化最终得到的价格：
- en: '[PRE47]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Notice that the top-level function is composing two orthogonal functions. One
    thing to notice is how we calculate `price`, which is how the other one is going
    to be represented. Changing one does not change the other. If we don''t pass anything
    in particular, it will use `string` conversion as the default representation function,
    and if we choose to pass a custom function, the resulting `string` will change.
    However, changes in `show_price` do not affect `calculate_price`. We can make
    changes to either function, knowing that the other one will remain as it was:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，顶级函数是由两个正交函数组成的。值得注意的是我们如何计算`price`，这是另一个将要如何表示的方式。改变一个不会改变另一个。如果我们不传递任何特定内容，它将使用`string`转换作为默认表示函数，如果我们选择传递一个自定义函数，生成的`string`将改变。然而，`show_price`中的更改不会影响`calculate_price`。我们可以对任一函数进行更改，知道另一个将保持原样：
- en: '[PRE48]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: There is an interesting quality aspect that relates to orthogonality. If two
    parts of the code are orthogonal, it means one can change without affecting the
    other. This implies that the part that changed has unit tests that are also orthogonal
    to the unit tests of the rest of the application. Under this assumption, if those
    tests pass, we can assume (up to a certain degree) that the application is correct
    without needing full regression testing.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 与正交性相关的一个有趣的质量方面是，如果代码的两个部分是正交的，这意味着一个可以改变而不影响另一个。这暗示了更改的部分具有与整个应用程序的其他单元测试正交的单元测试。在这个假设下，如果那些测试通过，我们可以假设（在一定范围内）应用程序是正确的，而无需进行全面回归测试。
- en: More broadly, orthogonality can be thought of in terms of features. Two functionalities
    of the application can be totally independent so that they can be tested and released
    without having to worry that one might break the other (or the rest of the code,
    for that matter). Imagine that the project requires a new authentication mechanism
    (`oauth2`, let's say, but just for the sake of the example), and at the same time
    another team is also working on a new report.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 更广泛地说，正交性可以用特征来考虑。应用程序的两个功能可以完全独立，以至于它们可以在不担心一个可能会破坏另一个（或者代码的其余部分）的情况下进行测试和发布。想象一下，项目需要一个新的认证机制（例如`oauth2`，但只是为了举例），同时另一个团队也在进行一个新的报告。
- en: Unless there is something fundamentally wrong in that system, neither of those
    features should impact the other. Regardless of which one of those gets merged
    first, the other one should not be affected at all.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 除非系统中存在根本性的错误，否则这两个功能都不应该影响对方。无论哪个先合并，另一个都不应该受到影响。
- en: Structuring the code
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码结构
- en: The way code is organized also impacts the performance of the team and its maintainability.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的组织方式也会影响团队的表现和其可维护性。
- en: In particular, having large files with lots of definitions (classes, functions,
    constants, and so on) is a bad practice and should be discouraged. This doesn't
    mean going to the extreme of placing one definition per file, but a good code
    base will structure and arrange components by similarity.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，拥有包含大量定义（类、函数、常量等）的大文件是一种不良做法，应该被劝阻。这并不意味着将每个定义放在一个文件中，但一个好的代码库将根据相似性对组件进行结构和排列。
- en: Luckily, most of the time, changing a large file into smaller ones is not a
    hard task in Python. Even if other multiple parts of the code depend on definitions
    made on that file, this can be broken down into a package, and will maintain total
    compatibility. The idea would be to create a new directory with a `__init__.py`
    file on it (this will make it a Python package). Alongside this file, we will
    have multiple files with all the particular definitions each one requires (fewer
    functions and classes grouped by a certain criterion). Then, the `__init__.py`
    file will import from all the other files the definitions it previously had (which
    is what guarantees its compatibility). Additionally, these definitions can be
    mentioned in the `__all__` variable of the module to make them exportable.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在Python中，将大文件拆分成小文件通常不是一个困难的任务。即使代码的其他多个部分依赖于该文件上的定义，也可以将其拆分为一个包，并保持完全兼容性。想法是创建一个新的目录，并在其中创建一个`__init__.py`文件（这将使其成为一个Python包）。与该文件并行，我们将拥有多个文件，每个文件都包含每个文件所需的特定定义（根据某些标准将少量函数和类分组）。然后，`__init__.py`文件将从所有其他文件中导入它之前拥有的定义（这保证了其兼容性）。此外，这些定义可以在模块的`__all__`变量中提及，以便它们可以被导出。
- en: 'There are many advantages to this. Other than the fact that each file will
    be easier to navigate, and things will be easier to find, we could argue that
    it will be more efficient for the following reasons:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多优点。除了每个文件更容易导航，事情更容易找到之外，我们还可以从以下原因来论证它将更加高效：
- en: It contains fewer objects to parse and load into memory when the module is imported.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当模块被导入时，它包含的解析和加载到内存中的对象更少。
- en: The module itself will probably be importing fewer modules because it needs fewer
    dependencies, like before.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该模块本身可能导入的模块更少，因为它需要的依赖更少，就像之前一样。
- en: 'It also helps to have a convention for the project. For example, instead of
    placing `constants` in all of the files, we can create a file specific to the
    constant values to be used in the project, and import it from there:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 对于项目来说，有一个约定也很有帮助。例如，我们可以在所有文件中放置`常量`，而不是创建一个专门用于项目中要使用的常量值的文件，并从那里导入：
- en: '[PRE49]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Centralizing information in this way makes it easier to reuse code and helps
    to avoid inadvertent duplication.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式集中信息使得代码重用更容易，并有助于避免无意中的重复。
- en: More details about separating modules and creating Python packages will be discussed
    in *Chapter 10*, *Clean Architecture*, when we explore this in the context of
    software architecture.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于分离模块和创建 Python 包的细节将在第 10 章“干净的架构”中讨论，当我们从软件架构的角度探讨这一主题时。
- en: Summary
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored several principles to achieve a clean design.
    Understanding that the code is part of the design is key to achieving high-quality
    software. This and the following chapter are focused precisely on that.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了几个实现清晰设计的原则。理解代码是设计的一部分是实现高质量软件的关键。这一章和下一章正是专注于这一点。
- en: With these ideas, we can now construct more robust code. For example, by applying
    DbC, we can create components that are guaranteed to work within their constraints.
    More importantly, if errors occur, this will not happen out of the blue, but instead,
    we will have a clear idea of who the offender is and which part of the code broke
    the contract. This compartmentalization is key to effective debugging.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些想法，我们现在可以构建更健壮的代码。例如，通过应用 DbC，我们可以创建在约束内保证工作的组件。更重要的是，如果发生错误，这不会突然发生，而是我们将清楚地知道是谁违反了规则以及代码的哪个部分破坏了合同。这种模块化对于有效的调试至关重要。
- en: Along similar lines, each component can be made more robust if it defends itself
    from malicious intent or incorrect input. Although this idea goes in a different
    direction from DbC, it might complement it very well. Defensive programming is
    a good idea, especially for critical parts of the application.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着类似的思路，如果每个组件能够防御恶意意图或错误的输入，它就可以变得更加健壮。尽管这个想法与 DbC 的方向不同，但它可能与之很好地互补。防御性编程是一个好主意，特别是对于应用程序的关键部分。
- en: For both approaches (DbC and defensive programming), it's important to correctly
    handle assertions. Keep in mind how they should be used in Python, and don't use
    assertions as part of the control flow logic of the program. Don't catch this
    exception, either.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种方法（DbC 和防御性编程），正确处理断言非常重要。记住它们在 Python 中的使用方式，并且不要将断言用作程序控制流逻辑的一部分。也不要捕获这个异常。
- en: Speaking of exceptions, it's important to know how and when to use them, and
    the most important concept here is to avoid using exception as a control flow
    (`go-to`) kind of construction.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到异常，了解何时以及如何使用它们很重要，这里最重要的概念是避免将异常用作控制流（`goto`）类型的结构。
- en: We have explored a recurrent topic in object-oriented design—deciding between
    using inheritance or composition. The main lesson here is not to use one over
    the other, but to use whichever option is better; we should also avoid some common
    anti-patterns, which we might often see in Python (especially given its highly
    dynamic nature).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了面向对象设计中一个反复出现的话题——在继承和组合之间做出选择。这里的主要教训不是使用一个而放弃另一个，而是使用更好的选项；我们还应该避免一些常见的反模式，这些模式我们在
    Python 中可能会经常看到（尤其是在考虑到其高度动态的特性）。
- en: Finally, we discussed the number of arguments in functions, along with heuristics
    for a clean design, always with the particularities of Python in mind.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了函数中的参数数量，以及考虑 Python 特定性的清晰设计启发式方法。
- en: These concepts are fundamental design ideas that lay the foundations for what's
    coming in the next chapter. We need to first understand these ideas so that we
    can move on to more advanced topics, such as SOLID principles.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念是基本的设计理念，为下一章的内容奠定了基础。我们需要首先理解这些理念，以便我们能够继续学习更高级的主题，例如SOLID原则。
- en: References
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Here is a list of information you can refer to:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一份您可以参考的信息列表：
- en: '*PEP-570*: *Python Positional-Only Parameters* ([https://www.python.org/dev/peps/pep-0570/](https://www.python.org/dev/peps/pep-0570/))'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-570*：*Python位置只参数*：[https://www.python.org/dev/peps/pep-0570/](https://www.python.org/dev/peps/pep-0570/)'
- en: '*PEP-3102*: *Keyword-Only Arguments* ([https://www.python.org/dev/peps/pep-3102/](https://www.python.org/dev/peps/pep-3102/))'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-3102*：*关键字仅参数*：[https://www.python.org/dev/peps/pep-3102/](https://www.python.org/dev/peps/pep-3102/)'
- en: '*Object-Oriented Software Construction*, *Second Edition*, written by *Bertrand
    Meyer*'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《面向对象软件构造》*，第二版，作者：*伯特朗·迈耶*'
- en: '*The Pragmatic Programmer: From Journeyman to Master*, by *Andrew Hunt* and
    *David Thomas*, published by *Addison-Wesley*, 2000.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《程序员修炼之道：从小工到大师》*，作者：*安德鲁·亨特* 和 *大卫·托马斯*，出版社：*Addison-Wesley*，2000年出版。'
- en: '*PEP-316*: *Programming by Contract for Python* ([https://www.python.org/dev/peps/pep-0316/](https://www.python.org/dev/peps/pep-0316/))'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-316*：*Python的契约式编程*：[https://www.python.org/dev/peps/pep-0316/](https://www.python.org/dev/peps/pep-0316/)'
- en: '*REAL 01*: *The Most Diabolical Python Antipattern* ([https://realpython.com/blog/python/the-most-diabolical-python-antipattern/](https://realpython.com/blog/python/the-most-diabolical-python-antipattern/))'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*REAL 01*：*最狡猾的Python反模式*：[https://realpython.com/blog/python/the-most-diabolical-python-antipattern/](https://realpython.com/blog/python/the-most-diabolical-python-antipattern/)'
- en: '*PEP-3134*: *Exception Chaining and Embedded Tracebacks*: ([https://www.python.org/dev/peps/pep-3134/](https://www.python.org/dev/peps/pep-3134/))'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-3134*：*异常链和嵌套回溯*：[https://www.python.org/dev/peps/pep-3134/](https://www.python.org/dev/peps/pep-3134/)'
- en: '*Idiomatic Python: EAFP versus LBYL*: [https://blogs.msdn.microsoft.com/pythonengineering/2016/06/29/idiomatic-python-eafp-versus-lbyl/](https://blogs.msdn.microsoft.com/pythonengineering/2016/06/29/idiomatic-python-eafp-versus-lbyl/)'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python的惯用表达：EAFP与LBYL*：[https://blogs.msdn.microsoft.com/pythonengineering/2016/06/29/idiomatic-python-eafp-versus-lbyl/](https://blogs.msdn.microsoft.com/pythonengineering/2016/06/29/idiomatic-python-eafp-versus-lbyl/)'
- en: '*Composition vs. Inheritance: How to Choose?* [https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose](https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose)'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组合与继承：如何选择？*：[https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose](https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose)'
- en: '*Python HTTP*: [https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler](https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler)'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python HTTP*：[https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler](https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler)'
- en: 'Source reference for exceptions in the requests library: [http://docs.python-requests.org/en/master/_modules/requests/exceptions/](http://docs.python-requests.org/en/master/_modules/requests/exceptions/)'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求库中异常的来源参考：[http://docs.python-requests.org/en/master/_modules/requests/exceptions/](http://docs.python-requests.org/en/master/_modules/requests/exceptions/)
- en: '*Code Complete: A Practical Handbook of Software Construction*, *Second Edition*,
    written by *Steve McConnell*'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《代码大全：软件构造实用手册》*，第二版，作者：*史蒂夫·麦克康奈尔*'
