<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer133">
<h1 class="chapter-number" id="_idParaDest-125"><a id="_idTextAnchor129"/>6</h1>
<h1 id="_idParaDest-126"><a id="_idTextAnchor130"/>Structuring Our Code and Add-Ons</h1>
<p>The add-ons we have created so far consist of single Python files. That’s ok, but to deal with complexity, we can split our code into related modules contained in the <span class="No-Break">same directory.</span></p>
<p>Writing modules that interact with each other rather than a single huge file makes design and maintenance easier, allowing us to shift our focus to single aspects of <span class="No-Break">our task.</span></p>
<p>The presence of non-code files, such as images and other media, can be another reason for adopting a folder structure. This is because sharing one folder is more practical than handling the Python script and the <span class="No-Break">data separately.</span></p>
<p>In this chapter, you will learn how to code across separate modules of a package and blend everything using the import system. The packaged add-on that we are going to create will be easier to distribute, read, and maintain, and it will be possible to grasp the functionality of its different parts by just looking at <span class="No-Break">the filenames.</span></p>
<p>This chapter will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Creating a <span class="No-Break">Python package</span></li>
<li>Loading and refreshing code <span class="No-Break">and assets</span></li>
<li>Reading environment variables in <span class="No-Break">your scripts</span></li>
<li>Using the <span class="No-Break">Preferences system</span></li>
</ul>
<h1 id="_idParaDest-127"><a id="_idTextAnchor131"/>Technical requirements</h1>
<p>We will use Blender and Visual Studio Code in this chapter. The examples created in this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch6"><span class="No-Break">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch6</span></a><span class="No-Break">.</span></p>
<p>Optionally, on Windows, we can use 7-Zip to create compressed archives. 7-Zip is a free application that can be downloaded <span class="No-Break">from </span><a href="https://www.7zip.org"><span class="No-Break">https://www.7zip.org</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor132"/>Folders, packages, and add-ons</h1>
<p>We know that an add-on consists of Python code accompanied by information for the Blender plugin system. While single-file Python scripts are called modules, a folder of scripts is called <span class="No-Break">a package.</span></p>
<p>Writing an add-on folder implies that we will store the Blender information at the package level, so we will create a directory and create the package <span class="No-Break">information first.</span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor133"/>Creating a package folder and the init file</h2>
<p>Let’s create a <a id="_idIndexMarker384"/>folder for <em class="italic">this chapter</em> in our Python project. Then, in <a id="_idIndexMarker385"/>the <strong class="bold">Blender Preferences</strong> area, set the <strong class="source-inline">ch6</strong> folder as our <strong class="bold">Scripts Folder</strong> and restart Blender. To make a package, we need to create a new folder rather than a new file. We can do that using the file manager or, like in the following steps, use the files bar of our <span class="No-Break">programmer editor:</span></p>
<ol>
<li><span class="No-Break">Select </span><span class="No-Break"><strong class="source-inline">PythonScriptingBlender/ch6/addons</strong></span><span class="No-Break">.</span></li>
<li>Create a new folder by clicking the <strong class="bold">New </strong><span class="No-Break"><strong class="bold">Folder</strong></span><span class="No-Break"> icon:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer120">
<img alt="Figure 6.1: Creating folders in Visual Studio Code" height="485" src="image/Figure_6.1_B18375.jpg" width="478"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1: Creating folders in Visual Studio Code</p>
<ol>
<li value="3">Name the new <span class="No-Break">folder </span><span class="No-Break"><strong class="source-inline">structured_addon</strong></span><span class="No-Break">.</span></li>
</ol>
<p>A Python package contains a file named <strong class="source-inline">__init__.py</strong>. This is the <strong class="bold">entry point</strong> of the folder and Python runs it automatically when it imports a package. To create it, follow <span class="No-Break">these steps:</span></p>
<ol>
<li>Select the <strong class="source-inline">…/</strong><span class="No-Break"><strong class="source-inline">ch6/addons/structured_addon</strong></span><span class="No-Break"> folder.</span></li>
<li>Create a new <a id="_idIndexMarker386"/>file by clicking <a id="_idIndexMarker387"/>on the <strong class="bold">New </strong><span class="No-Break"><strong class="bold">File</strong></span><span class="No-Break"> icon:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer121">
<img alt="Figure 6.2: Creating a new file in Visual Studio Code" height="485" src="image/Figure_6.2_B18375.jpg" width="478"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2: Creating a new file in Visual Studio Code</p>
<ol>
<li value="3">Name the new <span class="No-Break">file </span><span class="No-Break"><strong class="source-inline">__init__.py</strong></span><span class="No-Break">.</span></li>
<li>Open the file by <span class="No-Break">double-clicking it.</span></li>
</ol>
<p>When Blender searches for installed add-ons, it will look for the <strong class="source-inline">bl_info</strong> dictionary inside the <strong class="source-inline">__init__.py</strong> files of this folder. We will fill in this information in the <span class="No-Break">usual way.</span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor134"/>Writing the init file</h2>
<p>This <strong class="source-inline">bl_info</strong> dictionary <a id="_idIndexMarker388"/>contains the usual attributes for <span class="No-Break">add-on discovery:</span></p>
<pre class="source-code">
bl_info = {
    "name": "A Structured Add-on",
    "author": "John Doe",
    "version": (1, 0),
    "blender": (3, 2, 0),
    "description": "Add-on consisting of multiple files",
    "category": "Learning",
}</pre>
<p>Providing a <strong class="source-inline">register()</strong> and an <strong class="source-inline">unregister()</strong> function will allow us to enable and disable <span class="No-Break">the add-on:</span></p>
<pre class="source-code">
def register():
    pass
def unregister():
    pass</pre>
<p>Now, we should be <a id="_idIndexMarker389"/>able to see our <strong class="bold">Structured Add-on</strong> if we restart Blender or refresh the <span class="No-Break">add-ons list:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer122">
<img alt="Figure 6.3: Structured Add-on listed in the “Learning” category" height="384" src="image/Figure_6.03_B18375.jpg" width="759"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3: Structured Add-on listed in the “Learning” category</p>
<p>We are going to make it useful by adding some content using different <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">py</strong></span><span class="No-Break"> files.</span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor135"/>Guidelines for separating modules</h2>
<p>There is a trade-off between partitioning and centralizing the code: excessively atomized code <a id="_idIndexMarker390"/>risks being unclear and hard to maintain. So, even if there are no fixed rules about splitting a program, there are general criteria for writing <span class="No-Break">modular code:</span></p>
<ul>
<li>Non-Python files such as <em class="italic">media</em> (images, sounds, and so on) have their subfolders according to <span class="No-Break">their types</span></li>
<li><em class="italic">Generic code</em> used by unrelated classes can be considered a utility module and used like <span class="No-Break">a library</span></li>
<li><em class="italic">Specific code</em> relevant to a particular functionality should be a <span class="No-Break">specific module</span></li>
<li><em class="italic">UI</em> classes, such as panels and menus, can be separated by <span class="No-Break">non-UI code</span></li>
<li><em class="italic">Operators</em> can be separated from non-operator code and split <span class="No-Break">per category</span></li>
<li><em class="italic">Import</em> statements relevant to only a part of a script might imply that entire sections could go to another file, thus reducing the number of imported libraries in <span class="No-Break">one file</span></li>
</ul>
<p>We will put these concepts into practice and see how, starting with an example we are familiar with, the package architecture makes our code clearer and <span class="No-Break">more effective:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer123">
<img alt="Figure 6.4: Execution of an add-on folder – __init__.py glues all the parts together" height="998" src="image/Figure_6.04_B18375.jpg" width="1092"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4: Execution of an add-on folder – __init__.py glues all the parts together</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor136"/>Writing the structured panel</h2>
<p>We wrote a <a id="_idIndexMarker391"/>user interface in <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, that relied on an external <strong class="source-inline">.png</strong> file to display an icon. That makes the tool difficult to share because Blender can only install either one <strong class="source-inline">.py</strong> or <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">zip</strong></span><span class="No-Break"> file.</span></p>
<p>We can bundle pictures and code together if we structure it all as a folder. According to the guidelines summed up earlier, we can create <span class="No-Break">the following:</span></p>
<ul>
<li>A subfolder for the <em class="italic">icon storage</em> (media files) <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">pictures</strong></span></li>
<li>A module for <em class="italic">icon loading</em> (generic functionality) <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">img_load.py</strong></span></li>
<li>A module that contains the <em class="italic">panel</em> (UI separation) <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">panel.py</strong></span></li>
<li>A module for add-on <em class="italic">preferences</em> (specific functionality) <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">preferences.py</strong></span></li>
<li>A module to <em class="italic">reload</em> the <a id="_idIndexMarker392"/>import system (maintenance utility) <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">_refresh_.py</strong></span></li>
</ul>
<p>In the next section, we will create a folder for storing the image files and the code for <span class="No-Break">loading them.</span></p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor137"/>Packing external images</h1>
<p>If we use image files for <a id="_idIndexMarker393"/>our add-on, we can create a folder in the <strong class="source-inline">structured_addon</strong> directory and name it <strong class="source-inline">pictures</strong>. Since we are going to write a module for loading icons, this folder can contain a collection of <span class="No-Break">image files.</span></p>
<p>In the <strong class="source-inline">ch6\addons\structured_addon\pictures</strong> folder from the examples, we have <strong class="source-inline">pack_64.png</strong>, a clipart representing a package, and <strong class="source-inline">smile_64.png</strong>, the smiley face from the <span class="No-Break">previous chapter:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer124">
<img alt="Figure 6.5: The pictures used for this add-on are stored in a folder" height="371" src="image/Figure_6.05_B18375.jpg" width="734"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5: The pictures used for this add-on are stored in a folder</p>
<p>Once all our images are in this folder, we can write the code to <span class="No-Break">load them.</span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor138"/>Writing an icon library</h2>
<p>In <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, we wrote a function that loads a specific image file <a id="_idIndexMarker394"/>from disk. That worked great. Now that we are loading two icons, we can just use the same <span class="No-Break">routine twice.</span></p>
<p>But now that we have an entire module for loading images, we can write a more sophisticated solution that works for any number of icons since it doesn’t rely on hardcoded <span class="No-Break">full paths.</span></p>
<p>This new loader scans the pictures folder for images. We will make sure that loading times are not increased by multiple calls from other modules so that we end up with a more flexible, yet still reliable, loader for custom images. Let’s create the module’s file, following the same steps <span class="No-Break">as before:</span></p>
<ol>
<li>Select the <strong class="source-inline">…/</strong><span class="No-Break"><strong class="source-inline">ch6/addons/structured_addon</strong></span><span class="No-Break"> folder.</span></li>
<li>Create a new file by clicking the <strong class="bold">New </strong><span class="No-Break"><strong class="bold">File</strong></span><span class="No-Break"> icon.</span></li>
<li>Name the new <span class="No-Break">file </span><span class="No-Break"><strong class="source-inline">img_loader.py</strong></span><span class="No-Break">.</span></li>
<li>Open the file by <span class="No-Break">double-clicking it.</span></li>
</ol>
<p>This module will handle icon loading for the <span class="No-Break">entire package.</span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor139"/>Loading pictures from a folder</h2>
<p>The <strong class="source-inline">img_loader</strong> module <a id="_idIndexMarker395"/>scrolls the image files from a folder, so we need to import the <strong class="source-inline">os</strong> package to access directories. And of course, <strong class="source-inline">bpy.utils.previews</strong> is needed for loading the images from the file and storing them <span class="No-Break">as icons:</span></p>
<pre class="source-code">
from bpy.utils import previews
import os</pre>
<p>We use a global variable, a list, to store the Blender previews <strong class="source-inline">Collection</strong>. Following the Python naming convention, the variable name is uppercase since it’s global. Also, it starts with an underscore because it is not meant to be used in any <span class="No-Break">other module:</span></p>
<pre class="source-code">
_CUSTOM_ICONS = None</pre>
<p>We create the <strong class="source-inline">register_icons()</strong> function to load the icons from disk. It is like the <strong class="source-inline">load_custom_icons</strong> function from the first section of <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><span class="No-Break">.</span></p>
<p>If <strong class="source-inline">_CUSTOM_ICONS</strong> tests <strong class="source-inline">True</strong> to the <strong class="source-inline">if</strong> condition, the <strong class="source-inline">return</strong> statement will exit the <a id="_idIndexMarker396"/>function immediately. That prevents it from loading the icons repeatedly every time that the module is used. Otherwise, we create a new collection of icons <span class="No-Break">via </span><span class="No-Break"><strong class="source-inline">previews.new()</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
def register_icons():
    """Load icons from the add-on folder"""
    global _CUSTOM_ICONS
    <strong class="source-inline">if _CUSTOM_ICONS:</strong>  # avoid loading icons twice
        <strong class="source-inline">return</strong>
    collection = <strong class="source-inline">previews.new()</strong></pre>
<p>Rather than hardcoding filenames, we load all the images contained in the <strong class="source-inline">pictures</strong> folder. We don’t want to load non-image files, so we store a list of our viable image extensions in the <strong class="source-inline">img_extensions</strong> variable. We are only using the <strong class="source-inline">.png</strong> and <strong class="source-inline">.jpg</strong> formats in this example but others, such as <strong class="source-inline">.tif</strong>, can <span class="No-Break">be used:</span></p>
<pre class="source-code">
    img_extensions = (<strong class="source-inline">'.png'</strong>, <strong class="source-inline">'.jpg'</strong>)</pre>
<p>We get the path to the pictures folder by adding <strong class="source-inline">'pictures'</strong> to the module’s path. When dealing with files, path functions from the <strong class="source-inline">os</strong> utilities are preferred to string manipulation since they ensure multi-platform compatibility. So, we build the <strong class="source-inline">picture_path</strong> variable using the <span class="No-Break"><strong class="source-inline">os.path.join</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
    module_path = os.path.dirname(__file__)
    picture_path = <strong class="source-inline">os.path.join</strong>(module_path, 'pictures')</pre>
<p>The <strong class="source-inline">os.listdir</strong> function returns a list of all the filenames contained in a directory. We navigate the list with a <strong class="source-inline">for</strong> loop, and at each iteration, we separate the filename from the extension using the <strong class="source-inline">os.path.splitext</strong> function. Both lower and uppercase extensions are valid, but string comparison is a case-sensitive operation. We convert all file extensions into lowercase letters so that <strong class="source-inline">.jpg</strong> or <strong class="source-inline">.png</strong> files can be considered. When a file extension is not found in <strong class="source-inline">img_extensions</strong>, the file is skipped by the <span class="No-Break"><strong class="source-inline">continue</strong></span><span class="No-Break"> statement:</span></p>
<pre class="source-code">
    for img_file in <strong class="source-inline">os.listdir(picture_path)</strong>:
        img_name, ext = os.path.<strong class="source-inline">splitext</strong>(img_file)
        if <strong class="source-inline">ext.lower()</strong> not in img_extensions:
            # skip non image files
            <strong class="source-inline">continue</strong></pre>
<p class="callout-heading">Bail out quickly or stick to it!</p>
<p class="callout">Escaping one loop iteration using <strong class="source-inline">continue</strong>, an entire loop using <strong class="source-inline">break</strong>, or a function using <strong class="source-inline">return</strong> before it’s over is a valid technique to interrupt a procedure as soon as its conditions are not met. It avoids nesting too many <strong class="source-inline">if</strong> statements, but it is recommended to do that only at the beginning of an execution: having exit points at seemingly random points in the code makes it hard <span class="No-Break">to read.</span></p>
<p><strong class="source-inline">os.listdir</strong> lists <a id="_idIndexMarker397"/>only the filenames and not their full disk paths. To get it, we must join <strong class="source-inline">picture_path</strong> and <strong class="source-inline">img_file</strong> together, using <strong class="source-inline">os.path.join</strong> again. We use <strong class="source-inline">img_nam</strong>e – that is, the filename without an extension – as the keyword for retrieving the icon from <span class="No-Break">the collection:</span></p>
<pre class="source-code">
        <strong class="source-inline">disk_path</strong> = os.path.<strong class="source-inline">join</strong>(picture_path, <strong class="source-inline">img_file</strong>)
        collection.<strong class="source-inline">load(img_name, disk_path, 'IMAGE')</strong></pre>
<p>Once the <strong class="source-inline">for</strong> loop is over, we can store the collection in the <span class="No-Break"><strong class="source-inline">_CUSTOM_ICONS</strong></span><span class="No-Break"> list:</span></p>
<pre class="source-code">
    _CUSTOM_ICONS = collection</pre>
<p>Using filenames as keywords is convenient as, for instance, <strong class="source-inline">'smile_64'</strong> will be the keyword for the <strong class="source-inline">smile_64.png</strong> file, but it can be ambiguous when our folder contains files with the same name but different extensions, such as <strong class="source-inline">smile_64.jpg</strong>. Our script will assume that the picture folder doesn’t contain pictures with the <span class="No-Break">same filenames.</span></p>
<p>With that, we have created the <strong class="source-inline">register_icons()</strong> function, which initializes the icon <a id="_idIndexMarker398"/>collection. Now, we need to add a function to clean it up when the add-on is disabled; otherwise, the leftover thumbnails in our computer’s RAM will interfere with <span class="No-Break">subsequent executions.</span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor140"/>Unregistering icons</h2>
<p>When the <a id="_idIndexMarker399"/>add-on is disabled, we must discharge its icons from our <span class="No-Break">computer’s memory.</span></p>
<p>To do that, we must define the <strong class="source-inline">unregister_icons</strong> function. In this function, we invoke <strong class="source-inline">previews.remove()</strong> and use <strong class="source-inline">_CUSTOM_ICONS</strong> as its argument. We also need to make sure that <strong class="source-inline">_CUSTOM_ICONS</strong> is set to <strong class="source-inline">None</strong> at the end of the function; otherwise, Python will keep invalid references to deleted icons and cause Blender <span class="No-Break">to crash:</span></p>
<pre class="source-code">
def unregister_icons():
    global _CUSTOM_ICONS
    if _CUSTOM_ICONS:
        <strong class="source-inline">previews.remove</strong>(_CUSTOM_ICONS)
    <strong class="source-inline">_CUSTOM_ICONS = None</strong></pre>
<p>Now that <strong class="source-inline">img_loader</strong> can load and unload icons, what we need is a getter to access <strong class="source-inline">_CUSTOM_ICONS</strong> from the <span class="No-Break">other modules.</span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor141"/>Getting the collection</h2>
<p>Python <a id="_idIndexMarker400"/>doesn’t forbid access to module members, even if we mark them as <em class="italic">private</em> using a name with leading underscores. So, we could access the <strong class="source-inline">_CUSTOM_ICONS</strong> variable by typing <span class="No-Break">the following:</span></p>
<pre class="source-code">
&gt;&gt;&gt;<a id="_idTextAnchor142"/> img_loader<strong class="source-inline">._CUSTOM_ICONS</strong></pre>
<p>Still, we can add more control if we use a function to get the <span class="No-Break">loaded icons:</span></p>
<ul>
<li>In the future, we can change <strong class="source-inline">_CUSTOM_ICONS</strong> to a dictionary or list. That would have no repercussions for other modules using the data if the function used to get them is <span class="No-Break">changed accordingly.</span></li>
<li>It makes it easy to check that the conditions are met. In this case, our call to <strong class="source-inline">register_icons()</strong> makes sure that the icons are registered in case they weren’t for some reason. This practice adheres to <strong class="bold">defensive programming</strong>, as it aims to <a id="_idIndexMarker401"/>make the script work even against <span class="No-Break">unforeseen circumstances.</span></li>
<li>It allows us to set <em class="italic">roadblocks</em> in case some vital condition was not met. For instance, we <a id="_idIndexMarker402"/>have added an <strong class="source-inline">assert _CUSTOM_ICONS</strong> statement that will cause an error if the variable has not <a id="_idIndexMarker403"/>been set, despite the recent call to <strong class="source-inline">register_icons()</strong>. This is an example of <strong class="bold">offensive programming</strong> because it stops the execution when something <span class="No-Break">is wrong:</span></li>
</ul>
<pre class="source-code">
def get_icons_collection():
    """Get icons loaded from folder"""
    <strong class="source-inline">register_icons()</strong>  # load icons from disk
    <strong class="source-inline">assert</strong> _CUSTOM_ICONS  # if None something is wrong
    return _CUSTOM_ICONS</pre>
<p>Now, the picture loader provides a code interface for loading, unloading, and getting all the icons from the pictures folder. The main module can import it via <span class="No-Break">relative import.</span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor143"/>Using relative imports</h2>
<p>The <strong class="source-inline">import</strong> statement <a id="_idIndexMarker404"/>looks for modules installed in the Python search path, such as the built-in library or, in our case, the Blender API (<strong class="source-inline">bpy</strong>). Trying to import a module that is not in the search path halts the script with <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">ModuleNotFoundError</strong></span><span class="No-Break">.</span></p>
<p>For modules that belong to the same package, we use a slightly different syntax that gives access to the other modules of the same package: a <strong class="bold">relative</strong> <span class="No-Break">import statement.</span></p>
<p>In relative imports, the package is represented with a dot (<strong class="source-inline">.</strong>), and modules are imported using the <strong class="source-inline">from . import </strong><span class="No-Break"><strong class="source-inline">module</strong></span><span class="No-Break"> syntax.</span></p>
<p>So, in the import section of our <strong class="source-inline">__init__.py</strong> file, add <span class="No-Break">the following:</span></p>
<pre class="source-code">
from <strong class="source-inline">.</strong> import <strong class="source-inline">img_loader</strong></pre>
<p>The register and unregister functions will invoke the <strong class="source-inline">register_icons()</strong> and <strong class="source-inline">unregister_icons()</strong> functions contained in the <strong class="source-inline">img_loader</strong> <span class="No-Break">namespace, respectively:</span></p>
<pre class="source-code">
def register():
    img_loader.register_icons()
def unregister():
    img_loader.unregister_icons()</pre>
<p>Now that the <a id="_idIndexMarker405"/>entire process of loading images is handled in one module, we can write the <strong class="source-inline">.py</strong> file of the <span class="No-Break"><em class="italic">user interface</em></span><span class="No-Break">.</span></p>
<p>In the next section, we will see how, once we gain access to our icons system via a relative import of <strong class="source-inline">img_loader</strong>, we won’t have to worry about loading icon <span class="No-Break">files anymore.</span></p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor144"/>Adding a user interface</h1>
<p>We have already <a id="_idIndexMarker406"/>created the <strong class="source-inline">panel.py</strong> module, which will contain all the <em class="italic">user interface</em> classes and functions, so this file is going to contain our <span class="No-Break">panel class.</span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor145"/>Writing the UI module</h2>
<p>We will start importing the <strong class="source-inline">bpy</strong> module <a id="_idIndexMarker407"/>and our collection of icons via a relative import <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">img_loader</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
import bpy
from . import <strong class="source-inline">img_loader</strong></pre>
<p>The <strong class="source-inline">OBJECT_PT_structured</strong> class is derived from <strong class="source-inline">Panel</strong>. Like the one from <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, it contains the <strong class="source-inline">bl_*</strong> identifiers required by Blender in its <span class="No-Break">static section:</span></p>
<pre class="source-code">
class OBJECT_PT_structured(bpy.types.Panel):
    """Creates a Panel in the object context"""
    bl_label = "A Modular Panel"
    bl_idname = "MODULAR_PT_layout"
    bl_space_type = <strong class="source-inline">'PROPERTIES'</strong>
    bl_region_type = <strong class="source-inline">'WINDOW'</strong>
    bl_context = <strong class="source-inline">'object'</strong></pre>
<p>For now, our <strong class="source-inline">draw</strong> function is a few lines of code that display an icon, followed <span class="No-Break">by text:</span></p>
<pre class="source-code">
    def <strong class="source-inline">draw</strong>(self, context):
        layout = self.layout
        <strong class="source-inline">icons</strong> = img_loader.get_icons_collection()
        layout.label(text="A Custom Icon",
                     icon_value=icons['pack_64'].icon_id)</pre>
<p>Next, we must write the functions for registering and unregistering the class from <span class="No-Break">this module:</span></p>
<pre class="source-code">
def <strong class="source-inline">register_classes</strong>():
    bpy.utils.register_class(OBJECT_PT_structured)
def <strong class="source-inline">unregister_classes</strong>():
    bpy.utils.unregister_class(OBJECT_PT_structured)</pre>
<p>Providing registration <a id="_idIndexMarker408"/>utilities inside the module relieves <strong class="source-inline">__init__.py</strong> from concerns about which classes are defined in <strong class="source-inline">panel</strong> and which ones should be registered/unregistered. It is like what we did in <em class="italic">Getting the collection</em> in section 2 of this chapter, <em class="italic">Packing </em><span class="No-Break"><em class="italic">external images</em></span><span class="No-Break">.</span></p>
<p>These designs fall under the practice of <strong class="bold">encapsulation</strong> – that is, restricting direct access to the components of a module or object. Adhering to it is not inherently better, but it can help in keeping the code flexible <span class="No-Break">and clean.</span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor146"/>Importing the UI</h2>
<p>Inside <strong class="source-inline">__init__.py</strong>, we <a id="_idIndexMarker409"/>import <strong class="source-inline">panel</strong> from the <strong class="source-inline">.</strong> namespace, and invoke its <strong class="source-inline">register_classes()</strong> and <span class="No-Break"><strong class="source-inline">unregister_classes()</strong></span><span class="No-Break"> functions:</span></p>
<pre class="source-code">
from . import img_loader
from . import <strong class="source-inline">panel</strong>
def register():
    img_loader.register_icons()
    <strong class="source-inline">panel.register_classes</strong>()
def unregister():
    <strong class="source-inline">panel.unregister_classes</strong>()
    img_loader.unregister_icons()</pre>
<p>In this example, the <strong class="source-inline">unregister</strong> order is the reverse of the one in the <strong class="source-inline">register</strong> function. That is not relevant to the execution of the add-on, and it is followed here only for the sake <span class="No-Break">of clarity.</span></p>
<p>We can test our code by enabling <strong class="bold">Structured Panel</strong> in the <strong class="bold">Add-ons</strong> list from the <strong class="bold">Edit</strong> | <span class="No-Break"><strong class="bold">Preferences</strong></span><span class="No-Break"> menu.</span></p>
<p>We can see the <a id="_idIndexMarker410"/>panel and our new icon in the <span class="No-Break">object section:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer125">
<img alt="Figure 6.6: panel.py displays an icon via img_loader.py" height="94" src="image/Figure_6.06_B18375.jpg" width="272"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6: panel.py displays an icon via img_loader.py</p>
<p>Now, we will add other elements and complete <span class="No-Break">the panel.</span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor147"/>Completing the Objects panel</h2>
<p>A slightly simpler <a id="_idIndexMarker411"/>version of the panel displayed in <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, uses pretty much the same code. The <a id="_idIndexMarker412"/>maximum number of displayed objects is still stored in the <strong class="source-inline">max_objects</strong> static member, but it would work better if implemented as a preference of the add-on. We will do that in the <em class="italic">Using addon preferences</em> section, a few pages ahead in <span class="No-Break">this chapter:</span></p>
<pre class="source-code">
class OBJECT_PT_structured(bpy.types.Panel):
    """Creates a Panel in the object context"""
    bl_label = "A Modular Panel"
    bl_idname = "MODULAR_PT_layout"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = 'object'
    <strong class="source-inline">max_objects = 3</strong>  # limit displayed list to 3 objects</pre>
<p>The <strong class="source-inline">draw</strong> function displays a list of the <span class="No-Break">scene objects:</span></p>
<pre class="source-code">
    def draw(self, context):
        layout = self.layout
        icons = img_loader.get_icons_collection()
        row = layout.row(align=True)
        row.label(text="Scene Objects",
                  icon_value=icons['pack_64'].icon_id)
        row.label(text=" ",
                  icon_value=icons["smile_64"].icon_id)
        grid = layout.grid_flow(columns=2,
                                row_major=True)
        for i, ob in enumerate(context.scene.objects):
            if i &gt; self.max_objects:
                grid.label(text="...")
                break
            # display object name and type icon
            grid.label(text=ob.name,
                       icon=f'OUTLINER_OB_{ob.type}')</pre>
<p>This time, reloading <a id="_idIndexMarker413"/>the scripts does not reflect the changes in <a id="_idIndexMarker414"/>the preceding code: only the <strong class="source-inline">__init__.py</strong> file is refreshed on reload. We are going to cover explicitly reloading internal modules in the <span class="No-Break">next section.</span></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor148"/>Reloading cached modules</h1>
<p>When a module is <a id="_idIndexMarker415"/>imported, Python caches a copy of it for future access. Since the <strong class="source-inline">__init__.py</strong> file is the only one to be updated by the <strong class="bold">Reload Scripts</strong> operator, we are left with <span class="No-Break">two options:</span></p>
<ul>
<li>Close and <span class="No-Break">restart Blender</span></li>
<li>Explicitly call the <strong class="source-inline">reload</strong> function <span class="No-Break">inside </span><span class="No-Break"><strong class="source-inline">__init__.py</strong></span></li>
</ul>
<p>The latter is preferred over restarting the application as it takes less time. The <strong class="source-inline">reload</strong> function is part of the <span class="No-Break"><strong class="source-inline">importlib</strong></span><span class="No-Break"> module.</span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor149"/>Reloading via importlib</h2>
<p>The utilities contained <a id="_idIndexMarker416"/>in the <strong class="source-inline">importlib</strong> library interact <a id="_idIndexMarker417"/>with the import system, and the <strong class="source-inline">reload</strong> function forces the Python interpreter to reload a module <span class="No-Break">from disk.</span></p>
<p>If the <strong class="source-inline">img_loader</strong> module has changed and needs to be reloaded, we can use the <span class="No-Break">following command:</span></p>
<pre class="source-code">
from importlib import <strong class="source-inline">reload</strong>
<strong class="source-inline">reload(img_loader)</strong></pre>
<p>So, to make sure that the changes to our add-on <strong class="source-inline">.py</strong> files are always applied, we can add these lines of code <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">_init_.py</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
from . import img_loader
from . import panel
from importlib import reload
reload(img_loader)
reload(panel)</pre>
<p>Reloading every <a id="_idIndexMarker418"/>relative module soon after it is imported <a id="_idIndexMarker419"/>will work, but leaving <strong class="source-inline">reload</strong> statements in published code impacts performance and is considered bad practice. Next, we will learn how to refresh inside a specific module of <span class="No-Break">the add-on.</span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor150"/>Implementing a refresh module</h2>
<p>Calling <strong class="source-inline">reload</strong> increases the <a id="_idIndexMarker420"/>loading time of <a id="_idIndexMarker421"/>an add-on and makes the code less readable. Many developers add reload calls while they work and remove them when they are finished. However, using packages, we can move the refresh logic to <span class="No-Break">another module.</span></p>
<p>To do that, we need to create a file in our add-on package and name it <strong class="source-inline">_refresh_.py</strong>. This module doesn’t contain any add-on functionality, but it helps while we edit our code by ensuring that all modules are reloaded from disk and are up <span class="No-Break">to date.</span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor151"/>Reloading the package modules</h2>
<p>The refresh module <a id="_idIndexMarker422"/>makes use of the <a id="_idIndexMarker423"/><span class="No-Break">following elements:</span></p>
<ul>
<li>The <strong class="source-inline">reload</strong> function from the <span class="No-Break"><strong class="source-inline">importlib</strong></span><span class="No-Break"> module</span></li>
<li>The <strong class="source-inline">sys</strong> module, which is used by <strong class="source-inline">_refresh_</strong> to reload an instance <span class="No-Break">of itself</span></li>
<li>The <strong class="source-inline">bpy</strong> module, to access <span class="No-Break">Blender preferences</span></li>
<li>All the modules contained in <span class="No-Break">the add-on</span></li>
</ul>
<p>Those requirements translate into the following <span class="No-Break"><strong class="source-inline">import</strong></span><span class="No-Break"> statements:</span></p>
<pre class="source-code">
from importlib import reload
import sys
import bpy
<strong class="source-inline">from . import *</strong></pre>
<p>The wildcard character, <strong class="source-inline">*</strong>, stands for all the modules contained in the current package (<strong class="source-inline">.</strong>). Now, we can <a id="_idIndexMarker424"/>write a function that reloads the add-on <a id="_idIndexMarker425"/>modules if Blender is set for development. We encountered the <strong class="bold">Developer Extras</strong> setting in the <em class="italic">Useful features for Python</em> section, at the beginning of <a href="B18375_02.xhtml#_idTextAnchor033"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>. They can be found by going to <strong class="bold">Edit</strong> | <strong class="bold">Preferences</strong> from the top menu bar in the <strong class="bold">Interface</strong> tab of the <span class="No-Break"><strong class="bold">Preferences</strong></span><span class="No-Break"> window:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer126">
<img alt="Figure 6.7: Enabling Developer Extras in the Preferences window" height="287" src="image/Figure_6.07_B18375.jpg" width="990"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7: Enabling Developer Extras in the Preferences window</p>
<p>We can assume that when <strong class="bold">Developer Extras</strong> is on, we want the <strong class="bold">Reload Scripts</strong> operator to reload our submodules <span class="No-Break">as well.</span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor152"/>Using Developer Extras as a condition</h2>
<p>We need to <a id="_idIndexMarker426"/>find the full Python <a id="_idIndexMarker427"/>path of <strong class="bold">Developer Extras</strong> to read its value. To do that, follow <span class="No-Break">these steps:</span></p>
<ol>
<li>Make sure that <strong class="bold">Developer Extras</strong> <span class="No-Break">is enabled.</span></li>
<li>Also, make sure that <strong class="bold">User Tooltips</strong> and <strong class="bold">Python Tooltips</strong> <span class="No-Break">are enabled.</span></li>
<li>Hover your mouse pointer over the <strong class="bold">Developer Extras</strong> checkbox <span class="No-Break">or label.</span></li>
<li>Leaving your mouse still, without clicking or moving it, displays <span class="No-Break">a tooltip:</span></li>
</ol>
<pre class="source-code">
Show options for developers (edit source in context …
Python: <strong class="source-inline">PreferencesView.show_developer_ui</strong></pre>
<p>According to the API reference, <strong class="source-inline">PreferencesView</strong> is the <strong class="source-inline">view</strong> member of the <strong class="source-inline">Preferences</strong> class, which can be found <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">bpy.context.preferences</strong></span><span class="No-Break">:</span></p>
<p><a href="https://docs.blender.org/api/3.3/bpy.types.Preferences.xhtml"><span class="No-Break">https://docs.blender.org/api/3.3/bpy.types.Preferences.xhtml</span></a></p>
<p>#<span class="No-Break">bpy.types.Preferences.view</span></p>
<p>So, the full path of the <strong class="bold">Developer Extras</strong> setting is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
bpy.context.preferences.view.show_developer_ui</pre>
<p>The value of <strong class="source-inline">show_developer_ui</strong> is either <strong class="source-inline">True</strong> or <strong class="source-inline">False</strong>. Using it as a condition, we exit <strong class="source-inline">reload_modules</strong> if <strong class="bold">Developer Extras</strong> <span class="No-Break">is disabled:</span></p>
<pre class="source-code">
def reload_modules():
    if <strong class="source-inline">not</strong> bpy.context.preferences.view.<strong class="source-inline">show_developer_ui</strong>:
        return</pre>
<p>Then, we add a <strong class="source-inline">reload</strong> call <a id="_idIndexMarker428"/>for each <strong class="source-inline">.py</strong> file that we <a id="_idIndexMarker429"/>want to refresh. The first line reloads <strong class="source-inline">_refresh_.py</strong>, looking up the current filename in the system dictionary, <strong class="source-inline">sys.modules</strong>. This way, we can update changes in the <strong class="source-inline">_refresh_</strong> module itself. So, the full body of the <strong class="source-inline">reload_modules</strong> function looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
def reload_modules():
    if not bpy.context.preferences.view.show_developer_ui:
        return
    reload(sys.modules[<strong class="source-inline">__name__</strong>])
    reload(img_loader)
    reload(panel)</pre>
<p>Now, enabling <strong class="bold">Developer Extras</strong> in the preferences ensures the structured add-on modules <a id="_idIndexMarker430"/>are constantly updated. To <a id="_idIndexMarker431"/>make the reload happen, we need to call this function in <strong class="source-inline">__init__.py</strong>, as that is the only file to be executed when scripts are reloaded. We must invoke <strong class="source-inline">_refresh_.reload_modules()</strong> in the <span class="No-Break">import section:</span></p>
<pre class="source-code">
from . import img_loader
from . import panel
from . import _refresh_
_refresh_.<strong class="source-inline">reload_modules()</strong></pre>
<p>Calling <strong class="bold">Reload Scripts</strong> will now reflect the changes <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">OBJECT_PT_structured</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer127">
<img alt="Figure 6.8: Our panel source code has been reloaded" height="152" src="image/Figure_6.08_B18375.jpg" width="269"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8: Our panel source code has been reloaded</p>
<p>The limitation of three objects can be set in the <strong class="source-inline">max_objects = 3</strong> static member. However, there is a better place for hosting our add-on setting. In the next section, we are going to implement proper preferences for <span class="No-Break">our add-on.</span></p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor153"/>Using add-on preferences</h1>
<p>Besides using Blender <a id="_idIndexMarker432"/>preferences, we can use <strong class="source-inline">bpy.types.AddonPreferences</strong> to display the add-on-specific custom settings under the add-on activation checkbox. It’s an interface, just like <strong class="source-inline">bpy.types.Panel</strong>, and we can add settings to its layout using its <span class="No-Break"><strong class="source-inline">draw</strong></span><span class="No-Break"> method.</span></p>
<p>The <strong class="source-inline">bl_idname</strong> attribute of <strong class="source-inline">AddonPreferences</strong> must match the Python name of the add-on. The usage of <strong class="source-inline">__name__</strong> for single files and <strong class="source-inline">__package__</strong> for folders makes our code easier to maintain: these variables always match the respective Python names, so changes in files and folders’ names would have <span class="No-Break">no consequences.</span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor154"/>Creating preferences</h2>
<p>Since we are using multiple files, we <a id="_idIndexMarker433"/>will create <strong class="source-inline">preferences.py</strong> inside the folder of our <strong class="source-inline">structured_addon</strong>. It contains the <span class="No-Break"><strong class="source-inline">StructuredPreferences</strong></span><span class="No-Break"> class:</span></p>
<pre class="source-code">
import bpy
class StructuredPreferences(<strong class="source-inline">bpy.types.AddonPreferences</strong>):
    bl_idname = <strong class="source-inline">__package__</strong>
    def draw(self, context):
        layout = self.layout
        layout.label(text="Structured Add-On Preferences")</pre>
<p>Then, we must add a <strong class="source-inline">register_classes</strong> and an <span class="No-Break"><strong class="source-inline">unregister_classes</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
def register_classes():
    bpy.utils.register_class(StructuredPreferences)
def unregister_classes():
    bpy.utils.unregister_class(StructuredPreferences)</pre>
<p>We can add <strong class="source-inline">preferences</strong> to the <strong class="source-inline">import</strong> section of <strong class="source-inline">__init__.py</strong>, which looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
from . import panel
from . import img_loader
from . import <strong class="source-inline">preferences</strong>
from . import _refresh_
_refresh_.reload_modules()</pre>
<p>Then, we must <a id="_idIndexMarker434"/>register the class from the preferences module alongside <span class="No-Break">the others:</span></p>
<pre class="source-code">
def register():
    img_loader.register_icons()
    <strong class="source-inline">preferences.register_classes</strong>()
    panel.register_classes()
def unregister():
    panel.unregister_classes()
    <strong class="source-inline">preferences.unregister_classes()</strong>
    img_loader.unregister_icons()</pre>
<p>We must also make sure that the preferences will be reloaded in <strong class="source-inline">_refresh_.py</strong>. This is what the <strong class="source-inline">_reload_modules</strong> function will <span class="No-Break">look like:</span></p>
<pre class="source-code">
def _reload_modules():
    reload(sys.modules[__name__])
    reload(img_loader)
    <strong class="source-inline">reload(preferences)</strong>
    reload(panel)</pre>
<p>If we use <strong class="bold">Reload Scripts</strong> now, we <a id="_idIndexMarker435"/>will see our preferences beneath the <strong class="bold">Add-on</strong> checkbox, in the <span class="No-Break"><strong class="bold">Add-Ons</strong></span><span class="No-Break"> list:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer128">
<img alt="Figure 6.9: Add-ons settings displayed in the Preferences window" height="429" src="image/Figure_6.09_B18375.jpg" width="936"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9: Add-ons settings displayed in the Preferences window</p>
<p>The preferences show up but are still empty. Next, we are going to add <span class="No-Break">some values.</span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor155"/>Populating the preferences</h2>
<p>We want <a id="_idIndexMarker436"/>to replace <strong class="source-inline">OBJECT_PT_structured .max_objects</strong> with a setting. It’s an integer number, so we will add an <strong class="source-inline">IntProperty</strong> to the <span class="No-Break"><strong class="source-inline">StructuredPreferences</strong></span><span class="No-Break"> class:</span></p>
<pre class="source-code">
import bpy
from bpy.props <strong class="source-inline">import IntProperty</strong>
class StructuredPreferences(bpy.types.AddonPreferences):
    bl_idname = __package__
    <strong class="source-inline">max_objects</strong>: IntProperty(
        name="Maximum number of displayed objects",
        default=3
    )</pre>
<p>Now that it contains an integer property, <strong class="source-inline">StructuredPreferences</strong> can store the maximum displayed objects setting. To display this property to the user, we will add it to the layout in the <strong class="source-inline">draw</strong> method. A simple <strong class="source-inline">layout.prop</strong> instruction will <span class="No-Break">be enough:</span></p>
<pre class="source-code">
self.layout.prop(self, max_objects)</pre>
<p>But we can also use <strong class="source-inline">split</strong> for a nicer appearance. A split layout creates a column for each new <a id="_idIndexMarker437"/>entry. Adding an empty widget, a <strong class="source-inline">separator</strong>, as the first element, creates <span class="No-Break">an indentation:</span></p>
<pre class="source-code">
    def draw(self, context):
        layout = self.layout
        split = layout.split(factor=0.5)
        split.separator()
        split.label(text="Max Objects")
        split.prop(self, 'max_objects', text="")</pre>
<p>Reloading the script will display <strong class="bold">Max Objects</strong> as an <span class="No-Break">editable setting:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer129">
<img alt="Figure 6.10: Max Objects as a Preferences setting" height="470" src="image/Figure_6.10_B18375.jpg" width="990"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10: Max Objects as a Preferences setting</p>
<p>This value is saved along with the other user preferences, and Blender remembers its value when the application is restarted. We aren’t using this setting yet: we need to adjust the code in our panel so that we can <span class="No-Break">use it.</span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor156"/>Using add-on preferences in code</h2>
<p>Python scripts can <a id="_idIndexMarker438"/>access the preferences of an add-on using one line <span class="No-Break">of code:</span></p>
<pre class="source-code">
bpy.context.preferences.addons[ADDON_NAME].<strong class="source-inline">preferences</strong></pre>
<p>Notice how <strong class="source-inline">preferences</strong> is repeated at the end. It might seem redundant but it makes sense since <strong class="source-inline">bpy.context.preferences.addons</strong> refers to the application preferences, not the ones of the <span class="No-Break">single add-on.</span></p>
<p><strong class="source-inline">bpy.context.preferences.addons[ADDON_NAME]</strong> returns the add-on as a <span class="No-Break">Python object.</span></p>
<p>With that in mind, we will go back to the <strong class="source-inline">OBJECT_PT_structured</strong> class in the <em class="italic">user interface’s</em> <strong class="source-inline">panel.py</strong> module. Since we are going to use the value from the preferences, it should not have a <strong class="source-inline">max_objects</strong> static <span class="No-Break">member anymore:</span></p>
<pre class="source-code">
class OBJECT_PT_structured(bpy.types.Panel):
    """Creates a Panel in the object context"""
    bl_label = "A Modular Panel"
    bl_idname = "MODULAR_PT_layout"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = 'object'</pre>
<p>Now, before we iterate the scene objects in the <strong class="source-inline">draw</strong> function, we must get our <strong class="source-inline">add_on</strong> and <strong class="source-inline">preferences</strong> from the context. Using <strong class="source-inline">enumerate</strong>, so that we can keep count of the objects while they are displayed, we stop the loop when the amount stored in <strong class="source-inline">preferences.max_objects</strong> <span class="No-Break">is reached:</span></p>
<pre class="source-code">
    <strong class="source-inline">add_on</strong> = context.preferences.addons[__package__]
    <strong class="source-inline">preferences</strong> = add_on.preferences
    for i, ob in enumerate(context.scene.objects):
        if i <strong class="source-inline">&gt;=</strong> <strong class="source-inline">preferences</strong>.<strong class="source-inline">max_objects</strong>:
            grid.label(text="...")
            <strong class="source-inline">break</strong></pre>
<p>This time, we check <strong class="source-inline">max_objects</strong> with a greater or equal (<strong class="source-inline">&gt;=</strong>) comparison because, since the enumeration starts from <strong class="source-inline">0</strong>, breaking after <strong class="source-inline">i &gt; max_objects</strong> would display one <span class="No-Break">more object.</span></p>
<p>Just to be clear, using a separate module for the add-on preferences is not required – the entirety of the code <a id="_idIndexMarker439"/>written in this chapter could have been contained in a single, large <strong class="source-inline">.py</strong> file: we are just splitting the code for the sake <span class="No-Break">of readability.</span></p>
<p>If our add-on contains operators, we can create modules for those <span class="No-Break">as well.</span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor157"/>Adding operators</h1>
<p>Operators can be <a id="_idIndexMarker440"/>grouped into different files according to their purpose. For example, transform-related operators such as <strong class="bold">Elevate Objects</strong>, which we covered in <a href="B18375_04.xhtml#_idTextAnchor075"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, can be put into a file named <strong class="source-inline">ops_transform.py</strong>, while our first few operators, <strong class="bold">Create Type Collections</strong>, written in <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, can be put in an <strong class="source-inline">ops_collections.py</strong> file. All those classes would be then registered by <strong class="source-inline">__init__.py</strong> and, if needed, added to the add-on interface via <span class="No-Break">relative import.</span></p>
<p>Another solution is creating one module for all the operators, which can be named <strong class="source-inline">operators.py</strong>. In this section, we will create an operators module for <span class="No-Break">our add-on.</span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor158"/>Writing the operators module</h2>
<p>In the <strong class="source-inline">structured _addon</strong> folder, we will create the <strong class="source-inline">operators.py</strong> module. It will contain our <a id="_idIndexMarker441"/>operator class: we will reuse the <strong class="bold">Add Random Location</strong> operator from <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>. Besides <strong class="source-inline">bpy</strong>, which is ubiquitous in Blender script, we will import the <strong class="source-inline">random</strong> module and use <strong class="source-inline">randint</strong> in the <span class="No-Break"><strong class="source-inline">add_random_location</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
import bpy
import random
def add_random_location(objects, amount=1,
                        do_axis=(True, True, True)):
    """Add units to the locations of given objects"""
    for ob in objects:
        for i in range(3):
            if do_axis[i]:
                loc = ob.location
                loc[i] += random.randint(-amount, amount)</pre>
<p>Now, we can proceed with the add-on class. It’s the same as in the <em class="italic">Displaying buttons</em> section in the <a id="_idIndexMarker442"/>previous chapter – <strong class="source-inline">poll</strong> returns <strong class="source-inline">True</strong> if there are selected objects, while <strong class="source-inline">execute</strong> runs <strong class="source-inline">add_random_location</strong>, with the operator’s amount and axis <span class="No-Break">as arguments:</span></p>
<pre class="source-code">
class TRANSFORM_OT_random_location(bpy.types.Operator):
    """Add units to the locations of selected objects"""
    bl_idname = "transform.add_random_location"
    bl_label = "Add random Location"
    amount: bpy.props.IntProperty(name="Amount",
                                  default=1)
    axis: bpy.props.BoolVectorProperty(
                               name="Displace Axis",
                               default=(True, True, True)
                               )
@classmethod
    def poll(cls, context):
        return context.selected_objects
    def execute(self, context):
        add_random_location(context.selected_objects,
                            self.amount,
                            self.axis)
        return {'FINISHED'}</pre>
<p>Like in the <a id="_idIndexMarker443"/>case of <strong class="source-inline">panel.py</strong>, we must add functions for registering the <span class="No-Break">module’s classes:</span></p>
<pre class="source-code">
def register_classes():
    bpy.utils.register_class(TRANSFORM_OT_random_location)
def unregister_classes():
    bpy.utils.unregister_class(
                              TRANSFORM_OT_random_location
                              )</pre>
<p>Now, we can import <strong class="source-inline">operators.py</strong> into the other modules of <span class="No-Break">the script.</span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor159"/>Registering operator classes</h2>
<p>To use our <a id="_idIndexMarker444"/>operator, we must import <strong class="source-inline">operators.py</strong> in <strong class="source-inline">__init__.py</strong>, whose <strong class="source-inline">import</strong> section will look <span class="No-Break">like this:</span></p>
<pre class="source-code">
from . import <strong class="source-inline">operators</strong>
from . import img_load
from . import panel
from . import preferences
from . import _refresh_</pre>
<p>Of course, we can add and remove our operators with <strong class="source-inline">operator.register_class</strong> and <strong class="source-inline">operator.unregister_class</strong>. Since operators might be used as buttons, we call <strong class="source-inline">operators.register_classes</strong> <span class="No-Break">before </span><span class="No-Break"><strong class="source-inline">panel.register_classes</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
def register():
    preferences.unregister_classes()
    <strong class="source-inline">operators.register_classes()</strong>
    img_load.register_icons()
    panel.register_classes()
def unregister():
    panel.unregister_classes()
    img_load.unregister_icons()
    <strong class="source-inline">operators.register_classes()</strong>
    preferences.unregister_classes()</pre>
<p>This will <a id="_idIndexMarker445"/>make <strong class="bold">Add Random Location</strong> available to Blender. However, if we want changes in <strong class="source-inline">operators.py</strong> to be effective when we reload the script, we must add <strong class="source-inline">operators</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">_refresh_.reload_modules</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor160"/>Refreshing operators on reload</h2>
<p>Thanks to the <a id="_idIndexMarker446"/>work we did in the <em class="italic">Reloading cached modules</em> section, adding operators to the refreshed modules is easy: we add <strong class="source-inline">reload(operators)</strong> to the <strong class="source-inline">reload_modules</strong> function. The whole <strong class="source-inline">_refresh_.py</strong> file now looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
import sys
from importlib import reload
import bpy
from . import *
def reload_modules():
    if not bpy.context.preferences.view.show_developer_ui:
        return
    reload(sys.modules[__name__])
    reload(img_load)
    reload(preferences)
    <strong class="source-inline">reload(operators)</strong>
    reload(panel)</pre>
<p>The only thing left <a id="_idIndexMarker447"/>to do is display the operator button in <span class="No-Break">the panel.</span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor161"/>Adding operator buttons</h2>
<p>To add the <strong class="bold">Add Random Location</strong> button to the interface, we need to import our operators in <strong class="source-inline">panel.py</strong>, whose <a id="_idIndexMarker448"/>import section will look <span class="No-Break">as follows:</span></p>
<pre class="source-code">
import bpy
from . import img_loader
from . import operators</pre>
<p>Now, our panel can access the <strong class="source-inline">TRANSFORM_OT_random_location</strong> class using <strong class="source-inline">operators</strong> as a namespace, so we will add a new element to the <span class="No-Break"><strong class="source-inline">draw</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
    layout.operator(
          <strong class="source-inline">operators.TRANSFORM_OT_random_location.bl_idname</strong>
          )</pre>
<p>Upon displaying the <strong class="source-inline">F3</strong> <strong class="bold">Search Bar</strong> area to look up and run <strong class="bold">Reload Scripts</strong>, our panel will display the <strong class="bold">Add random </strong><span class="No-Break"><strong class="bold">Location</strong></span><span class="No-Break"> button:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer130">
<img alt="Figure 6.11: Modular panel displaying operators via relative import" height="193" src="image/Figure_6.11_B18375.jpg" width="270"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11: Modular panel displaying operators via relative import</p>
<p>Our add-on is finished. However, we could refine <strong class="source-inline">panel.py</strong> and add the same functionalities that we wrote for <strong class="source-inline">VerySimplePanel</strong> in <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, namely <span class="No-Break">the following:</span></p>
<ul>
<li>Color-coded entries for <span class="No-Break">selected/active objects</span></li>
<li>A <strong class="bold">Delete</strong> button with a <span class="No-Break">context-sensitive label</span></li>
</ul>
<p>Implementing those is <a id="_idIndexMarker449"/>left as an exercise for you. In the next section, we will learn how to distribute our add-on folders to <span class="No-Break">other users.</span></p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor162"/>Packaging and installing add-ons</h1>
<p>We learned how to <a id="_idIndexMarker450"/>install single <strong class="source-inline">.py</strong> add-ons in the <em class="italic">Installing our add-ons</em> section of <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>. To distribute an add-on that consists <a id="_idIndexMarker451"/>of more files, we must create a <strong class="source-inline">.zip</strong> archive of it. Most of you will be familiar with how a <strong class="source-inline">.zip</strong> file is a compressed archive that can contain more files <span class="No-Break">or folders.</span></p>
<p>Blender can install folders from a standard <strong class="source-inline">.zip</strong> archive, but there are <span class="No-Break">two requirements:</span></p>
<ul>
<li>The <strong class="source-inline">.zip</strong> file must contain the add-on as a <span class="No-Break">first-level folder</span></li>
<li>The name of the first-level folder must not contain any dot (<strong class="source-inline">.</strong>) as it won’t work with Python’s <span class="No-Break">import system</span></li>
</ul>
<p>There are third-party tools, such as <strong class="bold">7-Zip</strong>, that provide a wide array of options, but it is possible to create <strong class="source-inline">.zip</strong> files using <a id="_idIndexMarker452"/>the file utilities of your operating system. In this section, we will learn how to compress an add-on folder on <strong class="bold">Windows</strong> <strong class="bold">OSX</strong>, and <span class="No-Break"><strong class="bold">Ubuntu</strong></span><span class="No-Break"> systems.</span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor163"/>Cleaning up bytecode</h2>
<p>If the <strong class="source-inline">structured_addon.zip\structured_addon</strong> folder contains a subfolder named <strong class="source-inline">__pycache__</strong>, make sure you <a id="_idIndexMarker453"/>delete it: you should not distribute the <strong class="source-inline">.pyc</strong> files <span class="No-Break">it contains.</span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor164"/>Creating a .zip file using 7-Zip</h2>
<p><strong class="bold">7-Zip</strong> is a free <a id="_idIndexMarker454"/>compression utility for Windows. It is very lightweight <a id="_idIndexMarker455"/>and integrates with the file manager. Here are the steps to use it for packaging <span class="No-Break">our add-ons:</span></p>
<ol>
<li>Download and install 7-Zip <span class="No-Break">from </span><a href="https://www.7-zip.org"><span class="No-Break">https://www.7-zip.org</span></a><span class="No-Break">.</span></li>
<li>Open <span class="No-Break"><strong class="bold">File Explorer</strong></span><span class="No-Break">.</span></li>
<li>Navigate to the directory containing the <span class="No-Break"><strong class="source-inline">structured_addon</strong></span><span class="No-Break"> folder.</span></li>
<li>Right-click on the <strong class="source-inline">structured_addon</strong> folder to show the <span class="No-Break">context menu.</span></li>
<li>Select <strong class="bold">7-Zip</strong> | <strong class="bold">Add </strong><span class="No-Break"><strong class="bold">to “structured_addon.zip”</strong></span><span class="No-Break">.</span></li>
</ol>
<p>The <strong class="source-inline">structured_addon.zip</strong> file will be created alongside the original folder. If for some reason it is not possible to install 7-Zip or any other compression tool, we can still create <strong class="source-inline">.zip</strong> files using Windows File <span class="No-Break">Explorer alone.</span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor165"/>Creating a .zip file using Windows File Manager</h2>
<ol>
<li>Open <span class="No-Break"><strong class="bold">File Explorer</strong></span><span class="No-Break">.</span></li>
<li>Navigate <a id="_idIndexMarker456"/>to a folder where we want <a id="_idIndexMarker457"/>to create <span class="No-Break">the add-on.</span></li>
<li>Display the context menu by right-clicking on <span class="No-Break">the background.</span></li>
<li>From the right-click menu, select <strong class="bold">New</strong> | <strong class="bold">Compressed (zipped) Folder</strong>. We will name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">structured_addon.zip</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer131">
<img alt="Figure 6.12: Creating empty .zip files using Windows File Explorer" height="334" src="image/Figure_6.12_B18375.jpg" width="527"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12: Creating empty .zip files using Windows File Explorer</p>
<p>So far, we have <a id="_idIndexMarker458"/>created a <strong class="source-inline">.zip</strong> file, but it is <a id="_idIndexMarker459"/>empty. Next, we will copy our add-on <span class="No-Break">files there:</span></p>
<ol>
<li>Copy the <strong class="source-inline">ch6\addons\structured_addon</strong> folder to the clipboard by using <em class="italic">Ctrl</em> + <em class="italic">C</em> or right-clicking and <span class="No-Break">selecting </span><span class="No-Break"><strong class="bold">Copy</strong></span><span class="No-Break">.</span></li>
<li>Double-click the <strong class="source-inline">structured_addon.zip</strong> archive to display <span class="No-Break">its content.</span></li>
<li>Paste the <strong class="source-inline">ch6\addons\structured_addon</strong> folder into the archive via <em class="italic">Ctrl</em> + <em class="italic">V</em> or right-clicking and <span class="No-Break">selecting </span><span class="No-Break"><strong class="bold">Paste</strong></span><span class="No-Break">.</span></li>
</ol>
<h2 id="_idParaDest-161"><a id="_idTextAnchor166"/>Creating a .zip file on Mac using Finder</h2>
<p>Follow <span class="No-Break">these steps:</span></p>
<ol>
<li>Right-click <a id="_idIndexMarker460"/>on the <strong class="source-inline">structure_addon</strong> folder <a id="_idIndexMarker461"/>in <strong class="bold">Finder</strong> or left-click <a id="_idIndexMarker462"/>without releasing the button. A menu <span class="No-Break">will appear.</span></li>
<li>Select <strong class="bold">Compress “structured_addon”</strong> from <span class="No-Break">the menu:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer132">
<img alt="Figure 6.13: Compressing folders on a Mac computer" height="301" src="image/Figure_6.13_B18375.jpg" width="1001"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13: Compressing folders on a Mac computer</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor167"/>Creating a .zip file using Gnome</h2>
<p><strong class="bold">Gnome</strong> is the <a id="_idIndexMarker463"/>default environment for <strong class="bold">Ubuntu</strong> and other <a id="_idIndexMarker464"/>popular <strong class="bold">Linux</strong> distributions. Here’s how to create a <strong class="source-inline">.zip</strong> file <span class="No-Break">using Gnome:</span></p>
<ol>
<li>Right-click on the <strong class="source-inline">structure_addon</strong> folder in the <span class="No-Break">File Browser.</span></li>
<li>Choose the <strong class="bold">Compress…</strong> option from <span class="No-Break">the menu.</span></li>
<li>Confirm the filename and <strong class="source-inline">.zip</strong> extension of <span class="No-Break">the archive.</span></li>
<li>Click the <span class="No-Break"><strong class="bold">Create</strong></span><span class="No-Break"> button.</span></li>
</ol>
<h2 id="_idParaDest-163"><a id="_idTextAnchor168"/>Installing .zip add-ons</h2>
<p>The steps for installing a <a id="_idIndexMarker465"/>compressed add-on are the same as those we learned about in the <em class="italic">Expanding Blender by creating a simple add-on</em> section of <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><span class="No-Break">:</span></p>
<ol>
<li>Open the <strong class="bold">Preferences</strong> window via <strong class="bold">Edit</strong> | <strong class="bold">Preferences</strong> from the <span class="No-Break">top menu.</span></li>
<li>Select the <strong class="bold">Add-ons</strong> tab in the <span class="No-Break">left column.</span></li>
<li>Click on the <strong class="bold">Install</strong> button at the top right of <span class="No-Break"><strong class="bold">Add-ons Preferences</strong></span><span class="No-Break">.</span></li>
<li>In the file browser, find the <span class="No-Break"><strong class="source-inline">structured_addon.zip</strong></span><span class="No-Break"> file.</span></li>
<li>Click <a id="_idIndexMarker466"/>the <strong class="bold">Install Add-on</strong> button at <span class="No-Break">the bottom.</span></li>
</ol>
<p>With that, we have gone through the complete development and release of our structured add-on. A modular approach is important in programming and works for relatively simple tools as well. Plus, it makes our scripts more manageable as they increase <span class="No-Break">in complexity.</span></p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor169"/>Summary</h1>
<p>In this chapter, we learned how to set up a modular architecture for our code by splitting it into different files while keeping it coherent and clear. We also learned how to load files procedurally and how to write settings for <span class="No-Break">our add-ons.</span></p>
<p>This approach confers interoperability and generical usefulness to our code and, by applying appropriate separation guidelines, eases our task in navigating the different parts of <span class="No-Break">our tools.</span></p>
<p>In <a href="B18375_07.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, we will learn how to animate with Python and change the animation settings with <span class="No-Break">our scripts.</span></p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor170"/>Questions</h1>
<ol>
<li>Can Blender add-ons consist of <span class="No-Break">multiple files?</span></li>
<li>Which file of an add-on folder contains the <span class="No-Break">info dictionary?</span></li>
<li>How does relative <span class="No-Break">import work?</span></li>
<li>Does reloading an add-on refresh all <span class="No-Break">its modules?</span></li>
<li>Where do we store the settings of <span class="No-Break">an add-on?</span></li>
<li>How do we show the add-on properties in <span class="No-Break">the preferences?</span></li>
<li>How do we distribute <span class="No-Break">multi-file add-ons?</span></li>
</ol>
</div>
</div></body></html>