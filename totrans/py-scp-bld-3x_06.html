<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-125"><a id="_idTextAnchor129"/>6</h1>
<h1 id="_idParaDest-126"><a id="_idTextAnchor130"/>Structuring Our Code and Add-Ons</h1>
<p>The add-ons we have created so far consist of single Python files. That’s ok, but to deal with complexity, we can split our code into related modules contained in the same directory.</p>
<p>Writing modules that interact with each other rather than a single huge file makes design and maintenance easier, allowing us to shift our focus to single aspects of our task.</p>
<p>The presence of non-code files, such as images and other media, can be another reason for adopting a folder structure. This is because sharing one folder is more practical than handling the Python script and the data separately.</p>
<p>In this chapter, you will learn how to code across separate modules of a package and blend everything using the import system. The packaged add-on that we are going to create will be easier to distribute, read, and maintain, and it will be possible to grasp the functionality of its different parts by just looking at the filenames.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Creating a Python package</li>
<li>Loading and refreshing code and assets</li>
<li>Reading environment variables in your scripts</li>
<li>Using the Preferences system</li>
</ul>
<h1 id="_idParaDest-127"><a id="_idTextAnchor131"/>Technical requirements</h1>
<p>We will use Blender and Visual Studio Code in this chapter. The examples created in this chapter can be found at <a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch6">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch6</a>.</p>
<p>Optionally, on Windows, we can use 7-Zip to create compressed archives. 7-Zip is a free application that can be downloaded from <a href="https://www.7zip.org">https://www.7zip.org</a>.</p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor132"/>Folders, packages, and add-ons</h1>
<p>We know that an add-on consists of Python code accompanied by information for the Blender plugin system. While single-file Python scripts are called modules, a folder of scripts is called a package.</p>
<p>Writing an add-on folder implies that we will store the Blender information at the package level, so we will create a directory and create the package information first.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor133"/>Creating a package folder and the init file</h2>
<p>Let’s create a <a id="_idIndexMarker384"/>folder for <em class="italic">this chapter</em> in our Python project. Then, in <a id="_idIndexMarker385"/>the <code>ch6</code> folder as our <strong class="bold">Scripts Folder</strong> and restart Blender. To make a package, we need to create a new folder rather than a new file. We can do that using the file manager or, like in the following steps, use the files bar of our programmer editor:</p>
<ol>
<li>Select <code>PythonScriptingBlender/ch6/addons</code>.</li>
<li>Create a new folder by clicking the <strong class="bold">New </strong><strong class="bold">Folder</strong> icon:</li>
</ol>
<div><div><img alt="Figure 6.1: Creating folders in Visual Studio Code" height="485" src="img/Figure_6.1_B18375.jpg" width="478"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1: Creating folders in Visual Studio Code</p>
<ol>
<li value="3">Name the new folder <code>structured_addon</code>.</li>
</ol>
<p>A Python package contains a file named <code>__init__.py</code>. This is the <strong class="bold">entry point</strong> of the folder and Python runs it automatically when it imports a package. To create it, follow these steps:</p>
<ol>
<li>Select the <code>…/</code><code>ch6/addons/structured_addon</code> folder.</li>
<li>Create a new <a id="_idIndexMarker386"/>file by clicking <a id="_idIndexMarker387"/>on the <strong class="bold">New </strong><strong class="bold">File</strong> icon:</li>
</ol>
<div><div><img alt="Figure 6.2: Creating a new file in Visual Studio Code" height="485" src="img/Figure_6.2_B18375.jpg" width="478"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2: Creating a new file in Visual Studio Code</p>
<ol>
<li value="3">Name the new file <code>__init__.py</code>.</li>
<li>Open the file by double-clicking it.</li>
</ol>
<p>When Blender searches for installed add-ons, it will look for the <code>bl_info</code> dictionary inside the <code>__init__.py</code> files of this folder. We will fill in this information in the usual way.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor134"/>Writing the init file</h2>
<p>This <code>bl_info</code> dictionary <a id="_idIndexMarker388"/>contains the usual attributes for add-on discovery:</p>
<pre class="source-code">
bl_info = {
    "name": "A Structured Add-on",
    "author": "John Doe",
    "version": (1, 0),
    "blender": (3, 2, 0),
    "description": "Add-on consisting of multiple files",
    "category": "Learning",
}</pre>
<p>Providing a <code>register()</code> and an <code>unregister()</code> function will allow us to enable and disable the add-on:</p>
<pre class="source-code">
def register():
    pass
def unregister():
    pass</pre>
<p>Now, we should be <a id="_idIndexMarker389"/>able to see our <strong class="bold">Structured Add-on</strong> if we restart Blender or refresh the add-ons list:</p>
<div><div><img alt="Figure 6.3: Structured Add-on listed in the “Learning” category" height="384" src="img/Figure_6.03_B18375.jpg" width="759"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3: Structured Add-on listed in the “Learning” category</p>
<p>We are going to make it useful by adding some content using different <code>.</code><code>py</code> files.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor135"/>Guidelines for separating modules</h2>
<p>There is a trade-off between partitioning and centralizing the code: excessively atomized code <a id="_idIndexMarker390"/>risks being unclear and hard to maintain. So, even if there are no fixed rules about splitting a program, there are general criteria for writing modular code:</p>
<ul>
<li>Non-Python files such as <em class="italic">media</em> (images, sounds, and so on) have their subfolders according to their types</li>
<li><em class="italic">Generic code</em> used by unrelated classes can be considered a utility module and used like a library</li>
<li><em class="italic">Specific code</em> relevant to a particular functionality should be a specific module</li>
<li><em class="italic">UI</em> classes, such as panels and menus, can be separated by non-UI code</li>
<li><em class="italic">Operators</em> can be separated from non-operator code and split per category</li>
<li><em class="italic">Import</em> statements relevant to only a part of a script might imply that entire sections could go to another file, thus reducing the number of imported libraries in one file</li>
</ul>
<p>We will put these concepts into practice and see how, starting with an example we are familiar with, the package architecture makes our code clearer and more effective:</p>
<div><div><img alt="Figure 6.4: Execution of an add-on folder – __init__.py glues all the parts together" height="998" src="img/Figure_6.04_B18375.jpg" width="1092"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4: Execution of an add-on folder – __init__.py glues all the parts together</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor136"/>Writing the structured panel</h2>
<p>We wrote a <a id="_idIndexMarker391"/>user interface in <a href="B18375_05.xhtml#_idTextAnchor100"><em class="italic">Chapter 5</em></a>, that relied on an external <code>.png</code> file to display an icon. That makes the tool difficult to share because Blender can only install either one <code>.py</code> or <code>.</code><code>zip</code> file.</p>
<p>We can bundle pictures and code together if we structure it all as a folder. According to the guidelines summed up earlier, we can create the following:</p>
<ul>
<li>A subfolder for the <em class="italic">icon storage</em> (media files) named <code>pictures</code></li>
<li>A module for <em class="italic">icon loading</em> (generic functionality) named <code>img_load.py</code></li>
<li>A module that contains the <em class="italic">panel</em> (UI separation) named <code>panel.py</code></li>
<li>A module for add-on <em class="italic">preferences</em> (specific functionality) named <code>preferences.py</code></li>
<li>A module to <em class="italic">reload</em> the <a id="_idIndexMarker392"/>import system (maintenance utility) named <code>_refresh_.py</code></li>
</ul>
<p>In the next section, we will create a folder for storing the image files and the code for loading them.</p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor137"/>Packing external images</h1>
<p>If we use image files for <a id="_idIndexMarker393"/>our add-on, we can create a folder in the <code>structured_addon</code> directory and name it <code>pictures</code>. Since we are going to write a module for loading icons, this folder can contain a collection of image files.</p>
<p>In the <code>ch6\addons\structured_addon\pictures</code> folder from the examples, we have <code>pack_64.png</code>, a clipart representing a package, and <code>smile_64.png</code>, the smiley face from the previous chapter:</p>
<div><div><img alt="Figure 6.5: The pictures used for this add-on are stored in a folder" height="371" src="img/Figure_6.05_B18375.jpg" width="734"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5: The pictures used for this add-on are stored in a folder</p>
<p>Once all our images are in this folder, we can write the code to load them.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor138"/>Writing an icon library</h2>
<p>In <a href="B18375_05.xhtml#_idTextAnchor100"><em class="italic">Chapter 5</em></a>, we wrote a function that loads a specific image file <a id="_idIndexMarker394"/>from disk. That worked great. Now that we are loading two icons, we can just use the same routine twice.</p>
<p>But now that we have an entire module for loading images, we can write a more sophisticated solution that works for any number of icons since it doesn’t rely on hardcoded full paths.</p>
<p>This new loader scans the pictures folder for images. We will make sure that loading times are not increased by multiple calls from other modules so that we end up with a more flexible, yet still reliable, loader for custom images. Let’s create the module’s file, following the same steps as before:</p>
<ol>
<li>Select the <code>…/</code><code>ch6/addons/structured_addon</code> folder.</li>
<li>Create a new file by clicking the <strong class="bold">New </strong><strong class="bold">File</strong> icon.</li>
<li>Name the new file <code>img_loader.py</code>.</li>
<li>Open the file by double-clicking it.</li>
</ol>
<p>This module will handle icon loading for the entire package.</p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor139"/>Loading pictures from a folder</h2>
<p>The <code>img_loader</code> module <a id="_idIndexMarker395"/>scrolls the image files from a folder, so we need to import the <code>os</code> package to access directories. And of course, <code>bpy.utils.previews</code> is needed for loading the images from the file and storing them as icons:</p>
<pre class="source-code">
from bpy.utils import previews
import os</pre>
<p>We use a global variable, a list, to store the Blender previews <code>Collection</code>. Following the Python naming convention, the variable name is uppercase since it’s global. Also, it starts with an underscore because it is not meant to be used in any other module:</p>
<pre class="source-code">
_CUSTOM_ICONS = None</pre>
<p>We create the <code>register_icons()</code> function to load the icons from disk. It is like the <code>load_custom_icons</code> function from the first section of <a href="B18375_05.xhtml#_idTextAnchor100"><em class="italic">Chapter 5</em></a>.</p>
<p>If <code>_CUSTOM_ICONS</code> tests <code>True</code> to the <code>if</code> condition, the <code>return</code> statement will exit the <a id="_idIndexMarker396"/>function immediately. That prevents it from loading the icons repeatedly every time that the module is used. Otherwise, we create a new collection of icons via <code>previews.new()</code>:</p>
<pre class="source-code">
def register_icons():
    """Load icons from the add-on folder"""
    global _CUSTOM_ICONS
    <code>if _CUSTOM_ICONS:</code>  # avoid loading icons twice
        <code>return</code>
    collection = <code>previews.new()</code></pre>
<p>Rather than hardcoding filenames, we load all the images contained in the <code>pictures</code> folder. We don’t want to load non-image files, so we store a list of our viable image extensions in the <code>img_extensions</code> variable. We are only using the <code>.png</code> and <code>.jpg</code> formats in this example but others, such as <code>.tif</code>, can be used:</p>
<pre class="source-code">
    img_extensions = (<code>'.png'</code>, <code>'.jpg'</code>)</pre>
<p>We get the path to the pictures folder by adding <code>'pictures'</code> to the module’s path. When dealing with files, path functions from the <code>os</code> utilities are preferred to string manipulation since they ensure multi-platform compatibility. So, we build the <code>picture_path</code> variable using the <code>os.path.join</code> function:</p>
<pre class="source-code">
    module_path = os.path.dirname(__file__)
    picture_path = <code>os.path.join</code>(module_path, 'pictures')</pre>
<p>The <code>os.listdir</code> function returns a list of all the filenames contained in a directory. We navigate the list with a <code>for</code> loop, and at each iteration, we separate the filename from the extension using the <code>os.path.splitext</code> function. Both lower and uppercase extensions are valid, but string comparison is a case-sensitive operation. We convert all file extensions into lowercase letters so that <code>.jpg</code> or <code>.png</code> files can be considered. When a file extension is not found in <code>img_extensions</code>, the file is skipped by the <code>continue</code> statement:</p>
<pre class="source-code">
    for img_file in <code>os.listdir(picture_path)</code>:
        img_name, ext = os.path.<code>splitext</code>(img_file)
        if <code>ext.lower()</code> not in img_extensions:
            # skip non image files
            <code>continue</code></pre>
<p class="callout-heading">Bail out quickly or stick to it!</p>
<p class="callout">Escaping one loop iteration using <code>continue</code>, an entire loop using <code>break</code>, or a function using <code>return</code> before it’s over is a valid technique to interrupt a procedure as soon as its conditions are not met. It avoids nesting too many <code>if</code> statements, but it is recommended to do that only at the beginning of an execution: having exit points at seemingly random points in the code makes it hard to read.</p>
<p><code>os.listdir</code> lists <a id="_idIndexMarker397"/>only the filenames and not their full disk paths. To get it, we must join <code>picture_path</code> and <code>img_file</code> together, using <code>os.path.join</code> again. We use <code>img_nam</code>e – that is, the filename without an extension – as the keyword for retrieving the icon from the collection:</p>
<pre class="source-code">
        <code>disk_path</code> = os.path.<code>join</code>(picture_path, <code>img_file</code>)
        collection.<code>load(img_name, disk_path, 'IMAGE')</code></pre>
<p>Once the <code>for</code> loop is over, we can store the collection in the <code>_CUSTOM_ICONS</code> list:</p>
<pre class="source-code">
    _CUSTOM_ICONS = collection</pre>
<p>Using filenames as keywords is convenient as, for instance, <code>'smile_64'</code> will be the keyword for the <code>smile_64.png</code> file, but it can be ambiguous when our folder contains files with the same name but different extensions, such as <code>smile_64.jpg</code>. Our script will assume that the picture folder doesn’t contain pictures with the same filenames.</p>
<p>With that, we have created the <code>register_icons()</code> function, which initializes the icon <a id="_idIndexMarker398"/>collection. Now, we need to add a function to clean it up when the add-on is disabled; otherwise, the leftover thumbnails in our computer’s RAM will interfere with subsequent executions.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor140"/>Unregistering icons</h2>
<p>When the <a id="_idIndexMarker399"/>add-on is disabled, we must discharge its icons from our computer’s memory.</p>
<p>To do that, we must define the <code>unregister_icons</code> function. In this function, we invoke <code>previews.remove()</code> and use <code>_CUSTOM_ICONS</code> as its argument. We also need to make sure that <code>_CUSTOM_ICONS</code> is set to <code>None</code> at the end of the function; otherwise, Python will keep invalid references to deleted icons and cause Blender to crash:</p>
<pre class="source-code">
def unregister_icons():
    global _CUSTOM_ICONS
    if _CUSTOM_ICONS:
        <code>previews.remove</code>(_CUSTOM_ICONS)
    <code>_CUSTOM_ICONS = None</code></pre>
<p>Now that <code>img_loader</code> can load and unload icons, what we need is a getter to access <code>_CUSTOM_ICONS</code> from the other modules.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor141"/>Getting the collection</h2>
<p>Python <a id="_idIndexMarker400"/>doesn’t forbid access to module members, even if we mark them as <em class="italic">private</em> using a name with leading underscores. So, we could access the <code>_CUSTOM_ICONS</code> variable by typing the following:</p>
<pre class="source-code">
&gt;&gt;&gt;<a id="_idTextAnchor142"/> img_loader<code>._CUSTOM_ICONS</code></pre>
<p>Still, we can add more control if we use a function to get the loaded icons:</p>
<ul>
<li>In the future, we can change <code>_CUSTOM_ICONS</code> to a dictionary or list. That would have no repercussions for other modules using the data if the function used to get them is changed accordingly.</li>
<li>It makes it easy to check that the conditions are met. In this case, our call to <code>register_icons()</code> makes sure that the icons are registered in case they weren’t for some reason. This practice adheres to <strong class="bold">defensive programming</strong>, as it aims to <a id="_idIndexMarker401"/>make the script work even against unforeseen circumstances.</li>
<li>It allows us to set <em class="italic">roadblocks</em> in case some vital condition was not met. For instance, we <a id="_idIndexMarker402"/>have added an <code>assert _CUSTOM_ICONS</code> statement that will cause an error if the variable has not <a id="_idIndexMarker403"/>been set, despite the recent call to <code>register_icons()</code>. This is an example of <strong class="bold">offensive programming</strong> because it stops the execution when something is wrong:</li>
</ul>
<pre class="source-code">
def get_icons_collection():
    """Get icons loaded from folder"""
    <code>register_icons()</code>  # load icons from disk
    <code>assert</code> _CUSTOM_ICONS  # if None something is wrong
    return _CUSTOM_ICONS</pre>
<p>Now, the picture loader provides a code interface for loading, unloading, and getting all the icons from the pictures folder. The main module can import it via relative import.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor143"/>Using relative imports</h2>
<p>The <code>import</code> statement <a id="_idIndexMarker404"/>looks for modules installed in the Python search path, such as the built-in library or, in our case, the Blender API (<code>bpy</code>). Trying to import a module that is not in the search path halts the script with a <code>ModuleNotFoundError</code>.</p>
<p>For modules that belong to the same package, we use a slightly different syntax that gives access to the other modules of the same package: a <strong class="bold">relative</strong> import statement.</p>
<p>In relative imports, the package is represented with a dot (<code>.</code>), and modules are imported using the <code>from . import </code><code>module</code> syntax.</p>
<p>So, in the import section of our <code>__init__.py</code> file, add the following:</p>
<pre class="source-code">
from <code>.</code> import <code>img_loader</code></pre>
<p>The register and unregister functions will invoke the <code>register_icons()</code> and <code>unregister_icons()</code> functions contained in the <code>img_loader</code> namespace, respectively:</p>
<pre class="source-code">
def register():
    img_loader.register_icons()
def unregister():
    img_loader.unregister_icons()</pre>
<p>Now that the <a id="_idIndexMarker405"/>entire process of loading images is handled in one module, we can write the <code>.py</code> file of the <em class="italic">user interface</em>.</p>
<p>In the next section, we will see how, once we gain access to our icons system via a relative import of <code>img_loader</code>, we won’t have to worry about loading icon files anymore.</p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor144"/>Adding a user interface</h1>
<p>We have already <a id="_idIndexMarker406"/>created the <code>panel.py</code> module, which will contain all the <em class="italic">user interface</em> classes and functions, so this file is going to contain our panel class.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor145"/>Writing the UI module</h2>
<p>We will start importing the <code>bpy</code> module <a id="_idIndexMarker407"/>and our collection of icons via a relative import of <code>img_loader</code>:</p>
<pre class="source-code">
import bpy
from . import <code>img_loader</code></pre>
<p>The <code>OBJECT_PT_structured</code> class is derived from <code>Panel</code>. Like the one from <a href="B18375_05.xhtml#_idTextAnchor100"><em class="italic">Chapter 5</em></a>, it contains the <code>bl_*</code> identifiers required by Blender in its static section:</p>
<pre class="source-code">
class OBJECT_PT_structured(bpy.types.Panel):
    """Creates a Panel in the object context"""
    bl_label = "A Modular Panel"
    bl_idname = "MODULAR_PT_layout"
    bl_space_type = <code>'PROPERTIES'</code>
    bl_region_type = <code>'WINDOW'</code>
    bl_context = <code>'object'</code></pre>
<p>For now, our <code>draw</code> function is a few lines of code that display an icon, followed by text:</p>
<pre class="source-code">
    def <code>draw</code>(self, context):
        layout = self.layout
        <code>icons</code> = img_loader.get_icons_collection()
        layout.label(text="A Custom Icon",
                     icon_value=icons['pack_64'].icon_id)</pre>
<p>Next, we must write the functions for registering and unregistering the class from this module:</p>
<pre class="source-code">
def <code>register_classes</code>():
    bpy.utils.register_class(OBJECT_PT_structured)
def <code>unregister_classes</code>():
    bpy.utils.unregister_class(OBJECT_PT_structured)</pre>
<p>Providing registration <a id="_idIndexMarker408"/>utilities inside the module relieves <code>__init__.py</code> from concerns about which classes are defined in <code>panel</code> and which ones should be registered/unregistered. It is like what we did in <em class="italic">Getting the collection</em> in section 2 of this chapter, <em class="italic">Packing </em><em class="italic">external images</em>.</p>
<p>These designs fall under the practice of <strong class="bold">encapsulation</strong> – that is, restricting direct access to the components of a module or object. Adhering to it is not inherently better, but it can help in keeping the code flexible and clean.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor146"/>Importing the UI</h2>
<p>Inside <code>__init__.py</code>, we <a id="_idIndexMarker409"/>import <code>panel</code> from the <code>.</code> namespace, and invoke its <code>register_classes()</code> and <code>unregister_classes()</code> functions:</p>
<pre class="source-code">
from . import img_loader
from . import <code>panel</code>
def register():
    img_loader.register_icons()
    <code>panel.register_classes</code>()
def unregister():
    <code>panel.unregister_classes</code>()
    img_loader.unregister_icons()</pre>
<p>In this example, the <code>unregister</code> order is the reverse of the one in the <code>register</code> function. That is not relevant to the execution of the add-on, and it is followed here only for the sake of clarity.</p>
<p>We can test our code by enabling <strong class="bold">Structured Panel</strong> in the <strong class="bold">Add-ons</strong> list from the <strong class="bold">Edit</strong> | <strong class="bold">Preferences</strong> menu.</p>
<p>We can see the <a id="_idIndexMarker410"/>panel and our new icon in the object section:</p>
<div><div><img alt="Figure 6.6: panel.py displays an icon via img_loader.py" height="94" src="img/Figure_6.06_B18375.jpg" width="272"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6: panel.py displays an icon via img_loader.py</p>
<p>Now, we will add other elements and complete the panel.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor147"/>Completing the Objects panel</h2>
<p>A slightly simpler <a id="_idIndexMarker411"/>version of the panel displayed in <a href="B18375_05.xhtml#_idTextAnchor100"><em class="italic">Chapter 5</em></a>, uses pretty much the same code. The <a id="_idIndexMarker412"/>maximum number of displayed objects is still stored in the <code>max_objects</code> static member, but it would work better if implemented as a preference of the add-on. We will do that in the <em class="italic">Using addon preferences</em> section, a few pages ahead in this chapter:</p>
<pre class="source-code">
class OBJECT_PT_structured(bpy.types.Panel):
    """Creates a Panel in the object context"""
    bl_label = "A Modular Panel"
    bl_idname = "MODULAR_PT_layout"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = 'object'
    <code>max_objects = 3</code>  # limit displayed list to 3 objects</pre>
<p>The <code>draw</code> function displays a list of the scene objects:</p>
<pre class="source-code">
    def draw(self, context):
        layout = self.layout
        icons = img_loader.get_icons_collection()
        row = layout.row(align=True)
        row.label(text="Scene Objects",
                  icon_value=icons['pack_64'].icon_id)
        row.label(text=" ",
                  icon_value=icons["smile_64"].icon_id)
        grid = layout.grid_flow(columns=2,
                                row_major=True)
        for i, ob in enumerate(context.scene.objects):
            if i &gt; self.max_objects:
                grid.label(text="...")
                break
            # display object name and type icon
            grid.label(text=ob.name,
                       icon=f'OUTLINER_OB_{ob.type}')</pre>
<p>This time, reloading <a id="_idIndexMarker413"/>the scripts does not reflect the changes in <a id="_idIndexMarker414"/>the preceding code: only the <code>__init__.py</code> file is refreshed on reload. We are going to cover explicitly reloading internal modules in the next section.</p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor148"/>Reloading cached modules</h1>
<p>When a module is <a id="_idIndexMarker415"/>imported, Python caches a copy of it for future access. Since the <code>__init__.py</code> file is the only one to be updated by the <strong class="bold">Reload Scripts</strong> operator, we are left with two options:</p>
<ul>
<li>Close and restart Blender</li>
<li>Explicitly call the <code>reload</code> function inside <code>__init__.py</code></li>
</ul>
<p>The latter is preferred over restarting the application as it takes less time. The <code>reload</code> function is part of the <code>importlib</code> module.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor149"/>Reloading via importlib</h2>
<p>The utilities contained <a id="_idIndexMarker416"/>in the <code>importlib</code> library interact <a id="_idIndexMarker417"/>with the import system, and the <code>reload</code> function forces the Python interpreter to reload a module from disk.</p>
<p>If the <code>img_loader</code> module has changed and needs to be reloaded, we can use the following command:</p>
<pre class="source-code">
from importlib import <code>reload</code>
<code>reload(img_loader)</code></pre>
<p>So, to make sure that the changes to our add-on <code>.py</code> files are always applied, we can add these lines of code to <code>_init_.py</code>:</p>
<pre class="source-code">
from . import img_loader
from . import panel
from importlib import reload
reload(img_loader)
reload(panel)</pre>
<p>Reloading every <a id="_idIndexMarker418"/>relative module soon after it is imported <a id="_idIndexMarker419"/>will work, but leaving <code>reload</code> statements in published code impacts performance and is considered bad practice. Next, we will learn how to refresh inside a specific module of the add-on.</p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor150"/>Implementing a refresh module</h2>
<p>Calling <code>reload</code> increases the <a id="_idIndexMarker420"/>loading time of <a id="_idIndexMarker421"/>an add-on and makes the code less readable. Many developers add reload calls while they work and remove them when they are finished. However, using packages, we can move the refresh logic to another module.</p>
<p>To do that, we need to create a file in our add-on package and name it <code>_refresh_.py</code>. This module doesn’t contain any add-on functionality, but it helps while we edit our code by ensuring that all modules are reloaded from disk and are up to date.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor151"/>Reloading the package modules</h2>
<p>The refresh module <a id="_idIndexMarker422"/>makes use of the <a id="_idIndexMarker423"/>following elements:</p>
<ul>
<li>The <code>reload</code> function from the <code>importlib</code> module</li>
<li>The <code>sys</code> module, which is used by <code>_refresh_</code> to reload an instance of itself</li>
<li>The <code>bpy</code> module, to access Blender preferences</li>
<li>All the modules contained in the add-on</li>
</ul>
<p>Those requirements translate into the following <code>import</code> statements:</p>
<pre class="source-code">
from importlib import reload
import sys
import bpy
<code>from . import *</code></pre>
<p>The wildcard character, <code>*</code>, stands for all the modules contained in the current package (<code>.</code>). Now, we can <a id="_idIndexMarker424"/>write a function that reloads the add-on <a id="_idIndexMarker425"/>modules if Blender is set for development. We encountered the <strong class="bold">Developer Extras</strong> setting in the <em class="italic">Useful features for Python</em> section, at the beginning of <a href="B18375_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>. They can be found by going to <strong class="bold">Edit</strong> | <strong class="bold">Preferences</strong> from the top menu bar in the <strong class="bold">Interface</strong> tab of the <strong class="bold">Preferences</strong> window:</p>
<div><div><img alt="Figure 6.7: Enabling Developer Extras in the Preferences window" height="287" src="img/Figure_6.07_B18375.jpg" width="990"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7: Enabling Developer Extras in the Preferences window</p>
<p>We can assume that when <strong class="bold">Developer Extras</strong> is on, we want the <strong class="bold">Reload Scripts</strong> operator to reload our submodules as well.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor152"/>Using Developer Extras as a condition</h2>
<p>We need to <a id="_idIndexMarker426"/>find the full Python <a id="_idIndexMarker427"/>path of <strong class="bold">Developer Extras</strong> to read its value. To do that, follow these steps:</p>
<ol>
<li>Make sure that <strong class="bold">Developer Extras</strong> is enabled.</li>
<li>Also, make sure that <strong class="bold">User Tooltips</strong> and <strong class="bold">Python Tooltips</strong> are enabled.</li>
<li>Hover your mouse pointer over the <strong class="bold">Developer Extras</strong> checkbox or label.</li>
<li>Leaving your mouse still, without clicking or moving it, displays a tooltip:</li>
</ol>
<pre class="source-code">
Show options for developers (edit source in context …
Python: <code>PreferencesView.show_developer_ui</code></pre>
<p>According to the API reference, <code>PreferencesView</code> is the <code>view</code> member of the <code>Preferences</code> class, which can be found at <code>bpy.context.preferences</code>:</p>
<p><a href="https://docs.blender.org/api/3.3/bpy.types.Preferences.xhtml">https://docs.blender.org/api/3.3/bpy.types.Preferences.xhtml</a></p>
<p>#bpy.types.Preferences.view</p>
<p>So, the full path of the <strong class="bold">Developer Extras</strong> setting is as follows:</p>
<pre class="source-code">
bpy.context.preferences.view.show_developer_ui</pre>
<p>The value of <code>show_developer_ui</code> is either <code>True</code> or <code>False</code>. Using it as a condition, we exit <code>reload_modules</code> if <strong class="bold">Developer Extras</strong> is disabled:</p>
<pre class="source-code">
def reload_modules():
    if <code>not</code> bpy.context.preferences.view.<code>show_developer_ui</code>:
        return</pre>
<p>Then, we add a <code>reload</code> call <a id="_idIndexMarker428"/>for each <code>.py</code> file that we <a id="_idIndexMarker429"/>want to refresh. The first line reloads <code>_refresh_.py</code>, looking up the current filename in the system dictionary, <code>sys.modules</code>. This way, we can update changes in the <code>_refresh_</code> module itself. So, the full body of the <code>reload_modules</code> function looks like this:</p>
<pre class="source-code">
def reload_modules():
    if not bpy.context.preferences.view.show_developer_ui:
        return
    reload(sys.modules[<code>__name__</code>])
    reload(img_loader)
    reload(panel)</pre>
<p>Now, enabling <code>__init__.py</code>, as that is the only file to be executed when scripts are reloaded. We must invoke <code>_refresh_.reload_modules()</code> in the import section:</p>
<pre class="source-code">
from . import img_loader
from . import panel
from . import _refresh_
_refresh_.<code>reload_modules()</code></pre>
<p>Calling <code>OBJECT_PT_structured</code>:</p>
<div><div><img alt="Figure 6.8: Our panel source code has been reloaded" height="152" src="img/Figure_6.08_B18375.jpg" width="269"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8: Our panel source code has been reloaded</p>
<p>The limitation of three objects can be set in the <code>max_objects = 3</code> static member. However, there is a better place for hosting our add-on setting. In the next section, we are going to implement proper preferences for our add-on.</p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor153"/>Using add-on preferences</h1>
<p>Besides using Blender <a id="_idIndexMarker432"/>preferences, we can use <code>bpy.types.AddonPreferences</code> to display the add-on-specific custom settings under the add-on activation checkbox. It’s an interface, just like <code>bpy.types.Panel</code>, and we can add settings to its layout using its <code>draw</code> method.</p>
<p>The <code>bl_idname</code> attribute of <code>AddonPreferences</code> must match the Python name of the add-on. The usage of <code>__name__</code> for single files and <code>__package__</code> for folders makes our code easier to maintain: these variables always match the respective Python names, so changes in files and folders’ names would have no consequences.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor154"/>Creating preferences</h2>
<p>Since we are using multiple files, we <a id="_idIndexMarker433"/>will create <code>preferences.py</code> inside the folder of our <code>structured_addon</code>. It contains the <code>StructuredPreferences</code> class:</p>
<pre class="source-code">
import bpy
class StructuredPreferences(<code>bpy.types.AddonPreferences</code>):
    bl_idname = <code>__package__</code>
    def draw(self, context):
        layout = self.layout
        layout.label(text="Structured Add-On Preferences")</pre>
<p>Then, we must add a <code>register_classes</code> and an <code>unregister_classes</code> function:</p>
<pre class="source-code">
def register_classes():
    bpy.utils.register_class(StructuredPreferences)
def unregister_classes():
    bpy.utils.unregister_class(StructuredPreferences)</pre>
<p>We can add <code>preferences</code> to the <code>import</code> section of <code>__init__.py</code>, which looks like this:</p>
<pre class="source-code">
from . import panel
from . import img_loader
from . import <code>preferences</code>
from . import _refresh_
_refresh_.reload_modules()</pre>
<p>Then, we must <a id="_idIndexMarker434"/>register the class from the preferences module alongside the others:</p>
<pre class="source-code">
def register():
    img_loader.register_icons()
    <code>preferences.register_classes</code>()
    panel.register_classes()
def unregister():
    panel.unregister_classes()
    <code>preferences.unregister_classes()</code>
    img_loader.unregister_icons()</pre>
<p>We must also make sure that the preferences will be reloaded in <code>_refresh_.py</code>. This is what the <code>_reload_modules</code> function will look like:</p>
<pre class="source-code">
def _reload_modules():
    reload(sys.modules[__name__])
    reload(img_loader)
    <code>reload(preferences)</code>
    reload(panel)</pre>
<p>If we use <strong class="bold">Reload Scripts</strong> now, we <a id="_idIndexMarker435"/>will see our preferences beneath the <strong class="bold">Add-on</strong> checkbox, in the <strong class="bold">Add-Ons</strong> list:</p>
<div><div><img alt="Figure 6.9: Add-ons settings displayed in the Preferences window" height="429" src="img/Figure_6.09_B18375.jpg" width="936"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9: Add-ons settings displayed in the Preferences window</p>
<p>The preferences show up but are still empty. Next, we are going to add some values.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor155"/>Populating the preferences</h2>
<p>We want <a id="_idIndexMarker436"/>to replace <code>OBJECT_PT_structured .max_objects</code> with a setting. It’s an integer number, so we will add an <code>IntProperty</code> to the <code>StructuredPreferences</code> class:</p>
<pre class="source-code">
import bpy
from bpy.props <code>import IntProperty</code>
class StructuredPreferences(bpy.types.AddonPreferences):
    bl_idname = __package__
    <code>max_objects</code>: IntProperty(
        name="Maximum number of displayed objects",
        default=3
    )</pre>
<p>Now that it contains an integer property, <code>StructuredPreferences</code> can store the maximum displayed objects setting. To display this property to the user, we will add it to the layout in the <code>draw</code> method. A simple <code>layout.prop</code> instruction will be enough:</p>
<pre class="source-code">
self.layout.prop(self, max_objects)</pre>
<p>But we can also use <code>split</code> for a nicer appearance. A split layout creates a column for each new <a id="_idIndexMarker437"/>entry. Adding an empty widget, a <code>separator</code>, as the first element, creates an indentation:</p>
<pre class="source-code">
    def draw(self, context):
        layout = self.layout
        split = layout.split(factor=0.5)
        split.separator()
        split.label(text="Max Objects")
        split.prop(self, 'max_objects', text="")</pre>
<p>Reloading the script will display <strong class="bold">Max Objects</strong> as an editable setting:</p>
<div><div><img alt="Figure 6.10: Max Objects as a Preferences setting" height="470" src="img/Figure_6.10_B18375.jpg" width="990"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10: Max Objects as a Preferences setting</p>
<p>This value is saved along with the other user preferences, and Blender remembers its value when the application is restarted. We aren’t using this setting yet: we need to adjust the code in our panel so that we can use it.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor156"/>Using add-on preferences in code</h2>
<p>Python scripts can <a id="_idIndexMarker438"/>access the preferences of an add-on using one line of code:</p>
<pre class="source-code">
bpy.context.preferences.addons[ADDON_NAME].<code>preferences</code></pre>
<p>Notice how <code>preferences</code> is repeated at the end. It might seem redundant but it makes sense since <code>bpy.context.preferences.addons</code> refers to the application preferences, not the ones of the single add-on.</p>
<p><code>bpy.context.preferences.addons[ADDON_NAME]</code> returns the add-on as a Python object.</p>
<p>With that in mind, we will go back to the <code>OBJECT_PT_structured</code> class in the <em class="italic">user interface’s</em> <code>panel.py</code> module. Since we are going to use the value from the preferences, it should not have a <code>max_objects</code> static member anymore:</p>
<pre class="source-code">
class OBJECT_PT_structured(bpy.types.Panel):
    """Creates a Panel in the object context"""
    bl_label = "A Modular Panel"
    bl_idname = "MODULAR_PT_layout"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = 'object'</pre>
<p>Now, before we iterate the scene objects in the <code>draw</code> function, we must get our <code>add_on</code> and <code>preferences</code> from the context. Using <code>enumerate</code>, so that we can keep count of the objects while they are displayed, we stop the loop when the amount stored in <code>preferences.max_objects</code> is reached:</p>
<pre class="source-code">
    <code>add_on</code> = context.preferences.addons[__package__]
    <code>preferences</code> = add_on.preferences
    for i, ob in enumerate(context.scene.objects):
        if i <code>&gt;=</code> <code>preferences</code>.<code>max_objects</code>:
            grid.label(text="...")
            <code>break</code></pre>
<p>This time, we check <code>max_objects</code> with a greater or equal (<code>&gt;=</code>) comparison because, since the enumeration starts from <code>0</code>, breaking after <code>i &gt; max_objects</code> would display one more object.</p>
<p>Just to be clear, using a separate module for the add-on preferences is not required – the entirety of the code <a id="_idIndexMarker439"/>written in this chapter could have been contained in a single, large <code>.py</code> file: we are just splitting the code for the sake of readability.</p>
<p>If our add-on contains operators, we can create modules for those as well.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor157"/>Adding operators</h1>
<p>Operators can be <a id="_idIndexMarker440"/>grouped into different files according to their purpose. For example, transform-related operators such as <code>ops_transform.py</code>, while our first few operators, <code>ops_collections.py</code> file. All those classes would be then registered by <code>__init__.py</code> and, if needed, added to the add-on interface via relative import.</p>
<p>Another solution is creating one module for all the operators, which can be named <code>operators.py</code>. In this section, we will create an operators module for our add-on.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor158"/>Writing the operators module</h2>
<p>In the <code>structured _addon</code> folder, we will create the <code>operators.py</code> module. It will contain our <a id="_idIndexMarker441"/>operator class: we will reuse the <code>bpy</code>, which is ubiquitous in Blender script, we will import the <code>random</code> module and use <code>randint</code> in the <code>add_random_location</code> function:</p>
<pre class="source-code">
import bpy
import random
def add_random_location(objects, amount=1,
                        do_axis=(True, True, True)):
    """Add units to the locations of given objects"""
    for ob in objects:
        for i in range(3):
            if do_axis[i]:
                loc = ob.location
                loc[i] += random.randint(-amount, amount)</pre>
<p>Now, we can proceed with the add-on class. It’s the same as in the <em class="italic">Displaying buttons</em> section in the <a id="_idIndexMarker442"/>previous chapter – <code>poll</code> returns <code>True</code> if there are selected objects, while <code>execute</code> runs <code>add_random_location</code>, with the operator’s amount and axis as arguments:</p>
<pre class="source-code">
class TRANSFORM_OT_random_location(bpy.types.Operator):
    """Add units to the locations of selected objects"""
    bl_idname = "transform.add_random_location"
    bl_label = "Add random Location"
    amount: bpy.props.IntProperty(name="Amount",
                                  default=1)
    axis: bpy.props.BoolVectorProperty(
                               name="Displace Axis",
                               default=(True, True, True)
                               )
@classmethod
    def poll(cls, context):
        return context.selected_objects
    def execute(self, context):
        add_random_location(context.selected_objects,
                            self.amount,
                            self.axis)
        return {'FINISHED'}</pre>
<p>Like in the <a id="_idIndexMarker443"/>case of <code>panel.py</code>, we must add functions for registering the module’s classes:</p>
<pre class="source-code">
def register_classes():
    bpy.utils.register_class(TRANSFORM_OT_random_location)
def unregister_classes():
    bpy.utils.unregister_class(
                              TRANSFORM_OT_random_location
                              )</pre>
<p>Now, we can import <code>operators.py</code> into the other modules of the script.</p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor159"/>Registering operator classes</h2>
<p>To use our <a id="_idIndexMarker444"/>operator, we must import <code>operators.py</code> in <code>__init__.py</code>, whose <code>import</code> section will look like this:</p>
<pre class="source-code">
from . import <code>operators</code>
from . import img_load
from . import panel
from . import preferences
from . import _refresh_</pre>
<p>Of course, we can add and remove our operators with <code>operator.register_class</code> and <code>operator.unregister_class</code>. Since operators might be used as buttons, we call <code>operators.register_classes</code> before <code>panel.register_classes</code>:</p>
<pre class="source-code">
def register():
    preferences.unregister_classes()
    <code>operators.register_classes()</code>
    img_load.register_icons()
    panel.register_classes()
def unregister():
    panel.unregister_classes()
    img_load.unregister_icons()
    <code>operators.register_classes()</code>
    preferences.unregister_classes()</pre>
<p>This will <a id="_idIndexMarker445"/>make <code>operators.py</code> to be effective when we reload the script, we must add <code>operators</code> to <code>_refresh_.reload_modules</code>.</p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor160"/>Refreshing operators on reload</h2>
<p>Thanks to the <a id="_idIndexMarker446"/>work we did in the <em class="italic">Reloading cached modules</em> section, adding operators to the refreshed modules is easy: we add <code>reload(operators)</code> to the <code>reload_modules</code> function. The whole <code>_refresh_.py</code> file now looks like this:</p>
<pre class="source-code">
import sys
from importlib import reload
import bpy
from . import *
def reload_modules():
    if not bpy.context.preferences.view.show_developer_ui:
        return
    reload(sys.modules[__name__])
    reload(img_load)
    reload(preferences)
    <code>reload(operators)</code>
    reload(panel)</pre>
<p>The only thing left <a id="_idIndexMarker447"/>to do is display the operator button in the panel.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor161"/>Adding operator buttons</h2>
<p>To add the <code>panel.py</code>, whose <a id="_idIndexMarker448"/>import section will look as follows:</p>
<pre class="source-code">
import bpy
from . import img_loader
from . import operators</pre>
<p>Now, our panel can access the <code>TRANSFORM_OT_random_location</code> class using <code>operators</code> as a namespace, so we will add a new element to the <code>draw</code> method:</p>
<pre class="source-code">
    layout.operator(
          <code>operators.TRANSFORM_OT_random_location.bl_idname</code>
          )</pre>
<p>Upon displaying the <code>F3</code> <strong class="bold">Search Bar</strong> area to look up and run <strong class="bold">Reload Scripts</strong>, our panel will display the <strong class="bold">Add random </strong><strong class="bold">Location</strong> button:</p>
<div><div><img alt="Figure 6.11: Modular panel displaying operators via relative import" height="193" src="img/Figure_6.11_B18375.jpg" width="270"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11: Modular panel displaying operators via relative import</p>
<p>Our add-on is finished. However, we could refine <code>panel.py</code> and add the same functionalities that we wrote for <code>VerySimplePanel</code> in <a href="B18375_05.xhtml#_idTextAnchor100"><em class="italic">Chapter 5</em></a>, namely the following:</p>
<ul>
<li>Color-coded entries for selected/active objects</li>
<li>A <strong class="bold">Delete</strong> button with a context-sensitive label</li>
</ul>
<p>Implementing those is <a id="_idIndexMarker449"/>left as an exercise for you. In the next section, we will learn how to distribute our add-on folders to other users.</p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor162"/>Packaging and installing add-ons</h1>
<p>We learned how to <a id="_idIndexMarker450"/>install single <code>.py</code> add-ons in the <em class="italic">Installing our add-ons</em> section of <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>. To distribute an add-on that consists <a id="_idIndexMarker451"/>of more files, we must create a <code>.zip</code> archive of it. Most of you will be familiar with how a <code>.zip</code> file is a compressed archive that can contain more files or folders.</p>
<p>Blender can install folders from a standard <code>.zip</code> archive, but there are two requirements:</p>
<ul>
<li>The <code>.zip</code> file must contain the add-on as a first-level folder</li>
<li>The name of the first-level folder must not contain any dot (<code>.</code>) as it won’t work with Python’s import system</li>
</ul>
<p>There are third-party tools, such as <code>.zip</code> files using <a id="_idIndexMarker452"/>the file utilities of your operating system. In this section, we will learn how to compress an add-on folder on <strong class="bold">Windows</strong> <strong class="bold">OSX</strong>, and <strong class="bold">Ubuntu</strong> systems.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor163"/>Cleaning up bytecode</h2>
<p>If the <code>structured_addon.zip\structured_addon</code> folder contains a subfolder named <code>__pycache__</code>, make sure you <a id="_idIndexMarker453"/>delete it: you should not distribute the <code>.pyc</code> files it contains.</p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor164"/>Creating a .zip file using 7-Zip</h2>
<p><strong class="bold">7-Zip</strong> is a free <a id="_idIndexMarker454"/>compression utility for Windows. It is very lightweight <a id="_idIndexMarker455"/>and integrates with the file manager. Here are the steps to use it for packaging our add-ons:</p>
<ol>
<li>Download and install 7-Zip from <a href="https://www.7-zip.org">https://www.7-zip.org</a>.</li>
<li>Open <strong class="bold">File Explorer</strong>.</li>
<li>Navigate to the directory containing the <code>structured_addon</code> folder.</li>
<li>Right-click on the <code>structured_addon</code> folder to show the context menu.</li>
<li>Select <strong class="bold">7-Zip</strong> | <strong class="bold">Add </strong><strong class="bold">to “structured_addon.zip”</strong>.</li>
</ol>
<p>The <code>structured_addon.zip</code> file will be created alongside the original folder. If for some reason it is not possible to install 7-Zip or any other compression tool, we can still create <code>.zip</code> files using Windows File Explorer alone.</p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor165"/>Creating a .zip file using Windows File Manager</h2>
<ol>
<li>Open <strong class="bold">File Explorer</strong>.</li>
<li>Navigate <a id="_idIndexMarker456"/>to a folder where we want <a id="_idIndexMarker457"/>to create the add-on.</li>
<li>Display the context menu by right-clicking on the background.</li>
<li>From the right-click menu, select <code>structured_addon.zip</code>:</li>
</ol>
<div><div><img alt="Figure 6.12: Creating empty .zip files using Windows File Explorer" height="334" src="img/Figure_6.12_B18375.jpg" width="527"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12: Creating empty .zip files using Windows File Explorer</p>
<p>So far, we have <a id="_idIndexMarker458"/>created a <code>.zip</code> file, but it is <a id="_idIndexMarker459"/>empty. Next, we will copy our add-on files there:</p>
<ol>
<li>Copy the <code>ch6\addons\structured_addon</code> folder to the clipboard by using <em class="italic">Ctrl</em> + <em class="italic">C</em> or right-clicking and selecting <strong class="bold">Copy</strong>.</li>
<li>Double-click the <code>structured_addon.zip</code> archive to display its content.</li>
<li>Paste the <code>ch6\addons\structured_addon</code> folder into the archive via <em class="italic">Ctrl</em> + <em class="italic">V</em> or right-clicking and selecting <strong class="bold">Paste</strong>.</li>
</ol>
<h2 id="_idParaDest-161"><a id="_idTextAnchor166"/>Creating a .zip file on Mac using Finder</h2>
<p>Follow these steps:</p>
<ol>
<li>Right-click <a id="_idIndexMarker460"/>on the <code>structure_addon</code> folder <a id="_idIndexMarker461"/>in <strong class="bold">Finder</strong> or left-click <a id="_idIndexMarker462"/>without releasing the button. A menu will appear.</li>
<li>Select <strong class="bold">Compress “structured_addon”</strong> from the menu:</li>
</ol>
<div><div><img alt="Figure 6.13: Compressing folders on a Mac computer" height="301" src="img/Figure_6.13_B18375.jpg" width="1001"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13: Compressing folders on a Mac computer</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor167"/>Creating a .zip file using Gnome</h2>
<p><code>.zip</code> file using Gnome:</p>
<ol>
<li>Right-click on the <code>structure_addon</code> folder in the File Browser.</li>
<li>Choose the <strong class="bold">Compress…</strong> option from the menu.</li>
<li>Confirm the filename and <code>.zip</code> extension of the archive.</li>
<li>Click the <strong class="bold">Create</strong> button.</li>
</ol>
<h2 id="_idParaDest-163"><a id="_idTextAnchor168"/>Installing .zip add-ons</h2>
<p>The steps for installing a <a id="_idIndexMarker465"/>compressed add-on are the same as those we learned about in the <em class="italic">Expanding Blender by creating a simple add-on</em> section of <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>:</p>
<ol>
<li>Open the <strong class="bold">Preferences</strong> window via <strong class="bold">Edit</strong> | <strong class="bold">Preferences</strong> from the top menu.</li>
<li>Select the <strong class="bold">Add-ons</strong> tab in the left column.</li>
<li>Click on the <strong class="bold">Install</strong> button at the top right of <strong class="bold">Add-ons Preferences</strong>.</li>
<li>In the file browser, find the <code>structured_addon.zip</code> file.</li>
<li>Click <a id="_idIndexMarker466"/>the <strong class="bold">Install Add-on</strong> button at the bottom.</li>
</ol>
<p>With that, we have gone through the complete development and release of our structured add-on. A modular approach is important in programming and works for relatively simple tools as well. Plus, it makes our scripts more manageable as they increase in complexity.</p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor169"/>Summary</h1>
<p>In this chapter, we learned how to set up a modular architecture for our code by splitting it into different files while keeping it coherent and clear. We also learned how to load files procedurally and how to write settings for our add-ons.</p>
<p>This approach confers interoperability and generical usefulness to our code and, by applying appropriate separation guidelines, eases our task in navigating the different parts of our tools.</p>
<p>In <a href="B18375_07.xhtml#_idTextAnchor171"><em class="italic">Chapter 7</em></a>, we will learn how to animate with Python and change the animation settings with our scripts.</p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor170"/>Questions</h1>
<ol>
<li>Can Blender add-ons consist of multiple files?</li>
<li>Which file of an add-on folder contains the info dictionary?</li>
<li>How does relative import work?</li>
<li>Does reloading an add-on refresh all its modules?</li>
<li>Where do we store the settings of an add-on?</li>
<li>How do we show the add-on properties in the preferences?</li>
<li>How do we distribute multi-file add-ons?</li>
</ol>
</div>
</div></body></html>