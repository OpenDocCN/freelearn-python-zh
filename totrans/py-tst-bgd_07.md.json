["```py\nThis project is a personal scheduling system intended to keep track of a single person's schedule and activities. The system will store and display two kinds of schedule information: activities and statuses. Activities and statuses both support a protocol which allows them to be checked for overlap with another object supporting the protocol.\n\n>>> from planner.data import activities, statuses\n>>> from datetime import datetime\n\nActivities and statuses are stored in schedules, to which they can be added and removed.\n\n>>> from planner.data import schedules\n>>> activity = activities('test activity',\n...                       datetime(year=2009, month=6, day=1,\n...                                hour=10, minute=15),\n...                       datetime(year=2009, month=6, day=1,\n...                                hour=12, minute=30))\n>>> duplicate_activity = activities('test activity',\n...                       datetime(year=2009, month=6, day=1,\n...                                hour=10, minute=15),\n...                       datetime(year=2009, month=6, day=1,\n...                                hour=12, minute=30))\n>>> status = statuses('test status',\n...                   datetime(year=2009, month=7, day=1,\n...                            hour=10, minute=15),\n...                   datetime(year=2009, month=7, day=1,\n...                            hour=12, minute=30))\n>>> schedule = schedules()\n>>> schedule.add(activity)\n>>> schedule.add(status)\n>>> status in schedule\nTrue\n>>> activity in schedule\nTrue\n>>> duplicate_activity in schedule\nTrue\n>>> schedule.remove(activity)\n>>> schedule.remove(status)\n>>> status in schedule\nFalse\n>>> activity in schedule\nFalse\n\nActivities represent tasks that the person must actively engage in, and they are therefore mutually exclusive: no person can have two activities that overlap the same period of time.\n\n>>> activity1 = activities('test activity 1',\n...                        datetime(year=2009, month=6, day=1,\n...                                 hour=9, minute=5),\n...                        datetime(year=2009, month=6, day=1,\n...                                 hour=12, minute=30))\n>>> activity2 = activities('test activity 2',\n...                        datetime(year=2009, month=6, day=1,\n...                                 hour=10, minute=15),\n...                        datetime(year=2009, month=6, day=1,\n...                                 hour=13, minute=30))\n>>> schedule = schedules()\n>>> schedule.add(activity1)\n>>> schedule.add(activity2) # doctest:+ELLIPSIS\nTraceback (most recent call last):\nschedule_error: \"test activity 2\" overlaps with \"test activity 1\"\n\nStatuses represent tasks that a person engages in passively, and so\ncan overlap with each other and with activities.\n\n>>> activity1 = activities('test activity 1',\n...                        datetime(year=2009, month=6, day=1,\n...                                 hour=9, minute=5),\n...                        datetime(year=2009, month=6, day=1,\n...                                 hour=12, minute=30))\n>>> status1 = statuses('test status 1',\n...                    datetime(year=2009, month=6, day=1,\n...                             hour=10, minute=15),\n...                    datetime(year=2009, month=6, day=1,\n...                             hour=13, minute=30))\n>>> status2 = statuses('test status 2',\n...                    datetime(year=2009, month=6, day=1,\n...                             hour=8, minute=45),\n...                    datetime(year=2009, month=6, day=1,\n...                             hour=15, minute=30))\n>>> schedule = schedules()\n>>> schedule.add(activity1)\n>>> schedule.add(status1)\n>>> schedule.add(status2)\n>>> activity1 in schedule\nTrue\n>>> status1 in schedule\nTrue\n>>> status2 in schedule\nTrue\n\nSchedules can be saved to a sqlite database, and they can be reloaded\nfrom that stored state.\n\n>>> from planner.persistence import file\n>>> storage = file(':memory:')\n>>> schedule.store(storage)\n>>> newsched = schedules.load(storage)\n>>> schedule == newsched\nTrue\n```", "```py\nThis project is a personal scheduling system intended to keep track of a single person's schedule and activities. The system will store and display two kinds of schedule information: activities and statuses. Activities and statuses both support a protocol which allows them to be checked for overlap with another object supporting the protocol.\n\n>>> from planner.data import activities, statuses\n>>> from datetime import datetime\n```", "```py\n>>> from planner.data import schedules\n>>> activity = activities('test activity',\n...                       datetime(year=2009, month=6, day=1,\n...                                hour=10, minute=15),\n...                       datetime(year=2009, month=6, day=1,\n...                                hour=12, minute=30))\n>>> duplicate_activity = activities('test activity',\n...                       datetime(year=2009, month=6, day=1,\n...                                hour=10, minute=15),\n...                       datetime(year=2009, month=6, day=1,\n...                                hour=12, minute=30))\n>>> status = statuses('test status',\n...                   datetime(year=2009, month=7, day=1,\n...                            hour=10, minute=15),\n...                   datetime(year=2009, month=7, day=1,\n...                            hour=12, minute=30))\n>>> schedule = schedules()\n>>> schedule.add(activity)\n>>> schedule.add(status)\n>>> status in schedule\nTrue\n>>> activity in schedule\nTrue\n>>> duplicate_activity in schedule\nTrue\n>>> schedule.remove(activity)\n>>> schedule.remove(status)\n>>> status in schedule\nFalse\n>>> activity in schedule\nFalse\n```", "```py\n>>> activity1 = activities('test activity 1',\n...                        datetime(year=2009, month=6, day=1,\n...                                 hour=9, minute=5),\n...                        datetime(year=2009, month=6, day=1,\n...                                 hour=12, minute=30))\n>>> activity2 = activities('test activity 2',\n...                        datetime(year=2009, month=6, day=1,\n...                                 hour=10, minute=15),\n...                        datetime(year=2009, month=6, day=1,\n...                                 hour=13, minute=30))\n>>> schedule = schedules()\n>>> schedule.add(activity1)\n>>> schedule.add(activity2) # doctest:+ELLIPSIS\nTraceback (most recent call last):\nschedule_error: \"test activity 2\" overlaps with \"test activity 1\"\n```", "```py\n>>> activity1 = activities('test activity 1',\n...                        datetime(year=2009, month=6, day=1,\n...                                 hour=9, minute=5),\n...                        datetime(year=2009, month=6, day=1,\n...                                 hour=12, minute=30))\n>>> status1 = statuses('test status 1',\n...                    datetime(year=2009, month=6, day=1,\n...                             hour=10, minute=15),\n...                    datetime(year=2009, month=6, day=1,\n...                             hour=13, minute=30))\n>>> status2 = statuses('test status 2',\n...                    datetime(year=2009, month=6, day=1,\n...                             hour=8, minute=45),\n...                    datetime(year=2009, month=6, day=1,\n...                             hour=15, minute=30))\n>>> schedule = schedules()\n>>> schedule.add(activity1)\n>>> schedule.add(status1)\n>>> schedule.add(status2)\n>>> activity1 in schedule\nTrue\n>>> status1 in schedule\nTrue\n>>> status2 in schedule\nTrue\n```", "```py\n>>> from planner.persistence import file\n>>> storage = file(':memory:')\n>>> schedule.store(storage)\n>>> newsched = schedules.load(storage)\n>>> schedule == newsched\nTrue\n```", "```py\nfrom unittest import TestCase\nfrom mocker import MockerTestCase\nfrom planner.data import activities, task_error\nfrom datetime import datetime\n\nclass constructor_tests(TestCase):\n    def test_valid(self):\n        activity = activities('activity name',\n                              datetime(year=2007, month=9, day=11),\n                              datetime(year=2008, month=4, day=27))\n\n        self.assertEqual(activity.name, 'activity name')\n        self.assertEqual(activity.begins,\n                         datetime(year = 2007, month = 9, day = 11))\n        self.assertEqual(activity.ends,\n                         datetime(year = 2008, month = 4, day = 27))\n\n    def test_backwards_times(self):\n        self.assertRaises(task_error,\n                          activities,\n                          'activity name',\n                          datetime(year=2008, month=4, day=27),\n                          datetime(year=2007, month=9, day=11))\n\n    def test_too_short(self):\n        self.assertRaises(task_error,\n                          activities,\n                          'activity name',\n                          datetime(year = 2008, month = 4, day = 27,\n                                   hour = 7, minute = 15),\n                          datetime(year = 2008, month = 4, day = 27,\n                                   hour = 7, minute = 15))\n\nclass utility_tests(TestCase):\n    def test_repr(self):\n        activity = activities('activity name',\n                              datetime(year=2007, month=9, day=11),\n                              datetime(year=2008, month=4, day=27))\n\n        expected = \"<activity name 2007-09-11T00:00:00 2008-04-27T00:00:00>\"\n\n        self.assertEqual(repr(activity), expected)\n\nclass exclusivity_tests(TestCase):\n    def test_excludes(self):\n        activity = activities('activity name',\n                              datetime(year=2007, month=9, day=11),\n                              datetime(year=2007, month=10, day=6))\n\n        # Any activity should exclude any other activity\n        self.assertTrue(activity.excludes(activity))\n\n        # Anything not known to be excluded should be included\n        self.assertFalse(activity.excludes(None))\n\nclass overlap_tests(MockerTestCase):\n    def setUp(self):\n        pseudo = self.mocker.mock()\n\n        pseudo.begins\n        self.mocker.result(datetime(year=2007, month=10, day=7))\n        self.mocker.count(0, None)\n\n        pseudo.ends\n        self.mocker.result(datetime(year=2008, month=2, day=5))\n        self.mocker.count(0, None)\n\n        self.other = pseudo\n\n        self.mocker.replay()\n\n    def test_overlap_before(self):\n        activity = activities('activity name',\n                              datetime(year=2007, month=9, day=11),\n                              datetime(year=2007, month=10, day=6))\n\n        self.assertFalse(activity.overlaps(self.other))\n\n    def test_overlap_begin(self):\n        activity = activities('activity name',\n                              datetime(year=2007, month=8, day=11),\n                              datetime(year=2007, month=11, day=27))\n\n        self.assertTrue(activity.overlaps(self.other))\n\n    def test_overlap_end(self):\n        activity = activities('activity name',\n                              datetime(year=2008, month=1, day=11),\n                              datetime(year=2008, month=4, day=16))\n\n        self.assertTrue(activity.overlaps(self.other))\n\n    def test_overlap_inner(self):\n        activity = activities('activity name',\n                              datetime(year=2007, month=10, day=11),\n                              datetime(year=2008, month=1, day=27))\n\n        self.assertTrue(activity.overlaps(self.other))\n\n    def test_overlap_outer(self):\n        activity = activities('activity name',\n                              datetime(year=2007, month=8, day=12),\n                              datetime(year=2008, month=3, day=15))\n\n        self.assertTrue(activity.overlaps(self.other))\n\n    def test_overlap_after(self):\n        activity = activities('activity name',\n                              datetime(year=2008, month=2, day=6),\n                              datetime(year=2008, month=4, day=27))\n\n        self.assertFalse(activity.overlaps(self.other))\n```", "```py\n    def test_valid(self):\n        activity = activities('activity name',\n                              datetime(year=2007, month=9, day=11),\n                              datetime(year=2008, month=4, day=27))\n\n        self.assertEqual(activity.name, 'activity name')\n        self.assertEqual(activity.begins,\n                         datetime(year = 2007, month = 9, day = 11))\n        self.assertEqual(activity.ends,\n                         datetime(year = 2008, month = 4, day = 27))\n```", "```py\n    def test_backwards_times(self):\n        self.assertRaises(task_error,\n                          activities,\n                          'activity name',\n                          datetime(year=2008, month=4, day=27),\n                          datetime(year=2007, month=9, day=11))\n```", "```py\n    def test_too_short(self):\n        self.assertRaises(task_error,\n                          activities,\n                          'activity name',\n                          datetime(year = 2008, month = 4, day = 27,\n                                   hour = 7, minute = 15),\n                          datetime(year = 2008, month = 4, day = 27,\n                                   hour = 7, minute = 15))\n```", "```py\nclass utility_tests(TestCase):\n    def test_repr(self):\n        activity = activities('activity name',\n                              datetime(year=2007, month=9, day=11),\n                              datetime(year=2008, month=4, day=27))\n\n        expected = \"<activity name 2007-09-11T00:00:00 2008-04-27T00:00:00>\"\n\n        self.assertEqual(repr(activity), expected)\n```", "```py\nclass exclusivity_tests(TestCase):\n    def test_excludes(self):\n        activity = activities('activity name',\n                              datetime(year=2007, month=9, day=11),\n                              datetime(year=2007, month=10, day=6))\n\n        # Any activity should exclude any other activity\n        self.assertTrue(activity.excludes(activity))\n\n        # Anything not known to be excluded should be included\n        self.assertFalse(activity.excludes(None))\n```", "```py\nclass overlap_tests(MockerTestCase):\n    def setUp(self):\n        pseudo = self.mocker.mock()\n\n        pseudo.begins\n        self.mocker.result(datetime(year=2007, month=10, day=7))\n        self.mocker.count(0, None)\n\n        pseudo.ends\n        self.mocker.result(datetime(year=2008, month=2, day=5))\n        self.mocker.count(0, None)\n\n        self.other = pseudo\n\n        self.mocker.replay()\n```", "```py\n    def test_overlap_before(self):\n        activity = activities('activity name',\n                              datetime(year=2007, month=9, day=11),\n                              datetime(year=2007, month=10, day=6))\n\n        self.assertFalse(activity.overlaps(self.other))\n\n    def test_overlap_begin(self):\n        activity = activities('activity name',\n                              datetime(year=2007, month=8, day=11),\n                              datetime(year=2007, month=11, day=27))\n\n        self.assertTrue(activity.overlaps(self.other))\n\n    def test_overlap_end(self):\n        activity = activities('activity name',\n                              datetime(year=2008, month=1, day=11),\n                              datetime(year=2008, month=4, day=16))\n\n        self.assertTrue(activity.overlaps(self.other))\n\n    def test_overlap_inner(self):\n        activity = activities('activity name',\n                              datetime(year=2007, month=10, day=11),\n                              datetime(year=2008, month=1, day=27))\n\n        self.assertTrue(activity.overlaps(self.other))\n\n    def test_overlap_outer(self):\n        activity = activities('activity name',\n                              datetime(year=2007, month=8, day=12),\n                              datetime(year=2008, month=3, day=15))\n\n        self.assertTrue(activity.overlaps(self.other))\n\n    def test_overlap_after(self):\n        activity = activities('activity name',\n                              datetime(year=2008, month=2, day=6),\n                              datetime(year=2008, month=4, day=27))\n\n        self.assertFalse(activity.overlaps(self.other))\n```", "```py\nfrom unittest import TestCase\nfrom mocker import MockerTestCase\nfrom planner.data import statuses, task_error\nfrom datetime import datetime\n\nclass constructor_tests(TestCase):\n    def test_valid(self):\n        status = statuses('status name',\n                          datetime(year=2007, month=9, day=11),\n                          datetime(year=2008, month=4, day=27))\n\n        self.assertEqual(status.name, 'status name')\n        self.assertEqual(status.begins,\n                         datetime(year=2007, month=9, day=11))\n        self.assertEqual(status.ends,\n                         datetime(year=2008, month=4, day=27))\n\n    def test_backwards_times(self):\n        self.assertRaises(task_error,\n                          statuses,\n                          'status name',\n                          datetime(year=2008, month=4, day=27),\n                          datetime(year=2007, month=9, day=11))\n\n    def test_too_short(self):\n        self.assertRaises(task_error,\n                          statuses,\n                          'status name',\n                          datetime(year=2008, month=4, day=27,\n                                   hour=7, minute=15),\n                          datetime(year=2008, month=4, day=27,\n                                   hour=7, minute=15))\n\nclass utility_tests(TestCase):\n    def test_repr(self):\n        status = statuses('status name',\n                              datetime(year=2007, month=9, day=11),\n                              datetime(year=2008, month=4, day=27))\n\n        expected = \"<status name 2007-09-11T00:00:00 2008-04-27T00:00:00>\"\n\n        self.assertEqual(repr(status), expected)\n\nclass exclusivity_tests(TestCase):\n    def test_excludes(self):\n        status = statuses('status name',\n                          datetime(year=2007, month=9, day=11),\n                          datetime(year=2007, month=10, day=6))\n\n        # A status shouldn't exclude anything\n        self.assertFalse(status.excludes(status))\n        self.assertFalse(status.excludes(None))\n\nclass overlap_tests(MockerTestCase):\n    def setUp(self):\n        pseudo = self.mocker.mock()\n\n        pseudo.begins\n        self.mocker.result(datetime(year=2007, month=10, day=7))\n        self.mocker.count(1, None)\n\n        pseudo.ends\n        self.mocker.result(datetime(year=2008, month=2, day=5))\n        self.mocker.count(1, None)\n\n        self.other = pseudo\n\n        self.mocker.replay()\n\n    def test_overlap_before(self):\n        status = statuses('status name',\n                          datetime(year=2007, month=9, day=11),\n                          datetime(year=2007, month=10, day=6))\n\n        self.assertFalse(status.overlaps(self.other))\n\n    def test_overlap_begin(self):\n        status = statuses('status name',\n                          datetime(year=2007, month=8, day=11),\n                          datetime(year=2007, month=11, day=27))\n\n        self.assertTrue(status.overlaps(self.other))\n\n    def test_overlap_end(self):\n        status = statuses('status name',\n                          datetime(year=2008, month=1, day=11),\n                          datetime(year=2008, month=4, day=16))\n\n        self.assertTrue(status.overlaps(self.other))\n\n    def test_overlap_inner(self):\n        status = statuses('status name',\n                          datetime(year=2007, month=10, day=11),\n                          datetime(year=2008, month=1, day=27))\n\n        self.assertTrue(status.overlaps(self.other))\n\n    def test_overlap_outer(self):\n        status = statuses('status name',\n                          datetime(year=2007, month=8, day=12),\n                          datetime(year=2008, month=3, day=15))\n\n        self.assertTrue(status.overlaps(self.other))\n\n    def test_overlap_after(self):\n        status = statuses('status name',\n                          datetime(year=2008, month=2, day=6),\n                          datetime(year=2008, month=4, day=27))\n\n        self.assertFalse(status.overlaps(self.other))\n```", "```py\nclass exclusivity_tests(TestCase):\n    def test_excludes(self):\n        status = statuses('status name',\n                          datetime(year=2007, month=9, day=11),\n                          datetime(year=2007, month=10, day=6))\n\n        # A status shouldn't exclude anything\n        self.assertFalse(status.excludes(status))\n        self.assertFalse(status.excludes(None))\n```", "```py\nfrom unittest import TestCase\nfrom mocker import MockerTestCase, ANY\nfrom planner.data import schedules, schedule_error\nfrom datetime import datetime\n\nclass add_tests(MockerTestCase):\n    def setUp(self):\n\n        overlap_exclude = self.mocker.mock()\n        overlap_exclude.overlaps(ANY)\n        self.mocker.result(True)\n        self.mocker.count(0, None)\n        overlap_exclude.excludes(ANY)\n        self.mocker.result(True)\n        self.mocker.count(0, None)\n\n        overlap_include = self.mocker.mock()\n        overlap_include.overlaps(ANY)\n        self.mocker.result(True)\n        self.mocker.count(0, None)\n        overlap_include.excludes(ANY)\n        self.mocker.result(False)\n        self.mocker.count(0, None)\n\n        distinct_exclude = self.mocker.mock()\n        distinct_exclude.overlaps(ANY)\n        self.mocker.result(False)\n        self.mocker.count(0, None)\n        distinct_exclude.excludes(ANY)\n        self.mocker.result(True)\n        self.mocker.count(0, None)\n\n        distinct_include = self.mocker.mock()\n        distinct_include.overlaps(ANY)\n        self.mocker.result(False)\n        self.mocker.count(0, None)\n        distinct_include.excludes(ANY)\n        self.mocker.result(False)\n        self.mocker.count(0, None)\n\n        self.overlap_exclude = overlap_exclude\n        self.overlap_include = overlap_include\n        self.distinct_exclude = distinct_exclude\n        self.distinct_include = distinct_include\n\n        self.mocker.replay()\n\n    def test_add_overlap_exclude(self):\n        schedule = schedules()\n        schedule.add(self.distinct_include)\n        self.assertRaises(schedule_error,\n                          schedule.add,\n                          self.overlap_exclude)\n\n    def test_add_overlap_include(self):\n        schedule = schedules()\n        schedule.add(self.distinct_include)\n        schedule.add(self.overlap_include)\n\n    def test_add_distinct_exclude(self):\n        schedule = schedules()\n        schedule.add(self.distinct_include)\n        schedule.add(self.distinct_exclude)\n    def test_add_distinct_include(self):\n        schedule = schedules()\n        schedule.add(self.distinct_include)\n        schedule.add(self.distinct_include)\n\n    def test_add_over_overlap_exclude(self):\n        schedule = schedules()\n        schedule.add(self.overlap_exclude)\n        self.assertRaises(schedule_error,\n                          schedule.add,\n                          self.overlap_include)\n\n    def test_add_over_distinct_exclude(self):\n        schedule = schedules()\n        schedule.add(self.distinct_exclude)\n        self.assertRaises(schedule_error,\n                          schedule.add,\n                          self.overlap_include)\n\n    def test_add_over_overlap_include(self):\n        schedule = schedules()\n        schedule.add(self.overlap_include)\n        schedule.add(self.overlap_include)\n\n    def test_add_over_distinct_include(self):\n        schedule = schedules()\n        schedule.add(self.distinct_include)\n        schedule.add(self.overlap_include)\n\nclass in_tests(MockerTestCase):\n    def setUp(self):\n        fake = self.mocker.mock()\n        fake.overlaps(ANY)\n        self.mocker.result(True)\n        self.mocker.count(0, None)\n        fake.excludes(ANY)\n        self.mocker.result(True)\n        self.mocker.count(0, None)\n\n        self.fake = fake\n\n        self.mocker.replay()\n\n    def test_in_before_add(self):\n        schedule = schedules()\n        self.assertFalse(self.fake in schedule)\n\n    def test_in_after_add(self):\n        schedule = schedules()\n        schedule.add(self.fake)\n        self.assertTrue(self.fake in schedule)\n```", "```py\n    def setUp(self):\n\n        overlap_exclude = self.mocker.mock()\n        overlap_exclude.overlaps(ANY)\n        self.mocker.result(True)\n        self.mocker.count(0, None)\n        overlap_exclude.excludes(ANY)\n        self.mocker.result(True)\n        self.mocker.count(0, None)\n\n        overlap_include = self.mocker.mock()\n        overlap_include.overlaps(ANY)\n        self.mocker.result(True)\n        self.mocker.count(0, None)\n        overlap_include.excludes(ANY)\n        self.mocker.result(False)\n        self.mocker.count(0, None)\n\n        distinct_exclude = self.mocker.mock()\n        distinct_exclude.overlaps(ANY)\n        self.mocker.result(False)\n        self.mocker.count(0, None)\n        distinct_exclude.excludes(ANY)\n        self.mocker.result(True)\n        self.mocker.count(0, None)\n\n        distinct_include = self.mocker.mock()\n        distinct_include.overlaps(ANY)\n        self.mocker.result(False)\n        self.mocker.count(0, None)\n        distinct_include.excludes(ANY)\n        self.mocker.result(False)\n        self.mocker.count(0, None)\n\n        self.overlap_exclude = overlap_exclude\n        self.overlap_include = overlap_include\n        self.distinct_exclude = distinct_exclude\n        self.distinct_include = distinct_include\n\n        self.mocker.replay()\n```", "```py\n    def test_add_overlap_exclude(self):\n        schedule = schedules()\n        schedule.add(self.distinct_include)\n        self.assertRaises(schedule_error,\n                          schedule.add,\n                          self.overlap_exclude)\n\n    def test_add_overlap_include(self):\n        schedule = schedules()\n        schedule.add(self.distinct_include)\n        schedule.add(self.overlap_include)\n\n    def test_add_distinct_exclude(self):\n        schedule = schedules()\n        schedule.add(self.distinct_include)\n        schedule.add(self.distinct_exclude)\n\n    def test_add_distinct_include(self):\n        schedule = schedules()\n        schedule.add(self.distinct_include)\n        schedule.add(self.distinct_include)\n```", "```py\n    def test_add_over_overlap_exclude(self):\n        schedule = schedules()\n        schedule.add(self.overlap_exclude)\n        self.assertRaises(schedule_error,\n                          schedule.add,\n                          self.overlap_include)\n```", "```py\n    def test_add_over_distinct_exclude(self):\n        schedule = schedules()\n        schedule.add(self.distinct_exclude)\n        self.assertRaises(schedule_error,\n                          schedule.add,\n                          self.overlap_include)\n```", "```py\n    def test_add_over_overlap_include(self):\n        schedule = schedules()\n        schedule.add(self.overlap_include)\n        schedule.add(self.overlap_include)\n\n    def test_add_over_distinct_include(self):\n        schedule = schedules()\n        schedule.add(self.distinct_include)\n        schedule.add(self.overlap_include)\n```", "```py\nclass in_tests(MockerTestCase):\n    def setUp(self):\n        fake = self.mocker.mock()\n        fake.overlaps(ANY)\n        self.mocker.result(True)\n        self.mocker.count(0, None)\n        fake.excludes(ANY)\n        self.mocker.result(True)\n        self.mocker.count(0, None)\n\n        self.fake = fake\n\n        self.mocker.replay()\n\n    def test_in_before_add(self):\n        schedule = schedules()\n        self.assertFalse(self.fake in schedule)\n\n    def test_in_after_add(self):\n        schedule = schedules()\n        schedule.add(self.fake)\n        self.assertTrue(self.fake in schedule)\n```", "```py\nfrom datetime import timedelta\n\nclass task_error(Exception):\n    pass\n\nclass schedule_error(Exception):\n    pass\n\nclass _tasks:\n    def __init__(self, name, begins, ends):\n        if ends < begins:\n            raise task_error('The begin time must precede the end time')\n        if ends - begins < timedelta(minutes = 5):\n            raise task_error('The minimum duration is 5 minutes')\n\n        self.name = name\n        self.begins = begins\n        self.ends = ends\n\n    def excludes(self, other):\n        raise NotImplemented('Abstract method. Use a child class.')\n\n    def overlaps(self, other):\n        if other.begins < self.begins:\n            return other.ends > self.begins\n        elif other.ends > self.ends:\n            return other.begins < self.ends\n        else:\n            return True\n\n    def __repr__(self):\n        return ''.join(['<', self.name,\n                        ' ', self.begins.isoformat(),\n                        ' ', self.ends.isoformat(),\n                        '>'])\n\nclass activities(_tasks):\n    def excludes(self, other):\n        return isinstance(other, activities)\n\nclass statuses(_tasks):\n    def excludes(self, other):\n        return False\n\nclass schedules:\n    def __init__(self, name='schedule'):\n        self.tasks = []\n        self.name = name\n    def add(self, task):\n        for contained in self.tasks:\n            if task.overlaps(contained):\n                if task.exclude(contained) or contained.exclude(task):\n                    raise schedule_error(task, containeed)\n\n        self.tasks.append(task)\n\n    def remove(self, task):\n        try:\n            self.tasks.remove(task)\n        except ValueError:\n            pass\n\n    def __contains__(self, task):\n        return task in self.tasks\n```", "```py\nclass _tasks:\n    def __init__(self, name, begins, ends):\n        if ends < begins:\n            raise task_error('The begin time must precede the end time')\n        if ends - begins < timedelta(minutes = 5):\n            raise task_error('The minimum duration is 5 minutes')\n\n        self.name = name\n        self.begins = begins\n        self.ends = ends\n\n    def excludes(self, other):\n        raise NotImplemented('Abstract method. Use a child class.')\n\n    def overlaps(self, other):\n        if other.begins < self.begins:\n            return other.ends > self.begins\n        elif other.ends > self.ends:\n            return other.begins < self.ends\n        else:\n            return True\n\n    def __repr__(self):\n        return ''.join(['<', self.name,\n                        ' ', self.begins.isoformat(),\n                        ' ', self.ends.isoformat(),\n                        '>'])\n```", "```py\nclass activities(_tasks):\n    def excludes(self, other):\n        return isinstance(other, activities)\n\nclass statuses(_tasks):\n    def excludes(self, other):\n        return False\n\nclass schedules:\n    def __init__(self, name='schedule'):\n        self.tasks = []\n        self.name = name\n\n    def add(self, task):\n        for contained in self.tasks:\n            if task.overlaps(contained):\n                if task.exclude(contained) or contained.exclude(task):\n                    raise schedule_error(task, containeed)\n\n        self.tasks.append(task)\n\n    def remove(self, task):\n        try:\n            self.tasks.remove(task)\n        except ValueError:\n            pass\n\n    def __contains__(self, task):\n        return task in self.tasks\n```", "```py\n    def __eq__(self, other):\n        return self.name == other.name and self.begins == other.begins and self.ends == other.ends\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n```", "```py\n    def add(self, task):\n        for contained in self.tasks:\n            if task.overlaps(contained):\n                if task.excludes(contained) or contained.excludes(task):\n                    raise schedule_error(task, containeed)\n\n        self.tasks.append(task)\n```", "```py\n                    raise schedule_error(task, contained)\n```", "```py\n           raise schedule_error('\"%s\" overlaps with \"%s\"' %\n                                (task.name, contained.name))\n```", "```py\n    def setUp(self):\n\n        overlap_exclude = self.mocker.mock()\n        overlap_exclude.overlaps(ANY)\n        self.mocker.result(True)\n        self.mocker.count(0, None)\n        overlap_exclude.excludes(ANY)\n        self.mocker.result(True)\n        self.mocker.count(0, None)\n        overlap_exclude.name\n self.mocker.result('overlap_exclude')\n self.mocker.count(0, None)\n\n        overlap_include = self.mocker.mock()\n        overlap_include.overlaps(ANY)\n        self.mocker.result(True)\n        self.mocker.count(0, None)\n        overlap_include.excludes(ANY)\n        self.mocker.result(False)\n        self.mocker.count(0, None)\n        overlap_include.name\n self.mocker.result('overlap_include')\n self.mocker.count(0, None)\n\n        distinct_exclude = self.mocker.mock()\n        distinct_exclude.overlaps(ANY)\n        self.mocker.result(False)\n        self.mocker.count(0, None)\n        distinct_exclude.excludes(ANY)\n        self.mocker.result(True)\n        self.mocker.count(0, None)\n        distinct_exclude.name\n                self.mocker.result('distinct_exclude')\n self.mocker.count(0, None)\n\n        distinct_include = self.mocker.mock()\n        distinct_include.overlaps(ANY)\n        self.mocker.result(False)\n        self.mocker.count(0, None)\n        distinct_include.excludes(ANY)\n        self.mocker.result(False)\n        self.mocker.count(0, None)\n        distinct_include.name\n self.mocker.result('distinct_include')\n self.mocker.count(0, None)\n\n        self.overlap_exclude = overlap_exclude\n        self.overlap_include = overlap_include\n        self.distinct_exclude = distinct_exclude\n        self.distinct_include = distinct_include\n\n        self.mocker.replay()\n```", "```py\n     $ nosetests\n\n    ```", "```py\nfrom unittest import TestCase\nfrom mocker import MockerTestCase\nfrom planner.persistence import file\n\nclass test_file(TestCase):\n    def test_basic(self):\n        storage = file(':memory:')\n        storage.store_object('tag1', ('some object',))\n        self.assertEqual(tuple(storage.load_objects('tag1')),\n                         (('some object',),))\n\n    def test_multiple_tags(self):\n        storage = file(':memory:')\n\n        storage.store_object('tag1', 'A')\n        storage.store_object('tag2', 'B')\n        storage.store_object('tag1', 'C')\n        storage.store_object('tag1', 'D')\n        storage.store_object('tag3', 'E')\n        storage.store_object('tag3', 'F')\n\n        self.assertEqual(set(storage.load_objects('tag1')),\n                         set(['A', 'C', 'D']))\n\n        self.assertEqual(set(storage.load_objects('tag2')),\n                         set(['B']))\n\n        self.assertEqual(set(storage.load_objects('tag3')),\n                         set(['E', 'F']))\n```", "```py\n    def test_basic(self):\n        storage = file(':memory:')\n        storage.store_object('tag1', ('some object',))\n        self.assertEqual(tuple(storage.load_objects('tag1')),\n                         (('some object',),))\n```", "```py\n    def test_multiple_tags(self):\n        storage = file(':memory:')\n\n        storage.store_object('tag1', 'A')\n        storage.store_object('tag2', 'B')\n        storage.store_object('tag1', 'C')\n        storage.store_object('tag1', 'D')\n        storage.store_object('tag3', 'E')\n        storage.store_object('tag3', 'F')\n\n        self.assertEqual(set(storage.load_objects('tag1')),\n                         set(['A', 'C', 'D']))\n\n        self.assertEqual(set(storage.load_objects('tag2')),\n                         set(['B']))\n\n        self.assertEqual(set(storage.load_objects('tag3')),\n                         set(['E', 'F']))\n```", "```py\nimport sqlite3\nfrom cPickle import loads, dumps\n\nclass file:\n    def __init__(self, path):\n        self.connection = sqlite3.connect(path)\n\n        try:\n            self.connection.execute(\"\"\"\n                create table objects (tag, pickle)\n            \"\"\")\n        except sqlite3.OperationalError:\n            pass\n\n    def store_object(self, tag, object):\n        self.connection.execute('insert into objects values (?, ?)',\n                                (tag, dumps(object)))\n\n    def load_objects(self, tag):\n        cursor = self.connection.execute(\"\"\"\n                     select pickle from objects where tag like ?\n                 \"\"\", (tag,))\n        return [loads(row[0]) for row in cursor]\n```", "```py\n    def store_object(self, tag, object):\n        self.connection.execute('insert into objects values (?, ?)',\n                               (tag, sqlite3.Binary(dumps(object))))\n\n    def load_objects(self, tag):\n        cursor = self.connection.execute(\"\"\"\n                     select pickle from objects where tag like ?\n                 \"\"\", (tag,))\n        return [loads(str(row[0])) for row in cursor]\n\n```", "```py\nfrom mocker import MockerTestCase, ANY, IN\nâ€¦\nclass store_load_tests(MockerTestCase):\n    def setUp(self):\n        fake_tasks = []\n        for i in range(50):\n            fake_task = self.mocker.mock()\n            fake_task.overlaps(ANY)\n            self.mocker.result(False)\n            self.mocker.count(0, None)\n            fake_task.name\n            self.mocker.result('fake %d' % i)\n            self.mocker.count(0, None)\n            fake_tasks.append(fake_task)\n\n        self.tasks = fake_tasks\n\n    def test_store(self):\n        fake_file = self.mocker.mock()\n\n        fake_file.store_object('test_schedule', IN(self.tasks))\n        self.mocker.count(len(self.tasks))\n\n        self.mocker.replay()\n\n        schedule = schedules('test_schedule')\n        for task in self.tasks:\n            schedule.add(task)\n\n        schedule.store(fake_file)\n\n    def test_load(self):\n        fake_file = self.mocker.mock()\n\n        fake_file.load_objects('test_schedule')\n        self.mocker.result(self.tasks)\n        self.mocker.count(1)\n\n        self.mocker.replay()\n\n        schedule = schedules.load(fake_file, 'test_schedule')\n\n        self.assertEqual(set(schedule.tasks),\n                         set(self.tasks))\n```", "```py\n    def store(self, storage):\n        for task in self.tasks:\n            storage.store_object(self.name, task)\n\n    @staticmethod\n    def load(storage, name = 'schedule'):\n        value = schedules(name)\n\n        for task in storage.load_objects(name):\n            value.add(task)\n\n        return value\n```", "```py\n    def __eq__(self, other):\n        if len(self.tasks) != len(other.tasks):\n            return False\n\n        left_tasks = list(self.tasks)\n        left_tasks.sort(key = (lambda task: task.begins))\n        right_tasks = list(other.tasks)\n        right_tasks.sort(key = (lambda task: task.begins))\n        return tuple(left_tasks) == tuple(right_tasks)\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n```"]