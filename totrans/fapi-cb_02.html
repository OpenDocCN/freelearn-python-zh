<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-52"><a id="_idTextAnchor052"/>2</h1>
<h1 id="_idParaDest-53"><a id="_idTextAnchor053"/>Working with Data</h1>
<p><strong class="bold">Data handling</strong> is the <a id="_idIndexMarker059"/>backbone of any web application, and this chapter is dedicated to mastering this critical aspect. You will embark on a journey of working with data in FastAPI, where you’ll learn the intricacies of integrating, managing, and optimizing data storage using<a id="_idIndexMarker060"/> both <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) and <strong class="bold">NoSQL</strong> databases. We’ll cover how FastAPI, combined with powerful database tools, can create efficient and scalable data management solutions.</p>
<p>Starting with SQL databases, you’ll get hands-on experience in setting up a database, implementing <strong class="bold">create, read, update and delete</strong> (<strong class="bold">CRUD</strong>) operations, and understanding the nuances of working with SQLAlchemy – a popular <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) option for Python. We’ll then shift gears <a id="_idIndexMarker061"/>to NoSQL databases, delving into the world of <strong class="bold">MongoDB.</strong> You’ll learn how to integrate it with FastAPI, handle dynamic data structures, and leverage the flexibility and scalability of NoSQL solutions.</p>
<p>But it’s not just about storing and retrieving data. This chapter also focuses on best practices for securing sensitive data and managing transactions and concurrency in your databases. You’ll explore how to protect your data from vulnerabilities and ensure the integrity and consistency of your application’s data operations.</p>
<p>By the end of this chapter, you’ll not only have a solid understanding of how to work with various database systems in FastAPI but also the skills to build robust and secure data models for your web applications. Whether it’s implementing complex queries, optimizing database performance, or ensuring data security, this chapter provides the tools and knowledge you need to manage your application’s data effectively.</p>
<p>In this chapter, we’re going to cover the following recipes:</p>
<ul>
<li>Setting up SQL databases</li>
<li>Understanding CRUD operations with SQLAlchemy</li>
<li>Integrating MongoDB for NoSQL data storage</li>
<li>Working with data validation and serialization</li>
<li>Working with file uploads and downloads</li>
<li>Handling asynchronous data operations</li>
<li>Securing sensitive data and best practices</li>
</ul>
<p>Each topic is designed to equip you with the necessary skills and knowledge to handle data in FastAPI efficiently, ensuring your applications are not only functional but also secure and scalable.</p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor054"/>Technical requirements</h1>
<p>To effectively run and understand the code in this chapter, ensure you have the following set up. If you’ve followed <a href="B21025_01.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, <em class="italic">First Steps with FastAPI</em>, you should already have some of these installed:</p>
<ul>
<li><strong class="bold">Python</strong>: Make sure you’ve<a id="_idIndexMarker062"/> installed Python version 3.9 or higher on your computer.</li>
<li><code>pip install fastapi[all]</code> command. As we saw in <a href="B21025_01.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, <em class="italic">First Steps with FastAPI</em>, this command also installs <strong class="bold">Uvicorn</strong>, an ASGI server that’s necessary to run your FastAPI application.</li>
<li><strong class="bold">Integrated development environment</strong> (<strong class="bold">IDE</strong>): A suitable IDE such as <strong class="bold">VS Code</strong> or <strong class="bold">PyCharm</strong> should be installed. These IDEs offer excellent support for Python and FastAPI development, providing features such as syntax highlighting, code completion, and easy debugging.</li>
<li><strong class="bold">MongoDB</strong>: For the NoSQL database portions of this chapter, MongoDB needs to be installed on your local machine. Download and install the free community version server suitable for your operating system <a id="_idTextAnchor055"/>from <a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a>.<p class="list-inset">Make sure that MongoDB is correctly installed by running from the command line the Mongo Deamon:</p><pre class="source-code">
<code>C:\Program&gt;Files\MongoDB\Server\7.0\bin</code>. You need to open the terminal in this location to run the daemon or run:</p><pre class="source-code"><strong class="bold">$ C:\Program&gt;Files\MongoDB\Server\7.0\bin\mongod -- version</strong></pre></li> <li><strong class="bold">MongoDB tools</strong>: While optional, tools such as<a id="_idIndexMarker064"/> the <strong class="bold">MongoDB Shell</strong> (<a href="https://www.mongodb.com/try/download/shell">https://www.mongodb.com/try/download/shell</a>) and <strong class="bold">MongoDB Compass GUI</strong> (<a href="https://www.mongodb.com/try/download/compass">https://www.mongodb.com/try/download/compass</a>) can greatly enhance <a id="_idIndexMarker065"/>your interaction with the MongoDB server. They provide a more user-friendly interface for managing databases, running queries, and visualizing data structures.</li>
</ul>
<p>All the code and examples used throughout this chapter are available on GitHub for reference and download. Visit <a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter02">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter02</a> on GitHub to access the repository.</p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor056"/>Setting up SQL databases</h1>
<p>In the world of data <a id="_idIndexMarker066"/>handling, the power of Python meets the efficiency of SQL databases. This recipe aims to introduce you to how to integrate SQL databases within your application, a crucial skill for any developer looking to build robust and scalable web applications.</p>
<p>SQL is the standard language for managing and manipulating relational databases. When combined with FastAPI, it unlocks a world of possibilities in data storage and retrieval.</p>
<p>FastAPI’s compatibility with SQL databases is facilitated through ORMs. The most popular one<a id="_idIndexMarker067"/> is <strong class="bold">SQLAlchemy</strong>. We will focus on it in this recipe.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor057"/>Getting ready</h2>
<p>To begin, you’ll need to have FastAPI and SQLAlchemy installed in your virtual environment. If you followed the steps in <a href="B21025_01.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, <em class="italic">First Steps with FastAPI</em>, you should have FastAPI already set up. For SQLAlchemy, a simple <code>pip</code> command is all that’s needed:</p>
<pre class="console">
$ pip install sqlalchemy</pre> <p>Once installed, the next step is to configure SQLAlchemy so that it can work with FastAPI. This involves setting up the database connection – a process we will walk through step by step.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor058"/>How to do it…</h2>
<p>Now, let’s dive deeper into configuring SQLAlchemy for your FastAPI application. SQLAlchemy acts as the bridge between your Python code and the database, allowing you to interact with the database using Python classes and objects rather than writing raw SQL queries.</p>
<p>After installing SQLAlchemy, the next step is to configure it within your FastAPI application. This involves defining your database models – a representation of your database tables in <a id="_idIndexMarker068"/>Python code. In SQLAlchemy, models are typically defined using classes, with each class corresponding to a table in the database, and each attribute of the class corresponding to a column in the table.</p>
<p>Follow these steps to go through the process.</p>
<ol>
<li>Create a new folder called <code>sql_example</code>, move inside it, and then create a file called <code>database.py</code> there. Write a <code>base</code> class to be used as a reference:<pre class="source-code">
from sqlalchemy.orm import DeclarativeBase
class Base(DeclarativeBase):
    pass</pre><p class="list-inset">To define a model in SQLAlchemy, you need to create a base class that derives from the <code>DeclarativeBase</code> class. This <code>Base</code> class maintains a catalog of classes and tables you’ve defined and is central to SQLAlchemy’s ORM functionality.</p><p class="list-inset">You can learn more by reading the official documentation: <a href="https://docs.sqlalchemy.org/en/13/orm/extensions/declarative/index.xhtml">https://docs.sqlalchemy.org/en/13/orm/extensions/declarative/index.xhtml</a>.</p></li> <li>Once you have your <code>Base</code> class, you can start defining your models. For instance, if you have a table for users, your model might look something like this:<pre class="source-code">
from sqlalchemy.orm import (
    Mapped,
    mapped_column
)
class User(Base):
    __tablename__ = "user"
    id: Mapped[int] = mapped_column(
        primary_key=True,
    )
    name: Mapped[str]
    email: Mapped[str]</pre><p class="list-inset">In this model, <code>User</code> class corresponds to a table named <code>user</code> in the database, with columns for <code>id</code>, <code>name</code>, and <code>email</code>. Each <code>class attribute</code> specifies the data type of the <a id="_idIndexMarker069"/>column.</p></li> <li>Once your models have been defined, the next step is to connect to the database and create these tables. SQLAlchemy uses a connection string to define the details of the database it needs to connect to. The format of this connection string varies depending on the database system you are using.<p class="list-inset">For example, a connection string for a SQLite database might look like this:</p><pre class="source-code">
DATABASE_URL = "sqlite:///./test.db"</pre><p class="list-inset"><code>test.db</code> database file the first time you connect to it.<p class="list-inset">You will use the <code>DATABASE_URL</code> connection string to create an <code>Engine</code> object in SQLAlchemy that represents the core interface to the database:</p><pre class="source-code">
from sqlalchemy import create_engine
engine = create_engine(DATABASE_URL)</pre></li> <li>With the engine created, you can proceed to create your tables in the database. You can do this by passing your <code>base</code> class and the engine to SQLAlchemy’s <code>create_all</code> method:<pre class="source-code">
Base.metadata.create_all(bind=engine)</pre></li> </ol>
<p>Now that you’ve<a id="_idIndexMarker071"/> defined all the abstractions of the database in your code, you can proceed with setting the database connection.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor059"/>Establishing a database connection</h2>
<p>The final part of <a id="_idIndexMarker072"/>setting up a SQL database setup is establishing a database connection. This connection allows your application to communicate with the database, executing queries and retrieving data.</p>
<p>Database connections are managed with sessions. A session in SQLAlchemy represents a <em class="italic">workspace</em> for your objects, a place where you can add new records or fetch existing ones. Each session is bound to a single database connection.</p>
<p>To manage sessions, we need to create a <code>SessionLocal</code> class. This class will be used to create and manage session objects for the interactions with the database. Here’s how you can create it:</p>
<pre class="source-code">
from sqlalchemy.orm import sessionmaker
SessionLocal = sessionmaker(
    autocommit=False, autoflush=False, bind=engine
)</pre> <p>The <code>sessionmaker</code> function creates a factory for sessions. The <code>autocommit</code> and <code>autoflush</code> parameters are set to <code>False</code>, meaning you have to manually commit transactions and manage them when your changes are flushed to the database.</p>
<p>With the <code>SessionLocal</code> class in place, you can create a function that will be used in your FastAPI route functions to get a new database session. We can create it in the <code>main.py</code> module<a id="_idIndexMarker073"/> like so:</p>
<pre class="source-code">
from database import SessionLocal
def get_db()
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()</pre> <p>In your route functions, you can use this function as a dependency to communicate with the database.</p>
<p>In FastAPI, this can be done with the <code>Depends</code> class. In the <code>main.py</code> file, you can then add an endpoint:</p>
<pre class="source-code">
from fastapi import Depends, FastAPI
from sqlalchemy.orm import Session
from database import SessionLocal
app = FastAPI()
@app.get("/users/")
def read_users(db: Session = Depends(get_db)):
    users = db.query(User).all()
    return users</pre> <p>This approach ensures that a new session is created for each request and closed when the request is finished, which is crucial for maintaining the integrity of your database transactions.</p>
<p>You can then run the server with the following command:</p>
<pre class="console">
$ uvicorn main:app –-reload</pre> <p>If you try to call the endpoint <code>GET</code> at <code>localhost:8000/users</code> you will get an empty list since no <a id="_idIndexMarker074"/>users have been added already.</p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor060"/>See also</h2>
<p>You can discover more on how to <a id="_idIndexMarker075"/>set up a session in <strong class="bold">SQLAlchemy</strong> on the documentation page:</p>
<ul>
<li><em class="italic">SQLAlchemy </em><em class="italic">session</em>: <a href="https://docs.sqlalchemy.org/en/20/orm/session_basics.xhtml">https://docs.sqlalchemy.org/en/20/orm/session_basics.xhtml</a><a href="https://docs.sqlalchemy.org/en/20/orm/session_basics.xhtml%0D"/></li>
</ul>
<h1 id="_idParaDest-60"><a id="_idTextAnchor061"/>Understanding CRUD operations with SQLAlchemy</h1>
<p>After setting up your <a id="_idIndexMarker076"/>SQL database with FastAPI, the next<a id="_idIndexMarker077"/> crucial step is creating database models. This process is central to how your application interacts with the database. <strong class="bold">Database models</strong> in <a id="_idIndexMarker078"/>SQLAlchemy are essentially Python classes that represent tables in your SQL database. They provide a high-level, object-oriented interface to manipulate database records as if they were regular Python objects.</p>
<p>In this recipe, we will set<a id="_idIndexMarker079"/> up the <strong class="bold">create, read, update and delete</strong> (<strong class="bold">CRUD</strong>) endpoints to interact with the database.</p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor062"/>Getting ready</h2>
<p>With the models set up, you can now implement CRUD operations. These operations form the backbone of most web applications, allowing you to interact with the database.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor063"/>How to do it…</h2>
<p>For each operation, we <a id="_idIndexMarker080"/>will create a dedicated endpoint <a id="_idIndexMarker081"/>implementing the interacting operation with the database.</p>
<h3>Creating a new user</h3>
<p>To add a new<a id="_idIndexMarker082"/> user, we’ll use a <code>POST</code> request. In the <code>main.py</code> file, we must define an endpoint that receives user data, creates a new <code>User</code> instance in the body request, and adds it to the database:</p>
<pre class="source-code">
class UserBody(BaseModel):
    name: str
    email: str
@app.post("/user")
def add_new_user(
    user: UserBody,
    db: Session = Depends(get_db)
):
    new_user = User(
        name=user.name,
        email=user.email
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user</pre> <p>In a few lines, you’ve <a id="_idIndexMarker083"/>created the endpoint to add a new user to the database.</p>
<h3>Reading a specific user</h3>
<p>To get a single <a id="_idIndexMarker084"/>user, we are going to use a <code>GET</code> endpoint:</p>
<pre class="source-code">
from fastapi import HTTPException
@app.get("/user")
def get_user(
    user_id: int,
    db: Session = Depends(get_db)
    ):
    user = (
        db.query(User).filter(
            User.id == user_id
        ).first()
    )
    if user is None:
        raise HTTPException(
            status_code=404,
            detail="User not found"
        )
    return user</pre> <p>The endpoint will <a id="_idIndexMarker085"/>return a <code>404</code> response status if the user does not exist.</p>
<h3>Updating a user</h3>
<p>Updating a record<a id="_idIndexMarker086"/> via an API offers various approaches, including <code>PUT</code>, <code>PATCH</code>, or <code>POST</code> methods. Despite theoretical nuances, the choice of method often boils down to personal preference. I favor using a <code>POST</code> request and augmenting the <code>/user</code> endpoint with a <code>user_id</code> parameter. This simplifies the process, minimizing the need for extensive memorization. You can integrate this endpoint within the <code>main.py</code> module like so:</p>
<pre class="source-code">
@app.post("/user/{user_id}")
def update_user(
    user_id: int,
    user: UserBody,
    db: Session = Depends(get_db),
):
    db_user = (
        db.query(User).filter(
            User.id == user_id
        ).first()
    )
    if db_user is None:
        raise HTTPException(
            status_code=404,
            detail="User not found"
        )
    db_user.name = user.name
    db_user.email = user.email
    db.commit()
    db.refresh(db_user)
    return db_user</pre> <p>This is all you need to <a id="_idIndexMarker087"/>do to create the endpoint to update a user record in the database.</p>
<h3>Deleting a user</h3>
<p>To conclude, deleting a <a id="_idIndexMarker088"/>user within the same <code>main.py</code> module involves utilizing a <code>DELETE</code> request, as shown here:</p>
<pre class="source-code">
@app.delete("/user")
def delete_user(
    user_id: int, db: Session = Depends(get_db)
):
    db_user = (
        db.query(User).filter(
            User.id == user_id
        ).first()
    )
    if db_user is None:
        raise HTTPException(
            status_code=404,
            detail="User not found"
        )
    db.delete(db_user)
    db.commit()
    return {"detail": "User deleted"}</pre> <p>These endpoints cover the basic CRUD operations and demonstrate how FastAPI can be integrated with SQLAlchemy for database operations. By defining these endpoints, your application can create, retrieve, update, and delete user data, providing a fully functional API for client interactions.</p>
<p>Now that you have implemented all the operations, you can spin the server by running:</p>
<pre class="console">
$ uvicorn main:app</pre> <p>Then open the inreactive documentation at <code>http://localhost:8000/docs</code> and start playing with the endpoints by creating, reading, updating and deleting users.</p>
<p>Mastering these CRUD operations in FastAPI is a significant step in building dynamic and data-driven web applications. With the knowledge of how to integrate FastAPI endpoints with <a id="_idIndexMarker089"/>SQLAlchemy models, you are well-equipped to develop complex and efficient applications.</p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor064"/>See also</h2>
<p>You can find a clear quick start on how to set up the ORM for CRUD operations with SQLAlchemy on the <a id="_idIndexMarker090"/>official documentation page:</p>
<ul>
<li><em class="italic">SQLAlchemy ORM Quick </em><em class="italic">Start</em>: <a href="https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml">https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml</a><a href="https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml%0D"/></li>
</ul>
<h1 id="_idParaDest-64"><a id="_idTextAnchor065"/>Integrating MongoDB for NoSQL data storage</h1>
<p>Transitioning from <a id="_idIndexMarker091"/>SQL to NoSQL databases opens<a id="_idIndexMarker092"/> up a different paradigm in data storage and management. <strong class="bold">NoSQL databases</strong>, like MongoDB, are known for their flexibility, scalability, and ability to handle large volumes of unstructured data. In this recipe, we’ll explore how to integrate MongoDB, a popular NoSQL database, with FastAPI.</p>
<p>NoSQL databases differ from traditional SQL databases in that they often allow for more dynamic and flexible data models. MongoDB, for example, stores data in <strong class="bold">binary JSON</strong> (<strong class="bold">BSON</strong>) format, which<a id="_idIndexMarker093"/> can easily accommodate changes in data structure. This is particularly useful in applications that require rapid development and frequent updates to the database schema.</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor066"/>Getting ready</h2>
<p>Make sure you’ve installed MongoDB on your machine. If you haven’t done it yet, you can download the installer from<a href="https://www.mongodb.com/try/download/community"> https://www.mongodb.com/try/download/community</a>.</p>
<p>FastAPI doesn’t provide a built-in ORM for NoSQL databases. However, integrating MongoDB into FastAPI is straightforward thanks to Python’s powerful libraries.</p>
<p>We’ll use <code>pymongo</code>, a Python package driver to interact with MongoDB.</p>
<p>First, ensure you have MongoDB installed and running on your machine.</p>
<p>Then, you can install <code>pymongo</code> with <code>pip</code>:</p>
<pre class="console">
$ pip install pymongo</pre> <p>With <code>pymongo</code> installed, we can now establish a connection to a MongoDB instance and start <a id="_idIndexMarker094"/>performing <a id="_idIndexMarker095"/>database operations.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor067"/>How to do it…</h2>
<p>We can quickly connect our application to a Mongo DB instance running on our local machine by by applying the following steps.</p>
<ol>
<li>Create a new project folder called <code>nosql_example</code>. Start by defining connection configuration in a <code>database.py</code> file:<pre class="source-code">
From pymongo import MongoClient
client = MongoClient()
database = client.mydatabase</pre><p class="list-inset">In this example, <code>mydatabase</code> is the name of your database. You can replace it with the name you prefer. Here, <code>MongoClient</code> establishes a connection to a MongoDB instance running locally on the <em class="italic">default port </em><em class="italic">of 27017</em>.</p></li> <li>Once the connection has been set up, you can define your collections (equivalent to tables in SQL databases) and start interacting with them. MongoDB stores data in collections of documents, where each document is a JSON-like structure:<pre class="source-code">
user_collection = database["users"]</pre><p class="list-inset">Here, <code>user_collection</code> is a reference to the <code>users</code> collection in your MongoDB database.</p></li> <li>To test the connection, you can create an endpoint that will retrieve all users that should <a id="_idIndexMarker096"/>return <a id="_idIndexMarker097"/>an empty list in a <code>main.py</code> file:<pre class="source-code">
from database import user_collection
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
app = FastAPI()
class User(BaseModel):
    name: str
    email: str
@app.get("/users")
def read_users() -&gt; list[User]:
    return [user for user in user_collection.find()]</pre></li> <li>Now, run your <code>mongod</code> instance. You can do it from the command line:<pre class="source-code">
<strong class="bold">$ mongod</strong></pre><p class="list-inset">If you run on Windows the command will be:</p><pre class="source-code"><strong class="bold">$ C:\Program&gt;Files\MongoDB\Server\7.0\bin\mongod</strong></pre></li> </ol>
<p>And that's it. To test it, in a separate terminal window, spin up the FastAPI server by running the following command:</p>
<pre class="source-code">
<strong class="bold">$ uvicorn main:app</strong></pre> <p>Then, simply open your browser at http://localhost:8000/users; you will get an empty list. This means that your database connection is correctly working.</p>
<p>Now that the connection has been set up, we are going to create an endpoint to add a user and one to<a id="_idIndexMarker098"/> retrieve <a id="_idIndexMarker099"/>a specific user with an ID. We’ll create both endpoints in the <code>main.py</code> module.</p>
<h3>Creating a new user</h3>
<p>To add a new<a id="_idIndexMarker100"/> document to a collection, use the <code>insert_one</code> method:</p>
<pre class="source-code">
class UserResponse(User):
    id: str
@app.post("/user")
def create_user(user: User):
    result = user_collection.insert_one(
        user.model_dump(exclude_none=True)
    )
    user_response = UserResponse(
        id=str(result.inserted_id),
         *user.model_dump()
    )
    return user_response</pre> <p>The endpoint we’ve just created returns the affected <code>id</code> number in the response to be used as input for<a id="_idIndexMarker101"/> other endpoints.</p>
<h3>Reading a user</h3>
<p>To retrieve <a id="_idIndexMarker102"/>a document, you can use the <code>find_one</code> method:</p>
<pre class="source-code">
from bson import ObjectId
@app.get("/user")
def get_user(user_id: str):
    db_user = user_collection.find_one(
        {
            "_id": ObjectId(user_id)
            if ObjectId.is_valid(user_id)
            else None
        }
    )
    if db_user is None:
        raise HTTPException(
            status_code=404,
            detail="User not found"
        )
    user_response = UserResponse(
        id=str(db_user["_id"]), **db_user
    )
    return user_response</pre> <p>If the user with the specified ID doesn’t exist, it will return a response status of 404.</p>
<p>In Mongo, the ID of the document is not stored in plain text, but in a 12-byte object. That’s why we need to initialize a dedicated <code>bson.ObjectId</code> when querying the database and explicitly decode to <code>str</code> when returning the value through the response.</p>
<p>You can then spin up the server with <code>uvicorn</code>:</p>
<pre class="console">
$ uvicorn main:app</pre> <p>You can see the endpoints on the interactive documentation page: <a href="http://localhost:8000/docs">http://localhost:8000/docs</a>. Ensure you test every endpoint and the interaction among them thoroughly.</p>
<p>By integrating MongoDB with FastAPI, you gain the ability to handle dynamic, schemaless data structures, which is a significant advantage in many modern web applications. This recipe has equipped you with the knowledge to set up MongoDB, define models and<a id="_idIndexMarker103"/> collections, and perform CRUD operations, providing a solid foundation for building versatile and scalable applications with FastAPI and MongoDB.</p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor068"/>See also</h2>
<p>You can dig into how<a id="_idIndexMarker104"/> to use the <strong class="bold">PyMongo</strong> Python client by reading the official documentation:</p>
<ul>
<li><em class="italic">PyMongo </em><em class="italic">documentation</em>: <a href="https://pymongo.readthedocs.io/en/stable/">https://pymongo.readthedocs.io/en/stable/</a><a href="https://pymongo.readthedocs.io/en/stable/%0D"/></li>
</ul>
<h1 id="_idParaDest-68"><a id="_idTextAnchor069"/>Working with data validation and serialization</h1>
<p>Effective data <a id="_idIndexMarker105"/>validation <a id="_idIndexMarker106"/>stands as a cornerstone of robust web applications, ensuring that incoming data meets predefined criteria and remains safe for processing.</p>
<p>FastAPI harnesses the power of Pydantic, a Python library dedicated to data validation and serialization. By integrating Pydantic models, FastAPI streamlines the process of validating and serializing data, offering an elegant and efficient solution. This recipe shows how to utilize Pydantic models within FastAPI applications, exploring how they enable precise validation and seamless data serialization.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor070"/>Getting ready</h2>
<p><strong class="bold">Pydantic models</strong> are<a id="_idIndexMarker107"/> essentially Python classes that define the structure and validation rules of your data. They use Python’s type annotations to validate that incoming data matches the expected format. When you use a Pydantic model in your FastAPI endpoints, FastAPI automatically validates incoming request data against the model.</p>
<p>In this recipe, we’re going to use Pydantic’s email validator, which comes with the default <code>pydantic</code> package <a id="_idIndexMarker108"/>distribution. However, it needs to be installed in<a id="_idIndexMarker109"/> your environment. You can do this by running the following command:</p>
<pre class="console">
$ pip install pydantic[email]</pre> <p>Once the package has been installed, you are ready to start this recipe.</p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor071"/>How to do it…</h2>
<p>Let’s use it in the previous project. In the <code>main.py</code> module, we’ll modify the <code>UserCreate</code> class, which is used to accept only valid <code>email</code> fields:</p>
<pre class="source-code">
from typing import Optional
from pydantic import BaseModel, EmailStr
class UserCreate(BaseModel):
    name: str
<code>name</code> is a required string and <code>email</code> must be a valid email address. FastAPI will automatically use this model to validate incoming data for any endpoint that expects a <code>UserCreate</code> object.</p>
<p>Let’s say you try to add a user at the <code>POST /user</code> endpoint with an invalid user information body, as shown here:</p>
<pre class="source-code">
{
  "name": "John Doe",
  "email": "invalidemail.com",
}</pre> <p>You will <a id="_idIndexMarker110"/>get a <code>422</code> response <a id="_idIndexMarker111"/>with a message body specifying the invalid fields.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor072"/>Serialization and deserialization concepts</h2>
<p><strong class="bold">Serialization</strong> is the process<a id="_idIndexMarker112"/> of converting complex data types, such as Pydantic <a id="_idIndexMarker113"/>models or database models, into simpler formats such as JSON, which can be easily transmitted over the network. <strong class="bold">Deserialization</strong> is the reverse process, converting incoming data into complex Python types.</p>
<p>FastAPI handles serialization and deserialization automatically using Pydantic models. When you return a Pydantic model from an endpoint, FastAPI serializes it to JSON. Conversely, when you accept a Pydantic model as an endpoint parameter, FastAPI deserializes the incoming JSON data into the model.</p>
<p>For example, the <code>get_user</code> endpoint from the NoSQL example can be improved further like so:</p>
<pre class="source-code">
class UserResponse(User):
    id: str
@app.get("/user")
def get_user(user_id: str)<strong class="bold"> -&gt; UserResponse</strong>:
    db_user = user_collection.find_one(
        {
            "_id": ObjectId(user_id)
            if ObjectId.is_valid(user_id)
            else None
        }
    )
    if db_user is None:
        raise HTTPException(
            status_code=404,
            detail="User not found"
        )
<strong class="bold">    db_user["id"] = str(db_user["_id"])</strong>
<code>User</code> object and then serializes the returned <code>UserResponse</code> object back into JSON.</p>
<p>This <a id="_idIndexMarker114"/>automatic <a id="_idIndexMarker115"/>serialization and deserialization make working with JSON data in FastAPI straightforward and type-safe.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor073"/>Advanced validation techniques</h2>
<p><strong class="bold">Pydantic</strong> offers a range<a id="_idIndexMarker116"/> of advanced validation techniques that you can leverage in FastAPI. These include custom validators and complex data types.</p>
<p><code>@field_validator</code>.</p>
<p>For example, you could add a validator to ensure that a user’s age is within a certain range:</p>
<pre class="source-code">
from pydantic import BaseModel, EmailStr, <strong class="bold">field_validator</strong>
class User(BaseModel):
    name: str
    email: EmailStr
<strong class="bold">    age: int</strong>
<strong class="bold">    </strong><strong class="bold">@field_validator("age")</strong>
<strong class="bold">    def validate_age(cls, value):</strong>
<strong class="bold">        if value &lt; 18 or value &gt; 100:</strong>
<strong class="bold">            raise ValueError(</strong>
<strong class="bold">                "Age must be between 18 and 100"</strong>
<strong class="bold">            )</strong>
<code>age</code> field of the <code>User</code> model is between <code>18</code> and <code>100</code>.</p>
<p>If the validation fails, a descriptive error message is automatically returned to the client.</p>
<p><code>list</code>, <code>dict</code>, and custom types, allowing you to define models that closely represent your data structures.</p>
<p>For instance, you can have a model with a list of items:</p>
<pre class="source-code">
<strong class="bold">class Tweet(BaseModel):</strong>
<strong class="bold">    content: str</strong>
<strong class="bold">    hashtags: list[str]</strong>
class User(BaseModel):
    name: str
    email: EmailStr
    age: Optional[int]
<code>User</code> model has an optional <code>tweets</code> field, which is a list of <code>Tweet</code> objects.</p>
<p>By leveraging Pydantic’s advanced validation features, you can ensure that the data your FastAPI application processes is not only in the correct format but also adheres to your specific business logic and constraints. This provides a robust and flexible way to handle data validation and <a id="_idIndexMarker119"/>serialization in your FastAPI applications.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor074"/>See also</h2>
<p>You can learn more about the <a id="_idIndexMarker120"/>potential of Pydantic validators on the documentation page:</p>
<ul>
<li><em class="italic">Pydantic </em><em class="italic">validators</em>: <a href="https://docs.pydantic.dev/latest/concepts/validators/">https://docs.pydantic.dev/latest/concepts/validators/</a><a href="https://docs.pydantic.dev/latest/concepts/validators/%0D"/></li>
</ul>
<h1 id="_idParaDest-74"><a id="_idTextAnchor075"/>Working with file uploads and downloads</h1>
<p>Handling files is a <a id="_idIndexMarker121"/>common requirement in web applications, whether<a id="_idIndexMarker122"/> it’s uploading user avatars, downloading reports, or processing data files. FastAPI provides efficient and easy-to-implement methods for both uploading and downloading files. This recipe will guide you through how to set up and implement file handling in FastAPI.</p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor076"/>Getting ready</h2>
<p>Let’s create a new project directory called <code>uploads_and_downloads</code> that contains a <code>main.py</code> module with a folder called <code>uploads</code>. This will contain the files from the application side. The directory structure will look like this:</p>
<pre class="console">
uploads_and_downloads/
|─ uploads/
|─ main.py</pre> <p>We can now proceed to create the appropriate endpoints.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor077"/>How to do it…</h2>
<p>To handle file uploads in FastAPI, you must use the <code>File</code> and <code>UploadFile</code> classes from FastAPI. The <code>UploadFile</code> class is particularly useful as it provides an asynchronous interface and spools large files to disk to avoid memory exhaustion.</p>
<p>In the <code>main.py</code> module, you can define the endpoint to upload files like so:</p>
<pre class="source-code">
from fastapi import FastAPI, File, UploadFile
app = FastAPI()
@app.post("/uploadfile")
async def upload_file(
    file: UploadFile = File(...)):
    return {"filename": file.filename}</pre> <p>In this example, <code>upload_file</code> is an endpoint that accepts an uploaded file and returns <a id="_idIndexMarker123"/>its <a id="_idIndexMarker124"/>filename. The file is received in the form of an <code>UploadFile</code> object, which you can then save to disk or process further.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor078"/>Implementing file uploads</h2>
<p>When implementing <a id="_idIndexMarker125"/>file uploads, it’s essential to handle the file data correctly to ensure it is saved without corruption. Here’s an example of how you can save the uploaded file to a directory on your server.</p>
<p>Create a new folder project called <code>uploads_downloads</code>.</p>
<p>In the <code>main.py</code> module, create the <code>upload_file</code> endpoint:</p>
<pre class="source-code">
<strong class="bold">import shutil</strong>
from fastapi import FastAPI, File, UploadFile
app = FastAPI()
@app.post("/uploadfile")
async def upload_file(
    file: UploadFile = File(...),
):
<strong class="bold">    with open(</strong>
<strong class="bold">        </strong><strong class="bold">f"uploads/{file.filename}", "wb"</strong>
<strong class="bold">    ) as buffer:</strong>
<strong class="bold">        shutil.copyfileobj(file.file, buffer)</strong>
    return {"filename": file.filename}</pre> <p>This code snippet <a id="_idIndexMarker126"/>opens a new file in write-binary mode in the <code>uploads</code> directory and uses <code>shutil.copyfileobj</code> to copy the file content from the <code>UploadFile</code> object to the new file.</p>
<p class="callout-heading">Important note</p>
<p class="callout">In a production environment, remember to handle exceptions and errors appropriately, especially for larger files</p>
<p>Create a text file called <code>content.txt</code> with some text in it.</p>
<p>Start the server by running the <code>uvicorn main:app</code> command. Then, access the interactive documentation; you’ll observe that the endpoint we just created for file uploads includes a mandatory field prompting users to upload a file. Upon testing the endpoint by uploading a file, you’ll discover the uploaded file residing <a id="_idIndexMarker127"/>within the designated <code>uploads</code> folder.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor079"/>Managing file downloads and storage</h2>
<p>Downloading files is the <a id="_idIndexMarker128"/>reverse process of uploading. In FastAPI, you can easily set up an endpoint to serve files for download. The <code>FileResponse</code> class is particularly useful for this purpose. It streams files from the server to the client, making it efficient for serving large files.</p>
<p>Here’s a simple file download endpoint:</p>
<pre class="source-code">
from fastapi.responses import FileResponse
@app.get(
    "/downloadfile/{filename}",
    response_class=FileResponse,
)
async def download_file(filename: str):
    if not Path(f"uploads/{filename}").exists():
        raise HTTPException(
            status_code=404,
            detail=f"file {filename} not found",
        )
    return FileResponse(
        path=f"uploads/{filename}", filename=filename
    )</pre> <p>In this example, <code>download_file</code> is an endpoint that serves files from the <code>uploads</code> directory for download. Here, <code>FileResponse</code> automatically sets the appropriate content-type header based on the file type and handles streaming the file to the clien<a id="_idTextAnchor080"/>t.</p>
<p>The content of the file will be the response body of the endpoint.</p>
<p>Handling file storage is another crucial aspect, especially when dealing with a large number of files or large file sizes. It’s often advisable to store files in a dedicated file storage system rather than directly on your web server. Cloud storage solutions such as <strong class="bold">Amazon S3</strong>, <strong class="bold">Google Cloud Storage</strong>, or <strong class="bold">Azure Blob Storage</strong> can be integrated into your<a id="_idIndexMarker129"/> FastAPI <a id="_idIndexMarker130"/>application<a id="_idIndexMarker131"/> for scalable and secure file storage. Additionally, consider implementing cleanup<a id="_idIndexMarker132"/> routines or archival strategies to manage the life cycle of the files you store.</p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor081"/>See also</h2>
<p>You can learn more <a id="_idIndexMarker133"/>about how to manage uploaded files on the official documentation page:</p>
<ul>
<li> <em class="italic">FastAPI request </em><em class="italic">files</em>: <a href="https://fastapi.tiangolo.com/tutorial/request-files/">https://fastapi.tiangolo.com/tutorial/request-files/</a><a href="https://fastapi.tiangolo.com/tutorial/request-files/%0D"/></li>
</ul>
<h1 id="_idParaDest-80"><a id="_idTextAnchor082"/>Handling asynchronous data operations</h1>
<p><strong class="bold">Asynchronous programming</strong> is a core <a id="_idIndexMarker134"/>feature of FastAPI that <a id="_idIndexMarker135"/>allows you to develop highly efficient web applications. It allows your application to handle multiple tasks concurrently, making it particularly well-suited for I/O-bound operations, such as database interactions, file handling, and network communication.</p>
<p>Let’s delve into leveraging asynchronous programming in FastAPI for data operations, enhancing the performance and responsiveness of your applications.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor083"/>Getting ready</h2>
<p>FastAPI is built on Starlette and Pydantic, which provide a robust foundation for writing asynchronous code in Python using the <code>asyncio</code> library with <code>async</code>/<code>await</code> syntax.</p>
<p>The <code>asyncio</code> library allows you to write non-blocking code that can pause its execution while waiting for I/O operations to complete, and then resume where it left off, all without blocking the main execution thread.</p>
<p>This recipe demonstrates the benefits of using <code>asyncio</code> with FastAPI in a simple, practical example.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor084"/>How to do it…</h2>
<p>Let's create an application with two endpoints, one that runs a sleeping operation, the other that run the sleeping operation as well but in asynchrounous mode. Create a new <a id="_idIndexMarker136"/>project folder called <code>async_example</code> containing the <code>main.py</code> module. Fill the module as follows.</p>
<ol>
<li>Let’s start by creating the FastAPI server object class:<pre class="source-code">
from fastapi import FastAPI
app = FastAPI()</pre></li> <li>Now, let’s create an endpoint that sleeps for 1 second:<pre class="source-code">
import time
@app.get("/sync")
def read_sync():
    time.sleep(2)
    return {
        "message": "Synchrounouns blocking endpoint"
    }</pre><p class="list-inset">The sleeping operation represents the waiting time to get a response from the database in a real-life scenario.</p></li> <li>Now, let’s create the same endpoint for the <code>async def</code> version. The sleeping operation will be the sleep function from the <code>asyncio</code> module:<pre class="source-code">
import asyncio
@app.get("/async")
async def read_async():
    await asyncio.sleep(2)
    return {
        "message": 
        "Asynchronous non-blocking endpoint"
    }</pre></li> </ol>
<p>Now, we have two endpoints, <code>GET /sync</code> and <code>GET/async</code>, that are similar except for the fact the second contains a non-blocking sleeping operation.</p>
<p>Once we have our application with the endpoints, let's create a<a id="_idIndexMarker137"/> separate Python script to measure the time to serve a traffic demand. Let’s call it <code>timing_api_calls.py</code> and start building it through the following steps.</p>
<ol>
<li>Let’s define the function to run the server:<pre class="source-code">
import uvicorn
from main import app
def run_server():
    uvicorn.run(app, port=8000, log_level="error")</pre></li> <li>Now, let’s define the start of the server as a context manager:<pre class="source-code">
from contextlib import contextmanager
from multiprocessing import Process
@contextmanager
def run_server_in_process():
    p = Process(target=run_server)
    p.start()
    time.sleep(2)  # Give the server a second to start
    print("Server is running in a separate process")
    yield
    p.terminate()</pre></li> <li>Now, we can<a id="_idIndexMarker138"/> define a function that makes <em class="italic">n</em> concurrent requests to a specified path endpoint:<pre class="source-code">
async def make_requests_to_the_endpoint(
    n: int, path: str
):
    async with AsyncClient(
        base_url="http://localhost:8000"
    ) as client:
        tasks = (
            client.get(path, timeout=float("inf"))
            for _ in range(n)
        )
        await asyncio.gather(*tasks)</pre></li> <li>At this point, we can gather the operations into a main function, make <em class="italic">n</em> calls for each of the <a id="_idIndexMarker139"/>endpoints, and print the time to serve all the calls to the terminal:<pre class="source-code">
async def main(n: int = 10):
    with run_server_in_process():
        begin = time.time()
        await make_requests_to_the_endpoint(n,
                                            "/sync")
        end = time.time()
        print(
            f"Time taken to make {n} requests "
            f"to sync endpoint: {end - begin} seconds"
        )
        begin = time.time()
        await make_requests_to_the_endpoint(n,
                                            "/async")
        end = time.time()
        print(
            f"Time taken to make {n} requests "
            f"to async endpoint: {end - begin}
            seconds"
        )</pre></li> <li>Finally, we can run the main function in the <code>asyncio</code> event loop:<pre class="source-code">
if __name__ == "__main__":
    asyncio.run(main())</pre></li> </ol>
<p>Now that we have built our timing script, let's run it from the command terminal as follows:</p>
<pre class="console">
<code>10</code>, your output will likely resemble the one on my machine:</p>
<pre class="console">
Time taken to make 10 requests to sync endpoint: 2.3172452449798584 seconds
Time taken to make 10 requests to async endpoint: 2.3033862113952637 seconds</pre> <p>It looks like<a id="_idIndexMarker140"/> there is no improvement at all with using asyncio programming.</p>
<p>Now, try to set the number of calls to <code>100</code>:</p>
<pre class="source-code">
if __name__ == "__main__":
    asyncio.run(main(n=100))</pre> <p>The output will likely be more like this:</p>
<pre class="console">
<strong class="bold">Time taken to make 100 requests to sync endpoint: 6.424988269805908 seconds</strong>
<strong class="bold">Time taken to make 100 requests to async endpoint: 2.423431873321533 seconds</strong></pre> <p>This improvement is certainly noteworthy, and it’s all thanks to the use of asynchronous functions.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor085"/>There’s more…</h2>
<p>Asynchronous data operations can significantly improve the performance of your application, particularly when dealing with high-latency operations such as database access. By not blocking the main thread while waiting for these operations to complete, your application remains responsive and capable of handling other incoming requests or tasks.</p>
<p>If you already wrote CRUD operations synchronously, as we did in the previous recipe, <em class="italic">Understanding CRUD operations with SQLAlchemy</em>, implementing asynchronous CRUD operations in FastAPI involves modifying your standard CRUD functions so that they’re asynchronous with the <code>sqlalchemy[asyncio]</code> library. Similarly to SQL, for NoSQL, you will <a id="_idIndexMarker141"/>need to use the <code>motor</code> package, which is the asynchronous MongoDB client built on top of <code>pymongo</code>.</p>
<p>However, it’s crucial to use asynchronous programming judiciously. Not all parts of your application will benefit from asynchrony, and in some cases, it can introduce complexity. Here are some best practices for using asynchronous programming in FastAPI:</p>
<ul>
<li><strong class="bold">Use Async for I/O-bound operations</strong>: Asynchronous programming is most beneficial for I/O-bound<a id="_idIndexMarker142"/> operations (such as database access, file operations, and network requests). CPU-bound tasks that require heavy computation might not benefit as much from asynchrony.</li>
<li><strong class="bold">Database transactions</strong>: When working with databases asynchronously, be mindful of transactions. Ensure that your transactions are correctly managed to maintain the integrity of your data. This often involves using context managers (async with) to handle sessions and transactions.</li>
<li><strong class="bold">Error handling</strong>: Asynchronous code can make error handling trickier, especially with multiple concurrent tasks. Use try-except blocks to catch and handle exceptions appropriately.</li>
<li><code>async</code> and <code>await</code> in your test cases as needed.</li>
</ul>
<p>By understanding and applying these concepts, you can build applications that are not only robust but also <a id="_idIndexMarker143"/>capable of performing optimally under various load conditions. This knowledge is a valuable addition to your skillset as a modern web developer working with FastAPI.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor086"/>See also</h2>
<p>An overview of the concurrency use of the <code>asyncio</code> library in FastAPI can be found on the documentation page:</p>
<ul>
<li><em class="italic">FastAPI </em><em class="italic">C</em><em class="italic">oncurrency</em>: <a href="https://fastapi.tiangolo.com/async/">https://fastapi.tiangolo.com/async/</a><a href="https://fastapi.tiangolo.com/async/%0D"/></li>
</ul>
<p>To integrate <code>async</code>/<code>await</code> syntax with <strong class="bold">SQLAlchemy</strong>, you can have a look at documentation support:</p>
<ul>
<li><em class="italic">SQLAlchemy </em><em class="italic">Asyncio</em>: <a href="https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.xhtml">https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.xhtml</a></li>
</ul>
<p><a href="B21025_06.xhtml#_idTextAnchor193"><em class="italic">Chapter 6</em></a>, <em class="italic">Integrating FastAPI with SQL Databases</em>, will focus on SQL database interactions. Here, you can find examples of integrating <code>asyncio</code> with <code>sqlalchemy</code>.</p>
<p>To integrate <code>asyncio</code> with <code>motor</code>, which is built on top of <code>pymongo</code>:</p>
<ul>
<li><em class="italic">Motor asynchronous </em><em class="italic">driver</em>: <a href="https://motor.readthedocs.io/en/stable/">https://motor.readthedocs.io/en/stable/</a><a href="https://motor.readthedocs.io/en/stable/%0D"/></li>
</ul>
<p>In <a href="B21025_07.xhtml#_idTextAnchor227"><em class="italic">Chapter 7</em></a>, <em class="italic">Integrating FastAPI with NoSQL Databases</em>, you will find examples of motor integration with FastAPI.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor087"/>Securing sensitive data and best practices</h1>
<p>In the realm of web<a id="_idIndexMarker144"/> development, the<a id="_idIndexMarker145"/> security of sensitive data is paramount.</p>
<p>This recipe is a checklist of best practices for securing sensitive data in your FastAPI applications.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor088"/>Getting ready</h2>
<p>First and foremost, it’s crucial to understand the types of data that need protection. <em class="italic">Sensitive data</em> can include anything from passwords and tokens to personal user details. Handling such data requires careful consideration and adherence to security best practices.</p>
<p>Understanding the types of data that require protection sets the foundation for implementing robust security measures, such as leveraging environment variables for sensitive configurations, a key aspect of data security in app development.</p>
<p>Instead of hardcoding these values in your source code, they should be stored in environment variables, which can be accessed securely within your application. This approach not only enhances security but also makes your application more flexible and easier to configure across different environments.</p>
<p>Another important practice is encrypting sensitive data, particularly passwords. FastAPI doesn’t handle encryption directly, but you can use libraries such as <code>bcrypt</code> or <code>passlib</code> to hash and verify passwords securely.</p>
<p>This recipe will<a id="_idIndexMarker146"/> provide a checklist of good<a id="_idIndexMarker147"/> practices to apply to secure sensitive data.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor089"/>How to do it…</h2>
<p>Securely handling data in FastAPI involves more than just encryption; it encompasses a range of practices that are designed to protect data throughout its life cycle in your application.</p>
<p>Here is a list of good practices to apply when securing your application.</p>
<ul>
<li><strong class="bold">Validation and sanitization</strong>: Use the Pydantic model to validate and sanitize incoming data, as shown in the <em class="italic">Working with data validation and serialization</em> recipe. Ensure the data conforms to expected formats and values, reducing the risk of injection attacks or malformed data causing issues.<p class="list-inset">Be cautious with data that will be output to users or logs. Sensitive information should be redacted or anonymized to prevent accidental disclosure.</p></li>
<li><strong class="bold">Access control</strong>: Implement robust access control mechanisms to ensure that users can only access the data they are entitled to. This can involve <strong class="bold">role-based access control</strong> (<strong class="bold">RBAC</strong>), permission checks and properly managing user authentication. You will discover more about this in the <em class="italic">Setting up </em><em class="italic">RBAC</em> recipe in <a href="B21025_04.xhtml#_idTextAnchor122"><em class="italic">Chapter 4</em></a>, <em class="italic">Authentication </em><em class="italic">and Authorization</em>.</li>
<li><strong class="bold">Secure communication</strong>: Use HTTPS to encrypt data in transit. This prevents attackers from intercepting sensitive data that’s sent to or received from your application.</li>
<li><strong class="bold">Database security</strong>: Ensure that your database is securely configured. Use secure connections, avoid exposing database ports publicly, and apply the principle of least privilege to database access.</li>
<li><strong class="bold">Regular updates</strong>: Keep your dependencies, including FastAPI and its underlying libraries, up to date. This helps protect your application from vulnerabilities discovered in older versions of the software.</li>
</ul>
<p>Some of them<a id="_idIndexMarker148"/> will be covered in<a id="_idIndexMarker149"/> detail throughout this book.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor090"/>There’s more…</h2>
<p>Managing sensitive data extends beyond immediate security practices and involves considerations for data storage, transmission, and even deletion.</p>
<p>Here’s a checklist of more general practices so that you can secure your data, regardless of whatever code you are writing:</p>
<ul>
<li><strong class="bold">Data storage</strong>: Store sensitive data only when necessary. If you don’t need to store data such as credit card numbers or personal identification numbers, then don’t. When storage is necessary, ensure it is encrypted and that access is tightly controlled.</li>
<li><strong class="bold">Data transmission</strong>: Be cautious when transmitting sensitive data. Use secure APIs and ensure that any external services you interact with also follow security best practices.</li>
<li><strong class="bold">Data retention and deletion</strong>: Have clear policies on data retention and deletion. When data is no longer needed, ensure it is deleted securely, leaving no trace in backups or logs.</li>
<li><strong class="bold">Monitoring and logging</strong>: Implement monitoring to detect unusual access patterns or potential breaches. However, be careful with what you log. Avoid logging sensitive data and ensure that logs are stored securely and are only accessible to authorized personnel.</li>
</ul>
<p>By applying these practices, you can significantly enhance the security posture of your applications, protecting both your users and your organization from potential data breaches and<a id="_idIndexMarker150"/> ensuring compliance with<a id="_idIndexMarker151"/> data protection regulations. As a developer, understanding and implementing data security is not just a skill but a responsibility in today’s digital landscape. In the next chapter, we will learn how to build an entire RESTful API with FastAPI.</p>
</div>
</div></body></html>