<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer006">
<h1 class="chapter-number" id="_idParaDest-52"><a id="_idTextAnchor052"/>2</h1>
<h1 id="_idParaDest-53"><a id="_idTextAnchor053"/>Working with Data</h1>
<p><strong class="bold">Data handling</strong> is the <a id="_idIndexMarker059"/>backbone of any web application, and this chapter is dedicated to mastering this critical aspect. You will embark on a journey of working with data in FastAPI, where you’ll learn the intricacies of integrating, managing, and optimizing data storage using<a id="_idIndexMarker060"/> both <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) and <strong class="bold">NoSQL</strong> databases. We’ll cover how FastAPI, combined with powerful database tools, can create efficient and scalable data <span class="No-Break">management solutions.</span></p>
<p>Starting with SQL databases, you’ll get hands-on experience in setting up a database, implementing <strong class="bold">create, read, update and delete</strong> (<strong class="bold">CRUD</strong>) operations, and understanding the nuances of working with SQLAlchemy – a popular <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) option for Python. We’ll then shift gears <a id="_idIndexMarker061"/>to NoSQL databases, delving into the world of <strong class="bold">MongoDB.</strong> You’ll learn how to integrate it with FastAPI, handle dynamic data structures, and leverage the flexibility and scalability of <span class="No-Break">NoSQL solutions.</span></p>
<p>But it’s not just about storing and retrieving data. This chapter also focuses on best practices for securing sensitive data and managing transactions and concurrency in your databases. You’ll explore how to protect your data from vulnerabilities and ensure the integrity and consistency of your application’s <span class="No-Break">data operations.</span></p>
<p>By the end of this chapter, you’ll not only have a solid understanding of how to work with various database systems in FastAPI but also the skills to build robust and secure data models for your web applications. Whether it’s implementing complex queries, optimizing database performance, or ensuring data security, this chapter provides the tools and knowledge you need to manage your application’s <span class="No-Break">data effectively.</span></p>
<p>In this chapter, we’re going to cover the <span class="No-Break">following recipes:</span></p>
<ul>
<li>Setting up <span class="No-Break">SQL databases</span></li>
<li>Understanding CRUD operations <span class="No-Break">with SQLAlchemy</span></li>
<li>Integrating MongoDB for NoSQL <span class="No-Break">data storage</span></li>
<li>Working with data validation <span class="No-Break">and serialization</span></li>
<li>Working with file uploads <span class="No-Break">and downloads</span></li>
<li>Handling asynchronous <span class="No-Break">data operations</span></li>
<li>Securing sensitive data and <span class="No-Break">best practices</span></li>
</ul>
<p>Each topic is designed to equip you with the necessary skills and knowledge to handle data in FastAPI efficiently, ensuring your applications are not only functional but also secure <span class="No-Break">and scalable.</span></p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor054"/>Technical requirements</h1>
<p>To effectively run and understand the code in this chapter, ensure you have the following set up. If you’ve followed <a href="B21025_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">First Steps with FastAPI</em>, you should already have some of <span class="No-Break">these installed:</span></p>
<ul>
<li><strong class="bold">Python</strong>: Make sure you’ve<a id="_idIndexMarker062"/> installed Python version 3.9 or higher on <span class="No-Break">your computer.</span></li>
<li><strong class="bold">FastAPI</strong>: Install FastAPI <a id="_idIndexMarker063"/>along with all its dependencies using the <strong class="source-inline">pip install fastapi[all]</strong> command. As we saw in <a href="B21025_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">First Steps with FastAPI</em>, this command also installs <strong class="bold">Uvicorn</strong>, an ASGI server that’s necessary to run your <span class="No-Break">FastAPI application.</span></li>
<li><strong class="bold">Integrated development environment</strong> (<strong class="bold">IDE</strong>): A suitable IDE such as <strong class="bold">VS Code</strong> or <strong class="bold">PyCharm</strong> should be installed. These IDEs offer excellent support for Python and FastAPI development, providing features such as syntax highlighting, code completion, and <span class="No-Break">easy debugging.</span></li>
<li><strong class="bold">MongoDB</strong>: For the NoSQL database portions of this chapter, MongoDB needs to be installed on your local machine. Download and install the free community version server suitable for your operating system <a id="_idTextAnchor055"/><span class="No-Break">from</span><span class="No-Break"> </span><a href="https://www.mongodb.com/try/download/community"><span class="No-Break">https://www.mongodb.com/try/download/community</span></a><span class="No-Break">.</span><p class="list-inset">Make sure that MongoDB is correctly installed by running from the command line the <span class="No-Break">Mongo Deamon:</span></p><pre class="source-code">
<strong class="bold">$ mongod --version</strong></pre><p class="list-inset">You can check the MongoDB version installed on your machine by looking at the output after the installation. However, if you use Windows to run your MongoDB instance, the binary file daemon is in <strong class="source-inline">C:\Program&gt;Files\MongoDB\Server\7.0\bin</strong>. You need to open the terminal in this location to run the daemon <span class="No-Break">or run:</span></p><pre class="source-code"><strong class="bold">$ C:\Program&gt;Files\MongoDB\Server\7.0\bin\mongod -- version</strong></pre></li> <li><strong class="bold">MongoDB tools</strong>: While optional, tools such as<a id="_idIndexMarker064"/> the <strong class="bold">MongoDB Shell</strong> (<a href="https://www.mongodb.com/try/download/shell">https://www.mongodb.com/try/download/shell</a>) and <strong class="bold">MongoDB Compass GUI</strong> (<a href="https://www.mongodb.com/try/download/compass">https://www.mongodb.com/try/download/compass</a>) can greatly enhance <a id="_idIndexMarker065"/>your interaction with the MongoDB server. They provide a more user-friendly interface for managing databases, running queries, and visualizing <span class="No-Break">data structures.</span></li>
</ul>
<p>All the code and examples used throughout this chapter are available on GitHub for reference and download. Visit <a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter02">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter02</a> on GitHub to access <span class="No-Break">the repository.</span></p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor056"/>Setting up SQL databases</h1>
<p>In the world of data <a id="_idIndexMarker066"/>handling, the power of Python meets the efficiency of SQL databases. This recipe aims to introduce you to how to integrate SQL databases within your application, a crucial skill for any developer looking to build robust and scalable <span class="No-Break">web applications.</span></p>
<p>SQL is the standard language for managing and manipulating relational databases. When combined with FastAPI, it unlocks a world of possibilities in data storage <span class="No-Break">and retrieval.</span></p>
<p>FastAPI’s compatibility with SQL databases is facilitated through ORMs. The most popular one<a id="_idIndexMarker067"/> is <strong class="bold">SQLAlchemy</strong>. We will focus on it in <span class="No-Break">this recipe.</span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor057"/>Getting ready</h2>
<p>To begin, you’ll need to have FastAPI and SQLAlchemy installed in your virtual environment. If you followed the steps in <a href="B21025_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">First Steps with FastAPI</em>, you should have FastAPI already set up. For SQLAlchemy, a simple <strong class="source-inline">pip</strong> command is all <span class="No-Break">that’s needed:</span></p>
<pre class="console">
$ pip install sqlalchemy</pre> <p>Once installed, the next step is to configure SQLAlchemy so that it can work with FastAPI. This involves setting up the database connection – a process we will walk through step <span class="No-Break">by step.</span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor058"/>How to do it…</h2>
<p>Now, let’s dive deeper into configuring SQLAlchemy for your FastAPI application. SQLAlchemy acts as the bridge between your Python code and the database, allowing you to interact with the database using Python classes and objects rather than writing raw <span class="No-Break">SQL queries.</span></p>
<p>After installing SQLAlchemy, the next step is to configure it within your FastAPI application. This involves defining your database models – a representation of your database tables in <a id="_idIndexMarker068"/>Python code. In SQLAlchemy, models are typically defined using classes, with each class corresponding to a table in the database, and each attribute of the class corresponding to a column in <span class="No-Break">the table.</span></p>
<p>Follow these steps to go through <span class="No-Break">the process.</span></p>
<ol>
<li>Create a new folder called <strong class="source-inline">sql_example</strong>, move inside it, and then create a file called <strong class="source-inline">database.py</strong> there. Write a <strong class="source-inline">base</strong> class to be used as <span class="No-Break">a reference:</span><pre class="source-code">
from sqlalchemy.orm import DeclarativeBase
class Base(DeclarativeBase):
    pass</pre><p class="list-inset">To define a model in SQLAlchemy, you need to create a base class that derives from the <strong class="source-inline">DeclarativeBase</strong> class. This <strong class="source-inline">Base</strong> class maintains a catalog of classes and tables you’ve defined and is central to SQLAlchemy’s <span class="No-Break">ORM functionality.</span></p><p class="list-inset">You can learn more by reading the official <span class="No-Break">documentation:</span><span class="No-Break"> </span><a href="https://docs.sqlalchemy.org/en/13/orm/extensions/declarative/index.xhtml"><span class="No-Break">https://docs.sqlalchemy.org/en/13/orm/extensions/declarative/index.xhtml</span></a><span class="No-Break">.</span></p></li> <li>Once you have your <strong class="source-inline">Base</strong> class, you can start defining your models. For instance, if you have a table for users, your model might look something <span class="No-Break">like this:</span><pre class="source-code">
from sqlalchemy.orm import (
    Mapped,
    mapped_column
)
class User(Base):
    __tablename__ = "user"
    id: Mapped[int] = mapped_column(
        primary_key=True,
    )
    name: Mapped[str]
    email: Mapped[str]</pre><p class="list-inset">In this model, <strong class="source-inline">User</strong> class corresponds to a table named <strong class="source-inline">user</strong> in the database, with columns for <strong class="source-inline">id</strong>, <strong class="source-inline">name</strong>, and <strong class="source-inline">email</strong>. Each <strong class="source-inline">class attribute</strong> specifies the data type of <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker069"/></span><span class="No-Break">column.</span></p></li> <li>Once your models have been defined, the next step is to connect to the database and create these tables. SQLAlchemy uses a connection string to define the details of the database it needs to connect to. The format of this connection string varies depending on the database system you <span class="No-Break">are using.</span><p class="list-inset">For example, a connection string for a SQLite database might look <span class="No-Break">like this:</span></p><pre class="source-code">
DATABASE_URL = "sqlite:///./test.db"</pre><p class="list-inset"><strong class="bold">SQLite</strong> is a<a id="_idIndexMarker070"/> lightweight, file-based database that doesn’t require a separate server process. It’s an excellent choice for development <span class="No-Break">and testing.</span></p></li> <li>No further setup is required for SQLite as it will automatically create the <strong class="source-inline">test.db</strong> database file the first time you connect <span class="No-Break">to it.</span><p class="list-inset">You will use the <strong class="source-inline">DATABASE_URL</strong> connection string to create an <strong class="source-inline">Engine</strong> object in SQLAlchemy that represents the core interface to <span class="No-Break">the database:</span></p><pre class="source-code">
from sqlalchemy import create_engine
engine = create_engine(DATABASE_URL)</pre></li> <li>With the engine created, you can proceed to create your tables in the database. You can do this by passing your <strong class="source-inline">base</strong> class and the engine to SQLAlchemy’s <span class="No-Break"><strong class="source-inline">create_all</strong></span><span class="No-Break"> method:</span><pre class="source-code">
Base.metadata.create_all(bind=engine)</pre></li> </ol>
<p>Now that you’ve<a id="_idIndexMarker071"/> defined all the abstractions of the database in your code, you can proceed with setting the <span class="No-Break">database connection.</span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor059"/>Establishing a database connection</h2>
<p>The final part of <a id="_idIndexMarker072"/>setting up a SQL database setup is establishing a database connection. This connection allows your application to communicate with the database, executing queries and <span class="No-Break">retrieving data.</span></p>
<p>Database connections are managed with sessions. A session in SQLAlchemy represents a <em class="italic">workspace</em> for your objects, a place where you can add new records or fetch existing ones. Each session is bound to a single <span class="No-Break">database connection.</span></p>
<p>To manage sessions, we need to create a <strong class="source-inline">SessionLocal</strong> class. This class will be used to create and manage session objects for the interactions with the database. Here’s how you can <span class="No-Break">create it:</span></p>
<pre class="source-code">
from sqlalchemy.orm import sessionmaker
SessionLocal = sessionmaker(
    autocommit=False, autoflush=False, bind=engine
)</pre> <p>The <strong class="source-inline">sessionmaker</strong> function creates a factory for sessions. The <strong class="source-inline">autocommit</strong> and <strong class="source-inline">autoflush</strong> parameters are set to <strong class="source-inline">False</strong>, meaning you have to manually commit transactions and manage them when your changes are flushed to <span class="No-Break">the database.</span></p>
<p>With the <strong class="source-inline">SessionLocal</strong> class in place, you can create a function that will be used in your FastAPI route functions to get a new database session. We can create it in the <strong class="source-inline">main.py</strong> module<a id="_idIndexMarker073"/> <span class="No-Break">like so:</span></p>
<pre class="source-code">
from database import SessionLocal
def get_db()
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()</pre> <p>In your route functions, you can use this function as a dependency to communicate with <span class="No-Break">the database.</span></p>
<p>In FastAPI, this can be done with the <strong class="source-inline">Depends</strong> class. In the <strong class="source-inline">main.py</strong> file, you can then add <span class="No-Break">an endpoint:</span></p>
<pre class="source-code">
from fastapi import Depends, FastAPI
from sqlalchemy.orm import Session
from database import SessionLocal
app = FastAPI()
@app.get("/users/")
def read_users(db: Session = Depends(get_db)):
    users = db.query(User).all()
    return users</pre> <p>This approach ensures that a new session is created for each request and closed when the request is finished, which is crucial for maintaining the integrity of your <span class="No-Break">database transactions.</span></p>
<p>You can then run the server with the <span class="No-Break">following command:</span></p>
<pre class="console">
$ uvicorn main:app –-reload</pre> <p>If you try to call the endpoint <strong class="source-inline">GET</strong> at <strong class="source-inline">localhost:8000/users</strong> you will get an empty list since no <a id="_idIndexMarker074"/>users have been <span class="No-Break">added already.</span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor060"/>See also</h2>
<p>You can discover more on how to <a id="_idIndexMarker075"/>set up a session in <strong class="bold">SQLAlchemy</strong> on the <span class="No-Break">documentation page:</span></p>
<ul>
<li><em class="italic">SQLAlchemy </em><span class="No-Break"><em class="italic">session</em></span><span class="No-Break">: </span><a href="https://docs.sqlalchemy.org/en/20/orm/session_basics.xhtml"><span class="No-Break">https://docs.sqlalchemy.org/en/20/orm/session_basics.xhtml</span></a><a href="https://docs.sqlalchemy.org/en/20/orm/session_basics.xhtml%0D"/></li>
</ul>
<h1 id="_idParaDest-60"><a id="_idTextAnchor061"/>Understanding CRUD operations with SQLAlchemy</h1>
<p>After setting up your <a id="_idIndexMarker076"/>SQL database with FastAPI, the next<a id="_idIndexMarker077"/> crucial step is creating database models. This process is central to how your application interacts with the database. <strong class="bold">Database models</strong> in <a id="_idIndexMarker078"/>SQLAlchemy are essentially Python classes that represent tables in your SQL database. They provide a high-level, object-oriented interface to manipulate database records as if they were regular <span class="No-Break">Python objects.</span></p>
<p>In this recipe, we will set<a id="_idIndexMarker079"/> up the <strong class="bold">create, read, update and delete</strong> (<strong class="bold">CRUD</strong>) endpoints to interact with <span class="No-Break">the database.</span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor062"/>Getting ready</h2>
<p>With the models set up, you can now implement CRUD operations. These operations form the backbone of most web applications, allowing you to interact with <span class="No-Break">the database.</span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor063"/>How to do it…</h2>
<p>For each operation, we <a id="_idIndexMarker080"/>will create a dedicated endpoint <a id="_idIndexMarker081"/>implementing the interacting operation with <span class="No-Break">the database.</span></p>
<h3>Creating a new user</h3>
<p>To add a new<a id="_idIndexMarker082"/> user, we’ll use a <strong class="source-inline">POST</strong> request. In the <strong class="source-inline">main.py</strong> file, we must define an endpoint that receives user data, creates a new <strong class="source-inline">User</strong> instance in the body request, and adds it to <span class="No-Break">the database:</span></p>
<pre class="source-code">
class UserBody(BaseModel):
    name: str
    email: str
@app.post("/user")
def add_new_user(
    user: UserBody,
    db: Session = Depends(get_db)
):
    new_user = User(
        name=user.name,
        email=user.email
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user</pre> <p>In a few lines, you’ve <a id="_idIndexMarker083"/>created the endpoint to add a new user to <span class="No-Break">the database.</span></p>
<h3>Reading a specific user</h3>
<p>To get a single <a id="_idIndexMarker084"/>user, we are going to use a <span class="No-Break"><strong class="source-inline">GET</strong></span><span class="No-Break"> endpoint:</span></p>
<pre class="source-code">
from fastapi import HTTPException
@app.get("/user")
def get_user(
    user_id: int,
    db: Session = Depends(get_db)
    ):
    user = (
        db.query(User).filter(
            User.id == user_id
        ).first()
    )
    if user is None:
        raise HTTPException(
            status_code=404,
            detail="User not found"
        )
    return user</pre> <p>The endpoint will <a id="_idIndexMarker085"/>return a <strong class="source-inline">404</strong> response status if the user does <span class="No-Break">not exist.</span></p>
<h3>Updating a user</h3>
<p>Updating a record<a id="_idIndexMarker086"/> via an API offers various approaches, including <strong class="source-inline">PUT</strong>, <strong class="source-inline">PATCH</strong>, or <strong class="source-inline">POST</strong> methods. Despite theoretical nuances, the choice of method often boils down to personal preference. I favor using a <strong class="source-inline">POST</strong> request and augmenting the <strong class="source-inline">/user</strong> endpoint with a <strong class="source-inline">user_id</strong> parameter. This simplifies the process, minimizing the need for extensive memorization. You can integrate this endpoint within the <strong class="source-inline">main.py</strong> module <span class="No-Break">like so:</span></p>
<pre class="source-code">
@app.post("/user/{user_id}")
def update_user(
    user_id: int,
    user: UserBody,
    db: Session = Depends(get_db),
):
    db_user = (
        db.query(User).filter(
            User.id == user_id
        ).first()
    )
    if db_user is None:
        raise HTTPException(
            status_code=404,
            detail="User not found"
        )
    db_user.name = user.name
    db_user.email = user.email
    db.commit()
    db.refresh(db_user)
    return db_user</pre> <p>This is all you need to <a id="_idIndexMarker087"/>do to create the endpoint to update a user record in <span class="No-Break">the database.</span></p>
<h3>Deleting a user</h3>
<p>To conclude, deleting a <a id="_idIndexMarker088"/>user within the same <strong class="source-inline">main.py</strong> module involves utilizing a <strong class="source-inline">DELETE</strong> request, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
@app.delete("/user")
def delete_user(
    user_id: int, db: Session = Depends(get_db)
):
    db_user = (
        db.query(User).filter(
            User.id == user_id
        ).first()
    )
    if db_user is None:
        raise HTTPException(
            status_code=404,
            detail="User not found"
        )
    db.delete(db_user)
    db.commit()
    return {"detail": "User deleted"}</pre> <p>These endpoints cover the basic CRUD operations and demonstrate how FastAPI can be integrated with SQLAlchemy for database operations. By defining these endpoints, your application can create, retrieve, update, and delete user data, providing a fully functional API for <span class="No-Break">client interactions.</span></p>
<p>Now that you have implemented all the operations, you can spin the server <span class="No-Break">by running:</span></p>
<pre class="console">
$ uvicorn main:app</pre> <p>Then open the inreactive documentation at <strong class="source-inline">http://localhost:8000/docs</strong> and start playing with the endpoints by creating, reading, updating and <span class="No-Break">deleting users.</span></p>
<p>Mastering these CRUD operations in FastAPI is a significant step in building dynamic and data-driven web applications. With the knowledge of how to integrate FastAPI endpoints with <a id="_idIndexMarker089"/>SQLAlchemy models, you are well-equipped to develop complex and <span class="No-Break">efficient applications.</span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor064"/>See also</h2>
<p>You can find a clear quick start on how to set up the ORM for CRUD operations with SQLAlchemy on the <a id="_idIndexMarker090"/>official <span class="No-Break">documentation page:</span></p>
<ul>
<li><em class="italic">SQLAlchemy ORM Quick </em><span class="No-Break"><em class="italic">Start</em></span><span class="No-Break">: </span><a href="https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml"><span class="No-Break">https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml</span></a><a href="https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml%0D"/></li>
</ul>
<h1 id="_idParaDest-64"><a id="_idTextAnchor065"/>Integrating MongoDB for NoSQL data storage</h1>
<p>Transitioning from <a id="_idIndexMarker091"/>SQL to NoSQL databases opens<a id="_idIndexMarker092"/> up a different paradigm in data storage and management. <strong class="bold">NoSQL databases</strong>, like MongoDB, are known for their flexibility, scalability, and ability to handle large volumes of unstructured data. In this recipe, we’ll explore how to integrate MongoDB, a popular NoSQL database, <span class="No-Break">with FastAPI.</span></p>
<p>NoSQL databases differ from traditional SQL databases in that they often allow for more dynamic and flexible data models. MongoDB, for example, stores data in <strong class="bold">binary JSON</strong> (<strong class="bold">BSON</strong>) format, which<a id="_idIndexMarker093"/> can easily accommodate changes in data structure. This is particularly useful in applications that require rapid development and frequent updates to the <span class="No-Break">database schema.</span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor066"/>Getting ready</h2>
<p>Make sure you’ve installed MongoDB on your machine. If you haven’t done it yet, you can download the installer <span class="No-Break">from</span><a href="https://www.mongodb.com/try/download/community"><span class="No-Break"> https://www.mongodb.com/try/download/community</span></a><span class="No-Break">.</span></p>
<p>FastAPI doesn’t provide a built-in ORM for NoSQL databases. However, integrating MongoDB into FastAPI is straightforward thanks to Python’s <span class="No-Break">powerful libraries.</span></p>
<p>We’ll use <strong class="source-inline">pymongo</strong>, a Python package driver to interact <span class="No-Break">with MongoDB.</span></p>
<p>First, ensure you have MongoDB installed and running on <span class="No-Break">your machine.</span></p>
<p>Then, you can install <strong class="source-inline">pymongo</strong> <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">pip</strong></span><span class="No-Break">:</span></p>
<pre class="console">
$ pip install pymongo</pre> <p>With <strong class="source-inline">pymongo</strong> installed, we can now establish a connection to a MongoDB instance and start <a id="_idIndexMarker094"/>performing <a id="_idIndexMarker095"/><span class="No-Break">database operations.</span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor067"/>How to do it…</h2>
<p>We can quickly connect our application to a Mongo DB instance running on our local machine by by applying the <span class="No-Break">following steps.</span></p>
<ol>
<li>Create a new project folder called <strong class="source-inline">nosql_example</strong>. Start by defining connection configuration in a <span class="No-Break"><strong class="source-inline">database.py</strong></span><span class="No-Break"> file:</span><pre class="source-code">
From pymongo import MongoClient
client = MongoClient()
database = client.mydatabase</pre><p class="list-inset">In this example, <strong class="source-inline">mydatabase</strong> is the name of your database. You can replace it with the name you prefer. Here, <strong class="source-inline">MongoClient</strong> establishes a connection to a MongoDB instance running locally on the <em class="italic">default port </em><span class="No-Break"><em class="italic">of 27017</em></span><span class="No-Break">.</span></p></li> <li>Once the connection has been set up, you can define your collections (equivalent to tables in SQL databases) and start interacting with them. MongoDB stores data in collections of documents, where each document is a <span class="No-Break">JSON-like structure:</span><pre class="source-code">
user_collection = database["users"]</pre><p class="list-inset">Here, <strong class="source-inline">user_collection</strong> is a reference to the <strong class="source-inline">users</strong> collection in your <span class="No-Break">MongoDB database.</span></p></li> <li>To test the connection, you can create an endpoint that will retrieve all users that should <a id="_idIndexMarker096"/>return <a id="_idIndexMarker097"/>an empty list in a <span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break"> file:</span><pre class="source-code">
from database import user_collection
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
app = FastAPI()
class User(BaseModel):
    name: str
    email: str
@app.get("/users")
def read_users() -&gt; list[User]:
    return [user for user in user_collection.find()]</pre></li> <li>Now, run your <strong class="source-inline">mongod</strong> instance. You can do it from the <span class="No-Break">command line:</span><pre class="source-code">
<strong class="bold">$ mongod</strong></pre><p class="list-inset">If you run on Windows the command <span class="No-Break">will be:</span></p><pre class="source-code"><strong class="bold">$ C:\Program&gt;Files\MongoDB\Server\7.0\bin\mongod</strong></pre></li> </ol>
<p>And that's it. To test it, in a separate terminal window, spin up the FastAPI server by running the <span class="No-Break">following command:</span></p>
<pre class="source-code">
<strong class="bold">$ uvicorn main:app</strong></pre> <p>Then, simply open your browser at http://localhost:8000/users; you will get an empty list. This means that your database connection is <span class="No-Break">correctly working.</span></p>
<p>Now that the connection has been set up, we are going to create an endpoint to add a user and one to<a id="_idIndexMarker098"/> retrieve <a id="_idIndexMarker099"/>a specific user with an ID. We’ll create both endpoints in the <span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break"> module.</span></p>
<h3>Creating a new user</h3>
<p>To add a new<a id="_idIndexMarker100"/> document to a collection, use the <span class="No-Break"><strong class="source-inline">insert_one</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
class UserResponse(User):
    id: str
@app.post("/user")
def create_user(user: User):
    result = user_collection.insert_one(
        user.model_dump(exclude_none=True)
    )
    user_response = UserResponse(
        id=str(result.inserted_id),
         *user.model_dump()
    )
    return user_response</pre> <p>The endpoint we’ve just created returns the affected <strong class="source-inline">id</strong> number in the response to be used as input for<a id="_idIndexMarker101"/> <span class="No-Break">other endpoints.</span></p>
<h3>Reading a user</h3>
<p>To retrieve <a id="_idIndexMarker102"/>a document, you can use the <span class="No-Break"><strong class="source-inline">find_one</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
from bson import ObjectId
@app.get("/user")
def get_user(user_id: str):
    db_user = user_collection.find_one(
        {
            "_id": ObjectId(user_id)
            if ObjectId.is_valid(user_id)
            else None
        }
    )
    if db_user is None:
        raise HTTPException(
            status_code=404,
            detail="User not found"
        )
    user_response = UserResponse(
        id=str(db_user["_id"]), **db_user
    )
    return user_response</pre> <p>If the user with the specified ID doesn’t exist, it will return a response status <span class="No-Break">of 404.</span></p>
<p>In Mongo, the ID of the document is not stored in plain text, but in a 12-byte object. That’s why we need to initialize a dedicated <strong class="source-inline">bson.ObjectId</strong> when querying the database and explicitly decode to <strong class="source-inline">str</strong> when returning the value through <span class="No-Break">the response.</span></p>
<p>You can then spin up the server <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">uvicorn</strong></span><span class="No-Break">:</span></p>
<pre class="console">
$ uvicorn main:app</pre> <p>You can see the endpoints on the interactive documentation page: <a href="http://localhost:8000/docs">http://localhost:8000/docs</a>. Ensure you test every endpoint and the interaction among <span class="No-Break">them thoroughly.</span></p>
<p>By integrating MongoDB with FastAPI, you gain the ability to handle dynamic, schemaless data structures, which is a significant advantage in many modern web applications. This recipe has equipped you with the knowledge to set up MongoDB, define models and<a id="_idIndexMarker103"/> collections, and perform CRUD operations, providing a solid foundation for building versatile and scalable applications with FastAPI <span class="No-Break">and MongoDB.</span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor068"/>See also</h2>
<p>You can dig into how<a id="_idIndexMarker104"/> to use the <strong class="bold">PyMongo</strong> Python client by reading the <span class="No-Break">official documentation:</span></p>
<ul>
<li><em class="italic">PyMongo </em><span class="No-Break"><em class="italic">documentation</em></span><span class="No-Break">: </span><a href="https://pymongo.readthedocs.io/en/stable/"><span class="No-Break">https://pymongo.readthedocs.io/en/stable/</span></a><a href="https://pymongo.readthedocs.io/en/stable/%0D"/></li>
</ul>
<h1 id="_idParaDest-68"><a id="_idTextAnchor069"/>Working with data validation and serialization</h1>
<p>Effective data <a id="_idIndexMarker105"/>validation <a id="_idIndexMarker106"/>stands as a cornerstone of robust web applications, ensuring that incoming data meets predefined criteria and remains safe <span class="No-Break">for processing.</span></p>
<p>FastAPI harnesses the power of Pydantic, a Python library dedicated to data validation and serialization. By integrating Pydantic models, FastAPI streamlines the process of validating and serializing data, offering an elegant and efficient solution. This recipe shows how to utilize Pydantic models within FastAPI applications, exploring how they enable precise validation and seamless <span class="No-Break">data serialization.</span></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor070"/>Getting ready</h2>
<p><strong class="bold">Pydantic models</strong> are<a id="_idIndexMarker107"/> essentially Python classes that define the structure and validation rules of your data. They use Python’s type annotations to validate that incoming data matches the expected format. When you use a Pydantic model in your FastAPI endpoints, FastAPI automatically validates incoming request data against <span class="No-Break">the model.</span></p>
<p>In this recipe, we’re going to use Pydantic’s email validator, which comes with the default <strong class="source-inline">pydantic</strong> package <a id="_idIndexMarker108"/>distribution. However, it needs to be installed in<a id="_idIndexMarker109"/> your environment. You can do this by running the <span class="No-Break">following command:</span></p>
<pre class="console">
$ pip install pydantic[email]</pre> <p>Once the package has been installed, you are ready to start <span class="No-Break">this recipe.</span></p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor071"/>How to do it…</h2>
<p>Let’s use it in the previous project. In the <strong class="source-inline">main.py</strong> module, we’ll modify the <strong class="source-inline">UserCreate</strong> class, which is used to accept only valid <span class="No-Break"><strong class="source-inline">email</strong></span><span class="No-Break"> fields:</span></p>
<pre class="source-code">
from typing import Optional
from pydantic import BaseModel, EmailStr
class UserCreate(BaseModel):
    name: str
<strong class="bold">    email: EmailStr</strong></pre> <p>In this model, <strong class="source-inline">name</strong> is a required string and <strong class="source-inline">email</strong> must be a valid email address. FastAPI will automatically use this model to validate incoming data for any endpoint that expects a <span class="No-Break"><strong class="source-inline">UserCreate</strong></span><span class="No-Break"> object.</span></p>
<p>Let’s say you try to add a user at the <strong class="source-inline">POST /user</strong> endpoint with an invalid user information body, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
{
  "name": "John Doe",
  "email": "invalidemail.com",
}</pre> <p>You will <a id="_idIndexMarker110"/>get a <strong class="source-inline">422</strong> response <a id="_idIndexMarker111"/>with a message body specifying the <span class="No-Break">invalid fields.</span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor072"/>Serialization and deserialization concepts</h2>
<p><strong class="bold">Serialization</strong> is the process<a id="_idIndexMarker112"/> of converting complex data types, such as Pydantic <a id="_idIndexMarker113"/>models or database models, into simpler formats such as JSON, which can be easily transmitted over the network. <strong class="bold">Deserialization</strong> is the reverse process, converting incoming data into complex <span class="No-Break">Python types.</span></p>
<p>FastAPI handles serialization and deserialization automatically using Pydantic models. When you return a Pydantic model from an endpoint, FastAPI serializes it to JSON. Conversely, when you accept a Pydantic model as an endpoint parameter, FastAPI deserializes the incoming JSON data into <span class="No-Break">the model.</span></p>
<p>For example, the <strong class="source-inline">get_user</strong> endpoint from the NoSQL example can be improved further <span class="No-Break">like so:</span></p>
<pre class="source-code">
class UserResponse(User):
    id: str
@app.get("/user")
def get_user(user_id: str)<strong class="bold"> -&gt; UserResponse</strong>:
    db_user = user_collection.find_one(
        {
            "_id": ObjectId(user_id)
            if ObjectId.is_valid(user_id)
            else None
        }
    )
    if db_user is None:
        raise HTTPException(
            status_code=404,
            detail="User not found"
        )
<strong class="bold">    db_user["id"] = str(db_user["_id"])</strong>
<strong class="bold">    return db_user</strong></pre> <p>In this endpoint, FastAPI deserializes the incoming JSON data into a <strong class="source-inline">User</strong> object and then serializes the returned <strong class="source-inline">UserResponse</strong> object back <span class="No-Break">into JSON.</span></p>
<p>This <a id="_idIndexMarker114"/>automatic <a id="_idIndexMarker115"/>serialization and deserialization make working with JSON data in FastAPI straightforward <span class="No-Break">and type-safe.</span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor073"/>Advanced validation techniques</h2>
<p><strong class="bold">Pydantic</strong> offers a range<a id="_idIndexMarker116"/> of advanced validation techniques that you can leverage in FastAPI. These include custom validators and complex <span class="No-Break">data types.</span></p>
<p><strong class="bold">Custom validators</strong> allow<a id="_idIndexMarker117"/> you to define complex validation logic for your models. You can create a custom validator by adding a method to your Pydantic model decorated <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@field_validator</strong></span><span class="No-Break">.</span></p>
<p>For example, you could add a validator to ensure that a user’s age is within a <span class="No-Break">certain range:</span></p>
<pre class="source-code">
from pydantic import BaseModel, EmailStr, <strong class="bold">field_validator</strong>
class User(BaseModel):
    name: str
    email: EmailStr
<strong class="bold">    age: int</strong>
<strong class="bold">    </strong><strong class="bold">@field_validator("age")</strong>
<strong class="bold">    def validate_age(cls, value):</strong>
<strong class="bold">        if value &lt; 18 or value &gt; 100:</strong>
<strong class="bold">            raise ValueError(</strong>
<strong class="bold">                "Age must be between 18 and 100"</strong>
<strong class="bold">            )</strong>
<strong class="bold">        return value</strong></pre> <p>This validator ensures<a id="_idIndexMarker118"/> that the <strong class="source-inline">age</strong> field of the <strong class="source-inline">User</strong> model is between <strong class="source-inline">18</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">100</strong></span><span class="No-Break">.</span></p>
<p>If the validation fails, a descriptive error message is automatically returned to <span class="No-Break">the client.</span></p>
<p><strong class="bold">Pydantic</strong> also supports <strong class="bold">complex data types</strong> such as <strong class="source-inline">list</strong>, <strong class="source-inline">dict</strong>, and custom types, allowing you to define models that closely represent your <span class="No-Break">data structures.</span></p>
<p>For instance, you can have a model with a list <span class="No-Break">of items:</span></p>
<pre class="source-code">
<strong class="bold">class Tweet(BaseModel):</strong>
<strong class="bold">    content: str</strong>
<strong class="bold">    hashtags: list[str]</strong>
class User(BaseModel):
    name: str
    email: EmailStr
    age: Optional[int]
<strong class="bold">    tweets: list[Tweet] | None = None</strong></pre> <p>In this example, the <strong class="source-inline">User</strong> model has an optional <strong class="source-inline">tweets</strong> field, which is a list of <span class="No-Break"><strong class="source-inline">Tweet</strong></span><span class="No-Break"> objects.</span></p>
<p>By leveraging Pydantic’s advanced validation features, you can ensure that the data your FastAPI application processes is not only in the correct format but also adheres to your specific business logic and constraints. This provides a robust and flexible way to handle data validation and <a id="_idIndexMarker119"/>serialization in your <span class="No-Break">FastAPI applications.</span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor074"/>See also</h2>
<p>You can learn more about the <a id="_idIndexMarker120"/>potential of Pydantic validators on the <span class="No-Break">documentation page:</span></p>
<ul>
<li><em class="italic">Pydantic </em><span class="No-Break"><em class="italic">validators</em></span><span class="No-Break">: </span><a href="https://docs.pydantic.dev/latest/concepts/validators/"><span class="No-Break">https://docs.pydantic.dev/latest/concepts/validators/</span></a><a href="https://docs.pydantic.dev/latest/concepts/validators/%0D"/></li>
</ul>
<h1 id="_idParaDest-74"><a id="_idTextAnchor075"/>Working with file uploads and downloads</h1>
<p>Handling files is a <a id="_idIndexMarker121"/>common requirement in web applications, whether<a id="_idIndexMarker122"/> it’s uploading user avatars, downloading reports, or processing data files. FastAPI provides efficient and easy-to-implement methods for both uploading and downloading files. This recipe will guide you through how to set up and implement file handling <span class="No-Break">in FastAPI.</span></p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor076"/>Getting ready</h2>
<p>Let’s create a new project directory called <strong class="source-inline">uploads_and_downloads</strong> that contains a <strong class="source-inline">main.py</strong> module with a folder called <strong class="source-inline">uploads</strong>. This will contain the files from the application side. The directory structure will look <span class="No-Break">like this:</span></p>
<pre class="console">
uploads_and_downloads/
|─ uploads/
|─ main.py</pre> <p>We can now proceed to create the <span class="No-Break">appropriate endpoints.</span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor077"/>How to do it…</h2>
<p>To handle file uploads in FastAPI, you must use the <strong class="source-inline">File</strong> and <strong class="source-inline">UploadFile</strong> classes from FastAPI. The <strong class="source-inline">UploadFile</strong> class is particularly useful as it provides an asynchronous interface and spools large files to disk to avoid <span class="No-Break">memory exhaustion.</span></p>
<p>In the <strong class="source-inline">main.py</strong> module, you can define the endpoint to upload files <span class="No-Break">like so:</span></p>
<pre class="source-code">
from fastapi import FastAPI, File, UploadFile
app = FastAPI()
@app.post("/uploadfile")
async def upload_file(
    file: UploadFile = File(...)):
    return {"filename": file.filename}</pre> <p>In this example, <strong class="source-inline">upload_file</strong> is an endpoint that accepts an uploaded file and returns <a id="_idIndexMarker123"/>its <a id="_idIndexMarker124"/>filename. The file is received in the form of an <strong class="source-inline">UploadFile</strong> object, which you can then save to disk or <span class="No-Break">process further.</span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor078"/>Implementing file uploads</h2>
<p>When implementing <a id="_idIndexMarker125"/>file uploads, it’s essential to handle the file data correctly to ensure it is saved without corruption. Here’s an example of how you can save the uploaded file to a directory on <span class="No-Break">your server.</span></p>
<p>Create a new folder project <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">uploads_downloads</strong></span><span class="No-Break">.</span></p>
<p>In the <strong class="source-inline">main.py</strong> module, create the <span class="No-Break"><strong class="source-inline">upload_file</strong></span><span class="No-Break"> endpoint:</span></p>
<pre class="source-code">
<strong class="bold">import shutil</strong>
from fastapi import FastAPI, File, UploadFile
app = FastAPI()
@app.post("/uploadfile")
async def upload_file(
    file: UploadFile = File(...),
):
<strong class="bold">    with open(</strong>
<strong class="bold">        </strong><strong class="bold">f"uploads/{file.filename}", "wb"</strong>
<strong class="bold">    ) as buffer:</strong>
<strong class="bold">        shutil.copyfileobj(file.file, buffer)</strong>
    return {"filename": file.filename}</pre> <p>This code snippet <a id="_idIndexMarker126"/>opens a new file in write-binary mode in the <strong class="source-inline">uploads</strong> directory and uses <strong class="source-inline">shutil.copyfileobj</strong> to copy the file content from the <strong class="source-inline">UploadFile</strong> object to the <span class="No-Break">new file.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">In a production environment, remember to handle exceptions and errors appropriately, especially for <span class="No-Break">larger files</span></p>
<p>Create a text file called <strong class="source-inline">content.txt</strong> with some text <span class="No-Break">in it.</span></p>
<p>Start the server by running the <strong class="source-inline">uvicorn main:app</strong> command. Then, access the interactive documentation; you’ll observe that the endpoint we just created for file uploads includes a mandatory field prompting users to upload a file. Upon testing the endpoint by uploading a file, you’ll discover the uploaded file residing <a id="_idIndexMarker127"/>within the designated <span class="No-Break"><strong class="source-inline">uploads</strong></span><span class="No-Break"> folder.</span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor079"/>Managing file downloads and storage</h2>
<p>Downloading files is the <a id="_idIndexMarker128"/>reverse process of uploading. In FastAPI, you can easily set up an endpoint to serve files for download. The <strong class="source-inline">FileResponse</strong> class is particularly useful for this purpose. It streams files from the server to the client, making it efficient for serving <span class="No-Break">large files.</span></p>
<p>Here’s a simple file <span class="No-Break">download endpoint:</span></p>
<pre class="source-code">
from fastapi.responses import FileResponse
@app.get(
    "/downloadfile/{filename}",
    response_class=FileResponse,
)
async def download_file(filename: str):
    if not Path(f"uploads/{filename}").exists():
        raise HTTPException(
            status_code=404,
            detail=f"file {filename} not found",
        )
    return FileResponse(
        path=f"uploads/{filename}", filename=filename
    )</pre> <p>In this example, <strong class="source-inline">download_file</strong> is an endpoint that serves files from the <strong class="source-inline">uploads</strong> directory for download. Here, <strong class="source-inline">FileResponse</strong> automatically sets the appropriate content-type header based on the file type and handles streaming the file to <span class="No-Break">the clien<a id="_idTextAnchor080"/>t.</span></p>
<p>The content of the file will be the response body of <span class="No-Break">the endpoint.</span></p>
<p>Handling file storage is another crucial aspect, especially when dealing with a large number of files or large file sizes. It’s often advisable to store files in a dedicated file storage system rather than directly on your web server. Cloud storage solutions such as <strong class="bold">Amazon S3</strong>, <strong class="bold">Google Cloud Storage</strong>, or <strong class="bold">Azure Blob Storage</strong> can be integrated into your<a id="_idIndexMarker129"/> FastAPI <a id="_idIndexMarker130"/>application<a id="_idIndexMarker131"/> for scalable and secure file storage. Additionally, consider implementing cleanup<a id="_idIndexMarker132"/> routines or archival strategies to manage the life cycle of the files <span class="No-Break">you store.</span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor081"/>See also</h2>
<p>You can learn more <a id="_idIndexMarker133"/>about how to manage uploaded files on the official <span class="No-Break">documentation page:</span></p>
<ul>
<li> <em class="italic">FastAPI request </em><span class="No-Break"><em class="italic">files</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/tutorial/request-files/"><span class="No-Break">https://fastapi.tiangolo.com/tutorial/request-files/</span></a><a href="https://fastapi.tiangolo.com/tutorial/request-files/%0D"/></li>
</ul>
<h1 id="_idParaDest-80"><a id="_idTextAnchor082"/>Handling asynchronous data operations</h1>
<p><strong class="bold">Asynchronous programming</strong> is a core <a id="_idIndexMarker134"/>feature of FastAPI that <a id="_idIndexMarker135"/>allows you to develop highly efficient web applications. It allows your application to handle multiple tasks concurrently, making it particularly well-suited for I/O-bound operations, such as database interactions, file handling, and <span class="No-Break">network communication.</span></p>
<p>Let’s delve into leveraging asynchronous programming in FastAPI for data operations, enhancing the performance and responsiveness of <span class="No-Break">your applications.</span></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor083"/>Getting ready</h2>
<p>FastAPI is built on Starlette and Pydantic, which provide a robust foundation for writing asynchronous code in Python using the <strong class="source-inline">asyncio</strong> library with <span class="No-Break"><strong class="source-inline">async</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">await</strong></span><span class="No-Break"> syntax.</span></p>
<p>The <strong class="source-inline">asyncio</strong> library allows you to write non-blocking code that can pause its execution while waiting for I/O operations to complete, and then resume where it left off, all without blocking the main <span class="No-Break">execution thread.</span></p>
<p>This recipe demonstrates the benefits of using <strong class="source-inline">asyncio</strong> with FastAPI in a simple, <span class="No-Break">practical example.</span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor084"/>How to do it…</h2>
<p>Let's create an application with two endpoints, one that runs a sleeping operation, the other that run the sleeping operation as well but in asynchrounous mode. Create a new <a id="_idIndexMarker136"/>project folder called <strong class="source-inline">async_example</strong> containing the <strong class="source-inline">main.py</strong> module. Fill the module <span class="No-Break">as follows.</span></p>
<ol>
<li>Let’s start by creating the FastAPI server <span class="No-Break">object class:</span><pre class="source-code">
from fastapi import FastAPI
app = FastAPI()</pre></li> <li>Now, let’s create an endpoint that sleeps for <span class="No-Break">1 second:</span><pre class="source-code">
import time
@app.get("/sync")
def read_sync():
    time.sleep(2)
    return {
        "message": "Synchrounouns blocking endpoint"
    }</pre><p class="list-inset">The sleeping operation represents the waiting time to get a response from the database in a <span class="No-Break">real-life scenario.</span></p></li> <li>Now, let’s create the same endpoint for the <strong class="source-inline">async def</strong> version. The sleeping operation will be the sleep function from the <span class="No-Break"><strong class="source-inline">asyncio</strong></span><span class="No-Break"> module:</span><pre class="source-code">
import asyncio
@app.get("/async")
async def read_async():
    await asyncio.sleep(2)
    return {
        "message": 
        "Asynchronous non-blocking endpoint"
    }</pre></li> </ol>
<p>Now, we have two endpoints, <strong class="source-inline">GET /sync</strong> and <strong class="source-inline">GET/async</strong>, that are similar except for the fact the second contains a non-blocking <span class="No-Break">sleeping operation.</span></p>
<p>Once we have our application with the endpoints, let's create a<a id="_idIndexMarker137"/> separate Python script to measure the time to serve a traffic demand. Let’s call it <strong class="source-inline">timing_api_calls.py</strong> and start building it through the <span class="No-Break">following steps.</span></p>
<ol>
<li>Let’s define the function to run <span class="No-Break">the server:</span><pre class="source-code">
import uvicorn
from main import app
def run_server():
    uvicorn.run(app, port=8000, log_level="error")</pre></li> <li>Now, let’s define the start of the server as a <span class="No-Break">context manager:</span><pre class="source-code">
from contextlib import contextmanager
from multiprocessing import Process
@contextmanager
def run_server_in_process():
    p = Process(target=run_server)
    p.start()
    time.sleep(2)  # Give the server a second to start
    print("Server is running in a separate process")
    yield
    p.terminate()</pre></li> <li>Now, we can<a id="_idIndexMarker138"/> define a function that makes <em class="italic">n</em> concurrent requests to a specified <span class="No-Break">path endpoint:</span><pre class="source-code">
async def make_requests_to_the_endpoint(
    n: int, path: str
):
    async with AsyncClient(
        base_url="http://localhost:8000"
    ) as client:
        tasks = (
            client.get(path, timeout=float("inf"))
            for _ in range(n)
        )
        await asyncio.gather(*tasks)</pre></li> <li>At this point, we can gather the operations into a main function, make <em class="italic">n</em> calls for each of the <a id="_idIndexMarker139"/>endpoints, and print the time to serve all the calls to <span class="No-Break">the terminal:</span><pre class="source-code">
async def main(n: int = 10):
    with run_server_in_process():
        begin = time.time()
        await make_requests_to_the_endpoint(n,
                                            "/sync")
        end = time.time()
        print(
            f"Time taken to make {n} requests "
            f"to sync endpoint: {end - begin} seconds"
        )
        begin = time.time()
        await make_requests_to_the_endpoint(n,
                                            "/async")
        end = time.time()
        print(
            f"Time taken to make {n} requests "
            f"to async endpoint: {end - begin}
            seconds"
        )</pre></li> <li>Finally, we can run the main function in the <strong class="source-inline">asyncio</strong> <span class="No-Break">event loop:</span><pre class="source-code">
if __name__ == "__main__":
    asyncio.run(main())</pre></li> </ol>
<p>Now that we have built our timing script, let's run it from the command terminal <span class="No-Break">as follows:</span></p>
<pre class="console">
<strong class="bold">$ python timing_api_calls.py</strong></pre> <p>If you keep the default number of calls set to <strong class="source-inline">10</strong>, your output will likely resemble the one on <span class="No-Break">my machine:</span></p>
<pre class="console">
Time taken to make 10 requests to sync endpoint: 2.3172452449798584 seconds
Time taken to make 10 requests to async endpoint: 2.3033862113952637 seconds</pre> <p>It looks like<a id="_idIndexMarker140"/> there is no improvement at all with using <span class="No-Break">asyncio programming.</span></p>
<p>Now, try to set the number of calls <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">100</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
if __name__ == "__main__":
    asyncio.run(main(n=100))</pre> <p>The output will likely be more <span class="No-Break">like this:</span></p>
<pre class="console">
<strong class="bold">Time taken to make 100 requests to sync endpoint: 6.424988269805908 seconds</strong>
<strong class="bold">Time taken to make 100 requests to async endpoint: 2.423431873321533 seconds</strong></pre> <p>This improvement is certainly noteworthy, and it’s all thanks to the use of <span class="No-Break">asynchronous functions.</span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor085"/>There’s more…</h2>
<p>Asynchronous data operations can significantly improve the performance of your application, particularly when dealing with high-latency operations such as database access. By not blocking the main thread while waiting for these operations to complete, your application remains responsive and capable of handling other incoming requests <span class="No-Break">or tasks.</span></p>
<p>If you already wrote CRUD operations synchronously, as we did in the previous recipe, <em class="italic">Understanding CRUD operations with SQLAlchemy</em>, implementing asynchronous CRUD operations in FastAPI involves modifying your standard CRUD functions so that they’re asynchronous with the <strong class="source-inline">sqlalchemy[asyncio]</strong> library. Similarly to SQL, for NoSQL, you will <a id="_idIndexMarker141"/>need to use the <strong class="source-inline">motor</strong> package, which is the asynchronous MongoDB client built on top <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">pymongo</strong></span><span class="No-Break">.</span></p>
<p>However, it’s crucial to use asynchronous programming judiciously. Not all parts of your application will benefit from asynchrony, and in some cases, it can introduce complexity. Here are some best practices for using asynchronous programming <span class="No-Break">in FastAPI:</span></p>
<ul>
<li><strong class="bold">Use Async for I/O-bound operations</strong>: Asynchronous programming is most beneficial for I/O-bound<a id="_idIndexMarker142"/> operations (such as database access, file operations, and network requests). CPU-bound tasks that require heavy computation might not benefit as much <span class="No-Break">from asynchrony.</span></li>
<li><strong class="bold">Database transactions</strong>: When working with databases asynchronously, be mindful of transactions. Ensure that your transactions are correctly managed to maintain the integrity of your data. This often involves using context managers (async with) to handle sessions <span class="No-Break">and transactions.</span></li>
<li><strong class="bold">Error handling</strong>: Asynchronous code can make error handling trickier, especially with multiple concurrent tasks. Use try-except blocks to catch and handle <span class="No-Break">exceptions appropriately.</span></li>
<li><strong class="bold">Testing</strong>: Testing asynchronous code requires some additional considerations. Make sure your test framework supports asynchronous tests and use <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> in your test cases <span class="No-Break">as needed.</span></li>
</ul>
<p>By understanding and applying these concepts, you can build applications that are not only robust but also <a id="_idIndexMarker143"/>capable of performing optimally under various load conditions. This knowledge is a valuable addition to your skillset as a modern web developer working <span class="No-Break">with FastAPI.</span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor086"/>See also</h2>
<p>An overview of the concurrency use of the <strong class="source-inline">asyncio</strong> library in FastAPI can be found on the <span class="No-Break">documentation page:</span></p>
<ul>
<li><em class="italic">FastAPI </em><span class="No-Break"><em class="italic">C</em></span><span class="No-Break"><em class="italic">oncurrency</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/async/"><span class="No-Break">https://fastapi.tiangolo.com/async/</span></a><a href="https://fastapi.tiangolo.com/async/%0D"/></li>
</ul>
<p>To integrate <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> syntax with <strong class="bold">SQLAlchemy</strong>, you can have a look at <span class="No-Break">documentation support:</span></p>
<ul>
<li><em class="italic">SQLAlchemy </em><span class="No-Break"><em class="italic">Asyncio</em></span><span class="No-Break">: </span><a href="https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.xhtml"><span class="No-Break">https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.xhtml</span></a></li>
</ul>
<p><a href="B21025_06.xhtml#_idTextAnchor193"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Integrating FastAPI with SQL Databases</em>, will focus on SQL database interactions. Here, you can find examples of integrating <strong class="source-inline">asyncio</strong> <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">sqlalchemy</strong></span><span class="No-Break">.</span></p>
<p>To integrate <strong class="source-inline">asyncio</strong> with <strong class="bold">MongoDB</strong>, you have to use a dedicated package called <strong class="source-inline">motor</strong>, which is built on top <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">pymongo</strong></span><span class="No-Break">:</span></p>
<ul>
<li><em class="italic">Motor asynchronous </em><span class="No-Break"><em class="italic">driver</em></span><span class="No-Break">: </span><a href="https://motor.readthedocs.io/en/stable/"><span class="No-Break">https://motor.readthedocs.io/en/stable/</span></a><a href="https://motor.readthedocs.io/en/stable/%0D"/></li>
</ul>
<p>In <a href="B21025_07.xhtml#_idTextAnchor227"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Integrating FastAPI with NoSQL Databases</em>, you will find examples of motor integration <span class="No-Break">with FastAPI.</span></p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor087"/>Securing sensitive data and best practices</h1>
<p>In the realm of web<a id="_idIndexMarker144"/> development, the<a id="_idIndexMarker145"/> security of sensitive data <span class="No-Break">is paramount.</span></p>
<p>This recipe is a checklist of best practices for securing sensitive data in your <span class="No-Break">FastAPI applications.</span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor088"/>Getting ready</h2>
<p>First and foremost, it’s crucial to understand the types of data that need protection. <em class="italic">Sensitive data</em> can include anything from passwords and tokens to personal user details. Handling such data requires careful consideration and adherence to security <span class="No-Break">best practices.</span></p>
<p>Understanding the types of data that require protection sets the foundation for implementing robust security measures, such as leveraging environment variables for sensitive configurations, a key aspect of data security in <span class="No-Break">app development.</span></p>
<p>Instead of hardcoding these values in your source code, they should be stored in environment variables, which can be accessed securely within your application. This approach not only enhances security but also makes your application more flexible and easier to configure across <span class="No-Break">different environments.</span></p>
<p>Another important practice is encrypting sensitive data, particularly passwords. FastAPI doesn’t handle encryption directly, but you can use libraries such as <strong class="source-inline">bcrypt</strong> or <strong class="source-inline">passlib</strong> to hash and verify <span class="No-Break">passwords securely.</span></p>
<p>This recipe will<a id="_idIndexMarker146"/> provide a checklist of good<a id="_idIndexMarker147"/> practices to apply to secure <span class="No-Break">sensitive data.</span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor089"/>How to do it…</h2>
<p>Securely handling data in FastAPI involves more than just encryption; it encompasses a range of practices that are designed to protect data throughout its life cycle in <span class="No-Break">your application.</span></p>
<p>Here is a list of good practices to apply when securing <span class="No-Break">your application.</span></p>
<ul>
<li><strong class="bold">Validation and sanitization</strong>: Use the Pydantic model to validate and sanitize incoming data, as shown in the <em class="italic">Working with data validation and serialization</em> recipe. Ensure the data conforms to expected formats and values, reducing the risk of injection attacks or malformed data <span class="No-Break">causing issues.</span><p class="list-inset">Be cautious with data that will be output to users or logs. Sensitive information should be redacted or anonymized to prevent <span class="No-Break">accidental disclosure.</span></p></li>
<li><strong class="bold">Access control</strong>: Implement robust access control mechanisms to ensure that users can only access the data they are entitled to. This can involve <strong class="bold">role-based access control</strong> (<strong class="bold">RBAC</strong>), permission checks and properly managing user authentication. You will discover more about this in the <em class="italic">Setting up </em><em class="italic">RBAC</em> recipe in <a href="B21025_04.xhtml#_idTextAnchor122"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Authentication </em><span class="No-Break"><em class="italic">and Authorization</em></span><span class="No-Break">.</span></li>
<li><strong class="bold">Secure communication</strong>: Use HTTPS to encrypt data in transit. This prevents attackers from intercepting sensitive data that’s sent to or received from <span class="No-Break">your application.</span></li>
<li><strong class="bold">Database security</strong>: Ensure that your database is securely configured. Use secure connections, avoid exposing database ports publicly, and apply the principle of least privilege to <span class="No-Break">database access.</span></li>
<li><strong class="bold">Regular updates</strong>: Keep your dependencies, including FastAPI and its underlying libraries, up to date. This helps protect your application from vulnerabilities discovered in older versions of <span class="No-Break">the software.</span></li>
</ul>
<p>Some of them<a id="_idIndexMarker148"/> will be covered in<a id="_idIndexMarker149"/> detail throughout <span class="No-Break">this book.</span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor090"/>There’s more…</h2>
<p>Managing sensitive data extends beyond immediate security practices and involves considerations for data storage, transmission, and <span class="No-Break">even deletion.</span></p>
<p>Here’s a checklist of more general practices so that you can secure your data, regardless of whatever code you <span class="No-Break">are writing:</span></p>
<ul>
<li><strong class="bold">Data storage</strong>: Store sensitive data only when necessary. If you don’t need to store data such as credit card numbers or personal identification numbers, then don’t. When storage is necessary, ensure it is encrypted and that access is <span class="No-Break">tightly controlled.</span></li>
<li><strong class="bold">Data transmission</strong>: Be cautious when transmitting sensitive data. Use secure APIs and ensure that any external services you interact with also follow security <span class="No-Break">best practices.</span></li>
<li><strong class="bold">Data retention and deletion</strong>: Have clear policies on data retention and deletion. When data is no longer needed, ensure it is deleted securely, leaving no trace in backups <span class="No-Break">or logs.</span></li>
<li><strong class="bold">Monitoring and logging</strong>: Implement monitoring to detect unusual access patterns or potential breaches. However, be careful with what you log. Avoid logging sensitive data and ensure that logs are stored securely and are only accessible to <span class="No-Break">authorized personnel.</span></li>
</ul>
<p>By applying these practices, you can significantly enhance the security posture of your applications, protecting both your users and your organization from potential data breaches and<a id="_idIndexMarker150"/> ensuring compliance with<a id="_idIndexMarker151"/> data protection regulations. As a developer, understanding and implementing data security is not just a skill but a responsibility in today’s digital landscape. In the next chapter, we will learn how to build an entire RESTful API <span class="No-Break">with FastAPI.</span></p>
</div>
</div></body></html>