- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing Graphical Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many tools add their own elements to the graphical interface. In the previous
    chapters, we used existing menus, but we can also add new panels to the Blender
    window.
  prefs: []
  type: TYPE_NORMAL
- en: To design an interface, we must decide which elements to show and how to reach
    them, what information should be provided, and which actions should be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to insert new panels into different regions
    of Blender, how to display information and icons, and how to add buttons that
    can invoke operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Blender interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing a custom panel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context and UI interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use Blender and Visual Studio Code in this chapter. The examples created
    in this chapter can be found at [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch5](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch5).
  prefs: []
  type: TYPE_NORMAL
- en: The example files include 2D images to be used as icons. Optionally, any 2D
    software can be used to create custom `.png` images, and you can use them instead.
  prefs: []
  type: TYPE_NORMAL
- en: To implement our interface, we will have to learn how Blender is structured.
    Let’s begin our journey into graphical interfaces with a deep dive into the Blender
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Areas, regions, and panels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Blender window is split into **areas**. Each area can contain an **editor**
    of a different type, such as the *viewport* for 3D objects or the *sequencer*
    for editing videos. Each editor, or space, can contain one or more **regions**.
    The number and type of regions vary across different types of editors: for instance,
    some editors, such as the **Preferences** window, have a navigation sidebar, while
    others don’t.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Blender manual explains the interface in detail: [https://docs.blender.org/manual/en/3.1/interface/index.xhtml](https://docs.blender.org/manual/en/3.1/interface/index.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: What we need to know for now is that regions can contain **panels**, and panels
    are the basic containers of graphical elements such as text, editable values,
    and buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create new panels with Python, which makes it possible to customize
    any region with ease. A panel must contain information about the area and region
    to which it belongs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Areas, regions, and the panel in the Blender interface](img/Figure_5.01_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Areas, regions, and the panel in the Blender interface'
  prefs: []
  type: TYPE_NORMAL
- en: Internally, panels can access information about Blender and the scene so that
    they can display the status and properties of the objects and execute operators.
    Now that we are more familiar with the anatomy of the screen, we are going to
    create a panel that helps us deal with 3D objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with a simple panel that contains some text and icons, and we
    will see how to expand this initial idea into a tool that can help manage the
    objects in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Our panel is a new class that derives from `bpy.types.Panel`. Like operators,
    panels require some static members to be set; otherwise, they will not work. Similar
    to operators, panels can have a `poll()` class method that states under which
    conditions the panel can be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using the `execute` function, panels set up and draw their content
    via the `draw(self,` `context)` function.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are adding a new piece to the Blender interface, we will do that inside
    a new add-on. It’s not mandatory, but it makes it easier to enable and disable
    our panel.
  prefs: []
  type: TYPE_NORMAL
- en: To keep our code orderly and clean, we will create a new folder for the scripts
    written for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s create a folder for [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100) in
    our `ch5` folder as a **Scripts Folder** and restart Blender.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our add-on script contains a panel, much like the ones in the previous chapters
    contained operators:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `PythonScriptingBlender/ch5/addons` in **Visual** **Studio Code**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file by clicking the **New** **File** icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new file `simple_panel.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file by double-clicking on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now start writing the add-on for our panel.
  prefs: []
  type: TYPE_NORMAL
- en: Drafting our panel add-on
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we know from [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049), three elements
    are required:'
  prefs: []
  type: TYPE_NORMAL
- en: A `bl_info` dictionary containing basic information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `import bpy` statement to access the Blender API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `register()` and `unregister()` methods for enabling/disabling add-ons,
    respectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need a class for the graphical element that we want to add – in this
    case, a class that derives from `bpy.types.Panel`.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the information dictionary and add the stubs for the required
    elements to set a frame on which we can code a fully working UI add-on.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the info dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `bl_info` dictionary will provide the `name` property of the add-on, its
    `author` and `version`, and the required `blender` version, plus a short `description`.
    We can also add a `category` under which the add-on is listed. Here’s what the
    code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can proceed with the required `import` statements and the main `class`.
  prefs: []
  type: TYPE_NORMAL
- en: Drafting the Panel class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve imported the `bpy` module, we can write a class based on `bpy.types.Panel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use any name for our class, but Blender recommends some guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Since our panel will be part of the object properties, the class name must begin
    with `OBJECT`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name contains `_PT_` in the middle since this is a `Panel Type`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For now, our class will only contain a *docstring* and a `pass` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Before adding methods and attributes, we will handle the class activation and
    dismissal through the registration functions.
  prefs: []
  type: TYPE_NORMAL
- en: Panel registration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `register` and `unregister` functions add and remove this class to/from
    Blender when the add-on is enabled and disabled, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have created the initial structure of our panel add-on. We will
    now add the elements and attributes for displaying some text.
  prefs: []
  type: TYPE_NORMAL
- en: Setting display attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Blender looks for attributes that follow the `bl_*` pattern to determine where
    and how the panel is displayed. Panels have the same identification attributes
    as operators, as we saw in [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049), when
    we introduced the `Operator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bl_label`: The display name of the panel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bl_idname`: The unique name of the panel for internal usage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, there are attributes used only on classes that derive from `bpy.types.Panels`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bl_space_type`: The editor to which the panel belongs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bl_region_type`: The region of the editor to use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bl_context`: The sub-region for specific objects/modes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bl_category`: The tab inside the region, when available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of them are static strings, and `bl_space_type`, `bl_region_type`, and `bl_context`
    must match specific values known to Blender as regions of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The possible values encompass all the available editors in Blender. That might
    seem overwhelming at first, but once we have an idea of where to place our panel,
    we can look that up in the online documentation at [https://docs.blender.org/api/3.2/bpy.types.Panel.xhtml](https://docs.blender.org/api/3.2/bpy.types.Panel.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Since Blender contains many editors and each of them has its own sub-elements,
    we will have a look at the possible combinations.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing our editor view via bl_space_type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we must decide which Blender editor we are adding our panel to. That
    depends mainly on the purpose of our tool and where it will be more convenient
    to find it. For instance, if our panel helps make videos, it will be part of the
    `bl_space_type`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EMPTY`: This value is not used in scripts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIEW_3D`: **3D Viewport** for manipulating *objects*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IMAGE_EDITOR`: **UV/Image Editor** to view and edit *images* and UV Maps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NODE_EDITOR`: **Node Editor** for node-based *shading* and *compositing* tools'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SEQUENCE_EDITOR`: **Video Sequencer** *editing* tools'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLIP_EDITOR`: **Movie Clip Editor** for *motion tracking*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOPESHEET_EDITOR`: **Dope Sheet** for adjusting the timing of *keyframes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GRAPH_EDITOR`: **Graph Editor** for drivers and keyframe *interpolation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NLA_EDITOR`: **Nonlinear Animation** to combine and layer *actions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TEXT_EDITOR` **Text Editor** to edit *scripts* and in-file *documentation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONSOLE`: **Python Console** for interactive script *development*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INFO`: **Info** about operations, warnings, and error *messages*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TOPBAR`: **Topbar** for global, *per-window settings*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STATUSBAR`: **Status Bar** at the bottom of the screen for *general information*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OUTLINER`: **Outliner** overview of the *scene tree* and data blocks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PROPERTIES`: **Properties** to edit the *attributes* of active objects and
    data blocks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FILE_BROWSER`: **File Browser** to scroll through *files* *and assets*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SPREADSHEET`: **Spreadsheet** to explore *geometry data* in a table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PREFERENCES`: **Preferences** to edit persistent *configuration* settings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have decided on the space type, we are ready to pick a region for it.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a region via bl_region_type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The kind of region depends on the *space* we chose in the previous step. Different
    editors have different regions. So, only the default value is always available.
    Here is a description of all the options for `bl_region_type`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WINDOW`: The *main* region of a space area. This is the default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEADER`: A small horizontal strip for *menus* and buttons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CHANNELS`: Used in older versions of Blender, left for backward compatibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TEMPORARY`: *Poupps* detached from the main window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UI`: Sidebar containing object settings (toggled with *N*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TOOLS`: A toolbar containing a set of interactive tools (toggled with *T*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TOOL_PROPS`: Settings in *modal windows*, such as **File Browser**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PREVIEW`: The preview area of the **Video Sequencer**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HUD`: The operator’s **Redo** panel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NAVIGATION_BAR`: *Sidebar* in the **Preferences** window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXECUTE`: *Bottom bar* in modal windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FOOTER`: A bar for displaying *information* about the current operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TOOL_HEADER`: A small horizontal strip for *tool settings*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XR`: The interface for *virtual* *reality* controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picking a context via bl_context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some areas change according to the current selection, active tool, or interaction
    mode. In that case, the `bl_context` attribute is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the `''SCENE''`, `''OBJECT''`, and `''CONSTRAINTS''`. If we are
    not sure about which one to use, we can just activate the tab we are interested
    in and check the `bpy.context.space_data.context =` `NAME_OF_CONTEXT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: UI context name in the Info Log area, after Object Properties
    have been selected](img/Figure_5.02_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: UI context name in the Info Log area, after Object Properties have
    been selected'
  prefs: []
  type: TYPE_NORMAL
- en: Areas that do not follow the user context but still allow you to group their
    panels in tabs offer a *category* attribute instead.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping in tabs using bl_category
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Regions with arbitrary tabs will look at the `bl_category` variable to look
    up the correct label. If no value is given, the new panel will be added to the
    **Miscellaneous** tab. If no tab is named after that value, a new one will be
    created.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the category attribute at the end of this chapter in conjunction
    with the `'VIEW_3D'` space type. We are going to start with the `'PROPERTIES'`
    editor, which does not have tabs.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a panel to the Object Properties area
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add our panel to the `bl_space_type` to `'PROPERTIES'` and `bl_context` to
    `'object'`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Panel` needs a `draw` function where the actual design takes place. At this
    stage, we can leave it blank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Like most runtime functions of Blender classes, `draw` takes the `self` and
    `context` arguments. As per Python convention, `self` is the running instance
    of the class, while `context` contains information about the current state of
    the Blender scene.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how the `draw` method is used to add elements to the panel’s
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the panel’s content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `draw` function is executed continuously whenever a panel is used or updated.
    For this reason, it should not perform any computationally expensive task and
    just take care of the elements to display.
  prefs: []
  type: TYPE_NORMAL
- en: The elements of a panel are arranged according to its layout. Since the layout
    is a non-static member, it can be accessed inside the `draw` function using `self.layout`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, all elements are stacked vertically in a `column`, but different
    types of layouts will provide a different way to arrange the widgets in a `row`
    or inside a `grid`.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts can be also nested together for more complex arrangements. Let’s learn
    how to access the main layout and add elements to it.
  prefs: []
  type: TYPE_NORMAL
- en: Working with layouts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All layout types derive from the `UILayout` class. They have methods to add
    child elements or sub-layouts. The full list of attributes and methods is reported
    in the API documentation at https://docs.blender.org/api/3.2/bpy.types.UILayout.xhtml.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to display text, we can use the `UILayout.label` method. Here are the first
    few lines of code for our `draw` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we enable this add-on and reach for the **Object Properties** area, we will
    be able to see our new panel displaying some text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: Our panel showing up in the Object Properties area](img/Figure_5.03_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Our panel showing up in the Object Properties area'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying icons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Labels can display **icons** too. There are two types of icons:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Built-in* icons that come with Blender. The `label` method provides an `icon`
    keyword to use them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*External Images* can be used via the `icon_value` parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blender’s native set of icons is used across the application. Each icon is
    identified with a keyword. For instance, `LIGHT` displays a lightbulb:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Blender icon for the LIGHT keyword](img/Figure_5.04_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Blender icon for the LIGHT keyword'
  prefs: []
  type: TYPE_NORMAL
- en: There are more than 800 built-in icons, so Blender includes an add-on for searching
    through them.
  prefs: []
  type: TYPE_NORMAL
- en: Looking for built-in icons with the Icon Viewer add-on
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `icon` in the **Search** **Bar** area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: Activating the Icon Viewer add-on](img/Figure_5.05_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Activating the Icon Viewer add-on'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the add-on has been enabled, the **Icon Viewer** button appears in the
    header of the **Python** **Console** header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: The Icon Viewer button in the Python Console header](img/Figure_5.06_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: The Icon Viewer button in the Python Console header'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking this button opens a window that shows all native icons. We can select
    them by left-clicking:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: The Icon Viewer add-on window](img/Figure_5.07_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: The Icon Viewer add-on window'
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting an icon displays the associated keyword in the top-right corner.
    The keyword is also copied to the clipboard. For example, if we select the *question
    mark* icon, which is the first icon on the top left at the time of writing, the
    `QUESTION` keyword will be displayed, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: The QUESTION keyword is displayed in the top-right corner](img/Figure_5.08_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: The QUESTION keyword is displayed in the top-right corner'
  prefs: []
  type: TYPE_NORMAL
- en: We can type a search key in the filter field in the top middle, which is marked
    with a magnifier icon.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can type `“info”` to show the `''INFO''` icon only. Now that
    we know their keywords, we can display those icons in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Label icons are displayed before the text and are a good way to make it stand
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: The ‘INFO’ and ‘QUESTION’ icons displayed in our custom panel](img/Figure_5.09_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: The ‘INFO’ and ‘QUESTION’ icons displayed in our custom panel'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in icons are always available and don’t require external files to be distributed
    alongside our scripts. We can also use image files when needed. The `bpu.utils.previews`
    module can be used to load icons from image files and retrieve them using an index
    number.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom image icons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this example, we will add the icon of a smiling face to our panel. The image
    file is named `icon_smile_64.png` and can be found in this chapter’s Git folder.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, any image stored in `.png` format alongside the add-on’s `.py`
    file will work. In that case, the image filename used in the script must be changed
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resolution should not be too high: a 64-pixel-wide square picture is usually
    more than enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: A 64x64 smiley face](img/Figure_5.10_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: A 64x64 smiley face'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add custom icons to Blender, our script needs to import the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `os` Python module, to build the icon file path and make sure it will work
    on all platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bpy.utils.previews` Blender module, to generate a Blender identifier for
    our icon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is what our `import` section will look like once we import them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our icons must be accessible everywhere in the script. We can use a global variable,
    a static member, or a singleton for storage. In this example, we are using a global
    variable as it is the simpler option.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, right after the `import` section, we must add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialize the variable as `None` since we can load and clear it inside
    the `register`/`unregister` function. We can also add specific functions for that.
    This way, the code will be easier to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need a function that clears `custom_icons` when the add-on is unregistered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions are then invoked in the registration section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we read the image file, we used `"smile_face"` as the first argument of
    `custom_icons.load()`, so that is the keyword that will be used for retrieving
    its identifier. Here’s the code to use in a label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look up and execute **Reload Scripts** from the *F3* search panel, we
    will see our custom icon in the panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Smiley icon loaded from our file and displayed in our panel](img/Figure_5.11_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: Smiley icon loaded from our file and displayed in our panel'
  prefs: []
  type: TYPE_NORMAL
- en: For now, we have used the default column layout. We will learn how to use a
    different arrangement in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Where have my widgets gone?
  prefs: []
  type: TYPE_NORMAL
- en: Errors in the interface code fail “silently"; that is, Blender doesn’t complain
    visibly and instead just stops drawing the buggy panel.
  prefs: []
  type: TYPE_NORMAL
- en: This prevents the UI from crashing but makes our code more difficult to debug;
    we will only notice that some of our widgets are not displayed.
  prefs: []
  type: TYPE_NORMAL
- en: When that happens, the best thing to do is check the console output or the **Info
    Log** area in the **Scripting** workspace. It will contain *traceback* information
    about which line of code is failing.
  prefs: []
  type: TYPE_NORMAL
- en: Using layouts in our panels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we are not happy with the default stacking of the global layout, we can add
    a layout type of our choice to it and use that instead, and we’ll get a different
    arrangement.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can put two labels on the same line using a `row`. Also, even
    if we are happy with stacking our elements one under the other, it is good practice
    to create a `column` sub-layout anyway. This practice has at least two advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: We preserve the panel's look, even if the default arrangement should change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do not pollute the original layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see how we can change the way our widgets are stacked.
  prefs: []
  type: TYPE_NORMAL
- en: Arranging in columns and rows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can nest more layout types together inside our `draw` function. For instance,
    we can place the last two labels from the previous example side by side rather
    than arrange them vertically. To do that, we must do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we must create a `column` and add the first label to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we must create a `row`. The two labels we will add to it will be next
    to each other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our panel consists of only two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: The second line consists of two labels](img/Figure_5.12_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: The second line consists of two labels'
  prefs: []
  type: TYPE_NORMAL
- en: Adding frames with box layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Other types of sub-layouts provide additional effects. For instance, a box
    layout is like a column, but it is framed in a smoothed rectangle. Let’s say we
    want to display some information from the add-on’s `bl_info`. Here, we can add
    these lines to the `draw` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After we call **Reload Scripts**, we will see a frame around that information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: A box layout surrounds the version information](img/Figure_5.13_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: A box layout surrounds the version information'
  prefs: []
  type: TYPE_NORMAL
- en: We have put a caption of `"version"` and some information stating `bl_info['version']`
    in a row. That gives the same space to each element. To have more control over
    how much space is taken by the first element, we can use a `split` layout.
  prefs: []
  type: TYPE_NORMAL
- en: Using composite layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some layouts consist of more rows or columns. A `split` layout distributes the
    available space across different columns, while a `grid` layout creates rows and
    columns automatically.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use them to build a more sophisticated panel.
  prefs: []
  type: TYPE_NORMAL
- en: Arranging in splits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the `split` method to create a layout whose columns’ width can be
    tweaked. The `factor` argument is optional and accepts values between `0.0` and
    `1.0`. Leaving it to the default value of `0.0` computes the optimal width automatically;
    otherwise, it sets the percentage occupied by the first column.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we’ll use a factor of `0.33` to give less space to the first
    column. Here, we will also create two columns so that we can fill them later and
    arrange more elements like we would in a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet displays two entries per line. The first column takes
    about one-third of the space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon reloading the scripts, we will see our captions taking up one-third of
    the space, leaving the rest to the relevant information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: Author and version information taking one-third of the space](img/Figure_5.14_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.14: Author and version information taking one-third of the space'
  prefs: []
  type: TYPE_NORMAL
- en: We can take advantage of dictionary methods to add more information from `bl_info`.
    This way, we can populate our `split` layout using a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Populating with dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we have created the columns already, we can add more entries using a loop.
    This is ideal for displaying the entries in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that we want to show all the add-on information. In that case, we
    can iterate all the keyword/value pairs using the `items()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we skip unset values of `bl_info` using `continue` when `v` is empty.
    In these few lines, we can display all the available add-on information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: A box layout displaying bl_info](img/Figure_5.15_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: A box layout displaying bl_info'
  prefs: []
  type: TYPE_NORMAL
- en: If we are happy with leaving the column width to Blender, we can use a grid
    layout instead.
  prefs: []
  type: TYPE_NORMAL
- en: Arranging grids
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `grid_flow` layout is very convenient for arranging our elements into tables
    as it creates rows and columns automatically. For instance, we can display the
    object names from the scene on two columns by using `grid_flow(columns=2)` and
    adding labels to a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will display the names of the objects in the current scene, arranged
    in a two-column grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16: Object names displayed in a grid](img/Figure_5.16_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.16: Object names displayed in a grid'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have seen that labels can display icons too. This means we can
    display an icon of the object’s type beside each name, just like the outliner
    does.
  prefs: []
  type: TYPE_NORMAL
- en: Building icon keywords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A quick search in the `OUTLINER_OB_MESH` and `OUTLINER_OB_CURVE`, follow this
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is depicted in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17: Object type icons as displayed in the Icon Viewer area](img/Figure_5.17_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.17: Object type icons as displayed in the Icon Viewer area'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, we can build those keywords using *string formatting*, a
    feature of Python 3 that makes combining strings and variables easier. To inform
    Python that we are using formatting, we must put an `f` character before the quote
    or apostrophe delimiters, then surround our variables with curly brackets inside
    the string. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With that in mind, we get the string for the object type – for example, `''MESH''`,
    `''CURVE''`, or `''ARMATURE''` – using the `ob.type` attribute, then build the
    icon keyword using the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This result can be fed to the `icon` parameter inside our loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reload the scripts and see how icons are displayed before names:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18: A custom panel listing the scene objects and their icons](img/Figure_5.18_B18375.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.18: A custom panel listing the scene objects and their icons'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t want this list to take up too much space on large scenes, so we will
    break the loop after a certain number of objects. For instance, we can stop listing
    objects and display an ellipsis after the fourth listed object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Leaving the ellipsis on the last line implies filling the grid row by row.
    To do that, we must set the `row_major` argument to `True` for our `grid_flow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A (bad) kind of magic
  prefs: []
  type: TYPE_NORMAL
- en: Arbitrary digits appearing in the middle of the code, such as those in `i >
    3`, are called **magic numbers**, and using them is considered bad practice as
    it makes it very difficult to find and change those values at a later stage.
  prefs: []
  type: TYPE_NORMAL
- en: A better solution is to make those numbers members of the class and access them
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Storing `3` as a static member makes it easier to display the number of remaining
    objects. String formatting also works with numeric variables, so we can compute
    how many objects are left and use the result in curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since `max_objects` is an attribute of the class, it can be changed via Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blender considers these add-ons to be Python modules, so it is possible to
    execute these lines in the **Python Console** or **Text** **Editor** area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The downside of this trick is that every reload of the add-on resets that value.
    A better way to change the settings in our add-on, which is by using `bpy.types.Preferences`,
    will be discussed in [*Chapter 6*](B18375_06.xhtml#_idTextAnchor129):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19: Changing the limit displays more than three objects](img/Figure_5.19_B18375.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.19: Changing the limit displays more than three objects'
  prefs: []
  type: TYPE_NORMAL
- en: Using icons and informative text adds to the visual feedback of our UI. In the
    next section, we’ll take advantage of the colors from layout states to convey
    status information.
  prefs: []
  type: TYPE_NORMAL
- en: Providing color feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our object list will be much more useful if we can highlight which objects
    are selected and which are active. For instance, to reflect the selection status
    of an object in the color of its name, our script must perform two actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether an object is selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it’s selected or active, display its name in a different color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s learn how to perform these tasks using Blender’s API.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether an object has been selected
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can get the selection status of an object using its `select_get()` method.
    For instance, if the `''Cube''` object is selected, its `selected_get` method
    will return `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We already know from [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033)*,* that,
    unlike the selection status, `active` is not a flag of the object, so how we retrieve
    this information is a bit different.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether an object is active
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To check whether an object is active, we can test whether it matches the one
    stored in `context.object`. Here’s what happens when `''Cube''` is the active
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to retrieve the activity status of an object, let’s look
    at ways we can alter the color of its labels.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing layouts in red or gray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, painting text with a different color is useful to make an entry
    stand out. Blender doesn’t allow us to set the color of a piece of text explicitly,
    but we can take advantage of two specific attributes that alter the way a UI layout
    is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UILayout.enabled = False` is meant to display an element without letting the
    user interact with it. This is very useful if we want to make the user aware that,
    even if an operation is not possible now, the interface for executing it is there
    to be found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UILayout.alert = True` is useful for warning the user about something wrong,
    or potentially wrong.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those are very specific purposes, but we can take advantage of how they affect
    the displayed color:'
  prefs: []
  type: TYPE_NORMAL
- en: UI layouts whose `enabled` attribute equals `False` are *gray*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI layouts whose `alert` attribute equals `True` are *red*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we can use that to change the color of an entire layout. Labels are not
    layouts, and the `label()` method returns a `None` type. Since we cannot set those
    attributes directly on the text labels, we need to create a new layout for each
    entry of the grid and use that when we create our text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can set `item_layout.enabled` to `True` for selected objects and `False`
    for the unselected ones with this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, we can set `item_layout.alert` by assigning the result of the equality
    test `(==`) directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the list now provides information about which objects are active
    and/or selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20: The active object is dark red, while unselected objects are
    gray](img/Figure_5.20_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.20: The active object is dark red, while unselected objects are gray'
  prefs: []
  type: TYPE_NORMAL
- en: We can also add buttons to perform some operations, as we’ll see in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intuitively, pushing a button performs a transformative action. Since buttons
    take up space, the default interface displays only the more generic operations.
    When we write custom interfaces, we can add more buttons based on our specific
    needs. This is made easier by how Blender translates operators into buttons. In
    this section, we’ll learn how buttons and operators are equivalent when it comes
    to the graphical interface.
  prefs: []
  type: TYPE_NORMAL
- en: Using the operator method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the `UILayout.operator` method to display a button. In Blender, a
    button executes an operator. This operator is found through its identifier – that
    is, the `bl_idname` attribute, which we encountered in [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049)
    – and every operator must have it.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, to add a button that deletes the selected objects, we must provide
    the identifier of the **Delete** operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the **Delete** action from the **Object** menu or the *X* key and
    look into the **Scripting** workspace, we will find this new line in the **Info**
    **Log** area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The part before the parentheses, `bpy.ops.object.delete`, is the operator class.
    We must be careful as we must not use the class itself as the argument of the
    operator, but the identifier of that class. We can get the identifier using the
    `idname()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Using the `'OBJECT_OT_delete'` string as the argument of `operator()` will create
    a **Delete** button.
  prefs: []
  type: TYPE_NORMAL
- en: ID please
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `operator` class instead of an operator’s identifier with `operator`
    causes `TypeError`: the operator and all the elements that follow it will not
    be displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: We can either use the `idname()` function or the identifier string directly.
    The function is preferred as it guarantees compatibility in case of future changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display a `draw` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what we’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21: The Delete button has been added to the panel](img/Figure_5.21_B18375.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.21: The Delete button has been added to the panel'
  prefs: []
  type: TYPE_NORMAL
- en: Pressing the **Delete** button deletes the selected object. It is equivalent
    to invoking **Object** | **Delete** from the menu.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the operator’s text and visibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can customize the button text or toggle the button’s display. For instance,
    we can hide `context`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reflect this information in the button label. The following snippet
    changes the button’s text according to the number of objects that have been selected.
    It also adds an “s” to the word “object” at the end so that it can use the plural
    form when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 5.22: The text of the button changes according to the selection](img/Figure_5.22_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.22: The text of the button changes according to the selection'
  prefs: []
  type: TYPE_NORMAL
- en: Nothing to hide (usually)
  prefs: []
  type: TYPE_NORMAL
- en: It is often said that hiding pieces of the UI is generally wrong as it leaves
    the user with no knowledge of where a feature can be found once the conditions
    have been met. This is generally a valid point, even though for didactical purposes,
    a disappearing button was used in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to abide by the “no-hiding” rule, we can add an `else` statement
    containing a disabled layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When coding, rules can be broken but not ignored!
  prefs: []
  type: TYPE_NORMAL
- en: Overriding an operator’s settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `delete` operator prompts a confirm dialog before deleting an object. This
    is its default behavior, and it can be overridden:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23: Clicking Delete opens a confirmation menu](img/Figure_5.23_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.23: Clicking Delete opens a confirmation menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is reflected in the documented docstring. If we type the operator’s address
    and press *Tab*, the autocomplete will display two optional arguments called `use_global`
    and `confirm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can learn more about this by looking at the API documentation. Right-clicking
    on the **Delete** button will display a menu containing a direct link:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24: The right-click menu of our Delete button can open the online
    documentation](img/Figure_5.24_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.24: The right-click menu of our Delete button can open the online
    documentation'
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation describes these Boolean arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`use_global` (Boolean, optional): Delete globally or remove the object from
    all scenes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`confirm` (Boolean, optional): Confirm or prompt for confirmation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: According to the documentation, setting `use_global` to `True` would remove
    the selected objects from all the currently opened scenes. We do not want that,
    so we are not changing the default value.
  prefs: []
  type: TYPE_NORMAL
- en: The `confirm` parameter, on the other hand, is `True` by default. We need to
    change that to `False`, and since the button takes care of invoking the operator,
    we need to change that in the button’s properties.
  prefs: []
  type: TYPE_NORMAL
- en: Setting operator properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `operator` function returns an `OperatorProperties` object, which is a
    class containing the attributes that can be set. Typically, we use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we will store the properties returned by `operator` in the `props`
    variable so that we can change them later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This button triggers the `delete` operator, which is native to Blender. Since
    the interface considers Python and built-in operators equivalent, we can display
    buttons for our operators too.
  prefs: []
  type: TYPE_NORMAL
- en: Adding buttons for our functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will add a button for displacing each of the selected objects randomly.
    This can be done to give a more “natural” look to our scene. To do that, we must
    write a new operator. Blender’s operators transform all the selected objects in
    the same way. First, we must import the `random` module at the beginning of our
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We proceed with our location function. It can be part of the operator class,
    but we can also write a function that stands on. The operator will call it inside
    its `execute` method. This function’s arguments are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The objects to dislocate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The max number of units to add or subtract from each object’s location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which axis should be affected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will feed the amount of displacement to the `randint` function, which will
    return a random integer number between a `min` and `max` range. We’ll do that
    for each of the three axes (*X*, *Y*, and *Z*), so long as their entries in `do_axis`
    are `True`. The `amount` and `do_axis` arguments are optional. We set their default
    values to `1` and `True, True, True` in the function’s declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need an operator to display in the interface. We will add properties
    for the `amount` and `do_axis` function arguments. To an operator, an integer
    and a tuple of Booleans are `IntProperty` and `BoolVectorProperty`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The operator methods are straightforward; `poll` only makes sure that there
    are objects selected, while `execute` runs `add_random_location`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding this operator to the layout displays a new button. As stated earlier,
    native and scripted operators are the same to the interfacee. In both cases, it
    looks for the operator’s identifier when it comes to invoking it. Scripted operators
    offer one small advantage, though: we can refer to their `bl_idname` attribute
    directly since their classes and our graphical interface belong to the same module
    or package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our line for displaying the **Add random** **Location** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And of course, we mustn’t neglect class registration and removal. Here’s the
    line we should add to `register()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, the add-on’s `unregister()` function should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'After invoking **Reload Scripts**, a new button will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25: Our panel now displays two buttons](img/Figure_5.25_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.25: Our panel now displays two buttons'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pressing this button should add random variation to the positions of selected
    objects since the operator properties do not pop up at execution. Even adding
    the `bl_options = {''REGISTER'', ''UNDO''}` operator property, which we learned
    about in the *Writing the Elevator add-on* section in [*Chapter 4*](B18375_04.xhtml#_idTextAnchor075),
    would not change that: operator properties must be displayed explicitly when they
    are not run from the **3D** **Viewport** area.'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the operator properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides `poll` and `execute`, Blender operators involve another method, named
    `invoke`. The `invoke` method is run internally right before `execute`. Usually,
    we don’t need to define it, but in this case, we use it to tell Blender that we
    want to display and edit the operator properties – that is, our function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides `self` and `context`, `invoke` takes `event` as an argument. It contains
    information about what triggered the operator, but we don’t need that now. We
    only tell `window_manager` to display the properties dialog. So, we must add a
    few lines of code after the `poll` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Reloading the scripts and pressing the `add_random_location` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26: Using operator properties as function arguments](img/Figure_5.26_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.26: Using operator properties as function arguments'
  prefs: []
  type: TYPE_NORMAL
- en: With that, our object panel is finished. As a bonus, next, we will learn how
    to move it to a different part of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Using different regions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, panels can be moved freely to another part of the interface. There
    are a few exceptions where repositioning a panel would not make much sense. For
    instance, a tool that helps select the controls of a character would be of little
    help in the Video Editor, and its `poll()` method might be looking for attributes,
    such as animation bones, outside of the animation’s `context`.
  prefs: []
  type: TYPE_NORMAL
- en: Outside of those cases, changing the `bl_*` attributes of a `Panel` class is
    enough to move our panel to a different place. Please refer to the *panel attributes*
    that we looked at in the *Creating a simple panel* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to display our panel in the `bl_space_type` and `bl_region_type` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 5.27: Our panel has been moved to the 3D Viewport area](img/Figure_5.27_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.27: Our panel has been moved to the 3D Viewport area'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `bl_category` attribute can be used to specify new or existing
    tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If a Blender add-on contains more panels, putting them under the same tab is
    a good way to keep the interface neat:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28: A Viewport tab created from the bl_category attribute](img/Figure_5.28_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.28: A Viewport tab created from the bl_category attribute'
  prefs: []
  type: TYPE_NORMAL
- en: We have reached the end of our interface overview. There will be more UI insights
    in the next few chapters when we introduce lists and thumbnails, but for now,
    we have built a solid understanding of how to use layouts in Blender.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create and populate a custom `UIPanel` via
    Python and how to integrate that into our add-on. That gave us insight into how
    the Blender interface works in general and which steps we must take to add our
    widgets to it.
  prefs: []
  type: TYPE_NORMAL
- en: We also nested layouts together for a more complex appearance and displayed
    both native and external icons.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we learned how to change our panel’s look according to the context without
    too much increase in complexity, as well as how to add functions to the UI.
  prefs: []
  type: TYPE_NORMAL
- en: This closes the first part of this book, where we gained an overall understanding
    of how Blender and Python work together and what Python scripts can do.
  prefs: []
  type: TYPE_NORMAL
- en: The add-on we have written relies on an external file called `icon_smile_64.png`.
    If we were to distribute it to the public, we would have to package it as a ZIP
    file. This is something we are going to do in [*Chapter 6*](B18375_06.xhtml#_idTextAnchor129),
    which marks the beginning of *Part 2*, *Interactive Tools* *and Animation*.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is it possible for an area of the screen to host more than one editor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do all the editors consist of the same regions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we set the editor, region, and context to which a panel belongs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Must we always set a panel’s category?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are the elements of a panel static or can they change dynamically?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we alter the color of a piece of text?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we display buttons?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 2: Interactive Tools and Animation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part exposes modular, structured add-ons that interact with the animation
    system. It also introduces modal tools that capture the user input and the different
    steps of an operator’s execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18375_06.xhtml#_idTextAnchor129), *Structuring Our Code and
    Add-Ons*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18375_07.xhtml#_idTextAnchor171), *The Animation System*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18375_08.xhtml#_idTextAnchor206), *Animation Modifiers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18375_09.xhtml#_idTextAnchor226), *Animation Drivers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18375_10.xhtml#_idTextAnchor247), *Advanced and Modal Operators*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
