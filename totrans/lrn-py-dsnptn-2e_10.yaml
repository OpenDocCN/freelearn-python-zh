- en: Chapter 10. The State Design Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover the State design pattern. Like the Command or
    Template design patterns, State pattern falls under the hood of Behavioral patterns.
    You will be introduced to the State design pattern, and we will discuss how it
    is used in software application development. We will work with a sample use case,
    a real-world scenario, and implement this in Python v3.5\.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will briefly cover these topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the State design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The State design pattern and its UML diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A real-world use case with the Python v3.5 code implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'State pattern: advantages and disadvantages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter, you will appreciate the application and context
    of the State design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the State design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behavioral patterns focus on the responsibilities that an object has. They deal
    with the interaction among objects to achieve larger functionality. The State
    design pattern is a Behavioral design pattern, which is also sometimes referred
    to as an **objects for states** pattern. In this pattern, an object can encapsulate
    multiple behaviors based on its internal state. A State pattern is also considered
    as a way for an object to change its behavior at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changing behavior at runtime is something that Python excels at!
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the case of a simple radio. A radio has AM/FM (a toggle
    switch) channels and a scan button to scan across multiple FM/AM channels. When
    a user switches on the radio, the base state of the radio is already set (say,
    it is set to FM). On clicking the Scan button, the radio gets tuned to multiple
    valid FM frequencies or channels. When the base State is now changed to AM, the
    scan button helps the user to tune into multiple AM channels. Hence, based on
    the base state (AM/FM) of the radio, the scan button's behavior dynamically changes
    when tuning into AM or FM channels.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the State pattern allows an object to change its behavior when its internal
    state changes. It will appear as though the object itself has changed its class.
    The State design pattern is used to develop Finite State Machines and helps to
    accommodate State Transaction Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the State design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The State design patterns works with the help of three main participants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`State`: This is considered to be an interface that encapsulates the object''s
    behavior. This behavior is associated with the state of the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteState`: This is a subclass that implements the `State` interface.
    `ConcreteState` implements the actual behavior associated with the object''s particular
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Context`: This defines the interface of interest to clients. `Context` also
    maintains an instance of the `ConcreteState` subclass that internally defines
    the implementation of the object''s particular state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the structural code implementation of the State design
    pattern with these three participants. In this code implementation, we define
    a `State` interface that has a `Handle()` abstract method. The `ConcreteState`
    classes, `ConcreteStateA` and `ConcreteStateB`, implement the State interface
    and, thus, define the `Handle()` methods specific to the `ConcreteState` classes.
    So, when the `Context` class is set for a state, the `Handle()` method of this
    state''s `ConcreteClass` gets called. In the following example, since `Context`
    is set to `stateA`, the `ConcreteStateA.Handle()` method gets called and prints
    `ConcreteStateA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the State design pattern](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the State design pattern with a UML diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in the previous section, there are three main participants in the
    UML diagram: `State`, `ConcreteState`, and `Context`. In this section, we will
    try to manifest them on a UML class diagram.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the State design pattern with a UML diagram](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand the elements of UML diagram in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`State`: This is an interface that defines the `Handle()` abstract method.
    The `Handle()` method needs to be implemented by `ConcreteState`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteState`: In this UML diagram, we have defined two `ConcreteClasses`:
    `ConcreteStateA`, and `ConcreteStateB`. These implement the `Handle()` method
    and define the actual action to be taken based on the `State` change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Context`: This is a class that accepts the client''s request. It also maintains
    a reference to the object''s current state. Based on the request, the concrete
    behavior gets called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple example of the State design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's understand all three participants with a simple example. Say, we want
    to implement a TV remote with a simple button to perform on/off actions. If the
    TV is on, the remote button will switch off the TV and vice versa. In this case,
    the `State` interface will define the method (say, `doThis()`) to perform actions
    such as switching on/off the TV. We also need to define `ConcreteClass` for different
    states. In this example, we have two major states, `StartState` and `StopState`,
    which indicate when the TV is switched on and the state in which the TV is switched
    off, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this scenario, the `TVContext` class will implement the `State` interface
    and keep a reference to the current state. Based on the request, `TVContext` forwards
    the request to `ConcreteState`, which implements the actual behavior (for a given
    state) and performs the necessary action. So, in this case, the base state is
    `StartState` (as defined earlier) and the request received by the `TVContext`
    class is to switch Off the TV. `TVContext` class understands the need and accordingly
    forwards the request to `StopState` concrete class which inturn calls the `doThis()`
    method to actually switch off the TV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output for the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple example of the State design pattern](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The State design pattern with v3.5 implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's now take a look at a real-world use case for the State design pattern.
    Think of a computer system (desktop/laptop). It can have multiple states such
    as `On`, `Off`, `Suspend`, or `Hibernate`. Now, if we want to manifest these states
    with the help of State design pattern, how will we do it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Say, we start with the `ComputerState` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: The state should define two attributes, which are `name` and `allowed`. The
    `name` attribute represents the state of the object, and `allowed` is a list that
    defines the state's object, which it is allowed to get into.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state must define a `switch()` method, which will actually change the state
    of the object (in this case, the computer).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code implementation of the `ComputerState` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now take a look at `ConcreteState`, which implements the `State` interface.
    We will define four states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`On`: This switches *on* the computer. The allowed states here are `Off`, `Suspend`,
    and `Hibernate`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Off`: This switches *off* the computer. The allowed state here is just `On`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hibernate`: This state puts the computer in the *hibernate* mode. The computer
    can only get switched on when it''s in this state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Suspend`: This state *suspends* the computer, and once the computer is suspended,
    it can be switched on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we explore the context class (`Computer`). The context does two main things:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__()`: This method defines the base state of the computer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`change()`: This method will change the state of the object, and the actual
    change in behavior is implemented by the `ConcreteState` classes (`on`, `off`,
    `suspend`, and `hibernate`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the implementation of the preceding methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code for the client. We create the object of the `Computer`
    class (`Context`) and pass a state to it. The state can be either of these: `On`,
    `Off`, `Suspend`, and `Hibernate`. Based on the new state, the context calls its
    `change(state)` method, which eventually switches the actual state of the computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can observe the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The State design pattern with v3.5 implementation](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '`__class__` is a built-in attribute of every class. It is a reference to the
    class. For instance, `self.__class__.__name__` represents the name of the class.
    In this example, we use `__class__ attribute` of Python to change the `State`.
    So, when we pass the state to the `change()` method, the class of the objects
    gets dynamically changed at runtime. The `comp.change(On)` code, changes the object
    state to `On` and subsequently to different states like `Suspend`, `Hibernate`,
    and `Off`.'
  prefs: []
  type: TYPE_NORMAL
- en: Advantages/disadvantages of the State pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the benefits of the State design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: In the State design pattern, an object's behavior is the result of the function
    of its state, and the behavior gets changed at runtime depending on the state.
    This removes the dependency on the if/else or switch/case conditional logic. For
    example, in the TV remote scenario, we could have also implemented the behavior
    by simply writing one class and method that will ask for a parameter and perform
    an action (switch the TV on/off) with an `if`/`else` block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With State pattern, the benefits of implementing polymorphic behavior are evident,
    and it is also easier to add states to support additional behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The State design pattern also improves **Cohesion** since state-specific behaviors
    are aggregated into the `ConcreteState` classes, which are placed in one location
    in the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the State design pattern, it is very easy to add a behavior by just adding
    one more `ConcreteState` class. State pattern thus improves the flexibility to
    extend the behavior of the application and overall improves code maintenance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have seen the advantages of state patterns. However, they also have a few
    pitfalls:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class Explosion**: Since every state needs to be defined with the help of
    `ConcreteState`, there is a chance that we might end up writing many more classes
    with a small functionality. Consider the case of finite state machines—if there
    are many states but each state is not too different from another state, we''d
    still need to write them as separate `ConcreteState` classes. This increases the
    amount of code we need to write, and it becomes difficult to review the structure
    of a state machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the introduction of every new behavior (even though adding behavior is
    just adding one more `ConcreteState`), the `Context` class needs to be updated
    to deal with each behavior. This makes the `Context` behavior more brittle with
    every new behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To summarize what we've learned so far, in State design patterns, the object's
    behavior is decided based on its state. The state of the object can be changed
    at runtime. Python's ability to change behavior at runtime makes it very easy
    to apply and implement the State design pattern. The State pattern also gives
    us control over deciding the states that objects can take up such as those in
    the computer example that we saw earlier in the chapter. The `Context` class provides
    an easier interface for clients, and `ConcreteState` makes sure it is easy to
    add behaviors to the objects. Thus, the State pattern improves cohesion, flexibility
    to extend, and removes redundant code blocks. We academically studied the pattern
    in the form of a UML diagram and learned about the implementation aspects of the
    State pattern with help of the Python v3.5 code implementation. We also took a
    look at the few pitfalls you might encounter when it comes to the State pattern,
    and the code which can significantly increase when it comes to adding more states
    or behaviors. I hope you had a nice time going through this chapter!
  prefs: []
  type: TYPE_NORMAL
