<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Introduction to Physical Computing Systems"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Introduction to Physical Computing Systems</h1></div></div></div><p>This chapter will focus on giving you an introduction to what physical computing systems are, what they are composed of, how they work and where they are used. First, we will get started with a brief introduction to physical computing systems, which will give you a basic idea about the basic composition of physical computing systems with an example followed by its application areas, and at the end we will see how we can build our own physical computing system using BeagleBone Black with a push button and LED using Python programming to change the LED state based on the push button press input.</p><p>The contents of the chapter are divided into the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Prerequisites</li><li class="listitem" style="list-style-type: disc">Introduction to physical computing systems</li><li class="listitem" style="list-style-type: disc">Basic elements of physical computing systems </li><li class="listitem" style="list-style-type: disc">Application areas</li><li class="listitem" style="list-style-type: disc">Simple project: Push button input triggers event on Python code to toggle LED on and off</li></ul></div><div class="section" title="Prerequisites"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Prerequisites</h1></div></div></div><p>This topic will<a id="id158" class="indexterm"/> cover what parts you need in this chapter. These can be purchased from your favorite electrical hobby store or can simply be ordered online. We will need the following materials:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">1 x BeagleBone Black</li><li class="listitem" style="list-style-type: disc">1 x microSD Card with latest version of Debian flashed on it to boot the BeagleBone board from the microSD Card</li><li class="listitem" style="list-style-type: disc">1 x 5V DC, 2A power supply</li><li class="listitem" style="list-style-type: disc">1 x Ethernet cable</li><li class="listitem" style="list-style-type: disc">1 x Breadboard</li><li class="listitem" style="list-style-type: disc">1 x push button switch</li><li class="listitem" style="list-style-type: disc">1 x LED</li><li class="listitem" style="list-style-type: disc">1 x 470-ohm resistor</li><li class="listitem" style="list-style-type: disc">1 x 4.7 Kilo <a id="id159" class="indexterm"/>ohm resistor</li></ul></div></div></div>
<div class="section" title="Introducing physical computing systems"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Introducing physical computing systems</h1></div></div></div><p>This section will give you a basic overview of physical computing systems. Physical computing systems<a id="id160" class="indexterm"/> are electronic systems that use software and hardware together to get input from the physical world using the hardware and respond to it by providing an output based on the software running on the hardware. These systems are also called embedded systems in different applications. In general terms, any system that interacts with the analog world using hardware sensors and senses the input obtained and responds accordingly based on the software programmed for it is called a physical computing system.</p><p>Right from your music player, washing machine, automatic door opener, and mobile phone, everything that takes input from the physical world using sensors and buttons and responds to it by making a change in the physical world with its output is a physical computing system.</p><p>Take, for example, your washing machine. Based on the input you provide by clicking on the buttons available on it, which is a physical input from the world to the washing machine system, it washes your clothes and dries them, which is again an output on the physical world; it is changing the physical things, the clothes, using air and water. So it is basically creating a change in the physical, analog world with its output, which is based on the software running on the hardware on the washing machine system with the sensors and actuators available on it. We will look at this in detail with block diagrams and more examples with explanations in the next section of this chapter, which looks at the basic components comprising a physical computing system and how they work.</p></div>
<div class="section" title="Basic elements of physical computing systems"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Basic elements of physical computing systems</h1></div></div></div><p>In this section, you will learn what physical computing systems are composed of. First, we will see <a id="id161" class="indexterm"/>the basic structure of input and output elements and how to act and react, followed by the structure of it based on the electrical, electronic, and software aspects, including the input and output of the system. At the end, we will try to get a much clearer picture of the same concepts with examples.</p><p>The basic <a id="id162" class="indexterm"/>structure of a physical computing system comprises sensors, which can be either analog or digital, that will take input from the physical world using input sensors that are connected to the hardware of the physical computing system, as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/4602_03_01.jpg" alt="Basic elements of physical computing systems"/></div><p>These inputs will be read by the software running on the electronic microprocessors and controllers on the physical computing system. Based on that software, a decision will be taken to provide the output and this output is converted from digital to analog form or makes a change in the physical world depending on the type of the actuators. So, basically, an action is being carried out based on the senses just like a human reflex actions and how they react to different senses. So the microcontroller or the computer chip that runs the software together acts as a brain and takes decisions based on the senses using the sensors connected to the hardware.</p><p>Let's look at a basic real-time example as discussed earlier to get a clear understanding of how the system works. A treadmill is a device people generally use for walking or running while staying in the same place, to do workouts in the gym, or some people even have them in their homes. These are powered by electric motors and have a sensor to read the speed at which the motor is running and a microcontroller unit / computer system with displays and buttons which runs a special software which reads these inputs from the sensor to measure speed as well as get input from the user to make the treadmill work at a particular speed. Shown in the following figure is a basic treadmill and below that you can see a basic block diagram as well:</p><div class="mediaobject"><img src="graphics/4602_03_02.jpg" alt="Basic elements of physical computing systems"/></div><p>So, basically, as you see in the preceding figure, the treadmill has a HiTech computer console with<a id="id163" class="indexterm"/> buttons and a basic display for the user to select the speed at which he wants to run. The computer is connected to the motor controller to operate the motor at that particular speed by reading the speed sensor to measure the speed and regulate it using the algorithms running on the computer and the output from the computer controls to the motor controller maintain the speed of the motor. If you have a look at the following figure, you will understand better, as the block diagram shows the operation clearly:</p><div class="mediaobject"><img src="graphics/4602_03_03.jpg" alt="Basic elements of physical computing systems"/></div><p>Looking at the treadmill example will have given you a clear idea about the basic structure of<a id="id164" class="indexterm"/> physical computing systems and their operation. Let's go ahead and look in detail at the electronics in the total hardware of the system, followed by how the software works with this hardware to make decisions and give input.</p><p>Before we discuss the hardware structure of physical computing systems, let's have a quick look at basic computer structure, as shown in the following diagram, as physical computing systems have evolved from computing systems basically; the structure of physical computing systems includes basic computing systems with added interfaces:</p><div class="mediaobject"><img src="graphics/4602_03_04.jpg" alt="Basic elements of physical computing systems"/></div><p>Shown above is the block diagram of a basic computer which contains the <span class="strong"><strong>central processing unit</strong></span> (<span class="strong"><strong>CPU</strong></span>) which<a id="id165" class="indexterm"/> stores data in the memory<a id="id166" class="indexterm"/> unit and processes it in the arithmetic and logic unit, and the control unit basically performs the data transfer between all the other units to make them work together. To the CPU we the Input and Output are interfaced. If you look at the following image of a basic computer, you can see that the system unit is the CPU, the monitor and speakers are output devices, and, similarly, the keyboard and mouse are input devices:</p><div class="mediaobject"><img src="graphics/4602_03_05.jpg" alt="Basic elements of physical computing systems"/></div><p>Based on the software running on the CPU, the input from keyboard and mouse carry out the process on<a id="id167" class="indexterm"/> the hardware and we can see the output in the monitor as well as hear via the speaker. The computers are advanced physical computing systems which have dedicated software, the operating systems running on them, and various protocols for communication. Now that we have clarity on how the computing system is structured, let's have a look at the structure of embedded hardware systems such as BeagleBone Black. We will look into the basic structure first, followed by a detailed hardware block diagram specific to BeagleBone Black:</p><div class="mediaobject"><img src="graphics/4602_03_06.jpg" alt="Basic elements of physical computing systems"/></div><p>Shown in the preceding diagram is the fundamental block diagram of any physical computing embedded hardware<a id="id168" class="indexterm"/> system, in other words, embedded systems with microcontrollers and microprocessers. Comparing the preceding block diagram and the basic block diagram of the computer, you can see that the input and output ports are elaborated and explained well in the preceding block diagram, where you can see digital and analog input ports are interfaced with the CPU and, similarly, we have the output ports with Analog and Digital outputs. We also have the communication ports such as UART, I2C, SPI, and so on.</p><p>In basic terms, Digital input ports are capable of reading a particular DC voltage or a range of DC voltages between two set limits as HIGH and similarly as set limit as LOW value, in other words, the <code class="literal">1</code> and <code class="literal">0</code> we use in computer language called digital HIGH and digital LOW respectively. An example of a digital input can be the press of a switch: when it's closed, it's HIGH, in other words, <code class="literal">1</code>, and when it's open, it's LOW, in other words, <code class="literal">0</code>. Analog input ports are those which take in Analog voltage between a range of values and convert them to digital output form to make it understandable to the CPU by converting it<a id="id169" class="indexterm"/> to 0s and 1s or digital HIGHs and LOWs. An example of an Analog input could be an analog temperature sensor which senses temperature around it and provides a voltage in the range from minimum value to maximum value corresponding to the temperature around the sensor. Converters that convert Analog voltage values to digital values are called <span class="strong"><strong>Analog to Digital converters</strong></span> (<span class="strong"><strong>ADCs</strong></span>). Similarly, there are Digital output ports that provide HIGH and LOW <a id="id170" class="indexterm"/>values only and there are Analog output ports that convert digital values to Analog Outputs. An example of Analog output could be the audio output you get from phones and music players or video through an Analog signal. And we also have the communication ports, which include different protocol-based communication ports such as UART, I2C, SPI, and so on. The availability of input, output, and communication ports varies from one device to another, depending on what microcontrollers or microprocessors they use and the architecture of the system.</p><p>Now, let's look in detail at what the hardware structure of BeagleBone Black looks like, as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/4602_03_07.jpg" alt="Basic elements of physical computing systems"/></div><p>So, as you can see in the preceding block diagram, the CPU consists of a Sitara AM3358BZCZ processor, with<a id="id171" class="indexterm"/> 2 GB of eMMC storage as <span class="strong"><strong>Read Only Memory</strong></span> (<span class="strong"><strong>ROM</strong></span>) and 512 MB of <span class="strong"><strong>Random Access Memory</strong></span> (<span class="strong"><strong>RAM</strong></span>) with different external ports for interfaces such as<a id="id172" class="indexterm"/> HDMI for video, USB client for USB communication, RJ45 ports for Internet access, and so on. The structure is similar to a basic computer, just as we know that the BeagleBone board is nothing but a single board computer with GPIOs. The expansion header block contains the GPIOs, which can made to act as digital input or digital output depending on how we desire it to work for us based<a id="id173" class="indexterm"/> on the software running on the processor. The expansion headers also include analog inputs to read analog values. I believe that this section might have given you a clear idea about the basic structure of physical computing systems and how our BeagleBone board is also structured in a similar way.</p><div class="section" title="Application areas"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec08"/>Application areas</h2></div></div></div><p>A few of the<a id="id174" class="indexterm"/> application areas where physical computing systems are used include almost all of modern-day technology gadgets and machines, from your mobile phones, fire alarms, and baby monitors, to home automation and industrial automation electronic systems, as well as the robotic systems used in homes and industries.</p><p>For example, what fire alarms with sprinkler systems in malls do is, basically, sense the temperature and smoke using sensors and whenever a event of fire is detected, they start the sprinkler system to sprinkle water from the tanks via the pipes and pumps using a control system that is continuously running the dedicated software that was written to do this operation.</p><p>Similarly, home automation systems, baby monitors that are connected to the Internet help you connect your home electronic devices to the Internet and dedicated artificial intelligence software programs running on the servers operate your air conditioning or lighting and heating, and so on, to make your life better. Similar applications are also seen in industry, where robots are making a huge difference in manufacturing industries and nowadays many robot bartender systems are in use.</p><p>So, I hope now you should be able to imagine a clear picture of the existence of physical computing systems around us and how they work.</p><p>In the sections and chapters coming after this, we will look into the building of different projects and use of these ports available on the expansion headers, including the digital inputs and outputs and Analog inputs to sense the input given from the physical world and build software by writing code on Python to make the system respond and act by providing output depending on the sensed input based on the software.</p></div></div>
<div class="section" title="Project &#x2013; toggle LED using a push button"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Project – toggle LED using a push button</h1></div></div></div><p>Now that we<a id="id175" class="indexterm"/> have a clear idea about what physical<a id="id176" class="indexterm"/> computing systems are and how they work, let's go ahead and build our own physical computing system using BeagleBone Black by connecting a push button switch to act as a input to the system and an LED which will act as the output. How we write the software program will decide what the LED does based on the input from the push button switch.</p><p>We already <a id="id177" class="indexterm"/>know how to connect an LED to the BeagleBone<a id="id178" class="indexterm"/> board and also how to program in Python to turn on and turn off the LED just as we experimented in the project of the last chapter. In this project, we will use the knowledge we gained and what we are going to learn now before we go ahead and build the physical computing system. Now that we know how to interface an LED, let's learn how to interface a push button and read input value from the push button connected to the BeagleBone board using Python.</p><p>First, connect the push button to BeagleBone Black, as shown in the following figure:</p><div class="mediaobject"><img src="graphics/4602_03_08.jpg" alt="Project – toggle LED using a push button"/></div><p>Once you have connected the push button switch to BeagleBone Black as shown in the preceding figure to the GPIO_115 / P9_27 pin on the GPIO header through the switch and resistor to pull down the state to LOW when the push button is not pressed, let's go ahead and read the input from the switch via the python interactive shell. </p><p>Pull-down <a id="id179" class="indexterm"/>and pull-up resistors are used to keep the input state <a id="id180" class="indexterm"/>with either low or high input supplied as input to the GPIO pin. You can do your own research on the Web to learn more about pull-down and pull-up resistors.</p><p>Open the Python interactive shell:</p><div class="mediaobject"><img src="graphics/4602_03_09.jpg" alt="Project – toggle LED using a push button"/></div><p>Import the GPIO library using the following line of code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import Adafruit_BBIO.GPIO as GPIO</strong></span>
</pre></div><div class="mediaobject"><img src="graphics/4602_03_10.jpg" alt="Project – toggle LED using a push button"/></div><p>Then let's define GPIO <code class="literal">P9_27</code> of BeagleBone Black as the input pin to which we have connected the switch using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>GPIO.setup("P9_27", GPIO.IN)</strong></span>
</pre></div><div class="mediaobject"><img src="graphics/4602_03_11.jpg" alt="Project – toggle LED using a push button"/></div><p>Next, read the current status of the GPIO using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>GPIO.input("P9_27")</strong></span>
</pre></div><div class="mediaobject"><img src="graphics/4602_03_12.jpg" alt="Project – toggle LED using a push button"/></div><p>That should print out the current status of GPIO P9_27; in the output shown in the preceding screenshot, it is <code class="literal">0</code>. Now the setup is as shown in the following image, where the button is not pressed; that is the reason the reading value of P9_27 GPIO is <code class="literal">0</code>:</p><div class="mediaobject"><img src="graphics/4602_03_13.jpg" alt="Project – toggle LED using a push button"/></div><p>When you <a id="id181" class="indexterm"/>press the push button and hold it and then read the <a id="id182" class="indexterm"/>input, you will get the input value as <code class="literal">1</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/4602_03_14.jpg" alt="Project – toggle LED using a push button"/></div><p>So, as shown in the preceding screenshot, when the button is pressed, the value that will be read is <code class="literal">1</code>, as shown in the preceding screenshot on the python console:</p><div class="mediaobject"><img src="graphics/4602_03_15.jpg" alt="Project – toggle LED using a push button"/></div><p>Now that we <a id="id183" class="indexterm"/>know the basic functions using which we can<a id="id184" class="indexterm"/> read the input status of the push button, let's go ahead and write the python program which will read the push button status in real time and print it every half a second.</p><p>First, let's create the python file:</p><div class="mediaobject"><img src="graphics/4602_03_16.jpg" alt="Project – toggle LED using a push button"/></div><p>Then, let us type the program as shown in the following screenshot and save it:</p><div class="mediaobject"><img src="graphics/4602_03_17.jpg" alt="Project – toggle LED using a push button"/></div><p>Next we will run the Python code:</p><div class="mediaobject"><img src="graphics/4602_03_18.jpg" alt="Project – toggle LED using a push button"/></div><p>When you<a id="id185" class="indexterm"/> run the python code, the output will be as shown in<a id="id186" class="indexterm"/> the preceding screenshot when you don't press the push button.</p><p>And when you press and hold it, the output will be as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/4602_03_19.jpg" alt="Project – toggle LED using a push button"/></div><p>When you leave the button again and leave it to come back to its previous position, the output will be as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/4602_03_20.jpg" alt="Project – toggle LED using a push button"/></div><p>Now let's go <a id="id187" class="indexterm"/>ahead and modify the code in such a way <a id="id188" class="indexterm"/>that, instead of printing the current status of the switch, the python program prints that the button was pressed every time you press it and leave it. Save the python code with the name <code class="literal">ButtonPress.py</code>:</p><div class="mediaobject"><img src="graphics/4602_03_21.jpg" alt="Project – toggle LED using a push button"/></div><p>When you run the code and press the button, you will get the output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/4602_03_22.jpg" alt="Project – toggle LED using a push button"/></div><p>Every time you <a id="id189" class="indexterm"/>press the push button switch and leave it, you <a id="id190" class="indexterm"/>will get the text <span class="strong"><strong>Button pressed!</strong></span> printed on the shell.</p><p>Now that we have the basic logic figured out to print the button press event, we will go ahead and modify this code to toggle the LED to on and off every time the button is pressed.</p><p>Before we move on to programming BeagleBone Black to toggle the LED, let's connect the LED to BeagleBone Black, as shown in the following circuit diagram with the push button switch as well:</p><div class="mediaobject"><img src="graphics/4602_03_23.jpg" alt="Project – toggle LED using a push button"/></div><p>Now, write the program to toggle the LED to the On and Off state alternatively for every press of the button, as shown in the following screenshot, and save the file with the name <code class="literal">ButtonLEDToggle.py</code> or a name of your choice:</p><div class="mediaobject"><img src="graphics/4602_03_24.jpg" alt="Project – toggle LED using a push button"/></div><p>Then, when <a id="id191" class="indexterm"/>you run the code and then press the button, you<a id="id192" class="indexterm"/> can see that the LED goes On and Off alternatively every time you press the push button. The output will be as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/4602_03_25.jpg" alt="Project – toggle LED using a push button"/></div><p>When the LED is off as shown in the following image:</p><div class="mediaobject"><img src="graphics/4602_03_26.jpg" alt="Project – toggle LED using a push button"/></div><p>When you <a id="id193" class="indexterm"/>press the button and leave it, the LED will turn on, as <a id="id194" class="indexterm"/>shown in the following image:</p><div class="mediaobject"><img src="graphics/4602_03_27.jpg" alt="Project – toggle LED using a push button"/></div><p>Again, when you press the button, the LED will toggle back to the Off state:</p><div class="mediaobject"><img src="graphics/4602_03_28.jpg" alt="Project – toggle LED using a push button"/></div><p>This will<a id="id195" class="indexterm"/> happen alternatively every time when you press <a id="id196" class="indexterm"/>the push button, the led will toggle to HIGH and LOW state. </p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Summary</h1></div></div></div><p>Here we are at the end of the chapter where we learnt the fundamental concept of how a physical computing system works with the help of the basic structure of these systems with BeagleBone Black as an example. We also discussed a few application areas in the real world. Then, we saw how to interface a push button switch with a BeagleBone board and write python code to read its status by accessing the GPIO pin as an input from python. At the end, we worked on a very basic project to understand how we can build our own physical computing system that senses and reacts to the physical world using a push button and LED to toggle the LED from On to Off every time you push the button.</p><p>In the next chapter, we will see how we can build a much more complex physical computing system with an Analog temperature sensor, unlike a digital input reading from the input from the push button we read. But before you go to the next chapter, I would suggest you write different programs to make the LED do whatever you like using the button press event; for example, you can count how many button presses have to be made and, based on that, you can make the led blink for that many times and then get back to the mode where it will wait for the next number of clicks. Try anything that comes in your mind and play with the hardware and coding.</p></div></body></html>