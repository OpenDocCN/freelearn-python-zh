- en: Chapter 10. Advanced Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the following few advanced topics that can
    be used to take your scripts farther:'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Python functionality in MEL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom tools using contexts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using script jobs to trigger custom functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using script nodes to embed code in scenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining script jobs and script nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll look at a few advanced topics that can be used to give
    your scripts extra polish and make them easier to use for your teammates. We'll
    see how to make your scripts work like Maya's built-in tools using contexts, trigger
    custom functionality in response to events using script jobs, and embed code into
    a scene using script nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll look at a tool that can be used to embed custom functionality
    in a scene and trigger it when a specific object is selected (very useful for
    invoking complex UIs for character rigs, for example).
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Python functionality in MEL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Python is definitely the preferred way to go about scripting for Maya,
    there are some features that still require you to use MEL. We'll be seeing several
    of those features in this chapter, but first we'll need to look at how to call
    Python code from MEL.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First off, we''ll need a Python script to call. You can either use something
    you''ve already written or make something new. For the sake of this example, I''ll
    use a new script that simply creates a NURBS sphere at the origin, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we''ll create an MEL script that will in turn call our Python
    script. Create a new file and add the following code, being sure to save it with
    a `.mel` extension. In this case, we''ll create a file named `melToPython.mel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that the function defined in the file has the same name as the file itself;
    this is a standard practice when creating MEL scripts, and it is used to indicate
    the entry point for the script. You can certainly have multiple functions within
    the script, but there should generally always be one with the same name as the
    file, and that function should be the starting point for your script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure to save the script to one of Maya''s default script locations. On a
    Mac system, that means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And on a PC, it means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once you've done this, you'll need to make sure that Maya is aware of the new
    script, which means calling the rehash MEL command from within Maya. Switch your
    command line to MEL by clicking to the left of the text field, where it says **Python**.
    Alternatively, switch to the **MEL** tab in the script editor and enter your code
    there.
  prefs: []
  type: TYPE_NORMAL
- en: The rehash command forces Maya to re-examine its list of known script locations
    and take note of any new MEL scripts that have been added. This happens automatically
    every time Maya starts up, but if you make a new script with Maya open and attempt
    to run it without first calling rehash, Maya will give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've run rehash, you can run our new MEL script by entering the name
    of the script into either the command line or the script editor. Doing so should
    result in a new NURBS sphere appearing at the origin.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MEL script is pretty straightforward. Note that functions are defined in
    a slightly different manner, with a few minor differences. The `proc` keyword
    (short for *procedure*) serves the same purpose as `def` in Python, indicating
    a named block of code. Also, instead of having a colon after the parentheses,
    curly brackets are used to enclose the actual code.
  prefs: []
  type: TYPE_NORMAL
- en: The `global` keyword indicates that this particular function is meant to be
    called from outside the script. It is very common practice when writing MEL to
    have a global procedure with the same name as the file, which serves as the entry
    point for the script.
  prefs: []
  type: TYPE_NORMAL
- en: We're mainly interested in getting this script to invoke some Python functionality,
    though. To do that, we rely on the `python` MEL command. The `python` command
    takes a string as an argument and will attempt to run that string as a line of
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we wanted to invoke Python''s `print` command from MEL, we
    could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that MEL differs from Python in that arguments to built-in functions are
    *not* enclosed in parentheses. So, in the previous example, the `python` command
    receives a string as its single argument. That string is passed to the Python
    interpreter and, in this case, results in some text being printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually run a Python script from MEL, we''ll need to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the import statement to load the script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke a function from within the script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That means that we need to call MEL''s `python` command twice. Importing is
    fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The second line requires a bit of explanation. When we use the `import` command
    to load a script, the script is loaded as a module. Each of the functions defined
    in the script are attributes of the module. So, to invoke a function defined the
    script, we''ll want to use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Wrapping that in a string and passing it to MEL gives us the following for
    the `makeSphere()` function defined in the `pythonFromMel` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We could optionally combine both the `import` statement and the call to `makeSphere`
    into a single line. To do that, we'll need to separate out the two statements
    with a semicolon. While Python doesn't *require* semicolons at the end of statements,
    it does allow them. In most cases, that's not necessary, but if you need to have
    multiple statements on a single line, it can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we did that, we would end up with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will prove useful later, when we need to pass in MEL commands to invoke
    Python functionality as a single line.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It should be mentioned that Maya provides a built-in utility for creating MEL
    scripts from a given Python script, in the `createMelWrapper` command, defined
    as part of the `maya.mel` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to invoke that on the `makeSphere` function that we used in this
    example, we could do that by running the following code in the **Python** tab
    of the script editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'That would prompt you for a place to save the created MEL script. If you open
    the created script, you''ll see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Differences in formatting aside, the generated script is almost identical to
    what we wrote. The only real difference is that it explicitly imports just the
    `makeSphere` command, rather than the entire `pythonFromMel` module.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom tools using contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of Maya's tools are used in an interactive manner, with the user specifying
    inputs as needed, and actions taking place either when the necessary number of
    inputs have been provided, or the user hits the *Enter* key.
  prefs: []
  type: TYPE_NORMAL
- en: So far, none of our scripts have worked this way—it has been necessary to have
    the user explicitly run the script, or press a button. That works fine for many
    things, but providing interactive input can add a lot of polish to a script. In
    this example, we'll be doing exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a script that, once invoked, prompts the user to select two or
    more objects. When they press the *Enter* key, we'll create a locator at the average
    position of all of the objects. To do that, we'll need to create a custom context
    to implement our very own tool.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating custom tools using contexts](img/4657_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our custom tool in action. Left image is the tool while it's being used (notice
    the custom "AVG" icon on the left), and right image shows the result—a new locator
    at the average position of the selected objects
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script as presented makes use of a custom icon. While it''s not required,
    it''s a nice bit of polish. If you want to do that as well, create a 32 by 32
    pixel transparent PNG, and save it to the icons folder. On a mac, that would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '...and on a PC, it means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new file and add the following code. Be sure to name it `customCtx.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you run the script, you'll see that Maya activates your new icon in the left
    UI, just like is the case with any of the other tools. *Shift*-select at least
    two objects, and press the *Enter* key. You'll see a new locator appear at the
    averaged position of the selected objects.
  prefs: []
  type: TYPE_NORMAL
- en: As an additional feature, you'll find that the *Y* hotkey, which can be used
    to re-invoke the most recently used tool, will also start your script over again.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First off, we create a couple of functions that will be used by the new context,
    one that gets called when it starts, and another that gets called when it ends.
    The `start` script is very simple (just prints some text) and is just included
    for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The function that gets called at the end is a bit more involved, but still nothing
    too complex. We start by grabbing the currently-selected objects, and setting
    up a few variables—one to hold the number of objects, and one each for the x,
    y, and z position that we'll create the locator at.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Next, we run through all of the objects and grab their position using the `xform`
    command in query mode. We add each of the x, y, and z positions to our variables
    to create a running tally of positions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We then divide each of the position variables by the number of objects to average
    the positions, create a new locator, and move it to the averaged position.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now for the fun part—actually setting up a custom context. We start by creating
    MEL strings that can be used to invoke our two functions. In both cases, they
    simply call one of the functions defined as part of our script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that we're not explicitly importing `customCtx` before invoking the functions
    (as we did in the previous example). That's because we're using functionality
    defined within the same script, so if this code is executing at all, the `customCtx`
    script must have already been imported.
  prefs: []
  type: TYPE_NORMAL
- en: Now we're ready for the main event- creating a new context using the `scriptCtx`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is a pretty big command, so let's go through the arguments.
    First off, we use the `i1` flag to specify the icon to use for the tool. You can
    leave this out, but if you do, Maya will highlight a blank spot in the UI while
    your tool is active. Be sure to make the icon 32x32 pixels, and to put it in the
    icons folder (see *Getting ready*, above).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the title. This is also optional, but will make the text that appears
    a bit more useful for the user. Similarly, we could leave out the `setNoSelectionPrompt`
    flag, but it's best to leave it in. Setting both the title and `setNoSelectionPrompt`
    flag will cause helpful text to show up in bottom of Maya's interface.
  prefs: []
  type: TYPE_NORMAL
- en: Now we get to the meat of the command, with the `toolStart` and `finalCommandScript`
    flags. Both have to be passed a single string that corresponds to a MEL command
    that should be run either at the start of the script, or when *Enter* is pressed.
    We pass in the MEL strings that we created for each, which will in turn invoke
    Python functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The next set of flags all have to do with the specifics of the selection. First
    off, we set the number of selection sets to `1`, meaning that we want a single
    collection of items. After that, we use the `setSelectionCount` flag to specify
    that there should be at least two items selected for the tool to function. In
    this case, we also want to allow for the user to select more than two objects,
    so we set the `setAllowExcessCount` flag to `true`. Since we want to allow the
    user to specify a variable number of objects, and not finish the command until
    they press *Enter*, we need to set `setAutoComplete` to `false`. Setting it to
    `true` would cause the final command script to be run as soon as the user had
    selected objects equal to the `setSelectionCount` number. That's certainly useful
    in some cases, but isn't what we want here.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set the `toolCursorType` flag to `create`. That will set the cursor
    that gets used during the tool. Maya offers a number of different options, and
    choosing the best one for your purposes can be a great way to add a professional
    touch to your tool (as well as give the user some quality feedback). For the list
    of options, be sure to check the documentation for the `scriptCtx` command.
  prefs: []
  type: TYPE_NORMAL
- en: Whew—that was a lot of flags, but we're done, and ready to wrap things up. At
    this point in the script, we've created the new context, but it is not yet active.
    To actually invoke the tool, we need to use the `setToolTo` command, and pass
    in the output of the call to `scriptCtx`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: And with that, we've added a brand-new tool to Maya.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we created our own, custom tool. You can also invoke Maya's
    built-in tools by using the appropriate command to create a context of that type,
    and then switching to it using `setToolTo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might be creating a script to allow users to create character
    rigs in a semi-automated way. You might, as a part of that, want to have the user
    create some bones that are then manipulated further by your system. You could
    have that process begin with the user creating some bones using the joint tool.
    To drop them straight into bone creation after invoking your script, you could
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There are a large number of contexts that you can create—consult the Maya documentation
    for the full list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something else you might find useful is the ability to reset the current context,
    which will discard any input so far and reset the current tool. You can do that
    with either your own custom tools or with those built into Maya. Either way, reset
    the current tool with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Contexts are a great way to add polish to your scripts, but should only really
    be used when it makes sense to have the user add input in an interactive way,
    or if you expect the user to want to use your tool more than once in rapid succession.
    If you have a script that you only expect the user to use once, with a limited
    (and fixed) number of inputs, it's likely easier to just provide a button. However,
    if your script needs to work with a variable number of inputs and or be called
    again on a new set without re-invoking the script, you may want to consider creating
    a context. Another way to look at it is that you should only use contexts when
    they would offer a net *reduction* in work (as measured in number of clicks) for
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: Using script jobs to trigger custom functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Script jobs offer another alternative to explicitly calling scripts, or pressing
    buttons, to invoke your functionality. By using script jobs, it is possible to
    trigger custom functionality based on either a specific condition or a specific
    event.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll create a script job that will respond to the selection
    changed event by printing the name and type of the selected object to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the things that makes script jobs so useful is the fact that they persist
    (as opposed to just running once). However, that can make developing scripts that
    use them a bit difficult, since if you change your code and re-run your script,
    you''ll end up with multiple script jobs in your scene. For that reason, it''s
    good to give yourself a way to easily clear out all existing script jobs. The
    following script will do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Running the `scriptJob` command with the `killAll` flag will clear out all normal
    script jobs in the scene. However, script jobs can also be created as either `protected`
    or `permanent`. Adding the force flag will also clear out protected script jobs
    as well, but be careful with that, as Maya uses `scriptJobs` to implement some
    of its UI functionality. To be totally safe, leave off the `force=True` flag and
    make sure that the `scriptJobs` you create are not protected.
  prefs: []
  type: TYPE_NORMAL
- en: Permanent script jobs will persist until you create a new scene, but that shouldn't
    come up in development. Even if you really do want a permanent script job, it's
    best to develop it with default priority and upgrade it to permanent only once
    you're certain that you're getting the functionality you want.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to have the above script (or similar) available before you start working
    with script jobs, as it will definitely make your life a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and add the following code. Be sure to name the file `selectionOutput.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Run the above script, and you should see text appear in the bottom of Maya's
    UI every time you select (or deselect) an object.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First off, note that we're importing the sys (or system) library in addition
    to our standard `maya.cmds`. That's to allow us to print text to the command line,
    so that it will be visible to the user even if they don't have the script editor
    open. More on that in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we create the `scriptJob`, we''ll want to create the code we want it
    to call. In this case, we''ll be triggering code every time the selection changes,
    and we want that code to examine the currently-selected object(s). We start, as
    we have in other examples, by using ls to grab the selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Then, if we find that there is nothing selected, we output some text to the
    command line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And here's where that `sys` library comes in—by using `sys.stdout.write`, we
    are able to output text directly to the command line. That can be a good way to
    provide feedback to the users of your scripts, since you shouldn't expect them
    to have the script editor open. Note that we *could* have used either the error
    or warning commands as well, but since this text is simply output, and neither
    an error nor a warning, it is better to use `stdout.write`.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the `selectionChanged` function is pretty straightforward. The only
    slightly tricky thing is that if we look at the node type for the selected nodes
    themselves, we're guaranteed to get nothing but transforms. To avoid that, we
    first check to see if there are any shape nodes connected to the node in question.
    If there are, we append the node type for the shape to the name of the object,
    and output that to the command line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now we're ready for the fun part—actually making `scriptJob`. All `scriptJobs`
    require that we specify either an event or a condition, along with some code to
    execute when the event is triggered, or when the condition assumes a given value
    (true, false, or when it changes).
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that the events and conditions must correspond to those
    that are built into Maya. In this case, we'll be using the `SelectionChanged`
    event as our trigger. This will fire every time the selection changes for any
    reason, and no matter how many objects are selected (including zero).
  prefs: []
  type: TYPE_NORMAL
- en: To actually create the `scriptJob`, we use the `scriptJob` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we use the event flag to tell Maya that this `scriptJob` should
    be event-based (as opposed to being based on a condition). The value that we pass
    into the flag needs to be an array, with the first element being a string that
    corresponds to the event we want to watch for, and the second being a function
    to call in response.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we want to call our `selectionChanged` function in response to
    the `SelectionChanged` event. We also include the `killWithScene` flag, which
    will cause `scriptJob` to be destroyed when we leave the current scene, which
    is generally a good idea. There are certainly valid reasons to have `scriptJob`
    persist from scene to scene, but unless you're sure that that's what you want,
    it's usually a good idea to prevent that from happening.
  prefs: []
  type: TYPE_NORMAL
- en: And that's it! We will now have our custom function called each time the selection
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Getting ready* section, we covered a simple script to delete *all* `scriptJobs`.
    That's fine during testing, but can be a bit heavy-handed sometimes. There are
    many situations where you might want to delete only a specific `scriptJob`—possibly
    because the functionality it is being used to implement is no longer necessary.
    That's easily done, but requires you specify which `scriptJob` you want to delete.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating a new script job, the `scriptJob` command will return an integer
    that can be used as the ID of the created script job. Later, you can use that
    number to delete that specific script job while leaving any other script jobs
    in the scene intact. If you want to delete a script job later, make sure to save
    the output to a variable as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to delete the script job, call the `scriptJob` command again, but with
    the kill flag, and passing in the ID, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If the script job you''re trying to delete is protected, you''ll need to also
    set the `force` flag to `true`, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `scriptJob` command to get a list of all of the script
    jobs currently active. To do that, run it with the `listJobs` flag set to `True`.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '...which would result in something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '...as well as a long list of other script jobs used by Maya, as well as any
    that you have added. The number on the left is the ID of the job, and can be used
    to delete it (as long as it isn''t *permanent*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative to deleting all jobs, or deleting individual jobs by ID,
    you can also have Maya delete a script job when a given piece of UI is deleted.
    For example, if we wanted to have a script job that would only exist as long as
    a given window was open, we could do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Notice the addition of the `parent` flag in the call to `cmds.scriptJob`. You
    can include that flag to tie the script job to a specific piece of UI. In this
    case, we tie the script job to the window.
  prefs: []
  type: TYPE_NORMAL
- en: Using script nodes to embed code in scenes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the examples we've seen so far exist as scripts, separate from the actual
    scene that they are run in. That's fine for tools, but means that if you create
    a script that is tightly tied to a particular scene (such as a custom control
    UI for a character rig), you have to be careful to make sure that the script file
    is always distributed along with the Maya file.
  prefs: []
  type: TYPE_NORMAL
- en: For such situations, Maya offers a better way. Script nodes can be used to bake
    scripts directly into a scene, allowing them to be run without any external dependencies.
    Furthermore, script nodes can be created with code.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll create a script that will prompt the user for a Python
    file, and will then create a script node with the contents of the file, and set
    it up so that the script will be executed each time the file is opened.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use the script we'll be creating, we'll need to have a script ready to embed.
    For the sake of the example, I'll be using a simple script that shows a window
    containing a single button to create a NURBS sphere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Run the script, and point the resulting file browser at the script that you
    want to embed. Save your file, and re-open it. You should see your embedded script
    run automatically.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing that we do is to invoke the `fileDialog2` command to prompt
    the user to provide a Python file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If the user cancels out of the dialog without specifying a file, `filePath`
    will be empty. We check for that and end the script early if it is.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If we *do* have a file, we open it for reading, in text mode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we're ready to prep the script for embedding. The `scriptNode`
    command will be expecting a single string for the code that makes up the script
    node, so we'll need to create such a string. To do that, we'll start out with
    a blank string, and add each line of the python file specified by the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the `scriptStr` variable holds the entire contents of the specified
    script. Since we're done with the file, we close it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now we're ready to actually create the script node. Creating a script node requires
    that we specify a few different things. First off, we need to specify whether
    the script is MEL or Python, which we do with the `sourceType` flag.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to specify the conditions under which the code in the script node
    will be run, which requires that we specify both a condition and whether the code
    should be executed either before or after it. In this case, we'll be using what
    is probably the most standard option, in that we'll have the script run once when
    the scene is first loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we want to use the **Execute on file load** option, and set our
    code using the `beforeScript` flag. Putting it all together gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `scriptType` flag specifies the condition, and needs to be an integer between
    `0` and `7`. Using a value of `2` will tie the node to the opening of the scene
    when not in batch mode. If you wanted to have the script run on opening even in
    batch mode, use `1` instead. Using a value of `0` will only run the code when
    it is explicitly invoked—more on that in a bit. The other options are less commonly
    used—see the documentation for details.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is also an `afterScript` flag which can be used to tie code
    execution to after the given event. If you use that with either of the file load
    options (1 or 2), it will cause the code to be executed when the file is closed.
    You can specify scripts for both the `beforeScript` and `afterScript` flags if
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also use `scriptNodes` to embed functionality that doesn''t execute
    on its own, but is triggered directly. To do that, specify a value of 0 for the
    `scriptType` (corresponding to the **Execute on demand** option). Then, when you
    want to invoke the code, call it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: … to run the "before" script, or..
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '...to run the "after" script.'
  prefs: []
  type: TYPE_NORMAL
- en: As you work with script nodes, it can be helpful to verify that they have been
    created without directly triggering them. To do that, go to **Windows** | **Animation
    Editors** | **Expression Editor**. From the expression editor, go to **Select
    Filte**r | **By Script Node Name**. You'll see the interface change, and a list
    of the script nodes in your scene appear. Clicking on any of them will allow you
    to alter its properties and view or edit the corresponding code.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/4657_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can also delete script nodes from this window, if you need to.
  prefs: []
  type: TYPE_NORMAL
- en: Combining script jobs and script nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the great things about script jobs, and script nodes, is that you can
    use script nodes to ensure that a given script job travels along with your scene.
    For example, you might want to use a script job to trigger a custom character
    rig UI any time the user selects a certain object in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll create a script that will make it really easy to set
    such things up. Our script will perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It will ask the user to point it at a Python file with one or more functions
    to create UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will present the user with a list of all functions defined in the file in
    a scroll list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will allow the user to select an object in the scene and a named function
    from the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will embed the contents of the function into the scene as a script node,
    along with a script job that will run the function every time the specified object
    is selected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the script we''ll be writing, you''ll need to have a script with at
    least one top-level function definition. Note that the current form of the script
    cannot parse functionality that is part of a class, and will only deal with a
    single function at a time, so make sure that all of your functionality is self-contained
    in a single function. For best results, make sure your input file looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First off, we create a class for our UI, in order to make it easier to pass
    data around.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `__init__` function, we add three items:'
  prefs: []
  type: TYPE_NORMAL
- en: A button to load and parse a source file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A button to tie a specific function to the selection of a specific object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `textScrollList` command to hold the function names and allow the user to
    select them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also give ourselves a `commandList` variable, which is a dictionary that
    we'll be using to hold the commands found in the file. The index of each element
    will be the name of the function, and the value will be the entire source code
    for that function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dictionaries are one of Python's built-in data structures, and are equivalent
    to what are sometimes called **associative arrays** in other languages. The big
    difference between dictionaries and lists is that, in lists, you specify entries
    by a numerical index, while with dictionaries you specify entries by name.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can create a simple dictionary with `myDict = {'foo':1, 'bar':2}`.
  prefs: []
  type: TYPE_NORMAL
- en: '…which would create a dictionary with two entries—one for `foo` and another
    for `bar`. Accessing those values looks a lot like indexing into a list, just
    with the name instead of a number, as in `print(myDict[''foo''] # would print
    1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting that all together gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we implement the `loadScript` function. We start by clearing out our
    `commandList` variable, in case the user is specifying a new file, then ask them
    to point us at a Python source file to load.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If we find a file, we open in in read mode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now we're ready to actually read the file. We start by creating two variables—one
    to hold the human-friendly function name, which we'll display in the `textScrollList`
    command, and another to hold the actual source code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done that, we start parsing the file. We loop through the file
    in the same way that we''ve done in previous examples, reading each line in turn—the
    only difference is how we parse the contents. Setting aside the handling of the
    file contents for a moment, the outer part of our parsing should look familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Onto the parsing—what we want to do is to capture all of the text for each function.
    That means we want everything from the line that defines the function to the function's
    end. Finding the end of the function requires some thought, however. What we're
    looking for is not only a blank line but, more specifically, a blank line that
    does *not* have a tab character.
  prefs: []
  type: TYPE_NORMAL
- en: We start by ignoring the import statement. We test to see if the current line
    starts with `import` and if so, we use the pass statement to skip doing anything.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that we could use the `continue` statement to skip the rest of the loop,
    but that would also skip the line responsible for reading in the next line of
    the file, leaving us with an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check to see if the line starts with `def`, indicating that it represents
    a new function definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If it does, we want to start collecting the code for the new function, but
    first we want to save the function that we were previously stepping through, if
    one exists. To do that, we check to see if our `functionName` and `functionStr`
    variables are blank. If they both have contents, it is because we were previously
    saving another function, which we insert into our function list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This would happen if the file that we're parsing had a new function definition
    on the line directly below a previous function, with no blank lines in between.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've dealt with the previous function (if there was one), we're ready
    to start storing our new function. We'll start by getting a more human-friendly
    form of the function name by discarding the `def` keyword, as well as the parentheses
    and colon.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we first use the split function to break the line up into an array
    by spaces, giving us `def` in the first index and something like `myFunction():`
    in the second. We then use replace to remove the `():`. That gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we set our `functionStr` variable to the entire line. As we continue
    to parse the file, we'll add additional lines to this variable. When we encounter
    either a new `def` statement, or truly empty (no tab character) lines, we'll store
    the entire `functionStr` into our list of commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Speaking of blank lines, that's the next thing that we check for. If the line
    contains nothing but whitespace characters, running it through the `strip()` function
    will give us an empty string. If we do find an empty string, we might be at the
    end of the current function, but we'll want to make sure by testing to see if
    the current line starts with a tab.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If we do have a truly blank line (no tabs), and we've been building up a function,
    now's the time to store it to our list. Once again, we check to make sure that
    both our `functionName` and `functionStr` variables have contents, and if they
    do, we store the function code into our `commandList`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In order to prevent the script from storing the same function more than once
    (in the event of multiple blank lines), we also reset both our `functionName`
    and `functionStr` variables to be blank.
  prefs: []
  type: TYPE_NORMAL
- en: If none of the above code has been triggered, we know that we have a non-blank
    line that starts with neither `import` or `def`. We'll assume that any such line
    is a valid line of code, and is part of the current function. As such, we simply
    add it on to our `functionStr` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: And with that, we're done parsing our file, and we close it. At this point,
    our `commandList` dictionary will have an entry for each function in the file.
    We'll want to show those functions to the user by adding them to our scroll list,
    which we do in our `updateList` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `updateList` function, we want to first clear out the contents of `scrollList`,
    and then add an entry for each of the functions we found. Both are easily done
    by calling the `textScrollList` command in edit mode. First, we clear it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we run through our list of commands and add the name of each to the list
    with the `append` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now all that's left is to implement the function that will actually create the
    script node. First, we want to make sure that the user has selected both a command
    from the scroll list and an object in the scene. To get the currently selected
    item in the scroll list, we use the `textScrollList` command once again, but this
    time in query mode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have a `[0]` at the end of the `textScrollList` command. That's
    necessary, since `textScrollList` widgets can allow for multiple item selection.
    As a result, the output of querying `selectItem` may have multiple values, and
    is returned as an array. Adding the `[0]` gives us the first element (if there
    is one).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code for grabbing the selected object is simple, and should look very familiar
    indeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: If we have *both* an object and a command, we're ready to dive into the script
    node creation. If we don't, we display an error message to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our script node, what we want is code that will perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Run on the start of the scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include the definition of the selected function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include the definition of a function that can be run every time the selection
    changes. That function will need to compare the currently selected object to the
    target object and, if there's a match, invoke the trigger function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a script job tied to the `SelectionChanged` event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How it works...](img/4657_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Left: the UI displaying a list of functions in the input file. Right: the result-
    selecting the specified sphere triggers a custom UI.'
  prefs: []
  type: TYPE_NORMAL
- en: That's a number of steps, but ultimately it all amounts to constructing a big
    string that has all of the features listed above. We start off by setting our
    string to the `import maya.cmds as cmds` line that we've been using in all of
    our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note that there are two newline characters at the end of the line. That will
    make things more readable, and make it easier to check the results in the expression
    editor in case there are problems.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add the code for the command we want to trigger. This is really easy,
    since we have all of the code stored in our `commandList` dictionary. All we need
    to do is to index into it using the command name that the user selected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to create the code for the function responsible for checking the
    current selection against the target object and running the target script. To
    do that, we'll need to string together some boilerplate code and the specific
    names (of the object and function) that we happen to have.
  prefs: []
  type: TYPE_NORMAL
- en: 'In situations like this, it''s generally helpful to write out what the result
    should look like given a specific input first. Let''s say that we wanted to trigger
    a function named `myFunction` if an object named `triggerObject` was selected.
    To do that, we could use the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Easy enough, right? All we need to do is to add the above text to our `nodeStr`
    variable, making sure that we replace the object and function name, and that we
    add proper tabs (`\t`) and newline characters (`\n`) so that we follow proper
    Python whitespace rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'That ends up giving us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'All that''s left is to add the code that will create a script job to properly
    tie our `testSelection` method to the `SelectionChanged` event. We add one final
    line to our `nodeStr` variable to do just that, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We're very close to done, but what we have is still just a big chunk of text.
    To actually make it into a script node, we'll need to pass it into the `scriptNode`
    command as the `beforeScript` value, with `scriptType=2` in order to have it run
    at scene startup.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! We now have a way to embed arbitrary UI code into a scene and
    have it trigger when a given object is selected.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As it stands, this example is more of a proof of concept than a proper tool.
    In the interest of brevity, I was forced to leave out several things that one
    would want, but the script could easily be extended to include all of them.
  prefs: []
  type: TYPE_NORMAL
- en: First off, the script only deals with single functions. For a proper character
    rig UI, it would be likely that we would want to include a collection of functions,
    possibly bundled together into one or more classes. In order to support that,
    the script would need to be changed to either copy the entire contents of a source
    file to the script node, or to have more sophisticated parsing of the file contents
    to include multiple functions.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the script as written would not work as desired if it was used more than
    once in the same scene, since every pairing of function and object uses the same
    name (`testSelection`) for the function tied to the script job.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix that, we would want to ensure that each script job gets its own uniquely-named
    function to test the selection. One way to do that would be to append the name
    of the function that we ultimately want to trigger to the `testSelection` function
    name, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
