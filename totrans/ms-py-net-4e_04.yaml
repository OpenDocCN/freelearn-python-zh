- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python Automation Framework – Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous two chapters incrementally introduced different ways to interact
    with network devices. In *Chapter 2*, *Low-Level Network Device Interactions*,
    we discussed the Pexpect and Paramiko libraries, which manage an interactive session
    to control interactions. In *Chapter 3*, *APIs and Intent-Driven Networking*,
    we started to think of our network in terms of API and intent. We looked at various
    APIs that contain a well-defined command structure and provide a structured way
    of getting feedback from the device. As we moved from *Chapter 2*, *Low-Level
    Network Device Interactions*, to *Chapter 3*, *APIs and Intent-Driven Networking*,
    we began to think about our intent for the network. We gradually began to express
    our network as code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, let’s expand upon the idea of translating our intention into
    network requirements. If you have worked on network designs, chances are the most
    challenging part of the process is not the different pieces of network equipment
    but rather the qualifying and translating of business requirements into the actual
    network design. Your network design needs to solve business problems. For example,
    you might be working within a larger infrastructure team that needs to accommodate
    a thriving online e-commerce site that experiences slow site response times during
    peak hours. How do you determine whether the network is the problem? If the slow
    response on the website was indeed due to network congestion, which part of the
    network should you upgrade? Can the rest of the system take advantage of the greater
    speed and feed?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is an illustration of a simple process of the steps that
    we might go through when trying to translate our business requirements into a
    network design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B18403_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Business logic to network deployment'
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, network automation is not just about faster configuration change.
    It should also solve business problems while accurately and reliably translating
    our intention into device behavior. These are the goals that we should keep in
    mind as we march on our network automation journey. In this chapter, we will look
    at a Python-based framework called **Ansible**, which allows us to declare our
    intention for the network and abstract even more from the API and CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ansible architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible advanced topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin by looking at an overview of the Ansible framework.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible – A More Declarative Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine yourselves in a hypothetical situation: you woke up one morning in
    a cold sweat from a nightmare you had about a potential network security breach.
    You realize your network contains valuable digital assets that should be protected.
    You have been doing your job as a network administrator, so it is pretty secure,
    but you want to put more security measures around your network devices just to
    be sure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, you break the objective down into two actionable items:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upgrading the devices to the latest version of the software. The steps include
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading the image to the device
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Instructing the device to boot from the new image
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Proceeding to reboot the device
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Verifying that the device is running with the new software image
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configuring the appropriate access control list on the networking devices,
    which includes the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing the access list on the device
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the access list on the interface under the interface configuration
    section
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Being an automation-focused network engineer, you want to write scripts to reliably
    configure the devices and receive feedback from the operations. You begin to research
    the necessary commands and APIs for each step, validate them in the lab, and finally,
    deploy them in production. Having done a fair amount of work for OS upgrade and
    ACL deployment, you hope the scripts are transferable to the next generation of
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Wouldn’t it be nice if there was a tool that could shorten this design-develop-deployment
    cycle? In this chapter, we will work with an open-source automation framework
    called Ansible. It is a framework that can simplify the process of going from
    business logic to completing the job without getting bogged down with specific
    network commands. It can configure systems, deploy software, and orchestrate a
    combination of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible is written in Python and has emerged as one of the leading automation
    tools for Python developers. It is also one of the most supported automation frameworks
    by network vendors. In the *‘Python Developers Survey 2020’* by JetBrains, Ansible
    is ranked #1 for configuration management tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Python Developers Survey 2020 Results (source: https://www.jetbrains.com/lp/python-developers-survey-2020/)'
  prefs: []
  type: TYPE_NORMAL
- en: Ever since version 2.10, Ansible has separated the release schedule for **ansible-core**
    and community packages. It is a bit confusing, so let’s take a look at the differences.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prior to version 2.9, Ansible has a fairly straightforward versioning system,
    going from 2.5, 2.6, 2.7, and so on ([https://docs.ansible.com/ansible/latest/roadmap/old_roadmap_index.html](https://docs.ansible.com/ansible/latest/roadmap/old_roadmap_index.html)).
    Starting from version 2.10, we see the jump from Ansible project 2.10, 3.0, 4.0,
    and so on ([https://docs.ansible.com/ansible/latest/roadmap/ansible_roadmap_index.html#ansible-roadmap](https://docs.ansible.com/ansible/latest/roadmap/ansible_roadmap_index.html#ansible-roadmap)).
    What gives? The Ansible team wants to separate the core engine, modules, and plugins
    from the wider community-curated modules and plugins. This allows the core team
    to move faster with the core features while allowing time for the community to
    catch up with the maintenance of their code.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about “Ansible,” we are referring to a collection of community
    packages at that level, say, version 3.0\. In the version, it will specify a version
    of `ansible-core` (initially called `ansible-base`) it requires. For example,
    Ansible 3.0 requires ansible-core 2.10 and above, while Ansible 4.0 requires ansible-core
    2.11+. In this structure, we can upgrade ansible-core to the latest version while
    keeping the community packages in an older release if needed.
  prefs: []
  type: TYPE_NORMAL
- en: If want to learn more about the versioning split, Ansible provides a useful
    Q&A page when they first adopted Ansible 3.0, [https://www.ansible.com/blog/ansible-3.0.0-qa](https://www.ansible.com/blog/ansible-3.0.0-qa).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move ahead and look at an Ansible example.
  prefs: []
  type: TYPE_NORMAL
- en: Our First Ansible Network Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is an IT automation tool. Its main attributes are simplicity and ease
    of use with minimum moving parts. It manages machines in an agent-less manner
    (more on this later) and relies on the existing operating system credentials and
    remote Python software to run its code. Ansible is installed on a centralized
    machine called the controlled node and executes on the machine it wishes to control,
    called the managed node.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Ansible Architecture (Source: https://docs.ansible.com/ansible/latest/getting_started/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: As with most IT infrastructure automation, Ansible started by managing servers.
    Most servers have Python installed or are capable of running Python code; Ansible
    would leverage this feature by pushing the code to the managed node and having
    it run locally on the managed node. However, as we know, most network devices
    are not capable of running native Python code; therefore, when it comes to network
    automation, the Ansible configuration is run locally first before making the changes
    to the remote devices.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on how network automation is different, check out this
    document from Ansible, [https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html).
  prefs: []
  type: TYPE_NORMAL
- en: Let us install Ansible on the control node.
  prefs: []
  type: TYPE_NORMAL
- en: The Control Node Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will install Ansible on the Ubuntu host in our lab. The only requirements
    for the control node are Python 3.8 or newer as well as Python’s `pip` package
    management system
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the installed Ansible version as well as other package-level information
    via the ‘—version’ switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you are interested in installing Ansible on specific operation systems using
    their respective package management systems, please consult the Ansible documentation,
    [https://docs.ansible.com/ansible/latest/installation_guide/installation_distros.html](https://docs.ansible.com/ansible/latest/installation_guide/installation_distros.html).
  prefs: []
  type: TYPE_NORMAL
- en: There is some important information displayed in the output. The most important
    is the Ansible core version (2.13.3) and configuration file (none for now). This
    is all we need to get started with Ansible, we can start to construct our first
    automation task.
  prefs: []
  type: TYPE_NORMAL
- en: Lab Topology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible is known to have many different ways to accomplish the same task. For
    example, we can define Ansible configuration files in different locations. We
    can also specify host-specific variables in a variety of places such as an inventory,
    in playbooks, in roles, and the command line. This is too confusing for people
    who are just getting started with Ansible. In this chapter, I will use just one
    way of doing things that makes the most sense to me. Once we learn the basics,
    we can always consult the documentation to find out other ways to accomplish a
    task.
  prefs: []
  type: TYPE_NORMAL
- en: For the first example, we will use the same lab topology that we have been using
    and run the task against the two IOSv devices, `lax-edg-r1` and `lax-edg-r2`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_04_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Lab Topology'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we will need to think about is how to define the hosts we want
    to manage. In Ansible, we use an inventory file to define the host we intend to
    manage. Let us create a file called `hosts` and put the following text in the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This type of file is in an INI format ([https://en.wikipedia.org/wiki/INI_file](https://en.wikipedia.org/wiki/INI_file)),
    which states I have a group of devices called the `ios_devices` with members of
    `iosv-1` and `iosv-2`.
  prefs: []
  type: TYPE_NORMAL
- en: We should now specify the particular variables associated with each host.
  prefs: []
  type: TYPE_NORMAL
- en: The Variable Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many places we can put the variables associated with a host. Let
    us create a folder called `host_vars` and two files with the names of the files
    identical to the hosts we specified in the inventory file. The directory and filenames
    are important because that is how Ansible matches up the variables with the host.
    Below is an output to show the directory and files within that directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The file is where we will put the necessary information belonging to the host.
    For example, we can specify the IP address, username, password, and other information.
    Here is the output of the `iosv-1` file for our lab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This file is in YAML format ([https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html](https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html)).
    The ‘---’ symbol indicates the start of the document. Below the start symbol,
    we have many key-value pairs. The keys all start with `ansible` and the value
    is separated from the key with a colon. The `ansible_host`, `ansible_user`, and
    `ansible_ssh_pass` should be changed to values matching your own lab. How do I
    know these names? Ansible documentation is our best friend here. Ansible has a
    standard way of naming these parameters listed in its documentation, [https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html](https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html).
  prefs: []
  type: TYPE_NORMAL
- en: Prior to Ansible 2.8, network modules did not have a standard way of naming
    the parameters, which is very confusing. Since version 2.8, the network modules
    have become much better at standardizing the parameters with the rest of the Ansible
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have defined the respective files for the host variables, we are ready
    to construct an Ansible playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Our First Playbook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Playbooks are Ansible’s blueprint to describe what you would like to do to the
    managed nodes, using modules. This is where we will be spending the majority of
    our time as operators when working with Ansible. What are modules? In a simplified
    view, modules are pre-built codes that we can use to accomplish a certain task.
    Similar to Python modules, the code can come with the default Ansible installation
    or it can be installed separately.
  prefs: []
  type: TYPE_NORMAL
- en: If we use an analogy of building a tree house with Ansible, the playbook will
    be the instruction manual, the modules will be the tools we use, and the inventory
    will be the components we work on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The playbook is designed to be human-readable in YAML format ([https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html](https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html)).
    We will write our first playbook, named `ios_config_backup.yml`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note the `-` in front of `name`, it specifies a list item in YAML. Everything
    in the same list item should have the same indentation. We set `gather_facts`
    to `false` because most network tasks are executed locally before making the changes
    to the devices. The `gather_facts` were mainly used when the managed nodes were
    servers to gather server information before any of the tasks were executed.
  prefs: []
  type: TYPE_NORMAL
- en: There are two key-value pairs in the list item, `hosts` and `tasks`. The `hosts`
    variable with the value of `all` specifies that we will work on all the hosts
    in the inventory file. The `tasks` key has another list item in the value, which
    uses the `ios_config` module ([https://docs.ansible.com/ansible/latest/collections/cisco/ios/ios_config_module.html#ansible-collections-cisco-ios-ios-config-module](https://docs.ansible.com/ansible/latest/collections/cisco/ios/ios_config_module.html#ansible-collections-cisco-ios-ios-config-module)).
    The `ios_config` module is one of the collections of modules installed along with
    Ansible. It also has a variety of arguments. We use the `backup` argument and
    set it to `yes` to indicate we will back up the devices’ `running-config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next task we will do is to use the new LibSSH connection plugin for Ansible.
    By default, Ansible network SSH connections use the Paramiko library. However,
    the Paramiko library does not guarantee FIPS readiness and is a bit slow when
    we need to connect to multiple devices. We will install LibSSH as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will specify the usage in a new `ansible.cfg` file. We will create the file
    in the same directory as our playbook with the following content. In the same
    configuration file, we will also set `host_key_checking` to be `false`; this is
    to prevent an error if the host is not initially in the `known_hosts` list in
    the `ssh` setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can execute the playbook via the `ansible-playbook` command with
    the `-i` switch to indicate the inventory file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Just like magic, if we take a look at our working directory where the playbook
    is executed, we will see a folder named `backup` with the two devices’ running
    configurations with timestamps! This command can now be scheduled to run via `cron`
    to run nightly to back up all of our devices’ configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on executing your first Ansible playbook! Even with a playbook
    as simple as ours, this is a very useful automation task that we were able to
    accomplish in a short amount of time. We will expand on this playbook in just
    a bit, but first, let’s take a look at why Ansible is a good fit for network management.
    Remember that Ansible modules are written in Python; that is one advantage for
    a Pythonic network engineer, right?
  prefs: []
  type: TYPE_NORMAL
- en: The Advantages of Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many infrastructure automation frameworks besides Ansible—namely Chef,
    Puppet, and SaltStack. Each framework offers its unique features; no one right
    framework fits all organizations. In this section, let’s take a look at some of
    the advantages of Ansible and why I believe it is a good tool for network automation.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages will be listed with limited comparison to other frameworks to
    not start a flame war. Other frameworks might adopt some of the same philosophies
    or certain aspects of Ansible, but rarely do they contain all of the features
    that I will be mentioning. It is the combination of all the following features
    and philosophies that makes Ansible ideal for network automation.
  prefs: []
  type: TYPE_NORMAL
- en: Agentless
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike some of its peers, Ansible does not require a strict master-client model.
    No software or agent needs to be installed on the client that communicates back
    to the server. Outside of the Python interpreter, which many platforms have by
    default, there is no additional software needed.
  prefs: []
  type: TYPE_NORMAL
- en: For network automation modules, instead of relying on remote host agents, Ansible
    uses SSH or API calls to push the required changes to the remote host. This further
    reduces the need for a Python interpreter. This is huge for network device management,
    as network vendors are typically reluctant to put third-party software on their
    platforms. SSH, on the other hand, already exists on the network equipment. As
    we saw from *Chapter 3*, *APIs and Intent-Driven Networking*, newer network devices
    also provide an API layer, which can also be leveraged by Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Because there is no agent on the remote host, Ansible uses a `push` model to
    push the changes to the device, as opposed to the `pull` model, where the agent
    pulls the information from the master server. The `push` model is more deterministic
    as everything originates from the control machine. In a `pull` model, the timing
    of the `pull` might vary from client to client and therefore results in timing
    variance.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the importance of being agentless cannot be stressed enough when working
    with the existing network equipment. This is usually one of the major reasons
    network operators and vendors embrace Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Idempotence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to Wikipedia, idempotence is the property of certain operations in
    mathematics and computer science that can be applied multiple times without changing
    the result beyond the initial application ([https://en.wikipedia.org/wiki/Idempotence](https://en.wikipedia.org/wiki/Idempotence)).
    In more common terms, it means that running the same procedure repeatedly does
    not change a system after the first time. Ansible aims to be idempotent, which
    is good for network operations that require a certain order of operations. In
    our first playbook example, there is a ‘changed’ value when the playbook is run;
    this value will be ‘false’ if there was no change made on the remote device.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of idempotence is best compared to the Pexpect and Paramiko scripts
    we have written. Remember that these scripts were written to push out commands
    like an engineer was sitting at the terminal. If you were to execute the script
    10 times, the script would make the same changes 10 times. If we write the same
    task via the Ansible playbook, the existing device configuration will be checked
    first, and the playbook will only execute if the changes do not exist. If we execute
    the playbook 10 times, the change will only be applied during the first run, with
    the next 9 runs suppressing the configuration change.
  prefs: []
  type: TYPE_NORMAL
- en: Being idempotent, we can repeatedly execute the playbook without worrying that
    there will be unnecessary changes made. This is important as we need to automatically
    check for state consistency without extra overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Simple and Extensible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible is written in Python and uses YAML for the playbook language, both of
    which are relatively easy to learn. Remember the Cisco IOS syntax? This is a domain-specific
    language that is only applicable when you are managing Cisco IOS devices or other
    similarly structured equipment; it is not a general-purpose language beyond its
    limited scope. Luckily, unlike some other automation tools, there is no extra
    **domain-specific language** (**DSL**) to learn for Ansible because YAML and Python
    are both widely used as general-purpose languages.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is extensible. As illustrated by the preceding example, Ansible starts
    with automating server (primarily Linux) workloads in mind. It then branches out
    to manage Windows machines with PowerShell. As more and more people in the network
    industry have started to adopt Ansible, network automation is now the main staple
    in Ansible workgroups.
  prefs: []
  type: TYPE_NORMAL
- en: The simplicity and extensibility speak well for future-proofing. The technology
    world is evolving fast, and we are constantly trying to adapt. Wouldn’t it be
    great to learn a technology once and continue to use it, regardless of the latest
    trend? Ansible’s track record speaks well for future technology adaptation.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered some of the advantages of Ansible, let’s build on what
    we have learned so far with more features.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Content Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start by listing out all the modules we have at hand with the default
    Ansible installation. They are organized into Content Collections ([https://www.ansible.com/products/content-collections](https://www.ansible.com/products/content-collections)),
    sometimes called collections for abbreviation. We can list out the collections
    via the `ansible-galaxy collection list` command. Some of the notable network
    collections are listed out below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As shown from the list, even with the default installation, there is a large
    collection of network-related modules we can use. They range from enterprise software
    to open-source projects. Taking a look at the list and reading up on the ones
    that are of interest in your production environment would be a good start. Ansible
    documentation also provides a full list of all the available collections, [https://docs.ansible.com/ansible/latest/collections/index.html](https://docs.ansible.com/ansible/latest/collections/index.html).
    The collections can also be expanded via the `agalaxy` `install` command, [https://docs.ansible.com/ansible/latest/user_guide/collections_using.html](https://docs.ansible.com/ansible/latest/user_guide/collections_using.html).
  prefs: []
  type: TYPE_NORMAL
- en: More Ansible Network Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first Ansible network example took us from being a noob to running our first
    useful network automation task. Let’s try to build from the foundation and learn
    more features.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by seeing how we can build an inventory file that includes all
    of our network devices. If you recall, we have two data centers, each with core
    and edge devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Full Lab Topology'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will include all of the devices in our inventory file.
  prefs: []
  type: TYPE_NORMAL
- en: Inventory Nesting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can build an inventory file that includes nesting. For example, we can put
    together a host file named `hosts_full` that includes children from one group
    to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file, we group the devices via both roles and features using the `[<name>:children]`
    format. To work with this new inventory file, we will need to update the `host_vars`
    directory to include the respective names of the devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to change the `ansible_host` and `ansible_network_os` accordingly,
    using `lax-cor-r1` as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use the parent’s group name to include its children. For example,
    in the `nxos_config_backup.yml` playbook, we only specified the parent group of
    `nxos_devices` instead of `all`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When we execute this playbook, it will automatically include its children, `lax_cor_devices`
    and `nyc_cor_devices`. Also note that we use a separate `nxos_config` module ([https://docs.ansible.com/ansible/latest/collections/cisco/nxos/nxos_config_module.html#ansible-collections-cisco-nxos-nxos-config-module](https://docs.ansible.com/ansible/latest/collections/cisco/nxos/nxos_config_module.html#ansible-collections-cisco-nxos-nxos-config-module))
    to accommodate the new device type.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible conditionals are similar to conditional statements in programming languages.
    Ansible uses conditional keywords to only run a task when a given condition is
    met. In many cases, the execution of a play or task may depend on the value of
    a fact, variable, or the previous task result. For example, if you have a play
    to upgrade router images, you want to include a step to make sure the new router
    image is on the device before you move on to the next play of rebooting the router.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will look at the `when` clause, which is supported for
    all modules. The `when` clause is useful when you need to check the output of
    a variable or a play execution result and act accordingly. Some of the conditions
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Equal to (`eq`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not equal to (`neq`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater than (`gt`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater than or equal to (`ge`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less than (`lt`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less than or equal to (`le`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following playbook named `ios_conditional.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the playbook, there are two tasks. In the first task, we use the `register`
    module to save the output of the command `show` `run` | `i hostname` in a variable
    called `output`. The `output` variable contains a `stdout` list with the output.
    We use the `when` clause to only show the output when the hostname is `nyc-edg-r2`.
    Let’s execute the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can see the output of `lax-edg-r1`, `lax-edg-r2`, and `nyc-edg-r1` were skipped
    because they did not meet the condition. Furthermore, we can see the `changed=0`
    output for all the devices. This is in accordance with the idempotency feature
    of Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration Change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can combine the conditional with configuration changes—for example, in the
    following playbook, `ios_conditional_config.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We would only change the logging buffer when the condition is met. Here is
    the output when we execute the playbook for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nyc-edg-r2` device console will show the configuration is changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when we run the playbook for the second time, the same change is NOT
    applied again because it is already changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How cool is that? With a simple playbook, we can safely apply a configuration
    change to only the devices we want to apply the change to with idempotency in
    check.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Network Facts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prior to 2.5, Ansible networking shipped with a number of vendor-specific fact
    modules. As a result, the naming and usage of the facts were different between
    vendors. Starting with version 2.5, Ansible started to standardize its network
    fact modules. The Ansible network fact modules gather information from a system
    and store the results in facts prefixed with `ansible_net_`. The data collected
    by these modules is documented in the *return values* in the module documentation.
    This is useful as we can gather network facts and only perform tasks based on
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of the `ios_facts` module, below is the content of the `ios_facts_playbook`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We are introducing a concept of variables in this playbook. The double curly
    brackets of `{{ }}` indicates it is a variable and the value of the variable should
    be presented for the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon execution of the playbook, here is a partial output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can now leverage the facts to combine with our conditional clause to customize
    our operations.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ansible provides a number of looping functions in the playbook: standard loops,
    looping over files, sub-elements, `do-until`, and many more. In this section,
    we will look at two of the most commonly used loop forms: standard loops and looping
    over hash values.'
  prefs: []
  type: TYPE_NORMAL
- en: Standard Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Standard loops in playbooks are often used to easily perform similar tasks
    multiple times. The syntax for standard loops is very easy: the `{{ item }}` variable
    is the placeholder looping over the `loop` list. In our next example, `standard_loop.yml`,
    we will loop over the items in the `loop` list with the `echo` command showing
    the output from our `localhost`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s go ahead and execute the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same concept, we can systematically add VLANs to our devices. Here
    is an example of adding three VLANs to a host with a playbook titled `standard_loop_vlan_example.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The playbook output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the playbook, the loop list can be read from a variable,
    which gives greater flexibility to the structure of your playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The standard loop is a great time saver when it comes to performing redundant
    tasks in a playbook. Let us see how we can loop over a dictionary in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Looping over Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we need to generate a configuration, we often have an entity with more
    than one attribute associated with it. If you think about the VLAN example in
    the last section, each VLAN would have several unique attributes, such as a description,
    a gateway IP address, and possibly others. Often, we can use a dictionary to represent
    the entity to incorporate multiple attributes into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s expand on the previous example to include a dictionary variable in `standard_loop_vlan_example_2.yml`.
    We defined the dictionary values for three `vlan` each with a nested dictionary
    for the description and the IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the playbook, we configure the first task to add the VLANs by using the key
    of the items. In the second task, we proceed with configuring the VLAN interfaces
    using the values within each of the items. Note that we use the `parents` parameter
    to uniquely identify the section the commands should be checked against. This
    is due to the fact that the description and the IP address are both configured
    under the `interface vlan <number>` subsection in the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we execute the command, we need to make sure the layer 3 interface feature
    is enabled on the `nyc-cor-r1` device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the playbook as we have done previously. We can see the dictionary
    being looped through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify the end result on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For more loop types of Ansible, feel free to check out the corresponding documentation
    ([https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_loops.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Looping over dictionaries takes some practice the first few times you use them.
    But just like standard loops, looping over dictionaries will be an invaluable
    tool in our tool belt. An Ansible loop is a tool that can save us time and make
    the playbook more readable. In the next section, we will look at Ansible templates
    that allow us to make systematic changes to text files commonly used for network
    device configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ever since I started working as a network engineer, I have always used some
    kind of network templating system. In my experience, many of the network devices
    have sections of the network configuration that are identical, especially if these
    devices serve the same role in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, when we need to provision a new device, we use the same configuration
    in the form of a template, replace the necessary fields, and copy the file over
    to the new device. With Ansible, you can automate all of the work by using the
    templating feature ([https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_templating.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible uses Jinja ([https://jinja.palletsprojects.com/en/3.1.x/](https://jinja.palletsprojects.com/en/3.1.x/))
    templating to enable dynamic expressions and access to variables and facts. Jinja
    has its own syntax and method of doing loops and conditionals; fortunately, we
    just need to know the very basics of it for our purpose. The Ansible template
    module is an important tool that we will be using in our daily tasks, and we will
    spend more of this section exploring it. We will learn the syntax by gradually
    building up our playbook from some simple tasks to more complex ones.
  prefs: []
  type: TYPE_NORMAL
- en: The basic syntax for template usage is very simple; we just need to specify
    the source file and the destination location that we want to copy it to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us create a new directory called `Templates` and start to create our playbooks.
    We will create an empty file for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will use the following playbook, `template_1.yml`, to copy `file1`
    to `file2`. Note that the playbook is executed on the control machine only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the playbook will create a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In our templates, the source files can have any extension, but since they are
    processed through the Jinja2 template engine, let’s create a text file called
    `nxos.j2` as the template source. The template will follow the Jinja convention
    of using double curly braces to specify the variables, as well as using the curly
    brace plus the percentage sign to specify commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We can now put together a playbook to create network configuration templates
    based on the `nxos.j2` file.
  prefs: []
  type: TYPE_NORMAL
- en: The Jinja Template Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `template_2.yml` playbook expands on the previous template example with
    the following additions:'
  prefs: []
  type: TYPE_NORMAL
- en: The source file is `nxos.j2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The destination filename is now a variable taken from the `nexus_devices` variable
    defined in the playbook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the devices within `nexus_devices` contains the variables that would
    be substituted or looped over within the template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The playbook might look more complex than the last one, but if you take out
    the variable definition portion, it is very similar to our simple template playbook
    from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Let us not execute the playbook just yet; we still need to take a look at the
    `if` conditional statements and `for` loops enclosed within the `{% %}` symbols
    from the `Jinja2` template.
  prefs: []
  type: TYPE_NORMAL
- en: Jinja Template Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two `for` loops in our `nxos.j2` template; one loops over the VLANs
    and the other loops over the VLAN interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If you recall, we can also loop through a list as well as a dictionary in Jinja.
    In our example, the `vlans` variable is a list, while the `vlan_interfaces` variable
    is a list of dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: The `vlan_interfaces` loop is nested inside a conditional. This is the last
    thing that we will incorporate into our playbook before we execute the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Jinja Template Conditional
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Jinja supports an `if` conditional check. We have added this conditional statement
    in two locations within the `nxos.j2` template; one is with the `netflow` variable
    and the other is the `l3_vlan_interfaces` variable. Only when the condition is
    `True` will we execute the statements within the block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the playbook, we have declared `netflow_enable` to be `True` for `nx-os-v1`
    and `False` for `nx-osv-2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are ready to run our playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you remember that the destination files are named after the `{{ item.key
    }}.conf?` Two files have been created with the device names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s check the similarities and differences of the two configuration files
    to make sure all of our intended changes are in place. Both files should contain
    the static items, such as `feature ospf`, the hostnames and other variables should
    be substituted accordingly, and only `nx-osv-1.conf` should have `netflow` enabled
    as well as the layer 3 `vlan` interface configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look at the `nx-osv-2.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Neat, huh? This can certainly save us a ton of time for something that previously
    required repeated copying and pasting. Personally, the template module was a big
    game-changer for me. This module alone was enough to motivate me to learn and
    use Ansible a few years ago.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a grand tour of the open-source automation framework
    Ansible. Unlike Pexpect-based and API-driven network automation scripts, Ansible
    provides a higher layer of abstraction called a playbook to automate our network
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is a full-featured automation framework capable of managing large infrastructures.
    Our focus is on managing network devices, but Ansible is capable of managing servers,
    databases, cloud infrastructures, and more. We have only touched the surface of
    its capabilities. If you feel Ansible is a tool you would like to learn more about,
    the Ansible documentation is an excellent source of reference. The Ansible community
    is friendly and welcoming if you would like to get involved.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 5*,*Docker Containers for Network Engineers*, we will start to learn
    about Docker and the world of containers.
  prefs: []
  type: TYPE_NORMAL
- en: Join our book community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2903617220506617062.png)'
  prefs: []
  type: TYPE_IMG
