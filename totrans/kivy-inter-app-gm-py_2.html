<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 2. Graphics – the Canvas"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Graphics – the Canvas</h1></div></div></div><p>Any Kivy <code class="literal">Widget</code> contains a <span class="strong"><strong><code class="literal">Canvas</code></strong></span> object. A Kivy <span class="strong"><strong><code class="literal">Canvas</code></strong></span> is a set of drawing instructions<a id="id121" class="indexterm"/> that <a id="id122" class="indexterm"/>define the graphical representation of <code class="literal">Widget</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>Be<a id="id123" class="indexterm"/> careful with the name because it tends to be confusing! A <span class="strong"><strong><code class="literal">Canvas</code></strong></span> object is not what we draw on (for example, as it is in HTML5); it is a set of instructions to draw in the <span class="strong"><strong>coordinate space</strong></span>.</p></div></div><p>The coordinate space refers to the place in which we draw. All the Kivy widgets share the same coordinate space, and a <code class="literal">Canvas</code> instance, the instructions to draw on it. A coordinate space is not restricted to the size of the window or the application screen, which means that we can draw outside of the visible area.</p><p>We will <a id="id124" class="indexterm"/>discuss how to draw and manipulate the representation of the widgets through the instructions we add to the <code class="literal">Canvas</code> object. Here is a list <a id="id125" class="indexterm"/>of the most important skills that we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Drawing<a id="id126" class="indexterm"/> basic geometric shapes (straight and curve lines, ellipses, and polygons) through <span class="strong"><strong>vertex instructions</strong></span></li><li class="listitem" style="list-style-type: disc">Using<a id="id127" class="indexterm"/> colors, and rotating, translating, and scaling the coordinate space through the <span class="strong"><strong>context instructions</strong></span></li><li class="listitem" style="list-style-type: disc">The difference between vertex and context instructions and how they complement each other</li><li class="listitem" style="list-style-type: disc">The three different sets of instructions of <code class="literal">Canvas</code> that we can use to modify the order of execution of the graphics instructions</li><li class="listitem" style="list-style-type: disc">Storing and retrieving the current coordinate space context through <code class="literal">PushMatrix</code> and <code class="literal">PopMatrix</code></li></ul></div><p>Using the Kivy canvas brings with it some technical challenges because Kivy integrates graphic processing with efficiency in mind. These challenges are not initially obvious, but there is nothing particularly difficult about them if we understand the underlying problem. This is why the next section is dedicated to introduce the main considerations that we face when we use the canvas.</p><div class="section" title="Understanding the canvas"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Understanding the canvas</h1></div></div></div><p>Before<a id="id128" class="indexterm"/> studying the examples of this chapter, it is important to recapitulate the following particularities related to the graphics display:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The coordinate space refers to the place in which we draw, which is not restricted to the windows size</li><li class="listitem" style="list-style-type: disc">A <code class="literal">Canvas</code> object<a id="id129" class="indexterm"/> is a set of instructions to draw in the coordinate space, not the place we draw in</li><li class="listitem" style="list-style-type: disc">All <code class="literal">Widget</code> objects<a id="id130" class="indexterm"/> contain their own <code class="literal">Canvas</code> (canvases, which we will see later) but all of them share the same coordinate space, the one in the <code class="literal">App</code> object.</li></ul></div><p>For example, if we add a rotation instruction to a specific <code class="literal">Canvas</code> instance (for example, the canvas of a button), then this will also affect all the subsequent graphics instructions that are going to display graphics in the coordinate space. It doesn't matter if the graphics belong to canvases of different widgets; they all share the same coordinate space.</p><p>Therefore, we need to learn techniques to leave the coordinate space context in its original state after modifying it with graphics instructions.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>All the graphics instructions added to different <code class="literal">Canvas</code> objects, which at the same time belong to different <code class="literal">Widget</code> objects, affect the same coordinate space. It is our task to make sure that the coordinate space is in its original state after modifying it with the graphics instructions.</p></div></div><p>Another important <a id="id131" class="indexterm"/>concept that we need to extend is the one of the <span class="strong"><strong><code class="literal">Widget</code></strong></span>. We already know that widgets are the blocks that allow us to build interfaces.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>A <span class="strong"><strong><code class="literal">Widget</code></strong></span> is also a place marker (with its position and size), but not necessarily a placeholder. The instructions of the canvas of a widget are not restricted to the specific area of the widget but to the whole coordinate space.</p></div></div><p>This directly adds to the previous problem of sharing a coordinate space. Not only do we need to control the fact that we share a coordinate space, but also, we have no restrictions on where to draw. On one hand, this makes Kivy very efficient and gives us a lot of flexibility. On the other hand, this seems to be a lot to control. Fortunately, Kivy provides the necessary tools to easily work around the problem.</p><p>The next <a id="id132" class="indexterm"/>section will present the available graphics instructions that can be added to the canvas in order to draw basic shapes. After this, we will explore graphic instructions that change the coordinate space context and exemplify the problems of sharing the coordinate space. The final section concentrates on illustrating the acquired knowledge inside <a id="id133" class="indexterm"/>the <span class="strong"><strong>Comic Creator</strong></span>, where we learn the most common techniques to master the use of the canvas considering its particularities. By the end of this chapter, we will be in complete control of the graphics that are displayed on the screen.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Drawing basic shapes"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Drawing basic shapes</h1></div></div></div><p>Before <a id="id134" class="indexterm"/>starting, let's introduce the Python code that we will reuse in all the examples of this chapter:</p><div class="informalexample"><pre class="programlisting">1. # File name: drawing.py
2. from kivy.app import App
3. from kivy.uix.relativelayout import RelativeLayout
4. 
5. class DrawingSpace(RelativeLayout):
6.     pass
7. 
8. class DrawingApp(App):
9.     def build(self):
10.         return DrawingSpace()
11. 
12. if __name__=="__main__":
13.     DrawingApp().run()</pre></div><p>We created the subclass <code class="literal">DrawingSpace</code> from <code class="literal">RelativeLayout</code>. It could have been inherited from any <code class="literal">Widget</code> but using <code class="literal">RelativeLayout</code> is generally a good choice for graphics because we usually want to draw inside the widget, and that means relative to its position.</p><p>Let's start with the canvas. There are basically two types of instructions that we can add to a canvas: vertex <a id="id135" class="indexterm"/>instructions<a id="id136" class="indexterm"/> and context instructions.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>The <a id="id137" class="indexterm"/>
<span class="strong"><strong>vertex instructions</strong></span> inherit from the <span class="strong"><strong><code class="literal">VertexInstruction</code></strong></span> base class, and allow us to draw vector shapes in the coordinate space.</p><p>The <span class="strong"><strong>context instructions</strong></span> (<code class="literal">Color</code>, <code class="literal">Rotate</code>, <code class="literal">Translate</code>, and <code class="literal">Scale</code>) inherit from<a id="id138" class="indexterm"/> the <span class="strong"><strong><code class="literal">ContextInstruction</code></strong></span> base class, and let us apply transformations to the <span class="strong"><strong>coordinate space context</strong></span>. By <span class="strong"><strong>coordinate space context</strong></span>, we mean the conditions in which the shapes (specified in the vertex instructions) are drawn in the coordinate space.</p></div></div><p>Basically, <span class="strong"><strong>vertex instructions</strong></span><a id="id139" class="indexterm"/> are what we draw and <span class="strong"><strong>context instructions</strong></span> affect where and how we draw. The following is the screenshot for the first example of this chapter:</p><div class="mediaobject"><img src="images/B04244_02_01.jpg" alt="Drawing basic shapes"/></div><p>In the preceding screenshot, the gray grid will simplify reading the coordinates that appear in the code. Also, the white letters associated with each cell will be used to refer to the shapes. Neither the grid nor the letters are part of the Kivy example. The preceding screenshot illustrates 10 basic figures that we learn to draw with vertex instructions. Almost all the available Kivy classes are represented in this example and we can create any 2D geometric shape with them. Since the vertex instructions use fixed coordinates, it is important to run this example with a screen size of 500 x 200 (<code class="literal">python drawing.py --size=500x200</code>) in order to visualize the shapes correctly.</p><p>We will study the Kivy language (<code class="literal">drawing.kv</code>) with small code fragments associated to the respective figure (and coordinates) next to it, so it would be easier to follow. Let's start with the shape <span class="strong"><strong>A</strong></span> (rectangle):</p><div class="mediaobject"><img src="images/B04244_02_01a.jpg" alt="Drawing basic shapes"/></div><p>Following is<a id="id140" class="indexterm"/> the code snippet for shape <span class="strong"><strong>A</strong></span>:</p><div class="informalexample"><pre class="programlisting">14. # File name: drawing.kv (vertex instructions)
15. &lt;DrawingSpace&gt;:
16.    canvas:
17.        Rectangle:
18.            pos: self.x+10,self.top-80
19.            size: self.width*0.15, self.height*0.3</pre></div><p>
<span class="strong"><strong><code class="literal">Rectangle</code></strong></span> is<a id="id141" class="indexterm"/> a good starting point because it resembles the way we set <a id="id142" class="indexterm"/>properties<a id="id143" class="indexterm"/> in widgets. We just have to set the <span class="strong"><strong><code class="literal">pos</code></strong></span> and <span class="strong"><strong><code class="literal">size</code></strong></span> properties.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>The <span class="strong"><strong><code class="literal">pos</code></strong></span> and <span class="strong"><strong><code class="literal">size</code></strong></span> properties of the vertex instructions are different from the <code class="literal">pos</code> and <code class="literal">size</code> properties of <code class="literal">Widget</code>, since they belong to the <code class="literal">VertexInstruction</code> base class. All the values to specify the properties of the vertex instructions are given in fixed values.</p></div></div><p>This means that we cannot use the <code class="literal">size_hint</code> or <code class="literal">pos_hint</code> properties as we did with the widgets in <a class="link" href="ch01.html" title="Chapter 1. GUI Basics – Building an Interface">Chapter 1</a>, <span class="emphasis"><em>GUI Basics – Building an Interface</em></span>. However, we can use the properties of <code class="literal">self</code> to achieve similar results (Line 18 and 19).</p><p>Let's proceed with the shape <span class="strong"><strong>B</strong></span> (Pac-Man-like figure):</p><div class="mediaobject"><img src="images/B04244_02_01b.jpg" alt="Drawing basic shapes"/></div><p>Following is the code snippet for shape <span class="strong"><strong>B</strong></span>:</p><div class="informalexample"><pre class="programlisting">20.         Ellipse:
21.            angle_start: 120
22.            angle_end: 420
23.            pos: 110, 110
24.            size: 80,80</pre></div><p>The <span class="strong"><strong><code class="literal">Ellipse</code></strong></span> works <a id="id144" class="indexterm"/>very similar to <code class="literal">Rectangle</code>, but it has three new properties: <span class="strong"><strong><code class="literal">angle_start</code></strong></span>, <span class="strong"><strong><code class="literal">angle_end</code></strong></span>, and <span class="strong"><strong><code class="literal">segments</code></strong></span>. The first two properties specify<a id="id145" class="indexterm"/> the <a id="id146" class="indexterm"/>initial <a id="id147" class="indexterm"/>and final angle <a id="id148" class="indexterm"/>of the ellipse. The angle 0° is North (or 12 o'clock) and they add up in the clockwise direction. So, the <code class="literal">angle_start</code> is 120° (90° + 30°), which is the lower jaw of the Pac-Man-like figure (Line 21). The <code class="literal">angle_end</code> value is 420° (360° + (90°-30°)), which is bigger than <code class="literal">angle_start</code> because we need Kivy to follow the clockwise direction to paint the <code class="literal">Ellipse</code>. If we specify a lower value than <code class="literal">angle_start</code>, Kivy will follow a counter clockwise direction, painting where the mouth of the Pac-Man is, instead of its body.</p><p>Let's continue with the shape <span class="strong"><strong>C</strong></span> (triangle):</p><div class="mediaobject"><img src="images/B04244_02_01c.jpg" alt="Drawing basic shapes"/></div><div class="informalexample"><pre class="programlisting">25.        Ellipse:
26.            segments: 3
27.            pos: 210,110
28.            size: 60,80</pre></div><p>The triangle of shape <span class="strong"><strong>C</strong></span> is actually another <span class="strong"><strong><code class="literal">Ellipse</code></strong></span> that we obtain thanks to the <span class="strong"><strong><code class="literal">segments</code></strong></span> property (Line 26). Let's put it this way: if you have to draw an ellipse with three<a id="id149" class="indexterm"/> lines, the best you would end up with is a triangle. If you have four lines, you would end up with a rectangle. You actually need infinite lines for a perfect <code class="literal">Ellipse</code>, but a computer cannot process that (neither the screen has enough resolution to support this), so we need to stop at some point. The default <code class="literal">segments</code> are 180. Notice that if you have a circle (that is, size: x,x), you will always get equilateral polygons (for example, a square if you specify just four <code class="literal">segments</code>).</p><p>We can analyze shapes <span class="strong"><strong>D</strong></span>, <span class="strong"><strong>E</strong></span>, <span class="strong"><strong>F</strong></span>, and <span class="strong"><strong>G</strong></span> together:</p><div class="mediaobject"><img src="images/B04244_02_01d.jpg" alt="Drawing basic shapes"/></div><div class="informalexample"><pre class="programlisting">29.        Triangle:
30.            points: 310,110,340,190,380,130
31.         Quad:
32.            points: 410,110,430,180,470,190,490,120
33.        Line:
34.            points: 10,30, 90,90, 90,10, 10,60
35.        Point:
36.            points: 110,30, 190,90, 190,10, 110,60
37.            pointsize: 3</pre></div><p>
<span class="strong"><strong><code class="literal">Triangle</code></strong></span> (shape <span class="strong"><strong>D</strong></span>), <span class="strong"><strong><code class="literal">Quad</code></strong></span> (shape <span class="strong"><strong>E</strong></span>), and <a id="id150" class="indexterm"/>
<span class="strong"><strong><code class="literal">Line</code></strong></span> (shape <span class="strong"><strong>F</strong></span>) work <a id="id151" class="indexterm"/>similarly. Their <span class="strong"><strong><code class="literal">points</code></strong></span> property (Lines 30, 32, and 34) indicates<a id="id152" class="indexterm"/> the corners of a triangle, quadrilateral, and<a id="id153" class="indexterm"/> a<a id="id154" class="indexterm"/> line, respectively. The <span class="strong"><strong><code class="literal">points</code></strong></span> property is a sequence of coordinates in the format <code class="literal">(x1, y1, x2, y2)</code>. <code class="literal">Point</code> is also similar to these three shapes. It uses the <span class="strong"><strong><code class="literal">points</code></strong></span> property (Line 36) but in this case to indicate a sequence of points (shape <span class="strong"><strong>G</strong></span>). It also uses the <span class="strong"><strong><code class="literal">pointsize</code></strong></span> (Line 37) property to indicate<a id="id155" class="indexterm"/> the size of the <code class="literal">Points</code>.</p><p>Let's proceed with the shape <span class="strong"><strong>H</strong></span>:</p><div class="mediaobject"><img src="images/B04244_02_01e.jpg" alt="Drawing basic shapes"/></div><div class="informalexample"><pre class="programlisting">38.        Bezier:
39.            points: 210,30, 290,90, 290,10, 210,60
40.            segments: 360
41.             dash_length: 10
42.             dash_offset: 5</pre></div><p>
<span class="strong"><strong><code class="literal">Bezier</code></strong></span> is<a id="id156" class="indexterm"/> a curved line that uses the <span class="strong"><strong><code class="literal">points</code></strong></span> property as a set of 'attractors' of the curve line (there is a math formalism behind Bézier curves that we are not going to cover in this book because<a id="id157" class="indexterm"/> it is out of its scope, but you can find enough information in Wikipedia <a class="ulink" href="http://en.wikipedia.org/wiki/B%C3%A9zier_curve">http://en.wikipedia.org/wiki/Bézier_curve</a>). The points are attractors because the line <a id="id158" class="indexterm"/>does<a id="id159" class="indexterm"/> not touch all of them (just the first and the last of them). The points of <code class="literal">Bezier</code> (Line 39) are at the same distance from each other as the points of the <code class="literal">Line</code> (Line 34), or the <code class="literal">Point</code> (Line 36); they were just translated 100 pixels to the right. You can visually compare the result of the Bezier curve (shape <span class="strong"><strong>H</strong></span>), with the results of the <code class="literal">Line</code> (shape <span class="strong"><strong>G</strong></span>) or the <code class="literal">Point</code> (shape <span class="strong"><strong>H</strong></span>). We included two other properties <span class="strong"><strong><code class="literal">dash_length</code></strong></span> (Line 41), for<a id="id160" class="indexterm"/> the length of the dashes of the <a id="id161" class="indexterm"/>discontinuous line, and <span class="strong"><strong><code class="literal">dash_offset</code></strong></span> (Line 42) for the distance between the dashes.</p><p>Let's cover the last shapes <span class="strong"><strong>I</strong></span> and <span class="strong"><strong>J</strong></span>:</p><div class="mediaobject"><img src="images/B04244_02_01f.jpg" alt="Drawing basic shapes"/></div><div class="informalexample"><pre class="programlisting">43.         Mesh:
44.             mode: 'triangle_fan'
45.             vertices: 310,30,0,0, 390,90,0,0, 390,10,0,0, 310,60,0,0
46.             indices: 0,1,2,3
47.         Mesh:
48.             mode: 'triangle_fan'
49.             vertices: 430,90,0,0, 470,90,0,0, 490,70,0,0, 450,10,0,0, 410,70,0,0, 430,90,0,0,
50.             indices: 0,1,2,3,4,5</pre></div><p>We<a id="id162" class="indexterm"/> added two <span class="strong"><strong><code class="literal">Mesh</code></strong></span> instructions (Lines 43 and 47). A <span class="strong"><strong><code class="literal">Mesh</code></strong></span> instruction is <a id="id163" class="indexterm"/>a compound of triangles and has many applications in computer graphics and games. There is not enough space in this book to cover the advanced techniques to use this instruction, but at the very least we will understand its basics and be<a id="id164" class="indexterm"/> able to draw flat polygons. The <span class="strong"><strong><code class="literal">mode</code></strong></span> property is set to <code class="literal">triangle_fan</code> (Line 44), which means that the triangles of the mesh are filled with color, instead of, for example, just drawing the border.</p><p>The <span class="strong"><strong><code class="literal">vertices</code></strong></span> property<a id="id165" class="indexterm"/> is a tuple of coordinates. For the purpose of this example, we will just ignore all the 0s. This will leave us with four coordinates (or vertices) in line 45. These points are relatively the same as shapes <span class="strong"><strong>F</strong></span>, <span class="strong"><strong>G</strong></span>, and <span class="strong"><strong>H</strong></span>. Let's imagine for the shape I how the triangles are created as we traverse them, left to right on the vertex list using three vertex points each time. The shape <span class="strong"><strong>I</strong></span> is composed of two triangles. The first triangle uses the first, second, and third vertices; and the second triangle uses the first, third, and fourth vertices. In general, if we are in the i<sup>th</sup> vertex of the list, a triangle is drawn using the first vertex, the (i-1)<sup>th</sup> vertex, and the i<sup>th</sup> vertex. The final mesh (shape <span class="strong"><strong>J</strong></span>) presents another example. It contains three triangles that are surrounded by a blue line in the following screenshot:</p><div class="mediaobject"><img src="images/B04244_02_02.jpg" alt="Drawing basic shapes"/></div><p>The <span class="strong"><strong><code class="literal">indexes</code></strong></span> property<a id="id166" class="indexterm"/> contains a list with the same number of vertices (not counting the 0s) and instructs the order in which the vertices list is traversed, altering the triangles that compose the mesh.</p><p>So far, all the<a id="id167" class="indexterm"/> polygons that we studied have been colored in. If we need to draw the border of the polygon, we should use <span class="strong"><strong><code class="literal">Line</code></strong></span> instead. In principle, this seems easy for a basic shape such as a triangle, but how do we draw a circle with just points? Fortunately, <code class="literal">Line</code> has the appropriate properties to make things easier.</p><p>The next example will show how you can build the figures in the following screenshot:</p><div class="mediaobject"><img src="images/B04244_02_03.jpg" alt="Drawing basic shapes"/><div class="caption"><p>Line examples</p></div></div><p>We have kept the gray coordinates and the letter to identify each cell in the screenshot. The Python code should be run in a screen size of 400 x 100: <code class="literal">python drawing.py --size=400x100</code>. The following is the <code class="literal">drawing.kv</code> code for the previous screenshot:</p><div class="informalexample"><pre class="programlisting">51. # File name: drawing.kv (Line Examples)
52. &lt;DrawingSpace&gt;:
53.     canvas:
54.         Line:
55.             ellipse: 10, 20, 80, 60, 120, 420, 180
56.             width: 2
57.         Line:
58.             circle: 150, 50, 40, 0, 360, 180
59.         Line:
60.             rectangle: 210,10,80,80
61.         Line:
62.             points: 310,10,340,90,390,20
63.             close: True</pre></div><p>In the previous code, we added four <span class="strong"><strong><code class="literal">Line</code></strong></span> instructions using specific properties. The first <code class="literal">Line</code> instruction (in line 54, shape <span class="strong"><strong>A</strong></span>) is<a id="id168" class="indexterm"/> similar to our Pac-Man (line 20). The <span class="strong"><strong><code class="literal">ellipse</code></strong></span> property (line 55) specifies <code class="literal">x</code>, <code class="literal">y</code>, <code class="literal">width</code>, <code class="literal">height</code>, <code class="literal">angle_start</code>, <code class="literal">angle_end</code>, and <code class="literal">segments</code>, respectively. The order of the parameters is difficult to remember so <a id="id169" class="indexterm"/>we should always keep the Kivy API next to us (<a class="ulink" href="http://kivy.org/docs/api-kivy.graphics.vertex_instructions.html">http://kivy.org/docs/api-kivy.graphics.vertex_instructions.html</a>). We also set <span class="strong"><strong><code class="literal">width</code></strong></span> of <code class="literal">Line</code> to make it thicker (line 56).</p><p>The second <code class="literal">Line</code> instruction (line 57, shape <span class="strong"><strong>B</strong></span>) introduces a property that has no counterpart in<a id="id170" class="indexterm"/> the vertex<a id="id171" class="indexterm"/> instructions: <span class="strong"><strong><code class="literal">circle</code></strong></span>. The difference with the <code class="literal">ellipse</code> property is that the first three parameters (line 58) define the center (150, 50) and radius (40) of <code class="literal">Circle</code>. The rest remains the same. The third <code class="literal">Line</code> (line 59, shape <span class="strong"><strong>C</strong></span>) is<a id="id172" class="indexterm"/> defined by <span class="strong"><strong><code class="literal">rectangle</code></strong></span> (line 60) and the parameters are simply <code class="literal">x</code>, <code class="literal">y</code>, <code class="literal">width</code>, and <code class="literal">height</code>. The last <code class="literal">Line</code> (line 61, shape <span class="strong"><strong>D</strong></span>) is the most flexible way to define polygons. We specified the points (line 62), as many as we<a id="id173" class="indexterm"/> want. The <span class="strong"><strong><code class="literal">close</code></strong></span> property (line 63) connects the first and last points.</p><p>We covered most of the instructions and properties related to vertex instructions. We should be able to draw any geometrical shape in two dimensions with Kivy. If you want more details <a id="id174" class="indexterm"/>about each of the instructions, you should visit the Kivy API (<a class="ulink" href="http://kivy.org/docs/api-kivy.graphics.vertex_instructions.html">http://kivy.org/docs/api-kivy.graphics.vertex_instructions.html</a>). Now, it is the turn of context instructions to decorate these boring black and white polygons.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Adding images, colors, and backgrounds"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Adding images, colors, and backgrounds</h1></div></div></div><p>In this<a id="id175" class="indexterm"/> section, we will discuss how to add images and colors to our<a id="id176" class="indexterm"/> graphics<a id="id177" class="indexterm"/> and how to control which graphic comes on top of which one. We continue using the same Python code of the first section. This time, we run it with a 400 x 100 screen size: <code class="literal">python drawing.py --size=400x100</code>. The following screenshot shows the final result of this section:</p><div class="mediaobject"><img src="images/B04244_02_04.jpg" alt="Adding images, colors, and backgrounds"/><div class="caption"><p>Images and Colors</p></div></div><p>The<a id="id178" class="indexterm"/> following is the corresponding <code class="literal">drawing.kv</code> code:</p><div class="informalexample"><pre class="programlisting">64. # File name: drawing.kv (Images and colors)
65. &lt;DrawingSpace&gt;:
66.     canvas:
67.         Ellipse:
68.            pos: 10,10
69.            size: 80,80
70.            source: 'kivy.png'
71.         Rectangle:
72.            pos: 110,10
73.            size: 80,80
74.            source: 'kivy.png'
75.        Color: 
76.            rgba: 0,0,1,.75
77.        Line:
78.            points: 10,10,390,10
79.            width: 10
80.            cap: 'square'
81.          Color: 
82.            rgba: 0,1,0,1
83.        Rectangle:
84.            pos: 210,10
85             size: 80,80
86.             source: 'kivy.png'
87.        Rectangle:
88.            pos: 310,10
89.            size: 80,80</pre></div><p>This code<a id="id179" class="indexterm"/> starts<a id="id180" class="indexterm"/> with <code class="literal">Ellipse</code> (line 67) and <code class="literal">Rectangle</code> (line 71). We<a id="id181" class="indexterm"/> used the <span class="strong"><strong><code class="literal">source</code></strong></span> property, which inserts an image to decorate each polygon. The <code class="literal">kivy.png</code> image is 80 x 80 pixels with a white background (without any alpha/transparency channel). The result is shown in the first two columns of the "Images and Colors" screenshot.</p><p>In line 75, we used the context instruction <span class="strong"><strong><code class="literal">Color</code></strong></span> to change the color (with the <span class="strong"><strong><code class="literal">rgba</code></strong></span> property: red, green, blue, and alpha) of the coordinate space context. This means that the next vertex<a id="id182" class="indexterm"/> instruction will be drawn with the color changed by <code class="literal">rgba</code>. A context instruction basically changes the current coordinate space context. In the screenshot, you can see the thin blue bar (or very dark gray bar in the printed version of this book) at the bottom (line 77) that appears as transparent blue (line 76) instead of the default white (<code class="literal">1,1,1,1</code>) of the previous examples. We set the ends shape of the line, to a square with the <span class="strong"><strong><code class="literal">cap</code></strong></span> property (line 80).</p><p>We changed the color again in line 81. After this, we drew two more rectangles, one with the <code class="literal">kivy.png</code> image and another without it. In the preceding screenshot, you can see that the white <a id="id183" class="indexterm"/>part <a id="id184" class="indexterm"/>of the image has become as green, or<a id="id185" class="indexterm"/> light gray in the printed version of this book, as the basic <code class="literal">Rectangle</code> on the right.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>The <code class="literal">Color</code> instruction acts as a light that illuminates the <code class="literal">kivy.png</code> image, it doesn't simply paint over it.</p></div></div><p>There is another important detail to notice in the screenshot. The blue (dark gray in the printed version) line at the bottom goes over the first two polygons and goes under the last two. The instructions are executed in order and this might bring some unwanted results. Kivy provides a solution to make this execution more flexible, and structured, which we will introduce in the next section.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Structuring graphic instructions"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Structuring graphic instructions</h1></div></div></div><p>Apart <a id="id186" class="indexterm"/>from the <code class="literal">canvas</code> instance, a Widget includes<a id="id187" class="indexterm"/> two other <a id="id188" class="indexterm"/>canvas instances: <span class="strong"><strong><code class="literal">canvas.before</code></strong></span> and <span class="strong"><strong><code class="literal">canvas.after</code></strong></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>The <code class="literal">Widget</code> class<a id="id189" class="indexterm"/> has three sets of instructions (<span class="strong"><strong><code class="literal">canvas.before</code></strong></span>, <span class="strong"><strong><code class="literal">canvas</code></strong></span>, and <span class="strong"><strong><code class="literal">canvas.after</code></strong></span>) to organize the order <a id="id190" class="indexterm"/>of execution. With them, we can control which<a id="id191" class="indexterm"/> elements will go to the background or stay on the foreground.</p></div></div><p>The following <code class="literal">drawing.kv</code> file shows an example of these three sets (lines 92, 98, and 104) of instructions:</p><div class="informalexample"><pre class="programlisting">90. # File name: drawing.kv (Before and After Canvas)
91. &lt;DrawingSpace&gt;:
92.    canvas.before:
93.        Color: 
94.            rgba: 1,0,0,1
95.        Rectangle:
96.            pos: 0,0
97.            size: 100,100
98.    canvas:
99.        Color: 
100.         rgba: 0,1,0,1
101.     Rectangle:
102.         pos: 100,0
103.         size: 100,100
104.  canvas.after:
105.      Color: 
106.          rgba: 0,0,1,1
107.      Rectangle:
108.          pos: 200,0
109.          size: 100,100
110.  Button:
111.      text: 'A very very very long button'
112.      pos_hint: {'center_x': .5, 'center_y': .5}
113.      size_hint: .9,.1</pre></div><p>In<a id="id192" class="indexterm"/> each set, a rectangle of different color is drawn (lines 95, 101, and 107). Here is a diagram that illustrates the execution order of the canvases. The numbers on the top-left margin of each code block indicates the order of execution:</p><div class="mediaobject"><img src="images/B04244_02_05.jpg" alt="Structuring graphic instructions"/><div class="caption"><p>Execution order of the canvas</p></div></div><p>Notice that we didn't define any <code class="literal">canvas</code>, <code class="literal">canvas.before</code>, or <code class="literal">canvas.after</code> for <code class="literal">Button</code> but Kivy does internally. Since <code class="literal">Button</code> displays graphics on the screen (for example, it contains <code class="literal">Rectangle</code> associated with the <span class="strong"><strong><code class="literal">background_color</code></strong></span> property), then it has<a id="id193" class="indexterm"/> instructions in its canvas sets. The final result is shown in the following screenshot (executed with: <code class="literal">python drawing.py --size=300x100</code>):</p><div class="mediaobject"><img src="images/B04244_02_06.jpg" alt="Structuring graphic instructions"/><div class="caption"><p>Before and after canvas</p></div></div><p>The <a id="id194" class="indexterm"/>graphics of <code class="literal">Button</code> (the child) are covered up by the set of instructions in <code class="literal">canvas.after</code>. It is clear that the instructions of <code class="literal">canvas.before</code> and <code class="literal">canvas</code> are executed before the displaying <code class="literal">Button</code>, but what is executed between them? It is necessary when we work with inheritance, and we want to add instructions in the subclass that should be executed before the <code class="literal">canvas</code> set of instructions of the base class. Also, it is a convenience when we mix Python code and Kivy language rules. We will study some practical examples in the last section of this chapter related to the <span class="emphasis"><em>Comic Creator</em></span>, and review the topic in <a class="link" href="ch04.html" title="Chapter 4. Improving the User Experience">Chapter 4</a>, <span class="emphasis"><em>Improving the User Experience</em></span>.</p><p>For<a id="id195" class="indexterm"/> now, it is good enough to understand that we have three sets of instructions (<code class="literal">Canvas</code>) that provide some flexibility when we display graphics on the screen. Let's now explore some more context instructions related to transformations of the vertex instruction.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Rotating, translating, and scaling the coordinate space"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Rotating, translating, and scaling the coordinate space</h1></div></div></div><p>
<span class="strong"><strong><code class="literal">Rotate</code></strong></span>, <span class="strong"><strong><code class="literal">Translate</code></strong></span>, and <span class="strong"><strong><code class="literal">Scale</code></strong></span> are context instructions that are applied to the vertex instructions, which <a id="id196" class="indexterm"/>are displayed in the coordinate space. They<a id="id197" class="indexterm"/> could bring unexpected results if we forget <a id="id198" class="indexterm"/>that the coordinate space is shared among all widgets, and <a id="id199" class="indexterm"/>it<a id="id200" class="indexterm"/> occupies the size of the window (actually bigger than that because there is no restriction on the coordinates and we can<a id="id201" class="indexterm"/> draw outside the window). First, we are going to understand the behavior of this instruction in this section and, in the next section, we can analyze the problems they bring in a deeper way, and learn techniques to make things easier.</p><p>Let's start with the new <code class="literal">drawing.kv</code> code:</p><div class="informalexample"><pre class="programlisting">114. # File name: drawing.kv (Rotate, Translate and Scale)
115. &lt;DrawingSpace&gt;:
116.    pos_hint: {'x':.5, 'y':.5}
117.    canvas:
118.        Rectangle:
119.            source: 'kivy.png'
120.        Rotate:
121.            angle: 90
122.            axis: 0,0,1
123.        Color:
124.            rgb: 1,0,0 # Red color
125.        Rectangle:
126.            source: 'kivy.png'
127.        Translate:
128.             x: -100
129.         Color:
130.             rgb: 0,1,0 # Green color
131.         Rectangle:
132.             source: 'kivy.png'
133.         Translate:
134.             y: -100
135.         Scale:
136.             xyz:(.5,.5,0)
137.         Color:
138.             rgb: 0,0,1 # Blue color
139.         Rectangle:
140.             source: 'kivy.png'</pre></div><p>In <a id="id202" class="indexterm"/>this<a id="id203" class="indexterm"/> code, the first thing <a id="id204" class="indexterm"/>we did is position the coordinates (0, 0) of <code class="literal">DrawingSpace</code> (<code class="literal">RelativeLayout</code>) in the center of the screen (line 116). We created <code class="literal">Rectangle</code> with the <code class="literal">kivi.png</code> figure, which we had previously modified to indicate the original <span class="strong"><strong>x</strong></span> axis and <span class="strong"><strong>y</strong></span> axis. </p><p>The result is presented in the top-right of the following screenshot (executed with <code class="literal">python drawing.py --size=200x200</code>):</p><div class="mediaobject"><img src="images/B04244_02_07.jpg" alt="Rotating, translating, and scaling the coordinate space"/><div class="caption"><p>Rotate, Translate and Scale</p></div></div><p>In the line 120, we<a id="id205" class="indexterm"/> applied the <span class="strong"><strong><code class="literal">Rotate</code></strong></span> instruction by 90° on the z axis (line 122). The value is (x, y, z), which means we can use any vector in the 3D space. Think of this as nailing a pin to the bottom-left corner of <code class="literal">DrawingSpace</code>, which we then rotate in the counter clockwise direction.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>By<a id="id206" class="indexterm"/> default, the pin nail of the rotation is always the coordinates (0, 0) but we can alter this behavior with the <span class="strong"><strong><code class="literal">origin</code></strong></span> property.</p></div></div><p>The top-left section of the screenshot ("Rotate, Translate, and Scale") shows the result after the rotation. We <a id="id207" class="indexterm"/>drew the same rectangle with red color (using the <span class="strong"><strong><code class="literal">rgb</code></strong></span> property instead of the <code class="literal">rgba</code> property) to highlight it. After adding a rotation to the coordinate space context, we also modified the relative X-axis and Y-axis. Line 128 considers that the axes are rotated, and in order to translate the coordinate space down (usually Y-axis), it sets -100px to the X-axis. We drew the same <code class="literal">Rectangle</code> with green <code class="literal">Color</code> in the bottom left corner. Notice that the image still rotates and it will rotate as long as we don't bring the coordinate space context to its original angle.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>Context instructions are persistent until we change them back again. Another way to avoid this is working inside <code class="literal">RelativeLayout</code>. If you remember from the previous chapter, it allows us to work with coordinates relative to the widget.</p></div></div><p>To scale <a id="id208" class="indexterm"/>or zoom out the image, we translated the coordinate<a id="id209" class="indexterm"/> space context (line 133) to use the bottom-right <a id="id210" class="indexterm"/>section of the screenshot. Notice that we use the Y-axis instead of the X-axis, since the context is still rotated. The scaling is done in line 135, where the image will be reduced to half the width and half the height. The <code class="literal">Scale</code> instruction reduces towards the (0, 0) coordinate, which initially is at the bottom-left corner. However, after all these modifications of the context, we need to think where this coordinate is. First, we rotated the axis (line 120) so the X-axis is vertical and the Y-axis is horizontal. After translating the coordinate space down (line 127) and then right (line 133), the (0, 0) coordinate is in the bottom-right corner with the X-axis being the vertical one and the Y-axis being the horizontal one.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>
<span class="strong"><strong><code class="literal">Scale</code></strong></span> uses<a id="id211" class="indexterm"/> proportions to the current size of the coordinate space context and not the original size. For example, to recover the original size, we should use <code class="literal">xyz: (2,2,0)</code> and not just <code class="literal">xyz: (1,1,0)</code>.</p></div></div><p>So far, in this chapter, we have discussed that a <code class="literal">Canvas</code> instance is a set of instructions that contains context instructions and vertex instructions. The context instructions apply changes (colors or transformation) to the coordinate space context that affects the conditions in which the vertex instructions are displayed in the coordinate space.</p><p>We will<a id="id212" class="indexterm"/> use some of the knowledge to add <span class="emphasis"><em>Stickman</em></span> to our project in <a id="id213" class="indexterm"/>the next and final section of this chapter. We <a id="id214" class="indexterm"/>will introduce two important context instructions to deal with the issues of sharing the same coordinate space between widgets: <code class="literal">PushMatrix</code> and <code class="literal">PopMatrix</code>.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Comic Creator: PushMatrix and PopMatrix"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Comic Creator: PushMatrix and PopMatrix</h1></div></div></div><p>Let's insert<a id="id215" class="indexterm"/> some<a id="id216" class="indexterm"/> graphics to the project we started in <a class="link" href="ch01.html" title="Chapter 1. GUI Basics – Building an Interface">Chapter 1</a>, <span class="emphasis"><em>GUI Basics – Building an Interface</em></span>. Before this, we need to recapitulate two important lessons of this chapter related to the coordinate space:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The coordinate space is not restricted to any position or size. It normally has its origin in the bottom-left corner of the screen. To avoid this, we use <code class="literal">RelativeLayout</code>, which internally performs a translation to the position of the <code class="literal">Widget</code>.</li><li class="listitem" style="list-style-type: disc">Once the coordinate space context is transformed by any instruction, it stays like that until we specify something different. <code class="literal">RelativeLayout</code> also addresses this problem with two contextual instructions, which we will study in this section: <span class="strong"><strong><code class="literal">PushMatrix</code></strong></span> and <span class="strong"><strong><code class="literal">PopMatrix</code></strong></span>.</li></ul></div><p>We<a id="id217" class="indexterm"/> use <code class="literal">RelativeLayout</code> in this section to avoid the problems<a id="id218" class="indexterm"/> of the shared coordinate space, but we will also explain the alternatives to it when we are inside any other type of <code class="literal">Widget</code>. We will add a new file (<code class="literal">comicwidgets.kv</code>) to our project. In <code class="literal">comicreator.py</code>, we need to add our new file to <code class="literal">Builder</code>:</p><div class="informalexample"><pre class="programlisting">Builder.load_file('comicwidgets.kv')</pre></div><p>The file <code class="literal">comicwidgets.kv</code> will contain special widgets, which we will create for the project. In this chapter, we will add the <code class="literal">StickMan</code> class:</p><div class="informalexample"><pre class="programlisting">141. # File name: comicwidgets.kv
142. &lt;StickMan@RelativeLayout&gt;:
143.    size_hint: None, None
144.    size: 48,48
145.    canvas:
146.        PushMatrix
147.        Line:
148.            circle: 24,38,5
149.        Line:
150.            points: 24,33,24,15
151.        Line:
152.            points: 14,5,24,15
153.        Line:
154.            points: 34,5,24,15
155.        Translate:
156.            y: 48-8
157.        Rotate:
158.            angle: 180
159.            axis: 1,0,0
160.        Line:
161.            points: 14,5,24,15
162.        Line:
163.            points: 34,5,24,15
164.        PopMatrix</pre></div><p>On line 142, the <code class="literal">StickMan</code> subclass inherits from <code class="literal">RelativeLayout</code> to facilitate the positioning <a id="id219" class="indexterm"/>and use of context instructions. We defined <code class="literal">StickMan</code> of size <a id="id220" class="indexterm"/>48 x 48. <code class="literal">StickMan</code> is composed of six lines that define the head, body, left leg, right leg, left arm, and right arm (line 147 to 163). You can see the result of <code class="literal">StickMan</code> three times in the following screenshot:</p><div class="mediaobject"><img src="images/B04244_02_08.jpg" alt="Comic Creator: PushMatrix and PopMatrix"/><div class="caption"><p>Comic Creator</p></div></div><p>The first <code class="literal">StickMan</code> is part of the design of the last <code class="literal">ToolButton</code> and the other two appear in the <span class="emphasis"><em>drawing space</em></span>; one of them is scaled. Notice that the code of the legs (lines 151 to 154) is <a id="id221" class="indexterm"/>exactly the same as the arms (lines 160 to 163); the difference<a id="id222" class="indexterm"/> is that we translated the coordinate space upwards (lines 155 and 156) and rotated it 180° in the x-axis (lines 157 to 159). With this, we saved ourselves some math to draw the <span class="emphasis"><em>stickman</em></span>.</p><p>We translated and rotated the coordinate space context; therefore, we should undo these context changes so everything will remain as it was at the beginning. Instead of adding more instructions to <code class="literal">Translate</code> and <code class="literal">Rotate</code> back to the coordinate space context, we used two <a id="id223" class="indexterm"/>convenient Kivy instructions: <span class="strong"><strong><code class="literal">PushMatrix</code></strong></span> and <span class="strong"><strong><code class="literal">PopMatrix</code></strong></span>. At<a id="id224" class="indexterm"/> the beginning, we used a <code class="literal">PushMatrix</code> (line 146), which will save the current coordinate space context and, at the end, we used a <code class="literal">PopMatrix</code> (line 164) to return the context to its original state.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>
<span class="strong"><strong><code class="literal">PushMatrix</code></strong></span> saves the current coordinate space context and <span class="strong"><strong><code class="literal">PopMatrix</code></strong></span> retrieves the last saved coordinate space context. Therefore, the transformation instructions (<code class="literal">Scale</code>, <code class="literal">Rotate</code>, and <code class="literal">Translate</code>) surrounded by <span class="strong"><strong><code class="literal">PushMatrix</code></strong></span> and <span class="strong"><strong><code class="literal">PopMatrix</code></strong></span> won't affect the rest of the interface.</p></div></div><p>We will extend this approach to add shapes to the other two instances of <code class="literal">ToolButton</code> (circle and line) in the top-left corner of <code class="literal">ToolBox</code>. We add this code in <code class="literal">toolbox.kv</code>:</p><div class="informalexample"><pre class="programlisting">165. # File name: toolbox.kv
166. &lt;ToolButton@ToggleButton&gt;:
167.     size_hint: None,None
168.     size: 48,48
169.     group: 'tool'
170.     canvas:
171.         PushMatrix:
172.         Translate:
173.             xy: self.x,self.y
174.     canvas.after:
175.         PopMatrix:
176. 
177. &lt;ToolBox@GridLayout&gt;:
178.     cols: 2
179.     padding: 2
180.     ToolButton:
181.         canvas:
182.             Line:
183.                 circle: 24,24,14
184.     ToolButton:
185.         canvas:
186.             Line:
187.                 points: 10,10,38,38
188.     ToolButton:
189.         StickMan:
190.             pos_hint: {'center_x':.5,'center_y':.5}</pre></div><p>In the <code class="literal">ToolButton</code> class (line 166), we used a <code class="literal">PushMatrix</code> (line 171) in the <code class="literal">canvas</code> set of instructions to save the current state of the coordinate space. Then, <code class="literal">Translate</code> (line 172) moves the graphic instructions to the position of <code class="literal">ToolButton</code> so we can use relative coordinates on each <code class="literal">ToolButton</code> (line 180 to 190). Finally, <code class="literal">PopMatrix</code> (line 175) was added to <code class="literal">canvas.after</code> to restore the coordinate space.</p><p>It is important to follow the execution order of the different canvases (instruction sets). For example, let's slowly follow the execution order of the canvases of <code class="literal">ToolButton</code> that contains the circle (line 180): first, <code class="literal">canvas</code> of the <code class="literal">ToolButton</code> class that has <code class="literal">PushMatrix</code> and <code class="literal">Translate</code> (line 170); second,  <code class="literal">canvas</code> of the <code class="literal">ToolButton</code> instance, which has the circle (line 181), and third, <code class="literal">canvas.after</code> of the base class, which has <code class="literal">PopMatrix</code> (line 174). We just implemented the same technique used for <code class="literal">RelativeLayout</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>
<span class="strong"><strong><code class="literal">RelativeLayout</code></strong></span> internally<a id="id225" class="indexterm"/> contains <code class="literal">PushMatrix</code> and <code class="literal">PopMatrix</code>. Therefore, we can add instructions safely inside it, which won't affect the rest of the interface.</p></div></div><p>Let's conclude<a id="id226" class="indexterm"/> this chapter by scaling our <span class="emphasis"><em>stickman</em></span> in the <span class="emphasis"><em>drawing space</em></span> and<a id="id227" class="indexterm"/> illustrate one more particularity of the execution order of the canvases. The following is the code of <code class="literal">drawingspace.kv</code>:</p><div class="informalexample"><pre class="programlisting">191. # File name: drawingspace.kv
192. &lt;DrawingSpace@RelativeLayout&gt;:
193.     StickMan:
194.         pos_hint: {'center_x':.5,'center_y':.5}
195.         canvas.before:
196.             Translate:
197.                 xy: -self.width/2, -self.height/2
198.             Scale:
199.                 xyz: 2,2,0
200.     StickMan:</pre></div><p>The first <code class="literal">StickMan</code> was translated and rotated (lines 193 to 199), but not the second one (line 200). We discussed that the context instructions affect the coordinate space globally, but when we see the result in the screenshot ("Comic Creator"), we realize that the second instance was neither scaled nor translated by the lines 196 and 198. What happened? The answer is not obvious. Is the answer related to <code class="literal">PushMatrix</code> and <code class="literal">PopMatrix</code> inside the canvas of the <code class="literal">StickMan</code> class (lines 146 and 164)? No, it isn't, because both of them are inside the same set of instructions.</p><p>The way we implemented <code class="literal">ToolButton</code> follows the way the <code class="literal">RelativeLayout</code> class is implemented. <code class="literal">StickMan</code> inherits from <code class="literal">RelativeLayout</code>, so there is actually another <code class="literal">PushMatrix</code> in <code class="literal">canvas.before</code> and its respective <code class="literal">PopMatrix</code> in <code class="literal">canvas.after</code> of the <code class="literal">StickMan</code> class (inherited from <code class="literal">RelativeLayout</code>). The instructions from lines 196 to 199 are executed after <code class="literal">PopMatrix</code> is executed in <code class="literal">canvas.before</code> of <code class="literal">RelativeLayout</code> and, therefore, the context is restored on the respective <code class="literal">PushMatrix</code> of <code class="literal">RelativeLayout</code>.</p><p>Finally, notice that the instructions must be in <code class="literal">canvas.before</code> because they are added before the existent instructions, the ones that actually draw the <span class="emphasis"><em>stickman</em></span>. In other words, if we simply add them in the canvas, then the <span class="emphasis"><em>stickman</em></span> would be drawn before the translation and scaling.</p><p>The rest<a id="id228" class="indexterm"/> of the files of the <span class="emphasis"><em>Comic Creator</em></span> <code class="literal">comiccreator.kv</code>, <code class="literal">generaloptions.kv</code>, and <code class="literal">statusbar.kv</code> were not modified, so we are not <a id="id229" class="indexterm"/>presenting them again. The context and vertex instructions are easy to understand. However, we must be very careful with the order of execution and make sure to leave the coordinate space context in its normal state after executing the desired vertex instructions. Finally, take into account that everything you see in the screen is displayed by an instruction (or instructions) inside the canvas, including, for example, <code class="literal">Label</code> texts and the <code class="literal">Button</code> backgrounds.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Summary</h1></div></div></div><p>This chapter explained the necessary concepts to understand the use of the canvas. We covered the use of vertex and context instructions, and how to manipulate the order of the execution of instructions. We covered how to deal with the transformation of <code class="literal">canvas</code>, either reversing all the transformations or using <code class="literal">RelativeLayout</code>. The following is the whole set of components we learnt to use, in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The vertex instructions (and many of their respective properties): <code class="literal">Rectangle</code> (<code class="literal">pos</code>, <code class="literal">size</code>), <code class="literal">Ellipse</code> (<code class="literal">pos</code>, <code class="literal">size</code>, <code class="literal">angle_start</code>, <code class="literal">angle_end</code>, <code class="literal">segments</code>), <code class="literal">Triangle</code> (<code class="literal">points</code>), <code class="literal">Quad</code> (<code class="literal">points</code>), <code class="literal">Point</code> (<code class="literal">points</code>, <code class="literal">pointsize</code>), <code class="literal">Line</code> (<code class="literal">points</code>, <code class="literal">ellipse</code>, <code class="literal">circle</code>, <code class="literal">rectangle</code>, <code class="literal">width</code>, <code class="literal">close</code>, <code class="literal">dash_lenght</code>, <code class="literal">dash_offset</code>, and <code class="literal">cap</code>), <code class="literal">Bezier</code> (<code class="literal">points</code>, <code class="literal">segments</code>, <code class="literal">dash_lenght</code>, and <code class="literal">dash_offset</code>,), and <code class="literal">Mesh</code> (<code class="literal">mode</code>, <code class="literal">vertices</code>, <code class="literal">indices</code>)</li><li class="listitem" style="list-style-type: disc">The <code class="literal">source</code> property that applies to all the vertex instructions</li><li class="listitem" style="list-style-type: disc">The three set of canvas instructions: <code class="literal">canvas.before</code>, <code class="literal">canvas</code>, and <code class="literal">canvas.after</code></li><li class="listitem" style="list-style-type: disc">The context instructions (and some of their properties): <code class="literal">Color</code> (<code class="literal">rgba</code>, <code class="literal">rgb</code>), <code class="literal">Rotate</code> (<code class="literal">angle</code>, <code class="literal">axis</code>,<code class="literal">origin</code>), <code class="literal">Translate</code> (<code class="literal">x</code>, <code class="literal">y</code>, <code class="literal">xy</code>), <code class="literal">Scale</code> (<code class="literal">xyz</code>), <code class="literal">PushMatrix</code>, and <code class="literal">PopMatrix</code></li></ul></div><p>The list is quite comprehensive, but of course there are some remaining components that we can find in the Kivy API. The important part is that we discussed the concepts behind the use of the canvas. Feel free to play with the provided examples to reinforce the important concepts of this chapter. You should feel comfortable to put things together and enliven your interface, so you can actually draw with it. The next chapter will focus on event handling and manipulating Kivy objects directly from Python.</p></div></div>
</body></html>