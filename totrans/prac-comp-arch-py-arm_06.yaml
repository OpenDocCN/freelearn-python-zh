- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: A Little More Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多Python知识
- en: We’ve introduced Python and we’ve been using it. In this chapter we increase
    our knowledge of Python and extend some of the concepts we have encountered, and
    also introduce new features. In particular, we examine data structures, starting
    with the way in which lists of elements or strings of characters can be processed.
    This chapter paves the way for [*Chapter 6*](B19624_06.xhtml#_idTextAnchor091)*,*
    where we complete the design of a computer simulator. But, before that, we provide
    a note on the terminology we use when discussing features of Python.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了Python，并且一直在使用它。在本章中，我们扩展了Python的知识，并扩展了一些我们遇到的概念，还介绍了新特性。特别是，我们检查了数据结构，从处理元素列表或字符字符串的方式开始。本章为[*第6章*](B19624_06.xhtml#_idTextAnchor091)**铺平了道路，其中我们完成了计算机模拟器的设计。但在那之前，我们提供了一些关于我们在讨论Python特性时使用的术语的说明。
- en: 'We will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论以下主题：
- en: Statements and expressions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句和表达式
- en: More string features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多字符串特性
- en: List comprehensions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表推导式
- en: String processing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串处理
- en: Repetition and looping
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复和循环
- en: The dictionary
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典
- en: Functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Lists of lists
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表中的列表
- en: Imports
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入
- en: Indenting in Python
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的缩进
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the programs used in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter05](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter05).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章使用的程序[https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter05](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter05)。
- en: This chapter requires no new resources in addition to previous chapters. All
    that is required is a computer with a Python IDE. The same is true of all chapters
    until we reach [*Chapter 9*](B19624_09.xhtml#_idTextAnchor159), which deals with
    Raspberry Pi.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不需要比前几章更多的资源。所需的一切仅是一个带有Python IDE的计算机。所有章节都是如此，直到我们达到[*第9章*](B19624_09.xhtml#_idTextAnchor159)，该章节涉及树莓派。
- en: Statements and Expressions
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 语句和表达式
- en: An *expression* is a combination of values and operators that can be evaluated
    to provide a result; for example `(p+q)*7 - r`. A Boolean expression is a combination
    of values and logical operators that yields the value `True` or `False`; for example,
    `p >` `q`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*表达式*是值和运算符的组合，可以评估为提供结果；例如`(p+q)*7 - r`。布尔表达式是值和逻辑运算符的组合，产生`True`或`False`的值；例如，`p
    >` `q`。
- en: 'A *statement* is a Python operation that must be evaluated by an interpreter;
    that is, it’s an action. Typical Python statements involve `if`… `for`… actions.
    These two terms are often used in formal definitions; for example, the definition
    of an `if` statement is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*语句*是Python操作，必须由解释器评估；也就是说，它是一个动作。典型的Python语句涉及`if`… `for`…动作。这两个术语常用于正式定义中；例如，`if`语句的定义如下：
- en: '`if <expr>:`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`if <expr>:`'
- en: '`<``statement>`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`<``statement>`'
- en: 'Angle brackets are used in descriptions of the language to indicate *something
    that will be replaced by its actual value*; for example, a valid `if` statement
    is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在语言描述中使用尖括号表示*将被其实际值替换的内容*；例如，一个有效的`if`语句如下：
- en: '`if x >` `y:`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`if x >` `y:`'
- en: '`p = p + q`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`p = p + q`'
- en: In this case the *expression* is `x > y` and the *statement* is `p = p +` `q`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*表达式*是`x > y`，而*语句*是`p = p +` `q`。
- en: More string features
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多字符串特性
- en: Now we’re going to extend our ability to manipulate strings. The string is one
    of Python’s most important data structures and is at the heart of all the programs
    we write in this book. Python’s string-handling facilities make it one of the
    most powerful and easy-to-use text-processing languages. A string is indicated
    by quotes, which may be either single or double; for example, `x = "Two"` and
    `y = 'One'` are Python strings. Python’s ability to use two string terminators
    means that we can create strings like “Alan’s book” (i.e., use the apostrophe
    as a normal grammar element).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将扩展我们操作字符串的能力。字符串是Python最重要的数据结构之一，也是我们在这本书中编写的所有程序的核心。Python的字符串处理功能使其成为最强大、最易用的文本处理语言之一。字符串由引号表示，可以是单引号或双引号；例如，`x
    = "Two"`和`y = 'One'`是Python字符串。Python使用两种字符串终止符的能力意味着我们可以创建像“Alan的书”这样的字符串（即，将撇号用作正常的语法元素）。
- en: During the execution of a Python program, you can read a string from the keyboard
    and also provide a prompt in the following way.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行Python程序的过程中，你可以从键盘读取一个字符串，也可以以下面的方式提供提示。
- en: '`x = input('' Please type` `something '')`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`x = input(''请输入'' `一些内容`)`'
- en: Executing this command displays '`Please type something`' on the screen, waits
    for your input, and then assigns the string you typed to variable `x`. This mechanism
    is very useful when simulating a program, because you can provide input as the
    program runs. Note that the input string must be terminated by hitting the *Enter*
    key.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令将在屏幕上显示"`请输入一些内容`"，等待您的输入，然后将您输入的字符串分配给变量`x`。这种机制在模拟程序时非常有用，因为您可以在程序运行时提供输入。请注意，输入字符串必须通过按*Enter*键来终止。
- en: String processing
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串处理
- en: 'You can change (substitute) characters in a string by using the method `replace`.
    For example, suppose we wish to replace all occurrences of `''$''` in the string
    `price` with `''£''`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`replace`方法在字符串中更改（替换）字符。例如，假设我们希望将字符串`price`中所有`'$'`的实例替换为`'£'`：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we print `price`, we now get `'eggs £2,` `cheese £4'`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印`price`，现在我们得到`'eggs £2,` `cheese £4'`。
- en: 'Other string methods are `upper()` (convert text to upper case), `lstrip()`
    (remove leading characters), and `rstrip()` (remove trailing characters). Let
    `x =''###this Is A test???''`. Consider the following sequence:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 其他字符串方法包括`upper()`（将文本转换为大写）、`lstrip()`（删除前导字符）和`rstrip()`（删除尾随字符）。设`x ='###this
    Is A test???'`。考虑以下序列：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This sequence produces `x` = '`this is is` `a test'`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列产生`x` = '`this is is` `a test'`。
- en: Strings are *immutable*. You cannot change them once they are defined. In the
    preceding code, it looks as if we have modified x by removing leading and trailing
    characters and converting upper case to lower case. No! In each case we have created
    a *new* string with the same name as the old string (i.e., x).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是不可变的。一旦定义了字符串，就无法更改它们。在先前的代码中，看起来我们通过删除前导和尾随字符以及将大写转换为小写来修改了x。不！在每种情况下，我们都创建了一个与旧字符串具有相同名称的*新*字符串（即，x）。
- en: If you were to enter `y =` '`Allen`' and try to edit it to read '`Allan`' by
    changing the '`e`' to '`a`' using the expression `y[3] =` '`a`', you would get
    an error, because you would have tried to change an immutable string. However,
    you could legally write `y = y[0:3] + 'a' + y[4]` to create a new string `y` with
    the value `'Allan'`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您输入`y =` '`Allen`'并尝试通过将`'e'`改为`'a'`来编辑它以读取`'Allan'`，您将得到一个错误，因为您尝试更改一个不可变的字符串。然而，您可以合法地写出`y
    = y[0:3] + 'a' + y[4]`来创建一个具有值`'Allan'`的新字符串`y`。
- en: The addition symbol, +, performs addition in *arithmetic* and *concatenation*
    in string processing; for example, `x = 4 + 5` gives `9`, whereas `x = '4' + '5'`
    gives `'45'`. This action is called *operator overloading* and indicates the extension
    of a function, when, for example, the function is applied to different objects.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 加号符号`+`在算术中执行加法，在字符串处理中执行*连接*；例如，`x = 4 + 5`给出`9`，而`x = '4' + '5'`给出`'45'`。这个动作被称为*操作符重载*，表示函数的扩展，例如，当函数应用于不同的对象时。
- en: 'The TC1 assembler uses the following string methods to remove spaces before
    an instruction, enable users to employ upper- or lower-case, and allow the use
    of a space or comma as a separator. For example, this code fragment lets you write
    either `r0,[r1]` or `R0,R1` with the same meaning. The code below shows how TC1
    takes a line of the input (i.e., an assembly instruction) and simplifies it for
    later conversion to binary:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: TC1汇编器使用以下字符串方法来删除指令前的空格，使用户能够使用大写或小写，并允许使用空格或逗号作为分隔符。例如，此代码片段允许您以相同的意义编写`r0,[r1]`或`R0,R1`。下面的代码显示了TC1如何将输入行（即汇编指令）简化以便稍后转换为二进制：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Suppose an instruction is entered in string form as '' `ADD r0,R1,r3`''. This
    has leading spaces, upper- and lower-case text and commas, and is converted to
    `''ADD R0 R1 R3''` by the above sequence of operations. The next step is to convert
    the string into individual *tokens* for analysis by the assembler. We can do this
    with the `split()` method. which converts a string into a list of strings separated
    by the character in the parentheses. Note that the default parameter is a space.
    If `s = ''ADD R0 R1 R2''`, then `s.split()` or `s.split('' '')` results in this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一条指令以字符串形式输入为 ' `ADD r0,R1,r3`'。这包含前导空格、大小写文本和逗号，并且通过上述操作序列转换为 `'ADD R0 R1
    R3'`。下一步是将字符串转换为汇编器分析的单独*标记*。我们可以使用`split()`方法来完成此操作。它将字符串转换为由括号中的字符分隔的字符串列表。请注意，默认参数是空格。如果`s
    = 'ADD R0 R1 R2'`，则`s.split()`或`s.split(' ')`的结果如下：
- en: '`s = [''ADD'', ''R1'', ''R2'', ''R3'']`      # A list of four tokens, each
    of which is a string'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`s = [''ADD'', ''R1'', ''R2'', ''R3'']`      # 四个标记的列表，每个标记都是一个字符串'
- en: 'We now have a list consisting of four separate strings; that is, a command
    followed by three parameters. We can access each of these strings using index
    notation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含四个单独字符串的列表；也就是说，一个命令后跟三个参数。我们可以使用索引符号访问这些字符串：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can now perform operations on the tokens:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以对标记进行操作：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The second statement uses `T2[1:]` to convert string `'R2'` into a new string
    `'2'` by removing the first character. The slice notation `[1:]` is interpreted
    as "All characters following the first." This lets us deal with one- or two-digit
    values like R2 or R23\. Since there are only 8 registers, we could have written
    `[1:2]`. Using `[1:]` allows the extension 16 registers in a future version of
    TC1 without changing the code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个语句使用 `T2[1:]` 将字符串 `'R2'` 转换为新的字符串 `'2'`，通过删除第一个字符。切片符号 `[1:]` 被解释为“第一个字符之后的所有字符”。这使我们能够处理像
    R2 或 R23\ 这样的单或双位数值。由于只有 8 个寄存器，我们本来可以写 `[1:2]`。使用 `[1:]` 允许在 TC1 的未来版本中扩展到 16
    个寄存器，而无需更改代码。
- en: 'We have to use the *integer* function `int` to convert the register number
    from a string into its value as an integer. When learning Python, a common mistake
    is to forget to convert a string to an integer:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用整数函数 `int` 将寄存器号从字符串转换为整数值。在学习 Python 时，一个常见的错误是忘记将字符串转换为整数：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code would generate an error. Because `regNum` is created as a string,
    holding the value you typed. However, in the second line, the program is expecting
    an integer as a list index. You have to write `reg[int(regNum)]` to convert the
    numeric string into an integer value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会生成错误。因为 `regNum` 是作为一个字符串创建的，它包含了你输入的值。然而，在第二行，程序期望一个整数作为列表索引。你必须写 `reg[int(regNum)]`
    来将数字字符串转换为整数值。
- en: Example – text Input
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 – 文本输入
- en: 'Here’s a simple example of text input with Python using a simple `.txt` file.
    The source file is this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用 Python 和简单 `.txt` 文件进行文本输入的简单示例。源文件如下：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This file was processed by Python as follows. I use the address it had on my
    computer. This is read into a variable `sFile`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件是用 Python 处理的。我使用它在我的电脑上的地址。这是读取到变量 `sFile` 中的内容：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output from this code fragment is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出如下：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We now have a Python list of strings, each corresponding to one line of the
    source text. Note that each line ends with an end-of-line (i.e., \n) and any spaces
    in the text are included. For example, there’s a totally empty line and an empty
    line with a space. We have to take account of these when dealing with the input.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个与源文本每一行对应的 Python 字符串列表。请注意，每一行都以换行符（即，\n）结束，并且文本中的任何空格都被包含在内。例如，有一个完全空的行和一个带有空格的空行。在处理输入时，我们必须考虑到这些。
- en: 'Having increased our ability to manipulate text strings, in the next section
    we look at one of Python’s most interesting features: the facility to perform
    a sequence of operations on a string or a list in just one line of code with list
    comprehension.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在增强了我们操作文本字符串的能力之后，在下一节中，我们将探讨 Python 最有趣的功能之一：使用列表推导式在单行代码中执行对字符串或列表的一系列操作。
- en: List comprehensions
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表推导式
- en: We now introduce a very powerful feature of Python, the *list comprehension*.
    It’s not powerful because of what it can do, but because of how succinct it is.
    A list comprehension lets you take a list and process it in a single line. We
    take a look at list comprehensions, because they are so useful in processing text;
    for example, you can use a list comprehension to take a line of text and replace
    all double-spaces with single spaces, or convert all lower-case characters to
    upper-case characters.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们介绍 Python 的一个非常强大的功能，即列表推导式。它的强大之处不在于它能做什么，而在于它的简洁性。列表推导式允许你在单行中处理列表。我们来看看列表推导式，因为它们在处理文本时非常有用；例如，你可以使用列表推导式将一行文本中的所有双空格替换为单空格，或者将所有小写字符转换为大写字符。
- en: 'List comprehensions can be applied to any iterable. An iterable is a structure
    that you can step through, such as a list, a string, or a tuple. The simplest
    form of list comprehension is this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式可以应用于任何可迭代对象。可迭代对象是一种你可以遍历的结构，例如列表、字符串或元组。列表推导式的最简单形式如下：
- en: '`x =` [`i` for `i` in `y`]'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`x =` [`i` for `i` in `y`]'
- en: 'Here, `x` and `y` are strings (or lists). The text in bold represents Python
    reserved words and punctuation. The variable `i` is a user-chosen variable used
    to step through the list. We could have used any name instead of *i*; it simply
    doesn’t matter. Consider the following example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`x`和`y`是字符串（或列表）。粗体的文本代表Python保留字和标点符号。变量`i`是一个用户选择的变量，用于遍历列表。我们可以用任何名字代替*i*；这根本不重要。考虑以下示例：
- en: '`lettersList = [i for i` `in ''Tuesday'']`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`lettersList = [i for i in ''Tuesday'']`'
- en: The iterable being processed is the string `'Tuesday'` and it is copied a character
    at a time to `lettersList`. This returns `lettersList` as the list of characters
    `[`'`T','u','e','s','d','a','y']`. We have turned a string into a list of characters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正在处理的可迭代对象是字符串`'Tuesday'`，它逐个字符复制到`lettersList`中。这返回`lettersList`作为字符列表`['T','u','e','s','d','a','y']`。我们已经将一个字符串转换成了字符列表。
- en: 'We can create a more sophisticated version of the list comprehension as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个更复杂的列表推导式版本，如下所示：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'where `expression` is a Python expression, and `condition` is a Boolean condition.
    We step through the iterable, `y`, looking at each element and selecting it subject
    to a condition, processing it according to the expression, and then putting it
    in a new list. That’s an awful lot of work in a single line. Consider this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`expression`是一个Python表达式，`condition`是一个布尔条件。我们遍历可迭代对象`y`，查看每个元素，并根据条件选择它，根据表达式处理它，然后将它放入一个新的列表中。这在一行中做了很多工作。考虑以下内容：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The condition is *if item i from y is not equal to ‘$’* . This list comprehension
    says, "Copy the characters in string y to string x, one-by-one, as long as the
    character isn’t a `''$''` character." The result is this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 条件是*如果y中的项目i不等于‘$’*。这个列表推导式表示，“将字符串y中的字符逐个复制到字符串x中，只要字符不是`'$'`字符。”结果是这个：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The original string has been replaced by a list of single-character strings,
    but with every `'$'` removed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串已被替换为单字符字符串的列表，但去除了每个`'$'`。
- en: 'Let’s look at three examples of list comprehensions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看列表推导式的三个示例：
- en: 'The first example demonstrates how empty lines (i.e., '''') can be removed
    from the input. We can copy all lines apart from those equal to the null or empty
    string " "with:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个示例演示了如何从输入中移除空行（即''）。我们可以通过以下方式复制所有不等于空或空字符串" "的行：
- en: '[PRE14]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We’ve renamed the new list the same as the old one. There’s no reason why we
    can’t do this and it saves having to invent a new name for each of the list comprehensions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将新列表重命名为与旧列表相同的名称。我们没有理由不能这样做，这可以节省为每个列表推导式发明新名字的需要。
- en: 'The second example is this:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个示例是这样的：
- en: '[PRE15]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We apply the function `.upper()` to each element `i`. This expression converts
    a lower-case character into its upper-case equivalent; that is, it converts all
    strings to upper-case. The last list comprehension is this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将函数`.upper()`应用于每个元素`i`。这个表达式将小写字符转换为其大写等效字符；也就是说，它将所有字符串转换为大写。最后的列表推导式是这样的：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The expression `i.split()` divides the source string into individual tokens
    (strings) at each space. This means we can then then process the line as a sequence
    of tokens. The condition `if i != ''` is used to remove empty strings by not copying
    them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`i.split()`将源字符串在每个空格处分割成单独的标记（字符串）。这意味着我们可以将行作为标记序列进行处理。条件`if i != ''`用于通过不复制它们来删除空字符串。
- en: The third example removes empty lines.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个示例移除了空行。
- en: 'We’ve created a list of three instructions that has empty lines in it, denoted
    by '' ''. When we execute this list comprehension, we convert each string into
    a sublist and we remove the empty lines:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含空行的三个指令列表，用' '表示。当我们执行这个列表推导式时，我们将每个字符串转换成子列表，并移除空行：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output from this code is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出如下：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The tuple
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: We now introduce the tuple for the sake of completeness, although we make little
    use of it in this text. A list is a sequence of elements enclosed by square brackets;
    for example, `P = [1,4,8,9]`. A tuple is a sequence of elements separated by round
    brackets; for example, `Q = (``1,4,8,9)`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为了完整性引入了元组，尽管在这篇文本中我们很少使用它。列表是由方括号包围的元素序列；例如，`P = [1,4,8,9]`。元组是由圆括号分隔的元素序列；例如，`Q
    = (1,4,8,9)`。
- en: There is little difference between a tuple and a list; they are both data structures
    that hold a sequence of elements. However, a *tuple is immutable* and cannot be
    modified, unlike a list. A tuple is a read-only list and is used when you wish
    to store data that does not change. Although not relevant here, tuples do have
    implementation and performance advantages over lists; that is, if you have a list
    that is fixed, it is better to use a tuple.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 元组和列表之间的区别很小；它们都是包含元素序列的数据结构。然而，*元组是不可变的*，不能被修改，与列表不同。元组是一个只读列表，用于存储不更改的数据。尽管这里不相关，但元组在实现和性能上比列表有优势；也就是说，如果你有一个固定的列表，最好使用元组。
- en: 'Later, we will use tuples in dictionary structures, as here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将使用元组在字典结构中，如下所示：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this case, the values in bold are each two-component tuples. We could have
    used a list, but the tuple indicates a fixed structure that cannot change. If
    you were to use a list instead of a tuple, you would write this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，加粗的值是每个两个组件的元组。我们本来可以用列表，但元组表示一个不能改变的结构。如果你要用列表代替元组，你会这样写：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Repetition and looping
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复和循环
- en: 'We now expand our knowledge of Python’s repetition mechanism, a feature common
    to all high-level procedural languages. In this section we learn how to do the
    following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们扩展我们对 Python 重复机制的认知，这是所有高级过程式语言共有的特性。在本节中，我们学习如何做以下事情：
- en: Repeat an action multiple times
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复执行操作多次
- en: Use different data and parameters each time you carry out the action
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次执行操作时使用不同的数据和参数
- en: Iterate over elements in a list
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历列表中的元素
- en: Use the `enumerate` function
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `enumerate` 函数
- en: 'Suppose we want to test whether a list includes a particular item. We can create
    a `for` loop to do this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要测试一个列表是否包含特定的项目。我们可以创建一个 `for` 循环来完成这个任务：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code first sets `inList` to `False` to indicate that the element `'grapes'`
    has not been found. The `for` loop steps though all elements in the list, testing
    each one for the item we’re looking for. If it is found, `inList` is set to `True`.
    This code works, but it is not good. If there are a million elements in the list
    and grapes the first one, the code still steps through the remaining 999,999 elements.
    This is horribly inefficient.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先将 `inList` 设置为 `False` 以指示元素 `'grapes'` 未被找到。`for` 循环遍历列表中的所有元素，测试每个元素是否是我们正在寻找的项目。如果找到了，`inList`
    被设置为 `True`。这段代码是有效的，但它并不好。如果列表中有百万个元素，而 `'grapes'` 是第一个，代码仍然会遍历剩余的 999,999 个元素。这是效率极低的。
- en: In the following example, we compare successive elements with a value, and stop
    if we find it. On each cycle, if the item is not found, we continue. If we find
    what we want, we jump out of the loop rather than continuing to the bitter end
    by testing every single item. When we do the comparison, if the current item is
    *not* equal to '`grapes'`, we set `inList` to `False` and the loop continues with
    the next element.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们比较连续的元素与一个值，并在找到它时停止。在每次循环中，如果未找到项目，我们继续。如果我们找到我们想要的项目，我们跳出循环而不是通过测试每个单独的项目来继续到痛苦的结尾。当我们进行比较时，如果当前项目不等于
    '`grapes'`，我们将 `inList` 设置为 `False`，然后循环继续到下一个元素。
- en: 'If we find `''grapes''`, the `else` part of the `if` statement sets `inList`
    to `True` and then uses a `break` statement to exit the loop and avoid further
    pointless cycles round the loop. A `break` in a `for` or `while` loop tells Python
    to exit the loop now and continue with the next instruction *after* the loop:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到 `'grapes'`，`if` 语句的 `else` 部分将 `inList` 设置为 `True`，然后使用 `break` 语句退出循环，避免进一步的无效循环。在
    `for` 或 `while` 循环中的 `break` 告诉 Python 立即退出循环并继续执行循环后的下一个指令：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The variable `inList` is just a flag that we can use later in the program;
    for example, we could write this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `inList` 只是一个我们可以在程序中稍后使用的标志；例如，我们可以这样写：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Another approach is to use the list operator `in`. If we have a list, we can
    check whether an item is a member of that list by using the following construct:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用列表操作符 `in`。如果我们有一个列表，我们可以通过以下结构来检查一个项目是否是该列表的成员：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first line returns `True` if `'grapes'` is in the list `fruit1`, and `False`
    otherwise. The `in` construct is very useful in testing whether an item belongs
    to a group of other items arranged as a list; for example, if all employees are
    in the list `staff`, then
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行如果 `'grapes'` 在列表 `fruit1` 中返回 `True`，否则返回 `False`。`in` 结构在测试一个项目是否属于作为列表排列的其他项目组时非常有用；例如，如果所有员工都在列表
    `staff` 中，那么
- en: sets `worksHere` to `True` if `Smith` is a valid employee name, and `False`
    otherwise.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Smith` 是有效的员工姓名，则将 `worksHere` 设置为 `True`，否则为 `False`。
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Later we will use the `in` operator in to test whether an instruction is a
    member of a set, as here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 之后我们将使用`in`运算符来测试一个指令是否是集合的成员，就像这样：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Repetition and Iterables
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复和可迭代对象
- en: 'Another version of the `for` loop iterates over the elements of a list as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的另一种版本如下遍历列表的元素：'
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The words in bold are the reserved Python words; the other words are user-defined
    variables. Here, the `i` is not a sequence-counting integer as it was in the previous
    example using `range()`. It is the value of each element (or iterable) in the
    list taken in turn. Consider the following example using a list of colors:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体的单词是Python的保留字；其他单词是用户定义的变量。在这里，`i`不是像在之前使用`range()`的例子中那样的序列计数整数。它是列表中每个元素（或可迭代对象）按顺序取的值。考虑以下使用颜色列表的例子：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This code steps through each element of the list `car` and prints out its value,
    as follows.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码遍历列表`car`的每个元素，并按如下方式打印其值。
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Consider an example using a list of computer operations. In this case we’ve
    taken a list of tuples, one for each of four op-codes. The tuple consists of an
    op-code string, an instruction type, and the number of operands required. This
    is just a demonstration. We could have used a list but chose a tuple to emphasize
    that the tuple values do not change:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用计算机操作列表的一个例子。在这种情况下，我们取了一个元组的列表，每个元组对应四个操作码。这个元组由一个操作码字符串、一个指令类型和所需的操作数数量组成。这只是一个演示。我们本来可以用列表，但选择元组来强调元组值不会改变：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output of this code fragment is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出如下：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We have now demonstrated that you can iterate through a list of any type in
    Python.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经证明，在Python中你可以迭代任何类型的列表。
- en: 'A particularly interesting feature of Python is looping with a *double index*.
    You can step through a list by numeric index, or by object name. This is useful
    when you want to step through by object name but would also like to know where
    it is in the list. The Python function `enumerate` permits this form of looping.
    It is easier to demonstrate the action of `enumerate` than to explain it. Consider
    the previous example of the list `car`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Python的一个特别有趣的特征是使用*双重索引*进行循环。你可以通过数字索引或对象名称遍历列表。当你想按对象名称遍历但还想知道它在列表中的位置时，这很有用。Python函数`enumerate`允许这种形式的循环。演示`enumerate`的作用比解释它更容易。考虑之前关于列表`car`的例子：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output from this code is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出如下：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The iterator, `color`, has become a sequence of tuples with the element index
    and the corresponding value from the list. Remember that a tuple is like a list
    except that its elements are immutable and can’t be changed. Here’s a case where
    I would use an iterator name like *color*, rather than `i`, because it is more
    explicit/descriptive, and it is less easy to confuse with an integer.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器`color`已经变成了一个包含元素索引和列表中相应值的元组序列。记住，元组就像列表一样，除了它的元素是不可变的，不能被更改。这里是一个我会使用像`color`这样的迭代器名称而不是`i`的情况，因为它更明确/描述性，并且与整数的混淆更少。
- en: 'An alternative form of enumeration uses two indices, one an explicit integer
    count and one an element count. In the following example, `count` is the explicit
    integer index and `color` is the enumeration index. Thus, `count` steps `0`, `1`,
    `2` etc., and `color` steps `red`, `white`, `green` …:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种枚举形式使用两个索引，一个是显式的整数计数，另一个是元素计数。在以下例子中，`count`是显式的整数索引，而`color`是枚举索引。因此，`count`步进`0`、`1`、`2`等，而`color`步进`red`、`white`、`green`…：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This produces the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Lists of lists
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表的列表
- en: 'Here we extend the use of Python’s most important data structure, the list.
    First, we demonstrate that a list can, itself, contain lists. Python lets you
    construct lists with any type of item; for example, `x = [1,2,''test'',v,True]`
    defines a list with two integers, a string, a variable, and a Boolean constant.
    Since you can use any legal element in a list, you can create a *list of lists*.
    Consider this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们扩展了Python最重要的数据结构列表的使用。首先，我们演示了列表可以包含列表本身。Python允许你用任何类型的项构建列表；例如，`x =
    [1,2,'test',v,True]`定义了一个包含两个整数、一个字符串、一个变量和一个布尔常量的列表。由于你可以在列表中使用任何合法的元素，你可以创建一个*列表的列表*。考虑以下例子：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a list of three items and each item is a list itself (shaded); for example,
    the first item in this list is the list ['apple',2.35,150]. Each sub-list consists
    of a string naming the fruit, the price of the fruit, and the current stock level.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含三个项目的列表，每个项目本身也是一个列表（阴影部分）；例如，这个列表中的第一个项目是列表`['apple',2.35,150]`。每个子列表由一个命名水果的字符串、水果的价格和当前库存水平组成。
- en: 'Suppose we want to know the price of oranges; we could write something like
    this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想知道橙子的价格；我们可以写点像这样的事情：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We use a `for` loop to step through the list of fruits. Then, when we’ve located
    the item we want (which is a list), we read the second item of that list. As you
    can see, we use two subscripts, first [i] and then [1].
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`for`循环遍历水果列表。然后，当我们找到我们想要的项（它是一个列表）时，我们读取那个列表的第二个项。正如你所看到的，我们使用了两个下标，首先是[i]，然后是[1]。
- en: 'Consider the following example of lists of lists:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下列表的列表的例子：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is not easy on the eye! Let’s use bold font and shading to emphasize the
    components of the string:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这对眼睛来说并不容易！让我们使用粗体和阴影来强调字符串的组成部分：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It’s a list consisting of two items: [4,9,[1,6]] and [8,7`4`, `9` and the list
    [1,6].'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含两个项的列表：[4,9,[1,6]]和[8,7`4`, `9`以及列表[1,6]。
- en: If I were to write `x = testList[1][2][1]`, what would the value of `x` be?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我写`x = testList[1][2][1]`，`x`的值会是什么？
- en: It would be `9`, because `testList`[1] is `[8,7,[0,9]]` and `testList[1]`[2]is
    [0,9] and `testList[1][2]`[1]is 9\. Think of this as a tree with branches! The
    first branch is element `[1]` of `testList`. The second branch is element `[2]`
    of that branch, and the third (final) branch is element `[1]` on that second branch.
    *Figure 5**.1* illustrates the concept of embedded lists graphically.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 它会是`9`，因为`testList`[1]是`[8,7,[0,9]]`，`testList[1]`[2]是`[0,9]`，而`testList[1][2]`[1]是`9`。想象这是一个有分支的树！第一个分支是`testList`的元素`[1]`。第二个分支是那个分支的元素`[2]`，第三个（最后的）分支是第二个分支上的元素`[1]`。*图5**.1*以图形方式说明了嵌套列表的概念。
- en: '![Figure 5.1 - Illustration of embedded lists](img/Figure_5.01_B19624.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 - 嵌套列表的说明](img/Figure_5.01_B19624.jpg)'
- en: Figure 5.1 - Illustration of embedded lists
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 - 嵌套列表的说明
- en: 'Consider a second example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑第二个例子：
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: What is `x[2][3]`? This expression yields `'n'`, because `x[2]` is `'then'`
    , and element 3 of that is `'n'`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`x[2][3]`是什么意思？这个表达式返回`''n''`，因为`x[2]`是`''then''`，而那个元素中的第3个是`''n''`。'
- en: Indenting in python
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的缩进
- en: We have been indenting code since we introduced Python. Now we re-emphasize
    the use of the indent in Python because it is so vital to correct programming.
    Most computer languages allow you to group statements together, as a block, for
    a particular purpose. Typically, the instructions in a group are executed as a
    batch, one by one. Such groups are often associated with conditional statements
    and loops.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们引入Python以来，我们就开始缩进代码。现在我们再次强调Python中缩进的使用，因为它对正确的编程至关重要。大多数计算机语言允许你将语句组合在一起，作为一个块，用于特定目的。通常，一组中的指令会作为一个批次，一个接一个地执行。这样的组通常与条件语句和循环相关联。
- en: 'Some languages indicate a block of instructions by enclosing them in curly
    brackets `{ }`. Consider the following. It’s not real code; it’s just plain text
    designed to illustrate the layout of a program:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言通过将指令包围在花括号`{}`中来表示指令块。考虑以下内容。这不是真正的代码；它只是用于说明程序布局的纯文本：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here, you have several blocks of operations, which include nested blocks (i.e.,
    a block within another block). Blocks are executed as if they were a single operation;
    that is, they are the computer equivalent of *subcontracting*. Although it is
    not a programming requirement, it is normal to use indentation as a reading aid
    to make the code more understandable to people, as here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你有几个操作块，包括嵌套块（即一个块在另一个块内）。块被当作一个单一的操作来执行；也就是说，它们是计算机中的分包等效。尽管这不是编程要求，但通常使用缩进来作为阅读辅助，使代码对人们来说更容易理解，如下所示：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Python doesn’t use brackets to indicate a block of consecutive operations. It
    requires that a block of code be indented (and the same indentation used for each
    member of the block). Failure to get the indentation right will either result
    in a failure to compile the program, or a program that doesn’t do what you think
    it will do. Errors of indentation are one of the first things that the novice
    programmer encounters. An indentation error is very easy to miss. For example,
    if you accidentally create an indent or remove an indent while editing a program,
    you can easily get an error that takes a long time to locate.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Python不使用括号来表示连续操作的块。它要求代码块必须缩进（并且每个块成员使用相同的缩进）。如果缩进不正确，可能会导致程序无法编译，或者程序的行为不符合你的预期。缩进错误是新手程序员遇到的第一件事之一。缩进错误很容易忽略。例如，如果你在编辑程序时意外地创建或删除了缩进，你可能会很容易地得到一个难以定位的错误。
- en: 'A simple example of the use of blocks and indentation in Python is given below.
    Although any amount of indent is legal, by convention, an indent is normally four
    spaces. Each level of indentation is shaded. Note that the `else` in the last
    line belongs to the first `if`. If we had indented it further, it would belong
    to the second `if`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下面给出了Python中使用块和缩进的简单示例。虽然任何数量的缩进都是合法的，但按照惯例，缩进通常是四个空格。每个缩进级别都有阴影。注意，最后一行的 `else`
    属于第一个 `if`。如果我们进一步缩进它，它将属于第二个 `if`：
- en: '[PRE47]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The dictionary
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典
- en: 'In this section we introduce Python’s dictionary mechanism, which makes writing
    simulators so easy. Here, you will learn how to create a dictionary that translates
    one thing into another, for example, translating the name of an instruction into
    its binary code. Here we learn about the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了Python的字典机制，这使得编写模拟器变得非常容易。在这里，你将学习如何创建一个将一个事物转换成另一个事物的字典，例如，将指令的名称转换成其二进制代码。在这里，我们学习以下内容：
- en: The nature of a dictionary
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典的本质
- en: The advantages of a dictionary over the list
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典相对于列表的优点
- en: The difference between a dictionary key and a dictionary value
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典键和字典值之间的区别
- en: Inserting items in a dictionary
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字典中插入项目
- en: Extracting items from a dictionary
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字典中提取项目
- en: Using a dictionary to solve a problem
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字典解决问题
- en: The dictionary is one of Python’s most useful features, a feature that makes
    it so much easier to design simulators. The Python dictionary is an impressive
    data structure that is accessed by means of a *key*, rather than a location within
    the data structure. Instead of providing a location like `myList[5]`, you look
    up an item in a dictionary in exactly the same way you use a dictionary in everyday
    life. You provide the dictionary with a name (which we call a *key*) and up pops
    the information *associated* with that name. Keys are unique; the same key can’t
    appear more than once in a dictionary (just as social security numbers are unique).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是Python最有用的特性之一，这个特性使得设计模拟器变得容易得多。Python字典是一个令人印象深刻的通过 *键* 访问的数据结构，而不是通过数据结构内的位置。你不需要提供像
    `myList[5]` 这样的位置，你可以在字典中查找一个项目，就像你在日常生活中使用字典一样。你向字典提供一个名称（我们称之为 *键*），然后就会弹出与该名称
    *相关联* 的信息。键是唯一的；同一个键在字典中不能出现多次（就像社会保险号码是唯一的）。
- en: A Python dictionary has the form `{key1:value1, key2:value2, key3:value3}`;
    for example, `{'UK':44, 'USA':1, 'Germany':49, 'France':33}` might be used to
    look up a country’s international telephone prefix. The dictionary is enclosed
    in curly braces, and `key:value` pairs have a colon between the key and its value.
    The order of pairs in a dictionary does not matter, because an item is accessed
    by its *key* and not by its location in the dictionary.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Python字典的形式是 `{key1:value1, key2:value2, key3:value3}`；例如，`{'UK':44, 'USA':1,
    'Germany':49, 'France':33}` 可以用来查找一个国家的国际电话区号。字典被括号包围，`key:value` 对之间用冒号分隔。字典中对的顺序不重要，因为项目是通过其
    *键* 而不是其在字典中的位置来访问的。
- en: The key is often a string, but that is not a requirement. In our computer simulator,
    the keys are usually the mnemonic codes of a computer language. The value associated
    with a key can be any legal Python data structure. In some of the simulators we
    create, we often specify the value as a tuple, which is an ordered list. For example,
    the dictionary entry `'INC':(8,16)`has the key `'INC'` and the value `(8,16)`.
    Searching the dictionary using the key `'INC'`, returns the tuple `(8,16)`. In
    this case, the value is the format of the instruction (i.e., 8), and its op-code
    (i.e., 16).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 键通常是字符串，但这不是必需的。在我们的计算机模拟器中，键通常是计算机语言的助记码。与键相关联的值可以是任何合法的Python数据结构。在我们创建的一些模拟器中，我们经常指定值为一个元组，它是一个有序列表。例如，字典条目
    `'INC':(8,16)` 有键 `'INC'` 和值 `(8,16)`。使用键 `'INC'` 搜索字典，返回元组 `(8,16)`。在这种情况下，值是指令的格式（即，8），以及它的操作码（即，16）。
- en: You could use a list as a value instead of a tuple, that is, `'INC':[8,16]`.
    The only significant difference is that you can’t change a tuple once it is defined.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用列表代替元组作为值，即 `'INC':[8,16]`。唯一的显著区别是，一旦定义了元组，就不能更改它。
- en: 'You can check whether an item is in the dictionary by writing `if key in dictionary`,
    as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编写 `if key in dictionary` 来检查一个项目是否在字典中，如下所示：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To obtain the information about a particular mnemonic, we can use the `get`
    method to read the value associated with the key. For example, `opData =` `opCodes`.get`('INC')`
    returns`(8,16)`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取特定助记符的信息，我们可以使用 `get` 方法来读取与键关联的值。例如，`opData = opCodes.get('INC')` 返回 `(8,16)`。
- en: 'We can then access the two fields of the tuple associated with `''INC''` as
    follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按照以下方式访问与 `'INC'` 关联的元组的两个字段：
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If the requested key is not in the dictionary, the `get` method returns `None`.
    `None` is a Python reserved word and indicates a null value. Note that `None`
    is not zero or an empty string, it has its own type `None`. Consider the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的键不在字典中，`get` 方法返回 `None`。`None` 是 Python 的保留字，表示空值。请注意，`None` 既不是零也不是空字符串，它有自己的类型
    `None`。考虑以下情况：
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following code uses the telephone prefix directory we described above to
    demonstrate how to use `None` to deal with errors. Note that this uses an infinite
    loop and terminates on an error. When `None` is detected, the `break` forces an
    exit from the infinite loop:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用我们上面描述的电话前缀目录来演示如何使用 `None` 来处理错误。请注意，这使用了一个无限循环，并在错误发生时终止。当检测到 `None`
    时，`break` 强制退出无限循环：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Python’s dictionaries make it incredibly easy to implement symbolic names for
    labels and variables. Just create a dictionary with *name: value* pairs, and use
    the name to get the value associated with the label; for example, you might want
    to associate Hastings with the value 1066\. Typical assemblers use *directives*
    to express this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'Python 的字典使得实现标签和变量的符号名称变得非常容易。只需创建一个包含 `name: value` 对的字典，并使用名称来获取与标签关联的值；例如，你可能想将
    Hastings 与值 1066 关联。典型的汇编器使用 `directives` 来表达这一点：'
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Later in your program, you might write `LDRL` r0`,Hastings` in order to load
    `r0` with `1066`. Suppose you have a table of names and values, `namSub`, that’s
    set up as a dictionary:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序稍后，你可能会写 `LDRL r0`,Hastings` 以将 `r0` 装载为 `1066`。假设你有一个包含名称和值的表 `namSub`，它被设置为一个字典：
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we wish to get the value associated with Hastings, we can write this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想获取与 Hastings 关联的值，我们可以写下以下内容：
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The name will be translated into its value.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 名称将被转换为它的值。
- en: In what follows, we’ve written several fragments of Python code in order to
    demonstrate how the dictionary can be used. These examples demonstrate the setting
    up of a dictionary, adding information to it, and accessing it. When an assembly
    language program is run, some dictionaries are set up before it is executed, for
    example, the list of legal instructions. Some directories, such as the symbol
    table of names appearing in the assembly language program, will be constructed
    as the program runs.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们编写了几个 Python 代码片段，以展示如何使用字典。这些示例演示了如何设置字典、向其中添加信息以及访问它。当汇编语言程序运行时，一些字典在执行之前就已经设置好了，例如，合法指令列表。一些目录，如汇编语言程序中出现的符号表，将在程序运行时构建。
- en: 'The first directory in the example converts a register name into its register
    number; for example, a register name `x` can be converted to its register number
    `y` by `y = regs.get(x)`. Of course, you don’t need to use a dictionary. We could
    simply write `y = int(x[1:])` to convert the string `''r6''` into the integer
    6 by using string processing. However, the dictionary method is more elegant and
    easier to follow. Moreover, it’s more flexible:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的第一个目录将寄存器名称转换为它的寄存器号；例如，寄存器名称 `x` 可以通过 `y = regs.get(x)` 转换为其寄存器号 `y`。当然，你不需要使用字典。我们可以简单地写
    `y = int(x[1:])` 来通过字符串处理将字符串 `'r6'` 转换为整数 6。然而，字典方法更为优雅且易于理解。此外，它还更灵活：
- en: '[PRE56]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following is the output after executing the above fragment of code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在执行上述代码片段后的输出：
- en: '[PRE57]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let’s look at dictionaries in more detail with another example. The use of
    Python’s dictionaries makes it easy to implement symbolic names for labels and
    variables. All we have to do is to create a dictionary with `name: value` pairs
    and use a name to get its associated value. Suppose we’ve read an instruction,
    say, `''ADD r4,r2,r3''`, and tokenized it into this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们通过另一个示例更详细地看看字典。使用 Python 的字典使得实现标签和变量的符号名称变得容易。我们只需创建一个包含 `name: value`
    对的字典，并使用名称来获取其关联的值。假设我们已经读取了一条指令，比如说 `''ADD r4,r2,r3''`，并将其标记化如下：'
- en: '[PRE58]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can get the integer value of a register the hard way by using slicing:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过切片的艰难方式获取寄存器的整数值：
- en: '[PRE59]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let’s simplify the expression to make the explanation easier. Suppose we write
    this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简化表达式，以便更容易解释。假设我们写下以下内容：
- en: '[PRE60]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The value of `rD` is the string `'r4'`. What we need to do is to isolate the
    `'4'` from `'r4'` and then convert the character `'4'` to the integer `4`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`rD` 的值是字符串 `''r4''`。我们需要做的是从 `''r4''` 中隔离 `''4''`，然后将字符 `''4''` 转换为整数 `4`。'
- en: We can write `rD = rD[1:]` to return all characters in the string except the
    initial `'r'`. The final step is to convert to an integer, which we can do with
    `rD =` `int(rD)`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以写 `rD = rD[1:]` 来返回字符串中除了初始 `'r'` 之外的所有字符。最后一步是将它转换为整数，我们可以用 `rD = int(rD)`
    来完成。
- en: 'The `[1:]` means all the characters after the first character, `r`, which returns
    `''4''` if the register was `''r4''`. We could have written `[1:2]` rather than
    `[1:]`. However, by using `[1:]`, we can later increase the number of registers
    beyond 9 without changing the program. Putting all three steps together, we get
    this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`[1:]` 表示第一个字符 `r` 之后的所有字符，如果寄存器是 `''r4''`，则返回 `''4''`。我们本来可以写 `[1:2]` 而不是
    `[1:]`。然而，通过使用 `[1:]`，我们可以在不更改程序的情况下增加寄存器的数量超过9。将这三个步骤结合起来，我们得到以下内容：'
- en: '[PRE61]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let’s use a dictionary to carry out the same action. Assume also that we’ve
    set up a directory for the registers:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用字典执行相同的操作。假设我们已为寄存器设置了一个目录：
- en: '[PRE62]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Before processing a register name, we can test for a valid register symbolic
    name with this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理寄存器名称之前，我们可以使用以下方法测试有效的寄存器符号名称：
- en: '[PRE63]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Extracting the actual integer number of the register is easy:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 提取寄存器的实际整数编号很简单：
- en: '[PRE64]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, note that you can access a dictionary in two ways. Consider the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，您可以通过两种方式访问字典。考虑以下内容：
- en: '[PRE65]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This gives us this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下内容：
- en: '[PRE66]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The advantage of `get` is that it returns `None` if the key is not found, whereas
    the other method creates a runtime error, called `KeyError`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 的优点是，如果找不到键，则返回 `None`，而另一种方法会创建一个运行时错误，称为 `KeyError`。'
- en: Functions revisited
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数回顾
- en: This section looks at functions in a little more detail and demonstrates the
    use of the `global` statement to make parameters accessible outside a function.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将更详细地探讨函数，并演示如何使用`global`语句使参数在函数外部可访问。
- en: Parameters can be passed to functions in parentheses in the function call, and
    results retrieved by a `return()` statement. Recall that variables created in
    a function are local to the function unless they are declared as global; that
    is, if you write `x = 5` in a function, you have created a local variable `x`
    with the value `5`. If there is an `x` outside the function, it is a different
    `x`. A value declared outside a function can be accessed inside the function provided
    it hasn’t been declared as a local variable within the function.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以通过函数调用中的括号传递给函数，并通过 `return()` 语句检索结果。回想一下，在函数中创建的变量是函数本地的，除非它们被声明为全局变量；也就是说，如果您在函数中写
    `x = 5`，您已经创建了一个值为 `5` 的局部变量 `x`。如果函数外部有一个 `x`，它是一个不同的 `x`。在函数内部可以访问在函数外部声明的值，前提是它没有被在函数内部声明为局部变量。
- en: 'The body of a function is indented from the initial `def` statement. A function
    does not need an explicit termination, because *indentation* takes care of that.
    Consider the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体从初始的 `def` 语句开始缩进。函数不需要显式终止，因为 *缩进* 会处理这一点。考虑以下内容：
- en: '[PRE67]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we run this program we get the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此程序，我们会得到以下内容：
- en: '[PRE68]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As you can see, we can return a value as an argument in the return statement,
    or we can make it global. When we do use the global variables, we don’t need to
    pass the parameters to or from the function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以在返回语句中作为参数返回一个值，或者我们可以将其设置为全局变量。当我们使用全局变量时，我们不需要将参数传递到或从函数中。
- en: Imports
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入
- en: This section shows how you can access operations that are not part of the Python
    language itself. These functions are not vital to writing a simulator, but they
    do provide some very useful facilities. We’ve included this short section to demonstrate
    how these facilities are accessed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了如何访问不属于Python语言本身的操作。这些函数对于编写模拟器并非至关重要，但它们确实提供了一些非常有用的功能。我们包括这个简短的部分来演示如何访问这些功能。
- en: 'A strength of Python is that it includes several libraries of functions that
    you can access to facilitate the design of programs, for example, graphics. We
    don’t need many external functions for our work. Here, we will demonstrate two:
    `random` and `sys`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的一个优点是它包含几个函数库，您可以通过它们来方便地设计程序，例如图形。我们不需要很多外部函数来完成我们的工作。在这里，我们将演示两个：`random`
    和 `sys`。
- en: 'When simulating a computer, you often need data for testing. Typing it in is
    time-consuming. Fortunately, Python has a library of functions that generate random
    numbers. In order to use a library, you first have to import it. Consider the
    following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟计算机时，你通常需要测试数据。手动输入它很耗时。幸运的是，Python有一个生成随机数的函数库。为了使用库，你首先必须导入它。考虑以下内容：
- en: '[PRE69]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Function calls are usually of the form `library.action`. In this case, the library
    is `random` and the action is `randomint(a,b)`. The parameters `a` and `b` give
    the range of random integer values.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用通常的形式是`library.action`。在这种情况下，库是`random`，操作是`randomint(a,b)`。参数`a`和`b`给出了随机整数的范围。
- en: 'Another useful library is `sys`, which provides operating system functions
    such as `exit()`, which terminates a Python program and returns to its calling
    level. See this, for example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的库是`sys`，它提供了操作系统功能，如`exit()`，该功能终止Python程序并返回其调用级别。例如，请参阅以下内容：
- en: '[PRE70]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We have now covered enough Python topics to begin to design a real computer
    simulator in the next chapter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了足够的Python主题，可以开始设计一个真正的计算机模拟器了。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve extended our knowledge of Python and introduced or expanded
    some of the features that demonstrate its power and versatility. For example,
    we’ve looked at the list and the string, the two data structures that are of most
    importance to us. We’ve also expanded on the use of loops and other repetitive
    structures.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们扩展了我们对Python的了解，并介绍或扩展了一些展示其强大和多功能性的特性。例如，我们研究了列表和字符串，这两个对我们来说最重要的数据结构。我们还扩展了循环和其他重复结构的使用。
- en: We’ve introduced the dictionary, a delightfully elegant data structure that
    enables us to locate information by a key that describes it, rather than its location
    in the directory. For example, if we want to convert instruction names into binary
    op-code, we can create a dictionary and just look up the appropriate code for
    any mnemonic. This feature really does simplify the design of interpreters and
    assemblers.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了字典，这是一个令人愉快优雅的数据结构，使我们能够通过描述它的键来定位信息，而不是它在目录中的位置。例如，如果我们想将指令名称转换为二进制操作码，我们可以创建一个字典，并只需查找任何助记符的适当代码。这个特性确实简化了解释器和汇编器的开发。
- en: 'We’ve also looked at one of Python’s more unusual features: list comprehensions.
    These take a little getting used to, but they can make it much easier to process
    the text of assembly language instructions by cleaning up the input (for example,
    by removing spaces, or modifying punctuation and syntax).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了Python的一个不太常见的特性：列表推导。这些需要一点时间来适应，但它们可以使通过清理输入（例如，通过删除空格或修改标点符号和语法）来处理汇编语言指令的文本变得更加容易。
- en: In [*Chapter 6*](B19624_06.xhtml#_idTextAnchor091) we put together the things
    we’ve learned about the operation of a computer and design an assembler and a
    simulator for a hypothetical computer called TC1.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B19624_06.xhtml#_idTextAnchor091)中，我们将关于计算机操作的知识整合起来，并为一个名为TC1的假设计算机设计了一个汇编器和模拟器。
