- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Little More Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve introduced Python and we’ve been using it. In this chapter we increase
    our knowledge of Python and extend some of the concepts we have encountered, and
    also introduce new features. In particular, we examine data structures, starting
    with the way in which lists of elements or strings of characters can be processed.
    This chapter paves the way for [*Chapter 6*](B19624_06.xhtml#_idTextAnchor091)*,*
    where we complete the design of a computer simulator. But, before that, we provide
    a note on the terminology we use when discussing features of Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Statements and expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More string features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List comprehensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repetition and looping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists of lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indenting in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the programs used in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter05](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter requires no new resources in addition to previous chapters. All
    that is required is a computer with a Python IDE. The same is true of all chapters
    until we reach [*Chapter 9*](B19624_09.xhtml#_idTextAnchor159), which deals with
    Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Statements and Expressions
  prefs: []
  type: TYPE_NORMAL
- en: An *expression* is a combination of values and operators that can be evaluated
    to provide a result; for example `(p+q)*7 - r`. A Boolean expression is a combination
    of values and logical operators that yields the value `True` or `False`; for example,
    `p >` `q`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *statement* is a Python operation that must be evaluated by an interpreter;
    that is, it’s an action. Typical Python statements involve `if`… `for`… actions.
    These two terms are often used in formal definitions; for example, the definition
    of an `if` statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if <expr>:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`<``statement>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Angle brackets are used in descriptions of the language to indicate *something
    that will be replaced by its actual value*; for example, a valid `if` statement
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if x >` `y:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`p = p + q`'
  prefs: []
  type: TYPE_NORMAL
- en: In this case the *expression* is `x > y` and the *statement* is `p = p +` `q`.
  prefs: []
  type: TYPE_NORMAL
- en: More string features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we’re going to extend our ability to manipulate strings. The string is one
    of Python’s most important data structures and is at the heart of all the programs
    we write in this book. Python’s string-handling facilities make it one of the
    most powerful and easy-to-use text-processing languages. A string is indicated
    by quotes, which may be either single or double; for example, `x = "Two"` and
    `y = 'One'` are Python strings. Python’s ability to use two string terminators
    means that we can create strings like “Alan’s book” (i.e., use the apostrophe
    as a normal grammar element).
  prefs: []
  type: TYPE_NORMAL
- en: During the execution of a Python program, you can read a string from the keyboard
    and also provide a prompt in the following way.
  prefs: []
  type: TYPE_NORMAL
- en: '`x = input('' Please type` `something '')`'
  prefs: []
  type: TYPE_NORMAL
- en: Executing this command displays '`Please type something`' on the screen, waits
    for your input, and then assigns the string you typed to variable `x`. This mechanism
    is very useful when simulating a program, because you can provide input as the
    program runs. Note that the input string must be terminated by hitting the *Enter*
    key.
  prefs: []
  type: TYPE_NORMAL
- en: String processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can change (substitute) characters in a string by using the method `replace`.
    For example, suppose we wish to replace all occurrences of `''$''` in the string
    `price` with `''£''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we print `price`, we now get `'eggs £2,` `cheese £4'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other string methods are `upper()` (convert text to upper case), `lstrip()`
    (remove leading characters), and `rstrip()` (remove trailing characters). Let
    `x =''###this Is A test???''`. Consider the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This sequence produces `x` = '`this is is` `a test'`.
  prefs: []
  type: TYPE_NORMAL
- en: Strings are *immutable*. You cannot change them once they are defined. In the
    preceding code, it looks as if we have modified x by removing leading and trailing
    characters and converting upper case to lower case. No! In each case we have created
    a *new* string with the same name as the old string (i.e., x).
  prefs: []
  type: TYPE_NORMAL
- en: If you were to enter `y =` '`Allen`' and try to edit it to read '`Allan`' by
    changing the '`e`' to '`a`' using the expression `y[3] =` '`a`', you would get
    an error, because you would have tried to change an immutable string. However,
    you could legally write `y = y[0:3] + 'a' + y[4]` to create a new string `y` with
    the value `'Allan'`.
  prefs: []
  type: TYPE_NORMAL
- en: The addition symbol, +, performs addition in *arithmetic* and *concatenation*
    in string processing; for example, `x = 4 + 5` gives `9`, whereas `x = '4' + '5'`
    gives `'45'`. This action is called *operator overloading* and indicates the extension
    of a function, when, for example, the function is applied to different objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The TC1 assembler uses the following string methods to remove spaces before
    an instruction, enable users to employ upper- or lower-case, and allow the use
    of a space or comma as a separator. For example, this code fragment lets you write
    either `r0,[r1]` or `R0,R1` with the same meaning. The code below shows how TC1
    takes a line of the input (i.e., an assembly instruction) and simplifies it for
    later conversion to binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose an instruction is entered in string form as '' `ADD r0,R1,r3`''. This
    has leading spaces, upper- and lower-case text and commas, and is converted to
    `''ADD R0 R1 R3''` by the above sequence of operations. The next step is to convert
    the string into individual *tokens* for analysis by the assembler. We can do this
    with the `split()` method. which converts a string into a list of strings separated
    by the character in the parentheses. Note that the default parameter is a space.
    If `s = ''ADD R0 R1 R2''`, then `s.split()` or `s.split('' '')` results in this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`s = [''ADD'', ''R1'', ''R2'', ''R3'']`      # A list of four tokens, each
    of which is a string'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a list consisting of four separate strings; that is, a command
    followed by three parameters. We can access each of these strings using index
    notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now perform operations on the tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The second statement uses `T2[1:]` to convert string `'R2'` into a new string
    `'2'` by removing the first character. The slice notation `[1:]` is interpreted
    as "All characters following the first." This lets us deal with one- or two-digit
    values like R2 or R23\. Since there are only 8 registers, we could have written
    `[1:2]`. Using `[1:]` allows the extension 16 registers in a future version of
    TC1 without changing the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to use the *integer* function `int` to convert the register number
    from a string into its value as an integer. When learning Python, a common mistake
    is to forget to convert a string to an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code would generate an error. Because `regNum` is created as a string,
    holding the value you typed. However, in the second line, the program is expecting
    an integer as a list index. You have to write `reg[int(regNum)]` to convert the
    numeric string into an integer value.
  prefs: []
  type: TYPE_NORMAL
- en: Example – text Input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s a simple example of text input with Python using a simple `.txt` file.
    The source file is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This file was processed by Python as follows. I use the address it had on my
    computer. This is read into a variable `sFile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this code fragment is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We now have a Python list of strings, each corresponding to one line of the
    source text. Note that each line ends with an end-of-line (i.e., \n) and any spaces
    in the text are included. For example, there’s a totally empty line and an empty
    line with a space. We have to take account of these when dealing with the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having increased our ability to manipulate text strings, in the next section
    we look at one of Python’s most interesting features: the facility to perform
    a sequence of operations on a string or a list in just one line of code with list
    comprehension.'
  prefs: []
  type: TYPE_NORMAL
- en: List comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now introduce a very powerful feature of Python, the *list comprehension*.
    It’s not powerful because of what it can do, but because of how succinct it is.
    A list comprehension lets you take a list and process it in a single line. We
    take a look at list comprehensions, because they are so useful in processing text;
    for example, you can use a list comprehension to take a line of text and replace
    all double-spaces with single spaces, or convert all lower-case characters to
    upper-case characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'List comprehensions can be applied to any iterable. An iterable is a structure
    that you can step through, such as a list, a string, or a tuple. The simplest
    form of list comprehension is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x =` [`i` for `i` in `y`]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `x` and `y` are strings (or lists). The text in bold represents Python
    reserved words and punctuation. The variable `i` is a user-chosen variable used
    to step through the list. We could have used any name instead of *i*; it simply
    doesn’t matter. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lettersList = [i for i` `in ''Tuesday'']`'
  prefs: []
  type: TYPE_NORMAL
- en: The iterable being processed is the string `'Tuesday'` and it is copied a character
    at a time to `lettersList`. This returns `lettersList` as the list of characters
    `[`'`T','u','e','s','d','a','y']`. We have turned a string into a list of characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a more sophisticated version of the list comprehension as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'where `expression` is a Python expression, and `condition` is a Boolean condition.
    We step through the iterable, `y`, looking at each element and selecting it subject
    to a condition, processing it according to the expression, and then putting it
    in a new list. That’s an awful lot of work in a single line. Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The condition is *if item i from y is not equal to ‘$’* . This list comprehension
    says, "Copy the characters in string y to string x, one-by-one, as long as the
    character isn’t a `''$''` character." The result is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The original string has been replaced by a list of single-character strings,
    but with every `'$'` removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at three examples of list comprehensions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example demonstrates how empty lines (i.e., '''') can be removed
    from the input. We can copy all lines apart from those equal to the null or empty
    string " "with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve renamed the new list the same as the old one. There’s no reason why we
    can’t do this and it saves having to invent a new name for each of the list comprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second example is this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We apply the function `.upper()` to each element `i`. This expression converts
    a lower-case character into its upper-case equivalent; that is, it converts all
    strings to upper-case. The last list comprehension is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The expression `i.split()` divides the source string into individual tokens
    (strings) at each space. This means we can then then process the line as a sequence
    of tokens. The condition `if i != ''` is used to remove empty strings by not copying
    them.
  prefs: []
  type: TYPE_NORMAL
- en: The third example removes empty lines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ve created a list of three instructions that has empty lines in it, denoted
    by '' ''. When we execute this list comprehension, we convert each string into
    a sublist and we remove the empty lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The tuple
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now introduce the tuple for the sake of completeness, although we make little
    use of it in this text. A list is a sequence of elements enclosed by square brackets;
    for example, `P = [1,4,8,9]`. A tuple is a sequence of elements separated by round
    brackets; for example, `Q = (``1,4,8,9)`.
  prefs: []
  type: TYPE_NORMAL
- en: There is little difference between a tuple and a list; they are both data structures
    that hold a sequence of elements. However, a *tuple is immutable* and cannot be
    modified, unlike a list. A tuple is a read-only list and is used when you wish
    to store data that does not change. Although not relevant here, tuples do have
    implementation and performance advantages over lists; that is, if you have a list
    that is fixed, it is better to use a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, we will use tuples in dictionary structures, as here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the values in bold are each two-component tuples. We could have
    used a list, but the tuple indicates a fixed structure that cannot change. If
    you were to use a list instead of a tuple, you would write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Repetition and looping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now expand our knowledge of Python’s repetition mechanism, a feature common
    to all high-level procedural languages. In this section we learn how to do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Repeat an action multiple times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use different data and parameters each time you carry out the action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterate over elements in a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `enumerate` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose we want to test whether a list includes a particular item. We can create
    a `for` loop to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This code first sets `inList` to `False` to indicate that the element `'grapes'`
    has not been found. The `for` loop steps though all elements in the list, testing
    each one for the item we’re looking for. If it is found, `inList` is set to `True`.
    This code works, but it is not good. If there are a million elements in the list
    and grapes the first one, the code still steps through the remaining 999,999 elements.
    This is horribly inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we compare successive elements with a value, and stop
    if we find it. On each cycle, if the item is not found, we continue. If we find
    what we want, we jump out of the loop rather than continuing to the bitter end
    by testing every single item. When we do the comparison, if the current item is
    *not* equal to '`grapes'`, we set `inList` to `False` and the loop continues with
    the next element.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we find `''grapes''`, the `else` part of the `if` statement sets `inList`
    to `True` and then uses a `break` statement to exit the loop and avoid further
    pointless cycles round the loop. A `break` in a `for` or `while` loop tells Python
    to exit the loop now and continue with the next instruction *after* the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable `inList` is just a flag that we can use later in the program;
    for example, we could write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach is to use the list operator `in`. If we have a list, we can
    check whether an item is a member of that list by using the following construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first line returns `True` if `'grapes'` is in the list `fruit1`, and `False`
    otherwise. The `in` construct is very useful in testing whether an item belongs
    to a group of other items arranged as a list; for example, if all employees are
    in the list `staff`, then
  prefs: []
  type: TYPE_NORMAL
- en: sets `worksHere` to `True` if `Smith` is a valid employee name, and `False`
    otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Later we will use the `in` operator in to test whether an instruction is a
    member of a set, as here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Repetition and Iterables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another version of the `for` loop iterates over the elements of a list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The words in bold are the reserved Python words; the other words are user-defined
    variables. Here, the `i` is not a sequence-counting integer as it was in the previous
    example using `range()`. It is the value of each element (or iterable) in the
    list taken in turn. Consider the following example using a list of colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This code steps through each element of the list `car` and prints out its value,
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider an example using a list of computer operations. In this case we’ve
    taken a list of tuples, one for each of four op-codes. The tuple consists of an
    op-code string, an instruction type, and the number of operands required. This
    is just a demonstration. We could have used a list but chose a tuple to emphasize
    that the tuple values do not change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code fragment is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We have now demonstrated that you can iterate through a list of any type in
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'A particularly interesting feature of Python is looping with a *double index*.
    You can step through a list by numeric index, or by object name. This is useful
    when you want to step through by object name but would also like to know where
    it is in the list. The Python function `enumerate` permits this form of looping.
    It is easier to demonstrate the action of `enumerate` than to explain it. Consider
    the previous example of the list `car`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The iterator, `color`, has become a sequence of tuples with the element index
    and the corresponding value from the list. Remember that a tuple is like a list
    except that its elements are immutable and can’t be changed. Here’s a case where
    I would use an iterator name like *color*, rather than `i`, because it is more
    explicit/descriptive, and it is less easy to confuse with an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative form of enumeration uses two indices, one an explicit integer
    count and one an element count. In the following example, `count` is the explicit
    integer index and `color` is the enumeration index. Thus, `count` steps `0`, `1`,
    `2` etc., and `color` steps `red`, `white`, `green` …:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Lists of lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we extend the use of Python’s most important data structure, the list.
    First, we demonstrate that a list can, itself, contain lists. Python lets you
    construct lists with any type of item; for example, `x = [1,2,''test'',v,True]`
    defines a list with two integers, a string, a variable, and a Boolean constant.
    Since you can use any legal element in a list, you can create a *list of lists*.
    Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is a list of three items and each item is a list itself (shaded); for example,
    the first item in this list is the list ['apple',2.35,150]. Each sub-list consists
    of a string naming the fruit, the price of the fruit, and the current stock level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to know the price of oranges; we could write something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We use a `for` loop to step through the list of fruits. Then, when we’ve located
    the item we want (which is a list), we read the second item of that list. As you
    can see, we use two subscripts, first [i] and then [1].
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example of lists of lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not easy on the eye! Let’s use bold font and shading to emphasize the
    components of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s a list consisting of two items: [4,9,[1,6]] and [8,7`4`, `9` and the list
    [1,6].'
  prefs: []
  type: TYPE_NORMAL
- en: If I were to write `x = testList[1][2][1]`, what would the value of `x` be?
  prefs: []
  type: TYPE_NORMAL
- en: It would be `9`, because `testList`[1] is `[8,7,[0,9]]` and `testList[1]`[2]is
    [0,9] and `testList[1][2]`[1]is 9\. Think of this as a tree with branches! The
    first branch is element `[1]` of `testList`. The second branch is element `[2]`
    of that branch, and the third (final) branch is element `[1]` on that second branch.
    *Figure 5**.1* illustrates the concept of embedded lists graphically.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 - Illustration of embedded lists](img/Figure_5.01_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 - Illustration of embedded lists
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a second example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: What is `x[2][3]`? This expression yields `'n'`, because `x[2]` is `'then'`
    , and element 3 of that is `'n'`.
  prefs: []
  type: TYPE_NORMAL
- en: Indenting in python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have been indenting code since we introduced Python. Now we re-emphasize
    the use of the indent in Python because it is so vital to correct programming.
    Most computer languages allow you to group statements together, as a block, for
    a particular purpose. Typically, the instructions in a group are executed as a
    batch, one by one. Such groups are often associated with conditional statements
    and loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some languages indicate a block of instructions by enclosing them in curly
    brackets `{ }`. Consider the following. It’s not real code; it’s just plain text
    designed to illustrate the layout of a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you have several blocks of operations, which include nested blocks (i.e.,
    a block within another block). Blocks are executed as if they were a single operation;
    that is, they are the computer equivalent of *subcontracting*. Although it is
    not a programming requirement, it is normal to use indentation as a reading aid
    to make the code more understandable to people, as here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Python doesn’t use brackets to indicate a block of consecutive operations. It
    requires that a block of code be indented (and the same indentation used for each
    member of the block). Failure to get the indentation right will either result
    in a failure to compile the program, or a program that doesn’t do what you think
    it will do. Errors of indentation are one of the first things that the novice
    programmer encounters. An indentation error is very easy to miss. For example,
    if you accidentally create an indent or remove an indent while editing a program,
    you can easily get an error that takes a long time to locate.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of the use of blocks and indentation in Python is given below.
    Although any amount of indent is legal, by convention, an indent is normally four
    spaces. Each level of indentation is shaded. Note that the `else` in the last
    line belongs to the first `if`. If we had indented it further, it would belong
    to the second `if`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section we introduce Python’s dictionary mechanism, which makes writing
    simulators so easy. Here, you will learn how to create a dictionary that translates
    one thing into another, for example, translating the name of an instruction into
    its binary code. Here we learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The nature of a dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of a dictionary over the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between a dictionary key and a dictionary value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting items in a dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting items from a dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a dictionary to solve a problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dictionary is one of Python’s most useful features, a feature that makes
    it so much easier to design simulators. The Python dictionary is an impressive
    data structure that is accessed by means of a *key*, rather than a location within
    the data structure. Instead of providing a location like `myList[5]`, you look
    up an item in a dictionary in exactly the same way you use a dictionary in everyday
    life. You provide the dictionary with a name (which we call a *key*) and up pops
    the information *associated* with that name. Keys are unique; the same key can’t
    appear more than once in a dictionary (just as social security numbers are unique).
  prefs: []
  type: TYPE_NORMAL
- en: A Python dictionary has the form `{key1:value1, key2:value2, key3:value3}`;
    for example, `{'UK':44, 'USA':1, 'Germany':49, 'France':33}` might be used to
    look up a country’s international telephone prefix. The dictionary is enclosed
    in curly braces, and `key:value` pairs have a colon between the key and its value.
    The order of pairs in a dictionary does not matter, because an item is accessed
    by its *key* and not by its location in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: The key is often a string, but that is not a requirement. In our computer simulator,
    the keys are usually the mnemonic codes of a computer language. The value associated
    with a key can be any legal Python data structure. In some of the simulators we
    create, we often specify the value as a tuple, which is an ordered list. For example,
    the dictionary entry `'INC':(8,16)`has the key `'INC'` and the value `(8,16)`.
    Searching the dictionary using the key `'INC'`, returns the tuple `(8,16)`. In
    this case, the value is the format of the instruction (i.e., 8), and its op-code
    (i.e., 16).
  prefs: []
  type: TYPE_NORMAL
- en: You could use a list as a value instead of a tuple, that is, `'INC':[8,16]`.
    The only significant difference is that you can’t change a tuple once it is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check whether an item is in the dictionary by writing `if key in dictionary`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: To obtain the information about a particular mnemonic, we can use the `get`
    method to read the value associated with the key. For example, `opData =` `opCodes`.get`('INC')`
    returns`(8,16)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then access the two fields of the tuple associated with `''INC''` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If the requested key is not in the dictionary, the `get` method returns `None`.
    `None` is a Python reserved word and indicates a null value. Note that `None`
    is not zero or an empty string, it has its own type `None`. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code uses the telephone prefix directory we described above to
    demonstrate how to use `None` to deal with errors. Note that this uses an infinite
    loop and terminates on an error. When `None` is detected, the `break` forces an
    exit from the infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Python’s dictionaries make it incredibly easy to implement symbolic names for
    labels and variables. Just create a dictionary with *name: value* pairs, and use
    the name to get the value associated with the label; for example, you might want
    to associate Hastings with the value 1066\. Typical assemblers use *directives*
    to express this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Later in your program, you might write `LDRL` r0`,Hastings` in order to load
    `r0` with `1066`. Suppose you have a table of names and values, `namSub`, that’s
    set up as a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wish to get the value associated with Hastings, we can write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The name will be translated into its value.
  prefs: []
  type: TYPE_NORMAL
- en: In what follows, we’ve written several fragments of Python code in order to
    demonstrate how the dictionary can be used. These examples demonstrate the setting
    up of a dictionary, adding information to it, and accessing it. When an assembly
    language program is run, some dictionaries are set up before it is executed, for
    example, the list of legal instructions. Some directories, such as the symbol
    table of names appearing in the assembly language program, will be constructed
    as the program runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first directory in the example converts a register name into its register
    number; for example, a register name `x` can be converted to its register number
    `y` by `y = regs.get(x)`. Of course, you don’t need to use a dictionary. We could
    simply write `y = int(x[1:])` to convert the string `''r6''` into the integer
    6 by using string processing. However, the dictionary method is more elegant and
    easier to follow. Moreover, it’s more flexible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output after executing the above fragment of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at dictionaries in more detail with another example. The use of
    Python’s dictionaries makes it easy to implement symbolic names for labels and
    variables. All we have to do is to create a dictionary with `name: value` pairs
    and use a name to get its associated value. Suppose we’ve read an instruction,
    say, `''ADD r4,r2,r3''`, and tokenized it into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get the integer value of a register the hard way by using slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s simplify the expression to make the explanation easier. Suppose we write
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The value of `rD` is the string `'r4'`. What we need to do is to isolate the
    `'4'` from `'r4'` and then convert the character `'4'` to the integer `4`.
  prefs: []
  type: TYPE_NORMAL
- en: We can write `rD = rD[1:]` to return all characters in the string except the
    initial `'r'`. The final step is to convert to an integer, which we can do with
    `rD =` `int(rD)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `[1:]` means all the characters after the first character, `r`, which returns
    `''4''` if the register was `''r4''`. We could have written `[1:2]` rather than
    `[1:]`. However, by using `[1:]`, we can later increase the number of registers
    beyond 9 without changing the program. Putting all three steps together, we get
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use a dictionary to carry out the same action. Assume also that we’ve
    set up a directory for the registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Before processing a register name, we can test for a valid register symbolic
    name with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Extracting the actual integer number of the register is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, note that you can access a dictionary in two ways. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of `get` is that it returns `None` if the key is not found, whereas
    the other method creates a runtime error, called `KeyError`.
  prefs: []
  type: TYPE_NORMAL
- en: Functions revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section looks at functions in a little more detail and demonstrates the
    use of the `global` statement to make parameters accessible outside a function.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters can be passed to functions in parentheses in the function call, and
    results retrieved by a `return()` statement. Recall that variables created in
    a function are local to the function unless they are declared as global; that
    is, if you write `x = 5` in a function, you have created a local variable `x`
    with the value `5`. If there is an `x` outside the function, it is a different
    `x`. A value declared outside a function can be accessed inside the function provided
    it hasn’t been declared as a local variable within the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of a function is indented from the initial `def` statement. A function
    does not need an explicit termination, because *indentation* takes care of that.
    Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this program we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can return a value as an argument in the return statement,
    or we can make it global. When we do use the global variables, we don’t need to
    pass the parameters to or from the function.
  prefs: []
  type: TYPE_NORMAL
- en: Imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section shows how you can access operations that are not part of the Python
    language itself. These functions are not vital to writing a simulator, but they
    do provide some very useful facilities. We’ve included this short section to demonstrate
    how these facilities are accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A strength of Python is that it includes several libraries of functions that
    you can access to facilitate the design of programs, for example, graphics. We
    don’t need many external functions for our work. Here, we will demonstrate two:
    `random` and `sys`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When simulating a computer, you often need data for testing. Typing it in is
    time-consuming. Fortunately, Python has a library of functions that generate random
    numbers. In order to use a library, you first have to import it. Consider the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Function calls are usually of the form `library.action`. In this case, the library
    is `random` and the action is `randomint(a,b)`. The parameters `a` and `b` give
    the range of random integer values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful library is `sys`, which provides operating system functions
    such as `exit()`, which terminates a Python program and returns to its calling
    level. See this, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We have now covered enough Python topics to begin to design a real computer
    simulator in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve extended our knowledge of Python and introduced or expanded
    some of the features that demonstrate its power and versatility. For example,
    we’ve looked at the list and the string, the two data structures that are of most
    importance to us. We’ve also expanded on the use of loops and other repetitive
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve introduced the dictionary, a delightfully elegant data structure that
    enables us to locate information by a key that describes it, rather than its location
    in the directory. For example, if we want to convert instruction names into binary
    op-code, we can create a dictionary and just look up the appropriate code for
    any mnemonic. This feature really does simplify the design of interpreters and
    assemblers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve also looked at one of Python’s more unusual features: list comprehensions.
    These take a little getting used to, but they can make it much easier to process
    the text of assembly language instructions by cleaning up the input (for example,
    by removing spaces, or modifying punctuation and syntax).'
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B19624_06.xhtml#_idTextAnchor091) we put together the things
    we’ve learned about the operation of a computer and design an assembler and a
    simulator for a hypothetical computer called TC1.
  prefs: []
  type: TYPE_NORMAL
