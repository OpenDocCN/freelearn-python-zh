<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Working with the Python GUI"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Working with the Python GUI</h1></div></div></div><p>In the first four chapters, we used the Python interactive prompt or Arduino serial monitor to observe the results. The method of using text-based output on prompt may be useful for basic and quick prototyping, but when it comes to an advanced level of<a id="id466" class="indexterm"/> prototyping and demonstrating your prototype or final product, you need to have a nice looking and user-friendly interface. GUI helps users to understand various components of your hardware project and easily interact with it. It can also help you to validate the results from your project.</p><p>Python has a number of widely used GUI frameworks such as <code class="literal">Tkinter</code>, <code class="literal">wxPython</code>, <code class="literal">PyQt</code>, <code class="literal">PySide</code>, and <code class="literal">PyGTK</code>. Each of these frameworks possesses an almost complete set of features that are required to create professional applications. Due to the complexity involved, these frameworks have different levels of learning curves for first-time Python programmers. Now, as this book is dedicated to Python programming for Arduino-based projects, we can't spend a large amount of time learning the nitty-gritty of a specific framework. Instead, we will choose our interface library based on the following criteria:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ease to install and get started</li><li class="listitem" style="list-style-type: disc">Ease to implement with negligible learning efforts</li><li class="listitem" style="list-style-type: disc">Use of minimum computational resources</li></ul></div><p>The framework that satisfies all these requirements<a id="id467" class="indexterm"/> is <code class="literal">Tkinter</code> (<a class="ulink" href="https://wiki.python.org/moin/TkInter">https://wiki.python.org/moin/TkInter</a>). <code class="literal">Tkinter</code> is also the default standard GUI library deployed <a id="id468" class="indexterm"/>with all Python installations.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>Although <code class="literal">Tkinter</code> is the de-facto GUI package for Python, you can learn more about other GUI frameworks that were mentioned earlier from<a id="id469" class="indexterm"/> their <a id="id470" class="indexterm"/>official<a id="id471" class="indexterm"/> websites, which <a id="id472" class="indexterm"/>are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>wxPython</strong></span>: <a class="ulink" href="http://www.wxpython.org/">http://www.wxpython.org/</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>PyGTK</strong></span>: <a class="ulink" href="http://www.pygtk.org/">http://www.pygtk.org/</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>PySide</strong></span>: <a class="ulink" href="http://qt-project.org/wiki/PySide">http://qt-project.org/wiki/PySide</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>PyQt</strong></span>: <a class="ulink" href="http://sourceforge.net/projects/pyqt/">http://sourceforge.net/projects/pyqt/</a></li></ul></div></div></div><div class="section" title="Learning Tkinter for GUI design"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Learning Tkinter for GUI design</h1></div></div></div><p>
<code class="literal">Tkinter</code>, short for <code class="literal">Tk</code> interface, is a cross-platform Python interface for the <code class="literal">Tk</code> GUI toolkit. <code class="literal">Tkinter</code> provides a thin layer on Python while <code class="literal">Tk</code> provides the graphical widgets. <code class="literal">Tkinter</code> is a<a id="id473" class="indexterm"/> cross-platform library and gets deployed as part of Python installation packages for major operating systems. For Mac OS X 10.9, <code class="literal">Tkinter</code> is installed <a id="id474" class="indexterm"/>with the default Python framework. For Windows, when you install Python from the installation file, <code class="literal">Tkinter</code> gets installed with it.</p><p>
<code class="literal">Tkinter</code> is designed to take minimal programming efforts for developing graphical applications, while also being powerful enough to provide support for the majority of GUI application features. If required, <code class="literal">Tkinter</code> can also be extended with plugins. <code class="literal">Tkinter</code> via <code class="literal">Tk</code> offers an operating system's natural look and feel after the release of <code class="literal">Tk</code> Version 8.0.</p><p>To test your current version of the <code class="literal">Tk</code> toolkit, use the following commands on the Python prompt:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; import Tkinter
&gt;&gt;&gt; Tkinter._test()</pre></div><p>You will be prompted with an image similar to that displayed in the following screenshot that contains information about your <code class="literal">Tk</code> version:</p><div class="mediaobject"><img src="graphics/5938OS_05_01.jpg" alt="Learning Tkinter for GUI design"/></div><p>If you face any problem in getting this window, check your Python installation and reinstall it, as you won't be able to move further ahead in this chapter without the <code class="literal">Tkinter</code> library and the <code class="literal">Tk</code> toolkit.</p><p>The <code class="literal">Tkinter</code> interface <a id="id475" class="indexterm"/>supports <a id="id476" class="indexterm"/>various widgets to develop GUIs. The following table describes a few of the important widgets that we will be using in this chapter:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Widget</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Tk()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id477" class="indexterm"/> the root <a id="id478" class="indexterm"/>widget that is required by each program</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Label()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This shows <a id="id479" class="indexterm"/>a text or <a id="id480" class="indexterm"/>an image</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Button()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is <a id="id481" class="indexterm"/>a simple <a id="id482" class="indexterm"/>button that can be used to execute actions</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Entry()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a text<a id="id483" class="indexterm"/> field to <a id="id484" class="indexterm"/>provide inputs to the program</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Scale()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id485" class="indexterm"/>provides a <a id="id486" class="indexterm"/>numeric value by dragging the slider</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Checkbox()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This enables <a id="id487" class="indexterm"/>you to <a id="id488" class="indexterm"/>toggle between two values by checking the box</p>
</td></tr></tbody></table></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>A detailed description of the <code class="literal">Tkinter</code> functions and methods to implement the majority of functionalities provided by the <code class="literal">Tk</code> toolkit can be obtained from <a class="ulink" href="https://docs.python.org/2/library/tk.html">https://docs.python.org/2/library/tk.html</a>.</p></div></div></div></div>
<div class="section" title="Your first Python GUI program"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Your first Python GUI program</h1></div></div></div><p>As we discussed in <a id="id489" class="indexterm"/>an earlier chapter, the first program while learning any programming language includes printing <code class="literal">Hello World!</code>. Now, as we are starting Python programming for GUI, let's start by printing the same string in a GUI window instead of a prompt.</p><p>Just to start with GUI programming, we are going to execute a Python program and then jump into explaining the structure and the details of the code. Let's create a Python executable file using the following lines of code, name it <code class="literal">helloGUI.py</code>, and then run it. The execution process should complete without any dependency errors:</p><div class="informalexample"><pre class="programlisting">import Tkinter

# Initialize main windows with title and size
top = Tkinter.Tk()
top.title("Hello GUI")
top.minsize(200,30)

# Label widget
helloLabel = Tkinter.Label(top, text = "Hello World!")
helloLabel.pack()

# Start and open the window
top.mainloop()</pre></div><p>You should be prompted with the following window on the successful execution of the preceding code snippet. As you can see, the <code class="literal">Hello World!</code> string has been printed inside <a id="id490" class="indexterm"/>the window and has <span class="strong"><strong>Hello GUI</strong></span> as the title of the window:</p><div class="mediaobject"><img src="graphics/5938OS_05_02.jpg" alt="Your first Python GUI program"/></div><p>So, what exactly happened? As you can see from the code snippet, we instantiated various <code class="literal">Tkinter</code> widgets one by one to obtain this result. These widgets are the building blocks for any Python GUI application that is developed using <code class="literal">Tkinter</code>. Let's start with the first and the most important widget, <code class="literal">Tk()</code>.</p><div class="section" title="The root widget Tk() and the top-level methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec75"/>The root widget Tk() and the top-level methods</h2></div></div></div><p>The <code class="literal">Tk()</code> widget initializes a main empty window with a title bar. This is a root widget and<a id="id491" class="indexterm"/> it is required by each program only once. The main window gets its decoration and styles from the operating system's environment. Therefore, when you run the same <code class="literal">Tkinter</code> code on different operating systems, you will get the same window and title bar but in a different style.</p><p>Once you create a root widget, you can perform some top-level methods to decorate, describe, or resize this window. In code, we are using the <code class="literal">title()</code> method to set the title of the main window. This <code class="literal">title()</code> method takes a string as an input argument:</p><div class="informalexample"><pre class="programlisting">Top = Tkinter.Tk()
top.title("Hello GUI")</pre></div><p>Next, we call the <code class="literal">minsize()</code> method on the main window to set the minimum size of the window with the argument <code class="literal">(width, height)</code>:</p><div class="informalexample"><pre class="programlisting">top.minsize(200,30)</pre></div><p>Similarly, you can also use the <code class="literal">maxsize()</code> method to specify the maximum size that the main window should have. In the <code class="literal">minsize()</code> and <code class="literal">maxsize()</code> methods, the values of <code class="literal">width</code> and <code class="literal">height</code> are provided in the number of pixels.</p><p>Once the entire program has been instantiated, the <code class="literal">mainloop()</code> function is required to start the event loop:</p><div class="informalexample"><pre class="programlisting">top.mainloop()</pre></div><p>You won't be <a id="id492" class="indexterm"/>able to see any other widgets, including the main window, if the code does not enter in the main event loop. The event loop will be alive until the window is manually closed or the quit method is called.</p><p>You might have various questions about updating the window, programmatically closing it, arranging widgets in the grid, and so on. There are definitely a lot more top-level methods than the ones specified earlier.</p></div><div class="section" title="The Label() widget"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec76"/>The Label() widget</h2></div></div></div><p>The other widget used in the code beside <code class="literal">Tk()</code> is <code class="literal">Label()</code>. The <code class="literal">Tkinter</code> widgets are part of the <a id="id493" class="indexterm"/>widget hierarchy, where <code class="literal">Label()</code> is the child of the root widget, <code class="literal">Tk()</code>. This widget cannot be called without specifying the root widget or the main window on which the label needs to be displayed. The major use of this widget is to display text or image in the main window. In the following line of code, we use it to display the <code class="literal">Hello World!</code> string:</p><div class="informalexample"><pre class="programlisting">helloLabel = Tkinter.Label(top, text = "Hello World!")</pre></div><p>Here, we created and initialized a label object called <code class="literal">helloLabel</code>, which has two input parameters: the <code class="literal">top</code> variable that specifies the root widget and a <code class="literal">text</code> string. The <code class="literal">Label()</code> widget is highly customizable and accepts various configuration parameters for adjusting the width, border, background, and justification as options. Examples involving these customizations are covered in the upcoming sections. You can learn more about the supported input arguments at <a class="ulink" href="http://effbot.org/tkinterbook/label.htm">http://effbot.org/tkinterbook/label.htm</a>.</p></div><div class="section" title="The Pack geometry manager"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec77"/>The Pack geometry manager</h2></div></div></div><p>The <a id="id494" class="indexterm"/>Pack geometry manager <a id="id495" class="indexterm"/>organizes widgets in rows and columns. To use this, <code class="literal">Tkinter</code> requires the <code class="literal">pack()</code> method to be called for each widget to make the widget visible on the main window:</p><div class="informalexample"><pre class="programlisting">helloLabel.pack()</pre></div><p>The Pack geometry manager can be used by all <code class="literal">Tkinter</code> widgets, except root, to organize the widget in the root window. In the case of multiple widgets, if the positions for <a id="id496" class="indexterm"/>the widgets are not specified, the Pack manager arranges them in the same root window. The Pack manager is simple to implement, but it has a limitation in terms of its <a id="id497" class="indexterm"/>degree of customization. An alternative geometry manager that is helpful to create a complex layout is called <a id="id498" class="indexterm"/>
<span class="strong"><strong>Grid</strong></span>, which is explained in the upcoming sections.</p><p>We will cover additional widgets and their associated methods in the upcoming coding exercises. In these exercises, we will explain each individual widget with practical applications to give you a better understanding of the use cases.</p></div></div>
<div class="section" title="The Button() widget &#x2013; interfacing GUI with Arduino and LEDs"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec33"/>The Button() widget – interfacing GUI with Arduino and LEDs</h1></div></div></div><p>Now that you have had your first hands-on experience in creating a Python graphical interface, let's integrate Arduino with it. Python makes it easy to interface various heterogeneous packages within each other and that is what you are going to do. In the <a id="id499" class="indexterm"/>next coding <a id="id500" class="indexterm"/>exercise, we will use <code class="literal">Tkinter</code> and <code class="literal">pyFirmata</code> to make the GUI work with Arduino. In this exercise, we are going to use the <code class="literal">Button()</code> widget to control the LEDs interfaced with the Arduino board.</p><p>Before we jump to the exercises, let's build the circuit that we will need for all upcoming programs. The following is a Fritzing diagram of the circuit where we use two different colored LEDs with pull up resistors. Connect these LEDs to digital pins 10 and 11 on your Arduino Uno board, as displayed in the following diagram:</p><div class="mediaobject"><img src="graphics/5938OS_05_10.jpg" alt="The Button() widget – interfacing GUI with Arduino and LEDs"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>While working with the programs provided in this and upcoming sections, you will have to replace the Arduino port that is used to define the board variable according to your operating system. To find out which port your Arduino board is connected to, follow the detailed instructions provided in <a class="link" href="ch02.html" title="Chapter 2. Working with the Firmata Protocol and the pySerial Library">Chapter 2</a>, <span class="emphasis"><em>Working with the Firmata Protocol and the pySerial Library</em></span>. Also, make sure that you provide the correct pin number in the code if you are planning to use any pins other than 10 and 11. For some exercises, you will have to use the PWM pins, so make sure that you have correct pins.</p></div></div><p>In the previous <a id="id501" class="indexterm"/>exercise, we asked you to use the entire code snippet as a Python file and run it. This might not be possible in the upcoming exercises due to the length of the program and the complexity involved. Therefore, we have assembled these exercises in the program files that can be accessed from the code folder of <a class="link" href="ch04.html" title="Chapter 4. Diving into Python-Arduino Prototyping">Chapter 4</a>, <span class="emphasis"><em>Diving into Python-Arduino Prototyping</em></span>, which can be downloaded from <a class="ulink" href="https://www.packtpub.com/books/content/support/1961">https://www.packtpub.com/books/content/support/1961</a>. For the <code class="literal">Button()</code> widget exercise, open the <code class="literal">exampleButton.py</code> file from the code folder of <a class="link" href="ch04.html" title="Chapter 4. Diving into Python-Arduino Prototyping">Chapter 4</a>, <span class="emphasis"><em>Diving into Python-Arduino Prototyping</em></span>. The code contains three main components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">pyFirmata</code> library and Arduino configurations</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Tkinter</code> widget definitions for a button</li><li class="listitem" style="list-style-type: disc">The LED blink function that gets executed when you press the button</li></ul></div><p>As you can see in the following code snippet, we have first imported libraries and initialized the Arduino board using <code class="literal">pyFirmata</code> methods. For this exercise, we are only going to work with one LED and we have initialized only the <code class="literal">ledPin</code> variable for it:</p><div class="informalexample"><pre class="programlisting">import Tkinter
import pyfirmata
from time import sleep
port = '/dev/cu.usbmodemfa1331'
board = pyfirmata.Arduino(port)
sleep(5)
ledPin = board.get_pin('d:11:o')</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>As we are using the <code class="literal">pyFirmata</code> library for all the exercises in this chapter, make sure that you have uploaded the latest version of the standard Firmata sketch on your Arduino board.</p></div></div><p>In the second part of the code, we have initialized the root <code class="literal">Tkinter</code> widget as <code class="literal">top</code> and provided a title string. We have also fixed the size of this window using the <code class="literal">minsize()</code> method. In order to get more familiar with the root widget, you can play around with the minimum and maximum size of the window:</p><div class="informalexample"><pre class="programlisting">top = Tkinter.Tk()
top.title("Blink LED using button")
top.minsize(300,30)</pre></div><p>The <code class="literal">Button()</code> widget is a standard <code class="literal">Tkinter</code> widget that is mostly used to obtain the manual, external input stimulus from the user. Like the <code class="literal">Label()</code> widget, the <code class="literal">Button()</code> widget can be used to display text or images. Unlike the <code class="literal">Label()</code> widget, it can be <a id="id502" class="indexterm"/>associated with actions or methods when it is pressed. When the button is pressed, <code class="literal">Tkinter</code> executes the methods or commands specified by the <code class="literal">command</code> option:</p><div class="informalexample"><pre class="programlisting">startButton = Tkinter.Button(top,
                             text="Start",
                             command=onStartButtonPress)
startButton.pack()</pre></div><p>In this initialization, the function associated with the button is <code class="literal">onStartButtonPress</code> and the <code class="literal">"Start"</code> string is displayed as the title of the button. Similarly, the <code class="literal">top</code> object specifies the parent or the root widget. Once the button is instantiated, you will need to use the <code class="literal">pack()</code> method to make it available in the main window.</p><p>In the preceding lines of code, the <code class="literal">onStartButonPress()</code> function includes the scripts that are required to blink the LEDs and change the state of the button. A button state can have the state as <code class="literal">NORMAL</code>, <code class="literal">ACTIVE</code>, or <code class="literal">DISABLED</code>. If it is not specified, the default state of any button is <code class="literal">NORMAL</code>. The <code class="literal">ACTIVE</code> and <code class="literal">DISABLED</code> states are useful in applications when repeated pressing of the button needs to be avoided. After turning the LED on using the <code class="literal">write(1)</code> method, we will add a time delay of 5 seconds using the <code class="literal">sleep(5)</code> function before turning it off with the <code class="literal">write(0)</code> method:</p><div class="informalexample"><pre class="programlisting">def onStartButtonPress():
  startButton.config(state=Tkinter.DISABLED)
  ledPin.write(1)
  # LED is on for fix amount of time specified below
  sleep(5)
  ledPin.write(0)
  startButton.config(state=Tkinter.ACTIVE)</pre></div><p>At the end of the program, we will execute the <code class="literal">mainloop()</code> method to initiate the <code class="literal">Tkinter</code> loop. Until this function is executed, the main window won't appear.</p><p>To run the code, make appropriate changes to the Arduino <code class="literal">board</code> variable and execute the program. The following screenshot with a button and title bar will appear as the output of the program. Clicking on the <span class="strong"><strong>Start</strong></span> button will turn on the LED on the <a id="id503" class="indexterm"/>Arduino board for the specified time delay. Meanwhile, when the LED is on, you will not be able to click on the <span class="strong"><strong>Start</strong></span> button again. Now, in this particular program, we haven't provided sufficient code to safely disengage the Arduino board and it will be covered in upcoming exercises.</p><div class="mediaobject"><img src="graphics/5938OS_05_03.jpg" alt="The Button() widget – interfacing GUI with Arduino and LEDs"/></div></div>
<div class="section" title="The Entry() widget &#x2013; providing manual user inputs"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec34"/>The Entry() widget – providing manual user inputs</h1></div></div></div><p>In the previous exercise, you used a button to blink the LED on the Arduino board for a fixed <a id="id504" class="indexterm"/>amount of time. Let's say that you want to change this fixed time delay and specify a value <a id="id505" class="indexterm"/>according to your application's requirement. To perform this operation, you will need a widget that accepts custom values that can then be converted into the delay. Just like any other GUI framework, <code class="literal">Tkinter</code> provides the interface for a similar widget called <code class="literal">Entry()</code> and we will utilize this in the next exercise.</p><p>Keep the same Arduino and LED configurations that you used for the previous exercise and open the <code class="literal">exampleEntry.py</code> file. In the beginning of the code, you will find the same configuration for the Arduino board and the LED pin that we used in the previous exercise. Moving on to the next stage, you will be able to see the following code snippet that defines the root widget. In this code snippet, we have changed the title of the main window to reflect the premise of the exercise. The use of unique strings for the title of the window will help you to differentiate these windows according to their properties, when you are dealing with multiple windows in one application:</p><div class="informalexample"><pre class="programlisting">top = Tkinter.Tk()
top.title("Specify time using Entry")</pre></div><p>Although the <code class="literal">Entry()</code> widget can be easily initialized by specifying the parent widget as the only parameter, it also supports a large number of parameters to customize the widget. For example, in our exercise, we are using the <code class="literal">bd</code> parameter to specify the width of the widget border and <code class="literal">width</code> to provide the expected width of the widget. You can learn more about the available options at <a class="ulink" href="http://effbot.org/tkinterbook/entry.htm">http://effbot.org/tkinterbook/entry.htm</a>:</p><div class="informalexample"><pre class="programlisting">timePeriodEntry = Tkinter.Entry(top,
                                bd=5,
                                width=25)
timePeriodEntry.pack()
timePeriodEntry.focus_set()
startButton = Tkinter.Button(top,
                             text="Start",
                             command=onStartButtonPress)
startButton.pack()</pre></div><p>In the preceding lines of code, we have initialized two widget objects in our main window: <code class="literal">timePeriodEntry</code> for the <code class="literal">Entry()</code> widget and <code class="literal">startButton</code> that we used in the previous <a id="id506" class="indexterm"/>exercise for the <code class="literal">Button()</code> widget. The Pack geometry manager always sets the graphical pointer to the last widget that has been added to the main window. We can manually shift the focus of the graphical pointer to the <code class="literal">timePeriodEntry</code> widget using the <code class="literal">focus_set()</code> method.</p><p>Contrary to the <code class="literal">onStartButtonPress()</code> function in the previous exercise, this function doesn't use the time delay fix. It, instead, obtains the value from the <code class="literal">timePeriodEntry</code> object. You can use the <code class="literal">get()</code> method to obtain the entered value from the <code class="literal">timePeriodEntry</code> object and convert it into a floating value using the <code class="literal">float()</code> function. As you can see in the following code snippet, we use this float value as the time delay between switching the LED off from the on state:</p><div class="informalexample"><pre class="programlisting">def onStartButtonPress():
  # Value for delay is obtained from the Entry widget input
  timePeriod = timePeriodEntry.get()
  timePeriod = float(timePeriod)
  startButton.config(state=Tkinter.DISABLED)
  ledPin.write(1)
  sleep(timePeriod)
  ledPin.write(0)
  startButton.config(state=Tkinter.ACTIVE)</pre></div><p>Once you have understood the process of initializing the <code class="literal">Entry()</code> widget and the method to obtain a custom value from it, let's execute the code.</p><p>When you run this exercise, you should be able to see a window similar to the one displayed in the following screenshot. Enter a time delay value in seconds and click on <span class="strong"><strong>Start</strong></span> to see the results on the LED. Basically, when the button is pressed, the program will call the <code class="literal">onStartButtonPress()</code> function and it will utilize this value to produce the time delay.</p><div class="mediaobject"><img src="graphics/5938OS_05_04.jpg" alt="The Entry() widget – providing manual user inputs"/></div></div>
<div class="section" title="The Scale() widget &#x2013; adjusting the brightness of an LED"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"/>The Scale() widget – adjusting the brightness of an LED</h1></div></div></div><p>In this section, we will develop some code to change an LED's brightness using the Python GUI. Previously, we learned that you can use a digital pin of Arduino to produce an analog output using PWM. Although you can use the <code class="literal">Entry()</code> widget to provide one<a id="id507" class="indexterm"/> time value for the PWM signal, it will be useful to have a widget that can dynamically <a id="id508" class="indexterm"/>provide this value. As brightness can be fluctuated between 0 and 100 percent, it makes sense to use a slider that varies between 0 and 100. The <code class="literal">Tkinter</code> library provides this kind of sliding interface using the <code class="literal">Scale()</code> widget.</p><p>As we are working to change the brightness of the LED and supply analog input, we will be using a digital pin with the PWM support. In the previous exercise, we used digital pin 11, which already supports PWM. If you are using a custom version of the circuit different to the one provided earlier, we recommend that you change it to a pin that supports PWM. Now it is time to open the program file, <code class="literal">exampleScale.py</code>, for this exercise.</p><p>The first stage of the program that involves importing the necessary libraries and initializing the Arduino board using <code class="literal">pyFirmata</code> is almost the same as in the previous exercise. Change the string that is used to specify the appropriate value for the port variable according to the operating system and the port that you are using. We will also instantiate the root window with the unique title for this exercise, as we did in the previous exercises. This part of the program will often reoccur for a large number of exercises and you can refer to the previous exercise for more information.</p><p>In the next stage, we will continue building the code that we developed earlier to provide a manual time delay for the LED. We will also use the same <code class="literal">Entry()</code> widget to obtain the time interval as an input:</p><div class="informalexample"><pre class="programlisting">timePeriodEntry = Tkinter.Entry(top,
                                bd=5,
                                width=25)
timePeriodEntry.pack()
timePeriodEntry.focus_set()</pre></div><p>The <code class="literal">Scale()</code> widget offers a slider knob that can be moved over a fixed scale to provide a numeric value as an output. The starting and the ending values for this scale are provided using the <code class="literal">from_</code> and <code class="literal">to</code> options. The orientation of this slider can also be configured using the <code class="literal">orient</code> option, where the acceptable values for the orientation are <code class="literal">HORIZONTAL</code> and <code class="literal">VERTICAL</code>. However, you will have to import <code class="literal">HORIZONTAL</code> and <code class="literal">VERTICAL</code> constants from the <code class="literal">Tkinter</code> library before utilizing them here.</p><p>If no options are provided, the default widget uses the scale from 0 to 100 and the vertical orientation. In our program, we have used the horizontal orientation as a demonstration of the <code class="literal">orient</code> option. Once you have defined the widget object, <code class="literal">brightnessScale</code>, you will have to add it to the Pack geometry manager using <code class="literal">pack()</code>:</p><div class="informalexample"><pre class="programlisting">brightnessScale = Tkinter.Scale(top,
                                from_=0, to=100,
                                orient=Tkinter.HORIZONTAL)
brightnessScale.pack()</pre></div><p>In order to <a id="id509" class="indexterm"/>start the process and reuse the previous code, we have kept the instantiation of the <code class="literal">startButton</code> widget and the <code class="literal">onStartButtonPress</code> function as it is. However, the property of the function is changed to accommodate the <code class="literal">Scale()</code> widget:</p><div class="informalexample"><pre class="programlisting">startButton = Tkinter.Button(top,
                             text="Start",
                             command=onStartButtonPress)
startButton.pack()</pre></div><p>In this version of the <code class="literal">onStartButtonPress()</code> function, we will obtain the <code class="literal">ledBrightness</code> value by using the <code class="literal">get()</code> method on the <code class="literal">brightnessScale</code> widget object, where the <code class="literal">get()</code> method will return the value of the current location of the slider. As the PWM input requires values between 0 and 1, and the obtained slider value is between 0 and 100, we will convert the slider value into the appropriate PWM input by dividing it with 100. This new value will then be used with the <code class="literal">write()</code> method and this will ultimately turn on the LED with the applied brightness for the time period that is provided by the <code class="literal">timePeriodEntry</code> value:</p><div class="informalexample"><pre class="programlisting">def onStartButtonPress():
  timePeriod = timePeriodEntry.get()
  timePeriod = float(timePeriod)
  ledBrightness = brightnessScale.get()
  ledBrightness = float(ledBrightness)
  startButton.config(state=Tkinter.DISABLED)
  ledPin.write(ledBrightness/100.0)
  sleep(timePeriod)
  ledPin.write(0)
  startButton.config(state=Tkinter.ACTIVE)</pre></div><p>For information about the <code class="literal">Scale()</code> widget, you can refer to <a class="ulink" href="http://effbot.org/tkinterbook/scale.htm">http://effbot.org/tkinterbook/scale.htm</a>. Now, run the <code class="literal">exampleScale.py</code> file. You will be able to see the following screenshot with the <code class="literal">Entry()</code> and <code class="literal">Scale()</code> widgets. Enter the time delay, drag the slider to the brightness that you want, and then click on the <span class="strong"><strong>Start</strong></span> button:</p><div class="mediaobject"><img src="graphics/5938OS_05_05.jpg" alt="The Scale() widget – adjusting the brightness of an LED"/></div><p>You will be<a id="id510" class="indexterm"/> able to see the LED light up with the brightness set by the <code class="literal">Scale()</code> widget. Once the LED is turned off after the given time delay, you can reset the slider to another position to dynamically vary the value for the brightness.</p></div>
<div class="section" title="The Grid geometry manager"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec36"/>The Grid geometry manager</h1></div></div></div><p>In the previous exercise, we added three different widgets to the root window using the <span class="strong"><strong>Pack</strong></span> geometry manager and the <code class="literal">pack()</code> method. We didn't actively organize these widgets<a id="id511" class="indexterm"/> but the <a id="id512" class="indexterm"/>Pack manager automatically arranged them in the vertical position. While designing a meaningful interface, you need to arrange these widgets in the appropriate order. If you look at the previous output window, it is really difficult to identify the function of each widget or their association with others. In order to design an intuitive GUI, you also need to describe these widgets using the appropriate labels. As a solution, <code class="literal">Tkinter</code> provides an alternative way to organize your widgets that is called <span class="strong"><strong>Grid geometry manager</strong></span>.</p><p>The Grid geometry manager provides a <span class="strong"><strong>two-dimensional</strong></span> (<span class="strong"><strong>2D</strong></span>) table interface to arrange widgets. Every cell that results from the row and column of the 2D table can be used as a place for the widgets. You will learn the various options that are provided by the <code class="literal">grid()</code> class to organize widgets in the next programming exercise. Open the <code class="literal">exampleGridManager.py</code> file from the code folder of this chapter. In terms of functionalities, this file contains the same program that we built in the previous exercise. However, we have added more <code class="literal">Label()</code> widgets and organized them using the Grid geometry manager to simplify the GUI and make it more useful.</p><p>As you can observe in the code, the <code class="literal">timePeriodEntry</code> object (an <code class="literal">Entry()</code> widget) now uses the <code class="literal">grid()</code> method instead of the <code class="literal">pack()</code> method. The <code class="literal">grid()</code> method is initialized with the column and row options. The values supplied for these options determine the position of the cell where the <code class="literal">timePeriodEntry</code> object will be placed. </p><p>On the other hand, we have also created a label object using the <code class="literal">Label()</code> widget and placed it beside the <code class="literal">Entry()</code> widget in the same row. The label contains a description string that is <a id="id513" class="indexterm"/>specified using the <code class="literal">text</code> option. After placing it in a cell using the <code class="literal">grid()</code> method, widgets are arranged in the center in that cell. To change this alignment, you can <a id="id514" class="indexterm"/>use the <code class="literal">sticky</code> option with one or more values from <code class="literal">N</code>, <code class="literal">E</code>, <code class="literal">S</code>, and <code class="literal">W</code>, that is, north, east, south, and west:</p><div class="informalexample"><pre class="programlisting">timePeriodEntry = Tkinter.Entry(top, bd=5)
timePeriodEntry.grid(column=1, row=1)
timePeriodEntry.focus_set()
Tkinter.Label(top, text="Time (seconds)").grid(column=2, row=1)</pre></div><p>We have repeated this practice of placing the widget in a cell and describing it using a <code class="literal">Label()</code> widget for the objects of the <code class="literal">Scale()</code> and <code class="literal">Button()</code> widgets as well:</p><div class="informalexample"><pre class="programlisting">brightnessScale = Tkinter.Scale(top, from_=0, to=100, orient=Tkinter.HORIZONTAL)
brightnessScale.grid(column=1, row=2)
Tkinter.Label(top, text="Brightness (%)").grid(column=2, row=2)

startButton = Tkinter.Button(top, text="Start", command=onStartButtonPress)
startButton.grid(column=1, row=3)</pre></div><p>As you can see in the preceding code snippet, we are using different row values for the widgets while having similar column values. As a result, our widgets will be organized in the same column and they will have their description labels in the next column of the same row. You can skip to the output window if you want to check this organization pattern.</p><p>So far, we were relying on the user to manually close the main window. However, you can create another <code class="literal">Button()</code> widget and through that, call the method to close this window. In this coding exercise, we have an additional button compared to the previous exercise that is called <code class="literal">exitButton</code>. The <code class="literal">command</code> parameter associated with this button is <code class="literal">quit</code>, which ends the loop started by the <code class="literal">Tkinter</code> method <code class="literal">top.mainloop()</code> and closes the GUI:</p><div class="informalexample"><pre class="programlisting">exitButton = Tkinter.Button(top,
                            text="Exit",
                            command=top.quit)
exitButton.grid(column=2, row=3)</pre></div><p>In this code sample, the <code class="literal">quit</code> method is initialized as a <code class="literal">command</code> option and it can be also be called as a method:</p><div class="informalexample"><pre class="programlisting">top.quit()</pre></div><p>Before we go ahead to the next step, perform the appropriate changes in the code and run the program. You will be prompted with a window similar to the one displayed in the<a id="id515" class="indexterm"/> following screenshot:</p><div class="mediaobject"><img src="graphics/5938OS_05_06.jpg" alt="The Grid geometry manager"/></div><p>The red dotted lines <a id="id516" class="indexterm"/>are inserted later to help you identify the grid and they won't appear in the window that is opened by running the program. You can now clearly identify the role of each widget due to the presence of the description label beside them. In the opened window, play around with the time and brightness values while using the <span class="strong"><strong>Start</strong></span> and <span class="strong"><strong>Exit</strong></span> buttons to perform the associated actions. From the next exercise, we will start using the <code class="literal">grid()</code> method regularly to arrange the widgets.</p></div>
<div class="section" title="The Checkbutton() widget &#x2013; selecting LEDs"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>The Checkbutton() widget – selecting LEDs</h1></div></div></div><p>While developing complex projects, you will encounter scenarios where you have to depend on the user to select single or multiple options from a given set of values. For example, when you have multiple numbers of LEDs interfaced with the Arduino board and you <a id="id517" class="indexterm"/>want the user to select an LED or LEDs that need to be turned on. This level of customization <a id="id518" class="indexterm"/>makes your interface more interactive and useful. The <code class="literal">Tkinter</code> library provides an interface for a standard widget called <code class="literal">Checkbutton()</code> that enables the manual selection process from the given options.</p><p>In this exercise, we are going to work with both the LEDs, green and red, that you connected to the Arduino board at the beginning. The entire Python program for this exercise is located in the code folder with the name <code class="literal">exampleCheckbutton.py</code>. Open the file with the same editor that you have been using all along. This program implements the <code class="literal">Checkbutton()</code> widget for users to select the red and/or green LED when the <span class="strong"><strong>Start</strong></span> button is clicked.</p><p>To understand the entire program logic, let's start from the initialization and importing of the libraries. As you can see, now we have two pin assignments for digital pins 10 and 11 as <code class="literal">redPin</code> and <code class="literal">greenPin</code> respectively. The code for the initialization of the Arduino board is unchanged:</p><div class="informalexample"><pre class="programlisting">port = '/dev/cu.usbmodemfa1331'
board = pyfirmata.Arduino(port)
sleep(5)
redPin = board.get_pin('d:10:o')
greenPin = board.get_pin('d:11:o')</pre></div><p>In our utilization of the <code class="literal">Checkbutton()</code> widget, we are using a very useful <code class="literal">Tkinter</code> variable class that is called <code class="literal">IntVar()</code>.The <code class="literal">Tkinter</code> variable can tell the system when the value of the <a id="id519" class="indexterm"/>variable is changed. To better understand the <code class="literal">Tkinter</code> variable class and its specific utilization in our exercise, take a look at the following code snippet from the program:</p><div class="informalexample"><pre class="programlisting">redVar = Tkinter.IntVar()
redCheckBox = Tkinter.Checkbutton(top,
                                  text="Red LED",
                                  variable=redVar)
redCheckBox.grid(column=1, row=1)</pre></div><p>The <code class="literal">Checkbutton()</code> widget lets a user select between two different values. These values are usually <code class="literal">1</code> (on) or <code class="literal">0</code> (off), making the <code class="literal">Checkbutton()</code> widget a switch. To capture this selection, the <code class="literal">variable</code> option is required in the widget definition. A variable can be initialized using one of the <code class="literal">Tkinter</code> variable class, <code class="literal">IntVar()</code>.</p><p>As you can see, the <code class="literal">redVar</code> variable object that is instantiated using the <code class="literal">IntVar()</code> class is used for the <code class="literal">variable</code> option while defining the <code class="literal">Checkbutton()</code> widget, <code class="literal">redCheckButton</code>. Therefore, any operation on the <code class="literal">redCheckButton</code> object will be translated to the <code class="literal">redVar</code> variable object. As <code class="literal">IntVar()</code> is a <code class="literal">Tkinter</code> class, it automatically takes care of any changes in the variable values through the <code class="literal">Checkbutton()</code> widget. Therefore, it is advisable to use the <code class="literal">Tkinter</code> variable class for the <code class="literal">Checkbutton()</code> widget instead of the default Python variables. After defining the <code class="literal">Checkbutton()</code> widget for the red LED, we have repeated this process for the green LED, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">greenVar = Tkinter.IntVar()
greenCheckBox = Tkinter.Checkbutton(top,
                                    text="Green LED",
                                    variable=greenVar)
greenCheckBox.grid(column=2, row=1)</pre></div><p>This program also contains the <span class="strong"><strong>Start</strong></span> and <span class="strong"><strong>Exit</strong></span> buttons and their respective association with the <code class="literal">onStartButtonPress</code> and <code class="literal">top.quit()</code> functions, similar to how we used them in the previous exercise. When called, the <code class="literal">onStartButtonPress</code> function will obtain the values of the <code class="literal">IntVar()</code> variables, <code class="literal">redVar</code> and <code class="literal">greenVar</code>, using the <code class="literal">get()</code> method. In this case, the variable value of the <code class="literal">Checkbutton()</code> widget will be <code class="literal">1</code> when it is checked and <code class="literal">0</code> otherwise. This will enable the program to send the value <code class="literal">1</code> or <code class="literal">0</code> to the Arduino pin using the <code class="literal">write()</code> method by checking or unchecking the widget and ultimately, turn the LED on or off:</p><div class="informalexample"><pre class="programlisting">def onStartButtonPress():
  redPin.write(redVar.get())
  greenPin.write(greenVar.get())</pre></div><p>As you can see, the code also implements an additional <span class="strong"><strong>Stop</strong></span> button to turn off the LEDs that were <a id="id520" class="indexterm"/>turned on using the <span class="strong"><strong>Start</strong></span> button:</p><div class="informalexample"><pre class="programlisting">stopButton = Tkinter.Button(top,
                            text="Stop",
                            command=onStopButtonPress)
stopButton.grid(column=2, row=2)</pre></div><p>The <code class="literal">onStopButtonPrerss()</code> function associated with this button turns off both the LEDs by using <code class="literal">write(0)</code> on both the pins:</p><div class="informalexample"><pre class="programlisting">def onStopButtonPress():
  redPin.write(0)
  greenPin.write(0)</pre></div><p>Since you have now learned about the <code class="literal">Tkinter</code> variables and the <code class="literal">Checkbutton()</code> widget, let's run the Python program, <code class="literal">exampleCheckbutton.py</code>. As you can see in the next screenshot, the GUI has two <code class="literal">Checkbutton()</code> widgets each for the red and green LEDs. As there is a separate initialization of the <code class="literal">Checkbutton()</code> widgets, a user can <a id="id521" class="indexterm"/>check both the red and green LEDs. <code class="literal">Tkinter</code> also provides similar widgets such as <code class="literal">Radiobutton()</code> and <code class="literal">Listbox()</code> for cases where you want to select only a single value from the given options.</p><div class="mediaobject"><img src="graphics/5938OS_05_07.jpg" alt="The Checkbutton() widget – selecting LEDs"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>You can learn <a id="id522" class="indexterm"/>more about the <code class="literal">Radiobutton()</code> and <code class="literal">Listbox()</code> widgets<a id="id523" class="indexterm"/> from the <a id="id524" class="indexterm"/>following web pages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://effbot.org/tkinterbook/radiobutton.htm">http://effbot.org/tkinterbook/radiobutton.htm</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://effbot.org/tkinterbook/listbox.htm">http://effbot.org/tkinterbook/listbox.htm</a></li></ul></div></div></div></div>
<div class="section" title="The Label() widget &#x2013; monitoring I/O pins"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>The Label() widget – monitoring I/O pins</h1></div></div></div><p>Arduino projects often deal with real-time systems and are required to continuously monitor<a id="id525" class="indexterm"/> input values<a id="id526" class="indexterm"/> from digital and analog pins. Therefore, if these values are being displayed on a graphical interface, they need to be updated periodically or when the state of a pin changes.</p><p>If you observe the previous GUI exercises, you will notice that we initialized the root window using <code class="literal">mainloop()</code> at the end of the code, which started the <code class="literal">Tkinter</code> loop and initialized all the widgets with the updated values. Once the <code class="literal">mainloop()</code> was initialized, we did not use any other <code class="literal">Tkinter</code> class or method to periodically update the widgets with the latest values.</p><p>In this exercise, we <a id="id527" class="indexterm"/>will use a potentiometer to provide variable input to the analog pin 0, which will be reflected by Tkinter's <code class="literal">Label()</code> widget. To update the label and display the values of the analog input, we are going to implement a few Python and <code class="literal">Tkinter</code> tricks. As we are using a potentiometer to provide input, you will need to change the circuit as displayed in the following diagram, before jumping to the Python program:</p><div class="mediaobject"><img src="graphics/5938OS_05_11.jpg" alt="The Label() widget – monitoring I/O pins"/></div><p>The Python file for this exercise is located in the code folder as the <code class="literal">workingWithLabels.py</code> file. For this exercise, let's run the code first to understand the premise of the exercise. Make sure that you have the appropriate string for the Arduino board when you define the <code class="literal">port</code> variable. On successful execution, the program will display the following screenshot and you can click on the <span class="strong"><strong>Start</strong></span> button to initiate the continuous update of the potentiometer's input value:</p><div class="mediaobject"><img src="graphics/5938OS_05_08.jpg" alt="The Label() widget – monitoring I/O pins"/></div><p>So, how did we do this? This code contains complex logic and a different program flow compared to what we have done so far. As you can see from the code, we are using a <a id="id528" class="indexterm"/>variable called <code class="literal">flag</code> to track the state of the <span class="strong"><strong>Exit</strong></span> button while continuously running the <code class="literal">while</code> loop that monitors and updates the value. To understand the program properly, let's first get familiar with the following new <code class="literal">Tkinter</code> classes and methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">BooleanVar()</code>: Just <a id="id529" class="indexterm"/>like the <code class="literal">IntVar()</code> variable class that we used to track the integer <a id="id530" class="indexterm"/>values, <code class="literal">BooleanVar()</code> is a <code class="literal">Tkinter</code> variable class that tracks changes in Boolean:<div class="informalexample"><pre class="programlisting">flag = Tkinter.BooleanVar(top)
flag.set(True)</pre></div><p>In the preceding code snippet, we have created a variable object, <code class="literal">flag</code>, using the <code class="literal">BooleanVar()</code> class and set the value of the object as <code class="literal">True</code>. Being a Boolean object, <code class="literal">flag</code> can only have two values, <code class="literal">True</code> or <code class="literal">False</code>. <code class="literal">Tkinter</code> also provides classes for string and double type with the <code class="literal">StringVar()</code> and <code class="literal">DoubleVar()</code> classes respectively.</p><p>Due to this, when the <span class="strong"><strong>Start</strong></span> button is clicked, the system starts updating the analog read value. The <span class="strong"><strong>Exit</strong></span> button sets the <code class="literal">flag</code> variable to <code class="literal">false</code>, breaks the <code class="literal">while</code> loop, and stops the monitoring process.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">update_idletasks</code>: While using the <code class="literal">Tkinter</code> library in Python, you can link a Python code to any changes that happen in a <code class="literal">Tk()</code> widget. This linked Python code is <a id="id531" class="indexterm"/>called a <a id="id532" class="indexterm"/><span class="strong"><strong>callback</strong></span>. The <code class="literal">update_idletasks</code> method calls all idle tasks without processing any callbacks. This method also redraws the geometry widgets, if required:<div class="informalexample"><pre class="programlisting">AnalogReadLabel.update_idletasks()</pre></div><p>In our exercise, this method can be used to continuously update the label with the latest potentiometer value.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">update</code>: This top-level method processes all the pending events and callbacks and also redraws<a id="id533" class="indexterm"/> any widget, if it is necessary:<div class="informalexample"><pre class="programlisting">top.update()</pre></div><p>We are using this method with the root window so that it can perform the callback for the <span class="strong"><strong>Start</strong></span> button.</p></li></ul></div><p>Now let's go back to the opened Python program. As you can see, besides assigning an analog pin through the <code class="literal">get_pin()</code> method and initializing the <code class="literal">Iterator()</code> class over the Arduino board, the code contains similar programming patterns that we used in the exercises for the other <code class="literal">Tkinter</code> widgets. In this code, we are performing the read operation for the analog pin inside the <code class="literal">onStartButtonPress()</code> function This function <a id="id534" class="indexterm"/>checks the status of the <code class="literal">flag</code> variable while performing the <code class="literal">read()</code> operation on the pin and subsequently updates the value of the <code class="literal">analogReadLabel()</code> widget if the value of the <code class="literal">flag</code> variable is <code class="literal">True</code>. If the value of the <code class="literal">flag</code> variable is found to be <code class="literal">False</code>, the function will exit after disengaging the Arduino board and closing the root window. Due to the use of the <code class="literal">while</code> statement, this process will continuously check the <code class="literal">flag</code> value until it is broken by the <code class="literal">onExitButtonPress()</code> function by changing the <code class="literal">flag</code> value to <code class="literal">False</code>:</p><div class="informalexample"><pre class="programlisting">def onStartButtonPress():
  while True:
    if flag.get():
      analogReadLabel.config(text=str(a0.read()))
      analogReadLabel.update_idletasks()
      top.update()
    else:
      break
  board.exit()
  top.destroy()</pre></div><p>The <code class="literal">onExitButtonPress()</code> function is called from the <span class="strong"><strong>Exit</strong></span> button and it simply resets the <code class="literal">flag</code> variable to <code class="literal">False</code> using the <code class="literal">set()</code> method:</p><div class="informalexample"><pre class="programlisting">def onExitButtonPress():
  flag.set(False)</pre></div></div>
<div class="section" title="Remaking your first Python-Arduino project with a GUI"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Remaking your first Python-Arduino project with a GUI</h1></div></div></div><p>Just to refresh your memory, I would like to remind you that we created a motion detection system<a id="id535" class="indexterm"/> that generated alerts by blinking the red LED when a motion was detected. While working with the project, we were printing the state of the proximity sensor onto the Python prompt. In this exercise, we are going to use the concepts that you learned in the previous exercises and we will create an interface for our project.</p><p>As part of this exercise, you have to connect the same circuit that we used in <a class="link" href="ch03.html" title="Chapter 3. The First Project – Motion-triggered LEDs">Chapter 3</a>, <span class="emphasis"><em>The First Project – Motion-triggered LEDs</em></span>. Make sure you have the exact same circuit with the PIR sensor and the LEDs before you move ahead. Once you are ready with your hardware, open the <code class="literal">firstProjectWithGUI.py</code> file from the code folder of this chapter. In the code, change the appropriate port values and run the GUI for the project.</p><p>As you can see in the pin assignments, we now have three digital pins—two of them as outputs <a id="id536" class="indexterm"/>and one as an input. The output pins are assigned to the red and green LEDs while the input pin is assigned to the PIR motion sensor. If the PIR sensor is in idle mode, we will perform a onetime <code class="literal">read()</code> operation to wake up the sensor:</p><div class="informalexample"><pre class="programlisting">pirPin = board.get_pin('d:8:i')
redPin = board.get_pin('d:10:o')
greenPin = board.get_pin('d:11:o')
pirPin.read()</pre></div><p>One of the important functions that is implemented by the code is <code class="literal">blinkLED()</code>. This function updates the <code class="literal">Label()</code> widget that is assigned to describe the status of the motion sensor. It also blinks the physical LEDs using the <code class="literal">write()</code> method and the inserted time delay. As input parameters, the <code class="literal">blinkLED()</code> function accepts the pin object and a message string from the function call, where the pin objects, that is, <code class="literal">redPin</code> or <code class="literal">greenPin</code>, should be one of the pin assignment for the LEDs:</p><div class="informalexample"><pre class="programlisting">def blinkLED(pin, message):
  MotionLabel.config(text=message)
  MotionLabel.update_idletasks()
  top.update()
  pin.write(1)
  sleep(1)
  pin.write(0)
  sleep(1)</pre></div><p>The other two <code class="literal">Tkinter</code> related functions, <code class="literal">onStartButtonPress()</code> and <code class="literal">onExitButtonPress()</code>, are basically derived from the previous exercise. In this version of <code class="literal">onStartButtonPress()</code>, we call the <code class="literal">blinkLED()</code> function if the <code class="literal">flag</code> variable is <code class="literal">True</code> and the motion is detected using <code class="literal">pinPir.read()</code>:</p><div class="informalexample"><pre class="programlisting">def onStartButtonPress():
  while True:
    if flag.get():
      if pirPin.read() is True:
        blinkLED(redPin, "Motion Detected")
      else:
        blinkLED(greenPin, "No motion Detected")
    else:
      break
  board.exit()
  top.destroy()</pre></div><p>The program <a id="id537" class="indexterm"/>also instantiates two buttons, <span class="strong"><strong>Start</strong></span> and <span class="strong"><strong>Exit</strong></span>, and one label using the methods similar to those we used in the previous exercises.</p><p>As you can observe from the code, the logic behind the motion detection system is still the same. We are only adding a layer of graphical interface to display the state of the detected motion continuously using a <code class="literal">Label()</code> widget. We have also added the <span class="strong"><strong>Start</strong></span> and <span class="strong"><strong>Exit</strong></span> buttons to control the project execution cycle. Once you run the code, you will be able to see a window similar to the one displayed in the following screenshot. Click on the <span class="strong"><strong>Start</strong></span> button and wave in front of the motion sensor. If the sensor detects the motion, the label will change from <span class="strong"><strong>No motion detected</strong></span> to <span class="strong"><strong>Motion detected</strong></span>.</p><div class="mediaobject"><img src="graphics/5938OS_05_09.jpg" alt="Remaking your first Python-Arduino project with a GUI"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Summary</h1></div></div></div><p>Now you have hands-on experience of building a basic GUI to handle Arduino projects. With minor modifications to the included exercises, you can use them to create a GUI for a large variety of Arduino prototyping projects. In the previous two exercises, we displayed the sensor outputs as strings in label widgets. It will be more meaningful if these numerical values are plotted as a graph and stored for further analysis. This is what you are going to perform in the next chapter.</p></div></body></html>