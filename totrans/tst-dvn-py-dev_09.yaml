- en: Chapter 9. Unit Testing Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 单元测试模式
- en: Throughout this book, we have looked at various patterns and anti-patterns in
    TDD. In this chapter, you are going to take a look at some additional patterns
    that we haven't discussed before in this book. In the process of doing so, you
    will also take a look at some more advanced features provided by the Python `unittest`
    module, such as test loaders, test runners, and skipping tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们探讨了TDD中的各种模式和反模式。在本章中，你将了解一些本书之前未讨论过的额外模式。在这个过程中，你还将了解Python `unittest`模块提供的更多高级功能，例如测试加载器、测试运行器和跳过测试。
- en: Pattern – fast tests
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式 - 快速测试
- en: One of the key goals of TDD is to write tests that execute quickly. We will
    be running the tests often when doing TDD— possibly even every few minutes. The
    TDD habit is to run the tests multiple times when developing code, refactoring,
    before checkins, and before deployments. If tests run any longer, we will be reluctant
    to run them often, which defeats the purpose of the tests.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的一个关键目标是编写执行快速的测试。在进行TDD时，我们会频繁地运行测试——可能每隔几分钟就会运行一次。TDD的习惯是在开发代码、重构、提交前和部署前多次运行测试。如果测试运行时间过长，我们就不愿意频繁运行它们，这样就违背了测试的目的。
- en: 'With that in mind, some techniques for keeping tests fast are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，以下是一些保持测试快速运行的技术：
- en: '**Disable unwanted external services**: Some services are not central to the
    purpose of the application and can be disabled. For instance, perhaps we use a
    service to collect analytics on how users use our application. Our application
    might be making a call to this service on every action. Such services can be disabled,
    enabling tests to run faster.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁用不需要的外部服务**：有些服务并非应用目的的核心，可以被禁用。例如，我们可能使用一个服务来收集用户如何使用我们应用的分析数据。我们的应用可能在每次操作时都会调用这个服务。这样的服务可以被禁用，从而使得测试运行得更快。'
- en: '**Mock out external services**: Other external services such as servers, databases,
    caches, and so on might be central to the functioning of the application. External
    services take time to start up, shut down, and communicate with. We want to mock
    these out and have our tests run against the mock.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟外部服务**：其他外部服务，如服务器、数据库、缓存等，可能对应用的功能至关重要。外部服务需要时间来启动、关闭和通信。我们想要模拟这些服务，并让我们的测试在模拟服务上运行。'
- en: '**Use fast variants of services**: If we must use a service, then make sure
    it is fast. For example, replace a database with an in-memory database, which
    is much faster and takes little time to start and shut down. Similarly, we can
    replace a call to an e-mail server with a fake in-memory e-mail server that just
    records the e-mails to be sent, without actually sending the e-mail.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用服务的快速变体**：如果我们必须使用服务，那么请确保它是快速的。例如，用一个内存数据库替换数据库，它更快，启动和关闭所需时间更少。同样，我们可以用一个记录要发送的电子邮件的内存电子邮件服务器替换对电子邮件服务器的调用，而不实际发送电子邮件。'
- en: '**Externalize configuration**: What does configuration have to do with unit
    testing? Simple: if we need to enable or disable services, or replace services
    with fake services, then we need to have different configurations for the regular
    application and for when running unit tests. This requires us to design the application
    in a way that allows us to easily switch between multiple configurations.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部化配置**：配置与单元测试有什么关系？简单来说：如果我们需要启用或禁用服务，或者用模拟服务替换服务，那么我们需要为常规应用和运行单元测试时设计不同的配置。这要求我们以允许我们轻松地在多个配置之间切换的方式设计应用。'
- en: '**Run tests for the current module only**: Both the `unittest` test runner
    and third-party runners allow us to run a subset of tests—tests for a specific
    module, class, or even a single test. This is a great feature for large tests
    suites with thousands of tests, as it allows us to run just the tests for the
    module we are working on.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅运行当前模块的测试**：`unittest`测试运行器和第三方运行器都允许我们运行测试子集——特定模块、类或单个测试的测试。这对于拥有数千个测试的大型测试套件来说是一个很好的功能，因为它允许我们只运行正在工作的模块的测试。'
- en: Pattern – running a subset of tests
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式 - 运行测试子集
- en: 'We already saw a simple way of running a subset of tests by simply specifying
    the module or test class on the command line, as shown in the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一种简单的方法来运行测试子集，只需在命令行上指定模块或测试类，如下所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This works for the common case of when we want to run a subset based on the
    module. What if we want to run tests based on some other parameter? Maybe we want
    to run a set of basic smoke tests, or we want to run only integration tests, or
    we want to skip tests when running on a specific platform or Python version.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于我们想要基于模块运行子集的常见情况。如果我们想根据其他参数运行测试怎么办？也许我们想运行一组基本烟雾测试，或者我们只想运行集成测试，或者我们想在特定平台或
    Python 版本上运行时跳过测试。
- en: The `unittest` module allows us to create test suites. A **test suite** is a
    collection of test classes that are run. By default, `unittest` performs an autodiscovery
    for tests and internally creates a test suite with all the tests that match the
    discovery pattern. However, we can also manually create different test suites
    and run them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest` 模块允许我们创建测试套件。**测试套件**是一组要运行的测试类。默认情况下，`unittest` 会自动发现测试并在内部创建一个包含所有匹配发现模式的测试的测试套件。然而，我们也可以手动创建不同的测试套件并运行它们。'
- en: 'Test suites are created using the `unittest.TestSuite` class. The `TestSuite`
    class has the following two methods of interest:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件是通过使用 `unittest.TestSuite` 类创建的。`TestSuite` 类有以下两个感兴趣的方法：
- en: '`addTest`: This method takes a `TestCase` or another `TestSuite` and adds it
    to the suite'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addTest`: 此方法接受一个 `TestCase` 或另一个 `TestSuite` 并将其添加到套件中'
- en: '`addTests`: Similar to `addTest`, this method takes a list of `TestCase` or
    `TestSuite` and adds it to the suite'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addTests`: 与 `addTest` 类似，此方法接受一个 `TestCase` 或 `TestSuite` 列表并将其添加到套件中'
- en: So, how do we use this function?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使用这个函数呢？
- en: 'First, we write a function that makes the suite and returns it, as shown in
    the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们编写一个函数来创建套件并返回它，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can choose the specific tests that we want in the suite. We've added a single
    test to the suite over here.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择套件中想要的特定测试。我们在这里向套件中添加了一个单个测试。
- en: 'Next, we need to write a script to run this suite, as shown in the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写一个脚本来运行此套件，如下所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we create a `TextTestRunner` that will run the tests and pass it the suite
    or tests. `unittest.TextTestRunner` is a test runner that accepts a suite of tests
    and runs the suite, showing the results of the test, run on the console.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个 `TextTestRunner`，它将运行测试并将套件或测试传递给它。`unittest.TextTestRunner` 是一个测试运行器，它接受一个测试套件并运行它，在控制台上显示测试的运行结果。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`unittest.TextTestRunner` is the default test runner that we have been using
    so far. It is possible to write our own test runners. For example, we might write
    a custom test runner to implement a GUI interface, or one that writes test output
    into an XML file.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.TextTestRunner` 是我们迄今为止一直在使用的默认测试运行器。我们可以编写自己的测试运行器。例如，我们可能会编写一个自定义测试运行器来实现
    GUI 接口，或者一个将测试输出写入 XML 文件的测试运行器。'
- en: 'When we run this script, we get the following output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此脚本时，我们得到以下输出：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Similarly, we can create different suites for different subsets of tests—for
    example, a separate suite containing just integration tests—and run only specific
    suites as per our needs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以为不同的测试子集创建不同的套件——例如，一个只包含集成测试的单独套件——并根据我们的需求只运行特定的套件。
- en: Test loaders
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试加载器
- en: 'One of the problems with the suite function is that we have to add each test
    individually into the suite. This is a cumbersome process if we have a lot of
    tests. Fortunately, we can simplify the process by using a `unittest.TestLoader`
    object to load a bunch of tests for us, as shown in the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 套件函数的一个问题是，我们必须将每个测试单独添加到套件中。如果我们有很多测试，这是一个繁琐的过程。幸运的是，我们可以通过使用 `unittest.TestLoader`
    对象来简化这个过程，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the loader extracts all the tests from the `StockCrossOverSignalTest`
    class and creates a suite out of it. We can return the suite directly if that
    is all we want, or we can create a new suite with additional tests. In the example
    above, we create a suite containing a single test from the `StockTest` class and
    all the tests from the `StockCrossOverSignalTest` class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，加载器从 `StockCrossOverSignalTest` 类中提取所有测试并创建一个套件。如果我们只想返回套件，我们可以直接返回套件，或者我们可以创建一个新的套件并添加额外的测试。在上面的例子中，我们创建了一个包含
    `StockTest` 类中的一个测试和 `StockCrossOverSignalTest` 类中所有测试的套件。
- en: '`unittest.TestLoader` also contains some other methods for loading tests:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.TestLoader` 还包含一些其他用于加载测试的方法：'
- en: '`loadTestsFromModule`: This method takes a module and returns a suite of all
    the tests in that module.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadTestsFromModule`: 此方法接受一个模块并返回该模块中所有测试的测试套件。'
- en: '`loadTestsFromName`: This method takes a string reference to a module, class,
    or function and extracts the tests from there. If it is a function, the function
    is called and the test suite returned by the function is returned. The string
    reference is in dotted format, meaning we can pass in something like `stock_alerter.tests.test_stock`
    or `stock_alerter.tests.test_stock.StockTest`, or even `stock_alerter.tests.test_stock.suite`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadTestsFromName`：此方法接受一个指向模块、类或函数的字符串引用，并从中提取测试。如果是一个函数，则调用该函数，并返回函数返回的测试套件。字符串引用采用点格式，这意味着我们可以传递类似`stock_alerter.tests.test_stock`或`stock_alerter.tests.test_stock.StockTest`，甚至`stock_alerter.tests.test_stock.suite`的内容。'
- en: '`discover`: This method executes the default autodiscovery process and returns
    the collected tests as a suite. The method takes three parameters: the start directory,
    the pattern to find `test` module (default `test*.py`), and the top-level directory.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`discover`：此方法执行默认的自动发现过程，并将收集到的测试作为套件返回。该方法接受三个参数：起始目录、查找`test`模块的模式（默认`test*.py`）和顶级目录。'
- en: Using these methods, we can create test suites with just the tests that we want.
    We can create different suites for different purposes and execute them from the
    test script.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法，我们可以仅创建我们想要的测试套件。我们可以为不同的目的创建不同的套件，并从测试脚本中执行它们。
- en: Using the load_tests protocol
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用load_tests协议
- en: A simpler way to create test suites is with the `load_tests` function. As we
    saw in [Chapter 7](ch07.html "Chapter 7. Executable Documentation with doctest"),
    *Executable Documentation with doctest*, the `unittest` framework calls the `load_tests`
    function if it is present in the test module. The function should return a `TestSuite`
    object containing the tests to be run. `load_tests` is a better solution when
    we want to just slightly modify the default autodiscovery process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 创建测试套件的一个更简单的方法是使用`load_tests`函数。正如我们在[第7章](ch07.html "第7章。使用doctest的可执行文档")中看到的，“使用doctest的可执行文档”，如果测试模块中存在`load_tests`函数，`unittest`框架会调用该函数。该函数应返回一个包含要运行的测试的`TestSuite`对象。当我们只想稍微修改默认的自动发现过程时，`load_tests`是一个更好的解决方案。
- en: '`load_tests` passes three parameters: the loader being used to load the tests,
    a suite of tests that are going to be loaded by default, and the test pattern
    that has been specified for the search.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_tests`传递三个参数：用于加载测试的加载器、默认将要加载的测试套件以及为搜索指定的测试模式。'
- en: 'Suppose we do not want to run the `StockCrossOverSignalTest` tests if the current
    platform is Windows. We can write a `load_tests` function like the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不想在当前平台是Windows时运行`StockCrossOverSignalTest`测试。我们可以编写一个如下所示的`load_tests`函数：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now the `StockCrossOverSignalTest` tests will be run only on non-windows platforms.
    When using the `load_tests` method, we don't need to write a separate script to
    run tests or create a test runner. It hooks into the autodiscovery process and
    is therefore much simpler to use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`StockCrossOverSignalTest`测试将仅在非Windows平台上运行。当使用`load_tests`方法时，我们不需要编写单独的脚本来运行测试或创建测试运行器。它挂钩到自动发现过程，因此使用起来更简单。
- en: Skipping tests
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳过测试
- en: 'In the previous section, we used the `load_tests` mechanism to skip some tests
    if the platform was Windows. The `unittest` module gives a simpler way to do the
    same using the `skip` decorator. Simply decorate a class or method with the decorator
    and the test will be skipped, as shown in the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用`load_tests`机制在平台是Windows时跳过一些测试。`unittest`模块提供了一个更简单的使用`skip`装饰器来完成相同任务的方法。只需用装饰器装饰一个类或方法，测试就会跳过，如下所示：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The decorator takes a parameter where we specify the reason that the test is
    being skipped. When we run all the tests, we get an output like the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器接受一个参数，我们可以在其中指定跳过测试的原因。当我们运行所有测试时，我们会得到如下所示的输出：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And when the tests are run in verbose mode, we get an output like the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当以详细模式运行测试时，我们会得到如下所示的输出：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `skip` decorator skips a test unconditionally, but `unittest` provides two
    more decorators, `skipIf` and `skipUnless`, which allow us to specify a condition
    to skip the tests. These decorators take a `Boolean` value as the first parameter
    and a message as the second parameter. `skipIf` will skip the test if the `Boolean`
    is `True`, while `skipUnless` will skip the test if the `Boolean` is `False`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`skip`装饰器无条件地跳过测试，但`unittest`提供了两个额外的装饰器`skipIf`和`skipUnless`，允许我们指定一个条件来跳过测试。这些装饰器将布尔值作为第一个参数，将消息作为第二个参数。`skipIf`如果布尔值为`True`则跳过测试，而`skipUnless`如果布尔值为`False`则跳过测试。'
- en: 'The following test will run on all platforms except windows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试将在所有平台（除了Windows）上运行：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'While the following test will run only on windows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 而下面的测试只会在Windows上运行：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `skip`, `skipIf`, and `skipUnless` decorators can be used on test methods
    as well as test classes. When applied to classes, all the tests in the class are
    skipped.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`skip`、`skipIf`和`skipUnless`装饰器可以用于测试方法和测试类。当应用于类时，类中的所有测试都将被跳过。'
- en: Pattern – using attributes
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式 - 使用属性
- en: The `nose2` test runner has a useful `attrib` plugin that allows us to set attributes
    on test cases and select tests that match particular attributes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`nose2`测试运行器有一个有用的`attrib`插件，允许我们在测试用例上设置属性并选择匹配特定属性的测试。'
- en: 'For example, the following test has three attributes set:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下测试设置了三个属性：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When nose2 is run via the following command, then the plugin is enabled, and
    only the tests that have the integration attribute set to `True` are executed:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过以下命令运行nose2时，插件将被启用，并且只有设置了`integration`属性为`True`的测试将被执行：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The plugin can also run all tests that have a specific value in a list. Take
    the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 插件还可以运行所有在列表中具有特定值的测试。以下是一个命令示例：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding command will run all tests that have the `python` attribute set
    to `2.6` or containing the value `2.6` in a list. It will select and run the `test_stock_update`
    test, shown previously.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将运行所有将`python`属性设置为`2.6`或包含列表中的值`2.6`的测试。它将选择并运行之前显示的`test_stock_update`测试。
- en: 'The plugin can also run all tests that *do not* have an attribute set. Take
    the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 插件还可以运行所有没有设置属性的测试。以下是一个命令示例：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding command will run all tests that are not marked as slow.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将运行所有未标记为慢速的测试。
- en: 'The plugin can also take complex conditions, so we can give the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 插件还可以接受复杂条件，因此我们可以给出以下命令：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This test runs all the tests that have the `integration` attribute, as well
    as `2.6` in the `python` attribute list. Note that we used the `-E` switch to
    specify that we are giving a `python` condition expression.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试运行所有具有`integration`属性以及`python`属性列表中的`2.6`的测试。请注意，我们使用了`-E`开关来指定我们正在提供一个`python`条件表达式。
- en: The attribute plugin is a great way to run specific subsets of tests without
    having to manually make test suites out of each and every combination that we
    might want to run.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 属性插件是一个很好的方法，可以在不手动从每个可能的组合中创建测试套件的情况下运行特定的测试子集。
- en: Attributes with vanilla unittests
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用vanilla unittests的属性
- en: 'The `attrib` plugin requires nose2 to work. What if we are using the regular
    `unittest` module? The design of the `unittest` module allows us to easily write
    a simplified version in just a few lines of code, as shown in the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`attrib`插件需要nose2才能工作。如果我们正在使用常规的`unittest`模块怎么办？`unittest`模块的设计允许我们仅用几行代码轻松编写一个简化版本，如下所示：'
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This little piece of code will only run those tests that have the `integration`
    attribute set on the test function. Let us look a little deeper into the code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这段小代码将只运行那些在测试函数上设置了`integration`属性的测试。让我们更深入地看看代码。
- en: First, we subclass the default `unittest.TestLoader` class and create our own
    loader called `AttribLoader`. Remember, the **loader** is the class responsible
    for loading the tests from a class or module.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们继承默认的`unittest.TestLoader`类，并创建我们自己的加载器，称为`AttribLoader`。记住，**加载器**是负责从类或模块中加载测试的类。
- en: Next, we override the `getTestCaseNames` method. This method returns a list
    of test case names from a class. Here, we call the parent method to get the default
    list of tests, and then select those test function that have the required attribute.
    This filtered list is returned, and it is only these tests that will be executed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们重写`getTestCaseNames`方法。此方法从一个类中返回一个测试用例名称列表。在这里，我们调用父方法以获取默认的测试列表，然后选择具有所需属性的测试函数。这个过滤后的列表将被返回，并且只有这些测试将被执行。
- en: 'So why have we overridden the `loadTestsFromModule` method as well? Well, simple:
    the default behavior for loading tests is to match by the `test` prefix on the
    method, but if the `load_tests` function is present, then everything is delegated
    to the `load_tests` function. Therefore, all modules that have the `load_tests`
    function defined will take priority over our attribute filtering scheme.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们还要重写`loadTestsFromModule`方法呢？简单来说：加载测试的默认行为是按方法上的`test`前缀进行匹配，但如果存在`load_tests`函数，则所有操作都将委托给`load_tests`函数。因此，所有定义了`load_tests`函数的模块都将优先于我们的属性过滤方案。
- en: When using our loader, we call the default implementation, but set the `use_load_tests`
    parameter to `False`. This means that none of the `load_tests` functions will
    be executed, and the tests to be loaded will be determined only by the filtered
    list that we return. If we would like to give priority to `load_tests` (as is
    the default behavior), then we just need to remove this method from `AttribLoader`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用我们的加载器时，我们调用默认实现，但将`use_load_tests`参数设置为`False`。这意味着将不会执行任何`load_tests`函数，要加载的测试将由我们返回的过滤列表确定。如果我们想优先考虑`load_tests`（这是默认行为），那么我们只需从`AttribLoader`中移除此方法。
- en: Okay, now that the loader is ready, we then modify our test running script to
    use this loader, instead of the default loader. We get the loaded test suite by
    calling the `discover` method, which, in turn, calls our overridden `getTestCaseNames`.
    We pass this suite to the runner and run the tests.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在加载器准备好了，我们修改我们的测试运行脚本以使用这个加载器，而不是默认加载器。我们通过调用`discover`方法来获取加载的测试套件，该方法反过来调用我们重写的`getTestCaseNames`方法。我们将这个套件传递给运行器并运行测试。
- en: The loader can be easily modified to support selecting tests that *don't* have
    a given attribute or to support more complex conditionals. We can then add support
    to the script to accept the attribute on the command line and pass it on to the
    loader.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器可以很容易地修改以支持选择没有给定属性或支持更复杂条件的测试。然后我们可以添加对脚本的支持，以接受命令行上的属性并将其传递给加载器。
- en: Pattern – expected failures
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式 - 预期失败
- en: Sometimes, we have tests that are failing, but, for whatever reason, we don't
    want to fix it yet. It could be that we found a bug and wrote a failing test that
    demonstrates the bug (a very good practice), but we have decided to fix the bug
    later. Now, the whole test suite is failing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们有一些失败的测试，但由于某种原因，我们不想立即修复它们。这可能是因为我们找到了一个错误并编写了一个失败的测试来演示该错误（这是一个非常好的做法），但我们决定稍后修复错误。现在，整个测试套件都在失败。
- en: On one hand, we don't want the suite to fail because we know this bug and want
    to fix it later. On the other hand, we don't want to remove the test from the
    suite because it reminds us that we need to fix the bug. What do we do?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，我们不希望套件失败，因为我们知道这个错误并想稍后修复它。另一方面，我们不想从套件中移除测试，因为它提醒我们需要修复错误。我们该怎么办？
- en: 'Python''s `unittest` module provides a solution: marking tests as expected
    failures. We can do this by applying the `unittest.expectedFailure` decorator
    to the test. The following is an example of it in action:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`unittest`模块提供了一个解决方案：将测试标记为预期失败。我们可以通过将`unittest.expectedFailure`装饰器应用于测试来实现这一点。以下是一个实际应用的示例：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We get the following output when the tests are executed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行测试时，我们得到以下输出：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And the following is the verbose output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其详细输出：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Pattern – data-driven tests
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式 - 数据驱动测试
- en: We briefly explored data-driven tests earlier. Data-driven tests reduce the
    amount of boilerplate test code by allowing us to write a single test execution
    flow and run it with different combinations of data.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前简要探讨了数据驱动测试。数据驱动测试通过允许我们编写单个测试执行流程并使用不同的数据组合运行它来减少样板测试代码的数量。
- en: 'The following is an example using the nose2 parameterization plugin that we
    looked at earlier in this book:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用我们在这本书前面提到的nose2参数化插件的示例：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Running tests like this requires the use of nose2\. Is there a way to do something
    similar using the regular `unittest` module? For a long time there was no way
    to do this without resorting to metaclasses, but a new feature added with Python
    3.4 has made this possible.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此类测试需要使用nose2。是否有方法使用常规的`unittest`模块做类似的事情？长期以来，没有不使用元类就能做到这一点的方法，但Python
    3.4新增的一个特性使得这成为可能。
- en: 'This new feature is the `unittest.subTest` context manager. All the code within
    the context manager block will be treated as a separate test, and any failures
    are reported independently. The following is an example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新特性是`unittest.subTest`上下文管理器。上下文管理器块内的所有代码都将被视为一个单独的测试，任何失败都将独立报告。以下是一个示例：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, the test loops through the different scenarios and asserts
    each one. The whole Arrange-Act-Assert pattern occurs inside the `subTest` context
    manager. The context manager takes any keyword arguments as parameters and these
    are used in displaying error messages.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，测试遍历不同的场景并对每个场景进行断言。整个 Arrange-Act-Assert 模式都发生在`subTest`上下文管理器内部。上下文管理器接受任何关键字参数作为参数，并在显示错误消息时使用这些参数。
- en: 'When we run the test, we get an output like the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，我们得到如下输出：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we can see, the whole test is considered a single test and it shows that
    the test passed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，整个测试被视为单个测试，并且它显示测试通过了。
- en: 'Suppose we change the test to make it fail in two of the three cases, as shown
    in the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将测试改为使其在三个案例中的两个案例中失败，如下所示：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, the output becomes as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输出变为以下内容：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see in the preceding output, it shows a single test was run, but each
    failure is reported individually. In addition, the values that were used when
    the test failed are appended to the end of the test name, making it easy to see
    exactly which condition failed. The values displayed here are the parameters that
    were passed into the `subTest` context manager.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述输出所示，它显示只运行了一个测试，但每个失败都会单独报告。此外，当测试失败时使用的值被附加到测试名称的末尾，这使得可以很容易地看到哪个条件失败了。这里显示的参数是传递给`subTest`上下文管理器的参数。
- en: Pattern – integration and system tests
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式 - 集成和系统测试
- en: 'Throughout this book, we''ve stressed the fact that unit tests are not integration
    tests. They have a different purpose to validating that the system works when
    integrated. Having said that, integration tests are also important and shouldn''t
    be ignored. Integration tests can be written using the same `unittest` framework
    that we use for writing unit tests. The key points to keep in mind when writing
    integration tests are as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们强调了单元测试不是集成测试的事实。它们有不同的目的，即验证系统在集成时是否工作。话虽如此，集成测试也很重要，不应被忽视。集成测试可以使用我们用于编写单元测试的相同`unittest`框架来编写。编写集成测试时需要记住的关键点如下：
- en: '**Still disable non-core services**: Keep non-core services such as analytics
    or logging disabled. These do not affect the functionality of the application.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仍然禁用非核心服务**：保持非核心服务，如分析或日志记录，禁用。这些不会影响应用程序的功能。'
- en: '**Enable all core services**: Every other service should be live. We don''t
    want to mock or fake these because this defeats the whole purpose of an integration
    test.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用所有核心服务**：每个其他服务都应该处于活动状态。我们不希望模拟或伪造这些服务，因为这违背了集成测试的全部目的。'
- en: '**Use attributes to tag integration tests**: By doing this, we can easily select
    only the unit tests to run during development, while enabling integration tests
    to be run during continuous integration or before deployment.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用属性标记集成测试**：通过这样做，我们可以在开发期间轻松选择仅运行单元测试，同时允许在持续集成或部署之前运行集成测试。'
- en: '**Try to minimize setup and teardown time**: For example, don''t start and
    stop a server for each and every test. Instead, use module or package level fixtures
    to start and stop a service once for the entire set of tests. When doing this,
    we have to be careful that our tests do not mess up the state of the service in-between
    tests. In particular, a failing test or a test error should not leave the service
    in an inconsistent state.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽量减少设置和拆卸时间**：例如，不要为每个测试启动和停止服务器。相反，使用模块或包级别的固定装置在所有测试中只启动和停止一次服务。在这样做的时候，我们必须小心，确保我们的测试不会在测试之间破坏服务的状态。特别是，失败的测试或测试错误不应该使服务处于不一致的状态。'
- en: Pattern – spies
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式 - 间谍
- en: Mocks allow us to replace an object or class with a dummy mock object. We've
    seen how we can then make the mock return predefined values, so that the class
    under test doesn't even know that it has made a call to a mock object. However,
    sometimes we might want to just record that the call was made to an object, but
    allow the execution flow to continue to the real object and return. Such an object
    is known as a **spy**. A spy retains the functionality of recording calls and
    being able to assert on the calls afterwards, but it does not replace a real object
    like a regular mock does.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟允许我们用一个虚拟模拟对象替换一个对象或类。我们已经看到我们如何使模拟返回预定义的值，这样被测试的类甚至不知道它已经调用了一个模拟对象。然而，有时我们可能只想记录对对象的调用，但允许执行流程继续到真实对象并返回。这样的对象被称为**间谍**。间谍保留了记录调用和在之后对调用进行断言的功能，但它并不像常规模拟那样替换真实对象。
- en: 'The `wraps` parameter when creating a `mock.Mock` object allows us to create
    spy behavior in our code. It takes an object as a value, and all calls to the
    mock are forwarded to the object we pass, and the return value is sent back to
    the caller. The following is an example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`mock.Mock`对象时的`wraps`参数允许我们在代码中创建间谍行为。它接受一个对象作为值，所有对模拟的调用都转发到我们传递的对象，并将返回值发送回调用者。以下是一个示例：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the above example, we are creating a spy for the `rule` object. The spy is
    nothing but a regular mock object that wraps the real object, as specified in
    the `wraps` parameter. We then pass the spy to the alert. When `alert.check_rule`
    is executed, the method called the `matches` method on the spy. The spy records
    the call details, and then forwards the call to the real rule object and returns
    the value from the real object. We can then assert on the spy to validate the
    call.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们为`rule`对象创建了一个间谍。间谍只是一个普通的模拟对象，它包装了在`wraps`参数中指定的真实对象。然后我们将间谍传递给警报。当`alert.check_rule`执行时，该方法在间谍上调用`matches`方法。间谍记录调用细节，然后将调用转发到真实规则对象并返回真实对象的值。然后我们可以对间谍进行断言以验证调用。
- en: Spies are typically used when we would like to avoid over-mocking and use a
    real object, but we also would like to assert on specific calls. They are also
    used when it is difficult to calculate mock return values by hand, and it is better
    to just do the real calculation and return the value.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍通常用于我们想要避免过度模拟并使用真实对象，但又想对特定的调用进行断言的情况。它们也用于难以手动计算模拟返回值时，最好是进行实际计算并返回值。
- en: Pattern – asserting a sequence of calls
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式 - 断言一系列调用
- en: 'Sometimes, we want to assert that a particular sequence of calls occurred across
    multiple objects. Consider the following test case:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们想要断言在多个对象之间发生了特定的调用序列。考虑以下测试用例：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this test, we are asserting that a call was made to the `rule.matches` method
    as well as a call being made to the `action.execute` method. The way we have written
    the assertions does not check the order of these two calls. This test will still
    pass even if the `matches` method is called after the `execute` method. What if
    we want to specifically check that the call to the `matches` method happened before
    the call to the `execute` method?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们正在断言调用了`rule.matches`方法，以及调用了`action.execute`方法。我们编写断言的方式并没有检查这两个调用之间的顺序。即使`matches`方法在`execute`方法之后被调用，这个测试仍然会通过。如果我们想特别检查`matches`方法的调用发生在`execute`方法调用之前，该怎么办呢？
- en: 'Before answering this question, let us take a look at this interactive Python
    session. First, we create a mock object, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答这个问题之前，让我们看看这个交互式Python会话。首先，我们创建一个模拟对象，如下所示：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we get two child objects that are attributes of the mock, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们得到两个作为模拟对象属性的子对象，如下所示：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Mock objects by default return new mocks whenever an attribute is accessed that
    doesn't have a `return_value` configured. So `child_obj1` and `child_obj2` will
    also be mock objects.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，模拟对象在访问没有配置`return_value`的属性时，会返回新的模拟对象。所以`child_obj1`和`child_obj2`也将是模拟对象。
- en: 'Next, we call some methods on our mock objects, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在模拟对象上调用一些方法，如下所示：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Again, no `return_value` is configured, so the default behavior for the method
    call is to return new mock objects. We can ignore those for this example.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，没有配置`return_value`，所以方法调用的默认行为是返回新的模拟对象。在这个例子中，我们可以忽略这些。
- en: 'Now, let us look at the `mock_calls` attribute for the child objects. This
    attribute contains a list of all the recorded calls on the mock object, as shown
    in the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下子对象的`mock_calls`属性。这个属性包含了对模拟对象上记录的所有调用的列表，如下所示：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The mock objects have the appropriate method calls recorded, as expected. Let
    us now take a look at the attribute on the main `obj` mock object, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象有记录的适当方法调用，正如预期的那样。现在，让我们看一下主`obj`模拟对象上的属性，如下所示：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, this is surprising! The main mock object seems to not only have details
    of its own calls, but also all the calls made by the child mocks!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在令人惊讶的是！主模拟对象似乎不仅有自己的调用细节，还有子模拟对象的所有调用！
- en: So, how can we use this feature in our test to assert the order of the calls
    made across different mocks?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在测试中使用这个特性来断言不同模拟对象之间调用的顺序呢？
- en: 'Well, what if we wrote the above test like the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果我们把上面的测试写成以下这样呢：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we create a main mock object called `main_mock`, and the `rule` and `action`
    mocks are child mocks of this. We then use the mocks as usual. The difference
    is that we use `main_mock` in the assert section. Since `main_mock` has a record
    of the order in which calls are made to the child mocks, this assertion can check
    the order of calls to the `rule` and `action` mocks.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个主模拟对象，称为`main_mock`，而`rule`和`action`模拟则是这个主模拟的子模拟。然后我们像往常一样使用这些模拟。区别在于我们在断言部分使用`main_mock`。因为`main_mock`记录了调用子模拟的顺序，所以这个断言可以检查对`rule`和`action`模拟的调用顺序。
- en: Let us go a step further. The `assert_has_calls` method only asserts that the
    calls were made and that they were in that particular order. The method *does
    not* guarantee that these were the *only* calls made. There could have been other
    calls before the first call or after the last call, or even in-between the two
    calls. The assertion will pass as long as the calls we are asserting were made,
    and that between them the order was maintained.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步。`assert_has_calls`方法只断言调用了调用，并且它们按照特定的顺序进行。该方法*不*保证这些是*唯一*的调用。在第一个调用之前或最后一个调用之后，甚至在这两个调用之间，可能还有其他调用。只要我们断言的调用被调用，并且它们之间保持了顺序，断言就会通过。
- en: 'To strictly match the calls, we can simply do an `assertEqual` on the `mock_calls`
    attribute like the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了严格匹配调用，我们可以在`mock_calls`属性上简单地执行`assertEqual`，如下所示：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the above, we assert the `mock_calls` with a list of expected calls. The
    list must match exactly—no missing calls, no extra calls, nothing different. The
    thing to be careful about is that we must list out *every* call. There is a call
    to `rule.depends_on`, which is done in the `alert.connect` method. We have to
    specify that call, even though it is not related to the functionality we are trying
    to test.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们使用预期调用列表断言`mock_calls`。列表必须完全匹配——没有缺失的调用，没有多余的调用，没有任何不同。需要注意的一点是，我们必须列出*每一个*调用。有一个调用`rule.depends_on`，这是在`alert.connect`方法中完成的。我们必须指定这个调用，即使它与我们要测试的功能无关。
- en: Usually, matching every call will lead to verbose tests as all calls that are
    tangential to the functionality being tested also need to be put in the expected
    output. It also leads to brittle tests as even slight change in calls elsewhere,
    which might not lead to change in behavior in this particular test, will still
    cause the test to fail. This is why the default behavior for `assert_has_calls`
    is to only determine whether the expected calls are present, instead of checking
    for an exact match of calls. In the rare cases where an exact match is required,
    we can always assert on the `mock_calls` attribute directly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，匹配每一个调用会导致测试变得冗长，因为所有与被测试功能无关的调用也需要放入预期的输出中。这也导致测试变得脆弱，因为即使其他地方的调用略有变化，这可能会在这个特定测试中导致行为变化，也会导致测试失败。这就是为什么`assert_has_calls`的默认行为是只确定预期的调用是否存在，而不是检查调用是否完全匹配。在需要完全匹配的罕见情况下，我们总是可以直接在`mock_calls`属性上断言。
- en: Pattern – patching the open function
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式 - 打开函数的修补
- en: One of the most common cases of mocking is to mock out file access. This is
    actually a little cumbersome because the `open` function can be used in a number
    of different ways. It can be used as a regular function or as a context manager.
    The data can be read using many methods such as `read`, `readlines`, and so on.
    In turn, some of these functions, return iterators that can be iterated upon.
    It is a pain to sit and mock all these out in order to be able to use them in
    tests.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟中最常见的用例之一是模拟文件访问。这实际上有点繁琐，因为`open`函数可以用多种方式使用。它可以作为一个普通函数使用，也可以作为一个上下文管理器使用。数据可以通过`read`、`readlines`等方法进行读取。反过来，其中一些函数返回可以迭代的迭代器。为了在测试中使用它们，必须逐一模拟所有这些，这很痛苦。
- en: Fortunately, the mocking library provides an extremely helpful `mock_open` function,
    which returns a mock that handles all these situations. Let us see how we can
    use this function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，模拟库提供了一个极其有用的`mock_open`函数，它可以返回一个处理所有这些情况的模拟。让我们看看我们如何使用这个函数。
- en: 'The following is the code for a `FileReader`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是`FileReader`的代码：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This class reads stock updates from a file and returns each update, one by one.
    The method is a generator, and uses the `yield` keyword to return updates, one
    at a time.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类从文件中读取股票更新，并逐个返回每个更新。这个方法是一个生成器，并使用`yield`关键字逐个返回更新。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**A quick primer on generators**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于生成器的一个快速入门**'
- en: '**Generators** are functions that use a `yield` statement instead of a `return`
    statement to return values. Each time the generator is executed, the execution
    does not start at the beginning of the function, but instead continues running
    from the previous `yield` statement. In the example above, when the generator
    is executed, it parses the first line of the file, then yields the value. The
    next time it is executed, it continues once more through the loop and returns
    the second value, then the third value, and so on until the loop is over. Each
    execution of the generator returns one stock update. For more on generators, check
    out the Python documentation or online articles. One such article can be found
    at [http://www.jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/](http://www.jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成器**是使用`yield`语句而不是`return`语句来返回值的函数。每次执行生成器时，执行不会从函数的开始处开始，而是从上一个`yield`语句继续运行。在上面的例子中，当生成器被执行时，它会解析文件的第一个行，然后返回值。下一次执行时，它会再次通过循环继续运行，返回第二个值，然后是第三个值，依此类推，直到循环结束。每次执行生成器返回一个股票更新。有关生成器的更多信息，请查看Python文档或在线文章。这样一篇文章可以在[http://www.jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/](http://www.jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/)找到。'
- en: 'In order to test the `get_update` method, we will need to create different
    kinds of file data and verify that the method reads them properly and returns
    values as expected. In order to do this, we will mock out the open function. The
    following is one such test:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`get_update`方法，我们需要创建不同类型的文件数据，并验证该方法是否正确读取它们并返回预期的值。为了做到这一点，我们将模拟打开函数。以下是一个这样的测试：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the above test, we are starting with patching the `builtins.open` function.
    The `patch` decorator can take a second parameter, in which we can specify the
    mock object to be used after patching. We call the `mock.mock_open` function to
    create an appropriate mock object, which we pass to the `patch` decorator.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述测试中，我们是从修补`builtins.open`函数开始的。`patch`装饰器可以接受第二个参数，其中我们可以指定修补后要使用的模拟对象。我们调用`mock.mock_open`函数来创建一个适当的模拟对象，并将其传递给`patch`装饰器。
- en: The `mock_open` function takes a `read_data` parameter, in which we can specify
    what data should be returned when the mocked file is read. We use this parameter
    to specify the file data we want to test against.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`mock_open`函数接受一个`read_data`参数，其中我们可以指定当模拟文件被读取时应返回什么数据。我们使用此参数来指定我们想要测试的文件数据。'
- en: 'The rest of the test is fairly simple. The only thing to note is in the following
    line:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的其余部分相当简单。需要注意的是以下一行：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Since `get_updates` is a generator function, a call to the `get_updates` method
    does not actually return a stock update, but instead returns the generator object.
    This generator object is stored in the `updater` variable. We use the built-in
    `next` function to get the stock update from the generator and assert that it
    is as expected.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`get_updates`是一个生成器函数，对`get_updates`方法的调用实际上并不返回股票更新，而是返回生成器对象。这个生成器对象存储在`updater`变量中。我们使用内置的`next`函数从生成器中获取股票更新，并断言它符合预期。
- en: Pattern – mocking with mutable args
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式 - 使用可变参数进行模拟
- en: 'One gotcha that can bite us is when arguments to mocked out objects are mutable.
    Take a look at the following example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能会咬我们的是当模拟对象的参数是可变的时候。看看下面的例子：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Whoa! What happened there? The error says the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！那里发生了什么？错误信息如下：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Actual call was `mock([''123''])`? But we called the mock as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 实际调用是`mock(['123'])`？但我们调用模拟的方式如下：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It's pretty clear that we called it with `["abc"]`. So why is this failing?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们是用`["abc"]`调用的它。那么为什么这个会失败？
- en: The answer is that the mock object only stores a reference to the call arguments.
    So, when the line `param[0] = "123"` was executed, it affected the value that
    was saved as the call argument in the mock. In the assertion, it looks at the
    saved call argument, and sees that the call was made with the data `["123"]`,
    so the assertion fails.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是模拟对象只存储了对调用参数的引用。因此，当执行`param[0] = "123"`这一行时，它影响了存储在模拟中的调用参数的值。在断言中，它查看保存的调用参数，并看到调用使用了数据`["123"]`，所以断言失败。
- en: 'The obvious question is: why is it that the mock stores a reference to the
    parameters? Why doesn''t it make a copy of the arguments so that the stored copy
    doesn''t get changed if the object passed as a parameter is changed later on?
    The answer is that making a copy creates a new object, so all assertions where
    object identity is compared in the argument list will fail.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 显然的问题是：为什么模拟存储了参数的引用？为什么它不复制参数，这样如果稍后传递给参数的对象被更改，存储的副本就不会改变？答案是，复制创建了一个新对象，所以所有在参数列表中比较对象身份的断言都会失败。
- en: So what do we do now? How do we make this test work?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们现在该怎么做？如何让这个测试工作起来？
- en: 'Simple: we just inherit from `Mock` or `MagicMock` and change the behavior
    to make a copy of the arguments, as shown in the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 简单：我们只是从`Mock`或`MagicMock`继承，并更改行为以复制参数，如下所示：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This mock just makes a copy of the arguments and then invokes the default behavior
    passing in the copy.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模拟只是复制了参数，然后调用默认行为，传入复制的内容。
- en: 'The assertion now passes, as shown in the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 断言现在通过了，如下所示：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Keep in mind that when we use `CopyingMock`, we cannot use any object identity
    comparisons with the arguments as they will now fail, as shown in the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当我们使用`CopyingMock`时，我们不能使用任何对象身份比较作为参数，因为它们现在会失败，如下所示：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you looked at some other patterns for unit testing. You looked
    at how to speed up tests and how you can run specific subsets of tests. You looked
    at various patterns for running subset of tests, including creating your own test
    suites and using the `load_tests` protocol. You saw how to use the nose2 attrib
    plugin to run a subset of tests based on test attributes and how to implement
    that functionality with the default unit test runner. We then examined features
    for skipping tests and marking tests as expected failures. You finally looked
    at how we could write data-driven tests.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你研究了单元测试的一些其他模式。你研究了如何加快测试速度以及如何运行特定的测试子集。你研究了运行测试子集的各种模式，包括创建自己的测试套件和使用`load_tests`协议。你看到了如何使用nose2
    attrib插件根据测试属性运行测试子集，以及如何使用默认单元测试运行器实现该功能。然后我们检查了跳过测试和标记测试为预期失败的功能。最后，你研究了如何编写数据驱动测试。
- en: Next, we moved on to some mocking patterns, starting with how to implement spy
    functionality. You also looked at the problem of validating a sequence of mock
    calls across multiple mocks. You then looked at the `mock_open` function to help
    us easily mock filesystem access, and in the process you took a peek at how to
    work with generator functions. Finally, you looked at the problem of using mocks
    when the arguments are mutable.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们转向了一些模拟模式，首先是实现间谍功能的方法。你也研究了在多个模拟之间验证模拟调用序列的问题。然后你研究了`mock_open`函数，以帮助我们轻松模拟文件系统访问，在这个过程中你瞥了一眼如何与生成器函数一起工作。最后，你研究了在参数可变时使用模拟的问题。
- en: The next chapter is the final chapter in this book, where you will look at other
    tools that we can use in our TDD practice.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是这本书的最后一章，你将了解我们可以在我们的TDD实践中使用的其他工具。
