- en: '1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numbers, Strings, and Tuples
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will look at some of the central types of Python objects. We’ll
    look at working with different kinds of numbers, working with strings, and using
    tuples. These are the simplest kinds of data that Python works with. In later
    chapters, we’ll look at data structures built on these foundations.
  prefs: []
  type: TYPE_NORMAL
- en: While these recipes start with a beginner’s level of understanding of Python
    3.12, they also provide some deeper background for those familiar with the language.
    In particular, we’ll look at some details of how numbers are represented internally,
    because this can help when confronted with more advanced numerical programming
    problems. This will help us distinguish the uses cases for the rich variety of
    numeric types.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also look at the two different division operators. These have distinct
    use cases, and we’ll look at one kind of algorithm that demands truncated division.
  prefs: []
  type: TYPE_NORMAL
- en: When working with strings, there are several common operations that are important.
    We’ll explore some of the differences between bytes—as used by our OS files—and
    strings used to represent Unicode text. We’ll look at how we can exploit the full
    power of the Unicode character set.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll show the recipes as if we’re working from the >>> prompt
    in interactive Python. This is the prompt that’s provided when running python
    from the command line or using the Python console in many Integrated Development
    Environment (IDE) tools. This is sometimes called the read-evaluate-print loop
    (REPL). In later chapters, we’ll change the style so it looks more like a script
    file. One goal of this chapter is to encourage interactive exploration because
    it’s a great way to learn the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover these recipes to introduce basic Python data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Choosing between float, decimal, and fraction](ch005_split_000.xhtml#x1-180001)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Choosing between true division and floor division](ch005_split_000.xhtml#x1-270002)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[String parsing with regular expressions](ch005_split_000.xhtml#x1-350003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Building complicated strings with f-strings](ch005_split_000.xhtml#x1-410004)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Building complicated strings from lists of strings](ch005_split_000.xhtml#x1-470005)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using the Unicode characters that aren’t on our keyboards](ch005_split_001.xhtml#x1-520006)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Encoding strings – creating ASCII and UTF-8 bytes](ch005_split_001.xhtml#x1-570007)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Decoding bytes – how to get proper characters from some bytes](ch005_split_001.xhtml#x1-620008)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using tuples of items](ch005_split_001.xhtml#x1-670009)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using NamedTuples to simplify item access in tuples](ch005_split_001.xhtml#x1-7500010)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll start with numbers, work our way through strings, and end up working with
    simple combinations of objects in the form of tuples and NamedTuple objects.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1 Choosing between float, decimal, and fraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python offers several ways to work with rational numbers and approximations
    of irrational numbers. We have three basic choices:'
  prefs: []
  type: TYPE_NORMAL
- en: Float
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decimal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we have choices, it helps to have some criteria for making a selection.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three general cases for expressions that involve numbers beyond integers,
    which are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Currency: Dollars, cents, euros, and so on. Currency generally has a fixed
    number of decimal places and rounding rules to properly quantize results.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rational Numbers or Fractions: When we scale a recipe that serves eight, for
    example, down to five people, we’re doing fractional math using a scaling factor
    of ![5 8](img/file4.png).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Floating Point: This includes all other kinds of calculations. This also includes
    irrational numbers, like π, root extraction, and logarithms.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we have one of the first two cases, we should avoid floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at each of the three cases separately.
  prefs: []
  type: TYPE_NORMAL
- en: Doing currency calculations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When working with currency, we should always use the decimal module. If we
    try to use the values of Python’s built-in float type, we can run into problems
    with the rounding and truncation of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with currency, import the Decimal class from the decimal module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to create Decimal objects from strings or integers. In this case, we
    want 7.25%, which is ![7.25 100](img/file5.png). We can compute the value using
    Decimal objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We could also use Decimal(’0.0725’) instead of doing the division explicitly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To round to the nearest penny, create a penny object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Quantize the result using the penny object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This uses the default rounding rule of ROUND_HALF_EVEN. The Decimal module
    offers other rounding variations. We might, for example, do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This shows the consequences of using a different rounding rule.
  prefs: []
  type: TYPE_NORMAL
- en: Fraction calculations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we’re doing calculations that have exact fraction values, we can use the
    fractions module to create rational numbers. In this example, we want to scale
    a recipe for eight down to five people, using ![58](img/file6.png) of each ingredient.
    When the recipe calls for 2![1 2](img/file7.png) cups of rice, what does that
    scale down to?
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with fractions, we’ll do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the Fraction class from the fractions module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create Fraction objects from strings, integers, or pairs of integers. We created
    one fraction from a string, ’2.5’. We created the second fraction from a floating-point
    expression, 5 / 8\. This only works when the denominator is a power of 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that we’ll use almost a cup and a half of rice to scale the recipe
    for five people instead of eight. While float values will often be useful for
    rational fractions, they may not be exact unless the denominator is a power of
    two.
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point approximations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python’s built-in float type can represent a wide variety of values. The trade-off
    here is that a float value is often an approximation. There may be a small discrepancy
    that reveals the differences between the implementation of float and the mathematical
    ideal of an irrational number:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with float, we often need to round values to make them look sensible.
    It’s important to recognize that all float calculations are an approximation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Mathematically, the value should be 1\. Because of the approximations used,
    the computed result isn’t exactly 1\. We can use round(answer, 3) to round to
    three digits, creating a value that’s more useful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Approximations have a very important consequence.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t compare floating-point values for exact equality.
  prefs: []
  type: TYPE_NORMAL
- en: Code that uses an exact == test between floating-point numbers has the potential
    to cause problems when two approximations differ by a single bit.
  prefs: []
  type: TYPE_NORMAL
- en: The float approximation rules come from the IEEE, and are not a unique feature
    of Python. Numerous programming languages work with float approximations and have
    identical behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For these numeric types, Python offers a variety of operators: +, -, *, /,
    //, %, and **. These are for addition, subtraction, multiplication, true division,
    truncated division, modulo, and raising to a power, respectively. We’ll look at
    the two division operators, / and //, in the [Choosing between true division and
    floor division](ch005_split_000.xhtml#x1-270002) recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Python will do some conversions between the various numeric types. We can mix
    int and float values; the integers will be promoted to floating-point to provide
    the most accurate answer possible. Similarly, we can mix int and Fraction as well
    as mixing int and Decimal. Note that we cannot casually mix Decimal with float
    or Fraction; an explicit conversion function will be required.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that float values are approximations. The Python syntax
    allows us to write floating-point values using base 10 digits; however, that’s
    not how values are represented internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write the value 8.066 × 10^(67) like this in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual value used internally will involve a binary approximation of the
    decimal value we wrote. The internal value for this example is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The numerator is a big number, 6737037547376141\. The denominator is always
    2^(53). This is why values can get truncated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the math.frexp() function to see these internal details of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The two parts are called the mantissa (or significand) and the exponent. If
    we multiply the mantissa by 2^(53), we always get a whole number, which is the
    numerator of the binary fraction.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the built-in float, a Fraction is an exact ratio of two integer values.
    We can create ratios that involve integers with a very large number of digits.
    We’re not limited by a fixed denominator.
  prefs: []
  type: TYPE_NORMAL
- en: A Decimal value, similarly, is based on a very large integer value, as well
    as a scaling factor to determine where the decimal place goes. These numbers can
    be huge and won’t suffer from peculiar representation issues.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python math module contains several specialized functions for working with
    floating-point values. This module includes common elementary functions such as
    square root, logarithms, and various trigonometry functions. It also has some
    other functions such as gamma, factorial, and the Gaussian error function.
  prefs: []
  type: TYPE_NORMAL
- en: The math module includes several functions that can help us do more accurate
    floating-point calculations. For example, the math.fsum() function will compute
    a floating-point sum more carefully than the built-in sum() function. It’s less
    susceptible to approximation issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also make use of the math.isclose() function to compare two floating-point
    values, an expression, and a literal 1.0, to see if they’re nearly equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This function provides us with a way to compare two floating-point numbers meaningfully
    for near-equality.
  prefs: []
  type: TYPE_NORMAL
- en: Python also offers complex numbers. A complex number has a real and an imaginary
    part. In Python, we write 3.14+2.78j to represent the complex number 3.14 + 2.78![√
    --- − 1](img/file8.png). Python will comfortably convert between float and complex.
    We have the usual group of operators available for complex numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support complex numbers, there’s the cmath package. The cmath.sqrt() function,
    for example, will return a complex value rather than raise an exception when extracting
    the square root of a negative number. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This module is helpful when working with complex numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll talk more about floating-point numbers and fractions in the [Choosing
    between true division and floor division](ch005_split_000.xhtml#x1-270002) recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [https://en.wikipedia.org/wiki/IEEE_floating_point](https://en.wikipedia.org/wiki/IEEE_floating_point).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.2 Choosing between true division and floor division
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python offers us two kinds of division operators. What are they, and how do
    we know which one to use? We’ll also look at the Python division rules and how
    they apply to integer values.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several general cases for division:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A div-mod pair: We want both parts – the quotient and the remainder. The name
    refers to the division and modulo operations combined together. We can summarize
    the quotient and remainder as q,r = (⌊![a b](img/file9.png)⌋,a mod b).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We often use this when converting values from one base into another. When we
    convert seconds into hours, minutes, and seconds, we’ll be doing a div-mod kind
    of division. We don’t want the exact number of hours; we want a truncated number
    of hours, and the remainder will be converted into minutes and seconds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The true value: This is a typical floating-point value; it will be a good approximation
    to the quotient. For example, if we’re computing an average of several measurements,
    we usually expect the result to be floating-point, even if the input values are
    all integers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A rational fraction value: This is often necessary when working in American
    units of feet, inches, and cups. For this, we should be using the Fraction class.
    When we divide Fraction objects, we always get exact answers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to decide which of these cases apply, so we know which division operator
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at these three cases separately.
  prefs: []
  type: TYPE_NORMAL
- en: Doing floor division
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we are doing the div-mod kind of calculations, we might use the floor
    division operator, //, and the modulo operator, %. The expression a % b gives
    us the remainder from an integer division of a // b. Or, we might use the divmod()
    built-in function to compute both at once:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll divide the number of seconds by 3,600 to get the value of hours. The
    modulo, or remainder in division, computed with the % operator, can be converted
    separately into minutes and seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll divide the number of seconds by 60 to get minutes; the remainder
    is the number of seconds less than 60:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the alternative, using the divmod() function to compute quotient and
    modulo together:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compute quotient and remainder at the same time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compute quotient and remainder again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Doing true division
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Performing a true division calculation gives a floating-point approximation
    as the result. For example, about how many hours is 7,385 seconds? Here’s ![736805](img/file10.png)
    using the true division operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We provided two integer values, but got a floating-point exact result. Consistent
    with our previous recipe, when using floating-point values, we rounded the result
    to avoid having to look at tiny error digits.
  prefs: []
  type: TYPE_NORMAL
- en: Rational fraction calculations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can do division using Fraction objects and integers. This forces the result
    to be a mathematically exact rational number:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create at least one Fraction value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the Fraction value in a calculation. Any integer will be promoted to a
    Fraction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The denominator of 720 doesn’t seem too meaningful. Working with fractions like
    this requires a bit of finesse to find useful denominators that makes sense to
    people. Otherwise, converting to a floating-point value can be useful.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If necessary, convert the exact Fraction into a floating-point approximation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we created a Fraction object for the total number of seconds. When we
    do arithmetic on fractions, Python will promote any integers to Fraction objects;
    this promotion means that the math is done as precisely as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python has two division operators:'
  prefs: []
  type: TYPE_NORMAL
- en: The / true division operator produces a true, floating-point result. It does
    this even when the two operands are integers. This is an unusual operator in this
    respect. All other operators preserve the type of the data. The true division
    operation – when applied to integers – produces a float result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The // truncated division operator always produces a truncated result. For
    two integer operands, this is the truncated quotient. When floating-point operands
    are used, this is a truncated floating-point result:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 1.2.4 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more on the choice between floating-point and fractions, see the [Choosing
    between float, decimal, and fraction](ch005_split_000.xhtml#x1-180001) recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [PEP-238](https://www.python.org/dev/peps/pep-0238).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.3 String parsing with regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do we decompose a complex string? What if we have complex, tricky punctuation?
    Or—worse yet—what if we don’t have punctuation, but have to rely on patterns of
    digits to locate meaningful information?
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to decompose a complex string is by generalizing the string
    into a pattern and then writing a regular expression that describes that pattern.
  prefs: []
  type: TYPE_NORMAL
- en: There are limits to the patterns that regular expressions can describe. When
    we’re confronted with deeply nested documents in a language like HTML, XML, or
    JSON, we often run into problems and be prohibited from using regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The re module contains all of the various classes and functions we need to create
    and use regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that we want to decompose text from a recipe website. Each line looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We want to separate the ingredient from the measurements.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write and use regular expressions, we often do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generalize the example. In our case, we have something that we can generalize
    as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ve replaced literal text with a two-part summary: what it means and how
    it’s represented. For example, ingredient is represented as words, while amount
    is represented as digits. Import the re module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rewrite the pattern into regular expression (RE) notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve replaced representation hints such as ingredient words, a mixture of letters
    and spaces, with [\w\s]+. We’ve replaced amount digits with \d+. And we’ve replaced
    single spaces with \s+ to allow one or more spaces to be used as punctuation.
    We’ve left the colon in place because, in regular expression notation, a colon
    matches itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For each of the fields of data, we’ve used () to capture the data matching the
    pattern. We didn’t capture the colon or the spaces because we don’t need the punctuation
    characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: REs typically use a lot of \ characters. To make this work out nicely in Python,
    we almost always use raw strings. The r’ tells Python not to look at the \ characters
    and not to replace them with special characters that aren’t on our keyboards.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Compile the pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Match the pattern against the input text. If the input matches the pattern,
    we’ll get a match object that shows details of the substring that matched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extract the named groups of characters from the match object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each group is identified by the order of the capture () portions of the regular
    expression. This gives us a tuple of the different fields captured from the string.
    We’ll return to the use of the tuple data structure in the [Using tuples of items](ch005_split_001.xhtml#x1-670009)
    recipe. This can be confusing in more complex regular expressions; there is a
    way to provide a name, instead of the numeric position, to identify a capture
    group.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a lot of different kinds of string patterns that we can describe with
    regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve shown a number of character classes:'
  prefs: []
  type: TYPE_NORMAL
- en: \w matches any alphanumeric character (a to z, A to Z, 0 to 9).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \d matches any decimal digit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \s matches any space or tab character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These classes also have inverses:'
  prefs: []
  type: TYPE_NORMAL
- en: \W matches any character that’s not a letter or a digit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \D matches any character that’s not a digit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \S matches any character that’s not some kind of space or tab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many characters match themselves. Some characters, however, have a special
    meaning, and we have to use \ to escape from that special meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: We saw that + as a suffix means to match one or more of the preceding patterns.
    \d+ matches one or more digits. To match an ordinary +, we need to use \+.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also have * as a suffix, which matches zero or more of the preceding patterns.
    \w* matches zero or more characters. To match a *, we need to use \*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have ? as a suffix, which matches zero or one of the preceding expressions.
    This character is used in other places, and has a different meaning in the other
    context. We’ll see it used in ?P<name>...)|, where it is inside \verb|)— to define
    special properties for the grouping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The . character matches any single character. To match a . specifically, we
    need to use \..
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create our own unique sets of characters using [] to enclose the elements
    of the set. We might have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This has a \w+ to match any number of alphanumeric characters. This will be
    collected into a group called name. It uses \s* to match an optional sequence
    of spaces. It matches any character in the set [=:]. Exactly one of the two characters
    in this set must be present. It uses \s* again to match an optional sequence of
    spaces. Finally, it uses .* to match everything else in the string. This is collected
    into a group named value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this to parse strings, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'By being flexible with the punctuation, we can make a program easier to use.
    We’ll tolerate any number of spaces, and either an = or a : as a separator.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A long regular expression can be awkward to read. We have a clever Pythonic
    trick for presenting an expression in a way that’s much easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This leverages three syntax rules:'
  prefs: []
  type: TYPE_NORMAL
- en: A statement isn’t finished until the () characters match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjacent string literals are silently concatenated into a single long string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Anything between # and the end of the line is a comment, and is ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve put Python comments after the important clauses in our regular expression.
    This can help us understand what we did, and perhaps help us diagnose problems
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the regular expression’s ”verbose” mode to add gratuitous whitespace
    and comments inside a regular expression string. To do this, we must use re.X
    as an option when compiling a regular expression to make whitespace and comments
    possible. This revised syntax looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We can either break the pattern up into separate string components, or make
    use of extended syntax to make the regular expression more readable. The benefit
    of providing names shows up when we use the groupdict() method of the match object
    to extract parsed values by the name associated with the pattern being captured.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Decoding bytes – how to get proper characters from some bytes](ch005_split_001.xhtml#x1-620008)
    recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many books on regular expressions and Python regular expressions in
    particular, like Mastering Python Regular Expressions [https://www.packtpub.com/application-development/mastering-python-regular-expressions](https://www.packtpub.com/application-development/mastering-python-regular-expressions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.4 Building complicated strings with f-strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating complex strings is, in many ways, the polar opposite of parsing a complex
    string. We generally use a template with substitution rules to put data into a
    more complex format.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say we have pieces of data that we need to turn into a nicely formatted
    message. We might have data that includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And we’d like a line that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 1.4.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an f-string for the result, replacing all of the data items with placeholders.
    Inside each placeholder, put a variable name (or an expression.) Note that the
    string uses the prefix of f’. This prefix creates a sophisticated string object
    where values are interpolated into the template when the string is used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each name or expression, an optional data type can be appended to the names
    in the template string. The basic data type codes are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: s for string
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d for decimal number
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: f for floating-point number
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It would look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because the book’s margins are narrow, the string has been broken to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fit on the page. It’s a single (very wide) line of code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add length information where required. Length is not always required, and in
    some cases, it’s not even desirable. In this example, though, the length information
    ensures that each message has a consistent format. For strings and decimal numbers,
    prefix the format with the length like this: 19s or 3d. For floating-point numbers,
    use a two-part prefix like 5.2f to specify the total length of five characters,
    with two to the right of the decimal point. Here’s the whole format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 1.4.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F-strings can do a lot of relatively sophisticated string assembly by interpolating
    data into a template. There are a number of conversions available.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve seen three of the formatting conversions—s, d, f—but there are many others.
    Details can be found in the Formatted string literals section of the Python Standard
    Library: [https://docs.python.org/3/reference/lexical_analysis.html\#formatted-string-literals](https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the format conversions we might use:'
  prefs: []
  type: TYPE_NORMAL
- en: b is for binary, base 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: c is for Unicode character. The value must be a number, which is converted into
    a character. Often, we use hexadecimal numbers for these characters, so you might
    want to try values such as 0x2661 through 0x2666 to see interesting Unicode glyphs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: d is for decimal numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E and e are for scientific notations. 6.626E-34 or 6.626e-34, depending on which
    E or e character is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F and f are for floating-point. For not a number, the f format shows lowercase
    nan; the F format shows uppercase NAN.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: G and g are for general use. This switches automatically between E and F (or
    e and f) to keep the output in the given sized field. For a format of 20.5G, up
    to 20-digit numbers will be displayed using F formatting. Larger numbers will
    use E formatting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: n is for locale-specific decimal numbers. This will insert , or . characters,
    depending on the current locale settings. The default locale may not have 1,000
    separators defined. For more information, see the locale module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: o is for octal, base 8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: s is for string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X and x are for hexadecimal, base 16\. The digits include uppercase A-F and
    lowercase a-f, depending on which X or x format character is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '% is for percentage. The number is multiplied by 100 and the output includes
    a % character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have a number of prefixes we can use for these different types. The most
    common one is the length. We might use {name:5d} to put in a 5-digit number. There
    are several prefixes for the preceding types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill and alignment: We can specify a specific filler character (space is the
    default) and an alignment. Numbers are generally aligned to the right and strings
    to the left. We can change that using <, >, or ^. This forces left alignment,
    right alignment, or centering, respectively. There’s a peculiar = alignment that’s
    used to put padding after a leading sign.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sign: The default rule is a leading negative sign where needed. We can use
    + to put a sign on all numbers, - to put a sign only on negative numbers, and
    a space to use a space instead of a plus for positive numbers. In scientific output,
    we often use {value:5.3f}. The space makes sure that room is left for the sign,
    ensuring that all the decimal points line up nicely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alternate form: We can use the # to get an alternate form. We might have something
    like {0:#x}, {0:#o}, or {0:#b} to get a prefix on hexadecimal, octal, or binary
    values. With a prefix, the numbers will look like 0xnnn, 0onnn, or 0bnnn. The
    default is to omit the two-character prefix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Leading zero: We can include 0 to get leading zeros to fill in the front of
    a number. Something like {code:08x} will produce a hexadecimal value with leading
    zeroes to pad it out to eight characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Width and precision: For integer values and strings, we only provide the width.
    For floating-point values, we often provide width.precision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some times when we won’t use a {name:format} specification. Sometimes,
    we’ll need to use a {name!conversion} specification. There are only three conversions
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '{name!r} shows the representation that would be produced by repr(name).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{name!s} shows the string value that would be produced by str(name); this is
    the default behavior if you don’t specify any conversion. Using !s explicitly
    lets you add string-type format specifiers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{name!a} shows the ASCII value that would be produced by ascii(name).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there’s a handy debugging format specifier available. We can
    include a trailing equals sign, =, to get a handy dump of a variable or expression.
    The following example uses both forms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The f-string showed the value of the variable named value and the result of
    an expression, 2**7+1.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter [7](ch011_split_000.xhtml#x1-3760007), we’ll leverage the idea of
    the {name!r} format specification to simplify displaying information about related
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The f-string processing relies on the string format() method. We can leverage
    this method and the related format_map() method for cases where we have more complex
    data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking forward to Chapter [5](ch009.xhtml#x1-2890005), we might have a dictionary
    where the keys are simple strings that fit with the format_map() rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve created a dictionary object, data, that contains a number of values with
    keys that are valid Python identifiers: id, location, max_temp, min_temp, and
    precipitation. We can then use this dictionary with the format_map() method to
    extract values from the dictionary using the keys.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the formatting template here is not an f-string. It doesn’t have the
    f" prefix. Instead of using the automatic formatting features of an f-string,
    we’ve done the interpolation ”the hard way” using the format_map() method of an
    f-string.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'More details can be found in the Formatted string literals section of the Python
    Standard Library: [https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals](https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.5 Building complicated strings from lists of strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we make complicated changes to an immutable string? Can we assemble
    a string from individual characters?
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, the recipes we’ve already seen give us a number of tools for
    creating and modifying strings. There are yet more ways in which we can tackle
    the string manipulation problem. In this recipe, we’ll look at using a list object
    as a way to decompose and rebuild a string. This will dovetail with some of the
    recipes in Chapter [4](ch008_split_000.xhtml#x1-2240004).
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s a string that we’d like to rearrange:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We’d like to do two transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the part before :.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace the punctuation with _ and make all the characters lowercase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll make use of the string module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This has two important constants:'
  prefs: []
  type: TYPE_NORMAL
- en: string.whitespace lists all of the whitespace characters that are also part
    of ASCII, including space and tab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: string.punctuation lists punctuation marks that are also part of ASCII. Unicode
    has a large domain of punctuation marks. This is a widely used subset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.5.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can work with a string exploded into a list. We’ll look at lists in more
    depth in Chapter [4](ch008_split_000.xhtml#x1-2240004):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explode the string into a list object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the partition character. The index() method for a list has the same semantics
    as the index() method has for a string. It locates the position with the given
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete the characters that are no longer needed. The del statement can remove
    items from a list. Unlike strings, lists are mutable data structures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace punctuation by stepping through each position. In this case, we’ll
    use a for statement to visit every index in the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The expression range(len(title_list)) generates all of the values between 0
    and len(title_list)-1\. This assures us that the value of position will be each
    value index in the list. Join the list of characters to create a new string. It
    seems a little odd to use a zero-length string, ’’, as a separator when concatenating
    strings together. However, it works perfectly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We assigned the resulting string back to the original variable. The original
    string object, which had been referred to by that variable, is no longer needed:
    it’s automatically removed from memory (this is known as garbage collection).
    The new string object replaces the value of the variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a change in representation trick. Since a string is immutable, we can’t
    update it. We can, however, convert it into a mutable form; in this case, a list.
    We can make whatever changes are required to the mutable list object. When we’re
    done, we can change the representation from a list back to a string and replace
    the original value of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Lists provide some features that strings don’t have. Conversely, strings provide
    a number of features lists don’t have. As an example, we can’t convert a list
    into lowercase the way we can convert a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s an important trade-off here:'
  prefs: []
  type: TYPE_NORMAL
- en: Strings are immutable, which makes them very fast. Strings are focused on Unicode
    characters. When we look at mappings and sets, we can use strings as keys for
    mappings and items in sets because the value is immutable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists are mutable. Operations are slower. Lists can hold any kind of item. We
    can’t use a list as a key for a mapping or an item in a set because the list value
    could change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Strings and lists are both specialized kinds of sequences. Consequently, they
    have a number of common features. The basic item indexing and slicing features
    are shared. Similarly, a list uses the same kind of negative index values that
    a string does: the expression list[-1] is the last item in a list object.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll return to mutable data structures in Chapter [4](ch008_split_000.xhtml#x1-2240004).
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.4 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we need to build a string, and then convert it into bytes. See the
    [Encoding strings – creating ASCII and UTF-8 bytes](ch005_split_001.xhtml#x1-570007)
    recipe for how we can do this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other times, we’ll need to convert bytes into a string. See the [Decoding bytes
    – how to get proper characters from some bytes](ch005_split_001.xhtml#x1-620008)
    recipe for more information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.6 Using the Unicode characters that aren’t on our keyboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A big keyboard might have almost 100 individual keys. Often, fewer than 50 of
    these keys are letters, numbers, and punctuation. At least a dozen are function
    keys that do things other than simply insert letters into a document. Some of
    the keys are different kinds of modifiers that are meant to be used in conjunction
    with another key—for example, we might have Shift, Ctrl, Option, and Command.
  prefs: []
  type: TYPE_NORMAL
- en: Most operating systems will accept simple key combinations that create about
    100 or so characters. More elaborate key combinations may create another 100 or
    so less popular characters. This isn’t even close to covering the vast domain
    of characters from the world’s alphabets. And there are icons, emojis, and dingbats
    galore in our computer fonts. How do we get to all of those glyphs?
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python works in Unicode. There are thousands of individual Unicode characters
    available.
  prefs: []
  type: TYPE_NORMAL
- en: We can see all the available characters at [https://en.wikipedia.org/wiki/List_of_Unicode_characters](https://en.wikipedia.org/wiki/List_of_Unicode_characters),
    as well as at [http://www.unicode.org/charts/](http://www.unicode.org/charts/).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll need the Unicode character number. We may also want the Unicode character
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'A given font on our computer may not be designed to provide glyphs for all
    of those characters. In particular, Windows computer fonts may have trouble displaying
    some of these characters. Using the following Windows command to change to code
    page 65001 is sometimes necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Linux and macOS rarely have problems with Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python uses escape sequences to extend the ordinary characters we can type
    to cover the vast space of Unicode characters. Each escape sequence starts with
    a \ character. The next character tells us exactly which of the Unicode characters
    to create. Locate the character that’s needed. Get the name or the number. The
    numbers are always given as hexadecimal, base 16\. Websites describing Unicode
    often write the character as U+2680\. The name might be DIE FACE-1\. Use \unnnn
    with up to a four-digit number, nnnn. Or, use \N{name} with the spelled-out name.
    If the number is more than four digits, use \Unnnnnnnn with the number padded
    out to exactly eight digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Yes, we can include a wide variety of characters in Python output. To place
    a \ in the string without the following characters being part of an escape sequence,
    we need to use \\. For example, we might need this for Windows file paths.
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python uses Unicode internally. The 128 or so characters we can type directly
    using the keyboard all have handy internal Unicode numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Python treats it as shorthand for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Once we get beyond the characters on our keyboards, the remaining thousands
    of characters are identified only by their number.
  prefs: []
  type: TYPE_NORMAL
- en: When the string is being compiled by Python, \uxxxx, \Uxxxxxxxx, and \N{name}
    are all replaced by the proper Unicode character. If we have something syntactically
    wrong—for example, \N{name with no closing }—we’ll get an immediate error from
    Python’s internal syntax checking.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions use a lot of \ characters and that we specifically do not
    want Python’s normal compiler to touch them; we used the r’ prefix on a regular
    expression string to prevent \ from being treated as an escape and possibly converted
    into something else. To use the full domain of Unicode characters, we cannot avoid
    using \ as an escape.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we need to use Unicode in a regular expression? We’ll need to use \\
    all over the place in the regular expression. We might see something like this:
    ’\\w+[\u2680\u2681\u2682\u2683\u2684\u2685]\\d+’.'
  prefs: []
  type: TYPE_NORMAL
- en: We couldn’t use the r’ prefix on the string because we needed to have the Unicode
    escapes processed. This forced us to use \\ for elements of the regular expression.
    We used \uxxxx for the Unicode characters that are part of the pattern. Python’s
    internal compiler will replace \uxxxx with Unicode characters and \\w will become
    the required \w internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we look at a string at the >>> prompt, Python will display the string
    in its canonical form. Python prefers to display strings with ’ as a delimiter,
    using " when the string contains a ’. We can use either ’ or " for a string delimiter
    when writing code. Python doesn’t generally display raw strings; instead, it puts
    all of the necessary escape sequences back into the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We provided a string in raw form. Python displayed it in canonical form.
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.4 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Encoding strings – creating ASCII and UTF-8 bytes](ch005_split_001.xhtml#x1-570007)
    and the [Decoding bytes – how to get proper characters from some bytes](ch005_split_001.xhtml#x1-620008)
    recipes, we’ll look at how Unicode characters are converted into sequences of
    bytes so we can write them to a file. We’ll look at how bytes from a file (or
    downloaded from a website) are turned into Unicode characters so they can be processed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you’re interested in history, you can read up on ASCII and EBCDIC and other
    old-fashioned character codes here: [http://www.unicode.org/charts/](http://www.unicode.org/charts/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.7 Encoding strings – creating ASCII and UTF-8 bytes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our computer files are bytes. When we upload or download from the internet,
    the communication works in bytes. A byte only has 256 distinct values. Our Python
    characters are Unicode. There are a lot more than 256 Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: How do we map Unicode characters to bytes to write to a file or for transmission?
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Historically, a character occupied 1 byte. Python leverages the old ASCII encoding
    scheme for bytes; this sometimes leads to confusion between bytes and text strings
    of Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode characters are encoded into sequences of bytes. There are a number of
    standardized encodings and a number of non-standard encodings.
  prefs: []
  type: TYPE_NORMAL
- en: Plus, there also are some encodings that only work for a small subset of Unicode
    characters. We try to avoid these, but there are some situations where we’ll need
    to use a subset encoding scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Unless we have a really good reason not to, we almost always use UTF-8 encoding
    for Unicode characters. Its main advantage is that it’s a compact representation
    of the Latin alphabet, which is used for English and a number of European languages.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, an internet protocol requires ASCII characters. This is a special
    case that requires some care because the ASCII encoding can only handle a small
    subset of Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python will generally use our OS’s default encoding for files and internet
    traffic. The details are unique to each OS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make a general setting using the PYTHONIOENCODING environment variable.
    We set this outside of Python to ensure that a particular encoding is used everywhere.
    When using Linux or macOS, use the shell’s export statement to set the environment
    variable. For Windows, use the set command, or the PowerShell Set-Item cmdlet.
    For Linux, it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We sometimes need to make specific settings when we open a file inside our
    script. We’ll return to this topic in Chapter [11](ch015_split_000.xhtml#x1-61500011).
    Open the file with a given encoding. Read or write Unicode characters to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also manually encode characters, in the rare case that we need to open
    a file in bytes mode; if we use a mode of wb, we’ll also need to use manual encoding
    of each string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We can see that a sequence of bytes (\xf0\x9f\x80\x80) was used to encode a
    single Unicode character, U+1F000, ![PIC](img/file11.png).
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unicode defines a number of encoding schemes. While UTF-8 is the most popular,
    there is also UTF-16 and UTF-32\. The number is the typical number of bits per
    character. A file with 1,000 characters encoded in UTF-32 would be 4,000 8-bit
    bytes. A file with 1,000 characters encoded in UTF-8 could be as few as 1,000
    bytes, depending on the exact mix of characters. In UTF-8 encoding, characters
    with Unicode numbers above U+007F require multiple bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Various OSes have their own coding schemes. macOS files can be encoded in Mac
    Roman or Latin-1\. Windows files might use CP1252 encoding.
  prefs: []
  type: TYPE_NORMAL
- en: The point with all of these schemes is to have a sequence of bytes that can
    be mapped to a Unicode character and—going the other way—a way to map each Unicode
    character to one or more bytes. Ideally, all of the Unicode characters are accounted
    for. Pragmatically, some of these coding schemes are incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: The historical form of ASCII encoding can only represent about 100 of the Unicode
    characters as bytes. It’s easy to create a string that cannot be encoded using
    the ASCII scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the error looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We may see this kind of error when we accidentally open a file with an encoding
    that’s not the widely used standard of UTF-8\. When we see this kind of error,
    we’ll need to change our processing to select the encoding actually used to create
    the file. It’s almost impossible to guess what encoding was used, so some research
    may be required to locate metadata about the file that states the encoding.
  prefs: []
  type: TYPE_NORMAL
- en: Bytes are often displayed using printable characters. We’ll see b’hello’ as
    shorthand for a five-byte value. The letters are chosen using the old ASCII encoding
    scheme, where byte values from 0x20 to 0x7F will be shown as characters, and outside
    this range, more complex-looking escapes will be used.
  prefs: []
  type: TYPE_NORMAL
- en: This use of characters to represent byte values can be confusing. The prefix
    of b’ is our hint that we’re looking at bytes, not proper Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.4 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of ways to build strings of data. See the [Building complicated
    strings with f-strings](ch005_split_000.xhtml#x1-410004) and the [Building complicated
    strings from lists of strings](ch005_split_000.xhtml#x1-470005) recipes for examples
    of creating complex strings. The idea is that we might have an application that
    builds a complex string, and then we encode it into bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on UTF-8 encoding, see [https://en.wikipedia.org/wiki/UTF-8](https://en.wikipedia.org/wiki/UTF-8).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For general information on Unicode encodings, see [http://unicode.org/faq/utf_bom.html](http://unicode.org/faq/utf_bom.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.8 Decoding bytes – how to get proper characters from some bytes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we work with files that aren’t properly encoded? What do we do with
    files written in ASCII encoding?
  prefs: []
  type: TYPE_NORMAL
- en: A download from the internet is almost always in bytes—not characters. How do
    we decode the characters from that stream of bytes?
  prefs: []
  type: TYPE_NORMAL
- en: Also, when we use the subprocess module, the results of an OS command are in
    bytes. How can we recover proper characters?
  prefs: []
  type: TYPE_NORMAL
- en: Much of this is also relevant to the material in Chapter [11](ch015_split_000.xhtml#x1-61500011).
    We’ve included this recipe here because it’s the inverse of the previous recipe,
    [Encoding strings – creating ASCII and UTF-8 bytes](ch005_split_001.xhtml#x1-570007).
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we’re interested in offshore marine weather forecasts. Perhaps this
    is because we are departing the Chesapeake Bay for the Caribbean.
  prefs: []
  type: TYPE_NORMAL
- en: Are there any special warnings coming from the National Weather Services office
    in Wakefield, Virginia?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the link: [https://forecast.weather.gov/product.php?site=AKQ&product=SMW&issuedby=AKQ](https://forecast.weather.gov/product.php?site=AKQ&product=SMW&issuedby=AKQ).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can download this with Python’s urllib module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that we’ve enclosed the URI string in () and broken it into two separate
    string literals. Python will concatenate these two adjacent literals into a single
    string. We’ll look at this in some depth in Chapter [2](ch006_split_000.xhtml#x1-840002).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alterative, we can use programs like curl or wget to get this. At the
    OS Terminal prompt, we might run the following (long) command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Typesetting this book tends to break the command onto many lines. It’s really
    one very long line.
  prefs: []
  type: TYPE_NORMAL
- en: The code repository includes a sample file, ch01/Text Products for SMW Issued
    by AKQ.html.
  prefs: []
  type: TYPE_NORMAL
- en: 'The forecast_text value is a stream of bytes. It’s not a proper string. We
    can tell because it starts like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The data goes on for a while, providing details from the web page. Because the
    displayed value starts with b’, it’s bytes, not proper Unicode characters. It
    was probably encoded with UTF-8, which means some characters could have weird-looking
    \xnn escape sequences instead of proper characters. We want to have the proper
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: While this data has many easy-to-read characters, the b’ prefix shows that it’s
    a collection of byte values, not proper text. Generally, a bytes object behaves
    somewhat like a string object. Sometimes, we can work with bytes directly. Most
    of the time, we’ll want to decode the bytes and create proper Unicode characters
    from them.
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Determine the coding scheme if possible. In order to decode bytes to create
    proper Unicode characters, we need to know what encoding scheme was used. When
    we read XML documents, there’s a big hint provided within the document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When browsing web pages, there’s often a header containing this information:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sometimes, an HTML page may include this as part of the header:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In other cases, we’re left to guess. In the case of US weather data, a good
    first guess is UTF-8\. Another good guess is ISO-8859-1\. In some cases, the guess
    will depend on the language.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The codecs — Codec registry and base classes section of the Python Standard
    Library lists the standard encodings available. Decode the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The b’ prefix is no longer used to show that these are bytes. We’ve created
    a proper string of Unicode characters from the stream of bytes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If this step fails with an exception, we guessed wrong about the encoding. We
    need to try another encoding in order to parse the resulting document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since this is an HTML document, we should use Beautiful Soup to extract the
    data. See [http://www.crummy.com/software/BeautifulSoup/](http://www.crummy.com/software/BeautifulSoup/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, however, extract one nugget of information from this document without
    completely parsing the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us what we need to know: there are no warnings at this time. This
    doesn’t mean smooth sailing, but it does mean that there aren’t any major weather
    systems that could cause catastrophes.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Encoding strings – creating ASCII and UTF-8 bytes](ch005_split_001.xhtml#x1-570007)
    recipe for more information on Unicode and the different ways that Unicode characters
    can be encoded into streams of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: At the foundation of the OS, files and network connections are built up from
    bytes. It’s our software that decodes the bytes to discover the content. It might
    be characters, images, or sounds. In some cases, the default assumptions are wrong
    and we need to do our own decoding.
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.4 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we’ve recovered the string data, we have a number of ways of parsing or
    rewriting it. See the [String parsing with regular expressions](ch005_split_000.xhtml#x1-350003)
    recipe for examples of parsing a complex string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on encodings, see [https://en.wikipedia.org/wiki/UTF-8](https://en.wikipedia.org/wiki/UTF-8)
    and [http://unicode.org/faq/utf_bom.html](http://unicode.org/faq/utf_bom.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.9 Using tuples of items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What’s the best way to represent simple (x,y) and (r,g,b) groups of values?
    How can we keep things that are pairs, such as latitude and longitude, together?
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [String parsing with regular expressions](ch005_split_000.xhtml#x1-350003)
    recipe, we skipped over an interesting data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We had data that looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We parsed this into meaningful data using a regular expression, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The result is a tuple object with three pieces of data. There are lots of places
    where this kind of grouped data can come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll look at two aspects to this: putting things into tuples and getting things
    out of tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are lots of places where Python creates tuples of data for us. In the
    Getting ready section of the [String parsing with regular expressions](ch005_split_000.xhtml#x1-350003)
    recipe, we showed you how a regular expression match object will create a tuple
    of text that was parsed from a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create our own tuples, too. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Enclose the data in ().
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Separate the items with ,.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There’s an important special case for the one-tuple, or singleton. We have
    to include the , even when there’s only one item in the tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The () characters aren’t always required. There are a few times where we can
    omit them. It’s not a good idea to omit them.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s the comma that creates a tuple of values. This means we can see funny
    things when we have an extra comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The comma after 355 turns the value into a singleton tuple.
  prefs: []
  type: TYPE_NORMAL
- en: We can also create a tuple by conversion from another sequence. For example,
    tuple([355]) creates a singleton tuple from a singleton list.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting items from a tuple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The idea of a tuple is to be a container with a number of items that’s fixed
    by the problem domain: for example, for (red, green, blue) color numbers, the
    number of items is always three.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we’ve got an ingredient, and amount, and units. This must be
    a three-item collection. We can look at the individual items in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By index position; that is, positions are numbered starting with zero from
    the left:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using multiple assignment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tuples—like strings—are immutable. We can’t change the individual items inside
    a tuple. We use tuples when we want to keep the data together.
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tuples are one example of the more general Sequence class. We can do a few things
    with sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example tuple that we can work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some operations we can perform on this tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: How many items in t?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How many times does a particular value appear in t?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Which position has a particular value?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When an item doesn’t exist, we’ll get an exception:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Does a particular value exist?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 1.9.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tuple, like a string, is a sequence of items. In the case of a string, it’s
    a sequence of characters. In the case of a tuple, it’s a sequence of many things.
    Because they’re both sequences, they have some common features. We’ve noted that
    we can pluck out individual items by their index position. We can use the index()
    method to locate the position of an item.
  prefs: []
  type: TYPE_NORMAL
- en: The similarities end there. A string has many methods it can use to create a
    new string that’s a transformation of a string, plus methods to parse strings,
    plus methods to determine the content of the strings. A tuple doesn’t have any
    of these bonus features. It’s—perhaps—the simplest possible data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at one other sequence, the list, in the [Building complicated strings
    from lists of strings](ch005_split_000.xhtml#x1-470005) recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll also look at sequences in Chapter [4](ch008_split_000.xhtml#x1-2240004).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.10 Using NamedTuples to simplify item access in tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we worked with tuples, we had to remember the positions as numbers. When
    we use a (r,g,b) tuple to represent a color, can we use ”red” instead of zero,
    ”green” instead of 1, and ”blue” instead of 2?
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s continue looking at items in recipes. The regular expression for parsing
    the string had three attributes: ingredient, amount, and unit. We used the following
    pattern with names for the various substrings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting data tuple looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: While the matching between ingredient, amount, and unit is pretty clear, using
    something like the following isn’t ideal. What does 1 mean? Is it really the quantity?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: We want to define tuples with names, as well as positions.
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll use the NamedTuple class definition from the typing package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this base class definition, we can define our own unique tuples, with
    names for the items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create an instance of this unique kind of tuple by using the classname:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we want a value from the tuple, we can use a name instead of the position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 1.10.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NamedTuple class definition introduces a core concept from Chapter [7](ch011_split_000.xhtml#x1-3760007).
    We’ve extended the base class definition to add unique features for our application.
    In this case, we’ve named the three attributes each Ingredient tuple must contain.
  prefs: []
  type: TYPE_NORMAL
- en: Because a subclass of NamedTuple class is a tuple, the order of the attribute
    names is fixed. We can use a reference like the expression item_2[0] as well as
    the expression item_2.ingredient. Both names refer to the item in index 0 of the
    tuple, item_2.
  prefs: []
  type: TYPE_NORMAL
- en: The core tuple types can be called ”anonymous tuples” or maybe ”index-only tuples.”
    This can help to distinguish them from the more sophisticated ”named tuples” introduced
    through the typing module.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples are very useful as tiny containers of closely related data. Using the
    NamedTuple class definition makes them even easier to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can have a mixed collection of values in a tuple or a named tuple. We need
    to perform conversion before we can build the tuple. It’s important to remember
    that a tuple cannot ever be changed. It’s an immutable object, similar in many
    ways to the way strings and numbers are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we might want to work with amounts that are exact fractions. Here’s
    a more sophisticated definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'These objects require some care to create. If we’re using a bunch of strings,
    we can’t simply build this object from three string values; we need to convert
    the amount into a Fraction instance. Here’s an example of creating an item using
    a Fraction conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This tuple has a more useful value for the amount of each ingredient. We can
    now do mathematical operations on the amounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: It’s very handy to explicitly state the data type within the NamedTuple class
    definition. It turns out Python doesn’t use the type information directly. Other
    tools, for example, mypy, can check the type hints in a NamedTuple against the
    operations in the rest of the code to be sure they agree.
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at class definitions in Chapter [7](ch011_split_000.xhtml#x1-3760007).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community Discord space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
