- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1'
- en: Numbers, Strings, and Tuples
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数字、字符串和元组
- en: This chapter will look at some of the central types of Python objects. We’ll
    look at working with different kinds of numbers, working with strings, and using
    tuples. These are the simplest kinds of data that Python works with. In later
    chapters, we’ll look at data structures built on these foundations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨 Python 对象的一些核心类型。我们将探讨处理不同类型的数字、处理字符串和使用元组。这些是 Python 处理的最简单的数据类型。在后面的章节中，我们将探讨建立在这些基础上的数据结构。
- en: While these recipes start with a beginner’s level of understanding of Python
    3.12, they also provide some deeper background for those familiar with the language.
    In particular, we’ll look at some details of how numbers are represented internally,
    because this can help when confronted with more advanced numerical programming
    problems. This will help us distinguish the uses cases for the rich variety of
    numeric types.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些食谱从对 Python 3.12 的入门级理解开始，但它们也为熟悉该语言的人提供了一些更深入的知识背景。特别是，我们将探讨一些关于数字如何内部表示的细节，因为这在面对更高级的数值编程问题时可能会有所帮助。这将帮助我们区分丰富多样的数值类型的用例。
- en: We’ll also look at the two different division operators. These have distinct
    use cases, and we’ll look at one kind of algorithm that demands truncated division.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨两种不同的除法运算符。它们有特定的用例，我们将探讨一种需要截断除法的算法。
- en: When working with strings, there are several common operations that are important.
    We’ll explore some of the differences between bytes—as used by our OS files—and
    strings used to represent Unicode text. We’ll look at how we can exploit the full
    power of the Unicode character set.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理字符串时，有几个常见的操作很重要。我们将探讨字节（在我们的操作系统文件中使用）与用于表示 Unicode 文本的字符串之间的差异。我们将看看如何利用
    Unicode 字符集的全部力量。
- en: In this chapter, we’ll show the recipes as if we’re working from the >>> prompt
    in interactive Python. This is the prompt that’s provided when running python
    from the command line or using the Python console in many Integrated Development
    Environment (IDE) tools. This is sometimes called the read-evaluate-print loop
    (REPL). In later chapters, we’ll change the style so it looks more like a script
    file. One goal of this chapter is to encourage interactive exploration because
    it’s a great way to learn the language.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将像在交互式 Python 的 >>> 提示符下工作一样展示这些食谱。这是在命令行运行 python 或在许多集成开发环境（IDE）工具中的
    Python 控制台中提供的提示符。这有时被称为读取-评估-打印循环（REPL）。在后面的章节中，我们将改变风格，使其看起来更像脚本文件。本章的一个目标是通过交互式探索来鼓励学习，因为这是一种学习语言的好方法。
- en: 'We’ll cover these recipes to introduce basic Python data types:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍这些食谱来介绍基本的 Python 数据类型：
- en: '[Choosing between float, decimal, and fraction](ch005_split_000.xhtml#x1-180001)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在 float、decimal 和 fraction 之间进行选择](ch005_split_000.xhtml#x1-180001)'
- en: '[Choosing between true division and floor division](ch005_split_000.xhtml#x1-270002)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在真除法和地板除法之间进行选择](ch005_split_000.xhtml#x1-270002)'
- en: '[String parsing with regular expressions](ch005_split_000.xhtml#x1-350003)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用正则表达式解析字符串](ch005_split_000.xhtml#x1-350003)'
- en: '[Building complicated strings with f-strings](ch005_split_000.xhtml#x1-410004)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 f-strings 构建复杂的字符串](ch005_split_000.xhtml#x1-410004)'
- en: '[Building complicated strings from lists of strings](ch005_split_000.xhtml#x1-470005)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[从字符串列表构建复杂的字符串](ch005_split_000.xhtml#x1-470005)'
- en: '[Using the Unicode characters that aren’t on our keyboards](ch005_split_001.xhtml#x1-520006)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用键盘上没有的 Unicode 字符](ch005_split_001.xhtml#x1-520006)'
- en: '[Encoding strings – creating ASCII and UTF-8 bytes](ch005_split_001.xhtml#x1-570007)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编码字符串 – 创建 ASCII 和 UTF-8 字节](ch005_split_001.xhtml#x1-570007)'
- en: '[Decoding bytes – how to get proper characters from some bytes](ch005_split_001.xhtml#x1-620008)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[解码字节 – 如何从一些字节中获取正确的字符](ch005_split_001.xhtml#x1-620008)'
- en: '[Using tuples of items](ch005_split_001.xhtml#x1-670009)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用项目元组](ch005_split_001.xhtml#x1-670009)'
- en: '[Using NamedTuples to simplify item access in tuples](ch005_split_001.xhtml#x1-7500010)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 NamedTuples 简化元组中的项目访问](ch005_split_001.xhtml#x1-7500010)'
- en: We’ll start with numbers, work our way through strings, and end up working with
    simple combinations of objects in the form of tuples and NamedTuple objects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从数字开始，逐步过渡到字符串，最后以元组和 NamedTuple 对象的简单组合形式处理对象。
- en: 1.1 Choosing between float, decimal, and fraction
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1 在 float、decimal 和 fraction 之间进行选择
- en: 'Python offers several ways to work with rational numbers and approximations
    of irrational numbers. We have three basic choices:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了多种处理有理数和无理数近似值的方法。我们有三种基本选择：
- en: Float
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数
- en: Decimal
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小数
- en: Fraction
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分数
- en: When we have choices, it helps to have some criteria for making a selection.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有选择时，有一些标准来做出选择是有帮助的。
- en: 1.1.1 Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1.1 准备工作
- en: 'There are three general cases for expressions that involve numbers beyond integers,
    which are:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及到整数以外的数字的表达式有三个一般情况，它们是：
- en: 'Currency: Dollars, cents, euros, and so on. Currency generally has a fixed
    number of decimal places and rounding rules to properly quantize results.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 货币：美元、分、欧元等等。货币通常有固定的位数和小数点后舍入规则，以正确量化结果。
- en: 'Rational Numbers or Fractions: When we scale a recipe that serves eight, for
    example, down to five people, we’re doing fractional math using a scaling factor
    of ![5 8](img/file4.png).'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有理数或分数：当我们把为八人准备的食谱缩小到五人份时，例如，我们正在使用![5 8](img/file4.png)的缩放因子进行分数数学。
- en: 'Floating Point: This includes all other kinds of calculations. This also includes
    irrational numbers, like π, root extraction, and logarithms.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浮点数：这包括所有其他类型的计算。这也包括无理数，如π、根提取和对数。
- en: When we have one of the first two cases, we should avoid floating-point numbers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到前两种情况之一时，我们应该避免使用浮点数。
- en: 1.1.2 How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1.2 如何操作...
- en: We’ll look at each of the three cases separately.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别查看三个案例。
- en: Doing currency calculations
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进行货币计算
- en: 'When working with currency, we should always use the decimal module. If we
    try to use the values of Python’s built-in float type, we can run into problems
    with the rounding and truncation of numbers:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理货币时，我们应该始终使用decimal模块。如果我们尝试使用Python内置的float类型的值，我们可能会遇到数字舍入和截断的问题：
- en: 'To work with currency, import the Decimal class from the decimal module:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要处理货币，从decimal模块导入Decimal类：
- en: '[PRE0]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We need to create Decimal objects from strings or integers. In this case, we
    want 7.25%, which is ![7.25 100](img/file5.png). We can compute the value using
    Decimal objects:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要从字符串或整数创建Decimal对象。在这种情况下，我们想要7.25%，即![7.25 100](img/file5.png)。我们可以使用Decimal对象来计算这个值：
- en: '[PRE1]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We could also use Decimal(’0.0725’) instead of doing the division explicitly.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以使用Decimal('0.0725')而不是显式地进行除法。
- en: 'To round to the nearest penny, create a penny object:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要四舍五入到最近的便士，创建一个便士对象：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Quantize the result using the penny object:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用便士对象量化结果：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This uses the default rounding rule of ROUND_HALF_EVEN. The Decimal module
    offers other rounding variations. We might, for example, do something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用的是默认的ROUND_HALF_EVEN舍入规则。Decimal模块提供了其他舍入变体。例如，我们可能做如下操作：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This shows the consequences of using a different rounding rule.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了使用不同舍入规则的结果。
- en: Fraction calculations
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分数计算
- en: When we’re doing calculations that have exact fraction values, we can use the
    fractions module to create rational numbers. In this example, we want to scale
    a recipe for eight down to five people, using ![58](img/file6.png) of each ingredient.
    When the recipe calls for 2![1 2](img/file7.png) cups of rice, what does that
    scale down to?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行具有精确分数值的计算时，我们可以使用fractions模块来创建有理数。在这个例子中，我们想要将八人份的食谱缩小到五人份，使用![58](img/file6.png)的每种成分。当食谱要求2![1
    2](img/file7.png)杯大米时，这会缩小到多少？
- en: 'To work with fractions, we’ll do this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理分数，我们将这样做：
- en: 'Import the Fraction class from the fractions module:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从fractions模块导入Fraction类：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create Fraction objects from strings, integers, or pairs of integers. We created
    one fraction from a string, ’2.5’. We created the second fraction from a floating-point
    expression, 5 / 8\. This only works when the denominator is a power of 2:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串、整数或整数对创建Fraction对象。我们从一个字符串创建了一个分数，'2.5'。我们从一个浮点表达式创建第二个分数，5 / 8。这仅在分母是2的幂时才有效：
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can see that we’ll use almost a cup and a half of rice to scale the recipe
    for five people instead of eight. While float values will often be useful for
    rational fractions, they may not be exact unless the denominator is a power of
    two.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们将使用几乎一升半的大米来调整八人份的食谱，而不是五人份。虽然浮点数对于有理分数通常很有用，但除非分母是2的幂，否则它们可能不精确。
- en: Floating-point approximations
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点近似
- en: 'Python’s built-in float type can represent a wide variety of values. The trade-off
    here is that a float value is often an approximation. There may be a small discrepancy
    that reveals the differences between the implementation of float and the mathematical
    ideal of an irrational number:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Python内置的float类型可以表示各种值。这里的权衡是浮点值通常是一个近似值。可能会有一个小的差异，揭示了float的实现与无理数的数学理想之间的差异：
- en: 'To work with float, we often need to round values to make them look sensible.
    It’s important to recognize that all float calculations are an approximation:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了与浮点数一起工作，我们通常需要四舍五入值以使其看起来合理。重要的是要认识到所有浮点数计算都是近似值：
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Mathematically, the value should be 1\. Because of the approximations used,
    the computed result isn’t exactly 1\. We can use round(answer, 3) to round to
    three digits, creating a value that’s more useful:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数学上讲，值应该是1。由于使用了近似值，计算结果并不完全等于1。我们可以使用round(answer, 3)将其四舍五入到三位数字，创建一个更有用的值：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Approximations have a very important consequence.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 近似值有非常重要的后果。
- en: Don’t compare floating-point values for exact equality.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不要比较浮点数的精确相等性。
- en: Code that uses an exact == test between floating-point numbers has the potential
    to cause problems when two approximations differ by a single bit.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用精确的等于（==）测试浮点数的代码，当两个近似值只相差一个比特时，可能会引起问题的潜在风险。
- en: The float approximation rules come from the IEEE, and are not a unique feature
    of Python. Numerous programming languages work with float approximations and have
    identical behavior.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数近似规则来自IEEE，并不是Python的独特特性。许多编程语言都使用浮点数近似，并且具有相同的行为。
- en: 1.1.3 How it works...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1.3 它是如何工作的...
- en: 'For these numeric types, Python offers a variety of operators: +, -, *, /,
    //, %, and **. These are for addition, subtraction, multiplication, true division,
    truncated division, modulo, and raising to a power, respectively. We’ll look at
    the two division operators, / and //, in the [Choosing between true division and
    floor division](ch005_split_000.xhtml#x1-270002) recipe.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些数值类型，Python提供了各种运算符：+、-、*、/、//、%和**。这些分别用于加法、减法、乘法、真除法、截断除法、取模和求幂。我们将探讨两个除法运算符/和//，在[选择真除法和截断除法](ch005_split_000.xhtml#x1-270002)的食谱中。
- en: Python will do some conversions between the various numeric types. We can mix
    int and float values; the integers will be promoted to floating-point to provide
    the most accurate answer possible. Similarly, we can mix int and Fraction as well
    as mixing int and Decimal. Note that we cannot casually mix Decimal with float
    or Fraction; an explicit conversion function will be required.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Python会在各种数值类型之间进行一些转换。我们可以混合使用整型（int）和浮点型（float）值；整数将被提升为浮点数以提供尽可能精确的答案。同样，我们也可以混合使用整型与分数（Fraction）以及整型与十进制（Decimal）。请注意，我们无法随意混合十进制与浮点数或分数；需要显式转换函数。
- en: It’s important to note that float values are approximations. The Python syntax
    allows us to write floating-point values using base 10 digits; however, that’s
    not how values are represented internally.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，浮点数是近似值。Python语法允许我们使用十进制数字来编写浮点值；然而，这并不是值在内部表示的方式。
- en: 'We can write the value 8.066 × 10^(67) like this in Python:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Python中这样写出值8.066 × 10^(67)：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The actual value used internally will involve a binary approximation of the
    decimal value we wrote. The internal value for this example is this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 实际内部使用的值将涉及我们写入的十进制值的二进制近似。此示例的内部值如下：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The numerator is a big number, 6737037547376141\. The denominator is always
    2^(53). This is why values can get truncated.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 分子是一个大数，6737037547376141。分母始终是2的53次方。这就是为什么值可能会被截断。
- en: 'We can use the math.frexp() function to see these internal details of a number:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用math.frexp()函数来查看一个数字的内部细节：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The two parts are called the mantissa (or significand) and the exponent. If
    we multiply the mantissa by 2^(53), we always get a whole number, which is the
    numerator of the binary fraction.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这两部分被称为尾数（或有效数字）和指数。如果我们把尾数乘以2的53次方，我们总是得到一个整数，这是二进制分数的分子。
- en: Unlike the built-in float, a Fraction is an exact ratio of two integer values.
    We can create ratios that involve integers with a very large number of digits.
    We’re not limited by a fixed denominator.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与内置的浮点数不同，分数（Fraction）是两个整数值的精确比率。我们可以创建涉及具有非常大量数字的整数的比率。我们不受固定分母的限制。
- en: A Decimal value, similarly, is based on a very large integer value, as well
    as a scaling factor to determine where the decimal place goes. These numbers can
    be huge and won’t suffer from peculiar representation issues.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，十进制值基于一个非常大的整数值，以及一个缩放因子来确定小数点的位置。这些数字可以非常大，并且不会遭受奇特的表示问题。
- en: 1.1.4 There’s more...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1.4 更多...
- en: The Python math module contains several specialized functions for working with
    floating-point values. This module includes common elementary functions such as
    square root, logarithms, and various trigonometry functions. It also has some
    other functions such as gamma, factorial, and the Gaussian error function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Python的math模块包含用于处理浮点值的一些专用函数。此模块包括常见的初等函数，如平方根、对数和各种三角函数。它还有一些其他函数，如伽玛、阶乘和高斯误差函数。
- en: The math module includes several functions that can help us do more accurate
    floating-point calculations. For example, the math.fsum() function will compute
    a floating-point sum more carefully than the built-in sum() function. It’s less
    susceptible to approximation issues.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: math模块包含几个函数，可以帮助我们进行更精确的浮点计算。例如，math.fsum()函数将比内置的sum()函数更仔细地计算浮点数之和。它对近似问题不太敏感。
- en: 'We can also make use of the math.isclose() function to compare two floating-point
    values, an expression, and a literal 1.0, to see if they’re nearly equal:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用math.isclose()函数来比较两个浮点值、一个表达式和一个字面量1.0，以查看它们是否近似相等：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function provides us with a way to compare two floating-point numbers meaningfully
    for near-equality.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数为我们提供了一种有意义地比较两个浮点数近似的手段。
- en: Python also offers complex numbers. A complex number has a real and an imaginary
    part. In Python, we write 3.14+2.78j to represent the complex number 3.14 + 2.78![√
    --- − 1](img/file8.png). Python will comfortably convert between float and complex.
    We have the usual group of operators available for complex numbers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Python还提供了复数。复数有一个实部和虚部。在Python中，我们用3.14+2.78j来表示复数3.14 + 2.78![√ --- − 1](img/file8.png)。Python可以轻松地在浮点数和复数之间进行转换。我们有一组常用的运算符可用于复数。
- en: 'To support complex numbers, there’s the cmath package. The cmath.sqrt() function,
    for example, will return a complex value rather than raise an exception when extracting
    the square root of a negative number. Here’s an example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持复数，有cmath包。例如，cmath.sqrt()函数在提取负数的平方根时将返回一个复数值，而不是抛出异常。以下是一个示例：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This module is helpful when working with complex numbers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块在处理复数时很有帮助。
- en: 1.1.5 See also
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1.5 参见
- en: We’ll talk more about floating-point numbers and fractions in the [Choosing
    between true division and floor division](ch005_split_000.xhtml#x1-270002) recipe.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在[选择真除法和截断除法](ch005_split_000.xhtml#x1-270002)菜谱中更多地讨论浮点数和分数。
- en: See [https://en.wikipedia.org/wiki/IEEE_floating_point](https://en.wikipedia.org/wiki/IEEE_floating_point).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[https://en.wikipedia.org/wiki/IEEE_floating_point](https://en.wikipedia.org/wiki/IEEE_floating_point)。
- en: 1.2 Choosing between true division and floor division
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2 选择真除法和截断除法
- en: Python offers us two kinds of division operators. What are they, and how do
    we know which one to use? We’ll also look at the Python division rules and how
    they apply to integer values.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了两种除法运算符。它们是什么，我们如何知道该使用哪一个？我们还将探讨Python的除法规则以及它们如何应用于整数值。
- en: 1.2.1 Getting ready
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2.1 准备工作
- en: 'There are several general cases for division:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除法有几个通用情况：
- en: 'A div-mod pair: We want both parts – the quotient and the remainder. The name
    refers to the division and modulo operations combined together. We can summarize
    the quotient and remainder as q,r = (⌊![a b](img/file9.png)⌋,a mod b).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个除法-取模对：我们想要两个部分——商和余数。这个名字指的是将除法和取模操作组合在一起。我们可以将商和余数总结为q,r = (⌊![a b](img/file9.png)⌋,a
    mod b)。
- en: We often use this when converting values from one base into another. When we
    convert seconds into hours, minutes, and seconds, we’ll be doing a div-mod kind
    of division. We don’t want the exact number of hours; we want a truncated number
    of hours, and the remainder will be converted into minutes and seconds.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们经常在将一个基数的值转换为另一个基数时使用它。当我们把秒转换为小时、分钟和秒时，我们将进行一种除法-取模的运算。我们不需要确切的小时数；我们想要一个截断的小时数，余数将被转换为分钟和秒。
- en: 'The true value: This is a typical floating-point value; it will be a good approximation
    to the quotient. For example, if we’re computing an average of several measurements,
    we usually expect the result to be floating-point, even if the input values are
    all integers.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实值：这是一个典型的浮点值；它将是商的一个很好的近似。例如，如果我们正在计算几个测量的平均值，我们通常期望结果是浮点数，即使输入值都是整数。
- en: 'A rational fraction value: This is often necessary when working in American
    units of feet, inches, and cups. For this, we should be using the Fraction class.
    When we divide Fraction objects, we always get exact answers.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有理分数值：当在美国单位英尺、英寸和杯中工作时，这通常是必要的。为此，我们应该使用分数类。当我们除以分数对象时，我们总是得到精确的答案。
- en: We need to decide which of these cases apply, so we know which division operator
    to use.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要决定这些情况中的哪一个适用，以便我们知道要使用哪个除法运算符。
- en: 1.2.2 How to do it...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2.2 如何做...
- en: We’ll look at these three cases separately.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别查看这三个案例。
- en: Doing floor division
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行截断除法
- en: 'When we are doing the div-mod kind of calculations, we might use the floor
    division operator, //, and the modulo operator, %. The expression a % b gives
    us the remainder from an integer division of a // b. Or, we might use the divmod()
    built-in function to compute both at once:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行除法-模运算时，我们可能会使用整除运算符//和取模运算符%。表达式a % b给出了a // b的整数除法的余数。或者，我们可能会使用内置的divmod()函数同时计算这两个值：
- en: 'We’ll divide the number of seconds by 3,600 to get the value of hours. The
    modulo, or remainder in division, computed with the % operator, can be converted
    separately into minutes and seconds:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将秒数除以3,600以得到小时值。使用%运算符计算的模数，或除法中的余数，可以单独转换为分钟和秒：
- en: '[PRE14]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we’ll divide the number of seconds by 60 to get minutes; the remainder
    is the number of seconds less than 60:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将秒数除以60以得到分钟数；余数是小于60的秒数：
- en: '[PRE15]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here’s the alternative, using the divmod() function to compute quotient and
    modulo together:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一种方法，使用divmod()函数同时计算商和模数：
- en: 'Compute quotient and remainder at the same time:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时计算商和余数：
- en: '[PRE16]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Compute quotient and remainder again:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次计算商和余数：
- en: '[PRE17]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Doing true division
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行真正的除法
- en: 'Performing a true division calculation gives a floating-point approximation
    as the result. For example, about how many hours is 7,385 seconds? Here’s ![736805](img/file10.png)
    using the true division operator:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 执行真正的除法计算给出一个浮点近似值作为结果。例如，7,385秒大约是多少小时？这里使用真正的除法运算符：![736805](img/file10.png)
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We provided two integer values, but got a floating-point exact result. Consistent
    with our previous recipe, when using floating-point values, we rounded the result
    to avoid having to look at tiny error digits.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了两个整数值，但得到了一个浮点精确结果。与我们的先前的配方一致，当使用浮点值时，我们将结果四舍五入以避免查看微小的误差数字。
- en: Rational fraction calculations
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有理分数计算
- en: 'We can do division using Fraction objects and integers. This forces the result
    to be a mathematically exact rational number:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用分数对象和整数进行除法。这迫使结果成为一个数学上精确的有理数：
- en: 'Create at least one Fraction value:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少创建一个分数值：
- en: '[PRE19]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Use the Fraction value in a calculation. Any integer will be promoted to a
    Fraction:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在计算中使用分数值。任何整数都将提升为分数：
- en: '[PRE20]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The denominator of 720 doesn’t seem too meaningful. Working with fractions like
    this requires a bit of finesse to find useful denominators that makes sense to
    people. Otherwise, converting to a floating-point value can be useful.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 720的分母似乎不太有意义。使用这种分数需要一点技巧来找到对人们有意义的分母。否则，转换为浮点值可能是有用的。
- en: 'If necessary, convert the exact Fraction into a floating-point approximation:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，将精确的分数转换为浮点近似值：
- en: '[PRE21]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, we created a Fraction object for the total number of seconds. When we
    do arithmetic on fractions, Python will promote any integers to Fraction objects;
    this promotion means that the math is done as precisely as possible.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为总秒数创建了一个分数对象。当我们对分数进行算术运算时，Python会将任何整数提升为分数对象；这种提升意味着数学运算尽可能精确。
- en: 1.2.3 How it works...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2.3 它是如何工作的...
- en: 'Python has two division operators:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两个除法运算符：
- en: The / true division operator produces a true, floating-point result. It does
    this even when the two operands are integers. This is an unusual operator in this
    respect. All other operators preserve the type of the data. The true division
    operation – when applied to integers – produces a float result.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: / 真除法运算符产生一个真正的浮点结果。即使两个操作数都是整数，它也会这样做。在这方面，这是一个不寻常的运算符。所有其他运算符都保留数据类型。当应用于整数时，真正的除法操作产生一个浮点结果。
- en: 'The // truncated division operator always produces a truncated result. For
    two integer operands, this is the truncated quotient. When floating-point operands
    are used, this is a truncated floating-point result:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: // 截断除法运算符总是产生截断结果。对于两个整数操作数，这是截断商。当使用浮点操作数时，这是截断浮点结果：
- en: '[PRE22]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 1.2.4 See also
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2.4 参见
- en: For more on the choice between floating-point and fractions, see the [Choosing
    between float, decimal, and fraction](ch005_split_000.xhtml#x1-180001) recipe.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于浮点数和分数之间选择的信息，请参阅[选择浮点数、十进制和分数](ch005_split_000.xhtml#x1-180001)配方。
- en: See [PEP-238](https://www.python.org/dev/peps/pep-0238).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看[PEP-238](https://www.python.org/dev/peps/pep-0238)。
- en: 1.3 String parsing with regular expressions
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3 使用正则表达式进行字符串解析
- en: How do we decompose a complex string? What if we have complex, tricky punctuation?
    Or—worse yet—what if we don’t have punctuation, but have to rely on patterns of
    digits to locate meaningful information?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何分解一个复杂的字符串？如果我们有复杂、棘手的标点符号怎么办？或者——更糟糕的是——如果我们没有标点符号，但必须依赖数字的模式来定位有意义的信息呢？
- en: 1.3.1 Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3.1 准备工作
- en: The easiest way to decompose a complex string is by generalizing the string
    into a pattern and then writing a regular expression that describes that pattern.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 分解复杂字符串的最简单方法是将字符串泛化为一个模式，然后编写一个描述该模式的正则表达式。
- en: There are limits to the patterns that regular expressions can describe. When
    we’re confronted with deeply nested documents in a language like HTML, XML, or
    JSON, we often run into problems and be prohibited from using regular expressions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式可以描述的模式的数量是有限的。当我们面对像HTML、XML或JSON这样的深度嵌套文档时，我们经常会遇到问题，并被禁止使用正则表达式。
- en: The re module contains all of the various classes and functions we need to create
    and use regular expressions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: re模块包含我们创建和使用正则表达式所需的所有各种类和函数。
- en: 'Let’s say that we want to decompose text from a recipe website. Each line looks
    like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要分解来自食谱网站的文本。每一行看起来像这样：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We want to separate the ingredient from the measurements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将成分与测量值分开。
- en: 1.3.2 How to do it...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3.2 如何操作...
- en: 'To write and use regular expressions, we often do this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写和使用正则表达式，我们通常这样做：
- en: 'Generalize the example. In our case, we have something that we can generalize
    as:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将示例进行泛化。在我们的情况下，我们有一些可以泛化的东西：
- en: '[PRE24]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We’ve replaced literal text with a two-part summary: what it means and how
    it’s represented. For example, ingredient is represented as words, while amount
    is represented as digits. Import the re module:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将文本替换成了两部分总结：它的含义和它的表示方式。例如，成分用单词表示，而数量用数字表示。导入re模块：
- en: '[PRE25]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Rewrite the pattern into regular expression (RE) notation:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模式重写为正则表达式（RE）表示法：
- en: '[PRE26]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We’ve replaced representation hints such as ingredient words, a mixture of letters
    and spaces, with [\w\s]+. We’ve replaced amount digits with \d+. And we’ve replaced
    single spaces with \s+ to allow one or more spaces to be used as punctuation.
    We’ve left the colon in place because, in regular expression notation, a colon
    matches itself.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将成分词、字母和空格的混合表示法替换为[\w\s]+。我们将数量数字替换为\d+。我们将单个空格替换为\s+，以便可以使用一个或多个空格作为标点符号。我们保留了冒号，因为在正则表达式表示法中，冒号匹配自身。
- en: For each of the fields of data, we’ve used () to capture the data matching the
    pattern. We didn’t capture the colon or the spaces because we don’t need the punctuation
    characters.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于数据字段的每个字段，我们使用()捕获匹配模式的匹配数据。我们没有捕获冒号或空格，因为我们不需要标点符号字符。
- en: REs typically use a lot of \ characters. To make this work out nicely in Python,
    we almost always use raw strings. The r’ tells Python not to look at the \ characters
    and not to replace them with special characters that aren’t on our keyboards.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正则表达式通常使用很多\字符。为了在Python中使其工作得很好，我们几乎总是使用原始字符串。r’告诉Python不要查看\字符，也不要将它们替换成不在我们键盘上的特殊字符。
- en: 'Compile the pattern:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译模式：
- en: '[PRE27]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Match the pattern against the input text. If the input matches the pattern,
    we’ll get a match object that shows details of the substring that matched:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模式与输入文本进行匹配。如果输入与模式匹配，我们将得到一个匹配对象，它显示了匹配的子字符串的详细信息：
- en: '[PRE28]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Extract the named groups of characters from the match object:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从匹配对象中提取命名的字符组：
- en: '[PRE29]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Each group is identified by the order of the capture () portions of the regular
    expression. This gives us a tuple of the different fields captured from the string.
    We’ll return to the use of the tuple data structure in the [Using tuples of items](ch005_split_001.xhtml#x1-670009)
    recipe. This can be confusing in more complex regular expressions; there is a
    way to provide a name, instead of the numeric position, to identify a capture
    group.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组通过正则表达式的捕获 () 部分的顺序来标识。这给我们一个从字符串中捕获的不同字段的元组。我们将在[使用项目元组](ch005_split_001.xhtml#x1-670009)菜谱中返回到元组数据结构的使用。在更复杂的正则表达式中，这可能会令人困惑；有一种方法可以提供名称，而不是数字位置来标识捕获组。
- en: 1.3.3 How it works...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3.3 它是如何工作的...
- en: There are a lot of different kinds of string patterns that we can describe with
    regular expressions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用正则表达式描述很多不同种类的字符串模式。
- en: 'We’ve shown a number of character classes:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了多个字符类：
- en: \w matches any alphanumeric character (a to z, A to Z, 0 to 9).
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \w 匹配任何字母数字字符（a 到 z，A 到 Z，0 到 9）。
- en: \d matches any decimal digit.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \d 匹配任何十进制数字。
- en: \s matches any space or tab character.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \s 匹配任何空格或制表符字符。
- en: 'These classes also have inverses:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类也有它们的逆：
- en: \W matches any character that’s not a letter or a digit.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \W 匹配任何非字母或数字字符。
- en: \D matches any character that’s not a digit.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \D 匹配任何非数字字符。
- en: \S matches any character that’s not some kind of space or tab.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \S 匹配任何非空格或制表符字符。
- en: 'Many characters match themselves. Some characters, however, have a special
    meaning, and we have to use \ to escape from that special meaning:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 许多字符匹配自身。然而，一些字符具有特殊含义，我们必须使用 \ 来转义这种特殊含义：
- en: We saw that + as a suffix means to match one or more of the preceding patterns.
    \d+ matches one or more digits. To match an ordinary +, we need to use \+.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到，作为后缀的 + 表示匹配前面的一个或多个模式。\d+ 匹配一个或多个数字。要匹配普通的 +，我们需要使用 \+。
- en: We also have * as a suffix, which matches zero or more of the preceding patterns.
    \w* matches zero or more characters. To match a *, we need to use \*.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有 * 作为后缀，它匹配前面的零个或多个模式。\w* 匹配零个或多个字符。要匹配一个 *，我们需要使用 \*。
- en: We have ? as a suffix, which matches zero or one of the preceding expressions.
    This character is used in other places, and has a different meaning in the other
    context. We’ll see it used in ?P<name>...)|, where it is inside \verb|)— to define
    special properties for the grouping.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有 ? 作为后缀，它匹配前面的零个或一个表达式。这个字符在其他地方也被使用，但在其他上下文中具有不同的含义。我们将在 ?P<name>...)|, 其中它位于
    \verb|)— 内部，用来定义分组特殊属性。
- en: The . character matches any single character. To match a . specifically, we
    need to use \..
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: . 字符匹配任何单个字符。要特定地匹配一个 .，我们需要使用 \..
- en: 'We can create our own unique sets of characters using [] to enclose the elements
    of the set. We might have something like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 [] 来创建我们自己的唯一字符集。我们可能有一些像这样的东西：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This has a \w+ to match any number of alphanumeric characters. This will be
    collected into a group called name. It uses \s* to match an optional sequence
    of spaces. It matches any character in the set [=:]. Exactly one of the two characters
    in this set must be present. It uses \s* again to match an optional sequence of
    spaces. Finally, it uses .* to match everything else in the string. This is collected
    into a group named value.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个 \w+ 来匹配任意数量的字母数字字符。这将收集到一个名为 name 的组中。它使用 \s* 来匹配一个可选的空格序列。它匹配集合 [=:] 中的任何字符。这个集合中的两个字符中恰好有一个必须存在。它再次使用
    \s* 来匹配一个可选的空格序列。最后，它使用 .* 来匹配字符串中的其他所有内容。这被收集到一个名为 value 的组中。
- en: 'We can use this to parse strings, like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它来解析字符串，如下所示：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'By being flexible with the punctuation, we can make a program easier to use.
    We’ll tolerate any number of spaces, and either an = or a : as a separator.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '通过对标点符号的灵活性，我们可以使程序更容易使用。我们将容忍任意数量的空格，以及 = 或 : 作为分隔符。'
- en: 1.3.4 There’s more...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3.4 更多...
- en: 'A long regular expression can be awkward to read. We have a clever Pythonic
    trick for presenting an expression in a way that’s much easier to read:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个长的正则表达式可能难以阅读。我们有一个巧妙的 Pythonic 方法来以一种更容易阅读的方式呈现表达式：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This leverages three syntax rules:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这利用了三个语法规则：
- en: A statement isn’t finished until the () characters match.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个语句只有在 () 字符匹配后才会完成。
- en: Adjacent string literals are silently concatenated into a single long string.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相邻的字符串字面量会被静默地连接成一个单个的长字符串。
- en: 'Anything between # and the end of the line is a comment, and is ignored.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '任何在 # 和行尾之间的内容都是一个注释，并且会被忽略。'
- en: We’ve put Python comments after the important clauses in our regular expression.
    This can help us understand what we did, and perhaps help us diagnose problems
    later.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的正则表达式的重要子句后面添加了Python注释。这可以帮助我们理解我们做了什么，也许有助于我们以后诊断问题。
- en: 'We can also use the regular expression’s ”verbose” mode to add gratuitous whitespace
    and comments inside a regular expression string. To do this, we must use re.X
    as an option when compiling a regular expression to make whitespace and comments
    possible. This revised syntax looks like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用正则表达式的“详细”模式在正则表达式字符串内添加多余的空白和注释。为此，我们必须在编译正则表达式时使用 re.X 作为选项，以便使空白和注释成为可能。这种修改后的语法看起来像这样：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can either break the pattern up into separate string components, or make
    use of extended syntax to make the regular expression more readable. The benefit
    of providing names shows up when we use the groupdict() method of the match object
    to extract parsed values by the name associated with the pattern being captured.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将模式分解为单独的字符串组件，或者使用扩展语法使正则表达式更易于阅读。提供名称的好处在于，当我们使用 match 对象的 groupdict()
    方法通过捕获模式的关联名称提取解析值时。
- en: 1.3.5 See also
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3.5 相关阅读
- en: The [Decoding bytes – how to get proper characters from some bytes](ch005_split_001.xhtml#x1-620008)
    recipe.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[解码字节 – 如何从一些字节中获取正确的字符](ch005_split_001.xhtml#x1-620008) 的配方。'
- en: There are many books on regular expressions and Python regular expressions in
    particular, like Mastering Python Regular Expressions [https://www.packtpub.com/application-development/mastering-python-regular-expressions](https://www.packtpub.com/application-development/mastering-python-regular-expressions).
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于正则表达式和Python正则表达式的书籍有很多，比如《精通Python正则表达式》[https://www.packtpub.com/application-development/mastering-python-regular-expressions](https://www.packtpub.com/application-development/mastering-python-regular-expressions)。
- en: 1.4 Building complicated strings with f-strings
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.4 使用 f 字符串构建复杂的字符串
- en: Creating complex strings is, in many ways, the polar opposite of parsing a complex
    string. We generally use a template with substitution rules to put data into a
    more complex format.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，创建复杂的字符串与解析复杂的字符串正好相反。我们通常使用模板和替换规则来将数据放入更复杂的格式中。
- en: 1.4.1 Getting ready
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4.1 准备工作
- en: 'Let’s say we have pieces of data that we need to turn into a nicely formatted
    message. We might have data that includes the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一些需要转换为格式化消息的数据。我们可能有的数据包括以下内容：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And we’d like a line that looks like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望得到一条看起来像这样的线：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 1.4.2 How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4.2 如何做...
- en: 'Create an f-string for the result, replacing all of the data items with placeholders.
    Inside each placeholder, put a variable name (or an expression.) Note that the
    string uses the prefix of f’. This prefix creates a sophisticated string object
    where values are interpolated into the template when the string is used:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为结果创建一个 f 字符串，将所有数据项替换为占位符。在每个占位符内部，放置一个变量名（或一个表达式）。请注意，字符串使用 f' 前缀。这个前缀创建了一个复杂的字符串对象，其中值在字符串被使用时被插入到模板中：
- en: '[PRE36]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For each name or expression, an optional data type can be appended to the names
    in the template string. The basic data type codes are:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个名称或表达式，可以在模板字符串中的名称后附加一个可选的数据类型。基本数据类型代码如下：
- en: s for string
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: s 用于字符串
- en: d for decimal number
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: d 用于十进制数字
- en: f for floating-point number
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: f 用于浮点数
- en: 'It would look like this:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它看起来会是这样：
- en: '[PRE37]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Because the book’s margins are narrow, the string has been broken to
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于这本书的边距很窄，字符串已经被断开。
- en: fit on the page. It’s a single (very wide) line of code.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 适应页面。这是一行（非常宽）的代码。
- en: 'Add length information where required. Length is not always required, and in
    some cases, it’s not even desirable. In this example, though, the length information
    ensures that each message has a consistent format. For strings and decimal numbers,
    prefix the format with the length like this: 19s or 3d. For floating-point numbers,
    use a two-part prefix like 5.2f to specify the total length of five characters,
    with two to the right of the decimal point. Here’s the whole format:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在需要的地方添加长度信息。长度信息并不总是必需的，在某些情况下，甚至可能不希望有。然而，在这个例子中，长度信息确保了每条消息都有统一的格式。对于字符串和十进制数字，使用以下格式添加长度：19s
    或 3d。对于浮点数，使用两部分的格式前缀，如 5.2f，以指定总长度为五个字符，其中小数点右边有两个字符。以下是整个格式：
- en: '[PRE38]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 1.4.3 How it works...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4.3 它是如何工作的...
- en: F-strings can do a lot of relatively sophisticated string assembly by interpolating
    data into a template. There are a number of conversions available.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: F 字符串可以通过将数据插入模板来实现许多相对复杂的字符串组装。有几种转换可用。
- en: 'We’ve seen three of the formatting conversions—s, d, f—but there are many others.
    Details can be found in the Formatted string literals section of the Python Standard
    Library: [https://docs.python.org/3/reference/lexical_analysis.html\#formatted-string-literals](https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了三种格式化转换——s、d、f，但还有很多其他的。详细信息可以在Python标准库的格式化字符串字面量部分找到：[https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals](https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals)。
- en: 'Here are some of the format conversions we might use:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些我们可能使用的格式转换：
- en: b is for binary, base 2.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: b是用于二进制，基数2。
- en: c is for Unicode character. The value must be a number, which is converted into
    a character. Often, we use hexadecimal numbers for these characters, so you might
    want to try values such as 0x2661 through 0x2666 to see interesting Unicode glyphs.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: c是用于Unicode字符。值必须是一个数字，它将被转换成一个字符。通常，我们使用十六进制数字来表示这些字符，所以你可能想尝试0x2661到0x2666之间的值来查看有趣的Unicode符号。
- en: d is for decimal numbers.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: d是用于十进制数。
- en: E and e are for scientific notations. 6.626E-34 or 6.626e-34, depending on which
    E or e character is used.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: E和e是用于科学记数法。6.626E-34或6.626e-34，具体取决于使用的E或e字符。
- en: F and f are for floating-point. For not a number, the f format shows lowercase
    nan; the F format shows uppercase NAN.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F和f是用于浮点数。对于非数字，f格式显示小写的nan；F格式显示大写的NAN。
- en: G and g are for general use. This switches automatically between E and F (or
    e and f) to keep the output in the given sized field. For a format of 20.5G, up
    to 20-digit numbers will be displayed using F formatting. Larger numbers will
    use E formatting.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: G和g是用于通用。这会自动在E和F（或e和f）之间切换，以保持输出在给定的字段大小内。对于20.5G的格式，最多显示20位数字，使用F格式。更大的数字将使用E格式。
- en: n is for locale-specific decimal numbers. This will insert , or . characters,
    depending on the current locale settings. The default locale may not have 1,000
    separators defined. For more information, see the locale module.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: n是用于特定地区的十进制数字。这将插入逗号或点字符，具体取决于当前的地区设置。默认地区可能没有定义1,000分隔符。更多信息，请参阅地区模块。
- en: o is for octal, base 8.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: o是用于八进制，基数8。
- en: s is for string.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: s是用于字符串。
- en: X and x are for hexadecimal, base 16\. The digits include uppercase A-F and
    lowercase a-f, depending on which X or x format character is used.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X和x是用于十六进制，基数16。数字包括大写A-F和小写a-f，具体取决于使用的X或x格式字符。
- en: '% is for percentage. The number is multiplied by 100 and the output includes
    a % character.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%是用于百分比。数字乘以100，输出包括一个%字符。'
- en: 'We have a number of prefixes we can use for these different types. The most
    common one is the length. We might use {name:5d} to put in a 5-digit number. There
    are several prefixes for the preceding types:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多个前缀来表示这些不同类型。最常见的一个是长度。我们可以使用{name:5d}来插入一个5位数。对于前述类型，有几个前缀可以使用：
- en: 'Fill and alignment: We can specify a specific filler character (space is the
    default) and an alignment. Numbers are generally aligned to the right and strings
    to the left. We can change that using <, >, or ^. This forces left alignment,
    right alignment, or centering, respectively. There’s a peculiar = alignment that’s
    used to put padding after a leading sign.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充和对齐：我们可以指定一个特定的填充字符（默认为空格）和对齐方式。数字通常右对齐，字符串左对齐。我们可以使用<、>或^来改变这一点。这分别强制左对齐、右对齐或居中对齐。还有一个特殊的=对齐，用于在符号前填充。
- en: 'Sign: The default rule is a leading negative sign where needed. We can use
    + to put a sign on all numbers, - to put a sign only on negative numbers, and
    a space to use a space instead of a plus for positive numbers. In scientific output,
    we often use {value:5.3f}. The space makes sure that room is left for the sign,
    ensuring that all the decimal points line up nicely.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号：默认规则是在需要的地方有一个前导负号。我们可以使用+来给所有数字加上符号，-来只给负数加上符号，或者使用空格来用空格代替正数的加号。在科学输出中，我们经常使用{value:5.3f}。空格确保留出空间给符号，确保所有的小数点对齐得很好。
- en: 'Alternate form: We can use the # to get an alternate form. We might have something
    like {0:#x}, {0:#o}, or {0:#b} to get a prefix on hexadecimal, octal, or binary
    values. With a prefix, the numbers will look like 0xnnn, 0onnn, or 0bnnn. The
    default is to omit the two-character prefix.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交替形式：我们可以使用#来获取交替形式。我们可能有一些像{0:#x}、{0:#o}或{0:#b}这样的格式，以在十六进制、八进制或二进制值上添加前缀。带有前缀的数字将看起来像0xnnn、0onnn或0bnnn。默认情况下，省略两个字符的前缀。
- en: 'Leading zero: We can include 0 to get leading zeros to fill in the front of
    a number. Something like {code:08x} will produce a hexadecimal value with leading
    zeroes to pad it out to eight characters.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领先零：我们可以包含 0 以在数字前面填充前导零。例如，{code:08x} 将生成一个填充到八位的十六进制值。
- en: 'Width and precision: For integer values and strings, we only provide the width.
    For floating-point values, we often provide width.precision.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宽度和精度：对于整数值和字符串，我们只提供宽度。对于浮点值，我们通常提供宽度.精度。
- en: 'There are some times when we won’t use a {name:format} specification. Sometimes,
    we’ll need to use a {name!conversion} specification. There are only three conversions
    available:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们不会使用 {name:format} 说明符。有时，我们需要使用 {name!conversion} 说明符。只有三种转换可用：
- en: '{name!r} shows the representation that would be produced by repr(name).'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '{name!r} 显示由 repr(name) 生成的表示。'
- en: '{name!s} shows the string value that would be produced by str(name); this is
    the default behavior if you don’t specify any conversion. Using !s explicitly
    lets you add string-type format specifiers.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '{name!s} 显示由 str(name) 生成的字符串值；这是如果不指定任何转换时的默认行为。使用 !s 明确地允许你添加字符串类型格式说明符。'
- en: '{name!a} shows the ASCII value that would be produced by ascii(name).'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '{name!a} 显示由 ascii(name) 生成的 ASCII 值。'
- en: 'Additionally, there’s a handy debugging format specifier available. We can
    include a trailing equals sign, =, to get a handy dump of a variable or expression.
    The following example uses both forms:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有一个方便的调试格式说明符可用。我们可以在变量或表达式后包含一个尾随等号，=，以获取一个方便的变量或表达式转储。以下示例使用了这两种形式：
- en: '[PRE39]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The f-string showed the value of the variable named value and the result of
    an expression, 2**7+1.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: f-string 显示了名为 value 的变量的值以及表达式 2**7+1 的结果。
- en: In Chapter [7](ch011_split_000.xhtml#x1-3760007), we’ll leverage the idea of
    the {name!r} format specification to simplify displaying information about related
    objects.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [7](ch011_split_000.xhtml#x1-3760007) 章，我们将利用 {name!r} 格式说明符的想法来简化显示有关相关对象的信息。
- en: 1.4.4 There’s more...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4.4 更多...
- en: The f-string processing relies on the string format() method. We can leverage
    this method and the related format_map() method for cases where we have more complex
    data structures.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: f-string 处理依赖于字符串的 format() 方法。我们可以利用这个方法和相关的 format_map() 方法来处理更复杂的数据结构。
- en: 'Looking forward to Chapter [5](ch009.xhtml#x1-2890005), we might have a dictionary
    where the keys are simple strings that fit with the format_map() rules:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 期待第 [5](ch009.xhtml#x1-2890005) 章，我们可能有一个字典，其键是符合 format_map() 规则的简单字符串：
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We’ve created a dictionary object, data, that contains a number of values with
    keys that are valid Python identifiers: id, location, max_temp, min_temp, and
    precipitation. We can then use this dictionary with the format_map() method to
    extract values from the dictionary using the keys.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含多个值的字典对象，data，其键是有效的 Python 标识符：id、location、max_temp、min_temp 和 precipitation。然后我们可以使用这个字典和
    format_map() 方法来使用键从字典中提取值。
- en: Note that the formatting template here is not an f-string. It doesn’t have the
    f" prefix. Instead of using the automatic formatting features of an f-string,
    we’ve done the interpolation ”the hard way” using the format_map() method of an
    f-string.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里的格式模板不是 f-string。它没有 f" 前缀。我们不是使用 f-string 的自动格式化功能，而是通过 f-string 的 format_map()
    方法“硬编码”了插值。
- en: 1.4.5 See also
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4.5 参见
- en: 'More details can be found in the Formatted string literals section of the Python
    Standard Library: [https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals](https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals).'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多详细信息可以在 Python 标准库的格式化字符串字面量部分找到：[https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals](https://docs.python.org/3/reference/lexical_analysis.html#formatted-string-literals)。
- en: 1.5 Building complicated strings from lists of strings
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.5 从字符串列表构建复杂的字符串
- en: How can we make complicated changes to an immutable string? Can we assemble
    a string from individual characters?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何对不可变的字符串进行复杂更改？我们能从单个字符组装一个字符串吗？
- en: In most cases, the recipes we’ve already seen give us a number of tools for
    creating and modifying strings. There are yet more ways in which we can tackle
    the string manipulation problem. In this recipe, we’ll look at using a list object
    as a way to decompose and rebuild a string. This will dovetail with some of the
    recipes in Chapter [4](ch008_split_000.xhtml#x1-2240004).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们之前看到的食谱为我们提供了创建和修改字符串的许多工具。我们还有更多处理字符串操作问题的方法。在这个食谱中，我们将探讨使用列表对象作为分解和重建字符串的方法。这将与第[4](ch008_split_000.xhtml#x1-2240004)章中的一些食谱相呼应。
- en: 1.5.1 Getting ready
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5.1 准备工作
- en: 'Here’s a string that we’d like to rearrange:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们想要重新排列的字符串：
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We’d like to do two transformations:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要进行两种转换：
- en: Remove the part before :.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除冒号前的部分。
- en: Replace the punctuation with _ and make all the characters lowercase.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用下划线替换标点符号，并将所有字符转换为小写。
- en: 'We’ll make use of the string module:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用字符串模块：
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This has two important constants:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个重要的常数：
- en: string.whitespace lists all of the whitespace characters that are also part
    of ASCII, including space and tab.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: string.whitespace列出了所有也是ASCII一部分的空白字符，包括空格和制表符。
- en: string.punctuation lists punctuation marks that are also part of ASCII. Unicode
    has a large domain of punctuation marks. This is a widely used subset.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: string.punctuation列出了也是ASCII一部分的标点符号。Unicode有大量的标点符号。这是一个广泛使用的子集。
- en: 1.5.2 How to do it...
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5.2 如何做...
- en: 'We can work with a string exploded into a list. We’ll look at lists in more
    depth in Chapter [4](ch008_split_000.xhtml#x1-2240004):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以处理分解成列表的字符串。我们将在第[4](ch008_split_000.xhtml#x1-2240004)章中更深入地探讨列表：
- en: 'Explode the string into a list object:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字符串分解成列表对象：
- en: '[PRE43]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Find the partition character. The index() method for a list has the same semantics
    as the index() method has for a string. It locates the position with the given
    value:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到分隔字符。列表的index()方法与字符串的index()方法具有相同的语义。它定位给定值的索引位置：
- en: '[PRE44]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Delete the characters that are no longer needed. The del statement can remove
    items from a list. Unlike strings, lists are mutable data structures:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除不再需要的字符。del语句可以从列表中删除项。与字符串不同，列表是可变的数据结构：
- en: '[PRE45]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Replace punctuation by stepping through each position. In this case, we’ll
    use a for statement to visit every index in the string:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过遍历每个位置来替换标点符号。在这种情况下，我们将使用一个for语句来访问字符串中的每个索引：
- en: '[PRE46]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The expression range(len(title_list)) generates all of the values between 0
    and len(title_list)-1\. This assures us that the value of position will be each
    value index in the list. Join the list of characters to create a new string. It
    seems a little odd to use a zero-length string, ’’, as a separator when concatenating
    strings together. However, it works perfectly:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表达式range(len(title_list))生成介于0和len(title_list)-1之间的所有值。这确保了position的值将是列表中的每个索引值。将字符列表连接起来创建一个新的字符串。当将字符串连接在一起时，使用零长度字符串''作为分隔符看起来有点奇怪。然而，它工作得很好：
- en: '[PRE47]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We assigned the resulting string back to the original variable. The original
    string object, which had been referred to by that variable, is no longer needed:
    it’s automatically removed from memory (this is known as garbage collection).
    The new string object replaces the value of the variable.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成的字符串重新赋值给原始变量。原始字符串对象，该变量曾引用它，不再需要：它将自动从内存中删除（这被称为垃圾回收）。新的字符串对象替换了变量的值。
- en: 1.5.3 How it works...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5.3 它是如何工作的...
- en: This is a change in representation trick. Since a string is immutable, we can’t
    update it. We can, however, convert it into a mutable form; in this case, a list.
    We can make whatever changes are required to the mutable list object. When we’re
    done, we can change the representation from a list back to a string and replace
    the original value of the variable.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个表示技巧的改变。由于字符串是不可变的，我们无法更新它。然而，我们可以将其转换为可变形式；在这种情况下，是一个列表。我们可以对可变列表对象进行所需的任何更改。当我们完成时，我们可以将表示从列表转换回字符串，并替换原始变量的值。
- en: Lists provide some features that strings don’t have. Conversely, strings provide
    a number of features lists don’t have. As an example, we can’t convert a list
    into lowercase the way we can convert a string.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 列表提供了一些字符串没有的特性。反过来，字符串也提供了一些列表没有的特性。例如，我们不能像转换字符串那样将列表转换为小写。
- en: 'There’s an important trade-off here:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要的权衡：
- en: Strings are immutable, which makes them very fast. Strings are focused on Unicode
    characters. When we look at mappings and sets, we can use strings as keys for
    mappings and items in sets because the value is immutable.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists are mutable. Operations are slower. Lists can hold any kind of item. We
    can’t use a list as a key for a mapping or an item in a set because the list value
    could change.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Strings and lists are both specialized kinds of sequences. Consequently, they
    have a number of common features. The basic item indexing and slicing features
    are shared. Similarly, a list uses the same kind of negative index values that
    a string does: the expression list[-1] is the last item in a list object.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: We’ll return to mutable data structures in Chapter [4](ch008_split_000.xhtml#x1-2240004).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 1.5.4 See also
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we need to build a string, and then convert it into bytes. See the
    [Encoding strings – creating ASCII and UTF-8 bytes](ch005_split_001.xhtml#x1-570007)
    recipe for how we can do this.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other times, we’ll need to convert bytes into a string. See the [Decoding bytes
    – how to get proper characters from some bytes](ch005_split_001.xhtml#x1-620008)
    recipe for more information.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.6 Using the Unicode characters that aren’t on our keyboards
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A big keyboard might have almost 100 individual keys. Often, fewer than 50 of
    these keys are letters, numbers, and punctuation. At least a dozen are function
    keys that do things other than simply insert letters into a document. Some of
    the keys are different kinds of modifiers that are meant to be used in conjunction
    with another key—for example, we might have Shift, Ctrl, Option, and Command.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Most operating systems will accept simple key combinations that create about
    100 or so characters. More elaborate key combinations may create another 100 or
    so less popular characters. This isn’t even close to covering the vast domain
    of characters from the world’s alphabets. And there are icons, emojis, and dingbats
    galore in our computer fonts. How do we get to all of those glyphs?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.1 Getting ready
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python works in Unicode. There are thousands of individual Unicode characters
    available.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: We can see all the available characters at [https://en.wikipedia.org/wiki/List_of_Unicode_characters](https://en.wikipedia.org/wiki/List_of_Unicode_characters),
    as well as at [http://www.unicode.org/charts/](http://www.unicode.org/charts/).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: We’ll need the Unicode character number. We may also want the Unicode character
    name.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'A given font on our computer may not be designed to provide glyphs for all
    of those characters. In particular, Windows computer fonts may have trouble displaying
    some of these characters. Using the following Windows command to change to code
    page 65001 is sometimes necessary:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Linux and macOS rarely have problems with Unicode characters.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.2 How to do it...
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python uses escape sequences to extend the ordinary characters we can type
    to cover the vast space of Unicode characters. Each escape sequence starts with
    a \ character. The next character tells us exactly which of the Unicode characters
    to create. Locate the character that’s needed. Get the name or the number. The
    numbers are always given as hexadecimal, base 16\. Websites describing Unicode
    often write the character as U+2680\. The name might be DIE FACE-1\. Use \unnnn
    with up to a four-digit number, nnnn. Or, use \N{name} with the spelled-out name.
    If the number is more than four digits, use \Unnnnnnnn with the number padded
    out to exactly eight digits:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用转义序列来扩展我们可以输入的普通字符，以覆盖 Unicode 字符的广阔空间。每个转义序列都以一个 \ 字符开始。下一个字符告诉我们需要创建哪个
    Unicode 字符。找到所需的字符。获取名称或数字。数字总是以十六进制形式给出，基数为 16。描述 Unicode 的网站通常将字符写作 U+2680。名称可能是
    DIE FACE-1。使用 \unnnn，其中 nnnn 是最多四位数的数字。或者，使用 \N{name}，其中包含完整的名称。如果数字超过四位，使用 \Unnnnnnnn，将数字填充到正好八位：
- en: '[PRE49]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Yes, we can include a wide variety of characters in Python output. To place
    a \ in the string without the following characters being part of an escape sequence,
    we need to use \\. For example, we might need this for Windows file paths.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以在 Python 输出中包含各种字符。要在字符串中放置一个反斜杠（\）而不让后面的字符成为转义序列的一部分，我们需要使用\\. 例如，我们可能需要这样做来表示
    Windows 文件路径。
- en: 1.6.3 How it works...
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6.3 它是如何工作的...
- en: Python uses Unicode internally. The 128 or so characters we can type directly
    using the keyboard all have handy internal Unicode numbers.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在内部使用 Unicode。我们可以直接使用键盘输入的 128 个左右字符都有方便的内部 Unicode 数字。
- en: 'When we write:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们写：
- en: '[PRE50]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Python treats it as shorthand for this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Python 将其视为以下简写：
- en: '[PRE51]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Once we get beyond the characters on our keyboards, the remaining thousands
    of characters are identified only by their number.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们超出键盘上的字符，剩下的数千个字符仅通过它们的数字来识别。
- en: When the string is being compiled by Python, \uxxxx, \Uxxxxxxxx, and \N{name}
    are all replaced by the proper Unicode character. If we have something syntactically
    wrong—for example, \N{name with no closing }—we’ll get an immediate error from
    Python’s internal syntax checking.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当字符串被 Python 编译时，\uxxxx、\Uxxxxxxxx 和 \N{name} 都会被替换为正确的 Unicode 字符。如果我们有语法错误——例如，\N{name
    with no closing }——Python 的内部语法检查会立即报错。
- en: Regular expressions use a lot of \ characters and that we specifically do not
    want Python’s normal compiler to touch them; we used the r’ prefix on a regular
    expression string to prevent \ from being treated as an escape and possibly converted
    into something else. To use the full domain of Unicode characters, we cannot avoid
    using \ as an escape.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式使用了很多 \ 字符，并且我们明确不希望 Python 的正常编译器触及它们；我们在正则表达式字符串上使用了 r’ 前缀，以防止 \ 被视为转义并可能被转换为其他内容。要使用
    Unicode 字符的全域，我们无法避免使用 \ 作为转义。
- en: 'What if we need to use Unicode in a regular expression? We’ll need to use \\
    all over the place in the regular expression. We might see something like this:
    ’\\w+[\u2680\u2681\u2682\u2683\u2684\u2685]\\d+’.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在正则表达式中使用 Unicode，我们需要在正则表达式中到处使用 \\。我们可能会看到类似这样的：’\\w+[\u2680\u2681\u2682\u2683\u2684\u2685]\\d+’。
- en: We couldn’t use the r’ prefix on the string because we needed to have the Unicode
    escapes processed. This forced us to use \\ for elements of the regular expression.
    We used \uxxxx for the Unicode characters that are part of the pattern. Python’s
    internal compiler will replace \uxxxx with Unicode characters and \\w will become
    the required \w internally.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在字符串上使用 r’ 前缀，因为我们需要处理 Unicode 转义。这迫使我们使用 \\ 作为正则表达式的元素。我们使用了 \uxxxx 来表示模式中的
    Unicode 字符。Python 的内部编译器会将 \uxxxx 替换为 Unicode 字符，而 \\w 将在内部变为所需的 \w。
- en: 'When we look at a string at the >>> prompt, Python will display the string
    in its canonical form. Python prefers to display strings with ’ as a delimiter,
    using " when the string contains a ’. We can use either ’ or " for a string delimiter
    when writing code. Python doesn’t generally display raw strings; instead, it puts
    all of the necessary escape sequences back into the string:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 >>> 提示符下查看字符串时，Python 会以规范形式显示字符串。Python 倾向于使用单引号（'）作为分隔符，当字符串包含单引号时使用双引号（"）。在编写代码时，我们可以使用单引号或双引号作为字符串分隔符。Python
    通常不会显示原始字符串；相反，它会将所有必要的转义序列放回字符串中：
- en: '[PRE52]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We provided a string in raw form. Python displayed it in canonical form.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个原始格式的字符串。Python 以规范形式显示了它。
- en: 1.6.4 See also
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6.4 参见
- en: In the [Encoding strings – creating ASCII and UTF-8 bytes](ch005_split_001.xhtml#x1-570007)
    and the [Decoding bytes – how to get proper characters from some bytes](ch005_split_001.xhtml#x1-620008)
    recipes, we’ll look at how Unicode characters are converted into sequences of
    bytes so we can write them to a file. We’ll look at how bytes from a file (or
    downloaded from a website) are turned into Unicode characters so they can be processed.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[编码字符串 – 创建ASCII和UTF-8字节](ch005_split_001.xhtml#x1-570007)和[解码字节 – 如何从某些字节中获取正确的字符](ch005_split_001.xhtml#x1-620008)的菜谱中，我们将探讨Unicode字符是如何转换成字节序列的，这样我们就可以将它们写入文件。我们还将探讨文件中的字节（或从网站下载的）是如何转换成Unicode字符，以便进行处理。
- en: 'If you’re interested in history, you can read up on ASCII and EBCDIC and other
    old-fashioned character codes here: [http://www.unicode.org/charts/](http://www.unicode.org/charts/).'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你对历史感兴趣，你可以在这里了解ASCII和EBCDIC以及其他旧式字符编码：[http://www.unicode.org/charts/](http://www.unicode.org/charts/)。
- en: 1.7 Encoding strings – creating ASCII and UTF-8 bytes
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.7 编码字符串 – 创建ASCII和UTF-8字节
- en: Our computer files are bytes. When we upload or download from the internet,
    the communication works in bytes. A byte only has 256 distinct values. Our Python
    characters are Unicode. There are a lot more than 256 Unicode characters.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算机文件是字节。当我们从互联网上传或下载时，通信是以字节为单位的。一个字节只有256个不同的值。我们的Python字符是Unicode。Unicode字符的数量远远超过256个。
- en: How do we map Unicode characters to bytes to write to a file or for transmission?
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将Unicode字符映射到字节以写入文件或进行传输？
- en: 1.7.1 Getting ready
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7.1 准备工作
- en: Historically, a character occupied 1 byte. Python leverages the old ASCII encoding
    scheme for bytes; this sometimes leads to confusion between bytes and text strings
    of Unicode characters.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，一个字符占用1个字节。Python利用旧的ASCII编码方案来处理字节；这有时会导致字节和Unicode字符的文本字符串之间的混淆。
- en: Unicode characters are encoded into sequences of bytes. There are a number of
    standardized encodings and a number of non-standard encodings.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode字符被编码成一系列的字节。有许多标准化的编码和许多非标准化的编码。
- en: Plus, there also are some encodings that only work for a small subset of Unicode
    characters. We try to avoid these, but there are some situations where we’ll need
    to use a subset encoding scheme.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些编码只适用于Unicode字符的一个小子集。我们尽量避免使用这些编码，但在某些情况下，我们可能需要使用子集编码方案。
- en: Unless we have a really good reason not to, we almost always use UTF-8 encoding
    for Unicode characters. Its main advantage is that it’s a compact representation
    of the Latin alphabet, which is used for English and a number of European languages.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们有充分的理由不这样做，否则我们几乎总是使用UTF-8编码来表示Unicode字符。它的主要优点是它是对拉丁字母的紧凑表示，拉丁字母被用于英语和许多欧洲语言。
- en: Sometimes, an internet protocol requires ASCII characters. This is a special
    case that requires some care because the ASCII encoding can only handle a small
    subset of Unicode characters.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个互联网协议需要ASCII字符。这是一个需要特别注意的特殊情况，因为ASCII编码只能处理Unicode字符的一个小子集。
- en: 1.7.2 How to do it...
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7.2 如何操作...
- en: 'Python will generally use our OS’s default encoding for files and internet
    traffic. The details are unique to each OS:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Python通常使用我们操作系统的默认编码来处理文件和互联网流量。这些细节对每个操作系统都是独特的：
- en: 'We can make a general setting using the PYTHONIOENCODING environment variable.
    We set this outside of Python to ensure that a particular encoding is used everywhere.
    When using Linux or macOS, use the shell’s export statement to set the environment
    variable. For Windows, use the set command, or the PowerShell Set-Item cmdlet.
    For Linux, it looks like this:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用PYTHONIOENCODING环境变量来设置一个通用设置。我们将其设置在Python之外，以确保在所有地方都使用特定的编码。当使用Linux或macOS时，使用shell的export语句来设置环境变量。对于Windows，使用set命令或PowerShell的Set-Item命令。对于Linux，它看起来像这样：
- en: '[PRE53]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Run Python:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Python：
- en: '[PRE54]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We sometimes need to make specific settings when we open a file inside our
    script. We’ll return to this topic in Chapter [11](ch015_split_000.xhtml#x1-61500011).
    Open the file with a given encoding. Read or write Unicode characters to the file:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在脚本内部打开文件时，我们有时需要做出特定的设置。我们将在第11章中回到这个话题。以指定的编码打开文件。向文件中读取或写入Unicode字符：
- en: '[PRE55]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can also manually encode characters, in the rare case that we need to open
    a file in bytes mode; if we use a mode of wb, we’ll also need to use manual encoding
    of each string:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数需要以字节模式打开文件的情况下，我们也可以手动编码字符；如果我们使用wb模式，我们还需要对每个字符串进行手动编码：
- en: '[PRE56]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We can see that a sequence of bytes (\xf0\x9f\x80\x80) was used to encode a
    single Unicode character, U+1F000, ![PIC](img/file11.png).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.3 How it works...
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unicode defines a number of encoding schemes. While UTF-8 is the most popular,
    there is also UTF-16 and UTF-32\. The number is the typical number of bits per
    character. A file with 1,000 characters encoded in UTF-32 would be 4,000 8-bit
    bytes. A file with 1,000 characters encoded in UTF-8 could be as few as 1,000
    bytes, depending on the exact mix of characters. In UTF-8 encoding, characters
    with Unicode numbers above U+007F require multiple bytes.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Various OSes have their own coding schemes. macOS files can be encoded in Mac
    Roman or Latin-1\. Windows files might use CP1252 encoding.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: The point with all of these schemes is to have a sequence of bytes that can
    be mapped to a Unicode character and—going the other way—a way to map each Unicode
    character to one or more bytes. Ideally, all of the Unicode characters are accounted
    for. Pragmatically, some of these coding schemes are incomplete.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The historical form of ASCII encoding can only represent about 100 of the Unicode
    characters as bytes. It’s easy to create a string that cannot be encoded using
    the ASCII scheme.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the error looks like:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We may see this kind of error when we accidentally open a file with an encoding
    that’s not the widely used standard of UTF-8\. When we see this kind of error,
    we’ll need to change our processing to select the encoding actually used to create
    the file. It’s almost impossible to guess what encoding was used, so some research
    may be required to locate metadata about the file that states the encoding.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Bytes are often displayed using printable characters. We’ll see b’hello’ as
    shorthand for a five-byte value. The letters are chosen using the old ASCII encoding
    scheme, where byte values from 0x20 to 0x7F will be shown as characters, and outside
    this range, more complex-looking escapes will be used.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: This use of characters to represent byte values can be confusing. The prefix
    of b’ is our hint that we’re looking at bytes, not proper Unicode characters.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.4 See also
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of ways to build strings of data. See the [Building complicated
    strings with f-strings](ch005_split_000.xhtml#x1-410004) and the [Building complicated
    strings from lists of strings](ch005_split_000.xhtml#x1-470005) recipes for examples
    of creating complex strings. The idea is that we might have an application that
    builds a complex string, and then we encode it into bytes.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on UTF-8 encoding, see [https://en.wikipedia.org/wiki/UTF-8](https://en.wikipedia.org/wiki/UTF-8).
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For general information on Unicode encodings, see [http://unicode.org/faq/utf_bom.html](http://unicode.org/faq/utf_bom.html).
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.8 Decoding bytes – how to get proper characters from some bytes
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we work with files that aren’t properly encoded? What do we do with
    files written in ASCII encoding?
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: A download from the internet is almost always in bytes—not characters. How do
    we decode the characters from that stream of bytes?
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Also, when we use the subprocess module, the results of an OS command are in
    bytes. How can we recover proper characters?
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Much of this is also relevant to the material in Chapter [11](ch015_split_000.xhtml#x1-61500011).
    We’ve included this recipe here because it’s the inverse of the previous recipe,
    [Encoding strings – creating ASCII and UTF-8 bytes](ch005_split_001.xhtml#x1-570007).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.1 Getting ready
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we’re interested in offshore marine weather forecasts. Perhaps this
    is because we are departing the Chesapeake Bay for the Caribbean.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Are there any special warnings coming from the National Weather Services office
    in Wakefield, Virginia?
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the link: [https://forecast.weather.gov/product.php?site=AKQ&product=SMW&issuedby=AKQ](https://forecast.weather.gov/product.php?site=AKQ&product=SMW&issuedby=AKQ).'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'We can download this with Python’s urllib module:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that we’ve enclosed the URI string in () and broken it into two separate
    string literals. Python will concatenate these two adjacent literals into a single
    string. We’ll look at this in some depth in Chapter [2](ch006_split_000.xhtml#x1-840002).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alterative, we can use programs like curl or wget to get this. At the
    OS Terminal prompt, we might run the following (long) command:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Typesetting this book tends to break the command onto many lines. It’s really
    one very long line.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: The code repository includes a sample file, ch01/Text Products for SMW Issued
    by AKQ.html.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'The forecast_text value is a stream of bytes. It’s not a proper string. We
    can tell because it starts like this:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The data goes on for a while, providing details from the web page. Because the
    displayed value starts with b’, it’s bytes, not proper Unicode characters. It
    was probably encoded with UTF-8, which means some characters could have weird-looking
    \xnn escape sequences instead of proper characters. We want to have the proper
    characters.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: While this data has many easy-to-read characters, the b’ prefix shows that it’s
    a collection of byte values, not proper text. Generally, a bytes object behaves
    somewhat like a string object. Sometimes, we can work with bytes directly. Most
    of the time, we’ll want to decode the bytes and create proper Unicode characters
    from them.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.2 How to do it...
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Determine the coding scheme if possible. In order to decode bytes to create
    proper Unicode characters, we need to know what encoding scheme was used. When
    we read XML documents, there’s a big hint provided within the document:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When browsing web pages, there’s often a header containing this information:'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Sometimes, an HTML page may include this as part of the header:'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In other cases, we’re left to guess. In the case of US weather data, a good
    first guess is UTF-8\. Another good guess is ISO-8859-1\. In some cases, the guess
    will depend on the language.
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The codecs — Codec registry and base classes section of the Python Standard
    Library lists the standard encodings available. Decode the data:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The b’ prefix is no longer used to show that these are bytes. We’ve created
    a proper string of Unicode characters from the stream of bytes.
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If this step fails with an exception, we guessed wrong about the encoding. We
    need to try another encoding in order to parse the resulting document.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since this is an HTML document, we should use Beautiful Soup to extract the
    data. See [http://www.crummy.com/software/BeautifulSoup/](http://www.crummy.com/software/BeautifulSoup/).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, however, extract one nugget of information from this document without
    completely parsing the HTML:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This tells us what we need to know: there are no warnings at this time. This
    doesn’t mean smooth sailing, but it does mean that there aren’t any major weather
    systems that could cause catastrophes.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.3 How it works...
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Encoding strings – creating ASCII and UTF-8 bytes](ch005_split_001.xhtml#x1-570007)
    recipe for more information on Unicode and the different ways that Unicode characters
    can be encoded into streams of bytes.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: At the foundation of the OS, files and network connections are built up from
    bytes. It’s our software that decodes the bytes to discover the content. It might
    be characters, images, or sounds. In some cases, the default assumptions are wrong
    and we need to do our own decoding.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.4 See also
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we’ve recovered the string data, we have a number of ways of parsing or
    rewriting it. See the [String parsing with regular expressions](ch005_split_000.xhtml#x1-350003)
    recipe for examples of parsing a complex string.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on encodings, see [https://en.wikipedia.org/wiki/UTF-8](https://en.wikipedia.org/wiki/UTF-8)
    and [http://unicode.org/faq/utf_bom.html](http://unicode.org/faq/utf_bom.html).
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.9 Using tuples of items
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What’s the best way to represent simple (x,y) and (r,g,b) groups of values?
    How can we keep things that are pairs, such as latitude and longitude, together?
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.1 Getting ready
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [String parsing with regular expressions](ch005_split_000.xhtml#x1-350003)
    recipe, we skipped over an interesting data structure.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'We had data that looked like this:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We parsed this into meaningful data using a regular expression, like this:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The result is a tuple object with three pieces of data. There are lots of places
    where this kind of grouped data can come in handy.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.2 How to do it...
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll look at two aspects to this: putting things into tuples and getting things
    out of tuples.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Creating tuples
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are lots of places where Python creates tuples of data for us. In the
    Getting ready section of the [String parsing with regular expressions](ch005_split_000.xhtml#x1-350003)
    recipe, we showed you how a regular expression match object will create a tuple
    of text that was parsed from a string.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create our own tuples, too. Here are the steps:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Enclose the data in ().
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Separate the items with ,.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'There’s an important special case for the one-tuple, or singleton. We have
    to include the , even when there’s only one item in the tuple:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The () characters aren’t always required. There are a few times where we can
    omit them. It’s not a good idea to omit them.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s the comma that creates a tuple of values. This means we can see funny
    things when we have an extra comma:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The comma after 355 turns the value into a singleton tuple.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: We can also create a tuple by conversion from another sequence. For example,
    tuple([355]) creates a singleton tuple from a singleton list.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Extracting items from a tuple
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The idea of a tuple is to be a container with a number of items that’s fixed
    by the problem domain: for example, for (red, green, blue) color numbers, the
    number of items is always three.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we’ve got an ingredient, and amount, and units. This must be
    a three-item collection. We can look at the individual items in two ways:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'By index position; that is, positions are numbered starting with zero from
    the left:'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Using multiple assignment:'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Tuples—like strings—are immutable. We can’t change the individual items inside
    a tuple. We use tuples when we want to keep the data together.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.3 How it works...
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tuples are one example of the more general Sequence class. We can do a few things
    with sequences.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example tuple that we can work with:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Here are some operations we can perform on this tuple:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: How many items in t?
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How many times does a particular value appear in t?
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Which position has a particular value?
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'When an item doesn’t exist, we’ll get an exception:'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Does a particular value exist?
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 1.9.4 There’s more...
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tuple, like a string, is a sequence of items. In the case of a string, it’s
    a sequence of characters. In the case of a tuple, it’s a sequence of many things.
    Because they’re both sequences, they have some common features. We’ve noted that
    we can pluck out individual items by their index position. We can use the index()
    method to locate the position of an item.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: The similarities end there. A string has many methods it can use to create a
    new string that’s a transformation of a string, plus methods to parse strings,
    plus methods to determine the content of the strings. A tuple doesn’t have any
    of these bonus features. It’s—perhaps—the simplest possible data structure.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.5 See also
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at one other sequence, the list, in the [Building complicated strings
    from lists of strings](ch005_split_000.xhtml#x1-470005) recipe.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll also look at sequences in Chapter [4](ch008_split_000.xhtml#x1-2240004).
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.10 Using NamedTuples to simplify item access in tuples
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we worked with tuples, we had to remember the positions as numbers. When
    we use a (r,g,b) tuple to represent a color, can we use ”red” instead of zero,
    ”green” instead of 1, and ”blue” instead of 2?
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.1 Getting ready
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s continue looking at items in recipes. The regular expression for parsing
    the string had three attributes: ingredient, amount, and unit. We used the following
    pattern with names for the various substrings:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The resulting data tuple looked like this:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: While the matching between ingredient, amount, and unit is pretty clear, using
    something like the following isn’t ideal. What does 1 mean? Is it really the quantity?
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We want to define tuples with names, as well as positions.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.2 How to do it...
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll use the NamedTuple class definition from the typing package:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'With this base class definition, we can define our own unique tuples, with
    names for the items:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, we can create an instance of this unique kind of tuple by using the classname:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'When we want a value from the tuple, we can use a name instead of the position:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 1.10.3 How it works...
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NamedTuple class definition introduces a core concept from Chapter [7](ch011_split_000.xhtml#x1-3760007).
    We’ve extended the base class definition to add unique features for our application.
    In this case, we’ve named the three attributes each Ingredient tuple must contain.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Because a subclass of NamedTuple class is a tuple, the order of the attribute
    names is fixed. We can use a reference like the expression item_2[0] as well as
    the expression item_2.ingredient. Both names refer to the item in index 0 of the
    tuple, item_2.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: The core tuple types can be called ”anonymous tuples” or maybe ”index-only tuples.”
    This can help to distinguish them from the more sophisticated ”named tuples” introduced
    through the typing module.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Tuples are very useful as tiny containers of closely related data. Using the
    NamedTuple class definition makes them even easier to work with.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.4 There’s more...
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can have a mixed collection of values in a tuple or a named tuple. We need
    to perform conversion before we can build the tuple. It’s important to remember
    that a tuple cannot ever be changed. It’s an immutable object, similar in many
    ways to the way strings and numbers are immutable.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we might want to work with amounts that are exact fractions. Here’s
    a more sophisticated definition:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'These objects require some care to create. If we’re using a bunch of strings,
    we can’t simply build this object from three string values; we need to convert
    the amount into a Fraction instance. Here’s an example of creating an item using
    a Fraction conversion:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This tuple has a more useful value for the amount of each ingredient. We can
    now do mathematical operations on the amounts:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: It’s very handy to explicitly state the data type within the NamedTuple class
    definition. It turns out Python doesn’t use the type information directly. Other
    tools, for example, mypy, can check the type hints in a NamedTuple against the
    operations in the rest of the code to be sure they agree.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.5 See also
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at class definitions in Chapter [7](ch011_split_000.xhtml#x1-3760007).
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community Discord space
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
