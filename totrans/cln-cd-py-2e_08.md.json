["```py\nclass MetricsClient:\n    \"\"\"3rd-party metrics client\"\"\"\n    def send(self, metric_name, metric_value):\n        if not isinstance(metric_name, str):\n            raise TypeError(\"expected type str for metric_name\")\n        if not isinstance(metric_value, str):\n            raise TypeError(\"expected type str for metric_value\")\n        logger.info(\"sending %s = %s\", metric_name, metric_value)\nclass Process:\n    def __init__(self):\n        self.client = MetricsClient() # A 3rd-party metrics client\n    def process_iterations(self, n_iterations):\n        for i in range(n_iterations):\n            result = self.run_process()\n            self.client.send(f\"iteration.{i}\", str(result)) \n```", "```py\nTraceback (most recent call last):\n...\n    raise TypeError(\"expected type str for metric_value\")\nTypeError: expected type str for metric_value \n```", "```py\nclass WrappedClient:\n    def __init__(self):\n        self.client = MetricsClient()\n    def send(self, metric_name, metric_value):\n        return self.client.send(str(metric_name), str(metric_value))\nclass Process:\n    def __init__(self):\n        self.client = WrappedClient()\n    ... # rest of the code remains unchanged \n```", "```py\nimport unittest\nfrom unittest.mock import Mock\nclass TestWrappedClient(unittest.TestCase):\n    def test_send_converts_types(self):\n        wrapped_client = WrappedClient()\n        wrapped_client.client = Mock()\n        wrapped_client.send(\"value\", 1)\n        wrapped_client.client.send.assert_called_with(\"value\", \"1\") \n```", "```py\nfrom enum import Enum\nclass MergeRequestStatus(Enum):\n    APPROVED = \"approved\"\n    REJECTED = \"rejected\"\n    PENDING = \"pending\"\nclass MergeRequest:\n    def __init__(self):\n        self._context = {\n            \"upvotes\": set(),\n            \"downvotes\": set(),\n        }\n    @property\n    def status(self):\n        if self._context[\"downvotes\"]:\n            return MergeRequestStatus.REJECTED\n        elif len(self._context[\"upvotes\"]) >= 2:\n            return MergeRequestStatus.APPROVED\n        return MergeRequestStatus.PENDING\n    def upvote(self, by_user):\n        self._context[\"downvotes\"].discard(by_user)\n        self._context[\"upvotes\"].add(by_user)\n    def downvote(self, by_user):\n        self._context[\"upvotes\"].discard(by_user)\n        self._context[\"downvotes\"].add(by_user) \n```", "```py\nclass TestMergeRequestStatus(unittest.TestCase):\n    def test_simple_rejected(self):\n        merge_request = MergeRequest()\n        merge_request.downvote(\"maintainer\")\n        self.assertEqual(merge_request.status, MergeRequestStatus.REJECTED)\n    def test_just_created_is_pending(self):\n        self.assertEqual(MergeRequest().status, MergeRequestStatus.PENDING)\n    def test_pending_awaiting_review(self):\n        merge_request = MergeRequest()\n        merge_request.upvote(\"core-dev\")\n        self.assertEqual(merge_request.status, MergeRequestStatus.PENDING)\n    def test_approved(self):\n        merge_request = MergeRequest()\n        merge_request.upvote(\"dev1\")\n        merge_request.upvote(\"dev2\")\n        self.assertEqual(merge_request.status, MergeRequestStatus.APPROVED) \n```", "```py\nclass MergeRequest:\n    def __init__(self):\n        self._context = {\n            \"upvotes\": set(),\n            \"downvotes\": set(),\n        }\n        self._status = MergeRequestStatus.OPEN\n    def close(self):\n        self._status = MergeRequestStatus.CLOSED\n    ...\n    def _cannot_vote_if_closed(self):\n        if self._status == MergeRequestStatus.CLOSED:\n            raise MergeRequestException(\n                \"can't vote on a closed merge request\"\n            )\n    def upvote(self, by_user):\n        self._cannot_vote_if_closed()\n        self._context[\"downvotes\"].discard(by_user)\n        self._context[\"upvotes\"].add(by_user)\n    def downvote(self, by_user):\n        self._cannot_vote_if_closed()\n        self._context[\"upvotes\"].discard(by_user)\n        self._context[\"downvotes\"].add(by_user) \n```", "```py\n def test_cannot_upvote_on_closed_merge_request(self):\n        self.merge_request.close()\n        self.assertRaises(\n            MergeRequestException, self.merge_request.upvote, \"dev1\"\n        )\n    def test_cannot_downvote_on_closed_merge_request(self):\n        self.merge_request.close()\n        self.assertRaisesRegex(\n            MergeRequestException,\n            \"can't vote on a closed merge request\",\n            self.merge_request.downvote,\n            \"dev1\",\n        ) \n```", "```py\nwith self.assertRaises(MyException):\n   test_logic() \n```", "```py\nclass AcceptanceThreshold:\n    def __init__(self, merge_request_context: dict) -> None:\n        self._context = merge_request_context\n    def status(self):\n        if self._context[\"downvotes\"]:\n            return MergeRequestStatus.REJECTED\n        elif len(self._context[\"upvotes\"]) >= 2:\n            return MergeRequestStatus.APPROVED\n        return MergeRequestStatus.PENDING\nclass MergeRequest:\n    ...\n    @property\n    def status(self):\n        if self._status == MergeRequestStatus.CLOSED:\n            return self._status\n        return AcceptanceThreshold(self._context).status() \n```", "```py\nclass TestAcceptanceThreshold(unittest.TestCase):\n    def setUp(self):\n        self.fixture_data = (\n            (\n                {\"downvotes\": set(), \"upvotes\": set()},\n                MergeRequestStatus.PENDING\n            ),\n            (\n                {\"downvotes\": set(), \"upvotes\": {\"dev1\"}},\n                MergeRequestStatus.PENDING,\n            ),\n            (\n                {\"downvotes\": \"dev1\", \"upvotes\": set()},\n                MergeRequestStatus.REJECTED,\n            ),\n            (\n                {\"downvotes\": set(), \"upvotes\": {\"dev1\", \"dev2\"}},\n                MergeRequestStatus.APPROVED,\n            ),\n        )\n    def test_status_resolution(self):\n        for context, expected in self.fixture_data:\n            with self.subTest(context=context):\n                status = AcceptanceThreshold(context).status()\n                self.assertEqual(status, expected) \n```", "```py\nFAIL: (context={'downvotes': set(), 'upvotes': {'dev1', 'dev2'}})\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"\" test_status_resolution\n    self.assertEqual(status, expected)\nAssertionError: <MergeRequestStatus.APPROVED: 'approved'> != <MergeRequestStatus.REJECTED: 'rejected'> \n```", "```py\ndef test_simple_rejected():\n    merge_request = MergeRequest()\n    merge_request.downvote(\"maintainer\")\n    assert merge_request.status == MergeRequestStatus.REJECTED\ndef test_just_created_is_pending():\n    assert MergeRequest().status == MergeRequestStatus.PENDING\ndef test_pending_awaiting_review():\n    merge_request = MergeRequest()\n    merge_request.upvote(\"core-dev\")\n    assert merge_request.status == MergeRequestStatus.PENDING \n```", "```py\ndef test_invalid_types():\n    merge_request = MergeRequest()\n    pytest.raises(TypeError, merge_request.upvote, {\"invalid-object\"})\ndef test_cannot_vote_on_closed_merge_request():\n    merge_request = MergeRequest()\n    merge_request.close()\n    pytest.raises(MergeRequestException, merge_request.upvote, \"dev1\")\n    with pytest.raises(\n        MergeRequestException,\n        match=\"can't vote on a closed merge request\",\n    ):\n        merge_request.downvote(\"dev1\") \n```", "```py\n@pytest.mark.parametrize(\"context,expected_status\", (\n    (\n        {\"downvotes\": set(), \"upvotes\": set()},\n        MergeRequestStatus.PENDING\n    ),\n    (\n        {\"downvotes\": set(), \"upvotes\": {\"dev1\"}},\n        MergeRequestStatus.PENDING,\n    ),\n    (\n        {\"downvotes\": \"dev1\", \"upvotes\": set()},\n        MergeRequestStatus.REJECTED,\n    ),\n    (\n        {\"downvotes\": set(), \"upvotes\": {\"dev1\", \"dev2\"}},\n        MergeRequestStatus.APPROVED,\n    ),\n),)\ndef test_acceptance_threshold_status_resolution(context, expected_status):\n    assert AcceptanceThreshold(context).status() == expected_status \n```", "```py\n@pytest.mark.parametrize(\"x\", (1, 2))\n@pytest.mark.parametrize(\"y\", (\"a\", \"b\"))\ndef my_test(x, y):\n   â€¦ \n```", "```py\n@pytest.fixture\ndef rejected_mr():\n    merge_request = MergeRequest()\n    merge_request.downvote(\"dev1\")\n    merge_request.upvote(\"dev2\")\n    merge_request.upvote(\"dev3\")\n    merge_request.downvote(\"dev4\")\n    return merge_request\ndef test_simple_rejected(rejected_mr):\n    assert rejected_mr.status == MergeRequestStatus.REJECTED\ndef test_rejected_with_approvals(rejected_mr):\n    rejected_mr.upvote(\"dev2\")\n    rejected_mr.upvote(\"dev3\")\n    assert rejected_mr.status == MergeRequestStatus.REJECTED\ndef test_rejected_to_pending(rejected_mr):\n    rejected_mr.upvote(\"dev1\")\n    assert rejected_mr.status == MergeRequestStatus.PENDING\ndef test_rejected_to_approved(rejected_mr):\n    rejected_mr.upvote(\"dev1\")\n    rejected_mr.upvote(\"dev2\")\n    assert rejected_mr.status == MergeRequestStatus.APPROVED \n```", "```py\nPYTHONPATH=src pytest \\\n    --cov-report term-missing \\\n    --cov=coverage_1 \\\n    tests/test_coverage_1.py \n```", "```py\ntest_coverage_1.py ................ [100%]\n----------- coverage: platform linux, python 3.6.5-final-0 -----------\nName         Stmts Miss Cover Missing\n---------------------------------------------\ncoverage_1.py 39      1  97%    44 \n```", "```py\ndef my_function(number: int):\n    return \"even\" if number % 2 == 0 else \"odd\" \n```", "```py\n@pytest.mark.parametrize(\"number,expected\", [(2, \"even\")])\ndef test_my_function(number, expected):\n    assert my_function(number) == expected \n```", "```py\nclass GitBranch:\n    def __init__(self, commits: List[Dict]):\n        self._commits = {c[\"id\"]: c for c in commits}\n    def __getitem__(self, commit_id):\n        return self._commits[commit_id]\n    def __len__(self):\n        return len(self._commits)\ndef author_by_id(commit_id, branch):\n    return branch[commit_id][\"author\"] \n```", "```py\ndef test_find_commit():\n    branch = GitBranch([{\"id\": \"123\", \"author\": \"dev1\"}])\n    assert author_by_id(\"123\", branch) == \"dev1\"\ndef test_find_any():\n    author = author_by_id(\"123\", Mock()) is not None\n    # ... rest of the tests.. \n```", "```py\ndef author_by_id(commit_id, branch):\n    > return branch[commit_id][\"author\"]\n    E TypeError: 'Mock' object is not subscriptable \n```", "```py\ndef test_find_any():\n    mbranch = MagicMock()\n    mbranch.__getitem__.return_value = {\"author\": \"test\"}\n    assert author_by_id(\"123\", mbranch) == \"test\" \n```", "```py\n# mock_2.py\nfrom datetime import datetime\nimport requests\nfrom constants import STATUS_ENDPOINT\nclass BuildStatus:\n    \"\"\"The CI status of a pull request.\"\"\"\n    @staticmethod\n    def build_date() -> str:\n        return datetime.utcnow().isoformat()\n    @classmethod\n    def notify(cls, merge_request_id, status):\n        build_status = {\n            \"id\": merge_request_id,\n            \"status\": status,\n            \"built_at\": cls.build_date(),\n        }\n        response = requests.post(STATUS_ENDPOINT, json=build_status)\n        response.raise_for_status()\n        return response \n```", "```py\n# test_mock_2.py\nfrom unittest import mock\nfrom constants import STATUS_ENDPOINT\nfrom mock_2 import BuildStatus\n@mock.patch(\"mock_2.requests\")\ndef test_build_notification_sent(mock_requests):\n    build_date = \"2018-01-01T00:00:01\"\n    with mock.patch(\n        \"mock_2.BuildStatus.build_date\", \n        return_value=build_date\n    ):\n        BuildStatus.notify(123, \"OK\")\n    expected_payload = {\n        \"id\": 123, \n        \"status\": \"OK\", \n        \"built_at\": build_date\n    }\n    mock_requests.post.assert_called_with(\n        STATUS_ENDPOINT, json=expected_payload\n    ) \n```", "```py\n@pytest.fixture(autouse=True)\ndef no_requests():\n    with patch(\"requests.post\"):\n        yield \n```", "```py\nfrom datetime import datetime\nfrom constants import STATUS_ENDPOINT\nclass BuildStatus:\n    endpoint = STATUS_ENDPOINT\n    def __init__(self, transport):\n        self.transport = transport\n    @staticmethod\n    def build_date() -> str:\n        return datetime.utcnow().isoformat()\n    def compose_payload(self, merge_request_id, status) -> dict:\n        return {\n            \"id\": merge_request_id,\n            \"status\": status,\n            \"built_at\": self.build_date(),\n        }\n    def deliver(self, payload):\n        response = self.transport.post(self.endpoint, json=payload)\n        response.raise_for_status()\n        return response\n    def notify(self, merge_request_id, status):\n        return self.deliver(self.compose_payload(merge_request_id, status)) \n```", "```py\n@pytest.fixture\ndef build_status():\n    bstatus = BuildStatus(Mock())\n    bstatus.build_date = Mock(return_value=\"2018-01-01T00:00:01\")\n    return bstatus\ndef test_build_notification_sent(build_status):\n    build_status.notify(1234, \"OK\")\n    expected_payload = {\n        \"id\": 1234,\n        \"status\": \"OK\",\n        \"built_at\": build_status.build_date(),\n    }\n    build_status.transport.post.assert_called_with(\n        build_status.endpoint, json=expected_payload\n    ) \n```", "```py\nclass TestMergeRequestStatus(unittest.TestCase):\n    def setUp(self):\n        self.merge_request = MergeRequest()\n    def assert_rejected(self):\n        self.assertEqual(\n            self.merge_request.status, MergeRequestStatus.REJECTED\n        )\n    def assert_pending(self):\n        self.assertEqual(\n            self.merge_request.status, MergeRequestStatus.PENDING\n        )\n    def assert_approved(self):\n        self.assertEqual(\n            self.merge_request.status, MergeRequestStatus.APPROVED\n        )\n    def test_simple_rejected(self):\n        self.merge_request.downvote(\"maintainer\")\n        self.assert_rejected()\n    def test_just_created_is_pending(self):\n        self.assert_pending() \n```", "```py\n# File mutation_testing_1.py\nfrom mrstatus import MergeRequestStatus as Status\ndef evaluate_merge_request(upvote_count, downvotes_count):\n    if downvotes_count > 0:\n        return Status.REJECTED\n    if upvote_count >= 2:\n        return Status.APPROVED\n    return Status.PENDING \n```", "```py\n# file: test_mutation_testing_1.py\nclass TestMergeRequestEvaluation(unittest.TestCase):\n    def test_approved(self):\n        result = evaluate_merge_request(3, 0)\n        self.assertEqual(result, Status.APPROVED) \n```", "```py\n$ PYTHONPATH=src mut.py \\\n    --target src/mutation_testing_${CASE}.py \\\n    --unit-test tests/test_mutation_testing_${CASE}.py \\\n    --operator AOD `# delete arithmetic operator`\\\n    --operator AOR `# replace arithmetic operator` \\\n    --operator COD `# delete conditional operator` \\\n    --operator COI `# insert conditional operator` \\\n    --operator CRP `# replace constant` \\\n    --operator ROR `# replace relational operator` \\\n    --show-mutants \n```", "```py\n[*] Mutation score [0.04649 s]: 100.0%\n   - all: 4\n   - killed: 4 (100.0%)\n   - survived: 0 (0.0%)\n   - incompetent: 0 (0.0%)\n   - timeout: 0 (0.0%) \n```", "```py\n - [# 1] ROR mutation_testing_1:11 : \n------------------------------------------------------\n  7: from mrstatus import MergeRequestStatus as Status\n  8: \n  9: \n 10: def evaluate_merge_request(upvote_count, downvotes_count):\n~11:     if downvotes_count < 0:\n 12:         return Status.REJECTED\n 13:     if upvote_count >= 2:\n 14:         return Status.APPROVED\n 15:     return Status.PENDING\n------------------------------------------------------\n[0.00401 s] killed by test_approved (test_mutation_testing_1.TestMergeRequestEvaluation) \n```", "```py\nif remaining_days > 0: ... \n```", "```py\ndef my_function(number: int):\n    return \"even\" if number % 2 == 0 else \"odd\" \n```"]