- en: '[*Chapter 7*](B16119_07_Final_PD_ePub.xhtml#_idTextAnchor194): Recordsets –
    Working with Model Data'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we gave an overview of model creation and loading
    data into models. Now that we have a data model and some data to work with, it's
    time to learn more about how to programmatically interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: A business application needs business logic to compute data, perform validations,
    or automate operations. The **Odoo** framework API provides the tools for a developer
    to implement this business logic. Most of the time, this means querying, transforming,
    and writing data.
  prefs: []
  type: TYPE_NORMAL
- en: Odoo implements an **Object-Relational Mapping** (**ORM**) layer on top of the
    lower level database. The ORM objects provide the **Application Programming Interface**
    (**API**) to be used to interact with the data. This API provides an execution
    environment and the creation of **recordsets**, that are objects used to work
    the data stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explains how to use the execution environment and recordsets so
    that you have all the tools needed to implement the business processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the shell command to interactively explore the ORM API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the execution environment and context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying data using recordsets and domains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing data in recordsets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with date and time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with recordsets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions and low-level SQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to use Odoo code to perform all
    of these actions, and you will also be ready to use these tools to implement your
    own business processes.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples in this chapter will be executed in an interactive shell and
    do not require any code from the previous chapters. A copy of the code can be
    found in the `ch07/ch07_recorsets_code.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: Using the shell command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`shell` command option. These commands can be executed interactively to better
    understand how they work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, add the `shell` command when starting Odoo, plus any Odoo options
    that we would usually use when starting Odoo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will initiate the usual server startup sequence in the terminal, but instead
    of launching an HTTP server listening for requests, it will start a Python prompt
    waiting for input.
  prefs: []
  type: TYPE_NORMAL
- en: This interactive command interface simulates the environment found inside a
    `class` method, running under the `OdooBot` superuser. The `self` variable is
    available and is set to the `OdooBot` superuser record object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, these commands inspect the `self` recordset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands print out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `self` variable contains a `res.users` recordset containing a record with
    `ID 1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recordset model name, inspecting `self._name`, is `res.users`, as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value for the record `name` field is `OdooBot`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value for the record `login` field is `__system__`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes in Odoo 12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `ID 1` superuser changed from `admin` to the internal `__system__` user.
    The `admin` user is now the `ID 2` user, and not a superuser, although the Odoo
    standard apps are careful to automatically grant it full access to them. The main
    reason for this change was to avoid having users perform day-to-day activities
    with the superuser account. Doing so is dangerous because this change bypasses
    all access rules and may cause inconsistent data, such as cross-company relationships.
    It's now meant to be used only for troubleshooting or very specific cross-company
    operations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As with Python, to exit the prompt, press *Ctrl* + *D*. This will also close
    the server process and return to the system shell prompt.
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to start an Odoo shell session. This is important for us to
    discover the Odoo API features. So, let's use it to explore the execution environment.
  prefs: []
  type: TYPE_NORMAL
- en: The execution environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Odoo recordsets operate in an **environment** context, providing relevant information
    about the context where the operation was triggered. For example, the database
    cursor being used, the current Odoo user, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Python code running inside a model method has access to the `self` recordset
    variable, and the local environment can be accessed with `self.env`. The server
    shell environment also provides a `self` reference in a similar way to what is
    found inside a method.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn about the attributes made available by the execution
    environment and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Environment attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen, `self` is a recordset. Recordsets carry environment information
    with them such as the user browsing the data and additional context-related information
    (for example, the active language and time zone).
  prefs: []
  type: TYPE_NORMAL
- en: 'The current environment can be accessed using the `env` attribute of a recordset,
    as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution environment in `self.env` has the following attributes available:'
  prefs: []
  type: TYPE_NORMAL
- en: The `env.cr` attribute is the database cursor being used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `env.user` attribute is the record for the current user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `env.uid` attribute is the ID for the session user. It is the same as `env.user.id`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `env.context` attribute is an immutable dictionary containing the session
    context data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `env.company` attribute is the active company.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `env.companies` attributes are the user's allowed companies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes in Odoo 13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `env.company` and `env.companies` attributes were introduced in Odoo 13\.
    In previous versions, this information was read from the user record by using
    `env.user.company_id` and `env.user.company_ids`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The environment also provides access to the registry where all installed models
    are available. For example, `self.env["res.partner"]` returns a reference to the
    `partner` model. We can then use `search()` or `browse()` on it to create recordsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the returned recordset for the `res.partner` model contains
    three records, with IDs `14`, `26`, `33`, and `27`. The recordset is not ordered
    by ID, as the default order for the corresponding model was used. In the case
    of the partner model, the default object `_order` is `display_name`.
  prefs: []
  type: TYPE_NORMAL
- en: The environment context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `context` object is a dictionary carrying session data that can be used
    on both the client-side user interface and the server-side ORM and business logic.
  prefs: []
  type: TYPE_NORMAL
- en: From the client side, it can carry information from one view to the next—such
    as the ID of the record active on the previous view after following a link or
    a button—or it can provide default values to be used in the next view.
  prefs: []
  type: TYPE_NORMAL
- en: On the server side, some recordset field values can depend on the locale settings
    provided by the context. In particular, the `lang` key affects the value of the
    translatable fields.
  prefs: []
  type: TYPE_NORMAL
- en: Context can also provide signals for server-side code. For example, the `active_test`
    key, when set to `False`, changes the behavior of the ORM `search()` method so
    that it does not apply the automatic filter on inactive records, ignoring the
    `active` record field.
  prefs: []
  type: TYPE_NORMAL
- en: 'An initial context from the web client looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see the `lang` key with the user language and `tz` with the time
    zone information. The content in records might be different depending on the current
    context:'
  prefs: []
  type: TYPE_NORMAL
- en: Translated fields can have different values depending on the active `lang` language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Datetime fields, when returned to clients, can show different times depending
    on the active `tz` timezone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When opening a view from a link or a button in a previous view, the web client
    will automatically add a few keys to the context, providing information on the
    record we are navigating from:'
  prefs: []
  type: TYPE_NORMAL
- en: '`active_model` is the previous model name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active_id` is the ID of the original record the user was positioned at.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active_ids` is a list of the IDs selected in cases where the user is navigating
    from a list view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wizard assistants frequently use these keys to find the records they are expected
    to act on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The context can be used to set default values and activate default filters
    on the target web client view by using keys with these specific prefixes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `default_` prefix added to a field name sets a default value for that field.
    For example, `{''default_user_id'': uid}` sets the current user as a default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `default_search_` prefix added to a filter name will automatically enable
    that filter. For example, `{''default_search_filter_my_tasks'': 1}` activates
    the filter with name `filter_my_books`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These prefixes are frequently used in `<field context="{...}">` elements.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the recordset execution environment and context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recordset execution context can be modified to take advantage of the behaviors
    described in the previous section or to add information to be used in methods
    called on that recordset.
  prefs: []
  type: TYPE_NORMAL
- en: 'The environment and its context can be modified through the following methods.
    Each of these returns a new recordset, along with a copy of the original with
    a modified environment:'
  prefs: []
  type: TYPE_NORMAL
- en: The `<recordset>.with_context(<dictionary>)` method replaces the context with
    the one provided in the dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<recordset>.with_context(key=value, ...)` method modifies the context by
    setting the provided attributes on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<recordset>.sudo([flag=True])` method enables or disables the superuser
    mode, allowing it to bypass security rules. The context user is kept the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<recordset>.with_user(<user>)` method modifies the user to the one provided,
    which is either a user record or an ID number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<recordset>.with_company(<company>)` method modifies the company to the
    one provided, which is either a company record or an ID number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<recordset>.with_env(<env>)` method modifies the full environment of the
    recordset to the one provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes in Odoo 13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `with_user()` and `with_company()` methods were introduced in Odoo 13\.
    To switch users, previous versions used the `sudo([<user>])` method, which could
    be provided to a specific user to switch to the superuser context. To switch companies,
    previous versions used `with_context(force=company=<id>)`, setting a `context`
    key that was checked in the relevant business logic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Additionally, the environment object provides the `env.ref()` function, taking
    a string with an external identifier and returning the corresponding record, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the external identifier does not exist, a `ValueError` exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: We learned more about the execution environments when running Python code in
    the Odoo server. The next step is to interact with data. In this case, the first
    thing to learn is how to query data and create recordsets, which is discussed
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Querying data with recordsets and domains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Odoo business logic will need to read data from the database to perform actions
    based on it. This is done through *recordsets*, which query the raw data and expose
    it as Python objects we can manipulate.
  prefs: []
  type: TYPE_NORMAL
- en: Odoo Python will usually be running in a class method, where `self` represents
    the recordset to work with. In some cases, we need to create recordsets for other
    models. For that, we should get a reference to the models and then query it to
    create the recordset.
  prefs: []
  type: TYPE_NORMAL
- en: The environment object, usually accessible as `self.env`, holds references to
    all the models available, and these can be accessed using dictionary-like syntax.
    For example, to get a reference to the `partner` model, use `self.env['res.partner']`
    or `self.env.get('res.partner')`. This model reference can then be used to create
    recordsets, as we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating recordsets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `search()` method takes a domain expression and returns a recordset with
    the records matching those conditions. For example, `[('name', 'like', 'Azure')]`
    will return all records with a `name` field containing `Azure`.
  prefs: []
  type: TYPE_NORMAL
- en: If the model has the `active` special field then by default, only the records
    with `active=True` will be considered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following keyword arguments can also be used:'
  prefs: []
  type: TYPE_NORMAL
- en: The `order` keyword is a string to be used as the `ORDER BY` clause in the database
    query. This is usually a comma-separated list of field names. Each field name
    may be followed by the `DESC` keyword to indicate a descending order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `limit` keyword sets a maximum number of records to retrieve.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `offset` keyword ignores the first `n` results; it can be used with `limit`
    to query blocks of records at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, we just need to know the number of records meeting certain conditions.
    For that, we can use `search_count()`, which returns the record count instead
    of a recordset in a more efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: The `browse()` method takes a list of IDs or a single ID and returns a recordset
    with those records. This can be convenient in cases where we already know the
    IDs of the records we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to get all the partner records containing `Lumber` in the display
    name, use the following `search()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case the IDs to query are known, use a `browse()` call, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time the IDs are not known, so the `search()` method is used more
    often than `browse()`.
  prefs: []
  type: TYPE_NORMAL
- en: To make good use of `search()`, a good understanding of the domain filter syntax
    is needed. So, we will focus on this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Domain expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `WHERE` expressions that are used to query the database. A `(''<field>'',
    ''<operator>'', <value>)` tuple. For example, the following is a valid domain
    expression, with a single condition: `[(''is_done'', ''='', False)]`. A domain
    expression with no conditions is also allowed. This translates to an empty list
    (`[]`) and the result is a query returning all records.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are actually two possible evaluation contexts for domains: on the client
    side, such as in *window actions* and web client *views*, and on the server side,
    such as in security *record rules* and model method Python code. What can be used
    in the `<field>` and `<value>` elements may depend on the evaluation context.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will look at a detailed explanation for each element of a domain condition:
    **field**, **operator**, and **value**.'
  prefs: []
  type: TYPE_NORMAL
- en: The field element of a domain condition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first condition element is a string with the name of the field being filtered.
    When the domain expression is used on the server side, the field element can use
    dot-notation to access the values of related models. For example, we could use
    something like `'publisher_id.name'`, or even `'publisher_id.country_id.name'`.
  prefs: []
  type: TYPE_NORMAL
- en: On the client side, dot-notation is not allowed, and only simple field names
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: In cases where a related record value is needed for a client-side domain expression
    because dot-notation can't be used, the solution is to add to the model a related
    field by using a `related=` attribute. This way, the value is accessible as a
    directly accessible model field.
  prefs: []
  type: TYPE_NORMAL
- en: The operator element of a domain condition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second condition element is the operator to apply on the field being filtered.
    What follows is a list of the allowed operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_7.1_B16119.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These operators are applied to the field provided in the first element, using
    the value provided in the third element. For example, `('shipping_address_id',
    'child_of', partner_id)` checks the evaluation context for a `partner_id` variable
    and reads its value. The database is queried on the `shipping_address_id` field,
    selecting the records where that address is a child of the one identified in the
    `partner_id` value.
  prefs: []
  type: TYPE_NORMAL
- en: The value element of a domain condition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third element is evaluated as a Python expression. It can use literal values,
    such as numbers, Booleans, strings, or lists, and can use fields and identifiers
    available in the evaluation context.
  prefs: []
  type: TYPE_NORMAL
- en: Record objects are not accepted values. Instead, the corresponding ID values
    should be used. For example, don't use `[('user_id', '=', user)]` – instead, use
    `[('user_id', '=', user``)]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For record rules, the evaluation context has the following names available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user`: A record for the current user (equivalent to `self.env.user`). Use
    `user.id` to get the corresponding ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`company_id`: The ID of a record for the active company (equivalent to `self.env.company.id`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`company_ids`: A list of IDs for the allowed companies (equivalent to `self.env.companies.ids`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time`: The Python time module, exposing date and time functions. The official
    reference can be found at [https://docs.python.org/3/library/time.html](https://docs.python.org/3/library/time.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes in Odoo 13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `company_id` and `company_ids` context values are available for record rule
    evaluation since Odoo 13, and the approach from the previous version, using `user.company_id.id`,
    should not be used anymore. For example, the previously frequently used `['|',
    ('company_id', '=', False), ('company_id', 'child_of', [user.company_id.id])]`
    domain should now be written as `[('company_id', 'in', company_ids)]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Searching on to-many fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the searched field is a *to-many*, the operator is applied to each of the
    field values, and the evaluated record is included in the result if any of the
    field values match the domain condition.
  prefs: []
  type: TYPE_NORMAL
- en: The `=` and `in` operators behave like a *contains* operation. They both check
    if *any* of the field values match any of the list of values searched for. Symmetrically,
    the `!=` and `not in` operators check that *none* of the field values match any
    of the list of values searched for.
  prefs: []
  type: TYPE_NORMAL
- en: Composing a domain expression with multiple conditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A domain expression is a list of items and can contain several condition tuples.
    By default, these conditions will implicitly be combined using the AND logical
    operator. This means that it will only return records meeting all of the conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit logic operators can also be used – for example, the ampersand symbol
    (`&`) for AND operations (the default) and the pipe symbol (`|`) for OR operations.
    These will operate on the next two items, working in a recursive way. We'll look
    at this in more detail in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: For a slightly more formal definition, a domain expression uses prefix notation,
    also known as **Polish notation** (**PN**), where operators precede operands.
    The AND and OR operators are binary operators, while NOT is a unary operator.
  prefs: []
  type: TYPE_NORMAL
- en: The exclamation point (`!`) represents the NOT operator and it operates on the
    following item. So, it should be placed before the item to be negated. For example,
    the `['!', ('is_done','=',True)]` expression will filter all *not done* records.
  prefs: []
  type: TYPE_NORMAL
- en: Operator items, such as (`!`) or (`|`), can be nested, allowing the definition
    of `AND`/`OR`/`NOT` complex conditions. Let's illustrate this with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In server-side record rules, we can find domain expressions similar to this
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This domain filters all of the records where:'
  prefs: []
  type: TYPE_NORMAL
- en: '- the current user is a follower, or'
  prefs: []
  type: TYPE_NORMAL
- en: '- the current user is the record''s responsible (user_id), or'
  prefs: []
  type: TYPE_NORMAL
- en: '- the record has no responsible user set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the abstract syntax tree representation of
    the previous domain expression example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – A diagram illustrating a composed domain expression'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.1_B16119.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – A diagram illustrating a composed domain expression
  prefs: []
  type: TYPE_NORMAL
- en: The first `|` (*OR*) operator acts on the follower's condition plus the result
    of the next condition. The next condition is again the union of two other conditions
    - records where either the user ID is set to the current user, or the user ID
    is not set.
  prefs: []
  type: TYPE_NORMAL
- en: Special domain conditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some special domain conditions are also supported for the cases where an *always
    true* or *always false* expression is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `(1, "=", 1)` condition represents an *always true* expression. It can
    be used on record rules to give a higher user group access to all records, previously
    limited by a lower user group. For example, it is used on the `User: All Documents`
    group, to override the record access limitation in the inherited `User: Own Documents
    only` group. For an example of this, see `addons/sales_team/security/sales_team_security.xml`
    in the Odoo source code.'
  prefs: []
  type: TYPE_NORMAL
- en: The `(0, "=", 1)` condition is also supported and represents an *always false*
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping by fields and aggregate data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we need to group records by their data field. Odoo can do this using
    the `read_group()` method. The method arguments are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `domain` argument is a list with a domain expression to filter the records
    to retrieve.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `fields` argument is a list of field names, along with an aggregation function
    to apply in the format of `field:aggr`. Aggregation functions are the ones allowed
    by `sum`, `avg`, `min`, `max`, `count`, and `count_distinct`. For example: `["subtotal:sum"]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `groupby` argument is a list with the data field names to group by.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `limit` argument is an optional maximum number of groups to return.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `offset` argument is an optional number of records to skip.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `orderby` argument is an optional string with an *order by* clause to apply
    to the result (similar to what `search()` supports).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `lazy` argument, if set to `True`, only groups by the first field, and adds
    the remaining group of fields to the `__context` result. This argument defaults
    to `True`, so set it to `False` to have all *group by fields* immediately applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example grouping partner record by country, and count the number
    of different states found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This returned a list with a single group result for the `233` country ID. Running
    `self.env["res.country"].browse(233).name`, we can see that the country is `United
    Sates`. The `__count` key shows that there are `4` partners in the `233` country
    ID, and the `state_id` object shows the `count` distinct aggregation results:
    `1` distinct state is used by these partners.'
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to create recordsets. Next, we will want to read the data in
    them. In many cases, this is a trivial operation, but for some field types, there
    are a few details involved that are worth noting. The next section will help us
    with that.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing data in recordsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have a recordset, we want to inspect the data contained in it. So, in
    the following sections, we will explore how to access data in recordsets.
  prefs: []
  type: TYPE_NORMAL
- en: We can get field values for individual records called *singletons*. Relational
    fields have special properties, and we can use dot-notation to navigate through
    linked records. Finally, we will discuss some considerations for when we need
    to handle date and time records and convert them between different formats.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing individual record data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a recordset has only one record it is called a **singleton**. Singletons
    are still recordsets and can be used wherever a recordset is expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'But unlike multi-element recordsets, singletons can access their fields using
    dot-notation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next example, we can see that the same `self` singleton recordset also
    behaves as a recordset, and we can iterate it. It has only one record, so only
    one name is printed out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Trying to access field values in recordsets with more than one record will result
    in an error, so this can be an issue in cases where we are not sure if we are
    working with a singleton recordset.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Although using dot-notation to access fields won't work on multiple records,
    it is possible to access them in bulk by mapping the values to a recordset. This
    is done using `mapped()`. For example, `rset.mapped("name")` returns a list with
    the `name` values.
  prefs: []
  type: TYPE_NORMAL
- en: For methods designed to work only with a singleton, we can check this using
    `self.ensure_one()` at the beginning. It will raise an error if `self` is not
    a singleton.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The `ensure_one()` function also raises an error if the record is empty. To
    check if a `rset` has one or zero records, you can use `rset or rset.ensure_one()`.
  prefs: []
  type: TYPE_NORMAL
- en: An empty record is also a singleton. This is convenient because accessing field
    values will return a `None` value instead of raising an error. This is also true
    for relational fields, and accessing related records using dot notation won't
    raise errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in practice, there is no need to check for an empty recordset before accessing
    their field values. For example, instead of `if record: print(record.name)`, we
    can safely write the simpler `print(record.name)` method. A default value for
    an empty value can also be provided by using an `or` condition: `print(record.name``)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing relational fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw earlier, models can have relational fields—**many-to-one**, **one-to-many**,
    and **many-to-many**. These field types have recordsets as values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of many-to-one fields, the value can be a singleton or an empty
    recordset. In both cases, we can directly access their field values. As an example,
    the following instructions are correct and safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'An empty recordset conveniently also behaves like a singleton, and accessing
    its fields does not return an error but just returns `False`. Because of this,
    we can traverse records using dot-notation without worrying about errors from
    empty values, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Accessing date and time values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In recordsets, `date` and `datetime` values are represented as native Python
    objects. For example, when we look up the last login date for the `admin` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since the `date` and `datetime` values are Python objects, they have all of
    the manipulation features available for these objects.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 12
  prefs: []
  type: TYPE_NORMAL
- en: The `date` and `datetime` field values are now represented as Python objects,
    unlike previous Odoo versions, where the `date` and `datetime` values were represented
    as text strings. These field type values can still be set using text representations
    in the same way as previous Odoo versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dates and times are stored in the database in a native `datetime` values seen
    on recordsets are also in UTC. When presented to the user by the web client, the
    `datetime` values are converted into the user''s time zone by using the current
    session''s time zone setting that is stored in the context `tz` key, for example,
    `{''tz'': ''Europe/Brussels''}`. This conversion is a web client responsibility,
    as it isn''t done by the server.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, an 11:00 AM datetime value entered by a Brussels (UTC+1) user is
    stored in the database as 10:00 AM UTC, and will be seen by a New York (UTC-4)
    user as 06:00 AM. The Odoo server log message timestamps use the UTC time and
    not the local server time.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite conversion—from the session time zone to UTC—also needs to be done
    by the web client when sending the user's `datetime` input back to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the date and time data stored in the database and handled by the
    server code is always represented in UTC. Even the server log message timestamps
    are represented in UTC.
  prefs: []
  type: TYPE_NORMAL
- en: We have now reviewed the details of how to access record data. However, our
    application will provide some automation for business processes, so inevitably
    we will also need to write to recordsets. Let's look at this in detail in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have two different ways to write to records: using the object-style direct
    assignment or using the `write()` method. The `write()` method is the low-level
    method in charge of performing write operations, and it is still used directly
    when using the external API or when loading XML records. The object-style direct
    assignment was added later into the ORM model. It implements the **active record**
    pattern and can be used in Python code logic.'
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 13
  prefs: []
  type: TYPE_NORMAL
- en: In Odoo 13, the ORM model introduced a new database writing approach called
    `flush()` method is automatically called to perform the corresponding database
    operations in a single go.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at both of these methods and their differences.
  prefs: []
  type: TYPE_NORMAL
- en: Using object-style value assignments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recordsets implement the **active record pattern**. This means that we can assign
    values to them and these changes will be made persistent in the database. This
    is an intuitive and convenient way to manipulate data.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 13
  prefs: []
  type: TYPE_NORMAL
- en: Assigning values to a recordset with more than one record is supported as of
    Odoo 13\. Up to Odoo 12, only writing values to single records was supported,
    and the `write()` method had to be used to write to multiple records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When using the *active record* pattern, the value of relational fields can be
    set by assigning a recordset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Date and time fields can be assigned values as either Python native objects
    or string representations in the Odoo default format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Binary fields should be assigned `base64` encoded values. For example, when
    having raw binary data read from a file, that value must be converted using `base64.b64encode()`
    before being assigned to a field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When assigning values on many-to-one fields, the value assigned must be a single
    record (that is, a **singleton recordset**).
  prefs: []
  type: TYPE_NORMAL
- en: For to-many fields, the value can also be assigned with a recordset, replacing
    the list of linked records (if any) with a new one. Here, a recordset of any size
    is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set an empty value on a relational field, set it with `None` or `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To append or remove a record on the assigned list, use the record manipulation
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine a company record also has a related partner record that
    is used to hold address details. Suppose that we want to add the current user
    as a company child contact. This can be done with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, the pipe operator (`|`) was used to join a record to obtain a larger recordset.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compact append and assign operator (`|=`) could have been used for the
    same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: More details on record manipulation operations are given later in this chapter
    in the *Composing recordsets* section.
  prefs: []
  type: TYPE_NORMAL
- en: Using the write() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `write()` method can also be used to update data in records. It accepts
    a dictionary with the field names and values to assign. It can be more convenient
    to use in some cases, for example, where the dictionary is prepared first, and
    the assignment is performed later. It is also useful in older versions of Odoo
    (up to Odoo 12) for cases where direct assignment can't be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `write()` method receives a dictionary with the fields and values to assign
    and updates the recordset with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Date and time fields can be assigned with values of the corresponding Python
    objects or by using string text representations, just like with object-style assignments.
  prefs: []
  type: TYPE_NORMAL
- en: Since Odoo 13, `write()` can use recordsets to set values on to-one and to-many
    relational fields, just like with object-style assignments.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 13
  prefs: []
  type: TYPE_NORMAL
- en: The `write()` method can use recordsets to assign values on relational fields.
    Up to Odoo 12, many-to-one fields were set using an ID value, and to-many fields
    were set using a special syntax, for example, `(4, <id>, _)` to add a record and
    `(6, 0, [<ids>])` to set the full record list. This syntax is discussed in more
    detail in [*Chapter 5*](B16119_05_Final_PD_ePub.xhtml#_idTextAnchor146), *Importing,
    Exporting, and Module Data*.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we have two Partner records, `address1` and `address2`,
    and we want to set them on the `self.child_ids` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `write()` method, we would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option (needed for versions before Odoo 13) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `write()` method is used to write dates on existing records. But we also
    need to create and delete records, which we will discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and deleting records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `create()` and `unlink()` model methods allow us to create and delete existing
    records, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `create()` method takes a dictionary with the fields and values for the
    record to be created, using the same syntax as `write()`. Default values are automatically
    applied as expected, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `unlink()` method deletes the records in the recordset, as done in the
    next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `unlink()` method returns a `True` value. Also, during the `delete` operation,
    it triggers log messages informing the cascade deletion of related records, such
    as Chatter messages and followers.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to create a record is to duplicate an existing one. The `copy()`
    model method is available for this. It accepts an optional argument with a dictionary,
    which contains values to override when creating the new record.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to create a new user from the `demo` user, we could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The fields with the `copy=False` attribute won't be automatically copied. To-many
    relational fields have this flag disabled by default, so they won't be copied.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous sections, we have learned how to access data in recordsets and
    create and write to recordsets. However, there are some field types that deserve
    more attention. In the next section, we will discuss specific techniques for working
    with date and time fields.
  prefs: []
  type: TYPE_NORMAL
- en: Working with date and time fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Accessing data in recordsets* section, we saw how to read date and time
    values from records. It is common to also need to perform date calculations and
    to convert dates between their native format and string representations. Here,
    we will see how to perform these kinds of operations.
  prefs: []
  type: TYPE_NORMAL
- en: Odoo provides a few useful functions to create new date and time objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `odoo.fields.Date` object provides these helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `fields.Date.today()` function returns a string with the current date in
    the format expected by the server, using UTC as a reference. This is adequate
    to compute default values. It can be used directly in a date field definition
    by using `default=fields.Date.today`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fields.Date.context_today(record, timestamp=None)` function returns a string
    with the current date in the session's context. The time zone value is taken from
    the record's context. The optional `timestamp` parameter is a `datetime` object
    and will be used instead of the current time if provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `odoo.fields.Datetime` objects provide these datetime creation functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `fields.Datetime.now()` function returns a string with the current `datetime`
    in the format expected by the server, using UTC as a reference. This is adequate
    to compute default values. It can be used directly in a `datetime` field definition
    by using `default=fields.Datetime.now`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fields.Datetime.context_timestamp(record, timestamp)` function converts
    a naive `datetime` value (without time zone) into a time zone-aware `datetime`
    value. The time zone is extracted from the record's context, hence the name of
    the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding and subtracting time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Date objects can be compared and subtracted to find the time elapsed between
    both dates. This time elapsed is a `timedelta` object. A `timedelta` object can
    be added to or subtracted from `date` and `datetime` objects, performing date
    arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: 'These objects are provided by the Python standard library `datetime` module.
    Here is a sample of the essential operations we can do with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A full reference for the `date`, `datetime`, and `timedelta` data types can
    be found at [https://docs.python.org/3/library/datetime.html](https://docs.python.org/3/library/datetime.html).
  prefs: []
  type: TYPE_NORMAL
- en: The `timedelta` object supports weeks, days, hours, seconds, and more. But it
    doesn't support years or months.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform date arithmetic using months or years, we should use the `relativedelta`
    object. Here is an example of adding one year and one month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `relativedelta` object supports advanced date arithmetic, including leap
    years and Easter calculations. The documentation for it can be found at [https://dateutil.readthedocs.io](https://dateutil.readthedocs.io).
  prefs: []
  type: TYPE_NORMAL
- en: 'Odoo also provides a few additional functions in the `odoo.tools.date_utils`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: The `start_of(value, granularity)` function returns the start of a time period
    with the specified granularity, which is a string value with one of `year`, `quarter`,
    `month`, `week`, `day`, or `hour`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `end_of(value, granularity)` function returns the end of a time period with
    the specified granularity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `add(value, **kwargs)` function adds a time interval to the given value.
    The `**kwargs` arguments are to be used by a `relativedelta` object to define
    the time interval. These arguments can be `years`, `months`, `weeks`, `days`,
    `hours`, `minutes`, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `subtract(value, **kwargs)` function subtracts a time interval from the
    given value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These utility functions are also exposed in the `odoo.fields.Date` and the `odoo.fields.Datetime`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples using the previous functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Converting date and time objects to text representations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There will be cases where we need to convert a Python `date` object into a text
    representation. This may be needed, for example, to prepare a user message or
    to format data to send to another system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Odoo field objects provide helper functions to convert the native Python
    objects to string representations:'
  prefs: []
  type: TYPE_NORMAL
- en: The `fields.Date.to_string(value)` function converts a `date` object into a
    string in the format expected by the Odoo server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fields.Datetime.to_string(value)` function converts a `datetime` object
    into a string in the format expected by the Odoo server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These use the Odoo server predefined defaults, which are defined in the following
    constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`odoo.tools.DEFAULT_SERVER_DATE_FORMAT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`odoo.tools.DEFAULT_SERVER_DATETIME_FORMAT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These map to `%Y-%m-%d` and `%Y-%m-%d %H:%M:%S`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `date.strftime` and `datetime.strftime` functions accept a format string
    parameter that can be used for other conversions to text.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Further details on the available format codes can be found at [https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior).
  prefs: []
  type: TYPE_NORMAL
- en: Converting text-represented dates and times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are cases where dates arrive formatted as text strings and need to be
    converted to Python `date` or `datetime` objects. This was frequently needed up
    to Odoo 11, where stored dates were read as text representations. Some tools are
    provided to help with this conversion from text into native data types and then
    back into text.
  prefs: []
  type: TYPE_NORMAL
- en: 'To facilitate this conversion between formats, the `fields.Date` and `fields.Datetime`
    objects provide these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `fields.Date.to_date` function converts a string into a `date` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fields.Datetime.to_datetime(value)` function converts a string into a `datetime`
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of a usage of `to_datetime` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example uses the Odoo internal date format to parse the provided
    string and convert it into a Python `datetime` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For other date and time formats, the `strptime` method from the `date` and
    `datetime` object can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In most cases, the text-represented time will not be in UTC, as expected by
    the Odoo server. The time must be converted to UTC before it can be stored in
    the Odoo database.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the user is in the Europe/Brussels timezone (at +1:00 hours
    from UTC) the `2020-12-01 00:30:00` user time should be stored in UTC as `2020-11-30
    23:30:00`. Here is the code recipe for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This code gets the user time zone name from the context and then uses it to
    convert the naive date to a time zone-aware date. The final step is to convert
    the client time zone date to a UTC date by using `astimezone(pytz.utc)`.
  prefs: []
  type: TYPE_NORMAL
- en: We've now learned specific techniques to work with date and time in Odoo. There
    are also specific techniques to work with recordsets and the values stored in
    relational fields, which we'll discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with recordsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **recordset** is a collection of records, and Python business logic frequently
    needs to use them. There are several operations that can be performed on recordsets,
    such as mapping and filtering. We can also compose new recordsets by adding or
    removing records. Other common operations are inspecting the contents of a recordset
    to check if a particular record is there or not, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 10
  prefs: []
  type: TYPE_NORMAL
- en: Since Odoo 10, recordset manipulation has preserved the record order. This is
    unlike previous Odoo versions, where recordset manipulation was not guaranteed
    to preserve the record order, although addition and slicing maintained the record
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Recordset operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recordsets have a few functions available to perform useful actions on them,
    such as **sorting** or **filtering records**.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the supported functions and attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `recordset.ids` attribute returns a list with the IDs of the recordset elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `recordset.ensure_one()` function checks whether it's a single record (that
    is, a singleton); if it's not, a `ValueError` exception is raised.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `recordset.filtered(<function or str>)` function returns a filtered recordset,
    and this function is a test function to filter records. The argument can instead
    be a string containing a dot-separated sequence of fields to evaluate. The records
    evaluating to a truthy value are selected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `recordset.mapped(<function or str>)` function returns a list of values,
    and the function returns a value for each record. The argument can instead be
    a string containing a dot-separated sequence of fields to evaluate to reach the
    field to return. To-many relations are safe to use in the field sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `recordset.sorted(<function ot str>)` function returns the recordset with
    a specific element order. The function returns a value for each record, which
    are used to sort the recordset. The argument can instead be a string with the
    name of the field to sort by. Note that a dot-notation sequence of fields is not
    allowed. An optional `reverse=True` argument is also available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some usage examples for these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The composition of a recordset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recordsets are immutable, meaning that their values can''t be directly modified.
    Instead, we can compose a new recordset based on existing ones. **Slice notation**,
    which is commonly used with Python lists, can be used on recordsets to extract
    a subset of the records. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rs[0]` and `rs[-1]` retrieve the first element and the last element, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rs[1:]` results in a copy of the recordset without the first element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rs[:1]` returns the first element of the recordset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For a fail-safe way to retrieve the first element of a recordset, use `rs[:1]`
    instead of `rs[0]`. The latter results in an error if `rs` is empty, whereas the
    former will just return an empty recordset in this case. Another option is to
    use the `first()` function from the `odoo.fields` module: `fields.first(rs)`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Recordsets also support the following set operations:'
  prefs: []
  type: TYPE_NORMAL
- en: The  `rs1 | rs2` operation is a *union* set operation and results in a recordset
    with all elements from both recordsets. This is a set-like operation and won't
    result in duplicate elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `self.env.user | self.env.user` returns a single record, such as
    `res.users(1,)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The  `rs1 & rs2` operation is an *intersection* set operation and results in
    a recordset with only the elements present in both recordsets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The  `rs1 - rs2` operation is a *difference* set operation and results in a
    recordset with the `rs1` elements not present in `rs2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Recordsets also support the addition operation (`+`), however, it should be
    avoided. It has a different behavior from the union operation (`|`) and allows
    for duplicate elements in a recordset. However, this is rarely what we want. For
    example, `self.env.user + self.env.user` returns two records, such as `res.users(1,
    1)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can use these operations directly with a value assignment for shorter notation:'
  prefs: []
  type: TYPE_NORMAL
- en: The `self.author_ids |= author1` operation adds the `author1` record if it is
    not in the recordset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `self.author_ids &= author1` operation keeps only the records also present
    in the `author1` recordset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `self.author_ids -= author1` operation removes the specific `author1` record
    if it is present in the recordset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recordset accumulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, we want to loop through some logic and accumulate records resulting
    from each iteration of the loop. The ORM way to accumulate a recordset is to start
    with an empty recordset and then add records to it. To get an empty recordset,
    create a reference to the model. For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The previous code loops three times and on each loop it creates a new partner
    record before accumulating it to the `recs` recordset. As it is a recordset, the
    `recs` variable can be used in cases where recordsets are expected, such as assigning
    a value to a to-many field.
  prefs: []
  type: TYPE_NORMAL
- en: However, accumulating recordsets is not time-efficient and should be avoided
    inside loops. The reason for this is that Odoo recordsets are immutable objects
    and any operation on a recordset implies copying it to get the modified version.
    When appending a record to a recordset, the original recordset is not modified.
    Instead, a copy of it is made with the record appended to it. This copy operation
    consumes time, and the larger the recordset is, the longer it takes.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, alternatives should be considered. For the preceding example, we
    could have accumulated all of the record data dictionaries in a Python list and
    then made a single `create()` call to create all of the records. This is possible
    because the `create()` method can accept a list of dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the loop could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: However, this solution won't work in all cases. Another option is to use a Python
    list to accumulate records. Python lists are mutable objects, and appending elements
    is an efficient operation for them. As Python lists are not actually recordsets,
    this option can't be used where a recordset is expected, for example, an assignment
    to a to-many field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of accumulating records to a Python list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The previous examples illustrate a few techniques that can be used in loops
    to build recordsets from individual elements. However, there are many cases where
    the loop is not strictly needed and operations such as `mapped()` and `filtered()`
    can provide more efficient ways to achieve the desired aim.
  prefs: []
  type: TYPE_NORMAL
- en: Recordset comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are cases where we need to compare the content of a recordset to decide
    what further action is needed. Recordsets support the expected comparison operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check if a `<rec>` record is an element of a `<my_recordset>` recordset,
    the following code can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<rec> in <my_recordset>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<rec> not in <my_recordset>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Recordsets can also be compared to check if one is contained in another. To
    compare two recordsets, use `set1` and `set2`:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `set1 <= set2` and `set1 < set2` returns `True` if all of the elements
    in `set1` are also in `set2`. The `<` operators return `False` if both recordsets
    have the same elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `set1 >= set2` and `set1 > set2` returns `True` if all of the elements
    in `set2` are also in `set1`. The `>` operators return `False` if both recordsets
    have the same elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions and low-level SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ORM methods that are called from a client run in a *transaction*. Transactions
    ensure correctness in the case of concurrent writes or failures. During a transaction,
    the data records used are locked, protecting them from other concurrent transactions
    and ensuring that they are not unexpectedly changed. In case of failure, all the
    transaction changes are rolled back, returning to the initial state.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction support is provided by the PostgreSQL database. When an ORM method
    is called from a client, a new transaction is initiated. If an error occurs during
    the method execution, any changes that have been made are reverted. If the method
    execution completes with no errors, then the changes made are committed, making
    them effective and visible to all other transactions.
  prefs: []
  type: TYPE_NORMAL
- en: This is automatically handled for us, and we usually don't need to worry about
    it. However, in some advanced use cases, it might be useful to have control over
    the current transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 13
  prefs: []
  type: TYPE_NORMAL
- en: Since Odoo 13, database write operations are not done while the method is running.
    Instead, they accumulate in a memory cache, and the actual database writing is
    delayed to the end of the execution of the method, which is performed by a `flush()`
    call that is invoked automatically at that point.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling database transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are cases where controlling the transaction can be useful and the `self.env.cr`
    database cursor can be used for this. An example of this is looping through records
    to perform an operation on each of them, where we want to skip the ones with operation
    errors without affecting the other ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, the object provides the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`self.env.cr.commit()` commits the transaction''s buffered write operations,
    making them effective in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.env.cr.rollback()` cancels the transaction''s `write` operations since
    the last commit or all of them if no commit was made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An Odoo `shell` session mimics a method execution context. This means that the
    database writes are not performed until `self.env.cr.commit()` is called.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Executing raw SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQL can be run directly in the database by using the cursor `execute()` method.
    This takes a string with the SQL statement to run and a second optional argument
    with the values to use as parameters for the SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values parameter can be a tuple or a dict. When using a tuple, the parameters
    are replaced with `%s`, and when using a dict, they are replaced with `%(<name>)s`.
    Here are examples of both approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Any of the previous instructions run the SQL, replacing the parameters and preparing
    a cursor with the results that needs to be fetched. More details on this can be
    found in the `psycopg2` documentation at [https://www.psycopg.org/docs/usage.html#query-parameters](https://www.psycopg.org/docs/usage.html#query-parameters).
  prefs: []
  type: TYPE_NORMAL
- en: Caution!
  prefs: []
  type: TYPE_NORMAL
- en: With `cr.execute()`, we should not directly compose the SQL query concatenating
    parameters. Doing so is known to be a security risk that can be exploited through
    SQL injection attacks. Always use the `%s` placeholders with the second parameter
    to pass values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fetch the results, the `fetchall()` function can be used, returning the
    rows'' `tuples`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dictfetchall()` function can also be used to retrieve records as dicts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The `self.env.cr` database cursor object is an Odoo-specific wrapper around
    the PostgreSQL library, `psycopg2`. This means that the `psycopg2` documentation
    is helpful to understand how to fully use the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.psycopg.org/docs/cursor.html](https://www.psycopg.org/docs/cursor.html)'
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to run `UPDATE` and `INSERT`. The Odoo environment relies
    on a data cache, and it may become inconsistent with the database when these DML
    instructions are executed. For this reason, after running using raw DML, the environment
    cached should be invalidated by using `self.env.cache.invalidate(fnames=None,
    ids=None)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`fnames` is a list with the names of the fields to invalidate and refresh.
    If this is not provided, all fields will be invalidated.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ids` is a list with the record IDs to invalidate and refresh. If this is not
    provided, all will be invalidated.'
  prefs: []
  type: TYPE_NORMAL
- en: Caution!
  prefs: []
  type: TYPE_NORMAL
- en: Executing SQL directly in the database bypasses the ORM validations and dependencies
    and can lead to inconsistent data. You should use it only if you're sure of what
    you are doing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to work with model data to perform **CRUD**
    operations—that is, **creating**, **reading**, **updating**, and **deleting**
    data—and all the techniques needed to make use of and manipulate *recordsets*.
    This provides the foundation needed for us to implement our business logic and
    automation code.
  prefs: []
  type: TYPE_NORMAL
- en: To experiment with the ORM API, we used the Odoo interactive shell. We ran our
    commands in an environment accessible through `self.env`. The environment is similar
    to the one provided in the model method, and so it is a useful playground for
    exploring the Odoo API.
  prefs: []
  type: TYPE_NORMAL
- en: The environment allows us to query data from any Odoo model that is made available
    as a recordset. We learned about the different ways to create recordsets and then
    how to read the data provided, including special data types such as dates, binary
    values, and relational fields.
  prefs: []
  type: TYPE_NORMAL
- en: Another fundamental capability in Odoo is to write back data. In this chapter,
    we also learned how to create new records, write to existing records, and delete
    records.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at working with date and time values by using the Python built-in
    tools and a few additional helper functions included in the Odoo framework.
  prefs: []
  type: TYPE_NORMAL
- en: Recordsets can be manipulated to add elements, filter out records, reorder,
    or accumulate values, as well as to compare them or check for the inclusion of
    particular records. Any of these operations may be needed when implementing business
    logic, and this chapter presented the essential techniques for all of these.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in some cases, we may need to skip using the ORM model and use low-level
    SQL operations to directly access the database or have finer control over transactions.
    These allow us to address the occasional cases where the ORM model is not the
    best tool for the job.
  prefs: []
  type: TYPE_NORMAL
- en: With all these tools under our belt, we are ready for the next chapter, where
    we will add the business logic layer for our models and implement model methods
    that use the ORM API to automate actions.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official Odoo documentation for recordsets can be found at [https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html](https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html).
  prefs: []
  type: TYPE_NORMAL
