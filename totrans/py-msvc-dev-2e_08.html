<html><head></head><body>
  <div><h1 class="chapterNumber">8</h1>
    <h1 id="_idParaDest-140" class="chapterTitle">Making a Dashboard</h1>
    <p class="normal">Most of the work done so far has focused on building microservices and making them interact with each other. It is time to bring humans into the equation, adding a <strong class="keyword">User Interface</strong> (<strong class="keyword">UI</strong>) through which our end users can use the system with a browser and change settings that may be awkward or unwise to do through Slack.</p>
    <p class="normal">Modern web applications greatly rely on client-side JavaScript (JS, also known as ECMAScript). Some JS frameworks go all the way in terms of providing a full <strong class="keyword">Model-View-Controller</strong> (<strong class="keyword">MVC</strong>) system, which runs in the browser and manipulates the <strong class="keyword">Document Object Model</strong> (<strong class="keyword">DOM</strong>), the structured representation of the web page that is rendered in a browser.</p>
    <p class="normal">The web development paradigm has shifted from rendering everything on the side of the server, to rendering everything on the client side with data collected from the server on demand. The reason is that modern web applications change portions of a loaded web page dynamically instead of calling the server for a full rendering. It is faster, requires less network bandwidth, and offers a richer user experience. Delays of a few seconds can cause a user to navigate away from your page, unless they have a strong need to visit it, such as, more specifically, a need to shop or read. One of the biggest examples of this client-side shift is the Gmail app, which pioneered these techniques around 2004.</p>
    <p class="normal">Tools like Facebook's <strong class="keyword">ReactJS</strong> (<a href="https://facebook.github.io/react/">https://facebook.github.io/react/</a>) provide high-level APIs to avoid manipulating the DOM directly and offer a level of abstraction which makes client-side web development as comfortable as building Quart applications.</p>
    <p class="normal">That said, there seems to be a new JS framework every other week, and it is often hard to decide which one to use. <strong class="keyword">AngularJS</strong> (<a href="https://angularjs.org/">https://angularjs.org/</a>) used to be the coolest toy, but now many developers have switched to implementing most of their application UIs with ReactJS. There are also newer languages, such as <strong class="keyword">Elm</strong> (<a href="https://elm-lang.org">https://elm-lang.org</a>), which offers a functional programming language that compiles to JavaScript, allowing the compile-time detection of many common programming errors while also having a runtime that will work with any browser. In the future, no doubt, another new player will be popular.</p>
    <p class="normal">This volatility is not a bad sign at all. It simply means much innovation is happening in the JavaScript and browser ecosystem. Features like service workers allow developers to run JS code in the background natively: <a href="https://developer.mozilla.org/en/docs/Web/API/Service_Worker_API">https://developer.mozilla.org/en/docs/Web/API/Service_Worker_API</a>.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">WebAssembly</code> (<a href="https://webassembly.org/">https://webassembly.org/</a>), an extremely fast and safe sandboxed environment, allows developers to produce resource-intensive tools, such as 3D rendered environments, all running in a web browser.</p>
    <p class="normal">If you have a clean separation between your UI and the rest of the system, moving from one JS framework to another should not be too hard. This means that you should not change how your microservices publish data to make them specific to a JS framework.</p>
    <p class="normal">For our purposes, we shall use ReactJS to build our little dashboard, and we will wrap it in a dedicated Quart application that bridges it to the rest of the system. We will also see how that app can interact with all our microservices. We have chosen this approach due to ReactJS's current popularity, though you will also get excellent results in any of the other popular environments.</p>
    <p class="normal">This chapter is composed of the following three parts:</p>
    <ul>
      <li class="bullet">Building a ReactJS dashboard—a short introduction to ReactJS with an example</li>
      <li class="bullet">How to embed ReactJS in a Quart app and structure the application</li>
      <li class="bullet">Authentication and authorization</li>
    </ul>
    <p class="normal">By the end of this chapter, you should have a good understanding of how to build a web UI using Quart, with the knowledge of how to make it interact with microservices—whether you choose to use ReactJS or not.</p>
    <h1 id="_idParaDest-141" class="title">Building a ReactJS dashboard</h1>
    <p class="normal">The ReactJS framework<a id="_idIndexMarker510"/> implements its abstraction of the DOM and provides fast and efficient machinery to support dynamic events. Creating a ReactJS UI involves creating classes with a few standard methods, which will get called when events happen, such as the DOM being ready, the React class having been loaded, or user input occurring.</p>
    <p class="normal">In a similar way to a web server such as nginx, taking care of all the difficult and common parts of the network traffic and leaving you to deal with the logic in your endpoints, ReactJS lets you concentrate on the implementation in your methods instead of worrying<a id="_idIndexMarker511"/> about the state of the DOM and the browser. Implementing classes for React can be done in pure JavaScript, or using an extension called JSX. We will discuss JSX in the next section.</p>
    <h2 id="_idParaDest-142" class="title">The JSX syntax</h2>
    <p class="normal">Representing XML<a id="_idIndexMarker512"/> markup in a programming<a id="_idIndexMarker513"/> language can be hard work. A seemingly simple approach might be to treat all the markup as strings and format the content as if it were a template, but this approach means that your code does not understand what all that markup means. The other extreme would be creating each markup element as an object and rendering it all to the text representation.</p>
    <p class="normal">Instead, there is a better, hybrid model using a transpiler – a type of compiler that generates a different form of source code instead<a id="_idIndexMarker514"/> of a runnable program. The JSX syntax extension (<a href="https://facebook.github.io/jsx/">https://facebook.github.io/jsx/</a>) adds XML tags to JavaScript and can be transpiled into pure JavaScript, either in the browser or beforehand. JSX is promoted by the ReactJS community as the best way to write React apps.</p>
    <p class="normal">In the following example, a <code class="Code-In-Text--PACKT-">&lt;script&gt;</code> section contains a <code class="Code-In-Text--PACKT-">greeting</code> variable whose value is an XML structure representing a <code class="Code-In-Text--PACKT-">div</code>; this syntax is valid JSX. From there, the <code class="Code-In-Text--PACKT-">ReactDOM.render()</code> function can render the <code class="Code-In-Text--PACKT-">greeting</code> variable in the DOM at the <code class="Code-In-Text--PACKT-">id</code> you specify:</p>
    <pre class="programlisting code"><code class="hljs-code">    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
 
    &lt;head lang="en"&gt;
        &lt;meta charset="UTF-8"&gt;
    &lt;/head&gt;
 
    &lt;body&gt;
        &lt;div id="content"&gt;&lt;/div&gt;
        &lt;script src="img/react.development.js" crossorigin&gt;&lt;/script&gt;
        &lt;script src="img/react-dom.development.js" crossorigin&gt;&lt;/script&gt;
        &lt;script src="img/babel.min.js" crossorigin&gt;&lt;/script&gt;
        &lt;script type="text/babel"&gt;
            var greeting = (
                &lt;div&gt;
                    Hello World
                &lt;/div&gt;)
            ReactDOM.render(greeting, document.getElementById('content'));
        &lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
    <p class="normal">The two ReactJS scripts<a id="_idIndexMarker515"/> are part of the React<a id="_idIndexMarker516"/> distribution, and here we are using the development versions, which will provide more helpful error messages while we are still writing our code. Smaller, encoded versions—known as minified—are<a id="_idIndexMarker517"/> preferred for production use, as they use less network bandwidth and cache storage space. The <code class="Code-In-Text--PACKT-">babel.min.js</code> file is part of the Babel distribution and needs to be loaded before the browser encounters any JSX syntax.</p>
    <p class="normal">Babel (<code class="Code-In-Text--PACKT-">https://babeljs.io/</code>) is a transpiler<a id="_idIndexMarker518"/> that can convert JSX to JS on the fly, among other available conversions. To use it, you simply need to mark a script as being of type <code class="Code-In-Text--PACKT-">text/babel</code>.</p>
    <p class="normal">The JSX syntax is the only specific syntax difference to know about React, as everything else is done with common JavaScript. From there, building a ReactJS application involves creating classes to render markup and respond to events, and these will be used to render the web pages.</p>
    <p class="normal">Let's now look at the heart of ReactJS – components.</p>
    <h2 id="_idParaDest-143" class="title">React components</h2>
    <p class="normal">ReactJS<a id="_idIndexMarker519"/> is based on the idea that a web page can be constructed from basic components, which are invoked to render different parts of the display and respond to events such as typing, clicks, and new data appearing. </p>
    <p class="normal">As an example, if you want to display a list of people, you can create a <code class="Code-In-Text--PACKT-">Person</code> class that is in charge of rendering a single person's information, given its values, and a <code class="Code-In-Text--PACKT-">People</code> class that iterates through a list of people and calls the <code class="Code-In-Text--PACKT-">Person</code> class to render each item.</p>
    <p class="normal">Each class is created with the <code class="Code-In-Text--PACKT-">React.createClass()</code> function, which receives a mapping containing the future class methods. The <code class="Code-In-Text--PACKT-">createClass()</code> function generates a new class, and sets a <code class="Code-In-Text--PACKT-">props</code> attribute to hold some properties alongside the provided methods. In the following example, in a new JavaScript file, we define a <code class="Code-In-Text--PACKT-">Person</code> class with a <code class="Code-In-Text--PACKT-">render()</code> function, which returns a <code class="Code-In-Text--PACKT-">&lt;div&gt;</code> tag, and a <code class="Code-In-Text--PACKT-">People</code> class which assembles the <code class="Code-In-Text--PACKT-">Person</code> instances:</p>
    <pre class="programlisting code"><code class="hljs-code">class Person extends React.Component {
    render() {
        return (
            &lt;div&gt;{this.props.name} ({this.props.email})&lt;/div&gt;
        );
    }
}
class People extends React.Component {
    render() {
        var peopleNodes = this.props.data.map(function (person) {
            return (
                &lt;Person
                    key={person.email}
                    name={person.name}
                    email={person.email}
                /&gt;
            );
        });
        return (
            &lt;div&gt;
                {peopleNodes}
            &lt;/div&gt;
        );
    }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Person</code> class returns a <code class="Code-In-Text--PACKT-">div</code>—a section or division—containing details about the person by referring<a id="_idIndexMarker520"/> to the <code class="Code-In-Text--PACKT-">props</code> attribute in the instance. Updating these properties will update the object, and so update the display. </p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">props</code> array is populated when the <code class="Code-In-Text--PACKT-">Person</code> instance is created; this is what happens in the <code class="Code-In-Text--PACKT-">render()</code> method of the <code class="Code-In-Text--PACKT-">People</code> class. The <code class="Code-In-Text--PACKT-">peopleNodes</code> variable iterates through the <code class="Code-In-Text--PACKT-">People.props.data</code> list, which contains a list of the people we want to show. Each <code class="Code-In-Text--PACKT-">Person</code> class is also provided with a unique key so that it can be referred to later if needed.</p>
    <p class="normal">All that is left to do is instantiate a <code class="Code-In-Text--PACKT-">People</code> class and put a list of people to be displayed by React in its <code class="Code-In-Text--PACKT-">props.data</code> list. In our Jeeves app, this list can be provided by the appropriate microservice—the data service for information that we store, or a different service if we are fetching data from a third party. We can load<a id="_idIndexMarker521"/> the data asynchronously using an <strong class="keyword">Asynchronous JavaScript and XML</strong> (<strong class="keyword">AJAX</strong>) pattern using the built-in fetch method, or another helper library.</p>
    <p class="normal">That is what happens in the <code class="Code-In-Text--PACKT-">loadPeopleFromServer()</code> method in the following code, which builds<a id="_idIndexMarker522"/> on the previous example – add it to the same <code class="Code-In-Text--PACKT-">jsx</code> file. The code calls our data service on the endpoint that lists all users, using a <code class="Code-In-Text--PACKT-">GET</code> request and expecting some JSON as a response. Then, it sets the properties of the React component with the result, which propagates down through the other classes:</p>
    <pre class="programlisting code"><code class="hljs-code">class PeopleBox extends React.Component {
    constructor(props) {
        super(props);
        this.state = { data: [] };
    }
    loadPeopleFromServer() {
        fetch('http://localhost:5000/api/users')
            .then(response =&gt; response.json())
            .then(data =&gt; {
                console.log(data);
                this.setState({
                    data: data,
                });
                console.log(this.state);
            })
            .catch(function (error) {
                console.log(error);
            });
    }
    componentDidMount() {
        this.loadPeopleFromServer();
    }
        render() {
            return (
                &lt;div&gt;
                    &lt;h2&gt;People&lt;/h2&gt;
                    &lt;People data={this.state.data} /&gt;
                &lt;/div&gt;
            );
        }
 
    }
 
    const domContainer = document.querySelector('#people_list');
    ReactDOM.render(React.createElement(PeopleBox), domContainer);
</code></pre>
    <p class="normal">When the state<a id="_idIndexMarker523"/> changes, an event is passed to the <code class="Code-In-Text--PACKT-">React</code> class to update the DOM with the new data. The framework calls the <code class="Code-In-Text--PACKT-">render()</code> method, which displays the <code class="Code-In-Text--PACKT-">&lt;div&gt;</code> containing <code class="Code-In-Text--PACKT-">People</code>. The <code class="Code-In-Text--PACKT-">People</code> instance, in turn, passes data down to each <code class="Code-In-Text--PACKT-">Person</code> instance in a cascade.</p>
    <p class="normal">To trigger the <code class="Code-In-Text--PACKT-">loadPeopleFromServer()</code> method, the class implements the <code class="Code-In-Text--PACKT-">componentDidMount()</code> method, which gets called once the class instance is created and mounted in React, ready to be displayed. Last, but not least, the class's constructor provides an empty set of data so that in the time before anything has loaded, the display is not broken.</p>
    <p class="normal">This whole process of decomposition and chaining may seem complicated at first but, once in place, it is powerful and straightforward to use: it allows you to focus on rendering each component and letting React deal with how to do it in the most efficient way in the browser.</p>
    <p class="normal">Each component has a state, and when something changes, React first updates its own internal representation of the DOM—the virtual DOM. Once that virtual DOM is changed, React can apply the required changes efficiently on the actual DOM.</p>
    <p class="normal">All the JSX code we've seen in this section can be saved in a JSX file – it's static content, so let's place it in a directory called <code class="Code-In-Text--PACKT-">static</code> – and used in an HTML page as follows. There is also a small helper microservice to serve these files in the code samples at <a href="https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSample">https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSamples</a>.</p>
    <pre class="programlisting code"><code class="hljs-code">    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
 
    &lt;head lang="en"&gt;
        &lt;meta charset="UTF-8"&gt;
    &lt;/head&gt;
 
    &lt;body&gt;
        &lt;div class="container"&gt;
            &lt;h1&gt;Jeeves Dashboard&lt;/h1&gt;
            &lt;br&gt;
            &lt;div id="people_list"&gt;&lt;/div&gt;
        &lt;/div&gt;
 
        &lt;script src="img/react.development.js" crossorigin&gt;&lt;/script&gt;
        &lt;script src="img/react-dom.development.js" crossorigin&gt;&lt;/script&gt;
        &lt;script src="img/babel.min.js" crossorigin&gt;&lt;/script&gt;
        &lt;script src="img/people.jsx" type="text/babel"&gt;&lt;/script&gt;
        &lt;script type="text/babel"&gt;
 
        &lt;/script&gt;
 
    &lt;/body&gt;
 
    &lt;/html&gt;
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">PeopleBox</code> class<a id="_idIndexMarker524"/> is instantiated with the <code class="Code-In-Text--PACKT-">/api/users</code> URL for this demonstration, and once the web page has loaded and been processed, the <code class="Code-In-Text--PACKT-">componentDidMount</code> methods are triggered, React calls that URL, and it expects to get back a list of people, which it passes down the chain of components.</p>
    <p class="normal">Notice that we have also set up where to render the components in the last two lines: first, we find the element in the HTML with the right identifier, and then tell React to render a class within it.</p>
    <p class="normal">Using transpilation directly in the browser is unnecessary, as it can be done while building and releasing the application, as we will see in the next section.</p>
    <p class="normal">This section described a very basic usage of the ReactJS library and did not dive into all its possibilities. If you want to get more info on React, you should<a id="_idIndexMarker525"/> try the tutorial at <a href="https://reactjs.org/tutorial/tutorial.html">https://reactjs.org/tutorial/tutorial.html</a> as your first step. This tutorial shows you how your React components can interact with the user through events, which is the next step once you know how to do some basic rendering.</p>
    <h2 id="_idParaDest-144" class="title">Pre-processing JSX</h2>
    <p class="normal">So far, we have<a id="_idIndexMarker526"/> relied on the web<a id="_idIndexMarker527"/> browser to convert the JSX files for us. We could still do that, however, it will be the same work being done by each web browser that visits our site. Instead, we can process our own JSX files and provide pure JavaScript to people visiting our site. To do that we must install some tools.</p>
    <p class="normal">Firstly, we need a JavaScript package manager. The most<a id="_idIndexMarker528"/> important one to use is <code class="Code-In-Text--PACKT-">npm</code> (<a href="https://www.npmjs.com/">https://www.npmjs.com/</a>). The <code class="Code-In-Text--PACKT-">npm</code> package manager is installed via <code class="Code-In-Text--PACKT-">Node.js</code>. On macOS, the <code class="Code-In-Text--PACKT-">brew install node</code> command does the trick, or you<a id="_idIndexMarker529"/> can go to the <strong class="keyword">Node.js</strong> home page (<a href="https://nodejs.org/en/">https://nodejs.org/en/</a>) and download it to the system. Once Node.js and <code class="Code-In-Text--PACKT-">npm</code> are installed, you should be able to call the <code class="Code-In-Text--PACKT-">npm</code> command from the shell as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">$ npm -v 
7.7.6
</code></pre>
    <p class="normal">Converting our JSX files<a id="_idIndexMarker530"/> is straightforward. Move the <code class="Code-In-Text--PACKT-">.jsx</code> file we have created from <code class="Code-In-Text--PACKT-">static/</code> to a new directory called <code class="Code-In-Text--PACKT-">js-src</code>. Our directory layout should now look like this:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">mymicroservice/</code>
        <ul>
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">templates/</code> – all of our <code class="Code-In-Text--PACKT-">html</code> files</li>
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">js-src/</code> – our <code class="Code-In-Text--PACKT-">jsx</code> source code</li>
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">static/</code> – the JavaScript results of the transpilation</li>
        </ul>
      </li>
    </ul>
    <p class="normal">We can then install the tools we need using:</p>
    <pre class="programlisting con"><code class="hljs-con">$ npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/preset-react
</code></pre>
    <p class="normal">Then, for our development, we can start a command that will continuously watch our <code class="Code-In-Text--PACKT-">js-src</code> directory for any changes to the files, and automatically update them, in much the same way that the development version of Quart will reload Python files automatically. In a new terminal, type:</p>
    <pre class="programlisting con"><code class="hljs-con">$ npx babel --watch js-src/ --out-dir static/  --presets @babel/preset-react
</code></pre>
    <p class="normal">We can then see that it creates <code class="Code-In-Text--PACKT-">.js</code> files for you and does so each time you save your changes to the JSX files in <code class="Code-In-Text--PACKT-">js-src/</code>.</p>
    <p class="normal">To deploy our application, we can either generate the JavaScript files and commit them into the repository or generate them as part of the CI process. In either case, the command to process the files once is remarkably similar—we just don't watch the directory, and we use the production presets:</p>
    <pre class="programlisting con"><code class="hljs-con">$ npx babel js-src/ --out-dir static/ --presets @babel/preset-react
</code></pre>
    <p class="normal">With<a id="_idIndexMarker531"/> all the changes, the final <code class="Code-In-Text--PACKT-">index.html</code> file<a id="_idIndexMarker532"/> just needs a small change to use the <code class="Code-In-Text--PACKT-">.js</code> file instead of the <code class="Code-In-Text--PACKT-">.jsx</code> one:</p>
    <pre class="programlisting code"><code class="hljs-code">        &lt;script src="img/people.js"&gt;&lt;/script&gt; 
</code></pre>
    <p class="normal">Now that we have the basic layout for building a React-based UI, let's see how we can embed it in our Quart world.</p>
    <h1 id="_idParaDest-145" class="title">ReactJS and Quart</h1>
    <p class="normal">From the perspective of the server, the JavaScript code is a static file, and so serving React apps with Quart<a id="_idIndexMarker533"/> is no trouble<a id="_idIndexMarker534"/> at all. The HTML page can be rendered with Jinja2, and the transpiled JSX files can be provided as static content alongside it, much like you would do for plain JavaScript files. We can also get the React distribution and serve those files, or rely on a <strong class="keyword">Content Delivery Network </strong>(<strong class="keyword">CDN</strong>) to provide them.</p>
    <p class="normal">In many cases a CDN is the better option, as retrieving the files will be faster, and the browser then has the option of recognizing that it has already downloaded these files and can use a cached copy to save time and bandwidth. Let's name our Quart application <code class="Code-In-Text--PACKT-">dashboard</code>, and start off with a simple structure like this:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">setup.py</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">dashboard/</code>
        <ul>
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">__init__.py</code></li>
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">app.py</code></li>
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">templates/</code></li>
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">index.html</code></li>
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">static/</code></li>
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">people.jsx</code></li>
        </ul>
      </li>
    </ul>
    <p class="normal">The basic Quart application that serves the unique HTML file will look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">    from quart import Quart, render_template 
    app = Quart(__name__) 
 
    @app.route('/') 
    def index(): 
        return render_template('index.html') 
 
    if __name__ == '__main__': 
        app.run() 
</code></pre>
    <p class="normal">Thanks to Quart's convention on static assets, all the files contained inside the <code class="Code-In-Text--PACKT-">static/</code> directory are served under the <code class="Code-In-Text--PACKT-">/static</code> URL. The <code class="Code-In-Text--PACKT-">index.html</code> template looks like the one described in the previous section and can grow into something Quart-specific later on. That is all we need to serve a ReactJS-based<a id="_idIndexMarker535"/> app through<a id="_idIndexMarker536"/> Quart. </p>
    <p class="normal">Throughout this section, we have worked on the assumption that the JSON data that React picked was served by the same Quart app. Doing AJAX calls on the same domain is not an issue, but in case you need to call a microservice that belongs to another domain, there are a few changes required on both the server and the client side.</p>
    <h2 id="_idParaDest-146" class="title">Cross-origin resource sharing</h2>
    <p class="normal">Allowing<a id="_idIndexMarker537"/> client-side JavaScript to perform cross-domain requests is a potential security risk. If the JS code that's executed in the client page for your domain tries to request a resource from another domain that you don't own, it could potentially run malicious JS code and harm your users. This is why all browsers<a id="_idIndexMarker538"/> use the W3C standard for cross-origin resources (<a href="https://www.w3.org/TR/2020/SPSD-cors-20200602/">https://www.w3.org/TR/2020/SPSD-cors-20200602/</a>) when a request is made. They ensure that the requests can only be made to the domain that served the page to us.</p>
    <p class="normal">Beyond security, it is also a good way to prevent someone from using your bandwidth for their web app. For instance, if you provide a few font files on your website, you might not want another website to use them on their page and use your bandwidth without any control. However, there are legitimate use cases for wanting to share your resources with other domains, and you can set up rules on your service to allow other domains to reach your resources.</p>
    <p class="normal">That is what <strong class="keyword">Cross-Origin Resource Sharing</strong> (<strong class="keyword">CORS</strong>) is all about. When the browser sends a request to your service, an <code class="Code-In-Text--PACKT-">Origin</code> header is added, and you can control whether it is in the list of authorized domains. If not, the CORS protocol requires that you send back a few headers listing the allowed domains. There is also a <code class="Code-In-Text--PACKT-">preflight</code> mechanism where the browser questions the endpoint via an <code class="Code-In-Text--PACKT-">OPTIONS</code> call to know whether the request it wants to make is authorized and what capabilities the server has available. On the client side, you do not have to worry about setting up these mechanisms. The browser makes the decisions for you, depending on your requests.</p>
    <p class="normal">On the server<a id="_idIndexMarker539"/> side, however, you need to make sure your endpoints answer the <code class="Code-In-Text--PACKT-">OPTIONS</code> calls, and you need to decide which domains can reach your resources. If your service is public, you can authorize all domains with a wildcard. However, for a microservice-based application where you control the client side, you should restrict the domains. The <strong class="keyword">Quart-CORS</strong> (<a href="https://gitlab.com/pgjones/quart-cors/">https://gitlab.com/pgjones/quart-cors/</a>) project allows us to add support for this very simply:</p>
    <pre class="programlisting code"><code class="hljs-code">    # quart_cors_example.py
    from quart import Quart
    from quart_cors import cors
    app = Quart(__name__)
    app = cors(app, allow_origin="https://quart.com")
    @app.route("/api")
    async def my_microservice():
        return {"Hello": "World!"}
</code></pre>
    <p class="normal">When running this app and using <code class="Code-In-Text--PACKT-">curl</code> to do a <code class="Code-In-Text--PACKT-">GET</code> request, we can see the results in the <code class="Code-In-Text--PACKT-">Access-Control-Allow-Origin: * header</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">$ curl -H "Origin: https://quart.com" -vvv http://127.0.0.1:5000/api
*   Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to 127.0.0.1 (127.0.0.1) port 5200 (#0)
&gt; GET /api HTTP/1.1
&gt; Host: 127.0.0.1:5000
&gt; User-Agent: curl/7.64.1
&gt; Accept: */*
&gt; Origin: https://quart.com
&gt;
&lt; HTTP/1.1 200
&lt; content-type: application/json
&lt; content-length: 18
&lt; access-control-allow-origin: quart.com
&lt; access-control-expose-headers:
&lt; vary: Origin
&lt; date: Sat, 10 Apr 2021 18:20:32 GMT
&lt; server: hypercorn-h11
&lt;
* Connection #0 to host 127.0.0.1 left intact
{"Hello":"World!"}* Closing connection 0
</code></pre>
    <p class="normal">Quart-CORS<a id="_idIndexMarker540"/> allows finer-grained permissions, with decorators that allow protecting a single resource or blueprint instead of the whole app, or limiting methods to <code class="Code-In-Text--PACKT-">GET</code>, <code class="Code-In-Text--PACKT-">POST</code>, or others. It's also possible to set configuration using environment variables, which helps the app remain flexible and get the correct settings at runtime.</p>
    <p class="normal">For an in-depth understanding<a id="_idIndexMarker541"/> of CORS, the MDN page is a great resource that can be found here: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</a>. In this section, we have looked at how to set up CORS headers in our services to allow cross-domain calls, which are useful in JS apps. What's still missing to make our JS app fully functional is authentication and authorization.</p>
    <h1 id="_idParaDest-147" class="title">Authentication and authorization</h1>
    <p class="normal">The React dashboard<a id="_idIndexMarker542"/> needs to be able<a id="_idIndexMarker543"/> to authenticate its users and perform authorized calls on some microservices. It also needs to enable the user to grant access to any third-party sites we support, such as Strava or GitHub.</p>
    <p class="normal">We assume that the dashboard only works when you are authenticated and that there are two kinds of users: first-time and returning. The following is the user story for first-time users:</p>
    <blockquote class="packt_quote">As a first-time user, when I visit the dashboard, there's a "login" link. When I click on it, the dashboard redirects me to Slack to grant access to my resources. Slack then redirects me back to the dashboard, and I am connected. The dashboard then starts to fill with my data.</blockquote>
    <p class="normal">As described, our Quart app performs an OAuth2 conversation with Slack to authenticate users—and we know that since we are setting up a Slack bot, people should already have an account there. Connecting to Slack also means we need to store the access token in the user profile so we can use it to fetch data later on.</p>
    <p class="normal">Before going further, we need to make a design decision: do we want the dashboard merged with the dataservice, or do we want to have two separate apps?</p>
    <h2 id="_idParaDest-148" class="title">A note about Micro Frontends</h2>
    <p class="normal">Now we are discussing authenticating<a id="_idIndexMarker544"/> our users with a web frontend, there is the question of where we should put the corresponding code. One recent trend in frontend architecture is the idea of Micro Frontends. Facing many of the same scaling and interoperability troubles as the backend has faced, some organizations are shifting towards small, self-contained user interface components that can be included in a larger site.</p>
    <p class="normal">Let's imagine a shopping website. When you visit the front page, there will be several different parts, including:</p>
    <ul>
      <li class="bullet">Shopping categories</li>
      <li class="bullet">Site-wide news and events, such as upcoming sales</li>
      <li class="bullet">Highlighted and promoted items for sale, including customized recommendations</li>
      <li class="bullet">A list of items you have recently viewed</li>
      <li class="bullet">A widget allowing you to sign in or register for an account, plus other administrative tools</li>
    </ul>
    <p class="normal">If we develop a single web page to deal with all of these elements, it can become large and complex very quickly, especially if we need to repeat elements across different pages on the site. With many sites, these different features are kept separate by separating out the <code class="Code-In-Text--PACKT-">&lt;div&gt;</code> tags that anchor them in the page, and keeping the code in separate JavaScript files—whether or not those files are separate by the time they are loaded into the web page, as they have likely been compiled and minified.</p>
    <p class="normal">This approach introduces some of the same complications that a monolithic backend suffers from. A change to any of the backend or its user interface means updating a microservice and the user interface elements that query it, and those may well be in different source control repositories or managed by different teams. Perhaps support for both the old and new ways has to be introduced for a managed migration, or careful timing with different deployment mechanisms has to happen.</p>
    <p class="normal">By using a Micro Frontend architecture, these UI features can all be the responsibility of different teams and services. If the "recommendations" feature suddenly requires a new backend or a different JavaScript framework, that is possible, as the main site only knows about it as a self-contained feature to be included. Any change can also be self-contained, as the Micro Frontend UI components for the recommendations engine would live in the same repository and be provided by the same service. As long as the technique to include the Micro Frontend component doesn't change, the main user interface doesn't need to be changed; changes can be controlled entirely through the microservice it depends on.</p>
    <p class="normal">This also frees<a id="_idIndexMarker545"/> up the people working on each component, as they can release new features and bug fixes on their own schedule without large cross-team coordination to deploy updated features in multiple areas. The teams just have to ensure their UI is included in a consistent manner, accepts the same data, such as a customer identifier, and returns a UI element of the desired size.</p>
    <p class="normal">Let's look at the Packt website as an example. When loading the main web page, we get to see a banner along the top containing the usual options we expect, a banner below for current promotions and events, and then a listing of recently added stock to be brought to the reader's attention:</p>
    <figure class="mediaobject"><img src="img/B17108_08_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.1: Packt home page and its constituent parts</p>
    <p class="normal">If we were designing this page, we could construct at least three different micro-frontends: an authentication<a id="_idIndexMarker546"/> component that handles sessions and logging in, an events component that can display and react to upcoming conferences and promotions, and an inventory component that can display current stock. This approach isn't ideal for all situations; on many occasions, a user interface needs to interact closely with other elements, or perhaps the spread of knowledge within an organization doesn't allow it to produce many small user interface components this way.</p>
    <p class="normal">It is also worth noting that this architecture does not require many different URLs. The same nginx load balancer could be configured to route different URLs to different backend services without the client being any the wiser—and this may give a useful approach to migrating to such an architecture, as it lowers the chance of you needing to update the endpoint URLs.</p>
    <p class="normal">With all that said, the Micro Frontend model is still relatively new, and many best practices and even bits of terminology are still in flux. For that reason, we shall focus on a simpler variant of this approach and have the authentication service provide its own HTML for logging a user in and creating an account that can be included in an iframe within another page if desired.</p>
    <h2 id="_idParaDest-149" class="title">Getting the Slack token</h2>
    <p class="normal">Slack<a id="_idIndexMarker547"/> provides a typical three-legged OAuth2 implementation, using a simple set of HTTP <code class="Code-In-Text--PACKT-">GET</code> requests. Implementing the exchange is done by redirecting the user to Slack and exposing an endpoint the user's browser is redirected to once access has been granted.</p>
    <p class="normal">If we request the special identify scope, then all we get from Slack is confirmation of the user's identity and the unique Slack ID string. We can store all this information in the Quart session, use it as our login mechanism, and pass the e-mail and token values to <code class="Code-In-Text--PACKT-">DataService</code> for use with other components if we need to.</p>
    <p class="normal">As we did in <em class="chapterRef">Chapter 4</em>, <em class="italic">Designing Jeeves</em>, let us implement the function that generates the URL to send the user to, combined with the other information<a id="_idIndexMarker548"/> Slack needs, which is documented at <a href="https://api.slack.com/legacy/oauth">https://api.slack.com/legacy/oauth</a>:</p>
    <pre class="programlisting code"><code class="hljs-code">    @login.route("/login/slack")
    async def slack_login():
        query = {
            "client_id": current_app.config["JEEVES_CLIENT_ID"],
            "scope": "identify",
            "redirect_uri": current_app.config["SLACK_REDIRECT_URI"],
        }
        url = f"https://slack.com/oauth/authorize?{urlencode(query)}"
        return redirect(url)
</code></pre>
    <p class="normal">Here, we are running our Quart application<a id="_idIndexMarker549"/> behind nginx with a Let's Encrypt certificate, as we also set up in <em class="chapterRef">Chapter 4</em>, <em class="italic">Designing Jeeves</em>. This is why we are using a callback URL from our configuration rather than attempting to work it out dynamically, as that URL is tied to nginx. </p>
    <p class="normal">That function uses the <code class="Code-In-Text--PACKT-">client_id</code> from the Jeeves application generated in Slack and returns a redirection URL we can present to the user. The dashboard view can be changed accordingly to pass that URL to the template.</p>
    <pre class="programlisting code"><code class="hljs-code">    @login.route("/")
    async def index():
        return await render_template("index.html", user=session.get("user"))
</code></pre>
    <p class="normal">We also pass a <code class="Code-In-Text--PACKT-">user</code> variable if there are any stored in the session. The template can then use the Strava URL to display a login/logout link as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    {% if not user %}
    &lt;a href="{{url_for('login.slack_login')}}"&gt;Login via Slack&lt;/a&gt;
    {% else %}
    Hi {{user}}!
    &lt;a href="/logout"&gt;Logout&lt;/a&gt;
    {% endif %}
</code></pre>
    <p class="normal">When the user clicks on the <code class="Code-In-Text--PACKT-">login</code> link, they are redirected to Strava and back to our application on the endpoint, defined as <code class="Code-In-Text--PACKT-">SLACK_REDIRECT_URI</code>. The implementation of that view could be like this:</p>
    <pre class="programlisting code"><code class="hljs-code">    @login.route("/slack/callback")
    async def slack_callback():
        query = {
            "code": request.args.get("code"),
            "client_id": current_app.config["JEEVES_CLIENT_ID"],
            "client_secret": current_app.config["JEEVES_CLIENT_SECRET"],
            "redirect_uri": current_app.config["SLACK_REDIRECT_URI"],
        }
        url = "https://slack.com/api/oauth.access"
        response = requests.get(url, params=query)
        response_data = response.json()
        session["user"] = response_data["user_id"]
        return redirect(url_for("login.index"))
</code></pre>
    <p class="normal">Using the response we get<a id="_idIndexMarker550"/> from Slack's OAuth2 service, we put the temporary code received into a query to convert that into a real access token. Then we can store the token in the session or send it to the data service.</p>
    <p class="normal">We are not detailing how <code class="Code-In-Text--PACKT-">Dashboard</code> interacts with <code class="Code-In-Text--PACKT-">TokenDealer</code>, since we have already shown this in <em class="chapterRef">Chapter 7</em>, <em class="italic">Securing Your Services</em>. The process is similar—the <code class="Code-In-Text--PACKT-">Dashboard</code> app gets a token from <code class="Code-In-Text--PACKT-">TokenDealer</code> and uses it to access <code class="Code-In-Text--PACKT-">DataService</code>.</p>
    <p class="normal">The last part of authentication is in the ReactJS code, as we will see in the next section.</p>
    <h2 id="_idParaDest-150" class="title">JavaScript authentication</h2>
    <p class="normal">When the <code class="Code-In-Text--PACKT-">Dashboard</code> app<a id="_idIndexMarker551"/> performs the OAuth2 exchange with Slack, it stores user information in the session, which is a fine approach for the user authenticating on the dashboard. However, when the ReactJS UI calls the <code class="Code-In-Text--PACKT-">DataService</code> microservice to display the user runs, we need to provide an authentication header. The following are two ways to handle this problem:</p>
    <ul>
      <li class="bullet">Proxy all the calls to the microservices via the Dashboard web app using the existing session information.</li>
      <li class="bullet">Generate a JWT token for the end user, which can be stored and used against another microservice.</li>
    </ul>
    <p class="normal">The proxy solution seems simplest as it removes the need to generate one token per user for accessing <code class="Code-In-Text--PACKT-">DataService</code>, although that does mean that if we want to trace a transaction back to an individual user, we have to connect the <code class="Code-In-Text--PACKT-">DataService</code> event to the frontend's list of events.</p>
    <p class="normal">Proxying allows us to hide the <code class="Code-In-Text--PACKT-">DataService</code> from public view. Hiding everything behind the dashboard means we have more flexibility to change the internals while keeping the UI compatible. The problem then is that we are forcing all the traffic through the <code class="Code-In-Text--PACKT-">Dashboard</code> service even when it is not needed. Our exposed API and the <code class="Code-In-Text--PACKT-">Dashboard</code> appear, to the end user, to have different routes to the data, which may cause confusion. It also means that if there is an outage with the <code class="Code-In-Text--PACKT-">DataService</code>, then the <code class="Code-In-Text--PACKT-">Dashboard</code> is affected and may stop responding to any people trying to view the page. If the JavaScript contacts the <code class="Code-In-Text--PACKT-">DataService</code> directly, then the <code class="Code-In-Text--PACKT-">Dashboard</code> will continue operating, and notifications can be put up to let people know there is an ongoing problem.</p>
    <p class="normal">This leads us strongly towards the second solution, generating a token for the end user for use<a id="_idIndexMarker552"/> in the React frontend. If we are already dealing tokens to the other microservices, the web user interface is just one of the clients. However, this also means that the client has a second authentication loop, as it must first authenticate using OAuth2, and then fetch a JWT token for internal services.</p>
    <p class="normal">As we discussed in the last chapter, we can generate a JWT token once we have authenticated, and then use that to communicate with the other services under our control. The workflow is exactly the same—it simply gets called from JavaScript.</p>
    <h1 id="_idParaDest-151" class="title">Summary</h1>
    <p class="normal">In this chapter, we looked at the fundamentals of building a ReactJS UI dashboard served by a Quart application. ReactJS is an excellent way to build a modern interactive UI in the browser, as it introduces a new syntax called JSX which speeds up JS execution. We also looked at how to use a toolchain, based on <code class="Code-In-Text--PACKT-">npm</code>, and <code class="Code-In-Text--PACKT-">Babel</code>, to manage JS dependencies and transpile JSX files into pure JavaScript.</p>
    <p class="normal">The Dashboard application uses Slack's OAuth2 API to connect users and authenticate them with our own service. We made the design decision to separate the <code class="Code-In-Text--PACKT-">Dashboard</code> application from <code class="Code-In-Text--PACKT-">DataService</code>, so the token is sent to the <code class="Code-In-Text--PACKT-">DataService</code> microservice for storage. That token can then be used by the periodic workers as well as the Jeeves actions to perform tasks on behalf of the user.</p>
    <p class="normal">Lastly, the calls made to different services to build the dashboard are made independently of the dashboard, allowing us to focus on doing one thing well in each component. Our authorization service deals with all the token generation, and our dashboard can focus on being responsive to the viewer. </p>
    <p class="normal"><em class="italic">Figure 8.2</em> contains a diagram of the new architecture, which includes the <code class="Code-In-Text--PACKT-">Dashboard</code> app:</p>
    <figure class="mediaobject"><img src="img/B17108_08_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.2: The full Jeeves microservice architecture</p>
    <p class="normal">You can find the full code of the <code class="Code-In-Text--PACKT-">Dashboard</code> in the PythonMicroservices organization on GitHub at <a href="https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/">https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/</a>.</p>
    <p class="normal">With several different Quart apps that compose it, developing an application like Jeeves can be a challenge when you are a developer. In the next chapter, we will look at packaging and running the application to make maintenance and upgrading much easier.</p>
  </div>
</body></html>