- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Packaging and Running Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包和运行Python
- en: When the Python programming language was first released in the early 1990s,
    a Python application was run by pointing the Python scripts to the interpreter.
    Everything related to packaging, releasing, and distributing Python projects was
    done manually. There was no real standard back then, and each project had a long
    README on how to install it with all its dependencies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python编程语言在20世纪90年代初首次发布时，Python应用程序是通过将Python脚本指向解释器来运行的。与打包、发布和分发Python项目相关的所有事情都是手动完成的。当时没有真正的标准，每个项目都有一个长长的README，说明了如何使用所有依赖项来安装它。
- en: Bigger projects used system packaging tools to release their work—whether it
    was Debian packages, RPM packages for Red Hat Linux distributions, or MSI packages
    under Windows. Eventually, the Python modules from those projects all ended up
    in the `site-packages` directory of the Python installation, sometimes after a
    compilation phase, if they had a C extension.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 较大的项目使用系统打包工具发布他们的工作——无论是Debian包、为Red Hat Linux发行版提供的RPM包，还是Windows下的MSI包。最终，这些项目的Python模块都出现在Python安装的`site-packages`目录中，有时在编译阶段之后，如果它们有C扩展。
- en: The Python packaging ecosystem has evolved a lot since then. In 1998, `Distutils`
    was added to the standard library to provide essential support to create installable
    distributions for Python projects. Since then, a lot of new tools have emerged
    from the community to improve how a Python project can be packaged, released,
    and distributed. This chapter is going to explain how to use the latest Python
    packaging tools for your microservices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 自那时起，Python的打包生态系统已经发生了很大的变化。1998年，`Distutils`被添加到标准库中，为Python项目提供创建可安装分发的必要支持。从那时起，社区涌现出许多新工具，以改进Python项目打包、发布和分发的方式。本章将解释如何使用最新的Python打包工具为您的微服务。
- en: 'The other hot topic around packaging is how it fits in with your day-to-day
    work. When building microservices-based software, you need to deal with many moving
    parts. When you are working in a particular microservice, you can get away with
    using the TDD and mocking approach most of the time, which we discussed in *Chapter
    3*, *Coding, Testing, and Documentation: the Virtuous Cycle*.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 打包的另一个热门话题是如何与您日常的工作相结合。当构建基于微服务的软件时，您需要处理许多动态部分。当您在特定的微服务中工作时，您大多数时候可以使用我们在*第3章*中讨论的TDD和模拟方法，即*编码、测试和文档：良性循环*。
- en: 'However, if you want to do some realistic testing, and examine all the parts
    of the system, you need the whole stack running either locally or on a test cloud
    instance. Moreover, developing in such a context can be tedious if you need to
    reinstall new versions of your microservices all the time. This leads to one question
    in particular: *how can you correctly install the whole stack in your environment
    and develop in it?*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您想进行一些实际的测试，并检查系统的所有部分，您需要整个堆栈在本地或测试云实例上运行。此外，在这种背景下开发可能会很繁琐，如果您需要不断重新安装微服务的新版本。这导致了一个特别的问题：*您如何在环境中正确安装整个堆栈并在其中开发？*
- en: It also means you have to run all the microservices if you want to play with
    the app. In the case of Jeeves, having to open multiple different shells to run
    all the microservices is not something a developer would want to do every time
    they need to run the app.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着如果您想玩转应用程序，您必须运行所有微服务。在Jeeves的情况下，每次需要运行应用程序时都要打开多个不同的shell来运行所有微服务，这不是开发者每次都需要做的事情。
- en: In this chapter, we are going to look at how we can leverage the packaging tools
    to run all microservices from the same environment, and then how to run them all
    from a single **Command-Line Interface** (**CLI**) by using a dedicated process
    manager. First, however, we will look at how to package your projects, and which
    tools should be utilized.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何利用打包工具从同一环境中运行所有微服务，然后如何通过使用专门的进程管理器从单个**命令行界面**（**CLI**）运行它们。首先，然而，我们将探讨如何打包您的项目，以及应该使用哪些工具。
- en: The packaging toolchain
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包工具链
- en: Python has come a long way since the days of those early packaging methods.
    Numerous **Python Enhancement Proposals** (**PEPs**) were written to improve how
    to install, release, and distribute Python projects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 自从那些早期的打包方法以来，Python已经走了很长的路。许多**Python增强提案**（**PEPs**）被编写出来，以改进Python项目的安装、发布和分发方式。
- en: '`Distutils` had some flaws that made it a little tedious to release software.
    The biggest pain points were its lack of dependency management and the way it
    handled compilation and binary releases. For everything related to compiling,
    what worked well in the nineties started to get old-fashioned ten years later.
    No one in the core team made the library evolve due to lack of interest, and also
    because `Distutils` was good enough to compile Python and most projects. People
    who needed advanced toolchains used other tools, like `SCons` ([http://scons.org/](http://scons.org/)).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`Distutils` 存在一些缺陷，使得发布软件变得有些繁琐。最大的痛点是其缺乏依赖关系管理和处理编译和二进制发布的方式。对于与编译相关的一切，90
    年代有效的方法在十年后开始过时。核心团队没有人因为缺乏兴趣而没有使库发展，也因为 `Distutils` 足够编译 Python 和大多数项目。需要高级工具链的人使用了其他工具，如
    `SCons` ([http://scons.org/](http://scons.org/))。'
- en: In any case, improving the toolchain was not an easy task because of the existing
    legacy system based on `Distutils`. Starting a new packaging system from scratch
    was quite hard, since `Distutils` was part of the standard library, but introducing
    backward-compatible changes was also hard to do properly. The improvements were
    made in between. Projects like `Setuptools` and `virtualenv` were created outside the
    standard library, and some changes were made directly in Python.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，由于基于 `Distutils` 的现有遗留系统，改进工具链都不是一项容易的任务。从头开始构建一个新的打包系统相当困难，因为 `Distutils`
    是标准库的一部分，但引入向后兼容的更改也难以正确执行。改进是在其中进行的。像 `Setuptools` 和 `virtualenv` 这样的项目是在标准库之外创建的，并且一些更改是直接在
    Python 中进行的。
- en: As of the time of writing, you still find the scars from these changes, and
    it is still quite hard to know exactly how things should be done. For instance,
    the `pyvenv` command was added in early versions of Python 3 and then removed
    in Python 3.6, but Python still ships with its virtual environment module, although
    there are also tools such as `virtualenv` to help make life easier.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到写作的时候，你仍然能找到这些变化的痕迹，而且仍然很难确切知道应该如何操作。例如，`pyvenv` 命令在 Python 3 的早期版本中被添加，然后在
    Python 3.6 中被移除，尽管 Python 仍然附带其虚拟环境模块，尽管还有像 `virtualenv` 这样的工具来帮助使生活更轻松。
- en: The best bet is to use the tools that are developed and maintained outside the
    standard library, because their release cycle is shorter than Python's. In other
    words, a change in the standard library takes months to be released, whereas a
    change in a third-party project can be made available much faster. All third-party
    projects that are considered as being part of the de facto standard packaging
    toolchain are now all grouped under the **PyPA** ([https://www.pypa.io](https://www.pypa.io))
    umbrella project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的选择是使用在标准库之外开发和维护的工具，因为它们的发布周期比 Python 短。换句话说，标准库中的更改需要数月才能发布，而第三方项目中的更改可以更快地提供。现在，所有被认为是事实标准打包工具链一部分的第三方项目都被归类在
    **PyPA** ([https://www.pypa.io](https://www.pypa.io)) 旗下项目之下。
- en: Besides developing the tools, `PyPA` also works on improving the packaging standards
    through proposing PEPs for Python and developing its early specifications—refer
    to [https://www.pypa.io/en/latest/roadmap/](https://www.pypa.io/en/latest/roadmap/).
    There are often new tools and experiments in packaging and dependency management
    that let us learn new things whether or not they become popular. For this chapter,
    we will stick with the core, well-known tools.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了开发工具之外，`PyPA` 还致力于通过提出 Python 的 PEPs 和开发其早期规范来改进打包标准——请参阅 [https://www.pypa.io/en/latest/roadmap/](https://www.pypa.io/en/latest/roadmap/)。在打包和依赖关系管理方面，经常会有新的工具和实验，让我们无论它们是否流行都能学到新东西。对于本章，我们将坚持使用核心、众所周知的工具。
- en: Before we start to look at the tools that should be used, we need to go through
    a few definitions to avoid any confusion.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看应该使用的工具之前，我们需要通过几个定义来避免任何混淆。
- en: A few definitions
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几个定义
- en: 'When we talk about packaging Python projects, a few terms can be confusing,
    because their definitions have evolved over time, and also because they can mean
    slightly different things outside the Python world. We need to define a Python
    package, a Python project, a Python library, and a Python application. They are
    defined as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论打包 Python 项目时，一些术语可能会让人感到困惑，因为它们的定义随着时间的推移而演变，同时也因为它们在 Python 世界之外可能意味着略有不同的事情。我们需要定义
    Python 包、Python 项目、Python 库和 Python 应用程序。它们的定义如下：
- en: A **Python package** is a directory tree containing Python modules. You can
    import it, and it is part of the module namespace.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python 包** 是一个包含 Python 模块的目录树。你可以导入它，它是模块命名空间的一部分。'
- en: A **Python project** can contain several packages, modules, and other resources
    and is what you release. Each microservice you build with Flask is a Python project.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python 项目** 可以包含多个包、模块和其他资源，是你发布的内容。你用 Flask 构建的每个微服务都是一个 Python 项目。'
- en: A **Python application** is a Python project that can be directly used through
    a user interface. The user interface can be a command-line script or a web server.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python 应用程序** 是一个可以直接通过用户界面使用的 Python 项目。用户界面可以是命令行脚本或网络服务器。'
- en: Lastly, a **Python library** is a specific kind of Python project that provides
    features to be used in other Python projects and has no direct end-user interface.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，**Python 库** 是一种特定的 Python 项目，它为其他 Python 项目提供功能，但没有直接面向最终用户的应用程序界面。
- en: The distinction between an application and a library can be quite vague, since
    some libraries sometimes offer some command-line tools to use some of their features,
    even if the first use case is to provide Python packages for other projects. Moreover,
    sometimes, a project that was a library becomes an application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序和库之间的区别可能相当模糊，因为有些库有时会提供一些命令行工具来使用它们的一些功能，即使最初的使用案例是为其他项目提供 Python 包。此外，有时一个曾是库的项目变成了应用程序。
- en: To simplify the process, the best option is to make no distinction between applications
    and libraries. The only technical difference is that applications ship with more
    data files and console scripts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化流程，最佳选项是不要在应用程序和库之间做区分。唯一的区别是应用程序会附带更多的数据文件和控制台脚本。
- en: Now that we have defined the terminology around a Python package, project, application,
    and library, let's look at how projects are packaged.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了关于 Python 包、项目、应用程序和库的术语，让我们看看项目是如何打包的。
- en: Packaging
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包
- en: 'When you package your Python project, there are three standard files you need
    to have alongside your Python packages:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打包你的 Python 项目时，你需要有三个标准文件与你的 Python 包一起使用：
- en: '`pyproject.toml`: A configuration file for the project''s build system'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pyproject.toml`：项目构建系统的配置文件'
- en: '`setup.py` or `setup.cfg`: A special module that controls packaging and metadata
    about the project'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup.py` 或 `setup.cfg`：一个特殊的模块，用于控制打包和项目的元数据'
- en: '`requirements.txt`: A file listing dependencies'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requirements.txt`：一个列出依赖关系的文件'
- en: Let's look at each one of them in detail.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一详细看看。
- en: The setup.py file
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: setup.py 文件
- en: The `setup.py` file is what governs everything when you want to interact with
    a Python project. When the `setup()` function is executed, it generates a static
    metadata file that follows the `PEP 314` format. The metadata file holds all the
    metadata for the project, but you need to regenerate it via a `setup()` call to
    get it to the Python environment you are using.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要与 Python 项目交互时，`setup.py` 文件控制着一切。当 `setup()` 函数执行时，它会生成一个遵循 `PEP 314` 格式的静态元数据文件。元数据文件包含项目的所有元数据，但你需要通过
    `setup()` 调用来重新生成它，以便将其放入你正在使用的 Python 环境中。
- en: The reason why you cannot use a static version is that the author of a project
    might have platform-specific code in `setup.py`, which generates a different metadata
    file depending on the platform and Python versions. Relying on running a Python
    module to extract static information about a project has always been a problem.
    You need to make sure that the code in the module can run in the target Python
    interpreter. If you are going to make your microservices available to the community,
    you need to keep that in mind, as the installation happens in many different Python
    environments.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能使用静态版本的原因是，一个项目的作者可能在 `setup.py` 中包含特定平台的代码，这会根据平台和 Python 版本生成不同的元数据文件。依赖于运行
    Python 模块来提取关于项目的静态信息一直是一个问题。你需要确保模块中的代码可以在目标 Python 解释器中运行。如果你打算让你的微服务对社区可用，你需要记住这一点，因为安装会在许多不同的
    Python 环境中发生。
- en: A common mistake when creating the `setup.py` file is to import your package
    into it when you have third-party dependencies. If a tool like `pip` tries to
    read the metadata by running `setup.py`, it might raise an import error before
    it has a chance to list all the dependencies to install. The only dependency you
    can afford to import directly in your `setup.py` file is `Setuptools`, because
    you can assume that anyone trying to install your project is likely to have it
    in their environment.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`setup.py`文件时，一个常见的错误是在有第三方依赖项时将其导入。如果像`pip`这样的工具尝试通过运行`setup.py`来读取元数据，它可能会在有机会列出所有要安装的依赖项之前引发导入错误。你可以在`setup.py`文件中直接导入的唯一依赖项是`Setuptools`，因为你可以假设尝试安装你的项目的任何人很可能已经在他们的环境中有了它。
- en: Another important consideration is the metadata you want to include to describe
    your project. Your project can work with just a name, a version, a URL, and an
    author, but this is obviously not enough information to describe your project.
    Metadata fields are set through `setup()` arguments. Some of them match directly
    with the name of the metadata, while some do not.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的考虑因素是你想要包含以描述你的项目的元数据。你的项目只需要一个名称、一个版本、一个URL和一个作者就可以工作，但显然这些信息不足以描述你的项目。元数据字段通过`setup()`参数设置。其中一些直接与元数据名称匹配，而另一些则不匹配。
- en: 'The following is a useful set of arguments you could use for your microservices
    projects:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一组可用于你的微服务项目的有用参数：
- en: '`name`: The name of the package; should be short and lowercase'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 包的名称；应该是简短的小写'
- en: '`version`: The version of the project, as defined in `PEP 440`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`: 项目的版本，如`PEP 440`中定义'
- en: '`url`: A URL for the project; can be its repository or home page'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`: 项目的URL；可以是它的仓库或主页'
- en: '`description`: One sentence to describe the project'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`: 一句话来描述项目'
- en: '`long_description`: A reStructuredText or Markdown document'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long_description`: 一个reStructuredText或Markdown文档'
- en: '`author` and `author_email`: The name and email of the author—can be an organization'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`author`和`author_email`: 作者的姓名和电子邮件地址——可以是组织'
- en: '`license`: The license used for the project (MIT, Apache2, GPL, and so on)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`license`: 项目使用的许可证（MIT、Apache2、GPL等）'
- en: '`classifiers`: A list of classifiers picked from a fixed list, as defined in
    `PEP 301`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classifiers`: 从固定列表中选择的分类器列表，如`PEP 301`中定义'
- en: '`keywords`: Tags to describe your project—this is useful if you publish the
    project to the **Python Package Index** (**PyPI**)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keywords`: 描述你的项目的标签——如果你将项目发布到**Python包索引**（**PyPI**），这很有用'
- en: '`packages`: A list of packages that your project includes—`Setuptools` can
    populate that option automatically with the `find_packages()` method'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packages`: 包含在项目中的包列表——`Setuptools`可以使用`find_packages()`方法自动填充该选项'
- en: '`entry_points`: A list of `Setuptools` hooks, like console scripts (this is
    a `Setuptools` option)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry_points`: `Setuptools`钩子列表，如控制台脚本（这是一个`Setuptools`选项）'
- en: '`include_package_data`: A flag that simplifies the inclusion of non-Python
    files'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include_package_data`: 一个简化非Python文件包含的标志'
- en: '`zip_safe`: A flag that prevents `Setuptools` from installing the project as
    a ZIP file, which is a historical standard (executable eggs)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip_safe`: 一个标志，防止`Setuptools`将项目安装为ZIP文件，这是一个历史标准（可执行egg）'
- en: 'If you are missing any critical options, then `Setuptools` will provide information
    about the ones it needs when you try to use it. The following is an example of
    a `setup.py` file that includes these options:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你缺少任何关键选项，那么当你尝试使用`Setuptools`时，它将提供关于它需要的信息。以下是一个包含这些选项的`setup.py`文件的示例：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `long_description` option is usually pulled from a `README.rst` file, so
    you do not have to deal with including a large piece of reStructuredText string
    in your function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`long_description`选项通常从`README.rst`文件中提取，因此你不需要在函数中包含大段reStructuredText字符串。'
- en: The `Twine` project ([https://pypi.org/project/twine/](https://pypi.org/project/twine/))—which
    we will use later to upload packages to PyPI—has a check command to ensure the
    long description can be rendered properly. Adding this check to **Continuous Integration**
    (**CI**) as part of a standard test suite is a good idea, to ensure the documentation
    on PyPI is readable. The other benefit of separating the description is that it's
    automatically recognized, parsed, and displayed by most editors. For instance,
    GitHub uses it as your project landing page in your repository, while also offering
    an inline reStructuredText editor to change it directly from the browser. PyPI
    does the same to display the front page of the project.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Twine`项目([https://pypi.org/project/twine/](https://pypi.org/project/twine/))——我们稍后将其用于上传包到PyPI——有一个检查命令来确保长描述可以正确渲染。将此检查作为标准测试套件的一部分添加到**持续集成**(**CI**)是一个好主意，以确保PyPI上的文档可读。将描述分离出来的另一个好处是它会被大多数编辑器自动识别、解析和显示。例如，GitHub将其用作您在仓库中的项目着陆页，同时提供一个内联的reStructuredText编辑器，可以直接从浏览器中更改它。PyPI也这样做来显示项目的首页。'
- en: 'The `license` field is freeform, as long as people can recognize the license
    being used. [https://choosealicense.com/](https://choosealicense.com/) offers
    impartial advice about which open-source software license is most appropriate
    for you, if you plan to release the source code—and you should strongly consider
    it, as our progress through this book and the myriad of tools used have all been
    based on open-source projects, and adding more to the community helps everyone
    involved. In any case, you should add, alongside your `setup.py` file, a `LICENCE`
    file with the official text of that license. In open-source projects it is common
    practice now to also include a "Code Of Conduct," such as the `Contributor Covenant`:
    [https://www.contributor-covenant.org/](https://www.contributor-covenant.org/).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`license`字段是自由形式的，只要人们可以识别所使用的许可证即可。[https://choosealicense.com/](https://choosealicense.com/)提供了关于哪种开源软件许可证最适合您的公正建议，如果您计划发布源代码——您应该强烈考虑这一点，因为我们的这本书的进展和所使用的各种工具都是基于开源项目，为社区添加更多内容有助于所有相关人员。在任何情况下，您都应该在`setup.py`文件旁边添加一个包含该许可证官方文本的`LICENCE`文件。在开源项目中，现在通常还包括一个“行为准则”，例如`Contributor
    Covenant`：[https://www.contributor-covenant.org/](https://www.contributor-covenant.org/)。'
- en: This is because working with people from around the world involves many different
    cultures and expectations, and being open about the nature of the community is
    another aspect that helps everyone.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为与来自世界各地的人合作涉及许多不同的文化和期望，并且公开社区的性质是帮助每个人的另一个方面。
- en: The classifiers option is probably the most painful one to write. You need to
    use strings from [https://pypi.python.org/pypi?%3Aaction=list_classifiers](https://pypi.python.org/pypi?%3Aaction=list_classifiers)
    that classify your project. The three most common classifiers that developers
    use are the list of supported Python versions, the license (which duplicates and
    should match the license option), and the development status, which is a hint
    about the maturity of the project.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 分类器选项可能是编写过程中最痛苦的一个。你需要使用来自[https://pypi.python.org/pypi?%3Aaction=list_classifiers](https://pypi.python.org/pypi?%3Aaction=list_classifiers)的字符串来对您的项目进行分类。开发者最常用的三个分类器是支持的Python版本列表、许可证（它与许可证选项重复并应匹配），以及开发状态，这是关于项目成熟度的提示。
- en: 'The `Trove` classifier is machine-parsable metadata that can be used by tools
    interacting with `PyPI`. For example, the `zc.buildout` tool looks for packages
    with the `Framework :: Buildout :: Recipe` classifier. A list of valid classifiers
    is available at [https://pypi.org/classifiers/](https://pypi.org/classifiers/).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Trove`分类器是机器可解析的元数据，可以被与`PyPI`交互的工具使用。例如，`zc.buildout`工具寻找具有`Framework ::
    Buildout :: Recipe`分类器的包。有效的分类器列表可在[https://pypi.org/classifiers/](https://pypi.org/classifiers/)找到。'
- en: Keywords are a good way to make your project visible if you publish it to the
    Python Package Index. For instance, if you are creating a `Quart` microservice,
    you should use "quart" and "microservice" as keywords.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将项目发布到Python包索引，关键词是一个使您的项目可见的好方法。例如，如果您正在创建一个`Quart`微服务，您应该使用“quart”和“microservice”作为关键词。
- en: The `entry_points` section is an INI-like string that defines ways to interact
    with your Python module through callables—most commonly a console script. When
    you add functions in that section, a command-line script will be installed alongside
    the Python interpreter, and the function hooked to it via the entry point. This
    is a good way to create a CLI for your project. In the example, `mycli` should
    be directly reachable in the shell when the project is installed. Lastly, `install_requires`
    lists all the dependencies. It's a list of Python projects the project uses and
    can be used by projects like `pip` when the installation occurs. The tool will
    grab them if they are published in PyPI and install them. It is also possible
    to read the dependencies from the file we will be discussing next, `requirements.txt`,
    and to read the version from a separate text file—or JSON file—so that the version
    can be easily used in multiple places if it's needed in the release pipeline.
    Since the JSON module is part of the standard library, there is no extra dependency
    added by importing it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`entry_points`部分是一个类似于INI的字符串，它定义了通过可调用项与你的Python模块交互的方式——最常见的是控制台脚本。当你向该部分添加函数时，一个命令行脚本将与Python解释器一起安装，并通过入口点将其钩子连接。这是为你的项目创建CLI的好方法。在示例中，当项目安装时，`mycli`应该在shell中直接可达。最后，`install_requires`列出了所有依赖项。它是一个项目使用的Python项目列表，当发生安装时，`pip`等工具可以使用它。如果它们在PyPI上发布，工具将抓取它们并安装。还可能从我们将要讨论的下一个文件`requirements.txt`中读取依赖项，以及从单独的文本文件或JSON文件中读取版本，以便在需要时在多个地方轻松使用版本。由于JSON模块是标准库的一部分，因此导入它不会添加额外的依赖项。'
- en: Once this `setup.py` file is created, a good way to try it is by creating a
    local virtual environment.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了`setup.py`文件，尝试它的一个好方法是创建一个本地虚拟环境。
- en: 'Assuming you have `virtualenv` installed, and you run these commands in the
    directory containing the `setup.py` file, it will create a few directories, including
    a `bin` directory containing a local Python interpreter, and drop you into a local
    shell:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经安装了`virtualenv`，并且你在包含`setup.py`文件的目录中运行这些命令，它将创建几个目录，包括一个包含本地Python解释器的`bin`目录，并将你放入本地shell中：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are several helper tools to make managing your virtual environments easier,
    such as `virtualenvwrapper` ([https://virtualenvwrapper.readthedocs.io/en/latest/](https://virtualenvwrapper.readthedocs.io/en/latest/)),
    but we will keep to the core functionality with our examples.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个辅助工具可以使管理你的虚拟环境更容易，例如`virtualenvwrapper`([https://virtualenvwrapper.readthedocs.io/en/latest/](https://virtualenvwrapper.readthedocs.io/en/latest/))，但我们将通过我们的示例保持核心功能。
- en: From here, running the `pip install -e command` will install the project in
    editable mode. This command installs the project by reading its setup file, but
    unlike `install`, the installation occurs in-place. Installing in-place means
    that you will be able to work directly on the Python modules in the project, and
    they will be linked to the local Python installation via its `site-packages` directory.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，运行`pip install -e command`将以可编辑模式安装项目。此命令通过读取其设置文件来安装项目，但与`install`不同，安装是就地发生的。就地安装意味着你将能够直接在项目中的Python模块上工作，并且它们将通过其`site-packages`目录链接到本地Python安装。
- en: Using a regular `install` call would have created copies of the files in the
    local `site-packages` directory, and changing the source code would have had no
    impact on the installed version.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常规的`install`调用会在本地的`site-packages`目录中创建文件的副本，而更改源代码对已安装版本没有任何影响。
- en: 'The `pip` call also generates a `MyProject.egg-info` directory, which contains
    the metadata. pip generates version 1.1 of the metadata spec under the `PKG-INFO`
    name:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: pip调用还会生成一个`MyProject.egg-info`目录，其中包含元数据。pip在`PKG-INFO`名称下生成元数据规范的版本1.1：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This metadata file is what describes your project, and is used to register it
    to PyPI via other commands, as we will see later in the chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个元数据文件是用来描述你的项目的，并且用于通过其他命令将其注册到PyPI，正如我们在本章后面将要看到的。
- en: The pip call also pulls all the project dependencies by looking for them in
    PyPI on [https://pypi.python.org/pypi](https://pypi.python.org/pypi) and installs
    them in the local `site-packages`. Running this command is a good way to make
    sure everything works as expected.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: pip调用也会通过在PyPI上查找它们来拉取所有项目依赖项，并将它们安装在本地的`site-packages`中。运行此命令是确保一切按预期工作的好方法。
- en: The requirements.txt file
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`requirements.txt`文件'
- en: One standard that emerged from the pip community is to use a `requirements.txt`
    file, which lists all the project dependencies, but also proposes an extended
    syntax to install editable dependencies. Refer to [https://pip.pypa.io/en/stable/cli/pip_install/#requirements-file-format](https://pip.pypa.io/en/stable/cli/pip_install/#requirements-file-format).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从 pip 社区中产生的一个标准是使用 `requirements.txt` 文件，该文件列出了所有项目依赖项，同时也提出了一种扩展语法来安装可编辑的依赖项。请参阅
    [https://pip.pypa.io/en/stable/cli/pip_install/#requirements-file-format](https://pip.pypa.io/en/stable/cli/pip_install/#requirements-file-format)。
- en: 'The following is an example of such a file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个此类文件的示例：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using this file has been widely adopted by the community, because it makes it
    easier to document your dependencies. You can create as many requirements files
    as you want in a project, and have your users call the `pip install -r requirements.txt`
    command to install the packages described in them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它使得记录依赖项变得更加容易，因此使用此文件已被社区广泛采用。你可以在项目中创建任意数量的需求文件，并让用户调用 `pip install -r requirements.txt`
    命令来安装其中描述的包。
- en: For instance, you could have a `dev-requirements.txt` file, which contains extra
    tools for development, and a `prod-requirements.txt`, which has production-specific
    dependencies. The format allows inheritance to help you manage requirements files'
    collections.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以有一个名为 `dev-requirements.txt` 的文件，其中包含开发所需的额外工具，以及一个名为 `prod-requirements.txt`
    的文件，其中包含特定于生产的依赖项。这种格式允许继承，帮助你管理需求文件集合。
- en: Using the `requirements` files duplicates some of the information contained
    in the `setup.py` file's `install_requires` section. As noted earlier, we could
    read in the `requirements.txt` file and include the data in `setup.py`. Some developers
    deliberately keep these sources separate to distinguish between an application
    and a library, allowing a library more flexibility in its dependencies in order
    to co-operate with other installed libraries. This does mean keeping two sources
    of information up to date, which is often a source of confusion.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `requirements` 文件会重复 `setup.py` 文件 `install_requires` 部分中的一些信息。如前所述，我们可以读取
    `requirements.txt` 文件并将数据包含在 `setup.py` 中。一些开发者故意将这些来源分开，以区分应用程序和库，使库在依赖关系上具有更大的灵活性，以便与其他已安装的库协作。这确实意味着需要保持两个信息源更新，这通常是一个混淆的来源。
- en: As we said earlier in the chapter, we do not want to make our life complicated
    by having two different ways to describe Python project dependencies, since the
    distinction between an application and a library can be quite vague. To avoid
    duplicating the information in both places, there are some tools in the community
    that offer some syncing automation between `setup.py` and requirements files.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章前面所述，我们不希望通过有两种不同的方式来描述 Python 项目依赖项而使我们的生活复杂化，因为应用程序和库之间的区别可能相当模糊。为了避免在两个地方重复信息，社区中的一些工具提供了一些在
    `setup.py` 和需求文件之间的同步自动化功能。
- en: 'The `pip-tools` ([https://github.com/jazzband/pip-tools](https://github.com/jazzband/pip-tools))
    tool is one of these utilities, and it generates a `requirements.txt` file (or
    any other filename) via a `pip-compile` CLI, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip-tools` ([https://github.com/jazzband/pip-tools](https://github.com/jazzband/pip-tools))
    工具是这些实用工具之一，它通过 `pip-compile` CLI 生成 `requirements.txt` 文件（或任何其他文件名），如下所示：'
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With no other arguments, `pip-compile` will examine `setup.py`. It's also possible
    to pass it an unpinned version file, such as `requirements.in` as a list of packages
    to use instead.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有其他参数的情况下，`pip-compile` 将检查 `setup.py` 文件。你也可以传递一个未固定的版本文件，例如 `requirements.in`，作为要使用的包列表。
- en: Notice that all the dependencies are pinned—the version we want is in the file.
    This is always a good idea in a production environment, as we want our application
    to be reproducible. If we do not specify a version to install, then we will get
    whatever is the latest, and that may break our application. By specifying the
    version, we know that all the tests we have run will still be valid no matter
    how far in the future we deploy that version of our app.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有依赖项都已固定——我们想要的版本在文件中。在生产环境中，这始终是一个好主意，因为我们希望我们的应用程序是可重复的。如果我们没有指定要安装的版本，那么我们将得到最新的版本，这可能会破坏我们的应用程序。通过指定版本，我们知道我们运行的所有测试都将仍然有效，无论我们将来何时部署该版本的程序。
- en: 'It''s also a good idea to add the hash of the dependency to the `requirements.txt`
    file, as this avoids any issue with someone uploading a package without updating
    the version number, or a malicious actor replacing an existing version of a package.
    These hashes will be compared to the downloaded files on installation, and are
    only used if they match:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将依赖项的哈希值添加到`requirements.txt`文件中也是一个好主意，因为这可以避免有人上传未更新版本号的包，或者恶意行为者替换现有版本的包。这些哈希值将在安装时与下载的文件进行比较，并且只有在匹配时才会使用：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you don''t use `pip-tools`, pip has a built-in command called `freeze`,
    which you can use to generate a list of all the current versions that are installed
    in your Python virtual environment. Using `pip freeze` without a virtual environment
    is likely to result in a lot of packages that have been used for other projects,
    rather than just your own work:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用`pip-tools`，pip有一个内置的命令叫做`freeze`，你可以使用它来生成一个列表，列出所有当前安装在你Python虚拟环境中的版本。在没有虚拟环境的情况下使用`pip
    freeze`可能会产生很多用于其他项目的包，而不仅仅是你的工作：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The only problem when you pin your dependencies is when another project has
    the same dependencies, but is pinned with other versions. pip will complain and
    fail to meet both the requirements sets, and you will not be able to install everything.
    If you are producing a library, and you expect other people to use and add to
    their own list of dependencies, it is a good idea to specify a range of versions
    that you support, so that pip can try to sort out any dependency conflicts. For
    example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你固定依赖项时，唯一的问题是当另一个项目有相同的依赖项，但使用其他版本固定时。pip会抱怨并无法满足两个需求集，你将无法安装所有内容。如果你正在制作库，并期望其他人使用并添加到他们自己的依赖项列表中，指定你支持的版本范围是一个好主意，这样pip就可以尝试解决任何依赖项冲突。例如：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It's also common practice to leave the dependencies unpinned in the `setup.py`
    file and pin the `requirements.txt` file. That way, pip can install the latest
    version for each package, and when you deploy, specifically in stage or production,
    you can refresh the versions by running the `pip install -r requirements.txt`
    command. pip will then upgrade/downgrade all the dependencies to match the versions,
    and if you need to, you can tweak them in the requirements file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup.py`文件中不固定依赖项，并在`requirements.txt`文件中固定依赖项也是一种常见的做法。这样，pip可以为每个包安装最新版本，当你在特定阶段或生产环境中部署时，可以通过运行`pip
    install -r requirements.txt`命令来刷新版本。pip将升级/降级所有依赖项以匹配版本，如果你需要的话，你可以在需求文件中调整它们。
- en: To summarize, defining dependencies should be done in each project's `setup.py`
    file, and requirements files can be provided with pinned dependencies if you have
    a reproducible process to generate them from the `setup.py` file to avoid duplication.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，定义依赖项应该在每个项目的`setup.py`文件中完成，如果你有一个从`setup.py`文件生成它们的可重复过程，可以提供带有固定依赖项的需求文件，以避免重复。
- en: The next useful file your projects could have is the `MANIFEST.in` file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目可能还需要的一个有用文件是`MANIFEST.in`文件。
- en: The MANIFEST.in file
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`MANIFEST.in`文件'
- en: When creating a source or binary release, `Setuptools` will include all the
    package modules and data files, the `setup.py` file, and a few other files automatically
    in the package archive. Files like `pip requirements` will not be included. To
    add them to your distribution, you need to add a `MANIFEST.in` file, which contains
    the list of files to include.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建源或二进制发布版本时，`Setuptools`会自动将所有包模块和数据文件、`setup.py`文件以及一些其他文件包含在包归档中。像`pip requirements`这样的文件将不会被包含。要添加它们到你的分发中，你需要添加一个`MANIFEST.in`文件，其中包含要包含的文件列表。
- en: 'The file follows a simple glob-like syntax, described at the following, where
    you refer to a file or a directory pattern and say whether you want to include
    or prune the matches: [https://docs.python.org/3/distutils/commandref.html#creating-a-source-distribution-the-sdist-command](https://docs.python.org/3/distutils/commandref.html#creating-a-source-distribution-the-sdist-command).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件遵循一个类似于glob的简单语法，如下所述，其中你引用一个文件或目录模式，并说明你是否想要包含或删除匹配项：[https://docs.python.org/3/distutils/commandref.html#creating-a-source-distribution-the-sdist-command](https://docs.python.org/3/distutils/commandref.html#creating-a-source-distribution-the-sdist-command)。
- en: 'Here''s an example from Jeeves:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个来自Jeeves的例子：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `docs/directory` containing the Sphinx doc will be integrated in the source
    distribution, but any artifact generated locally in `docs/build/` when the doc
    is built will be pruned.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 包含Sphinx文档的`docs/directory`将被集成到源分发中，但文档构建时在`docs/build/`本地生成的任何工件将被删除。
- en: Once you have the `MANIFEST.in` file in place, all the files should be added
    in your distribution when your project is released.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了 `MANIFEST.in` 文件，当你的项目发布时，所有文件都应该添加到你的分布中。
- en: 'A typical microservice project, as described in this book, will have the following
    list of files:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书所述的典型微服务项目，将包含以下文件列表：
- en: '`setup.py`: The setup file'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup.py`: 设置文件'
- en: '`README.rst`: The content of the `long_description` option'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.rst`: `long_description` 选项的内容'
- en: '`MANIFEST.in`: The MANIFEST template if it is needed'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MANIFEST.in`: 如果需要，这是 MANIFEST 模板'
- en: A code of conduct, if the code is an open-source project
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果代码是开源项目，则有一份行为准则
- en: '`requirements.txt`: pip requirement files generated from `install_requires`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requirements.txt`: 从 `install_requires` 生成的 pip 需求文件'
- en: '`docs/`: The Sphinx documentation'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docs/`: Sphinx 文档'
- en: A directory containing the microservice code, which will typically be named
    after the microservice, or `src/`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含微服务代码的目录，通常以微服务命名，或 `src/`
- en: From there, releasing your project consists of creating a source distribution,
    which is basically an archive of this structure. If you have some C extensions,
    you can also create a binary distribution.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里开始，发布你的项目包括创建一个源分布，这基本上是这个结构的归档。如果你有一些 C 扩展，你也可以创建一个二进制分布。
- en: Before we learn how to create those releases, let's look at how to pick version
    numbers for your microservices.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习如何创建这些发布之前，让我们看看如何为你的微服务选择版本号。
- en: Versioning
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制
- en: Python packaging tools do not enforce a specific versioning pattern, although
    the version field should be one that can be converted using the packaging module
    into a meaningful version. Let's discuss what counts as a meaningful version number.
    To understand a versioning scheme, an installer needs to know how to sort and
    compare versions. The installer needs to be able to parse the string and know
    whether a version is older than another one.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Python 打包工具不强制执行特定的版本控制模式，尽管版本字段应该是可以使用打包模块转换为有意义的版本的版本。让我们讨论一下什么是有意义的版本号。为了理解版本控制方案，安装程序需要知道如何排序和比较版本。安装程序需要能够解析字符串并知道一个版本是否比另一个版本旧。
- en: Some software uses a scheme based on the date of release, like `20210101` if
    your software was released on January 1, 2021\. For some use cases this works
    perfectly well. If you are practicing **Continuous Deployment** (**CD**), where
    every change that reaches the release branch is pushed to production, then there
    may be such a large number of changes that fixed version numbers are hard to work
    with. In that sort of situation, a date-based version, or a version from the version
    control hash, may work well.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一些软件使用基于发布日期的方案，例如如果你的软件在 2021 年 1 月 1 日发布，则使用 `20210101`。对于某些用例，这工作得非常好。如果你正在实践**持续部署**（**CD**），其中每个达到发布分支的变化都会推送到生产环境，那么可能会有如此多的变化，以至于固定的版本号难以处理。在这种情况下，基于日期的版本或版本控制哈希的版本可能工作得很好。
- en: Date- or commit-based versioning won't work very well if you do branched releases.
    For instance, if your software has a large change in behavior and you need to
    support the older version for a while as people transition, then having versions
    1 and 2 makes things clear, but using dates in this situation will make some of
    your "version 1" releases appear as if they were more recent than some of the
    "version 2" releases, and confuse anyone trying to determine what they should
    install. Some software combines incremental versions and dates for that reason,
    but it became obvious that using dates was not the best way to handle branches.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进行了分支发布，基于日期或提交的版本控制可能不会很好用。例如，如果你的软件有大的行为变化，你需要支持旧版本一段时间，以便人们过渡，那么拥有版本 1
    和 2 可以使事情变得清晰，但在这个情况下使用日期将使一些“版本 1”的发布看起来比一些“版本 2”的发布更近，这会让人困惑，不知道应该安装什么。一些软件因为这种原因结合了增量版本和日期，但很明显，使用日期并不是处理分支的最佳方式。
- en: There is also the problem of releasing beta, alpha, release candidates, and
    dev versions. Developers want to have the ability to mark releases as being pre-releases.
    For instance, when Python is about to ship a new version, it will ship release
    candidates using an `rcX` marker so that the community can try it before the final
    release is shipped, for example, `3.10.0rc1` or `3.10.0rc2`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在发布 beta、alpha、候选发布和开发版本的问题。开发者希望有标记发布为预发布的能力。例如，当 Python 即将发布新版本时，它将使用 `rcX`
    标记发布候选版本，以便社区可以在最终版本发布之前尝试它，例如，`3.10.0rc1` 或 `3.10.0rc2`。
- en: For a microservice that you are not releasing to the community, using such markers
    is often unnecessary—but when you start to have people from outside your organization
    using your software, it may become useful.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你不会向社区发布的微服务，使用这样的标记通常是不必要的——但是当你开始有来自你组织外部的人使用你的软件时，它可能变得有用。
- en: Release candidates can be useful if you are about to ship a backward-incompatible
    version of a project. It's always a good idea to have your users try it out before
    it's published. For the usual release though, using candidate releases is probably
    overkill, as publishing a new release when a problem is found is cheap.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你即将发布一个向后不兼容的项目版本，发布候选版本可能很有用。在发布之前让用户试用总是一个好主意。然而，对于常规发布来说，使用候选版本可能有些过度，因为当发现问题时发布新版本的成本很低。
- en: pip does a fairly good job of figuring out most patterns, ultimately falling
    back to some alphanumeric sorting, but the world would be a better place if all
    projects were using the same versioning scheme. `PEP 386`, then `440`, was written
    to try to come up with a versioning scheme for the Python community. It's derived
    from the standard `MAJOR.MINOR[.PATCH]` scheme, which is widely adopted among
    developers, with some specific rules for pre and post versions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: pip在确定大多数模式方面做得相当不错，最终会退回到一些字母数字排序，但如果所有项目都使用相同的版本控制方案，世界会变得更好。`PEP 386`，然后是`440`，是为了尝试为Python社区制定一个版本控制方案而编写的。它源自标准的`MAJOR.MINOR[.PATCH]`方案，该方案在开发者中得到了广泛采用，并针对预发布和后发布版本有一些特定的规则。
- en: The **Semantic Versioning** (**SemVer**) ([http://semver.org/](http://semver.org/))
    scheme is another standard that emerged in the community, which is used in many
    places outside Python. If you use SemVer, you will be compatible with `PEP 440`
    and the pip installer as long as you don't use pre-release markers. For instance,
    `3.6.0rc2` translates to `3.6.0-rc2` in SemVer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**语义版本控制**（**SemVer**）([http://semver.org/](http://semver.org/))方案是社区中出现的另一个标准，它在Python之外的地方被广泛使用。如果你使用SemVer，只要你不使用预发布标记，你将与`PEP
    440`和pip安装程序兼容。例如，`3.6.0rc2`在SemVer中翻译为`3.6.0-rc2`。'
- en: 'Unlike `PEP 440`, SemVer asks that you always provide the three version numbers.
    For instance, `1.0` should be `1.0.0`. The `python-semver` library will help a
    great deal with comparing different versions: [https://github.com/python-semver/python-semver](https://github.com/python-semver/python-semver):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '与`PEP 440`不同，SemVer要求你始终提供三个版本号。例如，`1.0`应该是`1.0.0`。`python-semver`库在比较不同版本时非常有帮助：[https://github.com/python-semver/python-semver](https://github.com/python-semver/python-semver):'
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For your microservice project, or any Python project for that matter, you should
    start with the `0.1.0` version to make it clear that it is not yet stable and
    may change drastically during early development, and that backward compatibility
    is not guaranteed. From there, you can increment the `MINOR` number at will until
    you feel the software is mature enough.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的微服务项目，或者任何Python项目，你应该从`0.1.0`版本开始，以清楚地表明它还不稳定，在早期开发期间可能会发生重大变化，并且不保证向后兼容性。从那里开始，你可以随意增加`MINOR`号，直到你觉得软件足够成熟。
- en: 'Once maturity has been reached, a common pattern is to release `1.0.0`, and
    then start to follow these rules:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦达到成熟阶段，一个常见的模式是发布`1.0.0`版本，然后开始遵循以下规则：
- en: '`MAJOR` is incremented when you introduce a backward-incompatible change for
    the existing API.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你引入对现有API的向后不兼容更改时，`MAJOR`版本号会增加。
- en: '`MINOR` is incremented when you add new features that do not break the existing
    API.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你添加不破坏现有API的新功能时，`MINOR`版本号会增加。
- en: '`PATCH` is incremented just for bug fixes.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在修复bug时，`PATCH`版本号才会增加。
- en: Being strict about this scheme with the `0.x.x` series when the software is
    in its early phase does not make much sense, because you will make a lot of backward-incompatible
    changes, and your `MAJOR` version would reach a high number in no time.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件处于早期阶段时，对`0.x.x`系列严格遵循此方案并没有太多意义，因为你将进行大量的向后不兼容的更改，并且你的`MAJOR`版本号会迅速达到一个很高的数字。
- en: The `1.0.0` release is often emotionally charged for developers. They want it
    to be the first stable release they will give to the world—that's why it's common
    to use the `0.x.x` versions and bump to `1.0.0` when the software is deemed stable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，`1.0.0`版本的发布常常充满情感色彩。他们希望这是第一个稳定版本，将向世界展示——这就是为什么在软件被认为稳定时，通常使用`0.x.x`版本并升级到`1.0.0`的原因。
- en: For a library, what we call the API is all the public and documented functions
    and classes one may import and use. For a microservice, there's a distinction
    between the code API and the HTTP API. You may completely change the whole implementation
    in a microservice project and still implement the exact same HTTP API. You need
    to treat those two versions distinctly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个库，我们所说的 API 是所有可能导入和使用的公共和文档化的函数和类。对于一个微服务，代码 API 和 HTTP API 之间有一个区别。你可以在微服务项目中完全更改整个实现，同时仍然实现完全相同的
    HTTP API。你需要区分这两个版本。
- en: It's important to remember that version numbers are not decimals, or really
    any form of counting number, and so while it may look like the next version after
    `3.9` should be `4.0`, it does not have to be—`3.10` and onward are perfectly
    acceptable. The numbers are simply a way to order the values and tell which is
    lower or greater than another.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，版本号不是小数，或者实际上任何形式的计数数字，所以虽然看起来 `3.9` 之后的下一个版本应该是 `4.0`，但这并不一定——`3.10`
    及以后的版本都是完全可以接受的。数字只是用来排序值并告诉哪个比另一个低或高。
- en: Now that we know how to deal with version numbers, let's do some releasing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何处理版本号，让我们来进行一些发布。
- en: Releasing
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布
- en: To release your project, we must build a package that can be either uploaded
    to a package repository such as PyPI or installed directly wherever it is needed.
    Python has a build utility that makes this process straightforward.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布你的项目，我们必须构建一个包，这个包可以被上传到包仓库，如 PyPI，或者直接在任何需要的地方安装。Python 有一个构建工具，使得这个过程变得简单直接。
- en: 'In the following example, we install the build utility, and then run it in
    the example project we used earlier in this chapter. The output can be quite long,
    so only some of it is included below:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们安装了构建工具，然后在本章前面使用的示例项目中运行它。输出可能相当长，所以下面只包含了一部分：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `build` command reads the information from `setup.py` and `MANIFEST.in`,
    collects all the files, and puts them in an archive. The result is created in
    the `dist` directory:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`build` 命令从 `setup.py` 和 `MANIFEST.in` 中读取信息，收集所有文件，并将它们放入一个存档中。结果创建在 `dist`
    目录下：'
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice that the name of the archive is composed of the name of the project
    and its version. The archive is in the `Wheel` format, defined in `PEP 427`, which
    is currently the best format for distributing Python packages, although there
    have been different methods in the past, which you may encounter in existing projects.
    This archive can be used directly with pip to install the project as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，存档的名称由项目的名称和版本组成。存档以 `Wheel` 格式存在，该格式在 `PEP 427` 中定义，目前是分发 Python 包的最佳格式，尽管过去有过不同的方法，你可能在现有的项目中遇到。这个存档可以直接使用
    pip 来安装项目，如下所示：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once you have your archive ready, it's time to distribute it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的存档准备就绪，就是时候分发它了。
- en: Distributing
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发
- en: 'If you are developing in an open-source project, it is good practice to publish
    your project to PyPI, so that it can be used by a wide range of people. This can
    be found at: [https://pypi.python.org/pypi](https://pypi.python.org/pypi). If
    the project is private, or internal to a company, then you may have a package
    repository for your work that operates in a similar way to PyPI that is only visible
    to your own organization''s infrastructure.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个开源项目中开发，将你的项目发布到 PyPI 是一种良好的实践，这样它就可以被广泛的人群使用。可以在以下地址找到：[https://pypi.python.org/pypi](https://pypi.python.org/pypi)。如果项目是私有的，或者在公司内部，那么你可能有一个类似
    PyPI 的包仓库来管理你的工作，这个仓库只对你们自己的组织基础设施可见。
- en: Like most modern language ecosystems, PYPI can be browsed by installers that
    are looking for releases to download. When you call the `pip install <project>`
    command, pip will browse PyPI to see whether that project exists, and whether
    there are some suitable releases for your platform.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数现代语言生态系统一样，PyPI 可以被寻找要下载的发布的安装程序浏览。当你调用 `pip install <project>` 命令时，pip
    将浏览 PyPI 来查看该项目是否存在，以及是否有适合你平台的合适版本。
- en: The public name is the name you use in your `setup.py` file, and you need to
    register it at PyPI to be able to publish releases. The index uses the first-come,
    first-serve principle, so if the name you have picked is already taken, then you
    will have to choose another one.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 公共名称是在你的 `setup.py` 文件中使用的名称，你需要将其在 PyPI 上注册，以便能够发布版本。索引遵循先到先得的原则，所以如果你选择的名称已经被占用，那么你将不得不选择另一个名称。
- en: When creating microservices for an application or organization, you can use
    a common prefix for all your projects' names. It is also possible to set up your
    own private version of PyPI for projects that should not be released to the wider
    world. If at all possible, though, it helps everyone to contribute to the open-source
    community.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当为应用程序或组织创建微服务时，你可以为所有项目的名称使用一个共同的名称前缀。对于不应该发布给更广泛世界的项目，也可以设置你自己的 PyPI 私有版本。然而，尽可能地为开源社区做出贡献是有帮助的。
- en: At the package level, a prefix can also sometimes be useful to avoid conflicts.
    Python has a namespace package feature, which allows you to create a top-level
    package name (like `jeeves`), and then have packages in separate Python projects,
    which will end up being installed under the top-level `jeeves` package.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在包级别，前缀有时也可以用来避免冲突。Python 有一个命名空间包特性，允许你创建一个顶级包名（如 `jeeves`），然后在单独的 Python 项目中拥有包，最终这些包将安装到顶级的
    `jeeves` 包下。
- en: The effect is that every package gets a common `jeeves` namespace when you import
    them, which is quite an elegant way to group your code under the same banner.
    The feature is available through the `pkgutil` module from the standard library.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，当你导入它们时，每个包都会得到一个共同的 `jeeves` 命名空间，这是一种将代码分组在同一个旗帜下的相当优雅的方式。这个特性通过标准库中的
    `pkgutil` 模块提供。
- en: 'To do this, you just need to create the same top-level directory in every project,
    with the `__init__.py` file, containing and prefixing all absolute imports with
    the top-level name:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你只需要在每个项目中创建相同的顶级目录，包含 `__init__.py` 文件，并将所有绝对导入前缀化以包含顶级名称：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For example, in Jeeves, if we decide to release everything under the same namespace,
    each project can have the same top-level package name. In the `tokendealer`, it
    could be as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Jeeves 中，如果我们决定在同一个命名空间下发布所有内容，每个项目都可以有相同的顶级包名。在 `tokendealer` 中，它可以如下所示：
- en: '`jeeves`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jeeves`'
- en: '`__init__.py`: Contains the `extend_path` call'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__.py`: 包含 `extend_path` 调用'
- en: '`tokendealer/`'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tokendealer/`'
- en: '... the actual code...'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '... 实际代码...'
- en: 'And then in the `dataservice` directory, like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `dataservice` 目录中，如下所示：
- en: '`jeeves`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jeeves`'
- en: '__init__.py: Contains the `extend_path` call'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '__init__.py: 包含 `extend_path` 调用'
- en: '`dataservice/`'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dataservice/`'
- en: '... the actual code...'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '... 实际代码...'
- en: 'Both will ship a `jeeves` top-level namespace, and when pip installs them,
    the `tokendealer` and `dataservice` packages will both end up installed and available
    underneath the name `jeeves`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都将携带 `jeeves` 顶级命名空间，当 pip 安装它们时，`tokendealer` 和 `dataservice` 包最终都将安装并可在
    `jeeves` 名称下使用：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This feature is not that useful in production, where each microservice is deployed
    in a separate installation, but it does not hurt, and it can be useful if you
    start to create a lot of libraries that are used across projects. For now, we
    will make the assumption that each project is independent, and each name is available
    at PyPI.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性在生产环境中并不那么有用，因为每个微服务都在单独的安装中部署，但这并不妨碍，如果你开始创建大量跨项目使用的库，它可能是有用的。目前，我们将假设每个项目都是独立的，每个名称在
    PyPI 上都是可用的。
- en: To publish the releases at PyPI, you first need to register a new user using
    the form at [https://pypi.org/account/register/](https://pypi.org/account/register/),
    which will look like that shown in *Figure 9.1*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 PyPI 上发布版本，你首先需要使用 [https://pypi.org/account/register/](https://pypi.org/account/register/)
    上的表单注册一个新用户，它看起来就像 *图 9.1* 中所示的那样。
- en: '![image1.png](img/B17108_09_01.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![image1.png](img/B17108_09_01.png)'
- en: 'Figure 9.1: Creating an account on PyPI'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：在 PyPI 上创建账户
- en: It's also worth registering at the test version of PyPI, as this will let you
    experiment with uploads and try out all the commands without publishing anything
    to the real index. Use [https://test.pypi.org/account/register/](https://test.pypi.org/account/register/)
    for an account on the test service.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在 PyPI 的测试版本上注册也是值得的，因为这将允许你尝试上传并测试所有命令，而无需将任何内容发布到真实索引。请使用 [https://test.pypi.org/account/register/](https://test.pypi.org/account/register/)
    在测试服务上创建账户。
- en: 'Python `Distutils` has a `register` and `upload` command to register a new
    project at PyPI, but it is better to use `Twine` ([https://github.com/pypa/twine](https://github.com/pypa/twine)),
    which comes with a better user interface. Once you''ve installed `Twine` (using
    the `pip install twine` command), the next step is to register your package using
    the following command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Python `Distutils` 有一个 `register` 和 `upload` 命令，可以在 PyPI 上注册新项目，但最好使用 `Twine`
    ([https://github.com/pypa/twine](https://github.com/pypa/twine))，它提供了一个更好的用户界面。一旦你安装了
    `Twine`（使用 `pip install twine` 命令），下一步就是使用以下命令注册你的包：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once done, you can go ahead and upload the releases. Let''s upload to the test
    version of PyPI first, to make sure everything works. After the upload, we give
    pip some extra arguments so that it knows to use the test version of the PyPI
    version, and then to fall back to the real package index to sort out the other
    dependencies:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你可以继续上传发布版本。首先让我们上传到 PyPI 的测试版本，以确保一切正常工作。上传后，我们给 pip 一些额外的参数，让它知道要使用 PyPI
    的测试版本，然后回退到真正的包索引以解决其他依赖项：
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once we know everything is working, we can upload to the real package index:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道一切正常工作，我们就可以上传到真正的包索引：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: From there, your package should appear in the index, with an HTML home page
    at `https://pypi.python.org/pypi/<project>`. The `pip install <project>` command
    should work!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，你的包应该出现在索引中，在 `https://pypi.python.org/pypi/<project>` 有一个 HTML 主页。`pip
    install <project>` 命令应该可以工作！
- en: Now that we know how to package each microservice, let us see how to run them
    all in the same box for development purposes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何打包每个微服务，让我们看看如何在开发目的下在同一台机器上运行它们。
- en: Running all microservices
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行所有微服务
- en: So far, we have run our `Quart` applications using the built-in Quart wrapper,
    or using the `run()` function. This works well for development, as the app can
    detect changes to its source code and reload itself, saving time when making changes.
    However, there are limitations to this, not least of which is that this is running
    the server in a development mode, with extra diagnostics turned on that slow down
    the server's operation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用内置的 Quart 包装器或使用 `run()` 函数来运行我们的 `Quart` 应用程序。这对于开发来说效果很好，因为应用程序可以检测其源代码的变化并自动重新加载，从而在修改时节省时间。然而，这种方法也有局限性，其中最明显的是，它是以开发模式运行服务器，开启了额外的诊断功能，这会减慢服务器的运行速度。
- en: 'Instead, we should run our applications using `Hypercorn` ([https://pgjones.gitlab.io/hypercorn/](https://pgjones.gitlab.io/hypercorn/)),
    an ASGI web server that allows `Quart` to run to its full potential, supporting
    `HTTP/2`, `HTTP/3`, as well as `WebSocket`. It''s already installed alongside
    Quart and is very straightforward to use. For our dataservice application, we
    would run:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们应该使用 `Hypercorn` ([https://pgjones.gitlab.io/hypercorn/](https://pgjones.gitlab.io/hypercorn/))
    运行我们的应用程序，这是一个允许 `Quart` 充分运行的 ASGI Web 服务器，支持 `HTTP/2`、`HTTP/3` 以及 `WebSocket`。它已经与
    Quart 一起安装，并且使用起来非常简单。对于我们的数据服务应用程序，我们将运行：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Hypercorn is the latest in a mine of WSGI and ASGI servers that aim to serve
    web applications, and if you are searching the Flask documentation when looking
    into extensions, you may come across mention of `Gunicorn` (`https://gunicorn.org/`),
    as it is a common equivalent to Hypercorn for synchronous applications, using
    a worker pool model to provide concurrency, an option we discussed in *Chapter
    1*, *Understanding Microservices*. For `Quart`, though, we will stick with `Hypercorn`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Hypercorn 是一系列旨在服务于 Web 应用的 WSGI 和 ASGI 服务器中的最新成员，如果你在查找扩展时查看 Flask 文档，可能会遇到对
    `Gunicorn` 的提及（`https://gunicorn.org/`），因为它是 Hypercorn 的一个常见等效同步应用程序，使用工作池模型提供并发性，这是我们曾在
    *第一章*，*理解微服务* 中讨论过的选项。然而，对于 `Quart` 来说，我们将坚持使用 `Hypercorn`。
- en: The last piece of the puzzle is to avoid having to run each console script in
    a separate Bash window. We want to manage those processes with a single script.
    Let's see in the next section how we can do this with a process manager.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个难题是避免需要在单独的 Bash 窗口中运行每个控制台脚本。我们希望用一个脚本管理这些进程。让我们在下一节中看看如何使用进程管理器来实现这一点。
- en: Process management
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程管理
- en: Hypercorn specializes in running web apps. If you want to deploy a development
    environment with a few other processes, you have to manage several different Python
    microservices, a RabbitMQ instance, a database, and whatever else you use. In
    order to make life easier in your development environment, you will need to use
    another process manager.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Hypercorn 专注于运行 Web 应用程序。如果你想要部署一个包含其他几个进程的开发环境，你必须管理多个不同的 Python 微服务、一个 RabbitMQ
    实例、一个数据库以及你使用的其他任何东西。为了使你的开发环境更简单，你需要使用另一个进程管理器。
- en: A good option is a tool like `Circus` ([http://circus.readthedocs.io](http://circus.readthedocs.io)),
    which can run any kind of process, even when they are not ASGI or WSGI applications.
    It also has the ability to bind sockets and make them available for the managed
    processes. In other words, Circus can run a `Quart` app with several processes,
    and can also manage some other processes if needed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的选择是像`Circus`（[http://circus.readthedocs.io](http://circus.readthedocs.io)）这样的工具，它可以运行任何类型的进程，即使它们不是ASGI或WSGI应用程序。它还具有绑定套接字并使它们可用于管理进程的能力。换句话说，Circus可以运行具有多个进程的`Quart`应用程序，并在需要时管理其他进程。
- en: Circus is a Python application, so, to use it, you can simply run the command
    `pip install circus`. Once Circus is installed, it provides a few commands—through
    the `entry_points` method described earlier. The two principal commands are `circusd`,
    which is the process manager, and `circusctl`, which lets you control the process
    manager from the command line. Circus uses an INI-like configuration file, where
    you can list the commands to run in dedicated sections—and, for each one of them,
    the number of processes you want to use.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Circus是一个Python应用程序，因此，要使用它，您只需运行命令`pip install circus`。一旦安装了Circus，它就提供了一些命令——通过前面描述的`entry_points`方法。两个主要命令是`circusd`，它是进程管理器，以及`circusctl`，它允许您从命令行控制进程管理器。Circus使用类似于INI的配置文件，您可以在专用部分中列出要运行的命令——并且对于每一个，您想要使用的进程数。
- en: Circus can also bind sockets, and let the forked process use them via their
    file descriptors. When a socket is created on your system, it uses a **File Descriptor**
    (**FD**), which is a system handle a program can use to reach a file or an I/O
    resource like sockets. A process that is forked from another one inherits all
    its file descriptors. That is, through this mechanism, all the processes launched
    by Circus can share the same sockets.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Circus还可以绑定套接字，并允许通过它们的文件描述符使用它们。当您的系统上创建套接字时，它使用一个**文件描述符**（**FD**），这是一个程序可以用来访问文件或像套接字这样的I/O资源的系统句柄。从另一个进程派生的进程继承了所有其文件描述符。也就是说，通过这种机制，Circus启动的所有进程都可以共享相同的套接字。
- en: 'In the following example, two commands are being run. One will run five processes
    for the Quart application, located in the `server.py` module, using the `virtualenv`
    provided in the `virtualenv` path, and the second command will run one Redis server process:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，正在运行两个命令。第一个命令将在`server.py`模块中的Quart应用程序上运行五个进程，使用`virtualenv`路径中提供的`virtualenv`，第二个命令将运行一个Redis服务器进程：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `socket:web` section describes what host and port to use to bind the TCP
    socket, and the `watcher:web` section uses it via the `$(circus.sockets.web)`
    variable. When Circus runs, it replaces that variable with the FD value for the
    socket. To run this script, you can use the `circusd` command line:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket:web`部分描述了绑定TCP套接字时要使用的主机和端口，而`watcher:web`部分通过`$(circus.sockets.web)`变量使用它。当Circus运行时，它将替换该变量为套接字的FD值。要运行此脚本，您可以使用`circusd`命令行：'
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For our microservices, using Circus means we can simply create a watcher and
    a socket section per service and start them all using the `circusd` command.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的微服务，使用Circus意味着我们可以为每个服务简单地创建一个监视器和套接字部分，然后使用`circusd`命令启动它们。
- en: Circus also offers options to redirect the `stdout` and `stderr` streams to
    log files to facilitate debugging and numerous other features that can be found
    at [https://circus.readthedocs.io/en/latest/for-ops/configuration/](https://circus.readthedocs.io/en/latest/for-ops/configuration/).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Circus还提供了将`stdout`和`stderr`流重定向到日志文件以方便调试和其他许多功能的选项，这些功能可以在[https://circus.readthedocs.io/en/latest/for-ops/configuration/](https://circus.readthedocs.io/en/latest/for-ops/configuration/)找到。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have looked at how to package, release, and distribute each
    microservice. The current state of the art in Python packaging still requires
    some knowledge about the legacy tools, and this will be the case for some years
    until all the ongoing work in Python and `PyPA` becomes mainstream. But, provided
    you have a standard, reproducible, and documented way to package and install your
    microservices, you should be fine.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何打包、发布和分发每个微服务。Python打包的当前技术水平仍然需要一些关于遗留工具的知识，并且这种情况将在Python和`PyPA`的所有正在进行的工作成为主流之前持续数年。但是，如果您有一个标准、可重复和文档化的方式来打包和安装您的微服务，那么您应该没问题。
- en: Having numerous projects to run a single application adds a lot of complexity
    when you are developing it, and it's important to be able to run all pieces from
    within the same box. Tools like pip's development mode and Circus are useful for
    this, as it allows you to simplify how you run the whole stack—but they still
    require that you install tools on your system, even if it is inside a `virtualenv`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开发单个应用程序时，拥有众多项目会增加很多复杂性，并且能够从同一个环境中运行所有组件非常重要。像pip的开发模式和Circus这样的工具对此很有用，因为它们允许你简化整个堆栈的运行方式——但它们仍然需要在你的系统上安装工具，即使是在`virtualenv`内部。
- en: The other issue with running everything from your local computer is that you
    might not use an operating system that will be used to run your services in production,
    or you may have some libraries installed for other purposes, which might interfere.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从本地计算机运行所有内容的其他问题是，你可能不会使用在生产环境中运行你的服务的操作系统，或者你可能安装了一些用于其他目的的库，这可能会产生干扰。
- en: 'The best way to prevent this problem is to run your stack in an isolated environment.
    This is what the next chapter will cover: how to run your services inside a container.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 防止这种问题的最佳方式是在隔离环境中运行你的堆栈。这就是下一章将要介绍的内容：如何在容器内运行你的服务。
