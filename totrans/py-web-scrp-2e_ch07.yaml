- en: Solving CAPTCHA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CAPTCHA** stands for **Completely Automated Public Turing test to tell Computers
    and Humans Apart**. As the acronym suggests, it is a test to determine whether
    the user is human or not. A typical CAPTCHA consists of distorted text, which
    a computer program will find difficult to interpret but a human can (hopefully)
    still read.'
  prefs: []
  type: TYPE_NORMAL
- en: Many websites use CAPTCHA to prevent bots from interacting with their website.
    For example, my bank website forces me to pass a CAPTCHA everytime I log in, which
    is a pain. This chapter will cover how to solve CAPTCHAs automatically, first
    through **Optical Character Recognition** (**OCR**) and then with a CAPTCHA solving
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Solving CAPTCHAs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a CAPTCHA service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machine learning and CAPTCHAs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporting errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering an account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [chapter 6](py-web-scrp-2e_ch06.html), *Interacting with forms*, we logged
    in to the example website using a manually created account, but we skipped the
    account creation part because the registration form requires passing a CAPTCHA:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5679_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that each time the form is loaded, a different CAPTCHA image will be shown.
    To understand what the form requires, we can reuse the `parse_form()` function
    developed in the preceding chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All of the fields shown in the preceding code are straightforward, except for
    `recaptcha_response_field`, which, in this case, requires extracting strange from
    the image shown in our initial page view.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the CAPTCHA image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before the CAPTCHA image can be analyzed, it needs to be extracted from the
    form. Our browser developer tools show that the data for this image is embedded
    in the web page rather than being loaded from a separate URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5679_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To work with images in Python, we will use the `Pillow` package, which can
    be installed via `pip` using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Alternative ways to install `Pillow` are covered at [http://pillow.readthedocs.io/en/latest/installation.html](http://pillow.readthedocs.io/en/latest/installation.html).
  prefs: []
  type: TYPE_NORMAL
- en: '`Pillow` provides a convenient `Image` class with a number of high-level methods,
    which can be used to manipulate the CAPTCHA images. Here''s a function that takes
    the HTML of the registration page and returns the CAPTCHA image in an `Image`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first few lines here use `lxml` to extract the image data from the form.
    This image data is prepended with a header defining the data type. In this case,
    it is a PNG image encoded in Base64, which is a format used to represent binary
    data in ASCII. This header is removed by partitioning on the first comma. Then
    the image data needs to be decoded from Base64 into the original binary format.
    To load an image, `PIL` expects a file-like interface, so this binary data is
    wrapped with `BytesIO` and then passed to the `Image` class.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the CAPTCHA image in a more useful format, we are ready to
    attempt extracting the text.
  prefs: []
  type: TYPE_NORMAL
- en: Pillow vs PIL
  prefs: []
  type: TYPE_NORMAL
- en: '`Pillow` is a fork of the better known **Python Image Library** (**PIL**),
    which hasn''t been updated since 2009\. It uses the same interface as the original
    `PIL` package and is well documented at [http://pillow.readthedocs.org](http://pillow.readthedocs.org). `Pillow`
    supports Python3 (unlike `PIL`), so we will focus on using it in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Optical character recognition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Optical character recognition** (**OCR**) is a process to extract text from
    images. In this section, we will use the open source Tesseract OCR engine, which
    was originally developed at HP and now primarily at Google. Installation instructions
    for Tesseract are available at [https://github.com/tesseract-ocr/tesseract/wiki](https://github.com/tesseract-ocr/tesseract/wiki).
    The `pytesseract` Python wrapper can be installed with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If the original CAPTCHA image is passed to `pytesseract`, the results are terrible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: An empty string was returned, which means Tesseract failed to extract any characters
    from the input image. Tesseract was designed to extract more typical text, such
    as book pages with a consistent background. If we want to use Tesseract effectively,
    we will need to first modify the CAPTCHA images to remove the background noise
    and isolate the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand the CAPTCHA system we are dealing with, here are some
    more samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The samples in the previous image show that the CAPTCHA text is always black
    while the background is lighter, so this text can be isolated by checking each
    pixel and only keeping the black ones, a process known as **thresholding**. This
    process is straightforward to achieve with `Pillow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, we converted the image to grayscale using the `convert` method. Then,
    we mapped the image over a `lambda`function using the `point` command, which will
    iterate over every pixel in the image. In the `lambda` function, a threshold of
    less than `1` is used, which will only keep completely black pixels. This snippet
    saved three images--the original CAPTCHA image, the image in grayscale, and the
    image after thresholding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The text in the final image is much clearer and is ready to be passed to Tesseract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Success! The CAPTCHA text has been successfully extracted. In my test of 100
    images, this approach correctly interpreted the CAPTCHA image 82 times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the sample text is always lowercase ASCII characters, the performance
    can be improved further by restricting the result to these characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In my test on the same sample images, this improved the performance to 88 times
    out of 100.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full code of the registration script so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `register()` function downloads the registration page and scrapes the form
    as usual, where the desired name, e-mail, and password for the new account are
    set. The CAPTCHA image is then extracted, passed to the OCR function, and the
    result is added to the form. This form data is then submitted, and the response
    URL is checked to see whether the registration was successful.
  prefs: []
  type: TYPE_NORMAL
- en: If it fails (by not being properly redirected to the homepage), the form errors
    are printed as we may need to use a longer password, a different e-mail, or the
    CAPTCHA might have been unsuccessful. We also print out characters we removed
    in order to help debug how to make our CAPTCHA parser even better. These logs
    may help us identify common OCR errors, such as mistaking l for 1, and similar
    errors, which require fine distinction between similarly drawn characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to register an account, we simply need to call the `register()` function
    with the new account details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Further improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To improve the CAPTCHA OCR performance further, there are a number of possibilities,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Experimenting with different threshold levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eroding the thresholded text to emphasize the shape of characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resizing the image (sometimes increasing the image size helps)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Training the OCR tool on the CAPTCHA font
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricting results to dictionary words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are interested in experimenting to improve performance, the sample data
    used is available at [http://github.com/kjam/wswp/blob/master/data/captcha_samples](http://github.com/kjam/wswp/blob/master/data/captcha_samples).
    There is also a script to test the accuracy at [http://github.com/kjam/wswp/blob/master/code/chp7/test_samples.py](http://github.com/kjam/wswp/blob/master/code/chp7/test_samples.py).
    However, the current 88 percent accuracy is sufficient for our purposes of registering
    an account because actual users will also make mistakes when entering CAPTCHA
    text. Even 10 per cent accuracy would be sufficient because the script could be
    run many times until successful, though this would be rather impolite to the server
    and may lead to your IP being blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Solving complex CAPTCHAs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CAPTCHA system tested so far was relatively straightforward to solve --
    the black font color meant that the text could easily be distinguished from the
    background, and additionally, the text was level and did not need to be rotated
    for Tesseract to interpret it accurately. Often, you will find websites using
    simple custom CAPTCHA systems similar to this, and in these cases, an OCR solution
    is practical. However, if a website uses a more complex system, such as Google's
    reCAPTCHA, OCR will take a lot more effort and may become impractical.
  prefs: []
  type: TYPE_NORMAL
- en: In these examples, the text is placed at different angles and with different
    fonts and colors, so plenty more work needs to be done to clean and preprocess
    the image before OCR is accurate. These advanced CAPTCHAs can sometimes even be difficult
    for people to interpret, making it that much more difficult to do so with a simple
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Using a CAPTCHA solving service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To solve for these more complex images, we will make use of a CAPTCHA solving
    service. There are many CAPTCHA solving services available, such as [2captcha.com](https://2captcha.com)
    and [https://de-captcher.com/](https://de-captcher.com/), and the rates vary from
    $0.50 to $2 for around 1000 CAPTCHAs. When a CAPTCHA image is passed to a CAPTCHA-solving
    API, a person will then manually examine the image and provide the parsed text
    in an HTTP response, typically within 30 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: For the examples in this section, we will use the service at [9kw.eu](https://9kw.eu),
    which does not provide the cheapest per CAPTCHA rate or the best designed API.
    However, on the positive side, it is possible to use the API without spending
    money. This is because [9kw.eu](https://9kw.eu) allows users to manually solve
    CAPTCHAs to build up credit, which can then be spent on testing the API with our
    own CAPTCHAs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with 9kw
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start using 9kw, you will need to first create an account at [https://www.9kw.eu/register.html](https://www.9kw.eu/register.html).
  prefs: []
  type: TYPE_NORMAL
- en: Then, follow the account confirmation instructions, and when logged in, navigate
    to [https://www.9kw.eu/usercaptcha.html](https://www.9kw.eu/usercaptcha.html).
  prefs: []
  type: TYPE_NORMAL
- en: On this page, you can solve other people's CAPTCHAs to build up credit to use
    later on API calls. After solving a few CAPTCHAs, navigate to [https://www.9kw.eu/index.cgi?action=userapinew&source=api](https://www.9kw.eu/index.cgi?action=userapinew&source=api)
    to create an API key.
  prefs: []
  type: TYPE_NORMAL
- en: The 9kw CAPTCHA API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The 9kw API is documented at [https://www.9kw.eu/api.html#apisubmit-tab](https://www.9kw.eu/api.html#apisubmit-tab).
    The important parts for our purpose to submit a CAPTCHA and check the result are
    summarized here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To submit a CAPTCHA to solve, you can use this API method and parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL**: https://www.9kw.eu/index.cgi (POST)'
  prefs: []
  type: TYPE_NORMAL
- en: '**    apikey**: your API key'
  prefs: []
  type: TYPE_NORMAL
- en: '**    action**: must be set to "usercaptchaupload"'
  prefs: []
  type: TYPE_NORMAL
- en: '**    file-upload-01**: the image to solve (either a file, url or string)'
  prefs: []
  type: TYPE_NORMAL
- en: '**    base64**: set to "1" if the input is Base64 encoded'
  prefs: []
  type: TYPE_NORMAL
- en: '**    maxtimeout**: the maximum time to wait for a solution (must be between
    60 - 3999 seconds)'
  prefs: []
  type: TYPE_NORMAL
- en: '**    selfsolve**: set to "1" to solve this CAPTCHA yourself'
  prefs: []
  type: TYPE_NORMAL
- en: '**    json:** set to "1" to receive responses in JSON format'
  prefs: []
  type: TYPE_NORMAL
- en: '**API return value**: ID of this CAPTCHA'
  prefs: []
  type: TYPE_NORMAL
- en: 'To request the result of submitted captcha, you need to use a different API
    method with different parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL**: https://www.9kw.eu/index.cgi (GET)'
  prefs: []
  type: TYPE_NORMAL
- en: '**    apikey**: your API key'
  prefs: []
  type: TYPE_NORMAL
- en: '**    action**: must be set to "usercaptchacorrectdata"'
  prefs: []
  type: TYPE_NORMAL
- en: '**    id**: ID of CAPTCHA to check'
  prefs: []
  type: TYPE_NORMAL
- en: '**    info**: set to "1" to return "NO DATA" when there is not yet a solution
    (by default, returns nothing)'
  prefs: []
  type: TYPE_NORMAL
- en: '**    json:** set to "1" to receive responses in JSON format'
  prefs: []
  type: TYPE_NORMAL
- en: '**API return value**: Text of the solved CAPTCHA or an error code'
  prefs: []
  type: TYPE_NORMAL
- en: 'The API also has several error codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**0001** API key doesn''t exist'
  prefs: []
  type: TYPE_NORMAL
- en: '**0002** API key not found'
  prefs: []
  type: TYPE_NORMAL
- en: '**0003** Active API key not found'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '**0031** An account is not yet 24 hours in the system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**0032** An account does not have the full rights.'
  prefs: []
  type: TYPE_NORMAL
- en: '**0033** Plugin needs an update.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an initial implementation to send a CAPTCHA image to this API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This structure should hopefully be looking familiar by now -- first, build
    a dictionary with the required parameters, encode them, and then submit the data
    in the body of your request. Note that the `selfsolve` option is set to `''1''`:
    this means that if we are currently solving CAPTCHAs at the 9kw web interface,
    this CAPTCHA image will be passed to us to solve, which saves us credit. If not
    logged in, the CAPTCHA image is passed to another user to solve.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to fetch the result of a solved CAPTCHA image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: One drawback with the 9kw API is that the error messages are sent in the same JSON
    field as the results, which makes distinguishing them more complex. For example,
    if no user is available to solve the CAPTCHA image in time, the `ERROR NO USER`
    string is returned. Hopefully, the CAPTCHA image we submit never includes this
    text!
  prefs: []
  type: TYPE_NORMAL
- en: Another difficulty is the `get_captcha_text()` function will return error messages
    until another user has had the time to manually examine the CAPTCHA image, as
    mentioned earlier, typically 30 seconds later.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our implementation friendlier, we will add a wrapper function to submit
    the CAPTCHA image and wait until the result is ready. Here is an expanded version
    that wraps this functionality in a reusable class, as well as checking for error
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The source for the `CaptchaAPI` class is also available at [http://github.com/kjam/wswp/blob/master/code/chp7/captcha_api.py](http://github.com/kjam/wswp/blob/master/code/chp7/captcha_api.py),
    which will be kept updated if 9kw.eu modifies their API. This class is instantiated
    with your API key and a timeout, by default, set to 120 seconds. The `solve()`
    method then submits a CAPTCHA image to the API and keeps requesting the solution
    until either the CAPTCHA image is solved or a timeout is reached.
  prefs: []
  type: TYPE_NORMAL
- en: To check for error messages in the API response, the `check()` method examines
    whether the initial characters follow the expected format of four digits for the
    error code before the error message. For more robust use of this API, this method
    could be expanded to cover each of the 34 error types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of solving a CAPTCHA image with the `CaptchaAPI` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the correct solution for the first complex CAPTCHA image shown earlier
    in this chapter. If the same CAPTCHA image is submitted again soon after, the
    cached result is returned immediately, and no additional credit is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Reporting errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most CAPTCHA-solving services, such as 9kw.eu, offer the ability to report issues
    with solved CAPTCHAs and give feedback as to whether the text worked properly
    on the site or not. You may have already noticed that we have a `report` method
    on our `CaptchaAPI` class, which allows us to pass the CAPTCHA ID along with a
    boolean to determine whether the CAPTCHA was correct or not. It will then send
    the data to an endpoint used just for reporting CAPTCHA correctness. For our use
    case, we can determine if the CAPTCHA was correct by determining if our registration
    form succeeds or fails.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on what API you use, you may get returned credits when you report
    incorrect CAPTCHAs, which is useful if you are paying for the service. Of course,
    this could also be abused, so there is usually an upper limit on error reports
    for each day. Regardless of the return, reporting both correct and incorrect CAPTCHA
    solutions can help improve the service and allow you to not pay extra for invalid
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a working CAPTCHA API solution, we can integrate it with the
    previous form. Here is a modified version of the `register` function, which now utilizes
    the `CaptchaAPI` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, we are utilizing the new `CaptchaAPI`
    and ensuring we are reporting errors and success to the API. We also utilize `ConfigParser`,
    so our API key is never saved in the repository and is, instead, referenced in
    a config file. To see an example of the configuration file, check the repository
    ([http://github.com/kjam/wswp/blob/master/code/example_config.cfg](http://github.com/kjam/wswp/blob/master/code/example_config.cfg)).
    You could also store the API key in the environment variables or a safe storage
    on your computer or server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now try our new register function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It worked! The CAPTCHA image was successfully extracted from the form, submitted
    to the 9kw API, solved manually by another user, and the result was successfully
    submitted to the web server to register a new account.
  prefs: []
  type: TYPE_NORMAL
- en: CAPTCHAs and machine learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With advances in deep learning and image recognition, computers are getting
    better at properly identifying text and objects in images. There have been several
    interesting papers and projects applying these deep learning image recognition
    methods to CAPTCHAs. One Python-based project ([https://github.com/arunpatala/captcha](https://github.com/arunpatala/captcha))
    uses PyTorch to train a solver model on a large dataset of CAPTCHAs. In June 2012,
    Claudia Cruz, Fernando Uceda, and Leobardo Reyes (a group of students from Mexico)
    published a paper with an 82% solving accuracy on reCAPTCHA images ([http://dl.acm.org/citation.cfm?id=2367894](http://dl.acm.org/citation.cfm?id=2367894)).
    There have been several other research and hacking attempts, especially those
    targeting the often-included audio components of the CAPTCHA images (which are
    included for accessibility purposes).
  prefs: []
  type: TYPE_NORMAL
- en: It's unlikely that you'll need more than your OCR or API-based CAPTCHA-service
    to solve CAPTCHAs for the web scraping you encounter, but if you are curious to
    try and train your own model for fun, you will first need to find or create a
    large dataset of properly decoded CAPTCHAs. Deep learning and computer vision
    are rapidly-advancing fields, and it's likely that even more research and projects
    have been published since this book has been written!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed how to solve CAPTCHAs, first by using OCR, and then with
    an external API. For simple CAPTCHAs, or for when you need to solve a large amount
    of CAPTCHAs, investing time in an OCR solution can be worthwhile. Otherwise, using
    a CAPTCHA-solving API can prove to be a cost-effective alternative.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce Scrapy, which is a popular high-level
    framework used to build scraping applications.
  prefs: []
  type: TYPE_NORMAL
