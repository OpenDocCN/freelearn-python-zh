- en: Chapter 9. Exceptions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。异常
- en: Python's general approach to unexpected situations is to raise an **exception**.
    The idea is that an operation should either work normally and completely, or raise
    an exception. In some languages, complex numeric status codes are used to indicate
    success. In Python, success is assumed; if there's a problem, an exception is
    raised to indicate that the operation did not succeed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python处理意外情况的一般方法是通过引发**异常**。想法是操作要么正常完全工作，要么引发异常。在某些语言中，使用复杂的数值状态码来指示成功。在Python中，假设成功；如果有问题，会引发异常来指示操作未成功。
- en: Exceptions can be raised by all aspects of Python programs. All of the built-in
    classes involve exceptions for various kinds of unexpected conditions. Many library
    packages define their own unique exceptions which extend the built-in hierarchy
    of exceptions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序的所有方面都可以引发异常。所有内置类都涉及各种意外情况的异常。许多库包定义了自己的独特异常，这些异常扩展了内置异常层次结构。
- en: We'll look at the essential concept behind exceptions first. Python has a number
    of statements that we'll use. The `raise` statement creates an exception object.
    The `try` statement allows us to deal with exceptions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看看异常背后的基本概念。Python有一些我们将使用的语句。`raise`语句创建一个异常对象。`try`语句允许我们处理异常。
- en: The `except` clause in a `try` statement is used to match the class of exception
    being raised. With some kinds of programming, we narrowly match a specific class
    of exceptions. In other cases, we use a less specific class of exceptions, or
    a list of exception classes, to treat a variety of exceptions in a uniform manner.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`语句中的`except`子句用于匹配引发的异常类。在一些编程语言中，我们严格匹配特定的异常类。在其他情况下，我们使用更不具体的异常类或异常类列表，以统一的方式处理各种异常。'
- en: The core exception concept
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心异常概念
- en: The core concept behind exceptions can be summarized as, "when in doubt, raise
    an exception". In a typical situation, each Python function or method will return
    a value or have some documented side-effect. For everything that isn't on the
    "happy path" that leads to success, the Python approach is to raise an exception.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 异常背后的核心概念可以总结为：“当不确定时，引发异常”。在典型情况下，每个Python函数或方法都会返回一个值或有一些文档化的副作用。对于所有不在“成功路径”上的情况，Python的方法是引发异常。
- en: Even though most exceptions describe erroneous situations, an exception is not
    necessarily an error. It's merely an exceptional condition that a given function
    can't handle. For example, iterators raise the `StopIteration` exception when
    they can no longer produce a result item. This is an exceptional situation that
    occurs just once in the life cycle of an iterator object.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数异常描述了错误情况，但异常并不一定是错误。它只是给定函数无法处理的异常情况。例如，当迭代器无法再产生结果项时，会引发`StopIteration`异常。这是迭代器对象生命周期中仅发生一次的异常情况。
- en: 'When working with numbers, as a second example, division by zero is exceptional.
    If we divide by any other value, the happy path leads us to a result. While it''s
    possible to contrive a **Not a Number** (**NaN**) value as the result of division
    by zero, it''s simpler—and more universal—for the division operator to raise a
    `ZeroDivisionError` exception. Division by zero isn''t a normal or expected design.
    Almost universally, division by zero indicates one of these things:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理数字时，作为第二个例子，除以零是异常的。如果我们除以任何其他值，成功的路径将引导我们得到结果。虽然可以通过构造**非数字**（**NaN**）值作为除以零的结果，但让除法运算符引发`ZeroDivisionError`异常更简单——也更通用。除以零不是正常或预期的设计。几乎普遍来说，除以零表示以下情况之一：
- en: '**A design problem**: Zero was a possible condition, but the design didn''t
    deal with this situation. The `ZeroDivisionError` exception is unexpected. The
    root cause of a design problem may be a failure to understand the requirements:
    perhaps a hastily groomed story, perhaps other problems in understanding the problem
    domain.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计问题**：零是一个可能的情况，但设计没有处理这种情况。`ZeroDivisionError`异常是意外的。设计问题的根本原因可能是对需求理解不足：可能是匆忙整理的故事，也可能是对问题域理解的其他问题。'
- en: '**An implementation problem**: Zero is cropping up because of a bug. A `ZeroDivisionError`
    exception is similarly unexpected. The root cause may include inadequate unit
    testing.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现问题**：零的出现是因为一个错误。`ZeroDivisionError`异常同样意外。根本原因可能包括单元测试不足。'
- en: '**A misuse of the application**: The user provided input that led to division
    by zero. The overall application can offer a helpful error message and await different
    input. Or perhaps the overall application can use a different calculation that''s
    more appropriate to the input values.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用误用**：用户提供了导致除以零的输入。整体应用可以提供一个有用的错误消息并等待不同的输入。或者，整体应用可能可以使用更适合输入值的另一种计算方法。'
- en: An exception can be profound or shallow in its meaning.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 异常在其含义上可以是深刻的或浅显的。
- en: 'When working with strings, for example, there are a number of situations where
    an exception is raised. There are also some situations where a status code is
    returned instead of raising an exception. We can compare `str.find()` and `str.index()`
    for two differences in approach:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理字符串时，例如，有许多情况下会引发异常。也有一些情况下，返回状态码而不是抛出异常。我们可以比较`str.find()`和`str.index()`在方法上的两个不同之处：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first example shows the `index()` method, which raises an exception when
    a substring can't be found. The second example shows the `find()` method, which
    returns a peculiar number if the substring can't be found.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子显示了`index()`方法，当子串找不到时引发异常。第二个例子显示了`find()`方法，当子串找不到时返回一个特殊数字。
- en: Exceptions are used widely. Status codes are rarely used in Python.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 异常被广泛使用。在Python中，状态码很少被使用。
- en: Examining the exception object
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查异常对象
- en: When an exception is raised, it involves both a processing change and some data
    about the condition. An exception is an instance of a more general class. We'll
    talk generally about an `EOFError` exception without emphasizing that the given
    exception is an instance of the `EOFError` exception class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当异常被抛出时，它涉及处理方式的改变以及一些关于条件的数据。异常是更通用类的一个实例。我们将一般地讨论`EOFError`异常，而不强调给定的异常是`EOFError`异常类的实例。
- en: The data associated with an exception can include a root cause exception, and
    a collection of additional arguments. Sometimes the additional arguments are merely
    a string message. Some exceptions may have a more complex collection of arguments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与异常关联的数据可以包括根本原因异常和一系列额外的参数。有时这些额外的参数仅仅是一个字符串消息。一些异常可能有更复杂的参数集合。
- en: There is also a traceback object which contains the call stack. This identifies
    the function which raised the exception, the function which called that function,
    and so on, back to the initial function that started things off. This traceback
    information is in a specially named attribute called `__traceback__`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个包含调用栈的traceback对象。这确定了引发异常的函数，调用该函数的函数，以及等等，直到最初启动一切的函数。这个traceback信息在一个特别命名的属性`__traceback__`中。
- en: 'We can create an exception in several different ways:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种不同的方式创建异常：
- en: 'We can create exception objects and later raise them to signal a problem:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建异常对象，稍后抛出它们以表示问题：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can create and raise the exception in one smooth motion:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以一次性创建并抛出异常：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can create an exception which wraps a root-cause exception:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个封装根本原因异常的异常：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the last case, where an exception wraps a root cause, the root cause information
    is in an attribute named `__cause__`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况中，当一个异常封装了根本原因时，根本原因信息在一个名为`__cause__`的属性中。
- en: Using the try and except statements
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用try和except语句
- en: When an exception is raised, the ordinary sequential exception of statements
    stops. The next sequential statement is not executed. Instead, the exception handlers
    are examined to find an `except` clause which matches the given exception's class.
    This search proceeds down the call stack from the current function to the function
    which called it. If an `except` clause is found which matches the exception, then
    ordinary sequential execution resumes in that `except` clause. When the `except`
    clause finishes, the `try` statement is also finished. From there, the normal
    sequential statement execution continues after the `try` statement.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当异常被抛出时，普通的顺序语句执行停止。下一个顺序语句不会执行。相反，会检查异常处理程序以找到与给定异常类匹配的`except`子句。这个搜索从当前函数开始，沿着调用栈向下到调用它的函数。如果找到一个与异常匹配的`except`子句，那么在`except`子句中继续普通的顺序执行。当`except`子句完成后，`try`语句也结束了。从那里开始，正常的顺序语句执行在`try`语句之后继续。
- en: If no `except` clause matches the given exception, the exception and the traceback
    information is printed. Processing stops, and Python exits. Generally, the exit
    status is non-zero to indicate that the Python program ended abnormally.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`except`子句与给定的异常匹配，则会打印异常和跟踪信息。处理停止，Python退出。通常，退出状态是非零的，表示Python程序异常结束。
- en: 'A `try` statement inside a function looks like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 函数内部的`try`语句看起来像这样：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We've defined a function which will convert text to a number. We're going to
    silence the `ValueError` exception and return the `None` object instead of raising
    an exception. We might use this when cleaning a CSV file so that cells without
    proper numeric values are replaced with the `None` object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个将文本转换为数字的函数。我们将静默`ValueError`异常，并返回`None`对象而不是引发异常。我们可能会在清理CSV文件时使用它，以便将没有正确数值的单元格替换为`None`对象。
- en: We can see it in operation when we apply it to numbers, like this.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将它应用于数字时，我们可以看到它的运行情况，如下所示。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we're applying the `clean_number()` function to a row of data
    from the CSV reader. The sample row of data shows both the happy path and the
    exception path. On the happy path, the two numbers are converted from a string
    to a proper float value. On the exception path, the improper text was converted
    into a `None`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`clean_number()`函数应用于CSV读取器的数据行。示例数据行显示了快乐路径和异常路径。在快乐路径上，两个数字从字符串转换为正确的浮点值。在异常路径上，不正确的文本被转换为`None`。
- en: We've also included a test case that isn't handled well. This number-like string,
    "`1,956`" turns into `None`. We might have wanted it to be turned into a proper
    number, in spite of the embedded comma. We can see that a simplistic `except`
    clause isn't really doing everything we'd like it to do.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包含了一个处理不好的测试用例。这个类似数字的字符串"`1,956`"变成了`None`。我们可能希望即使有嵌入的逗号，也能将其转换为正确的数字。我们可以看到，简单的`except`子句并没有真正完成我们希望它完成的全部工作。
- en: Note that some financially-oriented spreadsheet values should be converted to
    `Decimal` values instead of `float` values. We can make a higher-order function
    which will use either the `float()` function or the `Decimal()` function (or any
    other conversion function for that matter) to create values of a desired type.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些以财务为导向的电子表格值应该转换为`Decimal`值而不是`float`值。我们可以创建一个高阶函数，该函数将使用`float()`函数或`Decimal()`函数（或任何其他转换函数）来创建所需类型的值。
- en: 'Here''s a revised version that has two `try` statements:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个包含两个`try`语句的修订版本：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this version of our number cleaning function, we have an additional parameter,
    `num_type`, with a conversion function to apply. We've provided a default value,
    `Decimal`, so that it is optional. The body of the function has the same happy
    path as the previous version. We've updated the first `except` clause to do more
    sophisticated fallback processing. This more sophisticated processing involves
    creating a new string without the `","` or `"$"` characters that commonly pollute
    numeric data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个数字清理函数的版本中，我们有一个额外的参数`num_type`，它有一个要应用的转换函数。我们提供了一个默认值`Decimal`，因此它是可选的。函数的主体与上一个版本相同。我们已经更新了第一个`except`子句，以进行更复杂的回退处理。这种更复杂的处理包括创建一个新的字符串，其中不包含常见的污染数值数据的`","`或`"$"`字符。
- en: If this second string is converted, we'll return a useful numeric result. If
    this revised string is not a number, we're stumped, and forced to return a `None`
    object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将这个第二个字符串转换为数字，我们将返回一个有用的数值结果。如果这个修订后的字符串不是数字，我们将陷入困境，被迫返回`None`对象。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As an exercise, the reader can create an algorithm to convert words to numbers
    as a fallback. Convert "twenty one" to 21\. The complexity of languages like English
    makes this is an interesting challenge.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，读者可以创建一个算法将单词转换为数字作为回退。将"twenty one"转换为21。英语等语言复杂度使得这是一个有趣的挑战。
- en: Using nested try statements
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用嵌套`try`语句
- en: The `clean_number3()` function shows one of the two ways that we can have nested
    `try` statements. In this case, the `try` statements are nested inside a single
    function. If an exception is raised in the inner `try` statement, then the inner
    `try` statement's `except` clause is checked first for a matching exception. The
    outer `try` statement's `except` clauses are checked next. If none of these match,
    then the function which called this is checked.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`clean_number3()`函数展示了我们可以嵌套`try`语句的两种方式之一。在这种情况下，`try`语句嵌套在单个函数内部。如果在内部`try`语句中引发异常，则首先检查内部`try`语句的`except`子句以匹配异常。然后检查外部`try`语句的`except`子句。如果没有这些匹配，则检查调用此函数的函数。'
- en: 'Consider this example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This produces a traceback dump that shows how nested try blocks behave:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个跟踪输出，显示嵌套`try`块的行为：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've elided some details with line numbers to focus on the relevant portions
    of the message. The first exception was raised by the first attempt to apply `Fraction(',2/0,')`.
    This raised a `ValueError` exception, knocking us off the happy path. Python resumes
    sequential execution in the `except` clause. This creates a new string with the
    `","` characters removed. The second attempt at conversion does not raise a `ValueError`
    exception, it raises a `ZeroDivisionError` exception.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了一些行号细节，以关注消息的相关部分。第一个异常是在第一次尝试应用`Fraction(',2/0,')`时引发的。这引发了一个`ValueError`异常，使我们偏离了快乐路径。Python在`except`子句中继续顺序执行。这创建了一个新的字符串，其中移除了`","`字符。第二次转换尝试不会引发`ValueError`异常，而是引发`ZeroDivisionError`异常。
- en: The inner `try` statement has no `except` clause to match this exception. Python
    must then search the outer `try` statement's `except` clauses for a matching exception.
    Since the outer `try` statement doesn't match the exception, the script as a whole
    ends with an unhandled exception.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 内部`try`语句没有`except`子句来匹配此异常。然后Python必须搜索外部`try`语句的`except`子句以查找匹配的异常。由于外部`try`语句不匹配异常，整个脚本以未处理的异常结束。
- en: The more common situation is to have `try` statements in separate functions.
    The nesting occurs via the function call stack, not the structure of a single
    suite of statements. Here's a function which calls our `clean_number3()` function
    to create a row of `Fraction` objects.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的情况是在单独的函数中包含`try`语句。嵌套是通过函数调用栈发生的，而不是单个语句块的结构。以下是一个调用我们的`clean_number3()`函数以创建一排`Fraction`对象的函数。
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function includes another `try` statement. When this function calls `clean_number3()`
    the calls stack will include `fraction_row()` and `clean_number3()`. If the `clean_number3()`
    function raises an unhandled exception, Python moves down the call stack and searches
    this `try` statement for matching `except` clauses.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数包含另一个`try`语句。当此函数调用`clean_number3()`时，调用栈将包括`fraction_row()`和`clean_number3()`。如果`clean_number3()`函数引发未处理的异常，Python将向下移动调用栈，并在此`try`语句中搜索匹配的`except`子句。
- en: Matching exception classes in an except clause
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`except`子句中匹配异常类
- en: 'In the previous examples, we''ve shown two kinds of `except` clauses:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们展示了两种`except`子句的类型：
- en: '`except SomeException:`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`except SomeException:`'
- en: '`except (OneException, AnotherException):`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`except (OneException, AnotherException):`'
- en: The first example matches a single specific exception. The second example matches
    any of the exceptions in the list of specific exceptions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子匹配单个特定异常。第二个例子匹配列表中的任何特定异常。
- en: 'In many cases, the details of the exception are not important. On the other
    hand, there are some cases where we want to do some processing on the exception
    object''s arguments. We can have the exception object assigned to a variable using
    this syntax:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，异常的详细信息并不重要。另一方面，有些情况下我们想在异常对象的参数上执行一些处理。我们可以使用此语法将异常对象分配给变量：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will assign the exception instance to the `exc` variable. We can then write
    this to a log, or examine the arguments, or modify the traceback that gets printed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把异常实例分配给`exc`变量。然后我们可以将其写入日志，或检查参数，或修改要打印的跟踪信息。
- en: Matching more general exceptions
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配更一般的异常
- en: The Python exceptions form a class hierarchy. Generally, we match exceptions
    specifically. In a few cases, we'll use exception superclasses instead of specific
    classes. Some of the most common superclasses are the `OSError` and `ArithmeticError`
    exceptions. There are a number of subclasses of `OSError` that provide more detailed
    information about the exception; in many cases, we're not too interested in the
    nuances of the `OSError` superclass. Similarly, the distinction between `OverflowError`
    and `ZeroDivisionError` may not be helpful.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Python 异常形成一个类层次结构。通常，我们会具体匹配异常。在少数情况下，我们会使用异常超类而不是具体类。一些最常见的超类是 `OSError` 和
    `ArithmeticError` 异常。有一些 `OSError` 的子类提供了关于异常的更详细的信息；在许多情况下，我们对 `OSError` 超类的细微差别不太感兴趣。同样，`OverflowError`
    和 `ZeroDivisionError` 之间的区别可能没有帮助。
- en: 'We can use the superclass exception like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用超类异常：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We've used the superclass `OSError` to match all of the various `OSError` subclasses.
    While the most likely exceptions are `FileNotFoundError` and `NotADirectoryError`,
    we may also get one of the other subclasses of `OSError`. In this case, we don't
    care about the specific problem, so we can use a superclass error.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用超类 `OSError` 来匹配所有各种 `OSError` 子类。虽然最可能的异常是 `FileNotFoundError` 和 `NotADirectoryError`，但我们也可能得到
    `OSError` 的其他子类之一。在这种情况下，我们不在乎具体问题，所以我们可以使用超类错误。
- en: This example also uses the `raise` statement with no argument. Within an `except`
    clause, this will reraise the exception after doing some initial handling. The
    exception will now propagate down the call stack as Python searches for a handler.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还使用了不带参数的 `raise` 语句。在 `except` 子句中，这将在进行一些初步处理后重新抛出异常。现在，异常将随着 Python 搜索处理程序而沿着调用堆栈传播。
- en: The empty except clause
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空的 `except` 子句
- en: 'Python allows an `except` clause with no exception named. This is the most
    general exception matcher: it matches all exception classes.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许没有指定异常的 `except` 子句。这是最通用的异常匹配器：它匹配所有异常类。
- en: Since it matches the `SystemExit` and `KeyboardInterrupt` exceptions, using
    this casually can create problems. When we're handling this exception, we may
    find that we can no longer gracefully exit from our program and must resort to
    the SIGKILL signal to stop the program.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它与 `SystemExit` 和 `KeyboardInterrupt` 异常匹配，随意使用可能会引起问题。当我们处理这个异常时，我们可能会发现我们不能再优雅地退出我们的程序，而必须求助于
    SIGKILL 信号来停止程序。
- en: The undecorated `except` clause should be viewed skeptically.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 未装饰的 `except` 子句应持怀疑态度。
- en: Creating our own exceptions
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们自己的异常
- en: The hierarchy of exceptions has a superclass for error-related exceptions, called
    `Exception`. All of the exceptions which reflect essentially erroneous conditions
    are subclasses of the `Exception` class. The base class for all exceptions is
    the `BaseException` class; some non-error-related exceptions are direct subclasses
    of the `BaseException` class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 异常的层次结构有一个名为 `Exception` 的错误相关异常的父类。所有反映基本错误条件的异常都是 `Exception` 类的子类。所有异常的基类是
    `BaseException` 类；一些非错误相关异常是 `BaseException` 类的直接子类。
- en: 'We can summarize the hierarchy like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样总结层次结构：
- en: '`BaseException`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseException`'
- en: '`SystemExit`'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SystemExit`'
- en: '`KeyboardInterrupt`'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeyboardInterrupt`'
- en: '`GeneratorExit`'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GeneratorExit`'
- en: '`Exception`'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exception`'
- en: All other exceptions
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他异常
- en: 'The superclass of all error-related exceptions, `Exception`, is quite broad.
    We can use this in a long-running server like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有错误相关异常的父类 `Exception` 非常广泛。我们可以在像这样长期运行的服务器中使用它：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This example depends on a function, `one_request()`, which handles a single
    request. The `while` loop runs forever, evaluating the `one_request()` function.
    If any of the error-related subclasses of `Exception` are raised, the error will
    be logged, but request handling will continue.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例依赖于一个函数，`one_request()`，它处理单个请求。`while` 循环永远运行，评估 `one_request()` 函数。如果抛出了任何与错误相关的
    `Exception` 子类，错误将被记录，但请求处理将继续。
- en: When a `Shutdown_Request` exception is raised, the inner `try` statement won't
    match this. The exception will propagate out of the loop into the outer `try`
    statement. We can log the shutdown request, do any other cleanup that's required,
    and exit the `server()` function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出 `Shutdown_Request` 异常时，内部的 `try` 语句不会匹配这个异常。异常将传播出循环到外部的 `try` 语句。我们可以记录关闭请求，执行任何其他所需的清理，并退出
    `server()` 函数。
- en: The class hierarchy assures us that two of the non-error exceptions—`KeyboardInterrupt`
    and `SystemExit`—will not be erroneously handled in the inner `try` statement.
    These exceptions are peers of the `Exception` class, which is why they will not
    be matched. This means that a `SIGINT` signal (the effect of hitting *Ctrl* +
    *C* on the keyboard) will terminate the server cleanly. Additionally, if some
    part of the request handling evaluates `sys.exit()`, the server will shut down
    gracefully.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类层次结构确保两个非错误异常——`KeyboardInterrupt`和`SystemExit`——不会在内部`try`语句中被错误处理。这些异常是`Exception`类的同等级别，这就是为什么它们不会匹配。这意味着一个`SIGINT`信号（在键盘上按*Ctrl*
    + *C*的效果）将干净地终止服务器。此外，如果请求处理的一部分评估`sys.exit()`，服务器将优雅地关闭。
- en: Using a finally clause
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`finally`子句
- en: 'We can include a `finally` clause on a `try` statement. This contains a suite
    of statements that will always be executed at the end of the `try` statement.
    This means that the happy path, as well as the exception paths, will always execute
    the `finally` suite. Here''s a summary of how this looks:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`try`语句上包含一个`finally`子句。这包含一个在`try`语句结束时始终执行的语句集。这意味着无论是成功路径还是异常路径，都会始终执行`finally`子句。以下是它的总结：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We use this when we have cleanup or a concluding suite of statements that must
    always be executed. One of the most common use cases for this is to close a file
    or a network connection even if an exception was raised and handled properly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有清理或必须始终执行的结束语句集时，我们会使用这个。这种用法最常见的情况是关闭文件或网络连接，即使异常已被引发并正确处理。
- en: In many cases, we can use a context manager to properly close a file or network
    connection. We can use `contextlib.closing()` to wrap objects which have a `close()`
    method but are not proper context managers. We'll look at context managers in
    [Chapter 10](ch10.html "Chapter 10. Files, Databases, Networks, and Contexts"),
    *Files, Databases, Networks, and Contexts*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们可以使用上下文管理器来正确关闭文件或网络连接。我们可以使用`contextlib.closing()`来包装具有`close()`方法但不是正确上下文管理器的对象。我们将在[第10章](ch10.html
    "第10章。文件、数据库、网络和上下文")*文件、数据库、网络和上下文*中查看上下文管理器。
- en: Use cases for exceptions
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常的使用场景
- en: The use cases for exceptions are very broad. We'll identify a few significant
    areas where exceptions are used in Python.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 异常的使用场景非常广泛。我们将确定几个在Python中使用异常的显著领域。
- en: Some exceptions are entirely benign. The `StopIteration` exception is raised
    by an iterable that has run out of values. The `for` statement consumes items
    from the iterable until this exception is raised to signal that there's no more
    data. Similarly, a `GeneratorExit` is used when a generator is closed before producing
    all of its data. This is not an error; it's a signal that more data will not be
    requested.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一些异常完全是良性的。`StopIteration`异常是由一个耗尽值的可迭代对象引发的。`for`语句从可迭代对象中消耗项目，直到这个异常被引发以表示没有更多数据。同样，当生成器在产生所有数据之前被关闭时，会使用`GeneratorExit`。这并不是错误；这是一个信号，表示不会请求更多数据。
- en: Conditions that are entirely outside the program may be seen as exceptions.
    Unexpected OS conditions or errors are signaled by exceptions which are subclasses
    of the `OSError` exception. Some OS conditions can be ignored; others may indicate
    a serious problem in the environment or in the application. There are over a dozen
    subclasses of this error to provide a more detailed description of the OS condition.
    Additionally, internal OS error numbers are also provided as an argument to these
    exceptions to help distinguish the details of the problem.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 完全在程序之外的条件下可能被视为异常。意外的操作系统条件或错误通过是`OSError`异常子类的异常来表示。一些操作系统条件可以忽略；其他可能表明环境或应用程序中存在严重问题。有十几个此类错误的子类，以提供对操作系统条件的更详细描述。此外，内部操作系统错误号也作为参数提供给这些异常，以帮助区分问题的细节。
- en: Some exceptions are the result of perfectly ordinary things inside a program.
    When we use the `str.index()` method, this may raise a `ValueError` exception
    instead of returning a numeric value. We can capture and leverage this exception
    information as part of a program's normal operation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一些异常是程序内部普通事物引起的。当我们使用`str.index()`方法时，可能会引发`ValueError`异常而不是返回一个数值。我们可以捕获并利用这个异常信息作为程序正常操作的一部分。
- en: We'll often detect the misuse of a program with exceptions. Bad data may be
    involved, or unsupported operations may be attempted. In these cases, a program
    may use exceptions to signal a problem that stems from user input problems. A
    common design pattern is to have exception handling at a high enough level to
    capture, log, and display these problems in a meaningful way to the user. A long-running
    server may merely log and then process the next request. A web page may wrap input
    form validation in exception handling so that the user's response is the form
    page decorated with error messages.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会通过异常检测程序的使用不当。可能涉及不良数据，或者尝试了不受支持的运算。在这些情况下，程序可能会使用异常来表示由用户输入问题引起的问题。一个常见的设计模式是在足够高的级别进行异常处理，以捕获、记录并以有意义的方式向用户显示这些问题。一个长期运行的服务器可能只是记录然后处理下一个请求。一个网页可能将输入表单验证包裹在异常处理中，以便用户的响应是带有错误信息的表单页面。
- en: Some exceptions reflect design or implementation problems. An unexpected occurrence
    of a `ValueError` exception may indicate a design problem or an implementation
    problem. It might indicate inadequate test cases. In this case, it's best for
    the program as a whole to crash so that the traceback information can be used
    to locate and correct the problem.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一些异常反映了设计或实现问题。`ValueError` 异常的意外发生可能表明设计问题或实现问题。它可能表明测试用例不足。在这种情况下，最好是整个程序崩溃，以便可以使用回溯信息来定位和纠正问题。
- en: Unexpected exceptions generally indicate that the program is broken. The program
    will stop; the output from the exception can provide valuable debugging information.
    We can interfere with this normal behavior by writing needlessly broad exception
    handlers, but concealing unexpected exceptions is generally a bad idea, since
    valuable debugging information is lost.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 未预期的异常通常表明程序已损坏。程序将停止；异常的输出可以提供有价值的调试信息。我们可以通过编写不必要的广泛异常处理程序来干扰这种正常行为，但隐藏未预期的异常通常是一个坏主意，因为会丢失有价值的调试信息。
- en: 'In *The Zen of Python* by Tim Peters, there''s some poetic advice:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在蒂姆·彼得斯的《Python之禅》中，有一些诗意的建议：
- en: '*Errors should never pass silently.*'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*错误绝不应该默默无闻。*'
- en: ''
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Unless explicitly silenced.*'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*除非明确静默。*'
- en: The idea here is that unexpected exceptions in Python will stop the program
    with a big, noisy error traceback. If we need to silence exceptions, we can use
    broad, general `except` statements to capture and silence them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是，Python 中的未预期异常将以一个大的、嘈杂的错误回溯停止程序。如果我们需要静默异常，我们可以使用广泛的通用 `except` 语句来捕获和静默它们。
- en: Issuing warnings instead of exceptions
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发出警告而不是异常
- en: The Python `warnings` module handles a special subclass of exceptions. We can
    use the `warnings` module to identify potential problems in our application. The
    warnings module is used internally to track a number of internal considerations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `warnings` 模块处理异常的特殊子类。我们可以使用 `warnings` 模块来识别应用程序中的潜在问题。警告模块用于内部跟踪多个内部考虑因素。
- en: The warning concept fits into the middle ground between perfectly normal operations
    and erroneous conditions. Our program may not be performing optimally, but it's
    not completely broken, either.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 警告概念介于完全正常的操作和错误条件之间。我们的程序可能表现不佳，但也不是完全损坏。
- en: There are three notable warning classes that we might encounter when running
    unit tests. Since the unit test framework displays `all` warnings, we may see
    some warnings in a test context that we don't see in the normal operational use
    of our software.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行单元测试时，我们可能会遇到三种显著的警告类别。由于单元测试框架显示`所有`警告，我们可能会在测试环境中看到一些在软件的正常操作使用中看不到的警告。
- en: '`DeprecationWarning`: This warning is raised by modules, functions, or classes
    that have been deprecated. It''s a reminder that we need to fix our code to stop
    using this feature.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeprecationWarning`：此警告由已弃用的模块、函数或类引发。它提醒我们需要修复代码以停止使用此功能。'
- en: '`PendingDeprecationWarning`: A function, module or class for which deprecation
    has been announced may raise this warning. This is a hint that we need to stop
    using this feature before it becomes deprecated.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PendingDeprecationWarning`：对于已宣布弃用的函数、模块或类，可能会引发此警告。这是一个提示，我们需要在它成为弃用功能之前停止使用此功能。'
- en: '`ImportWarning`: Since some modules are optional or platform-specific, some
    import statements are wrapped in a `try` block; this warning is raised instead
    of an exception. We can expose these warnings to be sure that imports are being
    processed properly.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImportWarning`：由于一些模块是可选的或平台特定的，一些导入语句被包裹在 `try` 块中；这个警告会引发而不是异常。我们可以暴露这些警告以确保导入被正确处理。'
- en: We can leverage the `warnings` module to expose the warnings which are normally
    silenced. We can use `warnings.simplefilter("always")` to see all warnings.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用 `warnings` 模块来暴露那些通常被静默的警告。我们可以使用 `warnings.simplefilter("always")` 来查看所有警告。
- en: 'We can raise the generic `UserWarning` like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样引发通用的 `UserWarning`：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using `warnings.warn()` allows us to include warning messages in an application
    with very little overhead. We can use this as a debugging aid to track rare situations
    that are questionable or potentially confusing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `warnings.warn()` 允许我们在应用程序中包含警告信息，而几乎不需要任何开销。我们可以将其用作调试辅助工具，以跟踪可疑或可能令人困惑的罕见情况。
- en: Permission versus forgiveness – a Pythonic approach
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权与宽恕——Pythonic 方法
- en: 'A common piece of Pythonic wisdom is the following advice from RADM Grace Murray
    Hopper:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一条常见的 Python 知识点是来自 RADM 格蕾丝·穆雷·霍珀的以下建议：
- en: '*"It is Easier to Ask for Forgiveness than Permission"*'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"求得宽恕比求得许可更容易"*'
- en: In the Python community, this is sometimes summarized as EAFP programming. This
    is in contrast to **Look Before You Leap** (**LBYL**) programming.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 社区中，这有时被总结为 EAFP（先做后检查）编程。这与 **LBYL（先检查后执行**）编程形成对比。
- en: Python exception handling is fast. More importantly, all of the necessary precondition
    checks for potential problems are already part of the language itself. We never
    need to bracket processing with extraneous `if` statements to see whether or not
    the input could possibly raise an exception.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Python 异常处理速度快。更重要的是，所有潜在问题的必要先决条件检查已经包含在语言本身中。我们永远不需要用额外的 `if` 语句括起来处理过程，以查看输入是否可能引发异常。
- en: 'It''s generally considered a bad practice to write LBYL code that looks like
    this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通常认为编写如下形式的 LBYL（先检查后执行）代码是不良实践：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The bad idea shown here is an attempt to check carefully to prevent an exception
    from being raised. This is ineffective for a number of reasons.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的糟糕想法是仔细检查以防止抛出异常。由于多种原因，这种方法是无效的。
- en: The `isdigit()` test fails to properly handle negative numbers. For a `float()`
    conversion, this kind of test misses a large number of valid syntax alternatives.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isdigit()` 测试无法正确处理负数。对于 `float()` 转换，这种测试会错过大量有效的语法变体。'
- en: The overhead of checking the validity of characters and syntax is already part
    of the `int()` function. Checking validity in advance duplicates the checking
    already in place.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查字符和语法的有效性开销已经包含在 `int()` 函数中。提前检查会重复已经存在的检查。
- en: 'The more Pythonic approach is to handle the built-in exceptions. For example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 更 Pythonic 的方法是对内置异常进行处理。例如：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is the same number of lines of code. It properly converts all possible
    Python integer strings. It does not include any redundant validity checks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的行数与之前相同。它正确地转换了所有可能的 Python 整数字符串。它不包括任何冗余的有效性检查。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've seen how we can use Python exceptions to write programs
    which properly handle unexpected conditions. The various kinds of exceptions reflect
    external conditions as well as internal conditions that may alter how our program
    behaves. We can use exception clauses to implement fallback processing so that
    our program handles these exceptional conditions gracefully.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用 Python 异常编写能够正确处理意外情况的程序。各种类型的异常反映了外部条件以及可能改变程序行为的内部条件。我们可以使用异常子句来实现回退处理，以便程序能够优雅地处理这些异常情况。
- en: We've also seen some things which are discouraged. The empty `except` clause—which
    matches too many kinds of exception classes—is something which is legal but should
    not be used.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了一些被 discourage 的事情。空白的 `except` 子句——它匹配太多种异常类——是合法的，但不应该使用。
- en: The idea of **Look Before You Leap** (**LBYL**) programming is also generally
    discouraged. The Pythonic approach is summarized as **Easier to Ask Forgiveness
    than to ask Permission** (**EAFP**). The general approach is to wrap operations
    in a `try` statement and write appropriate exception handlers for the meaningful
    exceptions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**“三思而后行”**（**LBYL**）编程的思想也通常不被鼓励。Python的方法可以概括为**“求原谅比求许可更容易”**（**EAFP**）。一般的方法是将操作封装在`try`语句中，并为有意义的异常编写适当的异常处理器。'
- en: Some exceptions, such as `RuntimeError` or `SyntaxError`, should not be handled
    by ordinary application programming. These exceptions usually indicate problems
    so serious that the program really should crash.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一些异常，如`RuntimeError`或`SyntaxError`，不应该由普通的应用程序编程来处理。这些异常通常表明问题非常严重，程序确实应该崩溃。
- en: Other exceptions, such as `IndexError` or `KeyError`, may be an expected part
    of the design. When these exceptions are unexpected, we've uncovered a design
    problem. This may also indicate that we have inadequate unit tests.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 其他异常，如`IndexError`或`KeyError`，可能是设计的一部分。当这些异常是意外的，我们就发现了设计问题。这也可能表明我们缺乏足够的单元测试。
- en: In [Chapter 10](ch10.html "Chapter 10. Files, Databases, Networks, and Contexts"),
    *Files, Databases, Networks, and Contexts*, we'll look at a number of ways in
    which Python can be used to work with persistent data files and network data transmission.
    This kind of processing will often require exception handling.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](ch10.html "第10章。文件、数据库、网络和上下文")*文件、数据库、网络和上下文*中，我们将探讨Python在处理持久数据文件和网络数据传输方面的多种方法。这类处理通常需要异常处理。
