- en: Chapter 9. Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python's general approach to unexpected situations is to raise an **exception**.
    The idea is that an operation should either work normally and completely, or raise
    an exception. In some languages, complex numeric status codes are used to indicate
    success. In Python, success is assumed; if there's a problem, an exception is
    raised to indicate that the operation did not succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions can be raised by all aspects of Python programs. All of the built-in
    classes involve exceptions for various kinds of unexpected conditions. Many library
    packages define their own unique exceptions which extend the built-in hierarchy
    of exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at the essential concept behind exceptions first. Python has a number
    of statements that we'll use. The `raise` statement creates an exception object.
    The `try` statement allows us to deal with exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The `except` clause in a `try` statement is used to match the class of exception
    being raised. With some kinds of programming, we narrowly match a specific class
    of exceptions. In other cases, we use a less specific class of exceptions, or
    a list of exception classes, to treat a variety of exceptions in a uniform manner.
  prefs: []
  type: TYPE_NORMAL
- en: The core exception concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core concept behind exceptions can be summarized as, "when in doubt, raise
    an exception". In a typical situation, each Python function or method will return
    a value or have some documented side-effect. For everything that isn't on the
    "happy path" that leads to success, the Python approach is to raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Even though most exceptions describe erroneous situations, an exception is not
    necessarily an error. It's merely an exceptional condition that a given function
    can't handle. For example, iterators raise the `StopIteration` exception when
    they can no longer produce a result item. This is an exceptional situation that
    occurs just once in the life cycle of an iterator object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with numbers, as a second example, division by zero is exceptional.
    If we divide by any other value, the happy path leads us to a result. While it''s
    possible to contrive a **Not a Number** (**NaN**) value as the result of division
    by zero, it''s simpler—and more universal—for the division operator to raise a
    `ZeroDivisionError` exception. Division by zero isn''t a normal or expected design.
    Almost universally, division by zero indicates one of these things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A design problem**: Zero was a possible condition, but the design didn''t
    deal with this situation. The `ZeroDivisionError` exception is unexpected. The
    root cause of a design problem may be a failure to understand the requirements:
    perhaps a hastily groomed story, perhaps other problems in understanding the problem
    domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An implementation problem**: Zero is cropping up because of a bug. A `ZeroDivisionError`
    exception is similarly unexpected. The root cause may include inadequate unit
    testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A misuse of the application**: The user provided input that led to division
    by zero. The overall application can offer a helpful error message and await different
    input. Or perhaps the overall application can use a different calculation that''s
    more appropriate to the input values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exception can be profound or shallow in its meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with strings, for example, there are a number of situations where
    an exception is raised. There are also some situations where a status code is
    returned instead of raising an exception. We can compare `str.find()` and `str.index()`
    for two differences in approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first example shows the `index()` method, which raises an exception when
    a substring can't be found. The second example shows the `find()` method, which
    returns a peculiar number if the substring can't be found.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions are used widely. Status codes are rarely used in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the exception object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an exception is raised, it involves both a processing change and some data
    about the condition. An exception is an instance of a more general class. We'll
    talk generally about an `EOFError` exception without emphasizing that the given
    exception is an instance of the `EOFError` exception class.
  prefs: []
  type: TYPE_NORMAL
- en: The data associated with an exception can include a root cause exception, and
    a collection of additional arguments. Sometimes the additional arguments are merely
    a string message. Some exceptions may have a more complex collection of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a traceback object which contains the call stack. This identifies
    the function which raised the exception, the function which called that function,
    and so on, back to the initial function that started things off. This traceback
    information is in a specially named attribute called `__traceback__`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create an exception in several different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create exception objects and later raise them to signal a problem:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can create and raise the exception in one smooth motion:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can create an exception which wraps a root-cause exception:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the last case, where an exception wraps a root cause, the root cause information
    is in an attribute named `__cause__`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the try and except statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an exception is raised, the ordinary sequential exception of statements
    stops. The next sequential statement is not executed. Instead, the exception handlers
    are examined to find an `except` clause which matches the given exception's class.
    This search proceeds down the call stack from the current function to the function
    which called it. If an `except` clause is found which matches the exception, then
    ordinary sequential execution resumes in that `except` clause. When the `except`
    clause finishes, the `try` statement is also finished. From there, the normal
    sequential statement execution continues after the `try` statement.
  prefs: []
  type: TYPE_NORMAL
- en: If no `except` clause matches the given exception, the exception and the traceback
    information is printed. Processing stops, and Python exits. Generally, the exit
    status is non-zero to indicate that the Python program ended abnormally.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `try` statement inside a function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a function which will convert text to a number. We're going to
    silence the `ValueError` exception and return the `None` object instead of raising
    an exception. We might use this when cleaning a CSV file so that cells without
    proper numeric values are replaced with the `None` object.
  prefs: []
  type: TYPE_NORMAL
- en: We can see it in operation when we apply it to numbers, like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're applying the `clean_number()` function to a row of data
    from the CSV reader. The sample row of data shows both the happy path and the
    exception path. On the happy path, the two numbers are converted from a string
    to a proper float value. On the exception path, the improper text was converted
    into a `None`.
  prefs: []
  type: TYPE_NORMAL
- en: We've also included a test case that isn't handled well. This number-like string,
    "`1,956`" turns into `None`. We might have wanted it to be turned into a proper
    number, in spite of the embedded comma. We can see that a simplistic `except`
    clause isn't really doing everything we'd like it to do.
  prefs: []
  type: TYPE_NORMAL
- en: Note that some financially-oriented spreadsheet values should be converted to
    `Decimal` values instead of `float` values. We can make a higher-order function
    which will use either the `float()` function or the `Decimal()` function (or any
    other conversion function for that matter) to create values of a desired type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a revised version that has two `try` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this version of our number cleaning function, we have an additional parameter,
    `num_type`, with a conversion function to apply. We've provided a default value,
    `Decimal`, so that it is optional. The body of the function has the same happy
    path as the previous version. We've updated the first `except` clause to do more
    sophisticated fallback processing. This more sophisticated processing involves
    creating a new string without the `","` or `"$"` characters that commonly pollute
    numeric data.
  prefs: []
  type: TYPE_NORMAL
- en: If this second string is converted, we'll return a useful numeric result. If
    this revised string is not a number, we're stumped, and forced to return a `None`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an exercise, the reader can create an algorithm to convert words to numbers
    as a fallback. Convert "twenty one" to 21\. The complexity of languages like English
    makes this is an interesting challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Using nested try statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `clean_number3()` function shows one of the two ways that we can have nested
    `try` statements. In this case, the `try` statements are nested inside a single
    function. If an exception is raised in the inner `try` statement, then the inner
    `try` statement's `except` clause is checked first for a matching exception. The
    outer `try` statement's `except` clauses are checked next. If none of these match,
    then the function which called this is checked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces a traceback dump that shows how nested try blocks behave:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We've elided some details with line numbers to focus on the relevant portions
    of the message. The first exception was raised by the first attempt to apply `Fraction(',2/0,')`.
    This raised a `ValueError` exception, knocking us off the happy path. Python resumes
    sequential execution in the `except` clause. This creates a new string with the
    `","` characters removed. The second attempt at conversion does not raise a `ValueError`
    exception, it raises a `ZeroDivisionError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: The inner `try` statement has no `except` clause to match this exception. Python
    must then search the outer `try` statement's `except` clauses for a matching exception.
    Since the outer `try` statement doesn't match the exception, the script as a whole
    ends with an unhandled exception.
  prefs: []
  type: TYPE_NORMAL
- en: The more common situation is to have `try` statements in separate functions.
    The nesting occurs via the function call stack, not the structure of a single
    suite of statements. Here's a function which calls our `clean_number3()` function
    to create a row of `Fraction` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This function includes another `try` statement. When this function calls `clean_number3()`
    the calls stack will include `fraction_row()` and `clean_number3()`. If the `clean_number3()`
    function raises an unhandled exception, Python moves down the call stack and searches
    this `try` statement for matching `except` clauses.
  prefs: []
  type: TYPE_NORMAL
- en: Matching exception classes in an except clause
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous examples, we''ve shown two kinds of `except` clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`except SomeException:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`except (OneException, AnotherException):`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first example matches a single specific exception. The second example matches
    any of the exceptions in the list of specific exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases, the details of the exception are not important. On the other
    hand, there are some cases where we want to do some processing on the exception
    object''s arguments. We can have the exception object assigned to a variable using
    this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will assign the exception instance to the `exc` variable. We can then write
    this to a log, or examine the arguments, or modify the traceback that gets printed.
  prefs: []
  type: TYPE_NORMAL
- en: Matching more general exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python exceptions form a class hierarchy. Generally, we match exceptions
    specifically. In a few cases, we'll use exception superclasses instead of specific
    classes. Some of the most common superclasses are the `OSError` and `ArithmeticError`
    exceptions. There are a number of subclasses of `OSError` that provide more detailed
    information about the exception; in many cases, we're not too interested in the
    nuances of the `OSError` superclass. Similarly, the distinction between `OverflowError`
    and `ZeroDivisionError` may not be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the superclass exception like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We've used the superclass `OSError` to match all of the various `OSError` subclasses.
    While the most likely exceptions are `FileNotFoundError` and `NotADirectoryError`,
    we may also get one of the other subclasses of `OSError`. In this case, we don't
    care about the specific problem, so we can use a superclass error.
  prefs: []
  type: TYPE_NORMAL
- en: This example also uses the `raise` statement with no argument. Within an `except`
    clause, this will reraise the exception after doing some initial handling. The
    exception will now propagate down the call stack as Python searches for a handler.
  prefs: []
  type: TYPE_NORMAL
- en: The empty except clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python allows an `except` clause with no exception named. This is the most
    general exception matcher: it matches all exception classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Since it matches the `SystemExit` and `KeyboardInterrupt` exceptions, using
    this casually can create problems. When we're handling this exception, we may
    find that we can no longer gracefully exit from our program and must resort to
    the SIGKILL signal to stop the program.
  prefs: []
  type: TYPE_NORMAL
- en: The undecorated `except` clause should be viewed skeptically.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our own exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hierarchy of exceptions has a superclass for error-related exceptions, called
    `Exception`. All of the exceptions which reflect essentially erroneous conditions
    are subclasses of the `Exception` class. The base class for all exceptions is
    the `BaseException` class; some non-error-related exceptions are direct subclasses
    of the `BaseException` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can summarize the hierarchy like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BaseException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SystemExit`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KeyboardInterrupt`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GeneratorExit`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exception`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All other exceptions
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The superclass of all error-related exceptions, `Exception`, is quite broad.
    We can use this in a long-running server like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This example depends on a function, `one_request()`, which handles a single
    request. The `while` loop runs forever, evaluating the `one_request()` function.
    If any of the error-related subclasses of `Exception` are raised, the error will
    be logged, but request handling will continue.
  prefs: []
  type: TYPE_NORMAL
- en: When a `Shutdown_Request` exception is raised, the inner `try` statement won't
    match this. The exception will propagate out of the loop into the outer `try`
    statement. We can log the shutdown request, do any other cleanup that's required,
    and exit the `server()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The class hierarchy assures us that two of the non-error exceptions—`KeyboardInterrupt`
    and `SystemExit`—will not be erroneously handled in the inner `try` statement.
    These exceptions are peers of the `Exception` class, which is why they will not
    be matched. This means that a `SIGINT` signal (the effect of hitting *Ctrl* +
    *C* on the keyboard) will terminate the server cleanly. Additionally, if some
    part of the request handling evaluates `sys.exit()`, the server will shut down
    gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: Using a finally clause
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can include a `finally` clause on a `try` statement. This contains a suite
    of statements that will always be executed at the end of the `try` statement.
    This means that the happy path, as well as the exception paths, will always execute
    the `finally` suite. Here''s a summary of how this looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We use this when we have cleanup or a concluding suite of statements that must
    always be executed. One of the most common use cases for this is to close a file
    or a network connection even if an exception was raised and handled properly.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, we can use a context manager to properly close a file or network
    connection. We can use `contextlib.closing()` to wrap objects which have a `close()`
    method but are not proper context managers. We'll look at context managers in
    [Chapter 10](ch10.html "Chapter 10. Files, Databases, Networks, and Contexts"),
    *Files, Databases, Networks, and Contexts*.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use cases for exceptions are very broad. We'll identify a few significant
    areas where exceptions are used in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Some exceptions are entirely benign. The `StopIteration` exception is raised
    by an iterable that has run out of values. The `for` statement consumes items
    from the iterable until this exception is raised to signal that there's no more
    data. Similarly, a `GeneratorExit` is used when a generator is closed before producing
    all of its data. This is not an error; it's a signal that more data will not be
    requested.
  prefs: []
  type: TYPE_NORMAL
- en: Conditions that are entirely outside the program may be seen as exceptions.
    Unexpected OS conditions or errors are signaled by exceptions which are subclasses
    of the `OSError` exception. Some OS conditions can be ignored; others may indicate
    a serious problem in the environment or in the application. There are over a dozen
    subclasses of this error to provide a more detailed description of the OS condition.
    Additionally, internal OS error numbers are also provided as an argument to these
    exceptions to help distinguish the details of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Some exceptions are the result of perfectly ordinary things inside a program.
    When we use the `str.index()` method, this may raise a `ValueError` exception
    instead of returning a numeric value. We can capture and leverage this exception
    information as part of a program's normal operation.
  prefs: []
  type: TYPE_NORMAL
- en: We'll often detect the misuse of a program with exceptions. Bad data may be
    involved, or unsupported operations may be attempted. In these cases, a program
    may use exceptions to signal a problem that stems from user input problems. A
    common design pattern is to have exception handling at a high enough level to
    capture, log, and display these problems in a meaningful way to the user. A long-running
    server may merely log and then process the next request. A web page may wrap input
    form validation in exception handling so that the user's response is the form
    page decorated with error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Some exceptions reflect design or implementation problems. An unexpected occurrence
    of a `ValueError` exception may indicate a design problem or an implementation
    problem. It might indicate inadequate test cases. In this case, it's best for
    the program as a whole to crash so that the traceback information can be used
    to locate and correct the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Unexpected exceptions generally indicate that the program is broken. The program
    will stop; the output from the exception can provide valuable debugging information.
    We can interfere with this normal behavior by writing needlessly broad exception
    handlers, but concealing unexpected exceptions is generally a bad idea, since
    valuable debugging information is lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *The Zen of Python* by Tim Peters, there''s some poetic advice:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Errors should never pass silently.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Unless explicitly silenced.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The idea here is that unexpected exceptions in Python will stop the program
    with a big, noisy error traceback. If we need to silence exceptions, we can use
    broad, general `except` statements to capture and silence them.
  prefs: []
  type: TYPE_NORMAL
- en: Issuing warnings instead of exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python `warnings` module handles a special subclass of exceptions. We can
    use the `warnings` module to identify potential problems in our application. The
    warnings module is used internally to track a number of internal considerations.
  prefs: []
  type: TYPE_NORMAL
- en: The warning concept fits into the middle ground between perfectly normal operations
    and erroneous conditions. Our program may not be performing optimally, but it's
    not completely broken, either.
  prefs: []
  type: TYPE_NORMAL
- en: There are three notable warning classes that we might encounter when running
    unit tests. Since the unit test framework displays `all` warnings, we may see
    some warnings in a test context that we don't see in the normal operational use
    of our software.
  prefs: []
  type: TYPE_NORMAL
- en: '`DeprecationWarning`: This warning is raised by modules, functions, or classes
    that have been deprecated. It''s a reminder that we need to fix our code to stop
    using this feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PendingDeprecationWarning`: A function, module or class for which deprecation
    has been announced may raise this warning. This is a hint that we need to stop
    using this feature before it becomes deprecated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImportWarning`: Since some modules are optional or platform-specific, some
    import statements are wrapped in a `try` block; this warning is raised instead
    of an exception. We can expose these warnings to be sure that imports are being
    processed properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can leverage the `warnings` module to expose the warnings which are normally
    silenced. We can use `warnings.simplefilter("always")` to see all warnings.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can raise the generic `UserWarning` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using `warnings.warn()` allows us to include warning messages in an application
    with very little overhead. We can use this as a debugging aid to track rare situations
    that are questionable or potentially confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Permission versus forgiveness – a Pythonic approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common piece of Pythonic wisdom is the following advice from RADM Grace Murray
    Hopper:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"It is Easier to Ask for Forgiveness than Permission"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the Python community, this is sometimes summarized as EAFP programming. This
    is in contrast to **Look Before You Leap** (**LBYL**) programming.
  prefs: []
  type: TYPE_NORMAL
- en: Python exception handling is fast. More importantly, all of the necessary precondition
    checks for potential problems are already part of the language itself. We never
    need to bracket processing with extraneous `if` statements to see whether or not
    the input could possibly raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s generally considered a bad practice to write LBYL code that looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The bad idea shown here is an attempt to check carefully to prevent an exception
    from being raised. This is ineffective for a number of reasons.
  prefs: []
  type: TYPE_NORMAL
- en: The `isdigit()` test fails to properly handle negative numbers. For a `float()`
    conversion, this kind of test misses a large number of valid syntax alternatives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overhead of checking the validity of characters and syntax is already part
    of the `int()` function. Checking validity in advance duplicates the checking
    already in place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The more Pythonic approach is to handle the built-in exceptions. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is the same number of lines of code. It properly converts all possible
    Python integer strings. It does not include any redundant validity checks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've seen how we can use Python exceptions to write programs
    which properly handle unexpected conditions. The various kinds of exceptions reflect
    external conditions as well as internal conditions that may alter how our program
    behaves. We can use exception clauses to implement fallback processing so that
    our program handles these exceptional conditions gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: We've also seen some things which are discouraged. The empty `except` clause—which
    matches too many kinds of exception classes—is something which is legal but should
    not be used.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of **Look Before You Leap** (**LBYL**) programming is also generally
    discouraged. The Pythonic approach is summarized as **Easier to Ask Forgiveness
    than to ask Permission** (**EAFP**). The general approach is to wrap operations
    in a `try` statement and write appropriate exception handlers for the meaningful
    exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Some exceptions, such as `RuntimeError` or `SyntaxError`, should not be handled
    by ordinary application programming. These exceptions usually indicate problems
    so serious that the program really should crash.
  prefs: []
  type: TYPE_NORMAL
- en: Other exceptions, such as `IndexError` or `KeyError`, may be an expected part
    of the design. When these exceptions are unexpected, we've uncovered a design
    problem. This may also indicate that we have inadequate unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](ch10.html "Chapter 10. Files, Databases, Networks, and Contexts"),
    *Files, Databases, Networks, and Contexts*, we'll look at a number of ways in
    which Python can be used to work with persistent data files and network data transmission.
    This kind of processing will often require exception handling.
  prefs: []
  type: TYPE_NORMAL
