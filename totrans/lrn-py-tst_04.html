<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Decoupling Units with unittest.mock</h1></div></div></div><p>Several times in the last couple of chapters, when faced with the problem of isolating tests from each other, I told you to just keep the problem in mind and said we'd deal with it in this chapter. Finally, it's time to actually address the problem.</p><p>Functions and methods that do not rely on the behavior of other functions, methods, or data are rare; the common case is to have them make several calls to other functions or methods, and instantiate at least one instance of a class. Every one of these calls and instantiations breaks the unit's isolation; or, if you prefer to think of it this way, it incorporates more code into the isolated section.</p><p>No matter how you look at it—as an isolation breaking or as expanding the isolated section—it's something you want to have the ability to prevent. Mock objects let you do this by taking the place of external functions or objects.</p><p>Using the <code class="literal">unittest.mock</code> package, you can easily perform the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Replace <a id="id140" class="indexterm"/>functions and objects in your own code or in external packages, as we did with <code class="literal">time.time</code> in <a class="link" href="ch03.html" title="Chapter 3. Unit Testing with doctest">Chapter 3</a>, <em>Unit Testing with doctest</em>.</li><li class="listitem" style="list-style-type: disc">Control how replacement objects behave. You can control what return values they provide, whether they raise an exception, even whether they make any calls to other functions, or create instances of other objects.</li><li class="listitem" style="list-style-type: disc">Check whether the replacement objects were used as you expected: whether functions or methods were called the correct number of times, whether the calls occurred in the correct order, and whether the passed parameters were correct.</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Mock objects in general</h1></div></div></div><p>All right, before <a id="id141" class="indexterm"/>we get down to the nuts and bolts of <code class="literal">unittest.mock</code>, let's spend a few moments talking about mock objects overall.</p><p>Broadly speaking, mock objects are any objects that you can use as substitutes in your test code, to keep your tests from overlapping and your tested code from infiltrating the wrong tests. Thus, our fake <code class="literal">time.time</code> from <a class="link" href="ch03.html" title="Chapter 3. Unit Testing with doctest">Chapter 3</a>, <em>Unit Testing with doctest</em>, was a mock object. However, like most things in programming, the idea works better when it has been formalized into a well-designed library that you can call on when you need it. There are many such libraries available for most programming languages.</p><p>Over time, the authors of mock object libraries have developed two major design patterns for mock objects: in one pattern, you can create a mock object and perform all of the expected operations on it. The object records these operations, and then you put the object into playback mode and pass it to your code. If your code fails to duplicate the expected operations, the mock object reports a failure.</p><p>In the second pattern, you can create a mock object, do the minimal necessary configuration to allow it to mimic the real object it replaces, and pass it to your code. It records how the code uses it, and then you can perform assertions after the fact to check whether your code used the object as expected.</p><p>The second pattern is <em>slightly</em> more capable in terms of the tests that you can write using it but, overall, either pattern works well.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Mock objects according to unittest.mock</h1></div></div></div><p>Python has <a id="id142" class="indexterm"/>several mock object libraries; as of Python 3.3, however, one of them has been crowned as a member of the standard library. Naturally <a id="id143" class="indexterm"/>that's the one we're going to focus on. That library is, of course, <code class="literal">unittest.mock</code>.</p><p>The <code class="literal">unittest.mock</code> library is of the second sort, a record-actual-use-and-then-assert library. The library contains several different kinds of mock objects that, between them, let you mock almost anything that exists in Python. Additionally, the library contains several useful helpers that simplify assorted tasks related to mock objects, such as temporarily replacing real objects with mocks.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Standard mock objects</h2></div></div></div><p>The basic <a id="id144" class="indexterm"/>element of <code class="literal">unittest.mock</code> is the <code class="literal">unittest.mock.Mock</code> class. Even without being configured at all, <code class="literal">Mock</code> instances can do a pretty good job of <a id="id145" class="indexterm"/>pretending to be some other object, method, or function.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>There are many mock object libraries for Python; so, strictly speaking, the phrase "mock object" could mean any object that was created by any of these libraries. From here on in this book, you can assume that a "mock object" is an instance of <code class="literal">unittest.mock.Mock</code> or one of its descendants.</p></div></div><p>Mock objects can pull off this impersonation because of a clever, somewhat recursive trick. When you access an unknown attribute of a mock object, instead of raising an <code class="literal">AttributeError</code> exception, the mock object creates a child mock object and returns that. Since mock objects are pretty good at impersonating other objects, returning a mock object instead of the real value works at least in the common case.</p><p>Similarly, mock objects are callable; when you call a mock object as a function or method, it records the parameters of the call and then, by default, returns a child mock object.</p><p>A child mock object is a mock object in its own right, but it knows that it's connected to the mock object it came from—its parent. Anything you do to the child is also recorded in the parent's memory. When the time comes to check whether the mock objects were used correctly, you can use the parent object to check on all of its descendants.</p><p>Example: Playing with mock objects in the interactive shell (try it for yourself!):</p><div><pre class="programlisting"><strong>$ python3.4</strong>
<strong>Python 3.4.0 (default, Apr  2 2014, 08:10:08)</strong>
<strong>[GCC 4.8.2] on linux</strong>
<strong>Type "help", "copyright", "credits" or "license" for more information.</strong>
<strong>&gt;&gt;&gt; from unittest.mock import Mock, call</strong>
<strong>&gt;&gt;&gt; mock = Mock()</strong>
<strong>&gt;&gt;&gt; mock.x</strong>
<strong>&lt;Mock name='mock.x' id='140145643647832'&gt;</strong>
<strong>&gt;&gt;&gt; mock.x</strong>
<strong>&lt;Mock name='mock.x' id='140145643647832'&gt;</strong>
<strong>&gt;&gt;&gt; mock.x('Foo', 3, 14)</strong>
<strong>&lt;Mock name='mock.x()' id='140145643690640'&gt;</strong>
<strong>&gt;&gt;&gt; mock.x('Foo', 3, 14)</strong>
<strong>&lt;Mock name='mock.x()' id='140145643690640'&gt;</strong>
<strong>&gt;&gt;&gt; mock.x('Foo', 99, 12)</strong>
<strong>&lt;Mock name='mock.x()' id='140145643690640'&gt;</strong>
<strong>&gt;&gt;&gt; mock.y(mock.x('Foo', 1, 1))</strong>
<strong>&lt;Mock name='mock.y()' id='140145643534320'&gt;</strong>
<strong>&gt;&gt;&gt; mock.method_calls</strong>
<strong>[call.x('Foo', 3, 14),</strong>
<strong> call.x('Foo', 3, 14),</strong>
<strong> call.x('Foo', 99, 12),</strong>
<strong> call.x('Foo', 1, 1),</strong>
<strong> call.y(&lt;Mock name='mock.x()' id='140145643690640'&gt;)]</strong>
<strong>&gt;&gt;&gt; mock.assert_has_calls([call.x('Foo', 1, 1)])</strong>
<strong>&gt;&gt;&gt; mock.assert_has_calls([call.x('Foo', 1, 1), call.x('Foo', 99, 12)])</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>  File "/usr/lib64/python3.4/unittest/mock.py", line 792, in assert_has_calls</strong>
<strong>    ) from cause</strong>
<strong>AssertionError: Calls not found.</strong>
<strong>Expected: [call.x('Foo', 1, 1), call.x('Foo', 99, 12)]</strong>
<strong>Actual: [call.x('Foo', 3, 14),</strong>
<strong> call.x('Foo', 3, 14),</strong>
<strong> call.x('Foo', 99, 12),</strong>
<strong> call.x('Foo', 1, 1),</strong>
<strong> call.y(&lt;Mock name='mock.x()' id='140145643690640'&gt;)]</strong>
<strong>&gt;&gt;&gt; mock.assert_has_calls([call.x('Foo', 1, 1),...                        call.x('Foo', 99, 12)], any_order = True)</strong>
<strong>&gt;&gt;&gt; mock.assert_has_calls([call.y(mock.x.return_value)])</strong>
<strong>&gt;&gt;&gt;</strong></pre></div><p>There are several important things demonstrated in this interactive session.</p><p>First, notice that the <em>same</em> mock object was returned each time that we accessed <code class="literal">mock.x</code>. This always holds true: if you access the same attribute of a mock object, you'll get the same mock object back as the result.</p><p>The next thing to notice might seem more surprising. Whenever you call a mock object, you get the same <a id="id146" class="indexterm"/>mock object back as the return value. The returned mock <a id="id147" class="indexterm"/>isn't made new for every call, nor is it unique for each combination of parameters. We'll see how to override the return value shortly but, by default, you get the same mock object back every time you call a mock object. This mock object can be accessed using the <code class="literal">return_value</code> attribute name, as you might have noticed from the last statement of the example.</p><p>The <code class="literal">unittest.mock</code> package contains a <code class="literal">call</code> object that helps to make it easier to check whether the correct calls have been made. The <code class="literal">call</code> object is callable, and takes note of its parameters in a way similar to mock objects, making it easy to compare it to a mock object's call history. However, the <code class="literal">call</code> object really shines when you have to check for calls to descendant mock objects. As you can see in the previous example, while <code class="literal">call('Foo', 1, 1)</code> will match a call to the parent mock object, if the call used these parameters, <code class="literal">call.x('Foo', 1, 1)</code>, it matches a call to the child mock object named <code class="literal">x</code>. You can build up a long chain of lookups and invocations. For example:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; mock.z.hello(23).stuff.howdy('a', 'b', 'c')</strong>
<strong>&lt;Mock name='mock.z.hello().stuff.howdy()' id='140145643535328'&gt;</strong>
<strong>&gt;&gt;&gt; mock.assert_has_calls([</strong>
<strong>...     call.z.hello().stuff.howdy('a', 'b', 'c')</strong>
<strong>... ])</strong>
<strong>&gt;&gt;&gt;</strong></pre></div><p>Notice that the original invocation included <code class="literal">hello(23)</code>, but the call specification wrote it simply as <code class="literal">hello()</code>. Each call specification is only concerned with the parameters of the object that was finally <a id="id148" class="indexterm"/>called after all of the lookups. The parameters of intermediate <a id="id149" class="indexterm"/>calls are not considered. That's okay because they always produce the same return value anyway unless you've overridden that behavior, in which case they probably don't produce a mock object at all.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>You might not have encountered an assertion before. Assertions have one job, and one job only: they raise an exception if something is not as expected. The <code class="literal">assert_has_calls</code> method, in particular, raises an exception if the mock object's history does not include the specified calls. In our example, the call history matches, so the assertion method doesn't do anything visible.</p></div></div><p>You <em>can</em> check whether the intermediate calls were made with the correct parameters, though, because the mock object recorded a call immediately to <code class="literal">mock.z.hello(23)</code> before it recorded a call to <code class="literal">mock.z.hello().stuff.howdy('a', 'b', 'c')</code>:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; mock.mock_calls.index(call.z.hello(23))</strong>
<strong>6</strong>
<strong>&gt;&gt;&gt; mock.mock_calls.index(call.z.hello().stuff.howdy('a', 'b', 'c'))</strong>
<strong>7</strong></pre></div><p>This also points out the <code class="literal">mock_calls</code> attribute that all mock objects carry. If the various assertion functions don't <a id="id150" class="indexterm"/>quite do the trick for you, you can always write your own functions that inspect the <code class="literal">mock_calls</code> list and check whether things are or <a id="id151" class="indexterm"/>are not as they should be. We'll discuss the mock object assertion methods shortly.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec01"/>Non-mock attributes</h3></div></div></div><p>What if <a id="id152" class="indexterm"/>you want a mock object to give back <a id="id153" class="indexterm"/>something other than a child mock object when you look up an attribute? It's easy; just assign a value to that attribute:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; mock.q = 5</strong>
<strong>&gt;&gt;&gt; mock.q</strong>
<strong>5</strong></pre></div><p>There's one other common case where mock objects' default behavior is wrong: what if accessing a particular attribute is supposed to raise an <code class="literal">AttributeError</code>? Fortunately, that's easy too:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; del mock.w</strong>
<strong>&gt;&gt;&gt; mock.w</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>  File "/usr/lib64/python3.4/unittest/mock.py", line 563, in __getattr__</strong>
<strong>    raise AttributeError(name)</strong>
<strong>AttributeError: w</strong></pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec02"/>Non-mock return values and raising exceptions</h3></div></div></div><p>Sometimes, actually <a id="id154" class="indexterm"/>fairly often, you'll want mock objects posing as <a id="id155" class="indexterm"/>functions or methods to <a id="id156" class="indexterm"/>return a specific value, or a series of specific values, rather than returning another mock object.</p><p>To make a mock object always return the same value, just change the <code class="literal">return_value</code> attribute:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; mock.o.return_value = 'Hi'</strong>
<strong>&gt;&gt;&gt; mock.o()</strong>
<strong>'Hi'</strong>
<strong>&gt;&gt;&gt; mock.o('Howdy')</strong>
<strong>'Hi'</strong></pre></div><p>If you want the mock object to return different value each time it's called, you need to assign an iterable of return values to the <code class="literal">side_effect</code> attribute instead, as follows:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; mock.p.side_effect = [1, 2, 3]</strong>
<strong>&gt;&gt;&gt; mock.p()</strong>
<strong>1</strong>
<strong>&gt;&gt;&gt; mock.p()</strong>
<strong>2</strong>
<strong>&gt;&gt;&gt; mock.p()</strong>
<strong>3</strong>
<strong>&gt;&gt;&gt; mock.p()</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>  File "/usr/lib64/python3.4/unittest/mock.py", line 885, in __call__</strong>
<strong>    return _mock_self._mock_call(*args, **kwargs)</strong>
<strong>  File "/usr/lib64/python3.4/unittest/mock.py", line 944, in _mock_call</strong>
<strong>    result = next(effect)</strong>
<strong>StopIteration</strong></pre></div><p>If you don't <a id="id157" class="indexterm"/>want your mock object to raise a <code class="literal">StopIteration</code> exception, you need to make sure to give it enough return values for all of the invocations in your test. If you don't know how many times it will be invoked, an infinite iterator such as <code class="literal">itertools.count</code> might be what you need. This is easily done:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; mock.p.side_effect = itertools.count()</strong></pre></div><p>If you want <a id="id158" class="indexterm"/>your mock to raise an exception <a id="id159" class="indexterm"/>instead of returning a value, just assign the exception object to <code class="literal">side_effect</code>, or put it into the iterable that you assign to <code class="literal">side_effect</code>:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; mock.e.side_effect = [1, ValueError('x')]</strong>
<strong>&gt;&gt;&gt; mock.e()</strong>
<strong>1</strong>
<strong>&gt;&gt;&gt; mock.e()</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>  File "/usr/lib64/python3.4/unittest/mock.py", line 885, in __call__</strong>
<strong>    return _mock_self._mock_call(*args, **kwargs)</strong>
<strong>  File "/usr/lib64/python3.4/unittest/mock.py", line 946, in _mock_call</strong>
<strong>    raise result</strong>
<strong>ValueError: x</strong></pre></div><p>The <code class="literal">side_effect</code> <a id="id160" class="indexterm"/>attribute has another use, as <a id="id161" class="indexterm"/>well that <a id="id162" class="indexterm"/>we'll talk about.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec03"/>Mocking class or function details</h3></div></div></div><p>Sometimes, the <a id="id163" class="indexterm"/>generic behavior of mock objects isn't a close enough emulation of the object being replaced. This is particularly the case when it's <a id="id164" class="indexterm"/>important that they raise exceptions when used improperly, since mock objects are usually happy to accept any usage.</p><p>The <code class="literal">unittest.mock</code> <a id="id165" class="indexterm"/>package addresses this problem using a technique called <strong>speccing</strong>. If you pass an object into <code class="literal">unittest.mock.create_autospec</code>, the returned value will be a <a id="id166" class="indexterm"/>mock object, but it will do its best to pretend that it's the same object you passed into <code class="literal">create_autospec</code>. This means that it will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Raise an <code class="literal">AttributeError</code> if you attempt to access an attribute that the original object doesn't have, unless you first explicitly assign a value to that attribute</li><li class="listitem" style="list-style-type: disc">Raise a <code class="literal">TypeError</code> if you attempt to call the mock object when the original object wasn't callable</li><li class="listitem" style="list-style-type: disc">Raise a <code class="literal">TypeError</code> if you pass the wrong number of parameters or pass a keyword parameter that isn't viable if the original object was callable</li><li class="listitem" style="list-style-type: disc">Trick <code class="literal">isinstance</code> into thinking that the mock object is of the original object's type</li></ul></div><p>Mock objects made by <code class="literal">create_autospec</code> share this trait with all of their children as well, which is usually what you want. If you really just want a specific mock to be specced, while its children are not, you can pass the template object into the <code class="literal">Mock</code> constructor using the <code class="literal">spec</code> keyword.</p><p>Here's a short demonstration of using <code class="literal">create_autospec</code>:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; from unittest.mock import create_autospec</strong>
<strong>&gt;&gt;&gt; x = Exception('Bad', 'Wolf')</strong>
<strong>&gt;&gt;&gt; y = create_autospec(x)</strong>
<strong>&gt;&gt;&gt; isinstance(y, Exception)</strong>
<strong>True</strong>
<strong>&gt;&gt;&gt; y</strong>
<strong>&lt;NonCallableMagicMock spec='Exception' id='140440961099088'&gt;</strong></pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec04"/>Mocking function or method side effects</h3></div></div></div><p>Sometimes, for <a id="id167" class="indexterm"/>a mock object to successfully take the place of a function or method means that the mock object has to actually perform <a id="id168" class="indexterm"/>calls to other functions, or set variable values, or generally do whatever a function can do.</p><p>This need is less <a id="id169" class="indexterm"/>common than you might think, and it's also somewhat dangerous for testing purposes because, when your mock objects can execute arbitrary code, there's a possibility that they stop being a simplifying tool for enforcing test isolation, and <a id="id170" class="indexterm"/>become a complex part of the problem instead.</p><p>Having said that, there are still times when you need a mocked function to do something more complex than simply returning a value, and we can use the <code class="literal">side_effect</code> attribute of mock objects to achieve this. We've seen <code class="literal">side_effect</code> before, when we assigned an iterable of return values to it.</p><p>If you assign a callable to <code class="literal">side_effect</code>, this callable will be called when the mock object is called and passed the same parameters. If the <code class="literal">side_effect</code> function raises an exception, this is what the mock object does as well; otherwise, the <code class="literal">side_effect</code> return value is returned by the mock object.</p><p>In other words, if you assign a function to a mock object's <code class="literal">side_effect</code> attribute, this mock object in effect becomes that function with the only important difference being that the mock object still records the details of how it's used.</p><p>The code in a <code class="literal">side_effect</code> function should be minimal, and should not try to actually do the job of the code the mock object is replacing. All it should do is perform any expected externally visible operations and then return the expected <code class="literal">result.Mock</code> object assertion methods</p><p>As we saw in the <em>Standard mock objects</em> section, you can always write code that checks the <code class="literal">mock_calls</code> attribute of mock objects to see whether or not things are behaving as they should. However, there are some particularly common checks that have already been written for you, and are available as assertion methods of the mock objects themselves. As is normal for assertions, these assertion methods return <code class="literal">None</code> if they pass, and raise an <code class="literal">AssertionError</code> if they fail.</p><p>The <code class="literal">assert_called_with</code> method accepts an arbitrary collection of arguments and keyword <a id="id171" class="indexterm"/>arguments, and raises an <code class="literal">AssertionError</code> unless these parameters were passed to the mock the last time it was called.</p><p>The <code class="literal">assert_called_once_with</code> method behaves like <code class="literal">assert_called_with</code>, except that it also <a id="id172" class="indexterm"/>checks whether the mock was only called once and raises <code class="literal">AssertionError</code> if that is not true.</p><p>The <code class="literal">assert_any_call</code> method accepts arbitrary arguments and keyword arguments, and raises <a id="id173" class="indexterm"/>an <code class="literal">AssertionError</code> if the mock object has never been called with these parameters.</p><p>We've already <a id="id174" class="indexterm"/>seen the <code class="literal">assert_has_calls</code> method. This method accepts a list of call objects, checks whether they appear in the history in the same order, and raises an exception if they do not. Note that "in the <a id="id175" class="indexterm"/>same order" does not necessarily mean "next to each other." There can be other calls in between the listed calls as long as all of the listed calls <a id="id176" class="indexterm"/>appear in the proper sequence. This <a id="id177" class="indexterm"/>behavior changes if you assign a true value to the <code class="literal">any_order</code> argument. In that case, <code class="literal">assert_has_calls</code> doesn't care about the order of the calls, and only checks whether they all appear in the history.</p><p>The <code class="literal">assert_not_called</code> <a id="id178" class="indexterm"/>method raises an exception if the <a id="id179" class="indexterm"/>mock has ever been called.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Mocking containers and objects with a special behavior</h2></div></div></div><p>One thing <a id="id180" class="indexterm"/>the <code class="literal">Mock</code> class does not handle is the so-called magic methods that underlie Python's special syntactic constructions: <code class="literal">__getitem__</code>, <code class="literal">__add__</code>, and so on. If you need your mock objects to record and respond to magic methods—in other words, if you want them to pretend to be container objects <a id="id181" class="indexterm"/>such as dictionaries or lists, or respond to mathematical operators, or act as context managers or any of the other things where <a id="id182" class="indexterm"/>syntactic sugar translates it into a <a id="id183" class="indexterm"/>method call underneath—you're going to use <code class="literal">unittest.mock.MagicMock</code> to create your mock objects.</p><p>There are a few magic methods that are not supported even by <code class="literal">MagicMock</code>, due to details of how they (and mock objects) work: <code class="literal">__getattr__</code>, <code class="literal">__setattr__</code>, <code class="literal">__init__</code> , <code class="literal">__new__</code>, <code class="literal">__prepare__</code>, <code class="literal">__instancecheck__</code>, <code class="literal">__subclasscheck__</code>, and <code class="literal">__del__</code>.</p><p>Here's a simple example in which we use <code class="literal">MagicMock</code> to create a mock object supporting the <code class="literal">in</code> operator:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; from unittest.mock import MagicMock</strong>
<strong>&gt;&gt;&gt; mock = MagicMock()</strong>
<strong>&gt;&gt;&gt; 7 in mock</strong>
<strong>False</strong>
<strong>&gt;&gt;&gt; mock.mock_calls</strong>
<strong>[call.__contains__(7)]</strong>
<strong>&gt;&gt;&gt; mock.__contains__.return_value = True</strong>
<strong>&gt;&gt;&gt; 8 in mock</strong>
<strong>True</strong>
<strong>&gt;&gt;&gt; mock.mock_calls</strong>
<strong>[call.__contains__(7), call.__contains__(8)]</strong></pre></div><p>Things work similarly with the other magic methods. For example, addition:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; mock + 5</strong>
<strong>&lt;MagicMock name='mock.__add__()' id='140017311217816'&gt;</strong>
<strong>&gt;&gt;&gt; mock.mock_calls</strong>
<strong>[call.__contains__(7), call.__contains__(8), call.__add__(5)]</strong></pre></div><p>Notice that the return value of the addition is a mock object, a child of the original mock object, but the <code class="literal">in</code> operator returned a Boolean value. Python ensures that some magic methods return a value of a particular type, and will raise an exception if that requirement is not fulfilled. In these cases, <code class="literal">MagicMock's</code> implementations of the methods return a best-guess value of the proper type, instead of a child mock object.</p><p>There's <a id="id184" class="indexterm"/>something you need to be careful of when it comes to the in-place mathematical operators, such as <code class="literal">+=</code> (<code class="literal">__iadd__</code>) and <code class="literal">|=</code> (<code class="literal">__ior__</code>), and that is the fact that <code class="literal">MagicMock</code> handles them somewhat strangely. What it does is still <a id="id185" class="indexterm"/>useful, but it might well catch you by surprise:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; mock += 10</strong>
<strong>&gt;&gt;&gt; mock.mock_calls</strong>
<strong>[]</strong></pre></div><p>What was that? Did <a id="id186" class="indexterm"/>it erase our call history? Fortunately, no, it <a id="id187" class="indexterm"/>didn't. What it did was assign the child mock created by the addition operation to the variable called mock. That is entirely in accordance with how the in-place math operators are supposed to work. Unfortunately, it has still cost us our ability to access the call history, since we no longer have a variable pointing at the parent mock object.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>Make sure that you have the parent mock object set aside in a variable that won't be reassigned, if you're going to be checking in-place math operators. Also, you should make sure that your mocked in-place operators return the result of the operation, even if that just means <code class="literal">return self.return_value</code>, because otherwise Python will assign <code class="literal">None</code> to the left-hand variable.</p></div></div><p>There's another <a id="id188" class="indexterm"/>detailed way in which in-place operators work that you should keep in mind:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; mock = MagicMock()</strong>
<strong>&gt;&gt;&gt; x = mock</strong>
<strong>&gt;&gt;&gt; x += 5</strong>
<strong>&gt;&gt;&gt; x</strong>
<strong>&lt;MagicMock name='mock.__iadd__()' id='139845830142216'&gt;</strong>
<strong>&gt;&gt;&gt; x += 10</strong>
<strong>&gt;&gt;&gt; x</strong>
<strong>&lt;MagicMock name='mock.__iadd__().__iadd__()' id='139845830154168'&gt;</strong>
<strong>&gt;&gt;&gt; mock.mock_calls</strong>
<strong>[call.__iadd__(5), call.__iadd__().__iadd__(10)]</strong></pre></div><p>Because the result of the operation is assigned to the original variable, a series of in-place math operations <a id="id189" class="indexterm"/>builds up a chain of child mock objects. If you <a id="id190" class="indexterm"/>think about it, that's the right thing to do, but <a id="id191" class="indexterm"/>it is rarely what people expect at first.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec42"/>Mock objects for properties and descriptors</h2></div></div></div><p>There's <a id="id192" class="indexterm"/>another category of things that basic <code class="literal">Mock</code> objects don't do a good job of emulating: <strong>descriptors</strong>.</p><p>Descriptors <a id="id193" class="indexterm"/>are objects that allow you to interfere with the normal variable access mechanism. The most commonly used descriptors are created by <a id="id194" class="indexterm"/>Python's property built-in function, which simply <a id="id195" class="indexterm"/>allows you to write functions to control getting, setting, and deleting a variable.</p><p>To mock a property (or other descriptor), create a <code class="literal">unittest.mock.PropertyMock</code> instance and assign it to the property name. The only complication is that you can't assign a descriptor to an object instance; you have to assign it to the object's type because descriptors are looked up in the type without first checking the instance.</p><p>That's not hard to do with mock objects, fortunately:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; from unittest.mock import PropertyMock</strong>
<strong>&gt;&gt;&gt; mock = Mock()</strong>
<strong>&gt;&gt;&gt; prop = PropertyMock()</strong>
<strong>&gt;&gt;&gt; type(mock).p = prop</strong>
<strong>&gt;&gt;&gt; mock.p</strong>
<strong>&lt;MagicMock name='mock()' id='139845830215328'&gt;</strong>
<strong>&gt;&gt;&gt; mock.mock_calls</strong>
<strong>[]</strong>
<strong>&gt;&gt;&gt; prop.mock_calls</strong>
<strong>[call()]</strong>
<strong>&gt;&gt;&gt; mock.p = 6</strong>
<strong>&gt;&gt;&gt; prop.mock_calls</strong>
<strong>[call(), call(6)]</strong></pre></div><p>The thing to be mindful of here is that the property is not a child of the object named mock. Because of this, we have to keep it around in its own variable because otherwise we'd have no way of accessing its history.</p><p>The <code class="literal">PropertyMock</code> <a id="id196" class="indexterm"/>objects record variable lookup as a call with <a id="id197" class="indexterm"/>no parameters, and variable assignment as a call with the new value as a parameter.</p><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>You can use a <code class="literal">PropertyMock</code> object if you actually need to record variable accesses in your mock object history. Usually you don't need to do that, but the option exists.</p></div></div><p>Even though you set a <a id="id198" class="indexterm"/>property by assigning it to an attribute of a type, you <a id="id199" class="indexterm"/>don't have to worry about having your <code class="literal">PropertyMock</code> objects bleed over into other tests. Each <code class="literal">Mock</code> you create has its own type object, even though they all claim to be of the same class:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; type(Mock()) is type(Mock())</strong>
<strong>False</strong></pre></div><p>Thanks to this feature, any changes that you make to a mock object's type object are unique to that specific mock object.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Mocking file objects</h2></div></div></div><p>It's likely that <a id="id200" class="indexterm"/>you'll occasionally need to replace a file object with a mock object. The <code class="literal">unittest.mock</code> library helps you with this by providing <code class="literal">mock_open</code>, which is a factory for fake open functions. These functions have the same interface as the <a id="id201" class="indexterm"/>real open function, but they return a mock object that's been configured to pretend that it's an open file object.</p><p>This sounds more complicated than it is. See for yourself:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; from unittest.mock import mock_open</strong>
<strong>&gt;&gt;&gt; open = mock_open(read_data = 'moose')</strong>
<strong>&gt;&gt;&gt; with open('/fake/file/path.txt', 'r') as f:</strong>
<strong>...   print(f.read())</strong>
<strong>...</strong>
<strong>moose</strong></pre></div><p>If you pass a string value to the <code class="literal">read_data</code> parameter, the mock file object that eventually gets created will use that value as the data source when its read methods get called. As of Python 3.4.0, <code class="literal">read_data</code> only supports string objects, not bytes.</p><p>If you don't pass <code class="literal">read_data</code>, <code class="literal">read</code> method calls will return an empty string.</p><p>The problem with the previous code is that it makes the real open function inaccessible, and leaves a mock object lying around where other tests might stumble over it. Read on to see how to fix these problems.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Replacing real code with mock objects</h2></div></div></div><p>The <a id="id202" class="indexterm"/>
<code class="literal">unittest.mock</code> library gives a very nice tool for temporarily replacing objects with mock objects, and then undoing the change when our test is done. This tool is <code class="literal">unittest.mock.patch</code>.</p><p>There are a lot of different ways in which that patch can be used: it works as a context manager, a function decorator, and a class decorator; additionally, it can create a mock object to use for the replacement or it can use the replacement object that you specify. There are a number of other optional parameters that can further adjust the behavior of the patch.</p><p>Basic usage is easy:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; from unittest.mock import patch, mock_open</strong>
<strong>&gt;&gt;&gt; with patch('builtins.open', mock_open(read_data = 'moose')) as mock:</strong>
<strong>...    with open('/fake/file.txt', 'r') as f:</strong>
<strong>...       print(f.read())</strong>
<strong>...</strong>
<strong>moose</strong>
<strong>&gt;&gt;&gt; open</strong>
<strong>&lt;built-in function open&gt;</strong></pre></div><p>As you can see, <code class="literal">patch</code> dropped the mock open function created by <code class="literal">mock_open</code> over the top of the real open function; then, when we left the context, it replaced the original for us automatically.</p><p>The first parameter of <code class="literal">patch</code> is the only one that is required. It is a string describing the absolute path to the object to be replaced. The path can have any number of package and subpackage names, but it must include the module name and the name of the object inside the module that is being replaced. If the path is incorrect, <code class="literal">patch</code> will raise an <code class="literal">ImportError</code>, <code class="literal">TypeError</code>, or <code class="literal">AttributeError</code>, depending on what exactly is wrong with the path.</p><p>If you don't <a id="id203" class="indexterm"/>want to worry about making a mock object to be the replacement, you can just leave that parameter off:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; import io</strong>
<strong>&gt;&gt;&gt; with patch('io.BytesIO'):</strong>
<strong>...    x = io.BytesIO(b'ascii data')</strong>
<strong>...    io.BytesIO.mock_calls</strong>
<strong>[call(b'ascii data')]</strong></pre></div><p>The <code class="literal">patch</code> function <a id="id204" class="indexterm"/>creates a new <code class="literal">MagicMock</code> for you if you don't tell it what to use for the replacement object. This usually works pretty well, but you can pass the new parameter (also the second parameter, as we used it in the first example of this section) to specify that the replacement should be a particular object; or you can pass the <code class="literal">new_callable</code> parameter to make patch use the value of that parameter to create the replacement object.</p><p>We can also force the patch to use <code class="literal">create_autospec</code> to make the replacement object, by passing <code class="literal">autospec=True</code>:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; with patch('io.BytesIO', autospec = True):</strong>
<strong>...    io.BytesIO.melvin</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 2, in &lt;module&gt;</strong>
<strong>  File "/usr/lib64/python3.4/unittest/mock.py", line 557, in __getattr__</strong>
<strong>    raise AttributeError("Mock object has no attribute %r" % name)</strong>
<strong>AttributeError: Mock object has no attribute 'melvin'</strong></pre></div><p>The <code class="literal">patch</code> function will normally refuse to replace an object that does not exist; however, if you pass it <code class="literal">create=True</code>, it will happily drop a mock object wherever you like. Naturally, this is not compatible with <code class="literal">autospec=True</code>.</p><p>The <code class="literal">patch</code> function covers the most common cases. There are a few related functions that handle less common but still useful cases.</p><p>The <code class="literal">patch.object</code> function does the same thing as <code class="literal">patch</code>, except that, instead of taking the path string, it accepts an object and an attribute name as its first two parameters. Sometimes this is more convenient than figuring out the path to an object. Many objects don't even have valid paths (for example, objects that exist only in a function local scope), although the need to patch them is rarer than you might think.</p><p>The <code class="literal">patch.dict</code> function temporarily drops one or more objects into a dictionary under specific keys. The first parameter is the target dictionary; the second is a dictionary from which to get the key and value pairs to put into the target. If you pass <code class="literal">clear=True</code>, the target will be emptied before the new values are inserted. Notice that <code class="literal">patch.dict</code> doesn't create the replacement values for you. You'll need to make your own mock objects, if you <a id="id205" class="indexterm"/>want them.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Mock objects in action</h1></div></div></div><p>That was a lot of <a id="id206" class="indexterm"/>theory interspersed with unrealistic examples. Let's take a look at what we've learned and apply it to the tests from the previous chapters for a more realistic view of how these tools can help us.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Better PID tests</h2></div></div></div><p>The PID tests <a id="id207" class="indexterm"/>suffered mostly from having to do a lot of extra work to patch and <a id="id208" class="indexterm"/>unpatch <code class="literal">time.time</code>, and had some difficulty breaking the dependence on the constructor.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec05"/>Patching time.time</h3></div></div></div><p>Using <code class="literal">patch</code>, we can <a id="id209" class="indexterm"/>remove a lot of the repetitiveness of dealing <a id="id210" class="indexterm"/>with <code class="literal">time.time</code>; this means that it's less likely that we'll make a mistake somewhere, and saves us from spending time on something that's kind of boring and annoying. All of the tests can benefit from similar changes:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; from unittest.mock import Mock, patch</strong>
<strong>&gt;&gt;&gt; with patch('time.time', Mock(side_effect = [1.0, 2.0, 3.0, 4.0, 5.0])):</strong>
<strong>...    import pid</strong>
<strong>...    controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,</strong>
<strong>...                         initial = 12)</strong>
<strong>...    assert controller.gains == (0.5, 0.5, 0.5)</strong>
<strong>...    assert controller.setpoint == [0.0]</strong>
<strong>...    assert controller.previous_time == 1.0</strong>
<strong>...    assert controller.previous_error == -12.0</strong>
<strong>...    assert controller.integrated_error == 0.0</strong></pre></div><p>Apart from using <code class="literal">patch</code> to handle <code class="literal">time.time</code>, this test has been changed. We can now use <code class="literal">assert</code> to check whether things are correct instead of having doctest compare the values directly. There's <a id="id211" class="indexterm"/>hardly any difference between the two <a id="id212" class="indexterm"/>approaches, except that we can place the <code class="literal">assert</code> statements inside the context managed by <code class="literal">patch</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec06"/>Decoupling from the constructor</h3></div></div></div><p>Using mock <a id="id213" class="indexterm"/>objects, we can finally separate the tests <a id="id214" class="indexterm"/>for the PID methods from the constructor, so that mistakes in the constructor cannot affect the outcome:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; with patch('time.time', Mock(side_effect = [2.0, 3.0, 4.0, 5.0])):</strong>
<strong>...    pid = imp.reload(pid)</strong>
<strong>...    mock = Mock()</strong>
<strong>...    mock.gains = (0.5, 0.5, 0.5)</strong>
<strong>...    mock.setpoint = [0.0]</strong>
<strong>...    mock.previous_time = 1.0</strong>
<strong>...    mock.previous_error = -12.0</strong>
<strong>...    mock.integrated_error = 0.0</strong>
<strong>...    assert pid.PID.calculate_response(mock, 6) == -3.0</strong>
<strong>...    assert pid.PID.calculate_response(mock, 3) == -4.5</strong>
<strong>...    assert pid.PID.calculate_response(mock, -1.5) == -0.75</strong>
<strong>...    assert pid.PID.calculate_response(mock, -2.25) == -1.125</strong></pre></div><p>What we've done here is set up a mock object with the proper attributes, and pass it into <code class="literal">calculate_response</code> as the self-parameter. We could do this because we didn't create a PID instance at all. Instead, we looked up the method's function inside the class and called it directly, allowing us to pass whatever we wanted as the self-parameter instead of having Python's automatic mechanisms handle it.</p><p>Never invoking the constructor means that we're immune to any errors it might contain, and guarantees that the <a id="id215" class="indexterm"/>object state is exactly what we expect here in <a id="id216" class="indexterm"/>our <code class="literal">calculate_response</code> test.</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Summary</h1></div></div></div><p>In this chapter, we've learned about a family of objects that specialize in impersonating other classes, objects, methods, and functions. We've seen how to configure these objects to handle corner cases where their default behavior isn't sufficient, and we've learned how to examine the activity logs that these mock objects keep, so that we can decide whether the objects are being used properly or not.</p><p>In the next chapter, we'll look at Python's <code class="literal">unittest</code> package, a more structured testing framework that is less useful for communicating with people than <code class="literal">doctest</code> is, but better able to handle the complexities of large-scale testing.</p></div></div>
</body></html>