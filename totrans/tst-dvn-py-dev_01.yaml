- en: Chapter 1. Getting Started with Test-Driven Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 测试驱动开发入门
- en: My first encounter with **Test-Driven Development** (**TDD**) was back in 2002\.
    At that time, it wasn't as mainstream as it is today, and I remember watching
    two developers writing some tests first and then implementing the functionality
    later. I thought it to be quite a strange way to write a code, and I promptly
    forgot about it. It was not until 2004, when I was involved with a challenging
    project, that I remembered TDD again. We were faced with a messy code that was
    difficult to test and every change seemed to create a series of new bugs. I thought,
    why not give TDD a shot and see how it worked? Suffice to say, TDD changed my
    outlook on software development. We stopped writing messy spaghetti code, and
    started writing better designed, more maintainable code. Regression failures dropped
    drastically. I was hooked.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我第一次接触**测试驱动开发**（**TDD**）是在2002年。当时，它还没有像现在这样普及，我记得看到两位开发者先编写了一些测试，然后才实现功能。我觉得这是一种相当奇怪的写代码方式，并且很快就忘记了它。直到2004年，当我参与一个具有挑战性的项目时，我才再次想起了TDD。我们面临的是一团糟的代码，难以测试，每次更改似乎都会产生一系列新的错误。我想，为什么不试试TDD看看它效果如何呢？
    suffice to say，TDD改变了我对软件开发的观点。我们停止了编写混乱的意大利面代码，开始编写设计更好、更易于维护的代码。回归失败率大幅下降。我上瘾了。
- en: Perhaps, like me, you face some challenges in a project and want to see how
    TDD can help you. Or, maybe you've heard a lot of people in the industry sing
    the praises of TDD and you're wondering what all the fuss is about. Maybe you've
    been reading about how TDD will be an essential skill in the near future, and
    want to get up to speed on it. No matter what your motivation, I hope this book
    will help you reach your goal.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，就像我一样，你在项目中遇到了一些挑战，并想知道TDD如何帮助你。或者，也许你听到业界很多人对TDD大加赞扬，你想知道这一切究竟是怎么回事。也许你一直在阅读关于TDD将在不久的将来成为一项必备技能的文章，并想尽快掌握它。无论你的动机是什么，我希望这本书能帮助你实现目标。
- en: TDD is a lot more than just a library or an API; it is a different way of developing
    software. In this book, we'll discuss how to apply this process to writing Python
    software. We're in luck, because Python has fantastic support for TDD right out
    of the box. In fact, unit testing has been an integral part of the Python standard
    library from the Python 2.1 release back in April 2001\. Numerous improvements
    have been added since then, and the latest version that ships with Python 3.4
    has a ton of exciting features that we'll explore over the course of this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: TDD不仅仅是一个库或API；它是一种不同的软件开发方式。在本书中，我们将讨论如何将这个过程应用于编写Python软件。我们很幸运，因为Python从一开始就提供了对TDD的出色支持。事实上，单元测试自2001年4月Python
    2.1版本发布以来一直是Python标准库的组成部分。自那时以来，已经添加了许多改进，Python 3.4版本中包含的最新版本拥有许多令人兴奋的功能，我们将在本书的整个过程中探讨这些功能。
- en: Prerequisites
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前提条件
- en: We will be using Python 3.4 in this book. Most of the techniques will work on
    Python 2.6+ as well, but some small changes may be required to the examples presented
    in this book in order to make them run. The [Appendix B](apb.html "Appendix B. Working
    with Older Python Versions"), *Working with Older Python Versions* lists these
    changes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将使用Python 3.4。大多数技术同样适用于Python 2.6+，但可能需要对本书中提供的示例进行一些小的修改，以便它们能够运行。[附录B](apb.html
    "附录 B. 使用较旧的Python版本")，*使用较旧的Python版本*列出了这些修改。
- en: This book assumes that the reader has an intermediate level of Python understanding.
    In this book, we will be using Python language features such as lambdas, decorators,
    generators, and properties, and we assume that the reader is familiar with them.
    While we will give a brief description of these features as we encounter them,
    this book will not go into a lot of details about how they work, choosing instead
    to focus on how to test such code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设读者具备中级Python理解能力。在本书中，我们将使用Python语言特性，如lambda表达式、装饰器、生成器和属性，并假设读者熟悉它们。虽然我们将在遇到这些特性时简要描述它们，但本书不会深入探讨它们的工作原理，而是选择专注于如何测试此类代码。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that if you have only Python 2.x installed on your system, then go to [http://python.org](http://python.org)
    and download the latest release in the Python 3.4 series. For Linux users, if
    Python 3.4 is not installed on your system, then check your distribution's package
    repository to get the latest version. If no package exists, or you are using a
    non-standard or older version of a distribution, then you might have to compile
    it from source. The instructions to do so are available at [https://docs.python.org/devguide/setup.html](https://docs.python.org/devguide/setup.html).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你在你的系统上只安装了Python 2.x，那么请访问[http://python.org](http://python.org)并下载Python
    3.4系列的最新版本。对于Linux用户，如果你的系统上没有安装Python 3.4，那么请检查你的发行版的软件包仓库以获取最新版本。如果没有软件包存在，或者你使用的是非标准的或较旧的发行版，那么你可能需要从源代码编译它。有关如何操作的说明可在[https://docs.python.org/devguide/setup.html](https://docs.python.org/devguide/setup.html)找到。
- en: Since TDD is a hands-on coding activity, this book will use a lot of code snippets
    throughout. We recommend that you follow along by typing the code and running
    it yourself. It is much easier to understand the code and concepts when you can
    see it working (or not working) in front of you, rather than just reading through
    the code in this book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TDD是一种动手编码活动，本书将在整个过程中使用大量的代码片段。我们建议你通过输入代码并亲自运行它来跟随。当你能够看到代码（或没有工作）在你面前运行时，理解代码和概念要容易得多，而不是仅仅阅读本书中的代码。
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Getting the code**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有Packt Publishing书籍的账户中下载示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给你。
- en: All the code in this book can be found online at [https://github.com/siddhi/test_driven_python](https://github.com/siddhi/test_driven_python).
    You can select a specific branch of the repository to get the code for the start
    of this chapter, and work through this chapter from that starting point. You can
    also select a tag on the branch to get the code for the endpoint of this chapter,
    if you would prefer to jump to the end of the code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有代码都可以在[https://github.com/siddhi/test_driven_python](https://github.com/siddhi/test_driven_python)上找到。你可以选择存储库的特定分支来获取本章开始的代码，并从这个起点开始学习本章。你也可以选择分支上的标签来获取本章末尾的代码，如果你更喜欢跳到代码的末尾。
- en: Understanding test-driven development
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解测试驱动开发
- en: After all the hype in the previous paragraphs, you might be wondering what exactly
    test-driven development is all about, and whether it is some complex procedure
    that requires a lot of skill to implement. Actually, test-driven development is
    very simple. The flowchart below shows the three steps in the process.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几段的热潮之后，你可能想知道测试驱动开发究竟是什么，以及它是否是一种复杂的程序，需要很多技能来实现。实际上，测试驱动开发非常简单。下面的流程图显示了过程中的三个步骤。
- en: '![Understanding test-driven development](img/7924OS_01_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![理解测试驱动开发](img/7924OS_01_01.jpg)'
- en: Let's walk through the preceding flowchart in a little more detail.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地回顾一下前面的流程图。
- en: '**Red**: The first step is to write a small unit test case. As we have only
    written the test and haven''t written the implementation yet, this test will naturally
    fail.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红色**：第一步是编写一个小型单元测试用例。因为我们只编写了测试，还没有编写实现，所以这个测试自然会失败。'
- en: '**Green**: Next, we write the code that implements the desired functionality.
    At this point, we aren''t looking to create the best design or the most readable
    code. We just want something simple that will pass the test.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿色**：接下来，我们编写实现所需功能的代码。在这个阶段，我们并不是要创建最佳的设计或最易读的代码。我们只想得到一个简单的东西，它能通过测试。'
- en: '**Refactor**: Now that the test is passing, we go back and look at the code
    to see whether it can be improved. This may involve improving the design, or making
    it more readable or maintainable. We can use the tests written so far to ensure
    that we aren''t breaking anything during the refactoring step.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构**：现在测试通过了，我们回头看看代码，看看是否可以改进。这可能涉及改进设计，或使其更易读或更易于维护。我们可以使用迄今为止编写的测试来确保我们在重构步骤中没有破坏任何东西。'
- en: The cycle repeats as we proceed to the next test and implement the next bit
    of functionality.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们进行下一个测试并实现下一个功能片段时，这个循环会重复进行。
- en: Developers who are familiar with TDD usually go through this cycle many times
    an hour, implementing small steps of functionality each time.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉TDD的开发者通常每小时会经历多次这个循环，每次实现功能的小步骤。
- en: TDD versus unit testing versus integration testing
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDD与单元测试与集成测试的比较
- en: Before we go further, let's take a short detour to define some terms and understand
    the differences between them. It is very easy to get confused between these terms,
    and they are often used with different meanings in different places.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，让我们短暂地偏离一下，定义一些术语并了解它们之间的区别。很容易在这些术语之间感到困惑，它们在不同的地方经常被赋予不同的含义。
- en: In the broadest sense of the term, **unit testing** simply means testing a single
    unit of code, isolated from other code that it might be integrated with. Traditionally,
    unit testing was an activity that was primarily performed by test engineers. These
    engineers would take code given by the developers and run them through a suite
    of tests to verify that the code worked. Since this code was tested before integration,
    the process fits into the definition of a unit test. Traditional unit testing
    was typically a manual affair, with test engineers walking through the tests cases
    by hand, although some teams would go a step further and automate the tests.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个术语的最广泛意义上，**单元测试**简单地说就是测试单个代码单元，将其与其他可能与之集成的代码隔离开。传统上，单元测试是主要由测试工程师执行的活动。这些工程师会接受开发者给出的代码，并通过一系列测试来验证代码是否工作。由于此代码在集成之前进行了测试，这个过程符合单元测试的定义。传统的单元测试通常是一项手动工作，测试工程师手动执行测试用例，尽管一些团队会更进一步，自动化测试。
- en: An **integration test** is a test that involves exercising more than one unit
    of the system. The goal is to check whether these units have been integrated correctly.
    A typical integration test might be to go to a web page, fill in a form, and check
    whether the right message is displayed on the screen. In order for this test to
    pass, the UI must show the form correctly, the input must be captured correctly,
    and that input must be passed on to any logic processing. The steps might involve
    reading and writing from a database before a message is generated and the UI has
    to display it correctly. Only if all these interactions succeed will the integration
    test pass. If any one step should fail, the integration test will fail.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**是涉及系统多个单元的测试。目标是检查这些单元是否已正确集成。一个典型的集成测试可能是访问一个网页，填写一个表单，并检查屏幕上是否显示了正确的消息。为了使这个测试通过，UI必须正确显示表单，输入必须被正确捕获，并且该输入必须传递给任何逻辑处理。这些步骤可能涉及在生成消息和UI正确显示之前从数据库中读取和写入。只有当所有这些交互都成功时，集成测试才会通过。如果任何一步失败，集成测试将失败。'
- en: At this point, a valid question would be to ask why we need unit testing at
    all. Why not write only integration tests, where a single test could check so
    many parts of the application at once? The reason is that integration tests do
    not pinpoint the location of failure. A failing integration test could have an
    error in the UI, or in the logic, or somewhere in the way data is read or written.
    It will take a lot of investigation to see where the error is and fix it. By contrast,
    with well-written unit tests, a failing unit test will pinpoint exactly what is
    failing. Developers can go right to the point and fix the error.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一个合理的问题可能是询问我们为什么需要单元测试。为什么不只写集成测试，一个测试就能一次性检查应用中的许多部分呢？原因是集成测试无法精确指出失败的位置。一个失败的集成测试可能存在UI、逻辑或数据读取或写入过程中的错误。需要大量调查才能找到错误并修复它。相比之下，良好的单元测试会在失败时精确指出是什么出了问题。开发者可以直接找到问题所在并修复错误。
- en: Along the way, teams started moving to a process where developers themselves
    wrote tests for the code that they had implemented. These tests would be written
    after the developer had finished the implementation, and helped verify that the
    code worked as expected. These tests were usually automated. Such a process is
    generally called **developer testing** or **developer unit testing**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，团队开始转向一个过程，即开发者自己为他们所实现的功能编写测试。这些测试会在开发者完成实现后编写，并有助于验证代码是否按预期工作。这些测试通常是自动化的。这样的过程通常被称为**开发者测试**或**开发者单元测试**。
- en: TDD takes developer tests one step further, by writing the test before starting
    the implementation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: TDD通过在开始实现之前编写测试，将开发者测试推进了一步。
- en: '**Developer tests**: Any kind of automated unit tests written by the developer,
    either before or after functionality is implemented.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者测试**：开发者编写的任何类型的自动化单元测试，无论是功能实现之前还是之后。'
- en: '**Unit testing**: Any kind of testing of a particular unit of an application,
    either by a developer or a tester. These tests might be automated, or run manually.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：由开发者或测试人员对应用程序的特定单元进行的任何类型的测试。这些测试可能是自动化的，也可以手动运行。'
- en: '**Integration testing**: Any kind of testing that involves two or more units
    working together. These tests are typically performed by a tester, but they could
    be done by a developer as well. These tests might be manual or automated.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：涉及两个或更多单元一起工作的任何类型的测试。这些测试通常由测试人员执行，但也可以由开发人员执行。这些测试可能是手动或自动的。'
- en: As we can see, unit testing is a general term, whereas developer testing is
    a specific subset of unit testing, and TDD is a specific form of developer testing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，单元测试是一个通用术语，而开发者测试是单元测试的一个特定子集，TDD是开发者测试的一种特定形式。
- en: On the surface, traditional unit testing, developer testing and TDD look similar.
    They all appear to be about writing tests for a single unit of code, with only
    minor variations based on who writes the test and whether the tests are written
    before the code or after.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，传统的单元测试、开发者测试和TDD看起来很相似。它们似乎都是关于为单个代码单元编写测试，只有基于谁编写测试以及测试是在代码编写之前还是之后编写的细微差别。
- en: However, dig deeper and differences appear. First, the intent is vastly different.
    Traditional unit testing and developer testing are all about writing tests to
    verify that the code works as it is supposed to. On the other hand, the main focus
    of TDD is not really about testing. The simple act of writing a test before the
    implementation changes the way we think when we implement the corresponding functionality.
    The resulting code is more testable, usually has a simple and elegant design,
    and is more maintainable and readable. This is because making a class easy to
    test also encourages good design practices, such as decoupling dependencies and
    writing small, modular classes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，深入挖掘，差异就出现了。首先，意图大不相同。传统的单元测试和开发者测试都是关于编写测试来验证代码是否按预期工作。另一方面，TDD的主要焦点实际上并不是测试。在实现相应功能之前简单地编写一个测试，就改变了我们实现功能时的思维方式。生成的代码更易于测试，通常具有简单优雅的设计，并且更易于维护和阅读。这是因为使类易于测试也鼓励良好的设计实践，例如解耦依赖关系和编写小型、模块化的类。
- en: Thus, one can say that TDD is all about writing better code, and it is just
    a happy side effect that we end up with a fully automated test suite as an outcome.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以说TDD完全是关于编写更好的代码，而最终得到一个完全自动化的测试套件只是一个愉快的副作用。
- en: This difference in intent manifests itself in the type of tests. Developer testing
    usually results in large test cases, with a hefty part of the test code involved
    in test setup. By contrast, tests written using TDD are very small and numerous.
    Some people like to call them micro tests to differentiate them from other developer
    tests or traditional unit tests. TDD-style unit tests also try to be very fast
    to run because they are executed every few minutes during the development process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种意图上的差异在测试类型上表现出来。开发者测试通常会产生大型测试用例，其中相当一部分测试代码涉及测试设置。相比之下，使用TDD编写的测试非常小且数量众多。有些人喜欢称它们为微测试，以区分它们与其他开发者测试或传统单元测试。TDD风格的单元测试还试图非常快地运行，因为它们在开发过程中每隔几分钟就会执行一次。
- en: Finally, the tests that are written in TDD are those that drive the development
    forward, and not necessarily those that cover all imaginable scenarios. For example,
    a function that is supposed to process a file might have tests to handle cases
    when the file exists or it doesn't exist, but probably won't have tests to see
    what happens if the file is 1 terabyte in size. The latter is something that a
    tester might conceivably test for, but would be an unusual test in TDD unless
    the function is clearly expected to work with such a file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，TDD（测试驱动开发）中编写的测试是推动开发前进的测试，而不一定是覆盖所有可想象场景的测试。例如，一个本应处理文件的函数可能会有处理文件存在或不存在的情况的测试，但可能不会有测试来查看如果文件大小为1TB会发生什么。后者可能是测试人员可能会测试的情况，但在TDD中除非函数明显预期可以处理这样的文件，否则这种测试是不寻常的。
- en: This really highlights the difference between TDD and other forms of unit testing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这真正突出了TDD与其他单元测试形式之间的区别。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: TDD is about writing better, cleaner, more maintainable code, and only incidentally
    about testing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是关于编写更好、更干净、更易于维护的代码，而不仅仅是关于测试。
- en: Using TDD to build a stock alert application
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TDD构建股票警报应用程序
- en: Over the course of this book, we are going to be using TDD to build a simple
    stock alert application. The application will listen to stock updates from a source.
    The source can be anything—a server on the Internet, or a file on the hard drive,
    or something else. We will be able to define rules, and when the rule is matched,
    the application sends us an email or text message.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将使用TDD构建一个简单的股票警报应用程序。该应用程序将监听来自来源的股票更新。来源可以是任何东西——互联网上的服务器，硬盘上的文件，或其他东西。我们将能够定义规则，当规则匹配时，应用程序会发送给我们电子邮件或短信。
- en: For example, we could define a rule as "If AAPL crosses the $550 level then
    send me an email". Once defined, the application will monitor updates and send
    an e-mail when the rule is matched.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义一条规则为“如果AAPL股价突破550美元，则发送给我一封电子邮件”。一旦定义，应用程序将监控更新，并在规则匹配时发送电子邮件。
- en: Writing our first test
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们的第一个测试
- en: 'Enough talk. Let''s get started with our application. What is a good place
    to start? From examining the application description mentioned earlier, it looks
    like we will need the following modules:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 谈话已经足够。让我们开始我们的应用程序。从检查之前提到的应用程序描述来看，我们似乎需要以下模块：
- en: Some way to read stock price updates, either from the Internet or from a file
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种读取股票价格更新的方法，无论是从互联网还是从文件中
- en: A way to manage the stock information so that we can process it
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理股票信息以便我们可以处理的方法
- en: A way to define rules and match them against the current stock information
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义规则并匹配当前股票信息的方法
- en: A way to send an email or text message when a rule is matched
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当规则匹配时发送电子邮件或短信的方法
- en: 'Based on these requirements, we will be using the following design:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些要求，我们将使用以下设计：
- en: '![Writing our first test](img/7924OS_01_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![编写我们的第一个测试](img/7924OS_01_02.jpg)'
- en: 'Each term is discussed as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个术语如下讨论：
- en: '**Alert**: This is the core of the application. An alert will take a **Rule**
    and map it to an **Action**. When the rule is matched, the action is executed.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警报**：这是应用程序的核心。警报将一个**规则**映射到一个**动作**。当规则匹配时，执行该动作。'
- en: '**Rule**: A **Rule** contains the condition we want to check for. We should
    get alerted when the rule is matched.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则**：一个**规则**包含我们想要检查的条件。当规则匹配时，我们应该收到警报。'
- en: '**Action**: This is the action to be performed when the rule is matched. This
    could be as simple as printing a message on the screen, or, in more real-work
    scenarios, we might send an e-mail or a text message.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作**：这是规则匹配时要执行的动作。这可能只是简单地打印屏幕上的消息，或者在更实际的工作场景中，我们可能会发送电子邮件或短信。'
- en: '**Stock**: The **Stock** class keeps track of the current price and possibly
    a history of the prices for a stock. It sends an **Event** to the **Alert** when
    there is an update. The alert then checks if it''s rule matched and whether any
    action needs to be executed.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**股票**：**股票**类跟踪股票的当前价格以及可能的价格历史。当有更新时，它会向**警报**发送一个**事件**。然后警报检查是否匹配规则以及是否需要执行任何动作。'
- en: '**Event**: This class is used to send events to the **Alert** when a **Stock**
    is updated.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：当**股票**更新时，此类用于向**警报**发送事件。'
- en: '**Processor**: The processor takes stock updates from the **Reader** and updates
    the **Stock** with the latest data. Updating the stock causes the event to be
    fired, which, in turn, causes the alert to check for a rule match.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器**：处理器从**读者**那里获取股票更新，并使用最新数据更新**股票**。更新股票会导致事件触发，进而导致警报检查规则匹配。'
- en: '**Reader**: The **Reader** gets the stock alerts from some source. In this
    book, we are going to get updates from a simple list or a file, but you can build
    other readers to get updates from the Internet or elsewhere.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读者**：**读者**从某个来源获取股票警报。在这本书中，我们将从简单的列表或文件中获取更新，但你也可以构建其他读者以从互联网或其他地方获取更新。'
- en: Among all these classes, the way to manage stock information seems to be the
    simplest, so let's start there. What we are going to do is to create a `Stock`
    class. This class will hold information about the current stock. It will store
    the current price and possibly some recent price history. We can then use this
    class when we want to match rules later on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些类中，管理股票信息的方式似乎是最简单的，所以让我们从这里开始。我们要做的是创建一个 `Stock` 类。这个类将保存当前股票的信息。它将存储当前价格和可能的一些最近价格历史。当我们想要匹配规则时，我们可以使用这个类。
- en: To get started, create a directory called `src`. This directory is going to
    hold all our source code. In the rest of this book, we will refer to this directory
    as the project root. Inside the `src` directory, create a subdirectory called
    `stock_alerter`. This is the directory in which we are going to implement our
    stock alert module.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，创建一个名为 `src` 的目录。这个目录将保存我们所有的源代码。在这本书的其余部分，我们将把这个目录称为项目根目录。在 `src` 目录内，创建一个名为
    `stock_alerter` 的子目录。这是我们将要实现股票警报模块的目录。
- en: Okay, let's get started with implementing the class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始实现这个类。
- en: NO! Wait! Remember the TDD process that was described earlier? The first step
    is to write a test, before we code the implementation. By writing the test first,
    we now have the opportunity to think about what we want this class to do.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 不！等等！记得之前描述的 TDD 流程吗？第一步是编写测试，在我们编写实现代码之前。通过先编写测试，我们现在有机会思考我们想让这个类做什么。
- en: 'So what exactly do we want this class to do? Let''s start with something simple:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们到底想让这个类做什么呢？让我们从一个简单的事情开始：
- en: A `Stock` class should be instantiated with the ticker symbol
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stock` 类应该用股票代码进行实例化'
- en: Once instantiated, and before any updates, the price should be `None`
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦实例化，并且在任何更新之前，价格应该是 `None`
- en: Of course, there are many more things we will want this class to do, but we'll
    think about them later. Rather than coming up with a very comprehensive list of
    functionality, we're going to focus on tiny bits of functionality, one at a time.
    For now, the preceding expectation is good enough.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还想让这个类做更多的事情，但我们会稍后再考虑。我们不会提出一个非常全面的特性列表，而是会一次关注一小块功能。现在，前面的期望已经足够了。
- en: 'To convert the preceding expectation into code, create a file called `stock.py`
    in the project root, and put the following code in it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要将前面的期望转换为代码，在项目根目录下创建一个名为 `stock.py` 的文件，并将以下代码放入其中：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What does this code do?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做了什么？
- en: First, we import `unittest`. This is the library that has the test framework
    that we are going to use. Luckily for us, it is bundled into the Python standard
    library by default and is always available, so we don't need to install anything,
    we can just import the module directly.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入 `unittest`。这是我们将要使用的测试框架所在的库。幸运的是，它默认包含在 Python 标准库中，总是可用，所以我们不需要安装任何东西，可以直接导入模块。
- en: Second, we create a class `StockTest`. This class will hold all the test cases
    for the `Stock` class. This is just a convenient way of grouping related tests
    together. There is no rule that every class should have a corresponding test class.
    Sometimes, if we have a lot of tests for a class, then we may want to create separate
    test classes for each individual behavior, or group the tests some other way.
    However, in most cases, creating one test class for an actual class is the best
    way to go about it.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二，我们创建一个名为 `StockTest` 的类。这个类将包含 `Stock` 类的所有测试用例。这只是将相关的测试分组在一起的一种方便方式。没有规定每个类都应该有一个对应的测试类。有时，如果我们对一个类有很多测试，那么我们可能想为每个单独的行为创建单独的测试类，或者以其他方式分组测试。然而，在大多数情况下，为实际类创建一个测试类是最佳做法。
- en: Our `StockTest` class inherits from the `TestCase` class in the `unittest` module.
    All tests need to inherit from this class in order to be identified as a test
    class.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `StockTest` 类继承自 `unittest` 模块中的 `TestCase` 类。所有测试都需要继承这个类，以便被识别为测试类。
- en: Inside the class, we have one method. This method is a test case. The `unittest`
    framework will pick up any method that starts with `test`. The method has a name
    that describes what the test is checking for. This is just so that when we come
    back after a few months, we still remember what the test does.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在课堂上，我们有一个方法。这个方法是一个测试用例。`unittest` 框架会选取任何以 `test` 开头的方法。这个方法的名字描述了测试要检查的内容。这样，当我们几个月后回来时，我们仍然记得测试做了什么。
- en: The test creates a `Stock` object and then checks if the price is `None`. `assertIsNone`
    is a method provided by the `TestCase` class that we are inheriting from. It checks
    that its parameter is `None`. If the parameter is not `None`, it raises an `AssertionError`
    and fails the test. Otherwise, execution continues to the next line. Since that
    is the last line of the method, the test completes and is marked as a pass.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试创建了一个 `Stock` 对象，然后检查价格是否为 `None`。`assertIsNone` 是我们从它继承的 `TestCase` 类提供的一个方法。它检查其参数是否为
    `None`。如果参数不是 `None`，它将引发一个 `AssertionError` 并使测试失败。否则，执行将继续到下一行。由于那是方法的最后一行，测试完成并标记为通过。
- en: The last segment checks if the module was executed directly from the command
    line. In such a case, the `__name__` variable will have the value `__main__`,
    and the code will execute the `unittest.main()` function. This function will scan
    the current file for all tests and execute them. The reason we need to wrap this
    function call inside the conditional is because this part does not get executed
    if the module is imported into another file.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一段检查模块是否直接从命令行执行。在这种情况下，`__name__` 变量将具有 `__main__` 的值，并且代码将执行 `unittest.main()`
    函数。此函数将扫描当前文件中的所有测试并执行它们。我们需要在条件中包装此函数调用的原因是因为如果模块被导入到另一个文件中，这部分将不会执行。
- en: Congratulations! You have your first failing test. Normally, a failing test
    would be a cause for worry, but in this case, a failing test means that we're
    done with the first step of the process and can move on to the next step.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了第一个失败的测试。通常，一个失败的测试会是一个令人担忧的原因，但在这个情况下，一个失败的测试意味着我们已经完成了过程的第一个步骤，可以继续到下一个步骤。
- en: Analyzing the test output
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析测试输出
- en: 'Now that we''ve written our test, it is time to run it. To run the test, just
    execute the file. Assuming that the current directory is the `src` directory,
    the following is the command to execute the file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了测试，是时候运行它了。要运行测试，只需执行文件。假设当前目录是 `src` 目录，以下是要执行文件的命令：
- en: 'Windows:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows：
- en: '[PRE1]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Linux/Mac:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux/Mac：
- en: '[PRE2]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the python executable is not on your path, then you will have to give the
    full path to the executable here. In some Linux distributions, the file may be
    called `python34` or `python3.4` instead of `python3`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Python 可执行文件不在你的路径上，那么你将必须在这里给出完整的可执行文件路径。在某些 Linux 发行版中，文件可能被称为 `python34`
    或 `python3.4` 而不是 `python3`。
- en: 'When we run the file, the output looks like the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行文件时，输出看起来如下所示：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As expected, the test fails, because we haven't created the `Stock` class yet.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，测试失败了，因为我们还没有创建 `Stock` 类。
- en: 'Let''s look at that output in a little more detail:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看那个输出：
- en: '`E` on the first line signifies that the test gave an error. If a test passed,
    then you would have a dot on that line. A failed test would be marked with `F`.
    Since we have only a single test, there is only one character there. When we have
    multiple tests, then the status of each test will be displayed on that line, one
    character per test.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行上的 `E` 表示测试产生了错误。如果测试通过了，那么你会在那一行看到一个点。一个失败的测试将被标记为 `F`。由于我们只有一个测试，所以那里只有一个字符。当我们有多个测试时，每个测试的状态将显示在同一行上，每个测试一个字符。
- en: After all the test statuses are displayed, we get a more detailed explanation
    of any test errors and failures. It tells us whether there was a failure or an
    error (in this case denoted by `ERROR`) followed by the name of the test and which
    class it belongs to. This is followed by a traceback, so we know where the failure
    occurred.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在显示所有测试状态之后，我们将获得任何测试错误和失败的更详细说明。它告诉我们是否有失败或错误（在这种情况下用 `ERROR` 表示），以及测试的名称和它所属的类。随后是一个跟踪回溯，这样我们知道失败发生在哪里。
- en: Finally, there is a summary that shows how many tests were executed, how many
    passed or failed, and how many gave errors.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，有一个总结显示了执行了多少个测试，有多少通过了或失败了，以及有多少产生了错误。
- en: Test errors versus test failures
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试错误与测试失败
- en: 'There are two reasons why a test might not pass: It might have failed or it
    might have caused an error. There is a small difference between these two. A **failure**
    indicates that we expected some outcome (usually via an assert), but got something
    else. For example, in our test, we are asserting that `stock.price` is `None`.
    Suppose `stock.price` has some other value apart from `None`, then the test will
    fail.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可能不通过有两个原因：它可能失败了，或者它可能引发了错误。这两个之间有一个小的区别。**失败**表示我们期望某种结果（通常通过断言），但得到了其他东西。例如，在我们的测试中，我们断言
    `stock.price` 是 `None`。假设 `stock.price` 除了 `None` 之外还有其他值，那么测试将失败。
- en: An error indicates that something unexpected happened, usually an unexpected
    exception was raised. In our previous example, we got an error because the `Stock`
    class has not yet been defined.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 错误表明发生了意外情况，通常是一个意外的异常被抛出。在我们之前的例子中，我们得到一个错误是因为`Stock`类尚未定义。
- en: In both the cases, the test does not pass, but for different reasons, and these
    are reported separately as test failures and test errors.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，测试都没有通过，但原因不同，这些原因分别作为测试失败和测试错误单独报告。
- en: Making the test pass
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使测试通过
- en: 'Now that we have a failing test, let''s make it pass. Add the following code
    to the `stock.py` file, after the `import unittest` line:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个失败的测试，让我们让它通过。在`stock.py`文件中`import unittest`行之后添加以下代码：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What we have done here is to implement just enough code to pass the test. We've
    created the `Stock` class so the test shouldn't complain about it being missing,
    and we've initialized the `price` attribute to `None`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是实现足够的代码以通过测试。我们创建了`Stock`类，这样测试就不会因为缺少它而抱怨，并且我们将`price`属性初始化为`None`。
- en: What about the rest of the implementation for this class? This can wait. Our
    main focus right now is to pass the current expectation for this class. As we
    write more tests, we will end up implementing more of the class as well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个类的其余实现呢？这可以稍后处理。我们现在的重点是让这个类的当前期望通过。随着我们编写更多的测试，我们最终也会实现这个类的更多部分。
- en: 'Run the file again, and this time the output should be like the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行文件，这次输出应该如下所示：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We've got a dot in the first line, which signifies that the test is passing.
    The `OK` message at the end tells us that all tests have passed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行有一个点，这表示测试正在通过。最后的`OK`消息告诉我们所有测试都已通过。
- en: The final step is to refactor the code. With so little code, there is really
    nothing much to clean up. So, we can skip the refactoring step and start with
    the next test.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是对代码进行重构。由于代码量很少，实际上没有什么可以清理的。因此，我们可以跳过重构步骤，直接开始下一个测试。
- en: Reorganizing the test code
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新组织测试代码
- en: We've added the test cases in the same file as the code. This is a good, simple
    way to add test cases to standalone scripts and applications that are not too
    complex. However, for larger applications, it is a good idea to keep test code
    separate from production code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在同一个文件中添加了测试用例，这是为独立脚本和不太复杂的应用程序添加测试用例的一个好方法。然而，对于更大的应用程序，将测试代码与生产代码分开是一个好主意。
- en: There are two common patterns for organizing test code this way.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 组织测试代码的这种模式有两种常见模式。
- en: 'The first pattern is to keep test code in a separate root directory, as shown
    in the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种模式是将测试代码保存在一个单独的根目录中，如下所示：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The other pattern is to keep test code as a submodule of the main code, as
    shown in the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种模式是将测试代码作为主代码的一个子模块，如下所示：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first pattern is commonly used for standalone modules as it allows us to
    distribute the code and tests together. Tests can generally be run without having
    to perform a lot of setup or configuration. The second pattern has an advantage
    when the application has to be packaged without the test code, for example when
    deploying to production servers, or distributing to customers (in the case of
    a commercial application). However, both the patterns are in popular use, and
    it is mainly a personal preference as to which method to use.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种模式通常用于独立模块，因为它允许我们将代码和测试一起分发。测试通常可以在不进行大量设置或配置的情况下运行。第二种模式在应用程序需要打包而不包含测试代码时具有优势，例如在部署到生产服务器或向客户（在商业应用程序的情况下）分发时。然而，这两种模式都很受欢迎，主要取决于个人偏好，选择哪种方法。
- en: We are going to follow the first pattern in this book. To get started, create
    a directory called `tests` inside the `stock_alerter` directory. Next, create
    a file called `test_stock.py` in this directory. We will put all our test cases
    in one-to-one correspondence with the source file. This means, a file called `sample.py`
    will have its test cases in the `tests/test_sample.py` file. This is a simple
    naming convention that helps to quickly locate test cases.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中遵循第一种模式。要开始，在`stock_alerter`目录中创建一个名为`tests`的目录。接下来，在这个目录中创建一个名为`test_stock.py`的文件。我们将把所有的测试用例与源文件一一对应。这意味着，一个名为`sample.py`的文件将在`tests/test_sample.py`文件中有其测试用例。这是一个简单的命名约定，有助于快速定位测试用例。
- en: 'Finally, we move our test cases into this file. We also need to import the
    `Stock` class to be able to use it in the test case. Our `test_stock.py` file
    now looks like the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将我们的测试用例移动到这个文件中。我们还需要导入`Stock`类，以便在测试用例中使用它。我们的`test_stock.py`文件现在看起来如下：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Remember to remove the `import unittest` line from `stock.py`, now that it no
    longer contains the test code. Previously we had just one standalone script, but
    we now have a `stock_alerter` module and a `stock_alerter.tests` submodule. Since
    we are now working with modules, we should also add in an empty `__init__.py`
    file in both the `stock_alerter` and `tests` directories.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 记得从`stock.py`中删除`import unittest`行，因为它现在不再包含测试代码。之前我们只有一个独立的脚本，但现在我们有一个`stock_alerter`模块和一个`stock_alerter.tests`子模块。由于我们现在正在使用模块，我们还应该在`stock_alerter`和`tests`目录中添加一个空的`__init__.py`文件。
- en: 'Our file layout should now be like the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的文件布局应该如下所示：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Running the tests after the reorganization
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新组织后的测试运行
- en: If you have noticed, we no longer have a call to `unittest.main()` in the test
    code. Including a call to `unittest.main()` works well with individual scripts
    since it allows us to run the tests by simply executing the file. However, it
    is not a very scalable solution. If we have hundreds of files, we would like to
    run all the tests at once, and not have to execute each file individually.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经注意到，测试代码中不再有对`unittest.main()`的调用。在单个脚本中包含对`unittest.main()`的调用效果很好，因为它允许我们通过简单地执行文件来运行测试。然而，这不是一个可扩展的解决方案。如果我们有数百个文件，我们希望一次性运行所有测试，而不必逐个执行每个文件。
- en: 'To address this, Python 3 comes with a very nice test discovery and execution
    capability from the command line. Simply go into the `src` directory and run the
    following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Python 3 从命令行提供了非常出色的测试发现和执行能力。只需进入`src`目录并运行以下命令：
- en: 'Windows:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows：
- en: '[PRE10]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Linux/Mac:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux/Mac：
- en: '[PRE11]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This command will go through the current directory and all subdirectories and
    run all the tests that are found. This is the default autodiscover mode of execution,
    where the command searches all the files and runs the tests. Autodiscovery can
    also be explicitly run with the following command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将遍历当前目录及其所有子目录，并运行找到的所有测试。这是默认的自动发现执行模式，其中命令搜索所有文件并运行测试。自动发现也可以通过以下命令显式运行：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Autodiscover can be customized to check in specific directories or files with
    the following parameters:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下参数自定义自动发现，以检查特定目录或文件：
- en: '`-s start_directory`: Specify the start directory from where the discovery
    should start. This defaults to the current directory.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s start_directory`：指定发现应开始的起始目录。默认为当前目录。'
- en: '`-t top_directory`: Specify the top-level directory. This is the directory
    from which imports are performed. This is important if the start directory is
    inside the package and you get errors due to incorrect imports. This defaults
    to the start directory.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t top_directory`：指定顶级目录。这是从该目录执行导入的目录。如果起始目录位于包内并且由于导入错误而出现错误，则此选项很重要。默认为起始目录。'
- en: '`-p file_pattern`: The file pattern that identifies test files. By default
    it checks for python files that start with `test`. If we name our test files something
    else (for example, `stock_test.py`), then we have to pass in this parameter so
    that the file is correctly identified as a test file.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p file_pattern`：用于识别测试文件的文件模式。默认情况下，它检查以`test`开头的Python文件。如果我们给测试文件命名其他名称（例如，`stock_test.py`），那么我们必须传递此参数，以便正确地将文件识别为测试文件。'
- en: 'To illustrate the difference between the start and top directory, run the following
    command from the `src` directory:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明起始目录和顶级目录之间的区别，请从`src`目录运行以下命令：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding command will fail with an import error. The reason is because
    when the start directory is set to `stock_alerter`, then the `tests` directory
    is imported as a top-level module, and the relative import fails. To get around
    this, we need to use the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将因导入错误而失败。原因是当起始目录设置为`stock_alerter`时，`tests`目录被导入为顶级模块，相对导入失败。为了解决这个问题，我们需要使用以下命令：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This command will import all modules relative to the top directory, and so `stock_alerter`
    correctly becomes the main module.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将导入相对于顶级目录的所有模块，因此`stock_alerter`正确地成为主模块。
- en: 'You can also disable autodiscovery and specify only certain tests to be run:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以禁用自动发现，并仅指定要运行的某些测试：
- en: Passing in a module name will only run the tests within that module. For example,
    `python3 -m unittest stock_alerter.tests.test_stock` will run the tests only in
    `test_stock.py`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个模块名称将只运行该模块内的测试。例如，使用`python3 -m unittest stock_alerter.tests.test_stock`将只运行`test_stock.py`中的测试。
- en: You can further refine to a specific class or method, such as `python3 -m unittest
    stock_alerter.tests.test_stock.StockTest`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将范围进一步细化到特定的类或方法，例如使用`python3 -m unittest stock_alerter.tests.test_stock.StockTest`。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations! You've completed one cycle of TDD. As you can see, each cycle
    is very quick. Some cycles, like the one we've just gone through, can be completed
    in a few seconds. Other cycles might involve a fair amount of cleanup and can
    take quite a long time. Each cycle will implement a small test, a small bit of
    functionality to pass the test, and then some cleanup to make the code of high
    quality.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经完成了一个TDD的循环。如您所见，每个循环都非常快。有些循环，比如我们刚刚经历的，可以在几秒钟内完成。其他循环可能涉及相当多的清理工作，可能需要相当长的时间。每个循环都会实现一个小测试，一小部分功能以通过测试，然后进行一些清理以确保代码质量。
- en: In this chapter, we looked at what TDD is, how it is different from other forms
    of unit and integration testing, and wrote our first test.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了TDD是什么，它与其他形式的单元和集成测试有何不同，并编写了我们的第一个测试。
- en: At this point, our implementation is still very small and very simple. You might
    be wondering if it is worth all this hype just to write and implement four lines
    of very simple code. In the next few chapters, we'll progress further with the
    examples and go more in-depth into the process.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的实现仍然非常小且非常简单。您可能会想知道，为了编写和实现这四行非常简单的代码，所有的炒作是否都值得。在接下来的几章中，我们将通过示例进一步深入探讨过程。
