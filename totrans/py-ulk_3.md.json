["```py\n    >>> def foo(a,b):\n    ...   print(a,b)\n    ... \n    >>> foo(1,2)\n    1 2\n    ```", "```py\n    >>> def foo(a,b=3):\n    ...    print(a,b)\n    ... \n    >>> foo(3)  \n    3 3\n    >>> foo(3,4)\n    3 4\n    ```", "```py\n    >>> def  foo(a,*,b):\n    ...   print(a,b)\n    ... \n    >>> foo(2,3)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: foo() takes 1 positional argument but 2 were given\n    >>> foo(1,b=4)\n    1 4\n    ```", "```py\n    >>> def foo(a,*pa):\n    ...   print(a,pa)\n    ... \n    >>> foo(1)\n    1 ()\n    >>> foo(1,2)\n    1 (2,)\n    >>> foo(1,2,3)\n    1 (2, 3)\n    ```", "```py\n    >>> def foo(a,**kw):\n    ...   print(a,kw)\n    ... \n    >>> foo(2)     \n    2 {}\n    >>> foo(2,b=4)\n    2 {'b': 4}\n    >>> foo(2,b=4,v=5)\n    2 {'b': 4, 'v': 5}\n    ```", "```py\n    >>> def foo1(a,*args):\n    ...   print(a,args)\n    ... \n    >>> def foo2(a,):\n    ...   print(a)\n    ... \n    >>> foo1(1,2,3,4)\n    1 (2, 3, 4)\n    >>> foo2(1,2,3,4)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: foo2() takes 1 positional argument but 4 were given\n    ```", "```py\n    >>> def foo(a,b,c):\n    ...   print(a,b,c)\n    ... \n    >>> foo(1,c=3,b=2)\n    1 2 3\n    >>> foo(1,b=2)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: foo() missing 1 required positional argument: 'c'\n    ```", "```py\n    >>> def foo(a,b,*,c):           \n    ...   print(a,b,c)\n    ... \n    >>> foo(1,2,3)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: foo() takes 2 positional arguments but 3 were given\n    >>> foo(1,2,c=3)\n    1 2 3\n    >>> foo(c=3,b=2,a=1)\n    1 2 3\n    ```", "```py\n    >>> def foo(a,b,*args,c,**kwargs):\n    ...   print(a,b,args,c,kwargs)\n    ... \n    >>> foo(1,2,3,4,5,c=6,d=7,e=8)        \n    1 2 (3, 4, 5) 6 {'d': 7, 'e': 8}\n    ```", "```py\n    >>> def foo(a,b,c=2,*pa,d,e=5,**ka):\n    ...   print(a,b,c,d,e,pa,ka)\n    ... \n    >>> foo(1,2,d=4)\n    1 2 2 4 5 () {}\n    >>> foo(1,2,3,4,5,d=6,e=7,g=10,h=11)\n    1 2 3 6 7 (4, 5) {'h': 11, 'g': 10}\n    ```", "```py\n>>> def wrap(func):\n...     def newfunc(*args):\n...         print(\"newfunc\",args)\n...     return newfunc\n...\n>>> def realfunc(*args):\n...     print(\"real func\",args)\n...\n>>>\n>>> realfunc = wrap(realfunc)\n>>>\n>>> realfunc(1,2,4)\n('newfunc', (1, 2, 4))\n```", "```py\n>>> @wrap\n... def realfunc(args):\n...     print(\"real func\",args)\n...\n>>> realfunc(1,2,4)\n('newfunc', (1, 2, 4))\n```", "```py\n>>> def closure_deco(prefix):\n...     def deco(func):\n...         return lambda x:x+prefix\n...     return deco\n... \n>>> @closure_deco(2)\n... def add(a):\n...     return a+1\n... \n>>> add(2)\n4\n>>> add(3)\n5\n>>> @closure_deco(3)\n... def add(a):\n...     return a+1\n... \n>>> add(2)\n5\n>>> add(3)\n6\n```", "```py\n>>> class Deco:\n...     def __init__(self,addval):\n...         self.addval = addval\n...     def __call__(self, func):\n...         return lambda x:x+self.addval\n... \n>>> @Deco(2)\n... def add(a):\n...     return a+1\n... \n>>> add(1)\n3\n>>> add(2)\n4\n>>> @Deco(3)\n... def add(a):\n...     return a+1\n... \n>>> add(1)\n4\n>>> add(2)\n5\n```", "```py\n>>> class K:\n...     def do(*args):\n...         print(\"imethod\",args)\n...\n>>> k = K()\n>>> k.do(1,2,3)\n('imethod', (<__main__.K instance at 0x7f12ea070bd8>, 1, 2, 3))\n>>>\n>>> # using a decorator on methods give similar results\n...\n>>> class K:\n...     @wrap\n...     def do(*args):\n...         print(\"imethod\",args)\n...\n>>> k = K()\n>>> k.do(1,2,3)\n('newfunc', (<__main__.K instance at 0x7f12ea070b48>, 1, 2, 3))\n```", "```py\n>>> class K:\n...     @wrap\n...     @staticmethod\n...     def do(*args):\n...         print(\"imethod\",args)\n...     @wrap\n...     @classmethod\n...     def do2(*args):\n...         print(\"imethod\",args)\n...\n>>> k = K()\n>>> k.do(1,2,3)\n('newfunc', (<__main__.K instance at 0x7f12ea070cb0>, 1, 2, 3))\n>>> k.do2(1,2,3)\n('newfunc', (<__main__.K instance at 0x7f12ea070cb0>, 1, 2, 3))\n```", "```py\n>>> class K:\n...     @staticmethod\n...     @wrap\n...     def do(*args):\n...         print(\"imethod\",args)\n...     @classmethod\n...     @wrap\n...     def do2(*args):\n...         print(\"imethod\",args)\n...\n>>> k = K()\n>>> k.do(1,2,3)\n('newfunc', (1, 2, 3))\n>>> k.do2(1,2,3)\n('newfunc', (<class __main__.K at 0x7f12ea05e1f0>, 1, 2, 3))\n```", "```py\n>>> def cdeco(cls):\n...     print(\"cdecorator working\")\n...     class NCls:\n...         def do(*args):\n...             print(\"Ncls do\",args)\n...     return NCls\n...\n>>> @cdeco\n... class Cls:\n...     def do(*args):\n...         print(\"Cls do\",args)\n...\ncdecorator working\n>>> b = Cls()\n>>> c = Cls()\n>>> c.do(1,2,3)\n('Ncls do', (<__main__.NCls instance at 0x7f12ea070cf8>, 1, 2, 3))\n```", "```py\n>>> def cdeco(cls):\n...     if hasattr(cls,'do'):\n...         cls.do = wrap(cls.do)\n...     return cls\n...\n>>> @cdeco\n... class Cls:\n...     def do(*args):\n...         print(\"Cls do\",args)\n...\n>>> c = Cls()\n>>> c.do(1,2,3)\n('newfunc', (<__main__.Cls instance at 0x7f12ea070cb0>, 1, 2, 3))\n```", "```py\n>>> ll = [ i+1 for i in range(10)]\n>>> print(type(ll),ll)\n<class 'list'> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>> ld = { i:'val'+str(i) for i in range(10) }\n>>> print(type(ld),ld)\n<class 'dict'> {0: 'val0', 1: 'val1', 2: 'val2', 3: 'val3', 4: 'val4', 5: 'val5', 6: 'val6', 7: 'val7', 8: 'val8', 9: 'val9'}\n>>> ls = {i for i in range(10)}\n>>> print(type(ls),ls)\n<class 'set'> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n```", "```py\n>>> list(( i for i in range(10)))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> dict(( (i,'val'+str(i)) for i in range(10)))\n{0: 'val0', 1: 'val1', 2: 'val2', 3: 'val3', 4: 'val4', 5: 'val5', 6: 'val6', 7: 'val7', 8: 'val8', 9: 'val9'}\n>>> set(( i for i in range(10)))\n{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n```", "```py\n>>> def func(val):\n...     for i in (j for j in range(1000)):\n...         k = i + 5\n... \n>>> def func_iter(val):\n...     for i in [ j for j in range(1000)]:\n...         k = i + 5\n... \n>>> timeit.timeit(stmt=\"func(1000)\", globals={'func':func_iter},number=10000)\n0.6765081569974427\n>>> timeit.timeit(stmt=\"func(1000)\", globals={'func':func},number=10000)\n0.838760247999744\n```", "```py\n    >>> list(itertools.chain(range(3),range(2),range(4)))\n    [0, 1, 2, 0, 1, 0, 1, 2, 3]\n    >>> \n    ```", "```py\n    >>> cc = cycle(range(4))\n    >>> cc.__next__()\n    0\n    >>> cc.__next__()\n    1\n    >>> cc.__next__()\n    2\n    >>> cc.__next__()\n    3\n    >>> cc.__next__()\n    0\n    >>> cc.__next__()\n    1\n    >>> cc.__next__()\n    ```", "```py\n    >>> i,j = tee(range(10),2)\n    >>> i\n    <itertools._tee object at 0x7ff38e2b2ec8>\n    >>> i.__next__()\n    0\n    >>> i.__next__()\n    1\n    >>> i.__next__()\n    2\n    >>> j.__next__()\n    0\n    ```", "```py\n    In [7]: @lru_cache(maxsize=None)\n    def fib(n):\n        if n<2:\n            return n\n        return fib(n-1) + fib(n-2)\n       ...: \n\n    In [8]: %timeit fib(30)\n    10000000 loops, best of 3: 105 ns per loop\n\n    In [9]:                         \n    def fib(n):\n        if n<2:\n            return n\n        return fib(n-1) + fib(n-2)\n       ...: \n\n    In [10]: %timeit fib(30)\n    1 loops, best of 3: 360 ms per loop\n    ```", "```py\n    >>> def deco(func):\n    ...     @wraps(func) # this will update wrapper to match func\n    ...     def wrapper(*args, **kwargs):\n    ...         \"\"\"i am imposter\"\"\"\n    ...         print(\"wrapper\")\n    ...         return func(*args, **kwargs)\n    ...     return wrapper\n    ... \n    >>> @deco\n    ... def realfunc(*args,**kwargs):\n    ...     \"\"\"i am real function \"\"\"\n    ...     print(\"realfunc\",args,kwargs)\n    ... \n    >>> realfunc(1,2)\n    wrapper\n    realfunc (1, 2) {}\n    >>> print(realfunc.__name__, realfunc.__doc__)\n    realfunc i am real function \n    ```", "```py\n    >>> def log(prefix):\n    ...     return lambda x:'%s : %s'%(prefix,x)\n    ... \n    >>> err = log(\"error\")\n    >>> warn = log(\"warn\")\n    >>> \n    >>> print(err(\"an error occurred\"))\n    error : an error occurred\n    >>> print(warn(\"some thing is not right\"))\n    warn : some thing is not right\n    ```", "```py\n    >>> import itertools\n    >>> af = lambda x:[i for i in itertools.chain(range(1,x+1),range(x-1,0,-1))]\n    >>> output = '\\n'.join(['%s%s'%('  '*(5-i),' '.join([str(j) for j in af(i)])) for i in af(5)])\n    >>> print(output)\n            1\n          1 2 1\n        1 2 3 2 1\n      1 2 3 4 3 2 1\n    1 2 3 4 5 4 3 2 1\n      1 2 3 4 3 2 1\n        1 2 3 2 1\n          1 2 1\n            1\n    ```"]