<html><head></head><body>
<div><h1 class="chapterNumber">3</h1>
<h1 class="chapterTitle" id="_idParaDest-113">Extending Your Blog Application</h1>
<p class="normal">The previous chapter went through the basics of forms and the creation of a comment system. You also learned how to send emails with Django. In this chapter, you will extend your blog application with other popular features used on blogging platforms, such as tagging, recommending similar posts, providing an RSS feed to readers, and allowing them to search posts. You will learn about new components and functionalities with Django by building these functionalities.</p>
<p class="normal">The chapter will cover the following topics:</p>
<ul>
<li class="bulletList">Implementing tagging using <code class="inlineCode">django-taggit</code></li>
<li class="bulletList">Retrieving posts by similarity</li>
<li class="bulletList">Creating custom template tags and filters to display the latest posts and most commented posts</li>
<li class="bulletList">Adding a sitemap to the site</li>
<li class="bulletList">Creating feeds for blog posts</li>
<li class="bulletList">Installing PostgreSQL</li>
<li class="bulletList">Using fixtures to dump and load data into the database</li>
<li class="bulletList">Implementing a full-text search engine with Django and PostgreSQL</li>
</ul>
<h1 class="heading-1" id="_idParaDest-114">Functional overview</h1>
<p class="normal"><em class="italic">Figure 3.1</em> shows a<a id="_idIndexMarker252"/> representation of the views, templates, and functionalities that will be built in this chapter:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_01.png"/></figure>
<p class="packt_figref">Figure 3.1: Diagram of functionalities built in Chapter 3</p>
<p class="normal">In this chapter, we will build the functionality to add tags to posts. We will extend the <code class="inlineCode">post_list</code> view to filter <a id="_idIndexMarker253"/>posts by tag. When loading a single post in the <code class="inlineCode">post_detail</code> view, we will retrieve similar posts based on common tags. We will also create custom template tags to display a sidebar with the total number of posts, the latest posts published, and the most commented posts.</p>
<p class="normal">We will add support to write posts with Markdown syntax and convert the content to HTML. We will create a sitemap for the blog with the <code class="inlineCode">PostSitemap</code> class and implement an RSS feed with the latest posts in the <code class="inlineCode">LatestPostsFeed</code> class. Finally, we will implement a search engine with the <code class="inlineCode">post_search</code> view and use PostgreSQL full-text search capabilities.</p>
<p class="normal">The source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03">https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03</a>.</p>
<p class="normal">All Python packages used in this chapter are included in the <code class="inlineCode">requirements.txt</code> file in the source code for the chapter. You can follow the instructions to install each Python package in the following sections, or you can install all the requirements at once with the command <code class="inlineCode">python</code> <code class="inlineCode">-m</code> <code class="inlineCode">pip install -r requirements.txt</code>.</p>
<h1 class="heading-1" id="_idParaDest-115">Implementing tagging with django-taggit</h1>
<p class="normal">A very common functionality in blogs is categorizing posts using tags. Tags allow you to categorize content in a non-hierarchical manner, using simple keywords. A tag is simply a label or keyword that can <a id="_idIndexMarker254"/>be assigned to posts. We will <a id="_idIndexMarker255"/>create a tagging system by integrating a third-party Django tagging application into the project.</p>
<p class="normal"><code class="inlineCode">django-taggit</code> is a reusable application that primarily offers you a <code class="inlineCode">Tag</code> model and a manager to easily add tags to any model. You can take a look at its source code at <a href="https://github.com/jazzband/django-taggit">https://github.com/jazzband/django-taggit</a>.</p>
<p class="normal">Let’s add tagging to our blog. First, you need to install <code class="inlineCode">django-taggit</code> via <code class="inlineCode">pip</code> by running the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python -m pip install django-taggit==5.0.1
</code></pre>
<p class="normal">Then, open the <code class="inlineCode">settings.py</code> file of the <code class="inlineCode">mysite</code> project and add <code class="inlineCode">taggit</code> to your <code class="inlineCode">INSTALLED_APPS</code> setting, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    <strong class="hljs-string-slc">'taggit'</strong><strong class="hljs-slc">,</strong>
'blog.apps.BlogConfig',
]
</code></pre>
<div><p class="normal">It’s good practice to keep the Django packages at the top, third-party packages in the middle, and local applications at the end of <code class="inlineCode">INSTALLED_APPS</code>.</p>
</div>
<p class="normal">Open the <code class="inlineCode">models.py</code> file of your <code class="inlineCode">blog</code> application and add the <code class="inlineCode">TaggableManager</code> manager provided by <code class="inlineCode">django-taggit</code> to the <code class="inlineCode">Post</code> model using the following code:</p>
<pre class="programlisting code"><code class="hljs-code"><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> taggit.managers </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> TaggableManager</strong>
class Post(models.Model):
    # ...
<strong class="hljs-slc">tags = TaggableManager()</strong>
</code></pre>
<p class="normal">The <code class="inlineCode">tags</code> manager will allow you to add, retrieve, and remove tags from <code class="inlineCode">Post</code> objects.</p>
<p class="normal">The following schema<a id="_idIndexMarker256"/> shows the data models defined by <code class="inlineCode">django-taggit</code> to create tags and store related tagged objects:</p>
<figure class="mediaobject"><img alt="Diagram  Description automatically generated with low confidence" src="img/B21088_03_02.png"/></figure>
<p class="packt_figref">Figure 3.2: Tag models of django-taggit</p>
<p class="normal">The <code class="inlineCode">Tag</code> model is used to store tags. It contains a <code class="inlineCode">name</code> and a <code class="inlineCode">slug</code> field.</p>
<p class="normal">The <code class="inlineCode">TaggedItem</code> model is used to store the related tagged objects. It has a <code class="inlineCode">ForeignKey</code> field for the related <code class="inlineCode">Tag</code> object. It contains a <code class="inlineCode">ForeignKey</code> to a <code class="inlineCode">ContentType</code> object and an <code class="inlineCode">IntegerField</code> to store the related <code class="inlineCode">id</code> of the tagged object. The <code class="inlineCode">content_type</code> and <code class="inlineCode">object_id</code> fields combined <a id="_idIndexMarker257"/>form a generic relationship with any model in your project. This allows you to create relationships between a <code class="inlineCode">Tag</code> instance and any other model instance of your applications. You will learn about generic relations ship in <em class="chapterRef">Chapter 7</em>, <em class="italic">Tracking User Actions</em>.</p>
<p class="normal">Run the following command in the shell prompt to create a migration for your model changes:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py makemigrations blog
</code></pre>
<p class="normal">You should get the following output:</p>
<pre class="programlisting con"><code class="hljs-con">Migrations for 'blog':
  blog/migrations/0004_post_tags.py
    - Add field tags to post
</code></pre>
<p class="normal">Now, run the following command to create the required database tables for <code class="inlineCode">django-taggit</code> models and to synchronize your model changes:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py migrate
</code></pre>
<p class="normal">You will see an output indicating that migrations have been applied, as follows:</p>
<pre class="programlisting con"><code class="hljs-con">Applying taggit.0001_initial... OK
Applying taggit.0002_auto_20150616_2121... OK
Applying taggit.0003_taggeditem_add_unique_index... OK
Applying taggit.0004_alter_taggeditem_content_type_alter_taggeditem_tag... OK
Applying taggit.0005_auto_20220424_2025... OK
Applying taggit.0006_rename_taggeditem_content_type_object_id_taggit_tagg_content_8fc721_idx... OK
Applying blog.0004_post_tags... OK
</code></pre>
<p class="normal">The database is now in sync with the <code class="inlineCode">taggit</code> models and we can start using the functionalities of <code class="inlineCode">django-taggit</code>.</p>
<p class="normal">Let’s now explore how to <a id="_idIndexMarker258"/>use the <code class="inlineCode">tags</code> manager.</p>
<p class="normal">Open the Django <a id="_idIndexMarker259"/>shell by running the following command in the system shell prompt:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py shell
</code></pre>
<p class="normal">Run the following code to retrieve one of the posts (the one with the <code class="inlineCode">1</code> ID):</p>
<pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from blog.models import Post
&gt;&gt;&gt; post = Post.objects.get(id=1)
</code></pre>
<p class="normal">Then, add some tags to it and retrieve its tags to check whether they were successfully added:</p>
<pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; post.tags.add('music', 'jazz', 'django')
&gt;&gt;&gt; post.tags.all()
&lt;QuerySet [&lt;Tag: jazz&gt;, &lt;Tag: music&gt;, &lt;Tag: django&gt;]&gt;
</code></pre>
<p class="normal">Finally, remove a tag and check the list of tags again:</p>
<pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; post.tags.remove('django')
&gt;&gt;&gt; post.tags.all()
&lt;QuerySet [&lt;Tag: jazz&gt;, &lt;Tag: music&gt;]&gt;
</code></pre>
<p class="normal">It’s really easy to add, retrieve, or remove tags from a model using the manager we have defined.</p>
<p class="normal">Start the development <a id="_idIndexMarker260"/>server from the shell prompt with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py runserver
</code></pre>
<p class="normal">Open <a href="http://127.0.0.1:8000/admin/taggit/tag/">http://127.0.0.1:8000/admin/taggit/tag/</a> in your browser.</p>
<p class="normal">You will see the administration <a id="_idIndexMarker261"/>page with the list of <code class="inlineCode">Tag</code> objects of the <code class="inlineCode">taggit</code> application:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_03.png"/></figure>
<p class="packt_figref">Figure 3.3: The tag change list view on the Django administration site</p>
<p class="normal">Click on the <strong class="screenText">jazz</strong> tag. You will see the following:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_04.png"/></figure>
<p class="packt_figref">Figure 3.4: The tag edit view on the Django administration site</p>
<p class="normal">Navigate to <code class="inlineCode">http://127.0.0.1:8000/admin/blog/post/1/change/</code> to edit the post with ID 1.</p>
<p class="normal">You will see that posts <a id="_idIndexMarker262"/>now include a new <strong class="screenText">Tags</strong> field, as follows, where<a id="_idIndexMarker263"/> you can easily edit tags:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_05.png"/></figure>
<p class="packt_figref">Figure 3.5: The related Tags field of a Post object</p>
<p class="normal">Now, you need to edit your blog posts to display tags.</p>
<p class="normal">Open the <code class="inlineCode">blog/post/list.html</code> template and add the following HTML code highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">{% extends "blog/base.html" %}
{% block title %}My Blog{% endblock %}
{% block content %}
  &lt;h1&gt;My Blog&lt;/h1&gt;
  {% for post in posts %}
    &lt;h2&gt;
&lt;a href="{{ post.get_absolute_url }}"&gt;
        {{ post.title }}
      &lt;/a&gt;
&lt;/h2&gt;
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">p</strong><strong class="hljs-tag-slc"> </strong><strong class="hljs-attr-slc">class</strong><strong class="hljs-tag-slc">=</strong><strong class="hljs-string-slc">"tags"</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">Tags: {{ post.tags.all|join:", " }}</strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">p</strong><strong class="hljs-tag-slc">&gt;</strong>
&lt;p class="date"&gt;
      Published {{ post.publish }} by {{ post.author }}
    &lt;/p&gt;
    {{ post.body|truncatewords:30|linebreaks }}
  {% endfor %}
  {% include "pagination.html" with page=page_obj %}
{% endblock %}
</code></pre>
<p class="normal">The <code class="inlineCode">join</code> template filter works analogously<a id="_idIndexMarker264"/> to Python’s string <code class="inlineCode">join()</code> method. You can concatenate a list of items<a id="_idIndexMarker265"/> into one string, using a specific character or string to separate each item. For example, a list of tags like <code class="inlineCode">['music', 'jazz', 'piano']</code> is converted into a single string, <code class="inlineCode">'music, jazz, piano'</code>, by joining them with <code class="inlineCode">','</code> as the <code class="inlineCode">join()</code> separator.</p>
<p class="normal">Open <code class="inlineCode">http://127.0.0.1:8000/blog/</code> in your browser. You should be able to see the list of tags under each post title:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_06.png"/></figure>
<p class="packt_figref">Figure 3.6: The Post list item, including related tags</p>
<p class="normal">Next, we will edit the <code class="inlineCode">post_list</code> view to let users list all posts tagged with a specific tag.</p>
<p class="normal">Open the <code class="inlineCode">views.py</code> file of your <code class="inlineCode">blog</code> application, import<a id="_idIndexMarker266"/> the <code class="inlineCode">Tag</code> model from <code class="inlineCode">django-taggit</code>, and change the <code class="inlineCode">post_list</code> view to<a id="_idIndexMarker267"/> optionally filter posts by a tag, as follows. New code is highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code"><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> taggit.models </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> Tag</strong>
def post_list(request<strong class="hljs-params-slc">, tag_slug=</strong><strong class="hljs-literal-slc">None</strong>):
    post_list = Post.published.all()
    <strong class="hljs-slc">tag = </strong><strong class="hljs-literal-slc">None</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> tag_slug:</strong>
<strong class="hljs-slc">        tag = get_object_or_404(Tag, slug=tag_slug)</strong>
<strong class="hljs-slc">        post_list = post_list.</strong><strong class="hljs-built_in-slc">filter</strong><strong class="hljs-slc">(tags__in=[tag])</strong>
# Pagination with 3 posts per page
    paginator = Paginator(post_list, 3)
    page_number = request.GET.get('page', 1)
    try:
        posts = paginator.page(page_number)
    except PageNotAnInteger:
        # If page_number is not an integer get the first page
        posts = paginator.page(1)
    except EmptyPage:
        # If page_number is out of range get last page of results
        posts = paginator.page(paginator.num_pages)
    return render(
 request,
 'blog/post/list.html',
 {
 'posts': posts<strong class="hljs-slc">,</strong>
 <strong class="hljs-string-slc">'</strong><strong class="hljs-string-slc">tag'</strong><strong class="hljs-slc">: tag</strong>
        }
    )
</code></pre>
<p class="normal">The <code class="inlineCode">post_list</code> view now works as follows:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">It takes an optional <code class="inlineCode">tag_slug</code> parameter that has a <code class="inlineCode">None</code> default value. This parameter will be passed in the URL.</li>
<li class="numberedList">Inside the view, we build the initial QuerySet, retrieving all published posts, and if there is a given tag slug, we get the <code class="inlineCode">Tag</code> object with the given slug using the <code class="inlineCode">get_object_or_404()</code> shortcut.</li>
<li class="numberedList">Then, we filter the list of posts by the ones that contain the given tag. Since this is a many-to-many relationship, we have to filter posts by tags contained in a given list, which, in this case, contains only one element. We use the <code class="inlineCode">__in</code> field lookup. Many-to-many relationships occur when multiple objects of a model are associated with multiple objects of another model. In our application, a post can have multiple tags and a tag can be related to multiple posts. You will learn how<a id="_idIndexMarker268"/> to create many-to-many relationships in <em class="chapterRef">Chapter 6</em>, <em class="italic">Sharing Content on Your Website</em>. You can discover more about many-to-many relationships at <a href="https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/">https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/</a>.</li>
<li class="numberedList">Finally, the <code class="inlineCode">render()</code> function now passes the new <code class="inlineCode">tag</code> variable to the template.</li>
</ol>
<p class="normal">Remember that QuerySets <a id="_idIndexMarker269"/>are lazy. The QuerySets to retrieve posts will only be evaluated when you loop over <code class="inlineCode">post_list</code> when rendering the template.</p>
<p class="normal">Open the <code class="inlineCode">urls.py</code> file of your <code class="inlineCode">blog</code> application, comment out the class-based <code class="inlineCode">PostListView</code> URL pattern, and uncomment the <code class="inlineCode">post_list</code> view, like this:</p>
<pre class="programlisting code"><code class="hljs-code"><strong class="hljs-slc">path(</strong><strong class="hljs-string-slc">''</strong><strong class="hljs-slc">, views.post_list, name=</strong><strong class="hljs-string-slc">'post_list'</strong><strong class="hljs-slc">),</strong>
<strong class="hljs-comment-slc">#</strong> path('', views.PostListView.as_view(), name='post_list'),
</code></pre>
<p class="normal">Add the following additional URL pattern to list posts by tag:</p>
<pre class="programlisting code"><code class="hljs-code">path(
    'tag/&lt;slug:tag_slug&gt;/', views.post_list, name='post_list_by_tag'
    ),
</code></pre>
<p class="normal">As you can see, both patterns point to the same view, but they have different names. The first pattern will call the <code class="inlineCode">post_list</code> view without any optional parameters, whereas the second pattern will call the view with the <code class="inlineCode">tag_slug</code> parameter. You use a <code class="inlineCode">slug</code> path converter to match the parameter as a lowercase string with ASCII letters or numbers, plus the hyphen and underscore characters.</p>
<p class="normal">The <code class="inlineCode">urls.py</code> file of the <code class="inlineCode">blog</code> application should now look like this:</p>
<pre class="programlisting code"><code class="hljs-code">from django.urls import path
from . import views
app_name = 'blog'
urlpatterns = [
    # Post views
    path('', views.post_list, name='post_list'),
    # path('', views.PostListView.as_view(), name='post_list'),
    path(
        'tag/&lt;slug:tag_slug&gt;/', views.post_list, name='post_list_by_tag'
 ),
    path(
        '&lt;int:year&gt;/&lt;int:month&gt;/&lt;int:day&gt;/&lt;slug:post&gt;/',
        views.post_detail,
        name='post_detail'
 ),
    path('&lt;int:post_id&gt;/share/', views.post_share, name='post_share'),
    path(
        '&lt;int:post_id&gt;/comment/', views.post_comment, name='post_comment'
 ),
]
</code></pre>
<p class="normal">Since you are using <a id="_idIndexMarker270"/>the <code class="inlineCode">post_list</code> view, edit the <code class="inlineCode">blog/post/list.html</code> template<a id="_idIndexMarker271"/> and modify the pagination to use the <code class="inlineCode">posts</code> object:</p>
<pre class="programlisting code"><code class="hljs-code">{% include "pagination.html" with page=<strong class="hljs-slc">posts</strong> %}
</code></pre>
<p class="normal">Add the following lines highlighted in bold to the <code class="inlineCode">blog/post/list.html</code> template:</p>
<pre class="programlisting code"><code class="hljs-code">{% extends "blog/base.html" %}
{% block title %}My Blog{% endblock %}
{% block content %}
  &lt;h1&gt;My Blog&lt;/h1&gt;
<strong class="hljs-slc">  {% if tag %}</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">h2</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">Posts tagged with "{{ tag.name }}"</strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">h2</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc">  {% endif %}</strong>
  {% for post in posts %}
    &lt;h2&gt;
&lt;a href="{{ post.get_absolute_url }}"&gt;
        {{ post.title }}
      &lt;/a&gt;
&lt;/h2&gt;
&lt;p class="tags"&gt;Tags: {{ post.tags.all|join:", " }}&lt;/p&gt;
&lt;p class="date"&gt;
      Published {{ post.publish }} by {{ post.author }}
    &lt;/p&gt;
    {{ post.body|truncatewords:30|linebreaks }}
  {% endfor %}
  {% include "pagination.html" with page=posts %}
{% endblock %}
</code></pre>
<p class="normal">If a user is accessing the blog, they will <a id="_idIndexMarker272"/>see the list of all posts. If they filter by posts tagged with a specific tag, they <a id="_idIndexMarker273"/>will see the tag that they are filtering by.</p>
<p class="normal">Now, edit the <code class="inlineCode">blog/post/list.html</code> template and change the way tags are displayed, as follows. New lines are highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">{% extends "blog/base.html" %}
{% block title %}My Blog{% endblock %}
{% block content %}
  &lt;h1&gt;My Blog&lt;/h1&gt;
  {% if tag %}
    &lt;h2&gt;Posts tagged with "{{ tag.name }}"&lt;/h2&gt;
  {% endif %}
  {% for post in posts %}
    &lt;h2&gt;
&lt;a href="{{ post.get_absolute_url }}"&gt;
        {{ post.title }}
      &lt;/a&gt;
&lt;/h2&gt;
&lt;p class="tags"&gt;
      Tags:
<strong class="hljs-slc">      {% for tag in post.tags.all %}</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">a</strong><strong class="hljs-tag-slc"> </strong><strong class="hljs-attr-slc">href</strong><strong class="hljs-tag-slc">=</strong><strong class="hljs-string-slc">"{% url "</strong><strong class="hljs-attr-slc">blog:post_list_by_tag</strong><strong class="hljs-tag-slc">" </strong><strong class="hljs-attr-slc">tag.slug</strong><strong class="hljs-tag-slc"> %}"&gt;</strong>
<strong class="hljs-slc">          {{ tag.name }}</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">a</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">{% if not forloop.last %}, {% endif %}</strong>
<strong class="hljs-slc">      {% endfor %}</strong>
&lt;/p&gt;
&lt;p class="date"&gt;
      Published {{ post.publish }} by {{ post.author }}
    &lt;/p&gt;
    {{ post.body|truncatewords:30|linebreaks }}
  {% endfor %}
  {% include "pagination.html" with page=posts %}
{% endblock %}
</code></pre>
<p class="normal">In the preceding code, we loop through all the tags of a post displaying a custom link to the URL to filter posts by that tag. We build the URL with <code class="inlineCode">{% url "blog:post_list_by_tag" tag.slug %}</code>, using the name of the URL and the <code class="inlineCode">slug</code> tag as its parameter. You separate the tags with commas.</p>
<p class="normal">Open <code class="inlineCode">http://127.0.0.1:8000/blog/tag/jazz/</code> in your <a id="_idIndexMarker274"/>browser. You will <a id="_idIndexMarker275"/>see the list of posts filtered by that tag, like this:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_07.png"/></figure>
<p class="packt_figref">Figure 3.7: A post filtered by the tag “jazz”</p>
<h1 class="heading-1" id="_idParaDest-116">Retrieving posts by similarity</h1>
<p class="normal">Now that we have implemented tagging for <a id="_idIndexMarker276"/>blog posts, you can do many interesting things with tags. Tags allow you to categorize posts in a non-hierarchical manner. Posts about similar topics will have several tags in common. We will build a functionality to display similar posts by the number of tags they share. In this way, when a user reads a post, we can suggest to them that they read other related posts.</p>
<p class="normal">In order to retrieve similar <a id="_idIndexMarker277"/>posts for a specific post, you need to perform the following steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Retrieve all tags for the current post.</li>
<li class="numberedList">Get all posts that are tagged with any of those tags.</li>
<li class="numberedList">Exclude the current post from that list to avoid recommending the same post.</li>
<li class="numberedList">Order the results by the number of tags shared with the current post.</li>
<li class="numberedList">In the case of two or more posts with the same number of tags, recommend the most recent post.</li>
<li class="numberedList">Limit the query to the number of posts you want to recommend.</li>
</ol>
<p class="normal">These steps are translated into a complex QuerySet. Let’s edit the <code class="inlineCode">post_detail</code> view to incorporate these similarity-based post suggestions.</p>
<p class="normal">Open the <code class="inlineCode">views.py</code> file of your <code class="inlineCode">blog</code> application and add the following import at the top of it:</p>
<pre class="programlisting code"><code class="hljs-code">from django.db.models import Count
</code></pre>
<p class="normal">This is the <code class="inlineCode">Count</code> aggregation function of the Django ORM. This function will allow you to perform aggregated counts of tags. <code class="inlineCode">django.db.models</code> includes the following aggregation functions:</p>
<ul>
<li class="bulletList"><code class="inlineCode">Avg</code>: The mean value</li>
<li class="bulletList"><code class="inlineCode">Max</code>: The maximum value</li>
<li class="bulletList"><code class="inlineCode">Min</code>: The minimum value</li>
<li class="bulletList"><code class="inlineCode">Count</code>: The total number of objects</li>
</ul>
<p class="normal">You can learn about aggregation at <a href="https://docs.djangoproject.com/en/5.0/topics/db/aggregation/">https://docs.djangoproject.com/en/5.0/topics/db/aggregation/</a>.</p>
<p class="normal">Open the <code class="inlineCode">views.py</code> file of your <code class="inlineCode">blog</code> application and add the following lines to the <code class="inlineCode">post_detail</code> view. New lines are highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">def post_detail(request, year, month, day, post):
    post = get_object_or_404(
        Post,
        status=Post.Status.PUBLISHED,
        slug=post,
        publish__year=year,
        publish__month=month,
        publish__day=day
    )
    # List of active comments for this post
    comments = post.comments.filter(active=True)
    # Form for users to comment
    form = CommentForm()
<strong class="hljs-slc"> </strong><strong class="hljs-comment-slc"># List of similar posts</strong>
<strong class="hljs-slc">    post_tags_ids = post.tags.values_list(</strong><strong class="hljs-string-slc">'id'</strong><strong class="hljs-slc">, flat=</strong><strong class="hljs-literal-slc">True</strong><strong class="hljs-slc">)</strong>
<strong class="hljs-slc">    similar_posts = Post.published.</strong><strong class="hljs-built_in-slc">filter</strong><strong class="hljs-slc">(</strong>
<strong class="hljs-slc">        tags__in=post_tags_ids</strong>
<strong class="hljs-slc">    ).exclude(</strong><strong class="hljs-built_in-slc">id</strong><strong class="hljs-slc">=post.</strong><strong class="hljs-built_in-slc">id</strong><strong class="hljs-slc">)</strong>
<strong class="hljs-slc">    similar_posts = similar_posts.annotate(</strong>
<strong class="hljs-slc">        same_tags=Count(</strong><strong class="hljs-string-slc">'tags'</strong><strong class="hljs-slc">)</strong>
<strong class="hljs-slc">    ).order_by(</strong><strong class="hljs-string-slc">'-same_tags'</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">'-publish'</strong><strong class="hljs-slc">)[:</strong><strong class="hljs-number-slc">4</strong><strong class="hljs-slc">]</strong>
return render(
        request,
        'blog/post/detail.html',
        {
            'post': post,
            'comments': comments,
            'form': form<strong class="hljs-slc">,</strong>
<strong class="hljs-string-slc">'similar_posts'</strong><strong class="hljs-slc">: similar_posts</strong>
        }
    )
</code></pre>
<p class="normal">The preceding code is as follows:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">You retrieve a<a id="_idIndexMarker278"/> Python list of IDs for the tags of the current post. The <code class="inlineCode">values_list()</code> QuerySet returns tuples with the values for the given fields. You pass <code class="inlineCode">flat=True</code> to it to get single values such as <code class="inlineCode">[1, 2, 3, ...]</code> instead of one tuple such as <code class="inlineCode">[(1,), (2,), (3,) ...]</code>.</li>
<li class="numberedList">You get all posts that contain any of these tags, excluding the current post itself.</li>
<li class="numberedList">You use the <code class="inlineCode">Count</code> aggregation function to generate a calculated field—<code class="inlineCode">same_tags</code>—that contains the number of tags shared with all the tags queried.</li>
<li class="numberedList">You order the result by the number of shared tags (descending order) and by <code class="inlineCode">publish</code> to display recent posts first for the posts with the same number of shared tags. You slice the result to retrieve only the first four posts.</li>
<li class="numberedList">You pass the <code class="inlineCode">similar_posts</code> object to the context dictionary for the <code class="inlineCode">render()</code> function.</li>
</ol>
<p class="normal">Now, edit the <code class="inlineCode">blog/post/detail.html</code> template<a id="_idIndexMarker279"/> and add the following code highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">{% extends "blog/base.html" %}
{% block title %}{{ post.title }}{% endblock %}
{% block content %}
  &lt;h1&gt;{{ post.title }}&lt;/h1&gt;
&lt;p class="date"&gt;
    Published {{ post.publish }} by {{ post.author }}
  &lt;/p&gt;
  {{ post.body|linebreaks }}
  &lt;p&gt;
&lt;a href="{% url "blog:post_share" post.id %}"&gt;
      Share this post
    &lt;/a&gt;
&lt;/p&gt;
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">h2</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">Similar posts</strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">h2</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc">  {% for post in similar_posts %}</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">p</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">a</strong><strong class="hljs-tag-slc"> </strong><strong class="hljs-attr-slc">href</strong><strong class="hljs-tag-slc">=</strong><strong class="hljs-string-slc">"{{ post.get_absolute_url }}"</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">{{ post.title }}</strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">a</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">p</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc">  {% empty %}</strong>
<strong class="hljs-slc">    There are no similar posts yet.</strong>
<strong class="hljs-slc">  {% endfor %}</strong>
  {% with comments.count as total_comments %}
    &lt;h2&gt;
      {{ total_comments }} comment{{ total_comments|pluralize }}
    &lt;/h2&gt;
  {% endwith %}
  {% for comment in comments %}
    &lt;div class="comment"&gt;
&lt;p class="info"&gt;
        Comment {{ forloop.counter }} by {{ comment.name }}
        {{ comment.created }}
      &lt;/p&gt;
      {{ comment.body|linebreaks }}
    &lt;/div&gt;
  {% empty %}
    &lt;p&gt;There are no comments yet.&lt;/p&gt;
  {% endfor %}
  {% include "blog/post/includes/comment_form.html" %}
{% endblock %}
</code></pre>
<p class="normal">The post detail page should look like this:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_08.png"/></figure>
<p class="packt_figref">Figure 3.8: The post detail page, including a list of similar posts</p>
<p class="normal">Open <code class="inlineCode">http://127.0.0.1:8000/admin/blog/post/</code> in your <a id="_idIndexMarker280"/>browser, edit a post that has no tags, and add the <code class="inlineCode">music</code> and <code class="inlineCode">jazz</code> tags, as follows:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_09.png"/></figure>
<p class="packt_figref">Figure 3.9: Adding the “jazz” and “music” tags to a post</p>
<p class="normal">Edit another post <a id="_idIndexMarker281"/>and add the <code class="inlineCode">jazz</code> tag, as follows:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_10.png"/></figure>
<p class="packt_figref">Figure 3.10: Adding the “jazz” tag to a post</p>
<p class="normal">The post detail page for<a id="_idIndexMarker282"/> the first post should now look like this:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_11.png"/></figure>
<p class="packt_figref">Figure 3.11: The post detail page, including a list of similar posts</p>
<p class="normal">The posts <a id="_idIndexMarker283"/>recommended in the <strong class="screenText">Similar posts</strong> section of the page appear in descending order based on the number of shared tags with the original post.</p>
<p class="normal">We are now able to successfully recommend similar posts to readers. <code class="inlineCode">django-taggit</code> also includes a <code class="inlineCode">similar_objects()</code> manager that you can use to retrieve objects by shared tags. You can take a look at all <code class="inlineCode">django-taggit</code> managers at <a href="https://django-taggit.readthedocs.io/en/latest/api.html">https://django-taggit.readthedocs.io/en/latest/api.html</a>.</p>
<p class="normal">You can also add the list of tags to your post detail template in the same way as you did in the <code class="inlineCode">blog/post/list.html</code> template.</p>
<h1 class="heading-1" id="_idParaDest-117">Creating custom template tags and filters</h1>
<p class="normal">Django offers a variety<a id="_idIndexMarker284"/> of built-in template tags, such as <code class="inlineCode">{% if %}</code> or <code class="inlineCode">{% block %}</code>. You used different template tags in <em class="chapterRef">Chapter 1</em>, <em class="italic">Building a Blog Application</em>, and <em class="italic">Chapter 2</em>, <em class="italic">Enhancing Your Blog with Advanced Features</em>. You can find a complete reference of built-in template tags and filters at <a href="https://docs.djangoproject.com/en/5.0/ref/templates/builtins/">https://docs.djangoproject.com/en/5.0/ref/templates/builtins/</a>.</p>
<p class="normal">Django also allows you to create your own template tags to perform custom actions. Custom template tags come in very handy when you need to add a functionality to your templates that is not covered by the core set of Django template tags. This can be a tag to execute a QuerySet or any server-side processing that you want to reuse across templates. For example, we could build a template tag to display a list of the latest posts published on the blog. We <a id="_idIndexMarker285"/>could include this list in the sidebar so that it is always visible, regardless of the view that processes the request.</p>
<h2 class="heading-2" id="_idParaDest-118">Implementing custom template tags</h2>
<p class="normal">Django provides the <a id="_idIndexMarker286"/>following helper functions, which allow you to easily create template tags:</p>
<ul>
<li class="bulletList"><code class="inlineCode">simple_tag</code>: Processes the given data and returns a string</li>
<li class="bulletList"><code class="inlineCode">inclusion_tag</code>: Processes the given data and returns a rendered template</li>
</ul>
<p class="normal">Template tags must live inside Django applications.</p>
<p class="normal">Inside your <code class="inlineCode">blog</code> application directory, create a new directory, name it <code class="inlineCode">templatetags</code>, and add an empty <code class="inlineCode">__init__.py</code> file to it. Create another file in the same folder and name it <code class="inlineCode">blog_tags.py</code>. The file structure of the blog application should look like the following:</p>
<pre class="programlisting con"><code class="hljs-con">blog/
    __init__.py
    models.py
    ...
    <strong class="hljs-con-slc">templatetags/</strong>
<strong class="hljs-con-slc">__init__.py</strong>
<strong class="hljs-con-slc">blog_tags.py</strong>
</code></pre>
<p class="normal">The way you name the file is important because you will use the name of this module to load tags in templates.</p>
<h2 class="heading-2" id="_idParaDest-119">Creating a simple template tag</h2>
<p class="normal">Let’s start by creating a<a id="_idIndexMarker287"/> simple tag to retrieve the total posts that have been published on the blog.</p>
<p class="normal">Edit the <code class="inlineCode">templatetags/blog_tags.py</code> file you just created and add the following code:</p>
<pre class="programlisting code"><code class="hljs-code">from django import template
from ..models import Post
register = template.Library()
@register.simple_tag
def total_posts():
    return Post.published.count()
</code></pre>
<p class="normal">We have created a simple template tag that returns the number of posts published on the blog.</p>
<p class="normal">Each module that contains template tags needs to define a variable called <code class="inlineCode">register</code> to be a valid tag library. This variable is an instance of <code class="inlineCode">template.Library</code>, and it’s used to register the template tags and filters of the application.</p>
<p class="normal">In the preceding code, we have defined a tag called <code class="inlineCode">total_posts</code> with a simple Python function. We have added <a id="_idIndexMarker288"/>the <code class="inlineCode">@register.simple_tag</code> decorator to the function, to register it as a simple tag. Django will use the function’s name as the tag name. </p>
<p class="normal">If you want to register it using a different name, you can do so by specifying a <code class="inlineCode">name</code> attribute, such as <code class="inlineCode">@register.simple_tag(name='my_tag')</code>.</p>
<div><p class="normal">After adding a new template tags module, you will need to restart the Django development server in order to use the new tags and filters in templates.</p>
</div>
<p class="normal">Before using custom template tags, we have to make them available for the template using the <code class="inlineCode">{% load %}</code> tag. As mentioned before, we need to use the name of the Python module containing our template tags and filters.</p>
<p class="normal">Edit the <code class="inlineCode">blog/templates/base.html</code> template and add <code class="inlineCode">{% load blog_tags %}</code> at the top of it to load your template tags module. Then, use the tag you created to display your total posts, as follows. The new lines are highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code"><strong class="hljs-slc">{% load blog_tags %}</strong>
{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;{% block title %}{% endblock %}&lt;/title&gt;
&lt;link href="{% static "css/blog.css" %}" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="content"&gt;
    {% block content %}
    {% endblock %}
  &lt;/div&gt;
&lt;div id="sidebar"&gt;
&lt;h2&gt;My blog&lt;/h2&gt;
&lt;p&gt;
      This is my blog.
      <strong class="hljs-slc">I've written {% total_posts %} posts so far.</strong>
&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">You will need to restart the <a id="_idIndexMarker289"/>server to keep track of the new files added to the project. Stop the development server with <em class="italic">Ctrl</em> + <em class="italic">C</em> and run it again using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py runserver
</code></pre>
<p class="normal">Open <code class="inlineCode">http://127.0.0.1:8000/blog/</code> in your browser. You should see the total number of posts in the sidebar of the site, as follows:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_12.png"/></figure>
<p class="packt_figref">Figure 3.12: The total posts published included in the sidebar</p>
<p class="normal">If you see the following error message, it’s very likely you didn’t restart the development server:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_13.png"/></figure>
<p class="packt_figref">Figure 3.13: The error message when a template tag library is not registered</p>
<p class="normal">Template tags allow you to <a id="_idIndexMarker290"/>process any data and add it to any template regardless of the view executed. You can perform QuerySets or process any data to display results in your templates.</p>
<h2 class="heading-2" id="_idParaDest-120">Creating an inclusion template tag</h2>
<p class="normal">We will create another tag to display the latest posts in the sidebar of the blog. This time, we will implement an inclusion <a id="_idIndexMarker291"/>tag. Using an inclusion tag, you can render a template with context variables returned by your template tag.</p>
<p class="normal">Edit the <code class="inlineCode">templatetags/blog_tags.py</code> file and add the following code:</p>
<pre class="programlisting code"><code class="hljs-code">@register.inclusion_tag('blog/post/latest_posts.html')
def show_latest_posts(count=5):
    latest_posts = Post.published.order_by('-publish')[:count]
    return {'latest_posts': latest_posts}
</code></pre>
<p class="normal">In the preceding code, we have registered the template tag using the <code class="inlineCode">@register.inclusion_tag</code> decorator. We have specified the template that will be rendered with the returned values using <code class="inlineCode">blog/post/latest_posts.html</code>. The template tag will accept an optional <code class="inlineCode">count</code> parameter that defaults to <code class="inlineCode">5</code>. This parameter will allow us to specify the number of posts to display. We use this variable to limit the results of the query <code class="inlineCode">Post.published.order_by('-publish')[:count]</code>.</p>
<p class="normal">Note that the function returns a dictionary of variables instead of a simple value. Inclusion tags have to return a dictionary of values, which is used as the context to render the specified template. The template tag we just created allows us to specify the optional number of <a id="_idIndexMarker292"/>posts to display as <code class="inlineCode">{% show_latest_posts 3 %}</code>.</p>
<p class="normal">Now, create a new template file under <code class="inlineCode">blog/post/</code> and name it <code class="inlineCode">latest_posts.html</code>.</p>
<p class="normal">Edit the new <code class="inlineCode">blog/post/latest_posts.html</code> template and add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;ul&gt;
  {% for post in latest_posts %}
    &lt;li&gt;
&lt;a href="{{ post.get_absolute_url }}"&gt;{{ post.title }}&lt;/a&gt;
&lt;/li&gt;
  {% endfor %}
&lt;/ul&gt;
</code></pre>
<p class="normal">In the preceding code, you have added an unordered list of posts using the <code class="inlineCode">latest_posts</code> variable returned by your template tag. Now, edit the <code class="inlineCode">blog/base.html</code> template and add the new template tag to display the last three posts, as follows. The new lines are highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">{% load blog_tags %}
{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;{% block title %}{% endblock %}&lt;/title&gt;
&lt;link href="{% static "css/blog.css" %}" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="content"&gt;
    {% block content %}
    {% endblock %}
  &lt;/div&gt;
&lt;div id="sidebar"&gt;
&lt;h2&gt;My blog&lt;/h2&gt;
&lt;p&gt;
      This is my blog.
      I've written {% total_posts %} posts so far.
    &lt;/p&gt;
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">h3</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">Latest posts</strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">h3</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc">    {% show_latest_posts 3 %}</strong>
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">The template tag is called, passing the number of posts to display, and the template is rendered in place with the given context.</p>
<p class="normal">Next, return to your <a id="_idIndexMarker293"/>browser and refresh the page. The sidebar should now look like this:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_14.png"/></figure>
<p class="packt_figref">Figure 3.14: The blog sidebar, including the latest published posts</p>
<h2 class="heading-2" id="_idParaDest-121">Creating a template tag that returns a QuerySet</h2>
<p class="normal">Finally, we will create a simple template tag that returns a value. We will store the result in a variable that can be<a id="_idIndexMarker294"/> reused, rather than outputting it directly. We will create a tag to display the most commented posts.</p>
<p class="normal">Edit the <code class="inlineCode">templatetags/blog_tags.py</code> file and add the following import and template tag to it:</p>
<pre class="programlisting code"><code class="hljs-code">from django.db.models import Count
@register.simple_tag
def get_most_commented_posts(count=5):
    return Post.published.annotate(
        total_comments=Count('comments')
    ).order_by('-total_comments')[:count]
</code></pre>
<p class="normal">In the preceding template tag, you build a QuerySet using the <code class="inlineCode">annotate()</code> function to aggregate the total number of comments for each post. You use the <code class="inlineCode">Count</code> aggregation function to store the number of comments in the computed <code class="inlineCode">total_comments</code> field for each <code class="inlineCode">Post</code> object. You order the QuerySet by the computed field in descending order. You also provide an optional <code class="inlineCode">count</code> variable to limit the total number of objects returned.</p>
<p class="normal">In addition to <code class="inlineCode">Count</code>, Django<a id="_idIndexMarker295"/> offers the aggregation functions <code class="inlineCode">Avg</code>, <code class="inlineCode">Max</code>, <code class="inlineCode">Min</code>, and <code class="inlineCode">Sum</code>. You can read more about aggregation functions at <a href="https://docs.djangoproject.com/en/5.0/topics/db/aggregation/">https://docs.djangoproject.com/en/5.0/topics/db/aggregation/</a>.</p>
<p class="normal">Next, edit the <code class="inlineCode">blog/base.html</code> template and add the following code highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">{% load blog_tags %}
{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;{% block title %}{% endblock %}&lt;/title&gt;
&lt;link href="{% static "css/blog.css" %}" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="content"&gt;
    {% block content %}
    {% endblock %}
  &lt;/div&gt;
&lt;div id="sidebar"&gt;
&lt;h2&gt;My blog&lt;/h2&gt;
&lt;p&gt;
      This is my blog.
      I've written {% total_posts %} posts so far.
    &lt;/p&gt;
&lt;h3&gt;Latest posts&lt;/h3&gt;
    {% show_latest_posts 3 %}
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">h3</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">Most commented posts</strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">h3</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc">    {% get_most_commented_posts as most_commented_posts %}</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">ul</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc">      {% for post in most_commented_posts %}</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">li</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">a</strong><strong class="hljs-tag-slc"> </strong><strong class="hljs-attr-slc">href</strong><strong class="hljs-tag-slc">=</strong><strong class="hljs-string-slc">"{{ post.get_absolute_url }}"</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">{{ post.title }}</strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">a</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">li</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc">      {% endfor %}</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">ul</strong><strong class="hljs-tag-slc">&gt;</strong>
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">In the preceding code, we store the result in a custom variable using the <code class="inlineCode">as</code> argument followed by the variable name. For the <a id="_idIndexMarker296"/>template tag, we use <code class="inlineCode">{% get_most_commented_posts as most_commented_posts %}</code> to store the result of the template tag in a new variable named <code class="inlineCode">most_commented_posts</code>. Then, we display the returned posts using an HTML unordered list element.</p>
<p class="normal">Now open your browser and refresh the page to see the final result. It should look like the following:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_15.png"/></figure>
<p class="packt_figref">Figure 3.15: The post list view, including the complete sidebar with the latest and most commented posts</p>
<p class="normal">You now have a clear <a id="_idIndexMarker297"/>idea of how to build custom template tags. You can read more about them at <a href="https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/">https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/</a>.</p>
<h2 class="heading-2" id="_idParaDest-122">Implementing custom template filters</h2>
<p class="normal">Django has a variety of built-in template filters that allow you to alter variables in templates. These are Python<a id="_idIndexMarker298"/> functions that take one or two parameters, the value of the variable that the filter is applied to, and an optional argument. They return a value that can be displayed or treated by another filter.</p>
<p class="normal">A filter is written like <code class="inlineCode">{{ variable</code><code class="codeHighlighted" style="font-weight: bold;">|my_filter </code><code class="inlineCode">}}</code>. Filters with an argument are written like <code class="inlineCode">{{ variable</code><code class="codeHighlighted" style="font-weight: bold;">|my_filter:"foo" </code><code class="inlineCode">}}</code>. For example, you can use the <code class="inlineCode">capfirst</code> filter to capitalize the first character of the value, like <code class="inlineCode">{{ value</code><code class="codeHighlighted" style="font-weight: bold;">|capfirst </code><code class="inlineCode">}}</code>. If <code class="inlineCode">value</code> is <code class="inlineCode">django</code>, the output will be <code class="inlineCode">Django</code>. You can apply as many filters as you like to a variable, for example, <code class="inlineCode">{{ variable</code><code class="codeHighlighted" style="font-weight: bold;">|filter1|filter2 </code><code class="inlineCode">}}</code>, and each filter will be applied to the output generated by the preceding filter.</p>
<p class="normal">You can find the list of Django’s built-in template filters at <a href="https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#built-in-filter-reference">https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#built-in-filter-reference</a>.</p>
<h2 class="heading-2" id="_idParaDest-123">Creating a template filter to support Markdown syntax</h2>
<p class="normal">We will create a custom filter to enable you to use Markdown syntax in your blog posts and then convert the post body to HTML in the templates.</p>
<p class="normal">Markdown is a plain-text formatting <a id="_idIndexMarker299"/>syntax that is very simple to use, and it’s intended to be converted into HTML. You can write posts using simple Markdown syntax and get the content automatically converted into HTML code. Learning Markdown syntax is much easier than learning HTML. By using Markdown, you can get other non-tech-savvy contributors to easily write posts for your blog. You can learn the basics of the Markdown format at <a href="https://daringfireball.net/projects/markdown/basics">https://daringfireball.net/projects/markdown/basics</a>.</p>
<p class="normal">First, install the Python <code class="inlineCode">markdown</code> module via <code class="inlineCode">pip</code> using the following command in the shell prompt:</p>
<pre class="programlisting con"><code class="hljs-con">python -m pip install markdown==3.6
</code></pre>
<p class="normal">Then, edit the <code class="inlineCode">templatetags/blog_tags.py</code> file and include the following code:</p>
<pre class="programlisting code"><code class="hljs-code">import markdown
from django.utils.safestring import mark_safe
@register.filter(name='markdown')
def markdown_format(text):
    return mark_safe(markdown.markdown(text))
</code></pre>
<p class="normal">We register template filters in the same way as template tags. To prevent a name clash between the function <a id="_idIndexMarker300"/>name and the <code class="inlineCode">markdown</code> module, we have named the function <code class="inlineCode">markdown_format</code> and we have named the filter <code class="inlineCode">markdown</code> for use in templates, such as <code class="inlineCode">{{ variable|markdown }}</code>.</p>
<p class="normal">Django escapes the HTML code generated by filters; characters of HTML entities are replaced with their HTML-encoded characters. For example, <code class="inlineCode">&lt;p&gt;</code> is converted to <code class="inlineCode">&amp;lt;p&amp;gt;</code> (<em class="italic">less than</em> symbol, <em class="italic">p</em> character, <em class="italic">greater than</em> symbol).</p>
<p class="normal">We use the <code class="inlineCode">mark_safe</code> function provided by Django to mark the result as safe HTML to be rendered in the template. By default, Django will not trust any HTML code and will escape it before placing it in the output. The only exceptions are variables that are marked as safe from escaping. This behavior prevents Django from outputting potentially dangerous HTML and allows you to create exceptions for returning safe HTML.</p>
<div><p class="normal"> In Django, HTML content is escaped by default for security. Use <code class="inlineCode">mark_safe</code> cautiously, only on content you control. Avoid using <code class="inlineCode">mark_safe</code> on any content submitted by non-staff users to prevent security vulnerabilities.</p>
</div>
<p class="normal">Edit the <code class="inlineCode">blog/post/detail.html</code> template and add the following new code highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">{% extends "blog/base.html" %}
<strong class="hljs-slc">{% load blog_tags %}</strong>
{% block title %}{{ post.title }}{% endblock %}
{% block content %}
  &lt;h1&gt;{{ post.title }}&lt;/h1&gt;
&lt;p class="date"&gt;
    Published {{ post.publish }} by {{ post.author }}
  &lt;/p&gt;
  {{ post.body<strong class="hljs-slc">|markdown</strong> }}
  &lt;p&gt;
&lt;a href="{% url "blog:post_share" post.id %}"&gt;
      Share this post
    &lt;/a&gt;
&lt;/p&gt;
&lt;h2&gt;Similar posts&lt;/h2&gt;
  {% for post in similar_posts %}
    &lt;p&gt;
&lt;a href="{{ post.get_absolute_url }}"&gt;{{ post.title }}&lt;/a&gt;
&lt;/p&gt;
  {% empty %}
    There are no similar posts yet.
  {% endfor %}
  {% with comments.count as total_comments %}
    &lt;h2&gt;
      {{ total_comments }} comment{{ total_comments|pluralize }}
    &lt;/h2&gt;
  {% endwith %}
  {% for comment in comments %}
    &lt;div class="comment"&gt;
&lt;p class="info"&gt;
        Comment {{ forloop.counter }} by {{ comment.name }}
        {{ comment.created }}
      &lt;/p&gt;
      {{ comment.body|linebreaks }}
    &lt;/div&gt;
  {% empty %}
    &lt;p&gt;There are no comments yet.&lt;/p&gt;
  {% endfor %}
  {% include "blog/post/includes/comment_form.html" %}
{% endblock %}
</code></pre>
<p class="normal">We have replaced the <code class="inlineCode">linebreaks</code> filter of the <code class="inlineCode">{{ post.body }}</code> template variable with the <code class="inlineCode">markdown</code> filter. This filter <a id="_idIndexMarker301"/>will not only transform line breaks into <code class="inlineCode">&lt;p&gt;</code> tags; it will also transform Markdown formatting into HTML.</p>
<div><p class="normal">Storing text in Markdown format in the database, rather than HTML, is a wise security strategy. Markdown limits the potential for injecting malicious content. This approach ensures that any text formatting is safely converted to HTML only at the point of rendering the template.</p>
</div>
<p class="normal">Edit the <code class="inlineCode">blog/post/list.html</code> template<a id="_idIndexMarker302"/> and add the following new code highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">{% extends "blog/base.html" %}
<strong class="hljs-slc">{% load blog_tags %}</strong>
{% block title %}My Blog{% endblock %}
{% block content %}
  &lt;h1&gt;My Blog&lt;/h1&gt;
  {% if tag %}
    &lt;h2&gt;Posts tagged with "{{ tag.name }}"&lt;/h2&gt;
  {% endif %}
  {% for post in posts %}
    &lt;h2&gt;
&lt;a href="{{ post.get_absolute_url }}"&gt;
        {{ post.title }}
      &lt;/a&gt;
&lt;/h2&gt;
&lt;p class="tags"&gt;
      Tags:
      {% for tag in post.tags.all %}
        &lt;a href="{% url "blog:post_list_by_tag" tag.slug %}"&gt;
          {{ tag.name }}
        &lt;/a&gt;
        {% if not forloop.last %}, {% endif %}
      {% endfor %}
    &lt;/p&gt;
&lt;p class="date"&gt;
      Published {{ post.publish }} by {{ post.author }}
    &lt;/p&gt;
    {{ post.body<strong class="hljs-slc">|markdown|truncatewords_html:30</strong> }}
  {% endfor %}
  {% include "pagination.html" with page=posts %}
{% endblock %}
</code></pre>
<p class="normal">We have added the new <code class="inlineCode">markdown</code> filter to the <code class="inlineCode">{{ post.body }}</code> template variable. This filter will transform the Markdown content into HTML. </p>
<p class="normal">Therefore, we have replaced the previous <code class="inlineCode">truncatewords</code> filter with the <code class="inlineCode">truncatewords_html</code> filter. This filter truncates a string after a certain number of words, avoiding unclosed HTML tags.</p>
<p class="normal">Now open <code class="inlineCode">http://127.0.0.1:8000/admin/blog/post/add/</code> in your browser and create a new post with the<a id="_idIndexMarker303"/> following body:</p>
<pre class="programlisting code"><code class="hljs-code">This is a post formatted with markdown
--------------------------------------
*This is emphasized* and **this is more emphasized**.
Here is a list:
* One
* Two
* Three
And a [link to the Django website](https://www.djangoproject.com/).
</code></pre>
<p class="normal">The form should look like this:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_16.png"/></figure>
<p class="packt_figref">Figure 3.16: The post with Markdown content rendered as HTML</p>
<p class="normal">Open <code class="inlineCode">http://127.0.0.1:8000/blog/</code> in your <a id="_idIndexMarker304"/>browser and take a look at how the new post is rendered. You should see the following output:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_17.png"/></figure>
<p class="packt_figref">Figure 3.17: The post with Markdown content rendered as HTML</p>
<p class="normal">As you can see in <em class="italic">Figure 3.17</em>, custom <a id="_idIndexMarker305"/>template filters are very useful for customizing formatting. You can find more information about custom filters at <a href="https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/#writing-custom-template-filters">https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/#writing-custom-template-filters</a>.</p>
<h1 class="heading-1" id="_idParaDest-124">Adding a sitemap to the site</h1>
<p class="normal">Django comes with a sitemap framework, which allows you to generate sitemaps for your site dynamically. A sitemap<a id="_idIndexMarker306"/> is an XML file that tells search engines the pages of your website, their relevance, and how frequently they are updated. Using a sitemap will make your site more visible in search engine rankings because it helps crawlers to index your website’s content.</p>
<p class="normal">The Django sitemap framework depends on <code class="inlineCode">django.contrib.sites</code>, which allows you to associate objects to particular websites that are running with your project. This comes in handy when you want to run multiple sites using a single Django project. To install the sitemap framework, we will need to activate both the <code class="inlineCode">sites</code> and <code class="inlineCode">sitemap</code> applications in your project. We are going to build a sitemap for the blog that includes the links to all published posts.</p>
<p class="normal">Edit the <code class="inlineCode">settings.py</code> file of the project and add <code class="inlineCode">django.contrib.sites</code> and <code class="inlineCode">django.contrib.sitemaps</code> to the <code class="inlineCode">INSTALLED_APPS</code> setting. Also, define a new setting for the site ID, as follows. New<a id="_idIndexMarker307"/> code is highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code"># ...
<strong class="hljs-slc">SITE_ID = </strong><strong class="hljs-number-slc">1</strong>
# Application definition
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    <strong class="hljs-string-slc">'django.contrib.sites'</strong><strong class="hljs-slc">,</strong>
<strong class="hljs-string-slc">'django.contrib.sitemaps'</strong><strong class="hljs-slc">,</strong>
'django.contrib.staticfiles',
    'taggit',
    'blog.apps.BlogConfig',
]
</code></pre>
<p class="normal">Now, run the following command from the shell prompt to create the tables of the Django site application in the database:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py migrate
</code></pre>
<p class="normal">You should see an output that contains the following lines:</p>
<pre class="programlisting con"><code class="hljs-con">Applying sites.0001_initial... OK
Applying sites.0002_alter_domain_unique... OK
</code></pre>
<p class="normal">The <code class="inlineCode">sites</code> application is now synced with the database.</p>
<p class="normal">Next, create a new file inside your <code class="inlineCode">blog</code> application directory and name it <code class="inlineCode">sitemaps.py</code>. Open the file and add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">from django.contrib.sitemaps import Sitemap
from .models import Post
class PostSitemap(Sitemap):
    changefreq = 'weekly'
    priority = 0.9
def items(self):
        return Post.published.all()
    def lastmod(self, obj):
        return obj.updated
</code></pre>
<p class="normal">We have defined a custom sitemap by inheriting the <code class="inlineCode">Sitemap</code> class of the <code class="inlineCode">sitemaps</code> module. The <code class="inlineCode">changefreq</code> and <code class="inlineCode">priority</code> attributes indicate the change frequency of your post pages and their <a id="_idIndexMarker308"/>relevance in your website (the maximum value is <code class="inlineCode">1</code>).</p>
<p class="normal">The <code class="inlineCode">items()</code> method returns the QuerySet of objects to include in this sitemap. By default, Django calls the <code class="inlineCode">get_absolute_url()</code> method on each object to retrieve its URL. Remember that we implemented this method in <em class="italic">Chapter 2</em>, <em class="italic">Enhancing Your Blog with Advanced Features</em>, to define the canonical URL for posts. If you want to specify the URL for each object, you can add a <code class="inlineCode">location</code> method to your sitemap class.</p>
<p class="normal">The <code class="inlineCode">lastmod</code> method receives each object returned by <code class="inlineCode">items()</code> and returns the last time the object was modified.</p>
<p class="normal">Both the <code class="inlineCode">changefreq</code> and <code class="inlineCode">priority</code> attributes can be either methods or attributes. You can take a look at the complete sitemap reference in the official Django documentation located at <a href="https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/">https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/</a>.</p>
<p class="normal">We have created the sitemap. Now we just need to create a URL for it.</p>
<p class="normal">Edit the main <code class="inlineCode">urls.py</code> file of the <code class="inlineCode">mysite</code> project and add the sitemap, as follows. New lines are highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">from django.contrib import admin
<strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> django.contrib.sitemaps.views </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> sitemap</strong>
from django.urls import include, path
<strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> blog.sitemaps </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> PostSitemap</strong>
<strong class="hljs-slc">sitemaps = {</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'posts'</strong><strong class="hljs-slc">: PostSitemap,</strong>
<strong class="hljs-slc">}</strong>
urlpatterns = [
    path('admin/', admin.site.urls),
    path('blog/', include('blog.urls', namespace='blog')),
<strong class="hljs-slc">    path(</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'sitemap.xml'</strong><strong class="hljs-slc">,</strong>
<strong class="hljs-slc">        sitemap,</strong>
<strong class="hljs-slc">        {</strong><strong class="hljs-string-slc">'sitemaps'</strong><strong class="hljs-slc">: sitemaps},</strong>
<strong class="hljs-slc">        name=</strong><strong class="hljs-string-slc">'django.contrib.sitemaps.views.sitemap'</strong>
<strong class="hljs-slc">    )</strong>
]
</code></pre>
<p class="normal">In the preceding code, we have included the required imports and defined a <code class="inlineCode">sitemaps</code> dictionary. Multiple sitemaps can be defined for the site. We have defined a URL pattern that matches the <code class="inlineCode">sitemap.xml</code> pattern and uses the <code class="inlineCode">sitemap</code> view provided by Django. The <code class="inlineCode">sitemaps</code> dictionary is<a id="_idIndexMarker309"/> passed to the <code class="inlineCode">sitemap</code> view.</p>
<p class="normal">Start the development server from the shell prompt with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py runserver
</code></pre>
<p class="normal">Open <code class="inlineCode">http://127.0.0.1:8000/sitemap.xml</code> in your browser. You will see an XML output including all of the published posts, like this:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9" xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt;
&lt;url&gt;
&lt;loc&gt;http://example.com/blog/2024/1/2/markdown-post/&lt;/loc&gt;
&lt;lastmod&gt;2024-01-02&lt;/lastmod&gt;
&lt;changefreq&gt;weekly&lt;/changefreq&gt;
&lt;priority&gt;0.9&lt;/priority&gt;
&lt;/url&gt;
&lt;url&gt;
&lt;loc&gt;http://example.com/blog/2024/1/2/notes-on-duke-ellington/&lt;/loc&gt;
&lt;lastmod&gt;2024-01-02&lt;/lastmod&gt;
&lt;changefreq&gt;weekly&lt;/changefreqa&gt;
&lt;priority&gt;0.9&lt;/priority&gt;
&lt;/url&gt;
&lt;url&gt;
&lt;loc&gt;http://example.com/blog/2024/1/2/who-was-miles-davis/&lt;/loc&gt;
&lt;lastmod&gt;2024-01-02&lt;/lastmod&gt;
&lt;changefreq&gt;weekly&lt;/changefreq&gt;
&lt;priority&gt;0.9&lt;/priority&gt;
&lt;/url&gt;
&lt;url&gt;
&lt;loc&gt;http://example.com/blog/2024/1/1/who-was-django-reinhardt/&lt;/loc&gt;
&lt;lastmod&gt;2024-01-01&lt;/lastmod&gt;
&lt;changefreq&gt;weekly&lt;/changefreq&gt;
&lt;priority&gt;0.9&lt;/priority&gt;
&lt;/url&gt;
&lt;url&gt;
&lt;loc&gt;http://example.com/blog/2024/1/1/another-post/&lt;/loc&gt;
&lt;lastmod&gt;2024-01-01&lt;/lastmod&gt;
&lt;changefreq&gt;weekly&lt;/changefreq&gt;
&lt;priority&gt;0.9&lt;/priority&gt;
&lt;/url&gt;
&lt;/urlset&gt;
</code></pre>
<p class="normal">The URL for each <code class="inlineCode">Post</code> object is built by calling its <code class="inlineCode">get_absolute_url()</code> method.</p>
<p class="normal">The <code class="inlineCode">lastmod</code> attribute corresponds<a id="_idIndexMarker310"/> to the post <code class="inlineCode">updated</code> date field, as you specified in your sitemap, and the <code class="inlineCode">changefreq</code> and <code class="inlineCode">priority</code> attributes are also taken from the <code class="inlineCode">PostSitemap</code> class.</p>
<p class="normal">The domain used to build the URLs is <code class="inlineCode">example.com</code>. This domain comes from a <code class="inlineCode">Site</code> object stored in the database. This default object was created when you synced the site’s framework with your database. You can read more about the <code class="inlineCode">sites</code> framework at <a href="https://docs.djangoproject.com/en/5.0/ref/contrib/sites/">https://docs.djangoproject.com/en/5.0/ref/contrib/sites/</a>.</p>
<p class="normal">Open <code class="inlineCode">http://127.0.0.1:8000/admin/sites/site/</code> in your browser. You should see something like this:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_18.png"/></figure>
<p class="packt_figref">Figure 3.18: The Django administration list view for the Site model of the site’s framework</p>
<p class="normal"><em class="italic">Figure 3.18</em> contains the list display administration view for the site’s framework. Here, you can set the domain or <a id="_idIndexMarker311"/>host to be used by the site’s framework and the applications that depend on it. To generate URLs that exist in your local environment, change the domain name to <code class="inlineCode">localhost:8000</code>, as shown in <em class="italic">Figure 3.19</em>, and save it:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_19.png"/></figure>
<p class="packt_figref">Figure 3.19: The Django administration edit view for the Site model of the site’s framework</p>
<p class="normal">Open <code class="inlineCode">http://127.0.0.1:8000/sitemap.xml</code> in your browser again. The URLs displayed in your sitemap will now use the new hostname and look like <code class="inlineCode">http://localhost:8000/blog/2024/1/22/markdown-post/</code>. Links are now accessible in your local environment. In a production environment, you will have to use your website’s domain to <a id="_idIndexMarker312"/>generate absolute URLs.</p>
<h1 class="heading-1" id="_idParaDest-125">Creating feeds for blog posts</h1>
<p class="normal">Django has a built-in syndication feed framework that you can use to dynamically generate RSS or Atom feeds <a id="_idIndexMarker313"/>in a similar manner to creating sitemaps using the site’s framework. A web feed is a data format (usually XML) that provides users with the most<a id="_idIndexMarker314"/> recently updated content. Users can subscribe to the feed using a feed aggregator, a software that is used to read feeds and get new content notifications.</p>
<p class="normal">Create a new file in your <code class="inlineCode">blog</code> application directory and name it <code class="inlineCode">feeds.py</code>. Add the following lines to it:</p>
<pre class="programlisting code"><code class="hljs-code">import markdown
from django.contrib.syndication.views import Feed
from django.template.defaultfilters import truncatewords_html
from django.urls import reverse_lazy
from .models import Post
class LatestPostsFeed(Feed):
    title = 'My blog'
    link = reverse_lazy('blog:post_list')
    description = 'New posts of my blog.'
def items(self):
        return Post.published.all()[:5]
    def item_title(self, item):
        return item.title
    def item_description(self, item):
        return truncatewords_html(markdown.markdown(item.body), 30)
    def item_pubdate(self, item):
        return item.publish
</code></pre>
<p class="normal">In the preceding code, we have defined a feed by subclassing the <code class="inlineCode">Feed</code> class of the syndication framework. The <code class="inlineCode">title</code>, <code class="inlineCode">link</code>, and <code class="inlineCode">description</code> attributes correspond to the <code class="inlineCode">&lt;title&gt;</code>, <code class="inlineCode">&lt;link&gt;</code>, and <code class="inlineCode">&lt;description&gt;</code> RSS elements, respectively.</p>
<p class="normal">We use <code class="inlineCode">reverse_lazy()</code> to generate the URL for the <code class="inlineCode">link</code> attribute. The <code class="inlineCode">reverse()</code> method allows you to build URLs by their name and pass optional parameters. We used <code class="inlineCode">reverse()</code> in <em class="italic">Chapter 2</em>, <em class="italic">Enhancing Your Blog with Advanced Features</em>.</p>
<p class="normal">The <code class="inlineCode">reverse_lazy()</code> utility function is a lazily evaluated version of <code class="inlineCode">reverse()</code>. It allows you to use a URL reversal before the <a id="_idIndexMarker315"/>project’s URL configuration is loaded.</p>
<p class="normal">The <code class="inlineCode">items()</code> method<a id="_idIndexMarker316"/> retrieves the objects to be included in the feed. We retrieve the last five published posts to include them in the feed.</p>
<p class="normal">The <code class="inlineCode">item_title()</code>, <code class="inlineCode">item_description()</code>, and <code class="inlineCode">item_pubdate()</code> methods will receive each object returned by <code class="inlineCode">items()</code> and return the title, description, and publication date for each item.</p>
<p class="normal">In the <code class="inlineCode">item_description()</code> method, we use the <code class="inlineCode">markdown()</code> function to convert Markdown content to HTML and the <code class="inlineCode">truncatewords_html()</code> template filter function to cut the description of posts after 30 words, avoiding unclosed HTML tags.</p>
<p class="normal">Now, edit the <code class="inlineCode">blog/urls.py</code> file, import the <code class="inlineCode">LatestPostsFeed</code> class, and instantiate the feed in a new URL pattern, as follows. New lines are highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">from django.urls import path
from . import views
<strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> .feeds </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> LatestPostsFeed</strong>
app_name = 'blog'
urlpatterns = [
    # Post views
    path('', views.post_list, name='post_list'),
    # path('', views.PostListView.as_view(), name='post_list'),
    path(
        'tag/&lt;slug:tag_slug&gt;/', views.post_list, name='post_list_by_tag'
 ),
    path(
        '&lt;int:year&gt;/&lt;int:month&gt;/&lt;int:day&gt;/&lt;slug:post&gt;/',
        views.post_detail,
        name='post_detail'
 ),
    path('&lt;int:post_id&gt;/share/', views.post_share, name='post_share'),
    path(
        '&lt;int:post_id&gt;/comment/', views.post_comment, name='post_comment'
 ),
    <strong class="hljs-slc">path(</strong><strong class="hljs-string-slc">'feed/'</strong><strong class="hljs-slc">, LatestPostsFeed(), name=</strong><strong class="hljs-string-slc">'post_feed'</strong><strong class="hljs-slc">),</strong>
]
</code></pre>
<p class="normal">Navigate to <code class="inlineCode">http://127.0.0.1:8000/blog/feed/</code> in your browser. You should now see the RSS feed, including the<a id="_idIndexMarker317"/> last five blog posts:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"&gt;
&lt;channel&gt;
&lt;title&gt;My blog&lt;/title&gt;
&lt;link&gt;http://localhost:8000/blog/&lt;/link&gt;
&lt;description&gt;New posts of my blog.&lt;/description&gt;
&lt;atom:link href="http://localhost:8000/blog/feed/" rel="self"/&gt;
&lt;language&gt;en-us&lt;/language&gt;
&lt;lastBuildDate&gt;Tue, 02 Jan 2024 16:30:00 +0000&lt;/lastBuildDate&gt;
&lt;item&gt;
&lt;title&gt;Markdown post&lt;/title&gt;
&lt;link&gt;http://localhost:8000/blog/2024/1/2/markdown-post/&lt;/link&gt;
&lt;description&gt;This is a post formatted with ...&lt;/description&gt;
&lt;guid&gt;http://localhost:8000/blog/2024/1/2/markdown-post/&lt;/guid&gt;
&lt;/item&gt;
    ...
  &lt;/channel&gt;
&lt;/rss&gt;
</code></pre>
<p class="normal">If you use Chrome, you will <a id="_idIndexMarker318"/>see the XML code. If you use Safari, it will ask you to install an RSS feed reader.</p>
<p class="normal">Let’s install an RSS desktop client to view the RSS feed with a user-friendly interface. We will use Fluent Reader, which is a multi-platform RSS reader.</p>
<p class="normal">Download Fluent Reader for Linux, macOS, or Windows from <a href="https://github.com/yang991178/fluent-reader/releases">https://github.com/yang991178/fluent-reader/releases</a>.</p>
<p class="normal">Install Fluent Reader and open it. You will see the following screen:</p>
<figure class="mediaobject"><img alt="A picture containing chart  Description automatically generated" src="img/B21088_03_20.png"/></figure>
<p class="packt_figref">Figure 3.20: Fluent Reader with no RSS feed sources</p>
<p class="normal">Click on the settings icon in the top-right<a id="_idIndexMarker319"/> corner of the window. You will see a screen to add RSS feed sources<a id="_idIndexMarker320"/> like the following one:</p>
<figure class="mediaobject"><img alt="Text  Description automatically generated" src="img/B21088_03_21.png"/></figure>
<p class="packt_figref">Figure 3.21: Adding an RSS feed in Fluent Reader</p>
<p class="normal">Enter <code class="inlineCode">http://127.0.0.1:8000/blog/feed/</code> in the <strong class="screenText">Add source</strong> field and click on the <strong class="screenText">Add </strong>button.</p>
<p class="normal">You will see a new entry with the RSS feed of the blog in the table below the form, like this:</p>
<figure class="mediaobject"><img alt="Graphical user interface, text, application, email  Description automatically generated" src="img/B21088_03_22.png"/></figure>
<p class="packt_figref">Figure 3.22: RSS feed sources in Fluent Reader</p>
<p class="normal">Now, go back to the main screen <a id="_idIndexMarker321"/>of Fluent Reader. You should be able to see the posts<a id="_idIndexMarker322"/> included in the blog RSS feed, as follows:</p>
<figure class="mediaobject"><img alt="Graphical user interface, text  Description automatically generated" src="img/B21088_03_23.png"/></figure>
<p class="packt_figref">Figure 3.23: RSS feed of the blog in Fluent Reader</p>
<p class="normal">Click on a post to see a description:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_24.png"/></figure>
<p class="packt_figref">Figure 3.24: The post description in Fluent Reader</p>
<p class="normal">Click on the third icon<a id="_idIndexMarker323"/> in the top-right corner of the window to load the full content of the <a id="_idIndexMarker324"/>post page:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_25.png"/></figure>
<p class="packt_figref">Figure 3.25: The full content of a post in Fluent Reader</p>
<p class="normal">The final step is to <a id="_idIndexMarker325"/>add an RSS feed subscription link to the blog’s sidebar.</p>
<p class="normal">Open the <code class="inlineCode">blog/base.html</code> template and<a id="_idIndexMarker326"/> add the following code highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">{% load blog_tags %}
{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;{% block title %}{% endblock %}&lt;/title&gt;
&lt;link href="{% static "css/blog.css" %}" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="content"&gt;
    {% block content %}
    {% endblock %}
  &lt;/div&gt;
&lt;div id="sidebar"&gt;
&lt;h2&gt;My blog&lt;/h2&gt;
&lt;p&gt;
      This is my blog.
      I've written {% total_posts %} posts so far.
    &lt;/p&gt;
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">p</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">a</strong><strong class="hljs-tag-slc"> </strong><strong class="hljs-attr-slc">href</strong><strong class="hljs-tag-slc">=</strong><strong class="hljs-string-slc">"{% url "</strong><strong class="hljs-attr-slc">blog:post_feed</strong><strong class="hljs-tag-slc">" %}"&gt;</strong>
<strong class="hljs-slc">        Subscribe to my RSS feed</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">a</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">p</strong><strong class="hljs-tag-slc">&gt;</strong>
&lt;h3&gt;Latest posts&lt;/h3&gt;
    {% show_latest_posts 3 %}
    &lt;h3&gt;Most commented posts&lt;/h3&gt;
    {% get_most_commented_posts as most_commented_posts %}
    &lt;ul&gt;
      {% for post in most_commented_posts %}
        &lt;li&gt;
&lt;a href="{{ post.get_absolute_url }}"&gt;{{ post.title }}&lt;/a&gt;
&lt;/li&gt;
      {% endfor %}
    &lt;/ul&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">Now open <code class="inlineCode">http://127.0.0.1:8000/blog/</code> in your browser <a id="_idIndexMarker327"/>and take a look at the sidebar. The new<a id="_idIndexMarker328"/> link will take users to the blog’s feed:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_26.png"/></figure>
<p class="packt_figref">Figure 3.26: The RSS feed subscription link added to the sidebar</p>
<p class="normal">You can<a id="_idIndexMarker329"/> read more <a id="_idIndexMarker330"/>about the Django syndication feed framework at <a href="https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/">https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/</a>.</p>
<h1 class="heading-1" id="_idParaDest-126">Adding full-text search to the blog</h1>
<p class="normal">Next, we will add search capabilities to the<a id="_idIndexMarker331"/> blog. Searching for data in the database with user input is a common task for web applications. The Django <a id="_idIndexMarker332"/>ORM allows you to perform simple matching operations using, for example, the <code class="inlineCode">contains</code> filter (or its case-insensitive version, <code class="inlineCode">icontains</code>). You can use the following query to find posts that contain the word <code class="inlineCode">framework</code> in their body:</p>
<pre class="programlisting code"><code class="hljs-code">from blog.models import Post
Post.objects.filter(body__contains='framework')
</code></pre>
<p class="normal">However, if you want to perform complex search lookups, retrieving results by similarity, or by weighting terms based on how frequently they appear in the text or how important different fields are (for example, the relevancy of the term appearing in the title versus in the body), you will need to use a full-text search engine. When you consider large blocks of text, building queries with operations on a string of characters is not enough. A full-text search examines the<a id="_idIndexMarker333"/> actual words against stored content as it tries to match search criteria.</p>
<p class="normal">Django provides a powerful <a id="_idIndexMarker334"/>search functionality built on top of PostgreSQL database full-text search features. The <code class="inlineCode">django.contrib.postgres</code> module provides functionalities offered by PostgreSQL that are not shared by the other databases that Django supports. You can learn about PostgreSQL’s full-text search support at <a href="https://www.postgresql.org/docs/16/textsearch.html">https://www.postgresql.org/docs/16/textsearch.html</a>.</p>
<div><p class="normal">Although Django is a database-agnostic web framework, it provides a module that supports part of the rich feature set offered by PostgreSQL, which is not offered by other databases that Django supports.</p>
</div>
<p class="normal">We are currently using an SQLite database for the <code class="inlineCode">mysite</code> project. SQLite support for full-text search is limited and Django doesn’t support it out of the box. However, PostgreSQL is much better suited for full-text search and we can use the <code class="inlineCode">django.contrib.postgres</code> module to use PostgreSQL’s full-text search capabilities. We will migrate our data from SQLite to PostgreSQL to benefit from its full-text search features.</p>
<div><p class="normal">SQLite is sufficient for development purposes. However, for a production environment, you will need a more powerful database, such as PostgreSQL, MariaDB, MySQL, or Oracle.</p>
</div>
<p class="normal">PostgreSQL provides a Docker image that makes it very easy to deploy a PostgreSQL server with a standard configuration.</p>
<h2 class="heading-2" id="_idParaDest-127">Installing Docker</h2>
<p class="normal">Docker is a popular <a id="_idIndexMarker335"/>open-source containerization platform. It enables <a id="_idIndexMarker336"/>developers to package applications into containers, simplifying the process of building, running, managing, and distributing applications.</p>
<p class="normal">First, download and install Docker for your OS. You will find instructions for downloading and installing<a id="_idIndexMarker337"/> Docker on Linux, macOS, and Windows at <a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a>. The installation includes both Docker Desktop and Docker command-line interface <a id="_idIndexMarker338"/>tools.</p>
<h2 class="heading-2" id="_idParaDest-128">Installing PostgreSQL</h2>
<p class="normal">After installing Docker on <a id="_idIndexMarker339"/>your Linux, macOS, or Windows machine, you <a id="_idIndexMarker340"/>can easily pull the PostgreSQL Docker image. Run the following command from the shell:</p>
<pre class="programlisting con"><code class="hljs-con">docker pull postgres:16.2
</code></pre>
<p class="normal">This will download the PostgreSQL Docker image to your local machine. You can find information about the official PostgreSQL Docker image at <a href="https://hub.docker.com/_/postgres">https://hub.docker.com/_/postgres</a>. You can find other PostgreSQL packages and installers at <a href="https://www.postgresql.org/download/">https://www.postgresql.org/download/</a>.</p>
<p class="normal">Execute the following command in the shell to start the PostgreSQL Docker container:</p>
<pre class="programlisting con"><code class="hljs-con">docker run --name=blog_db -e POSRGRES_DB=blog -e POSTGRES_USER=blog -e POSTGRES_PASSWORD=xxxxx -p 5432:5432 -d postgres:16.2
</code></pre>
<p class="normal">Replace <code class="inlineCode">xxxxx</code> with the desired password for your database user.</p>
<p class="normal">This command starts a PostgreSQL instance. The <code class="inlineCode">--name</code> option is used to assign a name to the container, in this case, <code class="inlineCode">blog_db</code>. The <code class="inlineCode">-e</code> option is to define environment variables for the instance. We set the following environment variables:</p>
<ul>
<li class="bulletList"><code class="inlineCode">POSTGRES_DB</code>: Name of the PostgreSQL database. If not defined, the value of <code class="inlineCode">POSTGRES_USER</code> is used for the database name.</li>
<li class="bulletList"><code class="inlineCode">POSTGRES_USER</code>: Used in conjunction with <code class="inlineCode">POSTGRES_PASSWORD</code> to define a username and password. The user is created with superuser power.</li>
<li class="bulletList"><code class="inlineCode">POSTGRES_PASSWORD</code>: Sets the superuser password for PostgreSQL.</li>
</ul>
<p class="normal">The <code class="inlineCode">-p</code> option is used to publish the <code class="inlineCode">5432</code> port, on which PostgreSQL runs, to the same host interface port. This allows external applications to access the database. The <code class="inlineCode">-d</code> option is for <em class="italic">detached mode</em>, which runs the Docker container in the background.</p>
<p class="normal">Open the Docker Desktop application. You should see the new container running, as in <em class="italic">Figure 3.27</em>:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_27.png"/></figure>
<p class="packt_figref">Figure 3.27: PostgreSQL instance running in Docker Desktop</p>
<p class="normal">You will see the newly created <code class="inlineCode">blog_db</code> container, with the status <strong class="screenText">Running</strong>. Under <strong class="screenText">Actions</strong>, you can stop or restart the service. You can also delete the container. Note that deleting the container will also eliminate the database and all the data it contains. You will learn how to persist <a id="_idIndexMarker341"/>PostgreSQL data in the local filesystem using Docker in <em class="chapterRef">Chapter 17</em>, <em class="italic">Going Live</em>.</p>
<p class="normal">You also need to install the <code class="inlineCode">psycopg</code> PostgreSQL<a id="_idIndexMarker342"/> adapter for Python. Run the following command in the shell prompt to install it:</p>
<pre class="programlisting con"><code class="hljs-con">python -m pip install psycopg==3.1.18
</code></pre>
<p class="normal">Next, we will migrate the existing data in the SQLite database to the new PostgreSQL instance.</p>
<h2 class="heading-2" id="_idParaDest-129">Dumping the existing data</h2>
<p class="normal">Before switching the database<a id="_idIndexMarker343"/> in the Django project, we need to dump the existing data from the SQLite database. We will export the data, switch the project’s database to PostgreSQL, and import the data into the new database.</p>
<p class="normal">Django comes with a simple way to load and dump data from the database into files that are called <strong class="keyWord">fixtures</strong>. Django supports fixtures<a id="_idIndexMarker344"/> in JSON, XML, or YAML format. We are going to create a fixture with all data contained in the database.</p>
<p class="normal">The <code class="inlineCode">dumpdata</code> command dumps data from the database into the standard output, serialized in JSON format by default. The resulting data structure includes information about the model and its fields for Django to be able to load it into the database.</p>
<p class="normal">You can limit the output to the models of an application by providing the application names to the command, or specifying single models for outputting data using the <code class="inlineCode">app.Model</code> format. You can also specify the format using the <code class="inlineCode">--format</code> flag. By default, <code class="inlineCode">dumpdata</code> outputs the serialized data to the standard output. However, you can indicate an output file using the <code class="inlineCode">--output</code> flag. The <code class="inlineCode">--indent</code> flag allows you to specify indentation. For more information on <code class="inlineCode">dumpdata</code> parameters, run <code class="inlineCode">python manage.py dumpdata --help</code>.</p>
<p class="normal">Execute the following command from the shell prompt:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py dumpdata --indent=2 --output=mysite_data.json
</code></pre>
<p class="normal">All existing data has been <a id="_idIndexMarker345"/>exported in JSON format to a new file named <code class="inlineCode">mysite_data.json</code>. You can view the file contents to see the JSON structure that includes all the different data objects for the different models of your installed applications. If you get an encoding error when running the command, include the <code class="inlineCode">-Xutf8</code> flag as follows to activate Python UTF-8 mode:</p>
<pre class="programlisting con"><code class="hljs-con">python -Xutf8 manage.py dumpdata --indent=2 --output=mysite_data.json
</code></pre>
<p class="normal">We will now switch the database in the Django project and then we will import the data into the new database.</p>
<h2 class="heading-2" id="_idParaDest-130">Switching the database in the project</h2>
<p class="normal">Now you will add the PostgreSQL database <a id="_idIndexMarker346"/>configuration to your project settings.</p>
<p class="normal">Edit the <code class="inlineCode">settings.py</code> file of your project and modify the <code class="inlineCode">DATABASES</code> setting to make it look as follows. New code is highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.<strong class="hljs-string-slc">postgresql</strong>',
        'NAME': <strong class="hljs-slc">config(</strong><strong class="hljs-string-slc">'DB_NAME'</strong><strong class="hljs-slc">),</strong>
<strong class="hljs-string-slc">'USER'</strong><strong class="hljs-slc">: config(</strong><strong class="hljs-string-slc">'DB_USER'</strong><strong class="hljs-slc">),</strong>
<strong class="hljs-string-slc">'PASSWORD'</strong><strong class="hljs-slc">: config(</strong><strong class="hljs-string-slc">'DB_PASSWORD'</strong><strong class="hljs-slc">),</strong>
<strong class="hljs-string-slc">'HOST'</strong><strong class="hljs-slc">: config(</strong><strong class="hljs-string-slc">'DB_HOST'</strong><strong class="hljs-slc">),</strong>
    }
}
</code></pre>
<p class="normal">The database engine is now <code class="inlineCode">postgresql</code>. The database credentials are now loaded from environment variables using <code class="inlineCode">python-decouple</code>.</p>
<p class="normal">Let’s add values to the environment variables. Edit the <code class="inlineCode">.env</code> file of your project and add the following lines highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">EMAIL_HOST_USER=your_account@gmail.com
EMAIL_HOST_PASSWORD=xxxxxxxxxxxx
DEFAULT_FROM_EMAIL=My Blog &lt;your_account@gmail.com&gt;
<strong class="hljs-slc">DB_NAME=blog</strong>
<strong class="hljs-slc">DB_USER=blog</strong>
<strong class="hljs-slc">DB_PASSWORD=xxxxx</strong>
<strong class="hljs-slc">DB_HOST=localhost</strong>
</code></pre>
<p class="normal">Replace <code class="inlineCode">xxxxxx</code> with the password<a id="_idIndexMarker347"/> you used when starting the PostgreSQL container. The new database is empty.</p>
<p class="normal">Run the following command to apply all database migrations to the new PostgreSQL database:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py migrate
</code></pre>
<p class="normal">You will see an output, including all the migrations that have been applied, like this:</p>
<pre class="programlisting con"><code class="hljs-con">Operations to perform:
  Apply all migrations: admin, auth, blog, contenttypes, sessions, sites, taggit
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying taggit.0001_initial... OK
  Applying taggit.0002_auto_20150616_2121... OK
  Applying taggit.0003_taggeditem_add_unique_index... OK
  Applying taggit.0004_alter_taggeditem_content_type_alter_taggeditem_tag... OK
  Applying taggit.0005_auto_20220424_2025... OK
  Applying taggit.0006_rename_taggeditem_content_type_object_id_taggit_tagg_content_8fc721_idx... OK
  Applying blog.0001_initial... OK
  Applying blog.0002_alter_post_slug... OK
  Applying blog.0003_comment... OK
  Applying blog.0004_post_tags... OK
  Applying sessions.0001_initial... OK
  Applying sites.0001_initial... OK
  Applying sites.0002_alter_domain_unique... OK
</code></pre>
<p class="normal">The PostgreSQL database is now in sync with your data models and you can run your Django project pointing to the new database. Let’s get the database to the same state by loading the data we <a id="_idIndexMarker348"/>previously exported from SQLite.</p>
<h2 class="heading-2" id="_idParaDest-131">Loading the data into the new database</h2>
<p class="normal">We are going to load the data fixtures we<a id="_idIndexMarker349"/> generated previously into our new PostgreSQL database.</p>
<p class="normal">Run the following command to load the previously exported data into the PostgreSQL database:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py loaddata mysite_data.json
</code></pre>
<p class="normal">You will see the following output:</p>
<pre class="programlisting con"><code class="hljs-con">Installed 104 object(s) from 1 fixture(s)
</code></pre>
<p class="normal">The number of objects might differ, depending on the users, posts, comments, and other objects that have been created in the database.</p>
<p class="normal">Start the development server from the shell prompt with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py runserver
</code></pre>
<p class="normal">Open <code class="inlineCode">http://127.0.0.1:8000/admin/blog/post/</code> in your browser to verify that all posts have been loaded<a id="_idIndexMarker350"/> into the new database. You should see all the posts, as follows:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_28.png"/></figure>
<p class="packt_figref">Figure 3.28: The list of posts on the administration site</p>
<h2 class="heading-2" id="_idParaDest-132">Simple search lookups</h2>
<p class="normal">Having enabled PostgreSQL in our project, we can now build a powerful search engine by leveraging PostgreSQL’s full-text search capabilities. We will begin with basic search lookups and progressively incorporate<a id="_idIndexMarker351"/> more sophisticated features, such as stemming, ranking, or weighting queries, to build a comprehensive full-text search engine.</p>
<p class="normal">Edit the <code class="inlineCode">settings.py</code> file of your project and add <code class="inlineCode">django.contrib.postgres</code> to the <code class="inlineCode">INSTALLED_APPS</code> setting, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.sites',
    'django.contrib.sitemaps',
    'django.contrib.staticfiles',
<strong class="hljs-string-slc">    'django.contrib.postgres'</strong><strong class="hljs-slc">,</strong>
'taggit',
    'blog.apps.BlogConfig',
]
</code></pre>
<p class="normal">Open the Django shell by running the following command in the system shell prompt:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py shell
</code></pre>
<p class="normal">Now you can search against a single field using the <code class="inlineCode">search</code> QuerySet lookup.</p>
<p class="normal">Run the following code in the Python shell:</p>
<pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from blog.models import Post
&gt;&gt;&gt; Post.objects.filter(title__search='django')
&lt;QuerySet [&lt;Post: Who was Django Reinhardt?&gt;]&gt;
</code></pre>
<p class="normal">This query uses PostgreSQL to create<a id="_idIndexMarker352"/> a search vector for the <code class="inlineCode">title</code> field and a search query from the term <code class="inlineCode">django</code>. Results are obtained by matching the query with the vector.</p>
<h2 class="heading-2" id="_idParaDest-133">Searching against multiple fields</h2>
<p class="normal">You might want to search against <a id="_idIndexMarker353"/>multiple fields. In this case, you will need to define a <code class="inlineCode">SearchVector</code> object. Let’s build a vector that allows you to search against the <code class="inlineCode">title</code> and <code class="inlineCode">body</code> fields of the <code class="inlineCode">Post</code> model.</p>
<p class="normal">Run the following code in the Python shell:</p>
<pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from django.contrib.postgres.search import SearchVector
&gt;&gt;&gt; from blog.models import Post
&gt;&gt;&gt;
&gt;&gt;&gt; Post.objects.annotate(
...     search=SearchVector('title', 'body'),
... ).filter(search='django')
&lt;QuerySet [&lt;Post: Markdown post&gt;, &lt;Post: Who was Django Reinhardt?&gt;]&gt;
</code></pre>
<p class="normal">Using <code class="inlineCode">annotate</code> and defining <code class="inlineCode">SearchVector</code> with both fields, you provide a functionality to match the query against both the <code class="inlineCode">title</code> and <code class="inlineCode">body</code> of the posts.</p>
<div><p class="normal">Full-text search is an intensive process. If you are searching for more than a few hundred rows, you should define a functional index that matches the search vector you are using. Django provides a <code class="inlineCode">SearchVectorField</code> field for your models. You can read more about this at <a href="https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/#performance">https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/#performance</a>.</p>
</div>
<h2 class="heading-2" id="_idParaDest-134">Building a search view</h2>
<p class="normal">Now, you will create a<a id="_idIndexMarker354"/> custom view to allow your users to search posts. First, you will need a search form. Edit the <code class="inlineCode">forms.py</code> file of the <code class="inlineCode">blog</code> application and add the following form:</p>
<pre class="programlisting code"><code class="hljs-code">class SearchForm(forms.Form):
    query = forms.CharField()
</code></pre>
<p class="normal">You will use the <code class="inlineCode">query</code> field to let users introduce search terms. Edit the <code class="inlineCode">views.py</code> file of the <code class="inlineCode">blog</code> application and add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code"># ...
<strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> django.contrib.postgres.search </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> SearchVector</strong>
from .forms import CommentForm, EmailPostForm<strong class="hljs-slc">, SearchForm</strong>
# ...
<strong class="hljs-keyword-slc">def</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">post_search</strong><strong class="hljs-slc">(</strong><strong class="hljs-params-slc">request</strong><strong class="hljs-slc">):</strong>
<strong class="hljs-slc">form = SearchForm()</strong>
<strong class="hljs-slc">query = </strong><strong class="hljs-literal-slc">None</strong>
<strong class="hljs-slc">results = []</strong>
<strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'query'</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">in</strong><strong class="hljs-slc"> request.GET:</strong>
<strong class="hljs-slc">form = SearchForm(request.GET)</strong>
<strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> form.is_valid():</strong>
<strong class="hljs-slc">query = form.cleaned_data[</strong><strong class="hljs-string-slc">'query'</strong><strong class="hljs-slc">]</strong>
<strong class="hljs-slc">results = (</strong>
<strong class="hljs-slc">                Post.published.annotate(</strong>
<strong class="hljs-slc">search=SearchVector(</strong><strong class="hljs-string-slc">'title'</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">'body'</strong><strong class="hljs-slc">),</strong>
<strong class="hljs-slc">)</strong>
<strong class="hljs-slc">                .</strong><strong class="hljs-built_in-slc">filter</strong><strong class="hljs-slc">(search=query)</strong>
<strong class="hljs-slc">            )</strong>
<strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> render(</strong>
<strong class="hljs-keyword-slc"> </strong><strong class="hljs-slc">request,</strong>
<strong class="hljs-keyword-slc"> </strong><strong class="hljs-string-slc">'blog/post/search.html'</strong><strong class="hljs-slc">,</strong>
<strong class="hljs-keyword-slc"> </strong><strong class="hljs-slc">{</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'form'</strong><strong class="hljs-slc">: form,</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'query'</strong><strong class="hljs-slc">: query,</strong>
<strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'results'</strong><strong class="hljs-slc">: results</strong>
<strong class="hljs-string-slc"> </strong><strong class="hljs-slc">}</strong>
<strong class="hljs-slc">    )</strong>
</code></pre>
<p class="normal">In the preceding view, first, we instantiate the <code class="inlineCode">SearchForm</code> form. To check whether the form is submitted, we look for the <code class="inlineCode">query</code> parameter in the <code class="inlineCode">request.GET</code> dictionary. We send the form using the <code class="inlineCode">GET</code> method instead of <code class="inlineCode">POST</code> so that the resulting URL includes the <code class="inlineCode">query</code> parameter and is <a id="_idIndexMarker355"/>easy to share. When the form is submitted, we instantiate it with the submitted <code class="inlineCode">GET</code> data and verify that the form data is valid. If the form is valid, we search for published posts with a custom <code class="inlineCode">SearchVector</code> instance built with the <code class="inlineCode">title</code> and <code class="inlineCode">body</code> fields.</p>
<p class="normal">The search view is now ready. We need to create a template to display the form and the results when the user performs a search.</p>
<p class="normal">Create a new file inside the <code class="inlineCode">templates/blog/post/</code> directory, name it <code class="inlineCode">search.html</code>, and add the following code to it:</p>
<pre class="programlisting code"><code class="hljs-code">{% extends "blog/base.html" %}
{% load blog_tags %}
{% block title %}Search{% endblock %}
{% block content %}
  {% if query %}
    &lt;h1&gt;Posts containing "{{ query }}"&lt;/h1&gt;
&lt;h3&gt;
      {% with results.count as total_results %}
        Found {{ total_results }} result{{ total_results|pluralize }}
      {% endwith %}
    &lt;/h3&gt;
    {% for post in results %}
      &lt;h4&gt;
&lt;a href="{{ post.get_absolute_url }}"&gt;
          {{ post.title }}
        &lt;/a&gt;
&lt;/h4&gt;
      {{ post.body|markdown|truncatewords_html:12 }}
    {% empty %}
      &lt;p&gt;There are no results for your query.&lt;/p&gt;
    {% endfor %}
    &lt;p&gt;&lt;a href="{% url "blog:post_search" %}"&gt;Search again&lt;/a&gt;&lt;/p&gt;
  {% else %}
    &lt;h1&gt;Search for posts&lt;/h1&gt;
&lt;form method="get"&gt;
      {{ form.as_p }}
      &lt;input type="submit" value="Search"&gt;
&lt;/form&gt;
  {% endif %}
{% endblock %}
</code></pre>
<p class="normal">As in the search view, we distinguish whether the form has been submitted by the presence of the <code class="inlineCode">query</code> parameter. Before<a id="_idIndexMarker356"/> the query is submitted, we display the form and a submit button. When the search form is submitted, we display the query performed, the total number of results, and the list of posts that match the search query.</p>
<p class="normal">Finally, edit the <code class="inlineCode">urls.py</code> file of the <code class="inlineCode">blog</code> application and add the following URL pattern highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">urlpatterns = [
    # Post views
    path('', views.post_list, name='post_list'),
    # path('', views.PostListView.as_view(), name='post_list'),
    path(
        'tag/&lt;slug:tag_slug&gt;/', views.post_list, name='post_list_by_tag'
 ),
    path(
        '&lt;int:year&gt;/&lt;int:month&gt;/&lt;int:day&gt;/&lt;slug:post&gt;/',
        views.post_detail,
        name='post_detail'
 ),
    path('&lt;int:post_id&gt;/share/', views.post_share, name='post_share'),
    path(
        '&lt;int:post_id&gt;/comment/', views.post_comment, name='post_comment'
 ),
    path('feed/', LatestPostsFeed(), name='post_feed'),
    <strong class="hljs-slc">path(</strong><strong class="hljs-string-slc">'search/'</strong><strong class="hljs-slc">, views.post_search, name=</strong><strong class="hljs-string-slc">'post_search'</strong><strong class="hljs-slc">),</strong>
]
</code></pre>
<p class="normal">Next, open <code class="inlineCode">http://127.0.0.1:8000/blog/search/</code> in your browser. You should see the following<a id="_idIndexMarker357"/> search form:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_29.png"/></figure>
<p class="packt_figref">Figure 3.29: The form with the query field to search for posts</p>
<p class="normal">Enter a query and click on the <strong class="screenText">SEARCH</strong> button. You will see the results of the search query, as follows:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_30.png"/></figure>
<p class="packt_figref">Figure 3.30: Search results for the term “jazz”</p>
<p class="normal">Congratulations! You have<a id="_idIndexMarker358"/> created a basic search engine for your blog.</p>
<h2 class="heading-2" id="_idParaDest-135">Stemming and ranking results</h2>
<p class="normal">Stemming is the process of reducing <a id="_idIndexMarker359"/>words to their word stem, base, or root form. Stemming is used by search engines to reduce indexed words to their stem, and to be able to match inflected or derived words. For example, the words “music,” “musical,” and “musicality” can be considered similar words by a search engine. The stemming<a id="_idIndexMarker360"/> process normalizes each search token into a lexeme, a unit of lexical meaning that underlies a set of words that are related through inflection. The words “music,” “musical,” and “musicality” would convert to “music” when creating a search query.</p>
<p class="normal">Django provides a <code class="inlineCode">SearchQuery</code> class to translate terms into a search query object. By default, the terms are passed through stemming algorithms, which helps you to obtain better matches.</p>
<p class="normal">The PostgreSQL search engine also removes stop words, such as “a,” “the,” “on,” and “of.” Stop words are a set of commonly used words in a language. They are removed when creating a search query because they appear too frequently to be relevant to searches. You can find the list of stop words used by PostgreSQL for the English language at <a href="https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/english.stop">https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/english.stop</a>.</p>
<p class="normal">We also want to order results by relevancy. PostgreSQL provides a ranking function that orders results based on how<a id="_idIndexMarker361"/> often the query terms appear and how close together they are.</p>
<p class="normal">Edit the <code class="inlineCode">views.py</code> file of the <code class="inlineCode">blog</code> application and add the following imports:</p>
<pre class="programlisting code"><code class="hljs-code">from django.contrib.postgres.search import (
 SearchVector,
    SearchQuery,
    SearchRank
)
</code></pre>
<p class="normal">Then, edit the <code class="inlineCode">post_search</code> view, as follows. New code is highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">def post_search(request):
    form = SearchForm()
    query = None
    results = []
    if 'query' in request.GET:
        form = SearchForm(request.GET)
        if form.is_valid():
            query = form.cleaned_data['query']
            <strong class="hljs-slc">search_vector = SearchVector(</strong><strong class="hljs-string-slc">'title'</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">'body'</strong><strong class="hljs-slc">)</strong>
<strong class="hljs-slc">search_query = SearchQuery(query)</strong>
            results = (
                Post.published.annotate(
                    search=<strong class="hljs-slc">search_vector,</strong>
<strong class="hljs-slc">rank=SearchRank(search_vector, search_query)</strong>
                )
                .filter(search=<strong class="hljs-slc">search_query</strong>)
<strong class="hljs-slc">                .order_by(</strong><strong class="hljs-string-slc">'-rank'</strong><strong class="hljs-slc">)</strong>
            )
    return render(
 request,
 'blog/post/search.html',
 {
 'form': form,
 'query': query,
 'results': results
 }
    )
</code></pre>
<p class="normal">In the preceding code, we create a <code class="inlineCode">SearchQuery</code> object, filter results by it, and use <code class="inlineCode">SearchRank</code> to order the results by relevancy.</p>
<p class="normal">You can open <code class="inlineCode">http://127.0.0.1:8000/blog/search/</code> in your browser and test different searches to test stemming and ranking. The following is<a id="_idIndexMarker362"/> an example of ranking by the number of occurrences of the word <code class="inlineCode">django</code> in the title and body of the posts:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_31.png"/></figure>
<p class="packt_figref">Figure 3.31: Search results for the term “django”</p>
<h2 class="heading-2" id="_idParaDest-136">Stemming and removing stop words in different languages</h2>
<p class="normal">We can set up <code class="inlineCode">SearchVector</code> and <code class="inlineCode">SearchQuery</code> to execute stemming and remove stop words in any language. We can <a id="_idIndexMarker363"/>pass a <code class="inlineCode">config</code> attribute to <code class="inlineCode">SearchVector</code> and <code class="inlineCode">SearchQuery</code> to use a different search configuration. This allows us to use different language parsers and dictionaries. The following example executes stemming and removes stop words in Spanish:</p>
<pre class="programlisting code"><code class="hljs-code">search_vector = SearchVector('title', 'body'<strong class="hljs-slc">, config=</strong><strong class="hljs-string-slc">'spanish'</strong>)
search_query = SearchQuery(query<strong class="hljs-slc">, config=</strong><strong class="hljs-string-slc">'spanish'</strong>)
results = (
    Post.published.annotate(
        search=search_vector,
        rank=SearchRank(search_vector, search_query)
    )
    .filter(search=search_query)
    .order_by('-rank')
)
</code></pre>
<p class="normal">You can find the Spanish <a id="_idIndexMarker364"/>stop words dictionary used by PostgreSQL at <a href="https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/spanish.stop">https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/spanish.stop</a>.</p>
<h2 class="heading-2" id="_idParaDest-137">Weighting queries</h2>
<p class="normal">We can boost specific vectors so that more weight is attributed to them when ordering results by relevancy. For example, we <a id="_idIndexMarker365"/>can use this to give more relevance to posts that are matched by title rather than by content.</p>
<p class="normal">Edit the <code class="inlineCode">views.py</code> file of the <code class="inlineCode">blog</code> application and modify the <code class="inlineCode">post_search</code> view as follows. New code is highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">def post_search(request):
    form = SearchForm()
    query = None
    results = []
    if 'query' in request.GET:
        form = SearchForm(request.GET)
        if form.is_valid():
            query = form.cleaned_data['query']
            search_vector = SearchVector(
                'title'<strong class="hljs-slc">, weight=</strong><strong class="hljs-string-slc">'A'</strong>
 <strong class="hljs-slc">) + SearchVector(</strong><strong class="hljs-string-slc">'body'</strong><strong class="hljs-slc">, weight=</strong><strong class="hljs-string-slc">'B'</strong><strong class="hljs-slc">)</strong>
            search_query = SearchQuery(query)
            results = (
                Post.published.annotate(
                    search=search_vector,
                    rank=SearchRank(search_vector, search_query)
                )
                .filter(<strong class="hljs-slc">rank__gte=</strong><strong class="hljs-number-slc">0.3</strong>)
                .order_by('-rank')
            )
    return render(
 request,
 'blog/post/search.html',
 {
 'form': form,
 'query': query,
 'results': results
 }
    )
</code></pre>
<p class="normal">In the preceding code, we apply different weights to the search vectors built using the <code class="inlineCode">title</code> and <code class="inlineCode">body</code> fields. The <a id="_idIndexMarker366"/>default weights are <code class="inlineCode">D</code>, <code class="inlineCode">C</code>, <code class="inlineCode">B</code>, and <code class="inlineCode">A</code>, and they refer to the numbers <code class="inlineCode">0.1</code>, <code class="inlineCode">0.2</code>, <code class="inlineCode">0.4</code>, and <code class="inlineCode">1.0</code>, respectively. We apply a weight of <code class="inlineCode">1.0</code> to the <code class="inlineCode">title</code> search vector (<code class="inlineCode">A</code>) and a weight of <code class="inlineCode">0.4</code> to the <code class="inlineCode">body</code> vector (<code class="inlineCode">B</code>). Title matches will prevail over body content matches. We filter the results to display only the ones with a rank higher than <code class="inlineCode">0.3</code>.</p>
<h2 class="heading-2" id="_idParaDest-138">Searching with trigram similarity</h2>
<p class="normal">Another search approach is trigram similarity. A trigram is a group of three consecutive characters. You can measure the similarity of two strings by counting the number of trigrams that they share. This <a id="_idIndexMarker367"/>approach turns out to be very effective for measuring the similarity of words in many languages.</p>
<p class="normal">To use trigrams in PostgreSQL, you will need to install the <code class="inlineCode">pg_trgm</code> database extension first. Django provides database migration operations to create PostgreSQL extensions. Let’s add a migration that creates the extension in the database.</p>
<p class="normal">First, execute the following command in the shell prompt to create an empty migration:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py makemigrations --name=trigram_ext --empty blog
</code></pre>
<p class="normal">This will create an empty migration for the <code class="inlineCode">blog</code> application. You will see the following output:</p>
<pre class="programlisting con"><code class="hljs-con">Migrations for 'blog':
  blog/migrations/0005_trigram_ext.py
</code></pre>
<p class="normal">Edit the file <code class="inlineCode">blog/migrations/0005_trigram_ext.py</code> and add the following lines highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code"><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> django.contrib.postgres.operations </strong><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> TrigramExtension</strong>
from django.db import migrations
class Migration(migrations.Migration):
    dependencies = [
        ('blog', '0004_post_tags'),
    ]
    operations = [
        <strong class="hljs-slc">TrigramExtension()</strong>
    ]
</code></pre>
<p class="normal">You have added the <code class="inlineCode">TrigramExtension</code> operation to the database migration. This operation executes the SQL <a id="_idIndexMarker368"/>statement <code class="inlineCode">CREATE EXTENSION pg_trgm</code> to create the extension in PostgreSQL. </p>
<p class="normal">You can find more information about database migration operations at <a href="https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/">https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/</a>.</p>
<p class="normal">Now execute the migration with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">python manage.py migrate blog
</code></pre>
<p class="normal">You will see the following output:</p>
<pre class="programlisting con"><code class="hljs-con">Running migrations:
  Applying blog.0005_trigram_ext... OK
</code></pre>
<p class="normal">The <code class="inlineCode">pg_trgm</code> extension has been created in the database. Let’s modify <code class="inlineCode">post_search</code> to search for trigrams.</p>
<p class="normal">Edit the <code class="inlineCode">views.py</code> file of your <code class="inlineCode">blog</code> application and add the following import:</p>
<pre class="programlisting code"><code class="hljs-code">from django.contrib.postgres.search import TrigramSimilarity
</code></pre>
<p class="normal">Then, modify the <code class="inlineCode">post_search</code> view as<a id="_idIndexMarker369"/> follows. New code is highlighted in bold:</p>
<pre class="programlisting code"><code class="hljs-code">def post_search(request):
    form = SearchForm()
    query = None
    results = []
    if 'query' in request.GET:
        form = SearchForm(request.GET)
        if form.is_valid():
            query = form.cleaned_data['query']
            results = (
                Post.published.annotate(
                    <strong class="hljs-slc">similarity=TrigramSimilarity(</strong><strong class="hljs-string-slc">'title'</strong><strong class="hljs-slc">, query),</strong>
                )
                .filter(<strong class="hljs-slc">similarity__gt=</strong><strong class="hljs-number-slc">0.1</strong>)
                .order_by(<strong class="hljs-string-slc">'-similarity'</strong>)
            )
    return render(
 request,
 'blog/post/search.html',
 {
 'form': form,
 'query': query,
 'results': results
 }
    )
</code></pre>
<p class="normal">Open <code class="inlineCode">http://127.0.0.1:8000/blog/search/</code> in your browser and test different searches for trigrams. The following example displays a hypothetical typo in the <code class="inlineCode">django</code> term, showing search results for <code class="inlineCode">yango</code>:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21088_03_32.png"/></figure>
<p class="packt_figref">Figure 3.32: Search results for the term “yango”</p>
<p class="normal">We have added a <a id="_idIndexMarker370"/>powerful search engine to the blog application.</p>
<p class="normal">You can find more information about full-text search with Django and PostgreSQL at <a href="https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/">https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/</a>.</p>
<h1 class="heading-1" id="_idParaDest-139">Summary</h1>
<p class="normal">In this chapter, you implemented a tagging system by integrating a third-party application into your project. You generated post recommendations using complex QuerySets. You also learned how to create custom Django template tags and filters to provide templates with custom functionalities. You also created a sitemap for search engines to crawl your site and an RSS feed for users to subscribe to your blog. You then built a search engine for your blog using the full-text search engine of PostgreSQL.</p>
<p class="normal">In the next chapter, you will learn how to build a social website using the Django authentication framework and how to implement user account functionalities and custom user profiles.</p>
<h1 class="heading-1" id="_idParaDest-140">Expanding your project using AI</h1>
<p class="normal">Having completed the blog application, you likely have numerous ideas for adding new functionalities to your blog. This section aims to provide some insights into exploring new functionalities to incorporate into your project with the assistance of ChatGPT. ChatGPT is a sophisticated AI <strong class="keyWord">Large Language Model</strong> (<strong class="keyWord">LLM</strong>) created by OpenAI that generates human-like responses based on the <a id="_idIndexMarker371"/>prompts it receives. In this section, you will be presented with a task to extend your project, accompanied by a sample prompt for ChatGPT to assist you.</p>
<p class="normal">Engage with ChatGPT at <a href="https://chat.openai.com/">https://chat.openai.com/</a>. You will find similar guidance after completing each Django project within this book, in <em class="italic">Chapter 7</em>, <em class="italic">Tracking User Actions</em>, <em class="italic">Chapter 11</em>, <em class="italic">Adding Internationalization to Your Shop</em>, and <em class="italic">Chapter 17</em>, <em class="italic">Going Live</em>.</p>
<p class="normal">Let’s further enhance your blog with the help of ChatGPT. Your blog currently allows filtering posts by tags. Adding these tags to our sitemap could significantly improve the SEO optimization of the blog. Use the prompt provided at <a href="https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md">https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md</a> for adding tag pages to the sitemap. This challenge is an excellent opportunity to refine your project and deepen your understanding of Django, while learning to interact with ChatGPT.</p>
<div><p class="normal">ChatGPT is ready to assist with code issues. Simply share your code along with any errors you’re facing, and ChatGPT can help you identify and resolve the issues.</p>
</div>
<h1 class="heading-1" id="_idParaDest-141">Additional resources</h1>
<p class="normal">The following resources provide additional information related to the topics covered in this chapter:</p>
<ul>
<li class="bulletList">Source code for this chapter: <a href="https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03">https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03</a></li>
<li class="bulletList"><code class="inlineCode">django-taggit</code>: <a href="https://github.com/jazzband/django-taggit">https://github.com/jazzband/django-taggit</a></li>
<li class="bulletList"><code class="inlineCode">django-taggit</code> ORM managers: <a href="https://django-taggit.readthedocs.io/en/latest/api.html">https://django-taggit.readthedocs.io/en/latest/api.html</a></li>
<li class="bulletList">Many-to-many relationships: <a href="https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/">https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/</a></li>
<li class="bulletList">Django aggregation functions: <a href="https://docs.djangoproject.com/en/5.0/topics/db/aggregation/">https://docs.djangoproject.com/en/5.0/topics/db/aggregation/</a></li>
<li class="bulletList">Built-in template tags and filters: <a href="https://docs.djangoproject.com/en/5.0/ref/templates/builtins/">https://docs.djangoproject.com/en/5.0/ref/templates/builtins/</a></li>
<li class="bulletList">Writing custom template tags: <a href="https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/">https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/</a></li>
<li class="bulletList">Markdown format reference: <a href="https://daringfireball.net/projects/markdown/basics ">https://daringfireball.net/projects/markdown/basics</a></li>
<li class="bulletList">Django sitemap framework: <a href="https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/">https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/</a></li>
<li class="bulletList">Django sites framework: <a href="https://docs.djangoproject.com/en/5.0/ref/contrib/sites/">https://docs.djangoproject.com/en/5.0/ref/contrib/sites/</a></li>
<li class="bulletList">Django syndication feed framework: <a href="https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/">https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/</a></li>
<li class="bulletList">Docker download and installation instructions: <a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a></li>
<li class="bulletList">PostgreSQL Docker image: <a href="https://hub.docker.com/_/postgres">https://hub.docker.com/_/postgres</a></li>
<li class="bulletList">PostgreSQL downloads: <a href="https://www.postgresql.org/download/">https://www.postgresql.org/download/</a></li>
<li class="bulletList">PostgreSQL full-text search capabilities: <a href="https://www.postgresql.org/docs/16/textsearch.html">https://www.postgresql.org/docs/16/textsearch.html</a></li>
<li class="bulletList">Database migration operations: <a href="https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/">https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/</a>.</li>
<li class="bulletList">Django support for PostgreSQL full-text search – <a href="https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/">https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/</a></li>
<li class="bulletList">ChatGPT interface – <a href="https://chat.openai.com/">https://chat.openai.com/</a></li>
<li class="bulletList">Sample ChatGPT prompt to add tag pages to the sitemap – <a href="https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md">https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md</a></li>
</ul>
</div>
</body></html>