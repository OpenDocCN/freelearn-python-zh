- en: Chapter 4. Game of Chess
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 棋盘游戏
- en: Let's now build a game of chess in Tkinter. You do not need to be a master at
    chess to build this game. If you have ever played chess and you know the basic
    rules that govern the chess pieces, you are ready to write this program.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在Tkinter中构建一个棋盘游戏。你不需要成为棋艺大师就能构建这个游戏。如果你曾经玩过棋类游戏，并且了解控制棋子的基本规则，你就准备好编写这个程序了。
- en: If you have never played chess and do not know the basic rules, you would better
    start by reading those rules from the Internet before you start programming this
    application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未玩过棋类游戏，并且不知道基本规则，你最好在开始编程这个应用程序之前先从互联网上阅读这些规则。
- en: Mission Briefing
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务简报
- en: 'In its final form our chess game would look like the following screenshot:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最终形式中，我们的棋盘游戏将看起来像以下截图：
- en: '![Mission Briefing](img/7941_04_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![任务简报](img/7941_04_01.jpg)'
- en: Our chess game would enforce all standard rules applicable to the game of chess.
    Some advanced rules and features are left as an exercise for you to complete.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的棋盘游戏将强制执行适用于棋类游戏的所有标准规则。一些高级规则和功能留给你作为练习来完成。
- en: Why Is It Awesome?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么它如此出色？
- en: In the process of building our chess application, we get introduced to the Tkinter
    Canvas widget, which is considered one of the most powerful and versatile features
    of Tkinter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的棋盘游戏应用的过程中，我们接触到了Tkinter Canvas小部件，这被认为是Tkinter中最强大和最灵活的功能之一。
- en: As you will see in the course of this project, the Canvas widget is a really
    powerful tool for a GUI programmer. It can be used to sketch compound objects
    using lines, rectangles, ovals, and polygons. It will also let you position images
    on the canvas with great accuracy.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在项目过程中将看到的，Canvas小部件是一个真正的强大工具，对于GUI程序员来说非常有用。它可以用来使用线条、矩形、椭圆和多边形绘制复合对象。它还将允许你以极高的精度在画布上定位图像。
- en: In addition, the Canvas widget will let you place any other widget (such as
    labels, buttons, scale, and other widgets) on itself. This makes it an ideal container
    for accommodating widgets for a variety of different GUI programs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Canvas小部件将允许你将任何其他小部件（如标签、按钮、刻度和其他小部件）放置在其上。这使得它成为容纳各种不同GUI程序小部件的理想容器。
- en: In addition to learning about the Canvas widget, you will also get an insight
    on how to structure your data using Python built-in types. You will also be introduced
    to the concepts involved in selecting pertinent objects and structuring them into
    classes and modules at the right granularity.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了学习Canvas小部件外，你还将了解如何使用Python内置类型来结构化你的数据。你还将被介绍到涉及选择相关对象并将它们按适当的粒度组织到类和模块中的概念。
- en: As the application develops, we are also introduced to several other Python
    modules that you will often use in a variety of application development projects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的发展，我们还介绍了几个你将在各种应用程序开发项目中经常使用的Python模块。
- en: Your Hotshot Objectives
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的高目标
- en: 'The following are the key objectives for this project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个项目的关键目标：
- en: How to structure a program into its model and view components
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将程序结构化为模型和视图组件
- en: How to represent a problem domain in a desired notation
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何用期望的符号表示问题域
- en: Peeking into the versatility and power of the Tkinter Canvas widget
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Tkinter Canvas小部件的灵活性和强大功能
- en: Basic usage of canvas coordinates, object IDs and tags
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Canvas坐标、对象ID和标签的基本用法
- en: How to work with newer image formats not supported by the Tkinter photo image
    class
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理Tkinter photo image类不支持的新图像格式
- en: Typical interaction of logic and presentation layers in a GUI program
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUI程序中逻辑层和表示层之间的典型交互
- en: Mission Checklist
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务清单
- en: We will need to process PNG images in our program. The Tkinter photo image class
    and other standard libraries of Python do not support PNG processing. We will
    use the **Python Imaging Library** (**PIL**) to render PNG files.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，我们需要处理PNG图像。Tkinter photo image类和其他Python标准库不支持PNG处理。我们将使用**Python Imaging
    Library**（**PIL**）来渲染PNG文件。
- en: 'To install the PIL package visit:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装PIL包，请访问：
- en: '[http://www.pythonware.com/products/pil/](http://www.pythonware.com/products/pil/)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.pythonware.com/products/pil/](http://www.pythonware.com/products/pil/)'
- en: 'If you are working on windows x64 (64 bit)or MacOSX machine, you may instead
    need to install and work with Pillow, which is a replacement for the PIL, from:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在Windows x64（64位）或MacOSX机器上工作，你可能需要安装并使用Pillow，它是PIL的替代品，从：
- en: '[http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow)'
- en: 'After you have installed the package, go to your Python interactive prompt
    and type:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在你安装了包之后，转到你的Python交互式提示符并输入：
- en: '`>>from PIL import ImageTk`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>from PIL import ImageTk`'
- en: If this executes without any error message, you are ready to make the chess
    application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误信息执行，你就准备好制作棋类应用了。
- en: Structuring our program
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的程序结构
- en: All our previous projects have been structured as a single file. However, as
    programs grow in complexity, we need to break our programs into modules and class
    structures.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有先前项目都结构化为一个单独的文件。然而，随着程序复杂性的增加，我们需要将我们的程序分解为模块和类结构。
- en: Development of large applications generally starts with recording the **software
    requirement specifications** (**SRS**). This is generally followed by a graphical
    representation of constructs, such as class, composition, inheritance, and information
    hiding using several modeling tools. These tools can be flow charts, **unified
    modeling language** (**UML**), data flow diagrams, Venn diagrams (for database
    modeling), and several other tools.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大型应用程序的开发通常从记录**软件需求规格说明书**（**SRS**）开始。这通常随后是使用几个建模工具对结构进行图形表示，例如类、组合、继承和信息隐藏。这些工具可以是流程图、**统一建模语言**（**UML**）、数据流图、维恩图（用于数据库建模）以及几种其他工具。
- en: These tools are very useful when the problem domain is not very clear. However,
    if you have ever played the game of chess, you are very well acquainted with the
    problem domain. Furthermore, our chess program may be classified as a medium-sized
    program spanning a few hundred lines of code. Let us, therefore, bypass these
    visual tools and get to the actual program design.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当问题域不是很清晰时，这些工具非常有用。然而，如果你曾经玩过棋类游戏，你对问题域非常熟悉。此外，我们的棋类程序可能被归类为中等规模程序，跨越几百行代码。因此，让我们跳过这些视觉工具，直接进入实际程序设计。
- en: Prepare for Lift Off
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: In this iteration, we decide an overall structure for our program.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个迭代中，我们决定我们程序的整体结构。
- en: 'In the true spirit of object-oriented programming (OOP), let''s first list
    the kind of objects that we would encounter in our program. An intuitive look
    at a chessboard tells us that we have two sets of objects to handle:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程（OOP）的真正精神中，让我们首先列出我们将在程序中遇到的物体类型。直观地看一个棋盘告诉我们，我们有两组对象需要处理：
- en: '**Chessboard**: It is an 8 x 8 square board with alternatively colored squares'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**棋盘**：它是一个8 x 8的方格棋盘，有交替着色的方格'
- en: '**Chess pieces**: They are the king, queen, bishop, knight, rook, and pawns'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**棋子**：它们是国王、王后、主教、骑士、车和兵'
- en: As we proceed, we may or may not come across other objects. But we are sure
    to come across these two kinds of objects. So, without much further delay, let
    us create two files named `chessboard.py` and `pieces.py` in our project folder.
    (See *code folder 4.01*)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，我们可能会遇到也可能不会遇到其他对象。但我们肯定会遇到这两种对象。因此，无需进一步延迟，让我们在我们的项目文件夹中创建两个名为`chessboard.py`和`pieces.py`的文件。（见*代码文件夹
    4.01*）
- en: We will use these two files to define the respective classes to keep the logic
    associated with these two objects. Note that these files will not display the
    board or its pieces; it will instead keep all logic related to board and pieces.
    In programming parlance, this is broadly referred to as the **model**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这两个文件来定义相应的类，以保持与这两个对象相关的逻辑。请注意，这些文件将不会显示棋盘或其棋子；它将保留所有与棋盘和棋子相关的逻辑。在编程术语中，这通常被称为**模型**。
- en: The actual display of board and pieces will be kept in a separate file, which
    will handle all views related to the program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 棋盘和棋子的实际显示将保存在一个单独的文件中，该文件将处理与程序相关的所有视图。
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The rule of separating logic from presentation should be applied not only for
    deciding your file structure, but also when defining methods within your files.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将逻辑与表示分离的规则不仅应该用于决定你的文件结构，还应该在定义文件内的方法时应用。
- en: Every time you write a method, try to separate its presentation from the logic.
    If you find a method mixing logic and presentation, refactor your code to separate
    the two. Avoid coupling the presentation and logic into the same method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你编写一个方法时，都尽量将其表示与逻辑分离。如果你发现一个方法混合了逻辑和表示，重构你的代码以分离这两个部分。避免将表示和逻辑耦合到同一个方法中。
- en: It is a good idea to keep the presentation layer (view) separate from logic
    (model). So, we will create a new file named `gui.py` to code all visible components
    of the program, including all our widgets. This file will be primarily responsible
    for generating the view.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将表示层（视图）与逻辑（模型）分开是一个好主意。因此，我们将创建一个名为 `gui.py` 的新文件来编写程序的所有可见组件，包括所有小部件。此文件将主要负责生成视图。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In addition to the model and view files, many programs also keep a separate
    controller file to decouple behavioral aspects of a program from the logic (model)
    and presentation (view). This kind of structural segregation is named the **model-view-controller**
    (**MVC**) style of programming.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了模型和视图文件外，许多程序还保留一个单独的控制器文件，以将程序的行为方面与逻辑（模型）和展示（视图）解耦。这种结构分离被称为 **模型-视图-控制器**（**MVC**）编程风格。
- en: 'However, our chess program has just one event to handle: mouse click for moving
    chess pieces. Creating a separate controller for just one event can make the program
    more complex than it should be.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的棋类程序只有一个事件需要处理：移动棋子的鼠标点击。仅为此事件创建一个单独的控制器可能会使程序比应有的更复杂。
- en: Given this limitation, we will handle the presentation (view) and event handling
    (controller) from a single class named `GUI`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这种限制，我们将从名为 `GUI` 的单个类中处理展示（视图）和事件处理（控制器）。
- en: Now that we have our file structure ready, let us start our coding. To begin,
    let's code the `GUI` class for our chessboard, as shown in the following screenshot.
    Because this pertains to the view section, let's put this code in the `gui.py`
    file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了文件结构，让我们开始编码。首先，让我们为棋盘编写 `GUI` 类，如下面的截图所示。因为这与视图部分相关，所以我们将此代码放在 `gui.py`
    文件中。
- en: '![Prepare for Lift Off](img/7941_04_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![准备起飞](img/7941_04_02.jpg)'
- en: Engage Thrusters
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – creating the GUI class
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 1 步 – 创建 GUI 类
- en: 'We first create a `GUI` class and assign attributes such as rows, columns,
    colors of squares, and the dimension of each square in pixels. We initialize our
    `GUI` class to create the canvas on which we will draw our chessboard, as follows
    (see *code 4.01 gui.py*):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个 `GUI` 类，并分配诸如行、列、方格颜色以及每个方格的像素尺寸等属性。我们初始化 `GUI` 类以创建棋盘的画布，如下所示（见 *代码
    4.01 gui.py*）：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The description of the code is listed as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We create a class, `GUI`, to handle the rendering of our view files. The `init`
    method of the `GUI` class is called immediately on object instantiation. The `init`
    method sets up a Canvas widget of the required size. This canvas will act as our
    container for all objects, such as chess square areas and eventually the chess
    pieces.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个类 `GUI` 来处理视图文件的渲染。`GUI` 类的 `init` 方法在对象实例化时立即被调用。`init` 方法设置所需大小的 Canvas
    小部件。这个画布将作为我们所有对象的容器，例如棋盘方格区域和最终的棋子。
- en: We have used the Canvas widget as a container, because it provides us the ability
    to handle tasks based on precise location coordinates of events, such as click
    of the mouse button.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了 Canvas 小部件作为容器，因为它为我们提供了处理基于事件精确位置坐标的任务的能力，例如鼠标按钮的点击。
- en: The `init` method then calls the `draw_board()` method, which is responsible
    for creating square blocks of alternating colors similar to a chessboard.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后 `init` 方法调用 `draw_board()` 方法，该方法负责创建类似棋盘的交替颜色的方块。
- en: Step 2 – creating the chessboard
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步 – 创建棋盘
- en: Now, we draw the squares on the chessboard using the `canvas.create_rectangle`
    method, filling it alternating between the two colors we defined earlier.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用 `canvas.create_rectangle` 方法在棋盘上绘制方格，交替填充我们之前定义的两种颜色。
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The description of the code is listed as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: To draw squares on the board we use the `canvas.create_rectangle()` method,
    which draws a rectangle given the x, y coordinates for the two diagonally opposite
    corners of the rectangle (coordinates of upper-left and lower-right edges).
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在棋盘上绘制方格，我们使用 `canvas.create_rectangle()` 方法，该方法根据矩形的对角线相对角（上左和下右边缘的坐标）绘制矩形。
- en: We will need to target the board. We, therefore, add a tag named `area` to each
    of the squares created on the board. This is similar to tagging of the text widget,
    as we had done in our text editor program.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要针对棋盘进行操作。因此，我们在棋盘上创建的每个方格上添加一个名为 `area` 的标签。这与我们在文本编辑程序中进行的文本小部件的标记类似。
- en: Step 3 – creating Tkinter mainloop
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步 – 创建 Tkinter 主循环
- en: 'Now, we will create Tkinter mainloop as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建 Tkinter 主循环，如下所示：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The description of the code is listed as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: Outside the class, we have a main method that sets the Toplevel window, starts
    Tkinter mainloop, instantiates a `GUI` object, and calls the `drawboard()` method.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类外部，我们有一个主方法，它设置Toplevel窗口，启动Tkinter主循环，实例化一个`GUI`对象，并调用`drawboard()`方法。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Tkinter Canvas widget lets you draw line, oval, rectangle, arc, and polygon
    shapes at a given coordinate specified location. You can also specify various
    configuration options, such as fill, outline, width, and several others for each
    of these shapes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter Canvas小部件允许你在指定的坐标位置绘制线条、椭圆形、矩形、圆弧和多边形形状。你还可以指定各种配置选项，例如填充、轮廓、宽度和这些形状的其它几个选项。
- en: 'In addition, the Canvas widget has a huge list of methods and configurable
    options. For a complete list of canvas-related options, type the following into
    Python interactive shell:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Canvas小部件还有一个巨大的方法列表和可配置选项。要获取与画布相关的完整选项列表，请在Python交互式shell中输入以下内容：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can also access the documentation of Tkinter in your core Python installation
    directory. The documentation is located at `path\to\python\installation\Doc\Python273`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在核心Python安装目录中访问Tkinter的文档。文档位于`path\to\python\installation\Doc\Python273`。
- en: This is a compiled HTML help file. Within the help file, search for Tkinter,
    and you get a comprehensive reference with details of all widgets.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个编译的HTML帮助文件。在帮助文件中搜索Tkinter，你可以获得一个全面的参考，其中包含所有小部件的详细信息。
- en: Objective Complete – Mini Debriefing
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: This completes our first iteration. In this iteration, we decided the class
    structure for our chess program. We created a `GUI` class and added attributes
    we would normally expect a chessboard to have.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的第一次迭代。在这个迭代中，我们决定了象棋程序类的结构。我们创建了一个`GUI`类，并添加了通常期望棋盘拥有的属性。
- en: We also got our first taste of the Canvas widget. We created a blank canvas,
    and then added square areas using the `canvas.create_rectangle` method to create
    our chessboard.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也尝到了Canvas小部件的第一口。我们创建了一个空白画布，然后使用`canvas.create_rectangle`方法添加方形区域来创建我们的棋盘。
- en: We also created out Tkinter mainloop and created an object out of the `GUI`
    class from within our mainloop. Now, if you run `code 4.01 gui.py`, you will see
    a chessboard.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了Tkinter主循环，并在主循环中从`GUI`类创建了一个对象。现在，如果你运行`code 4.01 gui.py`，你会看到一个棋盘。
- en: Classified Intel
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类情报
- en: 'The Canvas widget comes with a rich set of methods and configurable options.
    However, there are three important things to note about the Canvas widget:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas小部件附带丰富的方法和可配置选项。然而，关于Canvas小部件有三个重要事项需要注意：
- en: It uses a coordinate system to specify position of objects on the widget. Coordinates
    are measured in pixels. The top-left corner of the canvas has coordinates (0,0).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用坐标系来指定小部件上对象的位置。坐标以像素为单位测量。画布的左上角坐标为（0,0）。
- en: It offers methods to add images and to draw basic shapes, such as line, arc,
    ovals, and polygons.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了添加图像和绘制基本形状（如线条、圆弧、椭圆形和多边形）的方法。
- en: The objects drawn on the Canvas widget are usually handled through assigning
    them an ID or tag.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制在Canvas小部件上的对象通常通过分配一个ID或标签来处理。
- en: Structuring chessboard-and-pieces-related data
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化棋盘和棋子相关数据
- en: In our drum program, we had decided on a notation to describe a set of beat
    patterns. We could then store (pickle) that beat pattern notation and reproduce
    (unpickle) it later. The chess program is no different. It too needs a suitable
    notation for describing chess pieces and for locating their positions on the board.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的鼓程序中，我们决定使用一种符号来描述一组节奏模式。然后我们可以存储（pickle）这种节奏模式符号，并在以后重新生成（unpickle）。象棋程序也是如此。它也需要一种合适的符号来描述棋子和它们在棋盘上的位置。
- en: Prepare for Lift Off
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: We can define our own notation for representing chess piece and their positions,
    but it turns out that there already exists a globally accepted, simple, compact,
    and standard notation for representing a chessboard. The notation is called **Forsyth-Edwards
    notation** (**FEN**) available at [http://en.wikipedia.org/wiki/Forsyth-Edwards_Notation](http://en.wikipedia.org/wiki/Forsyth-Edwards_Notation).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为表示棋子和它们的棋盘位置定义自己的符号，但结果证明，已经存在一个全球公认、简单、紧凑且标准的棋盘表示符号。这种符号称为**福斯思-爱德华斯符号**（**FEN**），可在[http://en.wikipedia.org/wiki/Forsyth-Edwards_Notation](http://en.wikipedia.org/wiki/Forsyth-Edwards_Notation)找到。
- en: We might have decided to define our notation, but we preferred not to reinvent
    the wheel here.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能已经决定定义我们的符号，但在这里我们更倾向于不重新发明轮子。
- en: 'The FEN record for starting position of a chess game is written as:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 棋局起始位置的 FEN 记录写作如下：
- en: '`rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1`'
- en: 'The key things to note about the notation are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种记法的要点如下：
- en: The notation displays six records for a chess game. Each record is separated
    by a blank space.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种记法显示了一个棋局的六个记录。每个记录之间由一个空格分隔。
- en: The first record shows the positions of pieces on a chessboard. Each row of
    the chessboard (rank) is represented in a section demarcated by the `/` symbol.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一条记录显示了棋盘上棋子的位置。棋盘的每一行（等级）都由一个由 `/` 符号分隔的区域表示。
- en: Within the first record, each piece is identified by a single letter (pawn =
    `p`, knight = `n`, bishop = `b`, rook = `r`, queen = `q` and king = `k`).
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一条记录中，每个棋子由一个单独的字母识别（兵 = `p`，马 = `n`，象 = `b`，车 = `r`，后 = `q` 和王 = `k`）。
- en: White pieces are represented using uppercase letters (`PNBRQK`), but black pieces
    are represented by lowercase letters (`pnbrqk`).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白方棋子使用大写字母表示（`PNBRQK`），但黑方棋子使用小写字母表示（`pnbrqk`）。
- en: Squares with no pieces on it are represented using digits `1` through `8` (the
    number of blank squares).
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有棋子的方格使用数字 `1` 到 `8`（空白方格的数量）表示。
- en: The second record denotes the turn of a player. Letter `w` denotes white turn,
    and letter `b` denotes black turn.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二条记录表示玩家的回合。字母 `w` 表示白方回合，字母 `b` 表示黑方回合。
- en: 'The third record `KQkq` indicates whether or not castling feature is available.
    If neither castle, this is `-`. Otherwise, this has one or more letters: `K` (white
    can castle kingside), `Q` (white can castle queenside), `k` (black can castle
    kingside), and/or `q` (black can castle queenside).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三条记录 `KQkq` 表示王车易位功能是否可用。如果没有王车易位，则为 `-`。否则，它包含一个或多个字母：`K`（白方可以王车易位至王翼），`Q`（白方可以王车易位至后翼），`k`（黑方可以王车易位至王翼），以及/或
    `q`（黑方可以王车易位至后翼）。
- en: The fourth record`_`captures En passant details for the game. We will not be
    implementing castling and En passant features in our game, so we can safely disregard
    these two records for now.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四条记录 `_` 捕获游戏中的吃过路兵细节。我们将在游戏中不实现王车易位和吃过路兵功能，因此现在可以安全地忽略这两个记录。
- en: The fifth record keeps track of half-move clock for the game. The half-move
    clock keeps track of number of turns played since the last pawn advance or last
    capture. This is used to determine if a draw can be claimed under the fifty-move
    rule.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五条记录跟踪棋局的半回合时钟。半回合时钟跟踪自上次兵的推进或上次捕获以来的回合数。这用于确定是否可以根据五十回合规则要求和棋。
- en: The sixth record tracks the full-move number, which is incremented by 1 after
    each move of black. This is used to track the overall length for which a game
    was played.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第六条记录跟踪全回合数，每次黑方走棋后增加 1。这用于跟踪游戏的总长度。
- en: 'The notation as previously stated can be represented pictorially along x and
    y axis as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的记法可以如下沿 x 轴和 y 轴表示：
- en: '![Prepare for Lift Off](img/7941_04_03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![准备起飞](img/7941_04_03.jpg)'
- en: Using this notation, we can accurately represent any particular square on the
    chessboard.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种记法，我们可以准确地表示棋盘上的任何特定方格。
- en: The color of piece depends on whether the alphabet is in small letters (black)
    or capital letters (white).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 棋子的颜色取决于字母是否为小写（黑色）或大写（白色）。
- en: Thus **A1** denotes the bottom and left-most square on the chessboard. Currently,
    it is occupied by a white rook. The **C3** position is currently empty, and **E8**
    has black king and **A8** has a black rook.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此 **A1** 表示棋盘上最底部的最左方方格。目前，它被一个白方车占据。**C3** 位置目前为空，**E8** 有黑方王，**A8** 有黑方车。
- en: 'Following these rules, here is how the FEN notation would change after the
    following indicative turns played ([http://en.wikipedia.org/wiki/Forsyth-Edwards_Notation](http://en.wikipedia.org/wiki/Forsyth-Edwards_Notation)):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 依照这些规则，以下是如何在以下指示性回合后更改 FEN 记法（[http://en.wikipedia.org/wiki/Forsyth-Edwards_Notation](http://en.wikipedia.org/wiki/Forsyth-Edwards_Notation)）：
- en: 'After first move, `P` to `e4`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步棋后，兵从 `P` 移至 `e4`：
- en: '`rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1`'
- en: 'After second move, `p` to `c5`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步棋后，兵从 `p` 移至 `c5`：
- en: '`rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq c6 0 2`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq c6 0 2`'
- en: 'After third move, `N` to `f3`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步棋后，将棋子从 `N` 移至 `f3`：
- en: '`rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2`'
- en: All our chessboard and piece related logic will use the preceding notation.
    It is, therefore, very important that we fully understand this notation before
    we proceed to code our game.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的棋盘和棋子相关逻辑都将使用前面的表示法。因此，在我们继续编写游戏代码之前，完全理解这个表示法非常重要。
- en: Now that we are clear about the preceding notation, let's apply the notation
    to represent our chessboard. The key idea here is that, given a FEN notation,
    we should be able to represent it on the board.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经清楚地了解了前面的表示法，让我们将这个表示法应用到表示我们的棋盘上。关键思想是，给定一个FEN表示法，我们应该能够在棋盘上表示它。
- en: Engage Thrusters
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – creating a Piece superclass
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 - 创建棋子超类
- en: 'Let''s now first code the model code for `pieces.py` (see *code 4.02 pieces.py*)
    by creating a `Piece` super class as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们首先编写`pieces.py`的模型代码（见*代码4.02 pieces.py*），通过创建一个`Piece`超类如下：
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The description of the code is listed as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 代码描述如下：
- en: We define a class, `Piece ()`. It's `__init__` method, which takes a color as
    an argument. In accordance with our FEN notation, it changes the shortname to
    lowercase letter for black and uppercase letter for white. The color handling
    is done in the superclass, `Piece`, because it is a common feature for all chess
    pieces.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`Piece`的类。它的`__init__`方法，接受一个颜色作为参数。根据我们的FEN表示法，它将黑棋的简称改为小写字母，白棋的简称改为大写字母。颜色处理在超类`Piece`中完成，因为它是对所有棋子的共同特性。
- en: We also define a method named `ref`. Its only purpose is to get an instance
    of the chessboard into the object namespace for the board and pieces to interact.
    We need this method, because our pieces will ultimately be interacting with the
    chessboard. Accordingly, we need a reference of the chessboard instance within
    the `Piece` class.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还定义了一个名为`ref`的方法。它的唯一目的是获取棋盘实例到对象命名空间中，以便棋盘和棋子可以交互。我们需要这个方法，因为我们的棋子最终将与棋盘交互。因此，我们需要在`Piece`类中有一个棋盘实例的引用。
- en: Step 2 – creating individual child classes for all pieces
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 - 为所有棋子创建单独的子类
- en: 'We can create individual child classes for all pieces as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建所有棋子的单独子类如下：
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The description of the code is listed as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 代码描述如下：
- en: We define classes for each of the pieces found on a chessboard. So, we have
    classes named `King`, `Queen`, `Rook`, `Knight`, `Bishop`, and `Pawn`. These classes
    are derived from the `Piece` super class.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为棋盘上找到的每个棋子定义了类。因此，我们有名为`King`、`Queen`、`Rook`、`Knight`、`Bishop`和`Pawn`的类。这些类是从`Piece`超类派生出来的。
- en: For now, these child classes merely define the shortname associated with them.
    We will later expand these child classes to define and enforce rules for movement
    of each of these pieces.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，这些子类仅定义了与它们相关的简称。我们将在以后扩展这些子类，以定义和强制执行每个这些棋子的移动规则。
- en: Step 3 – defining a method to return the piece instance
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 - 定义一个返回棋子实例的方法
- en: 'We will define a method to return the piece instance as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个方法来返回棋子实例，如下所示：
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The description of the code is listed as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 代码描述如下：
- en: The code defines a dictionary with pieces shortname and full name as key-value
    pair.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码定义了一个字典，其中包含棋子的简称和全名作为键值对。
- en: We then define a method piece which takes a piece shortname and returns the
    corresponding piece instance.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个名为`piece`的方法，它接受一个棋子简称并返回相应的棋子实例。
- en: Step 4 – creating the Board class
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步 - 创建Board类
- en: 'Now that we have a basic model ready for pieces, let''s code the model to deal
    with their placement on the chessboard. We code this in `chessboard.py`.(see *code
    4.02 chessboard.py*) by creating a `Board` class as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了一个基本的棋子模型，让我们编写代码来处理它们在棋盘上的放置。我们在`chessboard.py`中编写这个模型（见*代码4.02 chessboard.py*），通过创建一个`Board`类如下：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The description of the code is listed as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 代码描述如下：
- en: Our code begins with defining the starting pattern as per the FEN notation discussed
    earlier. We do not include the castle and En passant related notation, because
    we will not be coding that in our program.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码从定义根据前面讨论的FEN表示法开始的起始模式。我们不包含王车易位和过路兵相关的表示法，因为我们不会在我们的程序中编写这些。
- en: We then define our `Board` class as a subclass of built-in `dict` type. This
    is because we will store the pattern as a dictionary.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将`Board`类定义为内置`dict`类型的子类。这是因为我们将存储模式作为字典。
- en: We then define `x_axis` and `y_axis` for our chessboard as nonimmutable tuples.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将`x_axis`和`y_axis`定义为棋盘的非不可变元组。
- en: The `__init__` method of our class simply calls the `process_notation` method
    of the class.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们类的`__init__`方法只是简单地调用类的`process_notation`方法。
- en: Step 5 – displaying pieces on board for a given FEN notation
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步 – 在棋盘上显示给定FEN表示的棋子
- en: 'Pieces on `Board` for a given FEN notation can be displayed as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定FEN表示的`Board`上的棋子，可以按以下方式显示：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The description of the code is listed as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The job of the `process_notation` method is to first expand the blank spaces
    represented by integers into actual spaces. It uses Python built-in regular expression
    module (`re`) to expand white spaces in a given FEN notation.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process_notation`方法的任务是首先将表示为整数的空白空间扩展为实际空间。它使用Python内置的正则表达式模块（`re`）来扩展给定FEN表示中的空白空间。'
- en: The code, `expand_whitespaces`, does something that might be tricky for Python
    beginners. It replaces each digit by the corresponding number of whitespaces,
    so you can later assume that a whitespace is an empty square. It then converts
    the FEN notation into a string corresponding to x and y alphanumeric coordinate
    for every piece. For doing this, it calls another method named `alpha_notation`,
    which is defined in step 7.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码`expand_whitespaces`做了一些对于Python初学者可能有点棘手的事情。它将每个数字替换为相应数量的空白空间，这样你就可以假设空白空间是一个空方格。然后，它将FEN表示转换为对应于每个棋子的x和y字母数字坐标的字符串。为此，它调用另一个名为`alpha_notation`的方法，该方法在第7步中定义。
- en: The final two lines keep a track of turns taken by the players.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后两行记录了玩家的回合。
- en: Step 6 – checking if a given coordinate is on the board
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第6步 – 检查给定坐标是否在棋盘上
- en: 'Finally, let''s end this iteration by defining a method to check if a given
    coordinate is on the board, as follows (see *code 4.02 chessboard.py*):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过定义一个方法来检查给定坐标是否在棋盘上结束这次迭代，如下所示（参见 *代码4.02 chessboard.py*）：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Step 7 – generating alphabetic and numeric notation
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7步 – 生成字母和数字表示
- en: 'We need a way to convert the x and y coordinates for a piece to its alphabetic
    equivalent notation for example, A1, D5, E3, and so on. We accordingly define
    the `alpha_notation` method as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来将棋子的x和y坐标转换为字母等效表示，例如，A1，D5，E3，等等。因此，我们定义了`alpha_notation`方法如下：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similarly, we define a method that takes in an x,y coordinate as input and
    returns its equivalent numerical notation, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们定义了一个方法，它接受x,y坐标作为输入，并返回其等效的数字表示，如下所示：
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Step 8 – checking places occupied on the board
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第8步 – 检查棋盘上占据的位置
- en: Before every move, we will need to check all the places occupied by all the
    pieces of a given color. This is required not only to calculate valid moves, but
    to also ensure that move by some other piece does not cause a check on the king.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次移动之前，我们需要检查给定颜色所有棋子所占据的所有位置。这不仅是为了计算有效移动，而且为了确保其他棋子的移动不会对国王造成将军。
- en: 'Accordingly, let''s define a method to return a list of coordinates occupied
    by a given color (see *code 4.02 chessboard.py*) as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们定义一个方法来返回给定颜色所占据的坐标列表（参见 *代码4.02 chessboard.py*），如下所示：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Step 9 – handling errors and exceptions
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第9步 – 处理错误和异常
- en: 'For handling errors and exceptions, we define a custom exception class named
    `ChessError`, and all other exceptions will later be subclassed to it, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理错误和异常，我们定义了一个名为`ChessError`的自定义异常类，所有其他异常都将后来子类化到它，如下所示：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Objective Complete – Mini Debriefing
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: In this iteration, we created a basic `Piece` class and dummy child classes
    for each of the pieces found on the chessboard. The individual piece classes inherit
    from the parent `Piece` class. We handle color identification in the parent class
    because it is something we need to do for all child classes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们创建了一个基本的`Piece`类和每个在棋盘上找到的棋子的虚拟子类。单个棋子类从父`Piece`类继承。我们在父类中处理颜色识别，因为这是我们需要为所有子类做的事情。
- en: We then defined our `Board` class and added some methods that we will surely
    need every time we want to move a piece on the board.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了我们的`Board`类，并添加了一些我们每次在棋盘上移动棋子时都需要的某些方法。
- en: We are yet to display those pieces on the board. We do that in the next iteration.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有在棋盘上显示这些棋子。我们将在下一次迭代中这样做。
- en: Adding pieces on the board
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在棋盘上添加棋子
- en: 'We now have a code that converts the FEN notation to its expanded coordinate-based
    representation. Now, let''s code to actually display chess pieces on the board,
    based on a given FEN notation, as shown in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个将 FEN 符号转换为基于坐标的扩展表示的代码。现在，让我们编写代码来在棋盘上显示棋子，基于给定的 FEN 符号，如下截图所示：
- en: '![Adding pieces on the board](img/7941_04_04.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![在棋盘上添加棋子](img/7941_04_04.jpg)'
- en: Prepare for Lift Off
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: We will use PNG images for displaying pieces on the board. We have provided
    PNG images for each piece in a folder named `pieces_image`. The images have been
    named by appending the shortname of each piece followed by the color of the piece.
    For instance, black queen is saved as `qblack.png`, and white knight is saved
    as `nwhite.png`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 PNG 图像来显示棋盘上的棋子。我们在名为 `pieces_image` 的文件夹中为每个棋子提供了 PNG 图像。图像是通过在每个棋子的短名后附加棋子的颜色来命名的。例如，黑后保存为
    `qblack.png`，白骑士保存为 `nwhite.png`。
- en: We have chosen PNG over GIF because unlike GIF, PNG allows for alpha channels
    (variable transparency), automatic gamma correction on different platforms, and
    color correction.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择 PNG 而不是 GIF，因为与 GIF 不同，PNG 允许使用 alpha 通道（可变透明度）、在不同平台上自动进行伽玛校正以及颜色校正。
- en: However, the `TkinterPhotoImage` class does not support the PNG format. We,
    therefore, use the PIL to process PNG files.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`TkinterPhotoImage` 类不支持 PNG 格式。因此，我们使用 PIL 来处理 PNG 文件。
- en: Tip
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Currently, the `TkinterPhotoImage` class supports images in GIF, PPM, XBM, and
    PGM formats only. None of these formats are in vogue currently. Unfortunately,
    support for new formats can only be added if the Tcl/Tk starts supporting those
    formats.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`TkinterPhotoImage` 类仅支持 GIF、PPM、XBM 和 PGM 格式的图像。这些格式目前都不流行。不幸的是，只有当 Tcl/Tk
    开始支持这些格式时，才能添加对新格式的支持。
- en: Up till then, you may find it handy to use the PIL, which supports most of the
    popular image formats including PNG, JPEG, GIF, TIFF, and BMP.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，使用 PIL 可能会很有用，因为它支持包括 PNG、JPEG、GIF、TIFF 和 BMP 在内的几乎所有流行的图像格式。
- en: In addition to displaying images in Tkinter, the PIL module can also be used
    for image processing, such as size transformations, format conversions, thumbnail
    creation, and several other image manipulation requirements.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 Tkinter 中显示图像外，PIL 模块还可以用于图像处理，例如尺寸变换、格式转换、缩略图创建以及其他几个图像操作需求。
- en: We will add code for displaying chess pieces in our view file, `gui.py`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的视图文件 `gui.py` 中添加显示棋子的代码。
- en: Engage Thrusters
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点火推进器
- en: Step 1 – importing PIL
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 1 步 – 导入 PIL
- en: 'Because we will use the PIL module to display PNG images for our pieces, we
    start by importing `ImageTk` from the PIL module as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用 PIL 模块来显示棋子的 PNG 图像，我们首先按照以下方式从 PIL 模块导入 `ImageTk`：
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Step 2 – defining method to draw pieces on chessboard
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步 – 定义在棋盘上绘制棋子的方法
- en: 'The code for adding pieces on the board is as follows (see *code 4.03: gui.py*):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '在棋盘上添加棋子的代码如下（见 *代码 4.03: gui.py*）：'
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The description of the code is listed as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We begin by importing `ImageTk` from the PIL module. We need this to handle
    PNG images.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先从 PIL 模块导入 `ImageTk`。我们需要这个来处理 PNG 图像。
- en: We define our `draw_pieces()` method, whose role is to draw the pieces on a
    board for a given FEN notation. Because the FEN notation is available to all class
    methods, we need not pass it as an argument.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了我们的 `draw_pieces()` 方法，其作用是为给定的 FEN 符号在棋盘上绘制棋子。因为 FEN 符号对所有类方法都是可用的，所以我们不需要将其作为参数传递。
- en: Recall that we have created an instance of the chessboard which produces a dictionary
    comprising of the coordinate-based location of a piece and the corresponding piece
    instance as the key-value pair.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，我们已经创建了一个棋盘实例，它产生一个字典，包含一个棋子的基于坐标的位置和相应的棋子实例作为键值对。
- en: We loop through the dictionary using `iteritems()`, and break down the x and
    y coordinate string into corresponding x-and-y-based number notation.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `iteritems()` 遍历字典，并将 x 和 y 坐标字符串分解为相应的基于 x 和 y 的数字表示法。
- en: If there exists a piece for a given coordinate, we add it to the Canvas widget
    using `canvas.create_image()`.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给定坐标存在棋子，我们使用 `canvas.create_image()` 将其添加到 Canvas 小部件中。
- en: 'One of the most important things to note here is that we have added two tags
    to each of the pieces: the name of the piece and a static string name `occupied`.
    Tags are the most important tool that you can use to operate on objects within
    the Canvas widget.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里需要注意的最重要的事情之一是我们为每个棋子添加了两个标签：棋子的名称和一个静态字符串名称 `occupied`。标签是在 Canvas 小部件内操作对象时可以使用的最重要的工具。
- en: The next two lines create the x, y coordinate for a given board size.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的两行创建了给定棋盘大小的x，y坐标。
- en: The final line of the method uses `self.canvas.coords` to place the piece at
    the calculated coordinate.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的最后一行使用`self.canvas.coords`将棋子放置在计算出的坐标上。
- en: Finally, we need to call our newly defined method. We do that from our `show()`
    method to invoke the pieces.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们需要调用我们新定义的方法。我们从`show()`方法中这样做，以调用棋子。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Let's wrap this iteration by analyzing the two canvas-related methods used here.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过分析这里使用的两个与canvas相关的方
- en: '**canvas.create_image(x, y, *options)**: The `create_image` method takes two
    arguments that specify x and y coordinates for positioning the image. After the
    coordinates, you may specify any number of option-value pairs. In our example,
    we have used the `anchor="c"` option to keep the image in the center.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**canvas.create_image(x, y, *options)**: `create_image`方法接受两个参数，用于指定图像的位置坐标x和y。在坐标之后，你可以指定任意数量的选项值对。在我们的例子中，我们使用了`anchor="c"`选项来保持图像在中心。'
- en: '**canvas.coords(tag/id, x0, y0, x1, y1, ..., xn, yn)**: The `coords()` method
    decides or modifies the coordinates for items attached to a given tag or ID. If
    coordinates are not specified, it returns a tuple specifying the coordinates of
    the item referenced by given tag or ID. If coordinates are specified, then they
    replace the current coordinates for the named item. If the tag or ID is attached
    to multiple items, only the first item is used.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**canvas.coords(tag/id, x0, y0, x1, y1, ..., xn, yn)**: `coords()`方法决定或修改与给定标签或ID关联的项目坐标。如果没有指定坐标，它将返回一个元组，指定由给定标签或ID引用的项目坐标。如果指定了坐标，则它们将替换命名项目的当前坐标。如果标签或ID关联到多个项目，则只使用第一个项目。'
- en: We will learn about the Canvas widget in greater detail as we progress. However,
    you may find it useful to look at the interactive help for the Canvas widget,
    or a list of available methods and configurable options.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们不断深入，我们将更详细地了解Canvas小部件。然而，查看Canvas小部件的交互式帮助或可用方法和可配置选项列表可能很有用。
- en: Objective Complete – Mini Debriefing
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: Our code can now take a FEN notation and display the images for corresponding
    pieces on the chessboard. If you modify the FEN notation, the pieces on the chessboard
    will change their places accordingly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的代码可以接受FEN表示法，并在棋盘上显示对应的棋子图像。如果你修改了FEN表示法，棋盘上的棋子将相应地改变位置。
- en: In the process, we got acquainted with the basic features of the Canvas widget.
    We also saw two canvas-related methods to create image and to change the coordinates.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们熟悉了Canvas小部件的基本功能。我们还看到了两个与canvas相关的创建图像和更改坐标的方法。
- en: Finally, we saw how to overcome a Tkinter limitation on image handling by using
    the PIL module to handle formats not supported by Tkinter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了如何通过使用PIL模块来处理Tkinter不支持格式的图像，从而克服Tkinter在图像处理上的限制。
- en: Enforcing rules for pieces' movement
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制棋子移动规则
- en: Before we get these chess pieces to move on click of mouse, we need to know
    how many squares a given piece can move. We need to enforce rules for each of
    the chess pieces.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们让这些棋子在鼠标点击时移动之前，我们需要知道给定棋子可以移动多少格。我们需要为每个棋子强制执行规则。
- en: Prepare for Lift Off
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: 'Before we start coding the rules, let''s quickly recap the rules of chess:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写规则之前，让我们快速回顾一下国际象棋的规则：
- en: 'King can move only one square in any direction: up, down, to the sides, and
    diagonally.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国王只能向任意方向移动一格：向上、向下、向侧和斜向。
- en: 'Queen can move in any one straight direction: forward, backward, sideways,
    or diagonally; as far as possible as long as she does not move through any of
    her own pieces.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后可以沿任意一个直线方向移动：向前、向后、向侧或斜向；只要不经过自己的棋子，可以尽可能远地移动。
- en: Rook can move as far as it wants, but only forward, backward, and to the sides
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 车可以移动任意远，但只能向前、向后和向侧移动
- en: Bishop can move as far as it wants, but only diagonally.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 象可以移动任意远，但只能斜着走。
- en: Knights are different from others. They must move two squares in one direction,
    and then one more move at a 90 degree angle, following the shape of *L*. Knights
    are also the only pieces that can jump over other pieces.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马与其他棋子不同。它们必须先沿一个方向移动两格，然后以90度角再移动一格，遵循L的形状。马也是唯一可以跳过其他棋子的棋子。
- en: Pawns move forward, but capture diagonally. Pawns can only move forward one
    square at a time, except for their very first move where they can move forward
    two squares. Pawns can only capture one square diagonally in front of them.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兵向前移动，但可以斜向捕获。兵每次只能向前移动一个方格，除了它们的第一次移动，那时它们可以向前移动两个方格。兵只能斜向捕获它们前方的一个方格。
- en: 'The bottom line here is that we need to track three common things for each
    of the piece:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的是，我们需要跟踪每个棋子的三个常见事物：
- en: Its current position
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的当前位置
- en: Allowed directions for movement
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动允许的方向
- en: Distance that a piece can move
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 棋子可以移动的距离
- en: Engage Thrusters
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – tracking moves available for all pieces from Pieces superclass
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 – 从`Pieces`超类跟踪所有棋子的可用移动
- en: 'Because the preceding things can be tracked at a central place, let''s define
    a method named `moves_available` in our superclass, `Pieces` (see *code 4.04:
    pieces.py*), for tracking moves available for all pieces as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因为前面的东西可以在一个中心位置跟踪，让我们在我们的超类`Pieces`中定义一个名为`moves_available`的方法，用于跟踪所有棋子的可用移动，如下所示：
- en: '[PRE16]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The description of the code is listed as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: 'The method accepts four arguments: the current position of a piece, two Boolean
    values representing whether or not diagonal and orthogonal movements are allowed
    for a piece, and the number of squares a piece can move at one time.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法接受四个参数：棋子的当前位置，两个表示是否允许棋子进行对角线和正交移动的布尔值，以及棋子一次可以移动的方格数。
- en: Depending upon these arguments, the method collects all allowed moves for a
    given piece in a list, `allowed_moves`.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据这些参数，该方法收集给定棋子的所有允许移动到一个列表中，`allowed_moves`。
- en: Having collected all directions of movements, the code iterates through all
    locations to detect any possible collision. If collision is detected, it breaks
    out of the loop, else it appends the coordinate to `allowed_moveslist`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集了所有移动方向后，代码会遍历所有位置以检测任何可能的碰撞。如果检测到碰撞，它会跳出循环，否则会将坐标添加到`allowed_moveslist`中。
- en: '`collision = True` is our way to break out of the loop. We need to break out
    of the loop in two cases: when the destination is occupied, and when it is not
    occupied, and we have already appended that position into our list of possible
    moves.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collision = True`是我们跳出循环的方式。我们需要在两种情况下跳出循环：当目的地被占用时，以及当它没有被占用，并且我们已经将那个位置添加到我们的可能移动列表中。'
- en: The second last line filters out those moves that fall out of the board, and
    the last line returns the equivalent board notations for all allowed moves.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行最后过滤掉那些超出棋盘的移动，最后一行返回所有允许移动的等效棋盘表示。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Having defined our `moves_available` method, we now simply need to call it
    from different pieces class.(see *code 4.04: pieces.py*).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '定义了我们的`moves_available`方法后，我们现在只需从不同的棋子类中调用它。（见 *代码 4.04: pieces.py*）。'
- en: Step 2 – rules for the king, queen, rook and bishop class
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 – 国王、皇后、车和象类的规则
- en: King, queen, rook, and bishop pieces on the chessboard have relatively simple
    rules governing them. These pieces can capture only in the direction in which
    they move.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 棋盘上的国王、皇后、车和象有相对简单的规则来规范它们。这些棋子只能在其移动方向上捕获。
- en: Moreover, they move in either orthogonal, diagonal, or a combination of these
    two directions. We have already coded `moves_available` in our superclass to handle
    these directions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它们可以在正交、对角或这两种方向的组合中移动。我们已经在我们的超类中编码了`moves_available`来处理这些方向。
- en: Accordingly, deciding their available moves is just a matter of passing the
    right arguments to our `moves_available` method.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，决定它们的可用移动只需将正确的参数传递给我们的`moves_available`方法。
- en: '[PRE17]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Step 3 – rules for knight
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 – 马的规则
- en: Knight is a different beast because it does not move orthogonally or diagonally.
    It can also jump over pieces.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 马是一种不同的生物，因为它既不沿正交也不沿对角移动。它还可以跳过其他棋子。
- en: Let's, therefore override the `moves_available` method from our `Knight` class.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从我们的`Knight`类中重写`moves_available`方法。
- en: 'The `Knight` class is defined as follows (see *code 4.04: pieces.py*):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`Knight`类定义如下（见 *代码 4.04: pieces.py*）：'
- en: '[PRE18]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The description of the code is listed as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The method is quite similar to our previous super class method. However, unlike
    the super class method, the changes are represented to capture moves two squares
    in one direction, and then one more move at a 90 degree angle.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法与我们的上一个超类方法非常相似。然而，与超类方法不同，变化被表示为捕获一个方向上的两个方格的移动，然后在一个90度的角度上再移动一次。
- en: Similarly, unlike the super class, we do not need to track collisions, because
    knights can jump over other pieces.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与超级类不同，我们不需要跟踪碰撞，因为马可以跳过其他棋子。
- en: Step 4 – rules for pawn
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步 - 兵的规则
- en: Pawn too has a unique movement, in that it moves forward, but captures diagonally.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 兵也有独特的移动方式，它向前移动，但可以向前方对角线捕获。
- en: 'Let''s similarly override the `moves_available` class from within the `Pawn`
    class as follows (see *code 4.04: pieces.py*):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '我们同样可以在 `Pawn` 类内部覆盖 `moves_available` 类，如下所示（见 *代码 4.04: pieces.py*）：'
- en: '[PRE19]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The description of the code is listed as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We first assign variables `startpos`, `direction`, and `enemy` depending on
    whether the pawn is black or white.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先根据兵是黑色还是白色分配变量 `startpos`、`direction` 和 `enemy`。
- en: Similar to our previous `moves_allowed` methods, this method also collects all
    allowed moves in a blank list, `allowed_moves`.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与我们之前的 `moves_allowed` 方法类似，此方法也收集所有允许的走法到一个空白列表 `allowed_moves` 中。
- en: We then collect a list of all prohibited moves by concatenating two lists of
    squares occupied by all black and white pieces.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们随后通过连接所有黑白棋子占据的方格列表来收集所有禁止的走法。
- en: We define a list, `forward`, which holds the position of the one square immediately
    ahead of the current position of pawn.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一个列表 `forward`，它保存了兵当前位置前方一个方格的位置。
- en: A pawn cannot move forward if there is a piece in front of it. If the forward
    position is not prohibited, the position is appended to our `allowed_moves` list.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果前方有棋子，兵不能向前移动。如果前方位置没有被禁止，该位置将被添加到我们的 `allowed_moves` 列表中。
- en: A pawn can move two places forward from its starting position. We check to see
    if the current position is the starting position, and if true, we append the double
    move to our `allowed_moves` list.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兵可以从起始位置向前移动两步。我们检查当前位置是否是起始位置，如果是，我们将双重移动添加到我们的 `allowed_moves` 列表中。
- en: A pawn can capture only diagonally adjacent pieces in front of it. We, therefore,
    assign a variable attack to track the diagonally adjacent positions on the board.
    If the diagonally adjacent square is occupied by an enemy, that position qualifies
    to be appended to our list, `allowed_moves`.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兵只能向前方对角线相邻的棋子进行捕获。因此，我们分配一个变量 `attack` 来跟踪棋盘上的对角线相邻位置。如果对角线相邻的方格被敌人占据，该位置符合添加到我们的列表
    `allowed_moves` 中。
- en: We then filter our list to remove all positions which may fall off the board.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们随后过滤我们的列表，移除所有可能超出棋盘边界的位置。
- en: The last line returns all allowed moves as a list of corresponding letter notations,
    as we had done in all our previous definitions.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一行返回所有允许的走法，作为一个对应字母标记的列表，正如我们在所有之前的定义中所做的那样。
- en: Objective Complete – Mini Debriefing
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简短总结
- en: In this iteration, we coded the logic for enforcing rules related to movement
    of chess pieces on the board.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们编写了与棋盘上棋子移动相关的规则执行逻辑。
- en: The chessboard logic
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 棋盘逻辑
- en: Before we allow chess pieces to move on click of the mouse button, we must have
    a record of all possible movement options on the board. At every move, we also
    need to check that it is a legitimate turn for a given player, and that the proposed
    move should not cause a check on the king.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们允许棋子在鼠标点击时移动之前，我们必须记录棋盘上所有可能的移动选项。在每次移动时，我们还需要检查这是否是给定玩家的合法回合，以及提议的走法是否不会导致对国王的将军。
- en: Now a check may occur on the king, not only from a piece that was moved, but
    from any other piece on the board as a consequence of such movement. Thus, after
    every move, we need to calculate the possible moves for all the pieces of the
    opponent.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对国王的将军可能不仅来自移动的棋子，还可能来自棋盘上任何其他棋子，这是由于这种移动造成的。因此，在每一步之后，我们需要计算对手所有棋子的可能走法。
- en: 'Accordingly we will need two methods to:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要两种方法来：
- en: Keep track of all available moves for a player
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪一个玩家所有可用走法
- en: Verify if there is a check on the king
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证是否有对国王的将军
- en: 'Let''s add the code for the preceding methods into our `Board` class. (See
    *code 4.05: chessboard.py*)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们把前面方法的代码添加到我们的 `Board` 类中。（见 *代码 4.05: chessboard.py*）'
- en: Engage Thrusters
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'Step 1: Tracking all Available Moves'
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步：跟踪所有可用走法
- en: 'The code for keeping track of all available moves for a player is as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪一个玩家所有可用走法的代码如下：
- en: '[PRE20]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The description of the code is listed as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We have already coded our `moves_available` method in the previous iteration.
    This method simply iterates through every item in the dictionary and appends the
    `moves_available` result for each piece of a given color in a list named `result`.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经在之前的迭代中编写了我们的`moves_available`方法。该方法简单地遍历字典中的每个项，并将给定颜色的每个棋子的`moves_available`结果追加到名为`result`的列表中。
- en: 'Step 2: Getting Current Position of King'
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步：获取国王当前位置
- en: 'Before we code the method to verify if a king is in check, we first need to
    know the exact position of the king. Let''s define a method to get the current
    position of the king, as follows (see *code 4.05: chessboard.py*):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写验证国王是否受将军的方法之前，我们首先需要知道国王的确切位置。让我们定义一个方法来获取国王的当前位置，如下（见*代码4.05：chessboard.py*）：
- en: '[PRE21]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code simply iterates through all items in the dictionary. If a
    given position is an instance of the `King` class, it simply returns its position.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码简单地遍历字典中的所有项。如果给定位置是`King`类的实例，它简单地返回其位置。
- en: 'Step 3: Verifying if King is under Check'
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步：验证国王是否受到将军
- en: 'Finally, we define a method to verify if the king is under check from the opponent
    as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了一种方法来验证国王是否受到对手的将军，如下所示：
- en: '[PRE22]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The description of the code is listed as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We first obtain the current position of the king, and the color of the opponent.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先获取国王的当前位置和对手的颜色。
- en: We then iterate through all possible moves for all pieces of the opponent. If
    the position of the king coincides with any position from all possible moves,
    the king is under check, and we return `True`, else we return `False`.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们遍历对手所有棋子的所有可能走法。如果国王的位置与所有可能走法中的任何一个位置重合，则国王处于将军状态，我们返回`True`，否则返回`False`。
- en: Objective Complete – Mini Debriefing
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简短总结
- en: This completes our objectives for the iteration. We are now in a position to
    check for all available moves for a player at a given point in the game. We can
    also verify if a king is under check from the opponent team.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的迭代目标。我们现在可以检查游戏中某个特定点的所有可用走法。我们还可以验证国王是否受到对手团队的将军。
- en: Making the chess functional
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使棋盘功能化
- en: Now that we have all pieces and board-related validation rules in place, let's
    now add life to our chess. In this iteration, we will make our chess game fully
    functional.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了所有棋子和棋盘相关的验证规则，让我们现在给我们的棋盘注入活力。在这个迭代中，我们将使我们的棋盘游戏完全功能化。
- en: 'In a game between two players, our chessboard would be like one shown in the
    following screenshot:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在两名玩家之间的游戏中，我们的棋盘将类似于以下截图所示：
- en: '![Making the chess functional](img/7941_04_05.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![使棋盘功能化](img/7941_04_05.jpg)'
- en: The objective for this iteration is to move pieces on click of the left mouse
    button. When a player clicks on a piece, our code should first check if it is
    a legitimate turn for that piece.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 本迭代的目的是在左键点击时移动棋子。当玩家点击一个棋子时，我们的代码应首先检查这是否是该棋子的合法回合。
- en: On the first click, the piece to be moved is selected, and all allowed moves
    for that piece are highlighted on the board. The second click should happen on
    the destination square. If the second click is done on a valid destination square,
    the piece should move from the source square to the destination square.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次点击时，选择要移动的棋子，并在棋盘上突出显示该棋子的所有允许走法。第二次点击应该在目标方格上。如果第二次点击在有效的目标方格上，则棋子应从源方格移动到目标方格。
- en: We also need to code the events of capturing of pieces and check on king. Other
    attributes to be tracked include list of captured pieces, halfmove clock count,
    fullmove number count, and history of all previous moves.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要编写捕获棋子和将军国王的事件。其他需要跟踪的属性包括捕获的棋子列表、半回合时钟计数、全回合数计数以及所有先前走法的记录。
- en: Engage Thrusters
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – updating the board for change in FEN notation
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 - 更新FEN表示法变化后的棋盘
- en: 'So far, we have the ability to take the original FEN notation and display it
    on board. However, we need a way that takes any FEN notation and updates the display
    on the board. We define a new method named `show()` to do this, as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有能力将原始FEN表示法显示在棋盘上。然而，我们需要一种方法，可以接受任何FEN表示法并更新棋盘上的显示。我们定义了一个名为`show()`的新方法来完成此操作，如下所示：
- en: '[PRE23]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Step 2 – binding mouse click event
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 - 绑定鼠标点击事件
- en: 'The pieces need to move on click of the mouse. So, we need to track the mouse
    click event. We only need to track mouse clicks on the Canvas widget. Let us,
    therefore, add an event handler to our `GUI` class immediately after the code
    that created the Canvas widget in the `init` method as follows (see *code 4.06:
    gui.py, __init__ method*):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '棋子需要在鼠标点击时移动。因此，我们需要跟踪鼠标点击事件。我们只需要跟踪在 Canvas 小部件上的鼠标点击。因此，我们将在 `init` 方法中创建
    Canvas 小部件的代码之后立即添加一个事件处理器到我们的 `GUI` 类中，如下所示（见 *代码 4.06: gui.py, __init__ 方法*）：'
- en: '[PRE24]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will bind the left mouse click event to a new method, `square_clicked`.
    However, before we sit down and define this method, let's pause and think about
    the attributes we need to keep tracking our program.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把左键点击事件绑定到一个新方法 `square_clicked`。然而，在我们坐下来定义这个方法之前，让我们暂停一下，思考我们需要跟踪程序的一些属性。
- en: Step 3 – adding attribute to track selected piece and remaining pieces
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步 – 添加属性以跟踪所选棋子和剩余棋子
- en: 'First of all, we need to track all pieces remaining on the board after every
    move. So we will create a dictionary pieces to keep track of this. We also need
    to track the name of the piece selected by the mouse click. We store that in an
    attribute, `selected_piece`. When a player clicks on a piece, we need to highlight
    all valid moves for that piece. We store all valid moves for that piece in a list
    named `focused`. Let''s define these three attributes in our `GUI` class before
    defining any of the methods. We modify our `GUI` class to include these attributes
    as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要跟踪每次移动后棋盘上剩余的所有棋子。因此，我们将创建一个名为 pieces 的字典来跟踪这一点。我们还需要跟踪鼠标点击所选的棋子名称。我们将其存储在一个属性
    `selected_piece` 中。当玩家点击一个棋子时，我们需要突出显示该棋子的所有有效移动。我们将该棋子的所有有效移动存储在一个名为 `focused`
    的列表中。在我们定义任何方法之前，让我们在 `GUI` 类中定义这三个属性。我们修改 `GUI` 类以包括这些属性，如下所示：
- en: '[PRE25]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Step 4 – identifying square clicked
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 4 步 – 识别点击的方格
- en: We will code our `square_clicked` method that gets called from the event handler
    we defined earlier.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写 `square_clicked` 方法，该方法由我们之前定义的事件处理器调用。
- en: The desired functionality of this method is twofold. We should be able to locate
    the coordinate of a piece being clicked. The first click should select a given
    piece. The second click should move the piece from the source square to the destination
    square.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的预期功能有两方面。我们应该能够定位被点击棋子的坐标。第一次点击应选择一个给定的棋子。第二次点击应将棋子从源方格移动到目标方格。
- en: 'The method is defined as follows(see *code 4.06: gui.py*):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '该方法定义为如下（见 *代码 4.06: gui.py*）：'
- en: '[PRE26]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The description of the code is listed as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The first part of code calculates the coordinates for the piece clicked. Based
    on the calculated coordinates, it stores the corresponding letter notation in
    a variable named `pos`.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的第一部分计算被点击棋子的坐标。根据计算出的坐标，它将相应的字母表示存储在一个名为 `pos` 的变量中。
- en: It then tries to assign the variable piece to the corresponding piece instance.
    If there is no piece instance on the clicked square, it simply ignores the click.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后尝试将变量 piece 分配给相应的棋子实例。如果点击的方格上没有棋子实例，它将简单地忽略点击。
- en: The second part of the method checks if this is the second click intended to
    move a piece to a destination square. If this is the second click, it calls the
    `shift` method, passing in the source and destination coordinates as its two arguments.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的第二部分检查这是否是第二个点击，目的是将棋子移动到目标方格。如果是第二个点击，它将调用 `shift` 方法，传入源坐标和目标坐标作为其两个参数。
- en: If shift succeeds, it sets back all previously set attributes to their original
    empty values and calls our `draw_board` and `draw_pieces` method to redraw the
    board and pieces.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果位移成功，它将所有之前设置的属性重置为其原始的空值，并调用我们的 `draw_board` 和 `draw_pieces` 方法来重新绘制棋盘和棋子。
- en: If this is the first click, it calls a method named `focus` to highlight all
    available moves for the first click, followed by a call to draw the fresh board.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这是第一次点击，它将调用一个名为 `focus` 的方法来突出显示第一次点击的所有可用移动，然后调用绘制新棋盘。
- en: While coding the desired functionality for the `square_clicked` method, we called
    several new methods from within it. We need to define those new methods.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 `square_clicked` 方法的所需功能时，我们在其中调用了几个新的方法。我们需要定义这些新方法。
- en: Step 5 – getting the source and destination position
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 5 步 – 获取源和目标位置
- en: We have called the `shift` method from the `square_clicked` method. The following
    shift code implemented is simply responsible for collecting the necessary arguments
    required for the shift operation.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `square_clicked` 方法中调用了 `shift` 方法。以下实现的 shift 代码仅负责收集移位操作所需的必要参数。
- en: In the spirit of keeping logic separate from presentation, we do not process
    shift-related rules in this view class. Instead, we delegate the `shift` method
    work from the `GUI` to `Board` class. Once the logic or validation for shift has
    been implemented, the visible part of the shift of pieces again takes place in
    the `draw_board` method of our `GUI` class.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持逻辑与展示分离的精神下，我们在这个视图类中不处理移位相关的规则。相反，我们将 `shift` 方法的任务从 `GUI` 类委托给 `Board`
    类。一旦移位的逻辑或验证被实现，棋子移位的可见部分再次在我们的 `GUI` 类的 `draw_board` 方法中发生。
- en: Although this may seem like overkill at first, structuring logic and presentation
    in different layers is very important for code reuse, scalability, and maintainability.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始这可能看起来有些过度，但将逻辑和展示结构化在不同的层中对于代码的重用、可扩展性和可维护性非常重要。
- en: 'The code is as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE27]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The code first checks if there exists a piece on the destination. If a piece
    does not exist at the destination square, it calls on a method, `shift`, from
    `chessboard.py`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先检查目标位置是否存在棋子。如果目标位置没有棋子，它将调用来自 `chessboard.py` 的 `shift` 方法。
- en: Step 6 – collecting list of moves to highlight
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第6步 – 收集要突出显示的移动列表
- en: We have also called the focus method from `square_clicked` method. The purpose
    of this method is to collect all possible moves for a given piece in a list named
    `focused`. The actual focusing of available moves takes place in the `draw_board`
    method of our GUI class.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从 `square_clicked` 方法中调用了 focus 方法。这个方法的目的在于将给定棋子的所有可能移动收集到一个名为 `focused`
    的列表中。实际的可移动性聚焦发生在我们 GUI 类的 `draw_board` 方法中。
- en: 'The code is as follows (see code 4.06: gui.py):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下（见代码 4.06：gui.py）：
- en: '[PRE28]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Step 7 – modifying draw_board to highlight allowed moves
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7步 – 修改 draw_board 以突出显示允许的移动
- en: 'In the `square_clicked` method, we called the `draw_board` method to take care
    of redrawing or changing the coordinates for our pieces. Our current `draw_board`
    method is not equipped to handle this, because we had designed it in the first
    iteration only to provide us with a blank board. Let''s first modify our `draw_board`
    method to handle this, as follows (see *code 4.06: gui.py*):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `square_clicked` 方法中，我们调用了 `draw_board` 方法来处理重新绘制或更改棋子的坐标。我们当前的 `draw_board`
    方法还没有配备处理这个功能，因为我们最初只设计它来提供一个空白棋盘。让我们首先修改我们的 `draw_board` 方法来处理这个功能，如下（见 *代码 4.06：gui.py*）：
- en: '[PRE29]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The description of the code is listed as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The additions made to our existing `draw_board` method are highlighted in the
    preceding code. We first define an attribute named `highlightcolor`, and assign
    it a color.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有的 `draw_board` 方法中添加的内容在上面的代码中突出显示。我们首先定义了一个名为 `highlightcolor` 的属性，并为其分配了一个颜色。
- en: In essence, the code has been modified to handle the clicks. The first section
    of highlighted code fills a different color to highlight all available moves.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的本质修改是为了处理点击。高亮显示代码的第一部分用不同的颜色突出显示所有可用的移动。
- en: The second section of highlighted code changes the coordinates of the piece
    instance to be located on new coordinates. Note the use of `canvas.coords(name,
    x0, y0)` to change the coordinates.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高亮显示代码的第二部分更改了棋子实例的坐标，以便位于新的坐标上。注意使用 `canvas.coords(name, x0, y0)` 来更改坐标。
- en: The last two lines change the precedence of options specified by tags.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后两行更改了由标签指定的选项的优先级。
- en: Note
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If an object on the canvas is tagged to multiple tags, options defined for tags
    at the top of the stack have higher precedence. You can, however, change the precedence
    of tags by using `tag_raise(name)` or `tag_lower(name)`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果画布上的对象被标记为多个标签，则堆栈顶部的标签定义的选项具有更高的优先级。然而，你可以通过使用 `tag_raise(name)` 或 `tag_lower(name)`
    来更改标签的优先级。
- en: For a complete list of canvas-related options, refer to interactive help for
    the Canvas widget using `help(Tkinter.Canvas)` in the command line.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取与画布相关的选项的完整列表，请参考使用命令行中的 `help(Tkinter.Canvas)` 对 Canvas 小部件的交互式帮助。
- en: Step 8 – defining attributes to keep game statistics
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第8步 – 定义用于保持游戏统计信息的属性
- en: 'As a consequence of adding mobility to our pieces, we need to add the following
    new attributes to our `Board` class to keep game statistics, as follows (see *code
    4.06: chessboard.py*):'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 由于为我们的棋子添加了移动性，我们需要向我们的 `Board` 类添加以下新属性以保持游戏统计信息，如下（见 *代码 4.06：chessboard.py*）：
- en: '[PRE30]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Step 9 – preshift validations
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第9步 – 预移动验证
- en: 'For that, we will code the `shift` method of our `Board` class, as follows
    (see *code 4.06: chessboard.py*):'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '为了这个，我们将编写 `Board` 类的 `shift` 方法，如下所示（见 *代码4.06: chessboard.py*）：'
- en: '[PRE31]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The description of the code is listed as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The code first checks if there exists a piece on the destination.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码首先检查目标位置上是否存在棋子。
- en: It then checks if it is a valid turn for the player. If not, it raises an exception.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它检查是否是玩家的有效回合。如果不是，它会抛出一个异常。
- en: It then checks if the move is proposed to occur to a valid location. If a player
    attempts to move a piece to an invalid location, it raises a corresponding exception.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后检查移动是否被提议到有效位置。如果玩家试图将棋子移动到无效位置，它会抛出一个相应的异常。
- en: 'It then checks if there is a check on the king. To do that, it calls a method
    named `is_in_check_after_move`, which is defined as follows:'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它检查国王是否受到攻击。为了做到这一点，它调用一个名为 `is_in_check_after_move` 的方法，该方法定义如下：
- en: '[PRE32]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This method creates a deep temporary copy of the object and tries to move the
    piece on the temporary copy. As a note, shallow copy of a collection is a copy
    of the collection structure, not the elements. When you do a shallow copy, the
    two collections now share the individual elements, so a modification at one place
    affects the other as well. In contrast, deep copies makes copy of everything,
    the structure as well as the elements. We need to create a deep copy of the board,
    because we want to check if the king makes a valid move before it actually moves
    and we want to do that without modifying the original object state in any way.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法创建对象的深拷贝，并在临时拷贝上尝试移动棋子。作为备注，集合的浅拷贝是集合结构的拷贝，而不是元素的拷贝。当你进行浅拷贝时，两个集合现在共享单个元素，所以一个地方的改变也会影响另一个。相比之下，深拷贝会复制一切，包括结构和元素。我们需要创建棋盘的深拷贝，因为我们想在移动之前检查国王是否做出有效移动，并且我们想在不以任何方式修改原始对象状态的情况下做到这一点。
- en: After executing the move on the temporary copy, it checks if the king is in
    check to return `True` or `False`. If the king is in check on the temporary board,
    it raises an exception, not allowing such a move on our actual board.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在临时拷贝上执行移动后，它检查国王是否受到攻击以返回 `True` 或 `False`。如果临时棋盘上的国王受到攻击，它会抛出一个异常，不允许在我们的实际棋盘上进行这样的移动。
- en: Similarly, it checks for possible occurrence of checkmate or draw and raises
    exceptions accordingly.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，它检查是否有可能发生将死或平局，并相应地抛出异常。
- en: If no exceptions are made, it finally calls a method named `move`, which actually
    executes the move.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有抛出异常，它最终会调用一个名为 `move` 的方法，该方法实际上执行移动操作。
- en: Step 10 – actual movement of pieces
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第10步 – 棋子的实际移动
- en: 'Actual movement of pieces can be coded as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 棋子的实际移动可以编码如下：
- en: '[PRE33]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Step 11 – Post movement updates
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第11步 – 移动后的更新
- en: 'After the move has actually been executed, it calls another method named `complete_move`,
    which updates game statistics as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 实际执行移动后，它调用另一个名为 `complete_move` 的方法，按照以下方式更新游戏统计信息：
- en: '[PRE34]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding method does the following tasks:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法执行以下任务：
- en: Keeps track of statistics, such as number of moves, halfmove clock
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪统计信息，例如移动次数、半回合时钟
- en: Changes the player's turn
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变玩家的回合
- en: Checks if a pawn has been moved so as to reset the halfmove clock
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否有棋子被移动以重置半回合时钟
- en: And finally, appends the last move to our history list
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，将最后一步移动添加到我们的历史列表中
- en: Step 12 – classes to handle exceptions and errors
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第12步 – 处理异常和错误的类
- en: 'Finally, we add the following empty classes for various exceptions raised by
    us:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了以下空类以处理我们抛出的各种异常：
- en: '[PRE35]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Objective Complete – Mini Debriefing
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: Let's summarize things that we did in this iteration
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下在这个迭代中我们所做的事情
- en: We started by binding a mouse click event to a method named `square_clicked`.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先将鼠标点击事件绑定到一个名为 `square_clicked` 的方法上。
- en: We added attributes to track selected piece and remaining pieces on the board.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了属性来跟踪选中的棋子和棋盘上剩余的棋子。
- en: We then identified the square clicked, followed by collecting the source and
    destination position.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们识别了被点击的方块，随后收集了起始和目标位置。
- en: We also collected a list of all possible moves for the selected piece, and then
    highlighted them.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还收集了所选棋子的所有可能移动列表，并将它们突出显示。
- en: We then defined attributes to keep vital game statistics.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们定义了属性以保持重要的游戏统计信息。
- en: We then did some preshift validations, followed by actual movement of pieces
    on the board.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们进行了一些预移动验证，接着在棋盘上实际移动棋子。
- en: After a piece had been moved, we updated statistics about the game.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个棋子被移动后，我们更新了关于游戏的统计数据。
- en: We had defined several exceptions in this iteration. We simply defined empty
    classes to handle them silently.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们定义了几个异常。我们只是定义了空类来静默处理它们。
- en: Our chess game is now functional. Two players can now play a game of chess on
    our application.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的国际象棋游戏现在功能齐全。现在，两位玩家可以在我们的应用程序上玩一局棋。
- en: Adding menu and an info frame
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加菜单和信息框架
- en: Though our game is fully functional, let's add two small features to it.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的游戏已经完全可用，但让我们给它添加两个小功能。
- en: Let's add a top menu item by navigating to **File** | **New Game**. When clicked,
    it should reset the board to a new game.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在**文件** | **新游戏**下添加一个顶部菜单项。当点击时，它应该将棋盘重置为新游戏。
- en: Additionally, let's add a small frame at the bottom to display game-related
    information, such as the last move, next turn, check, draw, and checkmate.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们在底部添加一个小的框架来显示与游戏相关的信息，例如最后一步移动、下一个回合、检查、和棋以及将军。
- en: '![Adding menu and an info frame](img/7941_04_06.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![添加菜单和信息框架](img/7941_04_06.jpg)'
- en: Engage Thrusters
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: Step 1 – creating top menu
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步 – 创建顶部菜单
- en: Our Canvas widget was set up in the the `__init__` method of our `GUI` class.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Canvas小部件是在`GUI`类的`__init__`方法中设置的。
- en: 'Let''s modify it to include the top menu, as follows (see *code 4.06: gui.py*):'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们修改它以包括顶部菜单，如下所示（见 *代码4.06: gui.py*）：'
- en: '[PRE36]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Step 2 – adding the bottom frame to display game statistics
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步 – 添加底部框架以显示游戏统计信息
- en: 'Let''s also add a bottom frame to display game statistics to the same `__init__`
    method, as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们也添加一个底部框架来显示游戏统计信息，如下所示（见 *代码4.06: gui.py*）：'
- en: '[PRE37]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The modification to existing init method is highlighted. The code is self-explanatory.
    We have done similar things in all our previous projects.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 对现有初始化方法的修改被突出显示。代码是自我解释的。我们在所有之前的项目中都做了类似的事情。
- en: Step 3 – starting a new game from File | New game menu
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 – 从文件 | 新游戏菜单开始新游戏
- en: 'The **File** | **New game** menu item calls on our method, `new_game()`. The
    code for `new_game()` is as follows (see *code 4.06: gui.py*):'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件** | **新游戏**菜单项调用我们的`new_game()`方法。`new_game()`的代码如下（见 *代码4.06: gui.py*）：'
- en: '[PRE38]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Step 4 – updating bottom label after every move
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步 – 每次移动后更新底部标签
- en: 'Finally, after every move, we want to update the label with details of the
    move and information about the next players turn. We also want to update the frame
    to display any error or exception that may have occurred during the move attempt.
    We accordingly modify the `shift` method of our `GUI` class to do this update
    for us as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在每次移动后，我们希望更新标签以显示移动的详细信息以及关于下一位玩家回合的信息。我们还想更新框架以显示在移动尝试过程中可能发生的任何错误或异常。因此，我们相应地修改了`GUI`类的`shift`方法，如下所示以完成此更新：
- en: '[PRE39]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The description of the code is listed as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下所示：
- en: The modifications to our `shift` method are highlighted. We have simply included
    the `shift` method of our `Board` class in a try except block. If the shift is
    successful, the Label widget is updated to show the current move and the next
    players turn.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对`shift`方法的修改被突出显示。我们只是将`Board`类的`shift`方法包含在一个try except块中。如果位移成功，标签小部件将更新以显示当前移动和下一位玩家的回合。
- en: If the shift is not successful, either because of invalid move or a check on
    the king, the corresponding error class name is displayed in the label with `error.__class__.__name__`.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果位移不成功，无论是由于无效的移动还是对国王的检查，相应的错误类名将显示在带有`error.__class__.__name__`的标签上。
- en: Objective Complete – Mini Debriefing
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: This completes our goal for the iteration. The application now displays some
    useful information to the players during the course of a chess game.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们这次迭代的目标。现在，在棋局过程中，应用程序会向玩家显示一些有用的信息。
- en: We also added a **File** | **New menu** item, which can be used to reset the
    board to starting position.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个**文件** | **新菜单**项，可以用来将棋盘重置到起始位置。
- en: Mission Accomplished
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务完成
- en: We now come to the end of the project.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在来到了项目的尾声。
- en: 'So what is it that we have achieved here? Let''s list all the key learning
    from this project:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在这里取得了什么成果呢？让我们列出从这个项目中获得的所有关键学习点：
- en: How to structure a program into its model and view components
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将程序结构化为模型和视图组件
- en: How to represent a problem domain in a desired notation
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何用期望的符号表示问题域
- en: Peek into the versatility and power of the Tkinter Canvas widget
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Tkinter Canvas小部件的多样性和强大功能
- en: Basic usage of Canvas coordinates, object IDs and tags
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Canvas坐标、对象ID和标签的基本用法
- en: How to work with newer image formats
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理新的图像格式
- en: Typical interaction of logic and presentation layers in a GUI program
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GUI 程序中逻辑层和表示层之间的典型交互
- en: Next project onwards, we take a look at different Tkinter widgets in greater
    detail.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一个项目开始，我们将更详细地查看不同的 Tkinter 小部件。
- en: A Hotshot Challenge
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热门挑战
- en: 'Here are the two hotshot challenges for you:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个热门挑战供您挑战：
- en: 'Add and implement the following menu items:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加并实现以下菜单项：
- en: '**File** | **Save**: Save a game state'
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件**| **保存**：保存游戏状态'
- en: '**File** | **Open**: Loads a previously saved game'
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件**| **打开**：加载之前保存的游戏'
- en: '**Edit**| **Undo**: To let the players undo the turns played'
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑**| **撤销**：允许玩家撤销已进行的回合'
- en: '**Edit** |**Redo**: To let the players redo any previous undo'
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑**|**重做**：允许玩家重做任何之前的撤销操作'
- en: '**View** | **Moves History**: Opens a new Toplevel window to display the history
    of the game'
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看**| **移动历史**：打开一个新的 Toplevel 窗口以显示游戏的历史'
- en: '**About**| **About**: Displays information about the game'
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关于**| **关于**：显示有关游戏的信息'
- en: Implement castling and En passant features in the game.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏中实现王车易位和过路兵的功能。
