- en: Chapter 4. Game of Chess
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now build a game of chess in Tkinter. You do not need to be a master at
    chess to build this game. If you have ever played chess and you know the basic
    rules that govern the chess pieces, you are ready to write this program.
  prefs: []
  type: TYPE_NORMAL
- en: If you have never played chess and do not know the basic rules, you would better
    start by reading those rules from the Internet before you start programming this
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Mission Briefing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In its final form our chess game would look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mission Briefing](img/7941_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our chess game would enforce all standard rules applicable to the game of chess.
    Some advanced rules and features are left as an exercise for you to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Why Is It Awesome?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the process of building our chess application, we get introduced to the Tkinter
    Canvas widget, which is considered one of the most powerful and versatile features
    of Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: As you will see in the course of this project, the Canvas widget is a really
    powerful tool for a GUI programmer. It can be used to sketch compound objects
    using lines, rectangles, ovals, and polygons. It will also let you position images
    on the canvas with great accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the Canvas widget will let you place any other widget (such as
    labels, buttons, scale, and other widgets) on itself. This makes it an ideal container
    for accommodating widgets for a variety of different GUI programs.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to learning about the Canvas widget, you will also get an insight
    on how to structure your data using Python built-in types. You will also be introduced
    to the concepts involved in selecting pertinent objects and structuring them into
    classes and modules at the right granularity.
  prefs: []
  type: TYPE_NORMAL
- en: As the application develops, we are also introduced to several other Python
    modules that you will often use in a variety of application development projects.
  prefs: []
  type: TYPE_NORMAL
- en: Your Hotshot Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the key objectives for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: How to structure a program into its model and view components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to represent a problem domain in a desired notation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peeking into the versatility and power of the Tkinter Canvas widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic usage of canvas coordinates, object IDs and tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with newer image formats not supported by the Tkinter photo image
    class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical interaction of logic and presentation layers in a GUI program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mission Checklist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will need to process PNG images in our program. The Tkinter photo image class
    and other standard libraries of Python do not support PNG processing. We will
    use the **Python Imaging Library** (**PIL**) to render PNG files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the PIL package visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.pythonware.com/products/pil/](http://www.pythonware.com/products/pil/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are working on windows x64 (64 bit)or MacOSX machine, you may instead
    need to install and work with Pillow, which is a replacement for the PIL, from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow)'
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have installed the package, go to your Python interactive prompt
    and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`>>from PIL import ImageTk`'
  prefs: []
  type: TYPE_NORMAL
- en: If this executes without any error message, you are ready to make the chess
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring our program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All our previous projects have been structured as a single file. However, as
    programs grow in complexity, we need to break our programs into modules and class
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: Development of large applications generally starts with recording the **software
    requirement specifications** (**SRS**). This is generally followed by a graphical
    representation of constructs, such as class, composition, inheritance, and information
    hiding using several modeling tools. These tools can be flow charts, **unified
    modeling language** (**UML**), data flow diagrams, Venn diagrams (for database
    modeling), and several other tools.
  prefs: []
  type: TYPE_NORMAL
- en: These tools are very useful when the problem domain is not very clear. However,
    if you have ever played the game of chess, you are very well acquainted with the
    problem domain. Furthermore, our chess program may be classified as a medium-sized
    program spanning a few hundred lines of code. Let us, therefore, bypass these
    visual tools and get to the actual program design.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this iteration, we decide an overall structure for our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the true spirit of object-oriented programming (OOP), let''s first list
    the kind of objects that we would encounter in our program. An intuitive look
    at a chessboard tells us that we have two sets of objects to handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chessboard**: It is an 8 x 8 square board with alternatively colored squares'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chess pieces**: They are the king, queen, bishop, knight, rook, and pawns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we proceed, we may or may not come across other objects. But we are sure
    to come across these two kinds of objects. So, without much further delay, let
    us create two files named `chessboard.py` and `pieces.py` in our project folder.
    (See *code folder 4.01*)
  prefs: []
  type: TYPE_NORMAL
- en: We will use these two files to define the respective classes to keep the logic
    associated with these two objects. Note that these files will not display the
    board or its pieces; it will instead keep all logic related to board and pieces.
    In programming parlance, this is broadly referred to as the **model**.
  prefs: []
  type: TYPE_NORMAL
- en: The actual display of board and pieces will be kept in a separate file, which
    will handle all views related to the program.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rule of separating logic from presentation should be applied not only for
    deciding your file structure, but also when defining methods within your files.
  prefs: []
  type: TYPE_NORMAL
- en: Every time you write a method, try to separate its presentation from the logic.
    If you find a method mixing logic and presentation, refactor your code to separate
    the two. Avoid coupling the presentation and logic into the same method.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to keep the presentation layer (view) separate from logic
    (model). So, we will create a new file named `gui.py` to code all visible components
    of the program, including all our widgets. This file will be primarily responsible
    for generating the view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the model and view files, many programs also keep a separate
    controller file to decouple behavioral aspects of a program from the logic (model)
    and presentation (view). This kind of structural segregation is named the **model-view-controller**
    (**MVC**) style of programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, our chess program has just one event to handle: mouse click for moving
    chess pieces. Creating a separate controller for just one event can make the program
    more complex than it should be.'
  prefs: []
  type: TYPE_NORMAL
- en: Given this limitation, we will handle the presentation (view) and event handling
    (controller) from a single class named `GUI`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our file structure ready, let us start our coding. To begin,
    let's code the `GUI` class for our chessboard, as shown in the following screenshot.
    Because this pertains to the view section, let's put this code in the `gui.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '![Prepare for Lift Off](img/7941_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – creating the GUI class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We first create a `GUI` class and assign attributes such as rows, columns,
    colors of squares, and the dimension of each square in pixels. We initialize our
    `GUI` class to create the canvas on which we will draw our chessboard, as follows
    (see *code 4.01 gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a class, `GUI`, to handle the rendering of our view files. The `init`
    method of the `GUI` class is called immediately on object instantiation. The `init`
    method sets up a Canvas widget of the required size. This canvas will act as our
    container for all objects, such as chess square areas and eventually the chess
    pieces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have used the Canvas widget as a container, because it provides us the ability
    to handle tasks based on precise location coordinates of events, such as click
    of the mouse button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `init` method then calls the `draw_board()` method, which is responsible
    for creating square blocks of alternating colors similar to a chessboard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 2 – creating the chessboard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we draw the squares on the chessboard using the `canvas.create_rectangle`
    method, filling it alternating between the two colors we defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To draw squares on the board we use the `canvas.create_rectangle()` method,
    which draws a rectangle given the x, y coordinates for the two diagonally opposite
    corners of the rectangle (coordinates of upper-left and lower-right edges).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will need to target the board. We, therefore, add a tag named `area` to each
    of the squares created on the board. This is similar to tagging of the text widget,
    as we had done in our text editor program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 3 – creating Tkinter mainloop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we will create Tkinter mainloop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Outside the class, we have a main method that sets the Toplevel window, starts
    Tkinter mainloop, instantiates a `GUI` object, and calls the `drawboard()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Tkinter Canvas widget lets you draw line, oval, rectangle, arc, and polygon
    shapes at a given coordinate specified location. You can also specify various
    configuration options, such as fill, outline, width, and several others for each
    of these shapes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the Canvas widget has a huge list of methods and configurable
    options. For a complete list of canvas-related options, type the following into
    Python interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can also access the documentation of Tkinter in your core Python installation
    directory. The documentation is located at `path\to\python\installation\Doc\Python273`.
  prefs: []
  type: TYPE_NORMAL
- en: This is a compiled HTML help file. Within the help file, search for Tkinter,
    and you get a comprehensive reference with details of all widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This completes our first iteration. In this iteration, we decided the class
    structure for our chess program. We created a `GUI` class and added attributes
    we would normally expect a chessboard to have.
  prefs: []
  type: TYPE_NORMAL
- en: We also got our first taste of the Canvas widget. We created a blank canvas,
    and then added square areas using the `canvas.create_rectangle` method to create
    our chessboard.
  prefs: []
  type: TYPE_NORMAL
- en: We also created out Tkinter mainloop and created an object out of the `GUI`
    class from within our mainloop. Now, if you run `code 4.01 gui.py`, you will see
    a chessboard.
  prefs: []
  type: TYPE_NORMAL
- en: Classified Intel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Canvas widget comes with a rich set of methods and configurable options.
    However, there are three important things to note about the Canvas widget:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses a coordinate system to specify position of objects on the widget. Coordinates
    are measured in pixels. The top-left corner of the canvas has coordinates (0,0).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It offers methods to add images and to draw basic shapes, such as line, arc,
    ovals, and polygons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The objects drawn on the Canvas widget are usually handled through assigning
    them an ID or tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring chessboard-and-pieces-related data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our drum program, we had decided on a notation to describe a set of beat
    patterns. We could then store (pickle) that beat pattern notation and reproduce
    (unpickle) it later. The chess program is no different. It too needs a suitable
    notation for describing chess pieces and for locating their positions on the board.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can define our own notation for representing chess piece and their positions,
    but it turns out that there already exists a globally accepted, simple, compact,
    and standard notation for representing a chessboard. The notation is called **Forsyth-Edwards
    notation** (**FEN**) available at [http://en.wikipedia.org/wiki/Forsyth-Edwards_Notation](http://en.wikipedia.org/wiki/Forsyth-Edwards_Notation).
  prefs: []
  type: TYPE_NORMAL
- en: We might have decided to define our notation, but we preferred not to reinvent
    the wheel here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The FEN record for starting position of a chess game is written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key things to note about the notation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The notation displays six records for a chess game. Each record is separated
    by a blank space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first record shows the positions of pieces on a chessboard. Each row of
    the chessboard (rank) is represented in a section demarcated by the `/` symbol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the first record, each piece is identified by a single letter (pawn =
    `p`, knight = `n`, bishop = `b`, rook = `r`, queen = `q` and king = `k`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: White pieces are represented using uppercase letters (`PNBRQK`), but black pieces
    are represented by lowercase letters (`pnbrqk`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Squares with no pieces on it are represented using digits `1` through `8` (the
    number of blank squares).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second record denotes the turn of a player. Letter `w` denotes white turn,
    and letter `b` denotes black turn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third record `KQkq` indicates whether or not castling feature is available.
    If neither castle, this is `-`. Otherwise, this has one or more letters: `K` (white
    can castle kingside), `Q` (white can castle queenside), `k` (black can castle
    kingside), and/or `q` (black can castle queenside).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth record`_`captures En passant details for the game. We will not be
    implementing castling and En passant features in our game, so we can safely disregard
    these two records for now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth record keeps track of half-move clock for the game. The half-move
    clock keeps track of number of turns played since the last pawn advance or last
    capture. This is used to determine if a draw can be claimed under the fifty-move
    rule.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sixth record tracks the full-move number, which is incremented by 1 after
    each move of black. This is used to track the overall length for which a game
    was played.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The notation as previously stated can be represented pictorially along x and
    y axis as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prepare for Lift Off](img/7941_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using this notation, we can accurately represent any particular square on the
    chessboard.
  prefs: []
  type: TYPE_NORMAL
- en: The color of piece depends on whether the alphabet is in small letters (black)
    or capital letters (white).
  prefs: []
  type: TYPE_NORMAL
- en: Thus **A1** denotes the bottom and left-most square on the chessboard. Currently,
    it is occupied by a white rook. The **C3** position is currently empty, and **E8**
    has black king and **A8** has a black rook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following these rules, here is how the FEN notation would change after the
    following indicative turns played ([http://en.wikipedia.org/wiki/Forsyth-Edwards_Notation](http://en.wikipedia.org/wiki/Forsyth-Edwards_Notation)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'After first move, `P` to `e4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1`'
  prefs: []
  type: TYPE_NORMAL
- en: 'After second move, `p` to `c5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq c6 0 2`'
  prefs: []
  type: TYPE_NORMAL
- en: 'After third move, `N` to `f3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2`'
  prefs: []
  type: TYPE_NORMAL
- en: All our chessboard and piece related logic will use the preceding notation.
    It is, therefore, very important that we fully understand this notation before
    we proceed to code our game.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are clear about the preceding notation, let's apply the notation
    to represent our chessboard. The key idea here is that, given a FEN notation,
    we should be able to represent it on the board.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – creating a Piece superclass
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s now first code the model code for `pieces.py` (see *code 4.02 pieces.py*)
    by creating a `Piece` super class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We define a class, `Piece ()`. It's `__init__` method, which takes a color as
    an argument. In accordance with our FEN notation, it changes the shortname to
    lowercase letter for black and uppercase letter for white. The color handling
    is done in the superclass, `Piece`, because it is a common feature for all chess
    pieces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also define a method named `ref`. Its only purpose is to get an instance
    of the chessboard into the object namespace for the board and pieces to interact.
    We need this method, because our pieces will ultimately be interacting with the
    chessboard. Accordingly, we need a reference of the chessboard instance within
    the `Piece` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 2 – creating individual child classes for all pieces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can create individual child classes for all pieces as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We define classes for each of the pieces found on a chessboard. So, we have
    classes named `King`, `Queen`, `Rook`, `Knight`, `Bishop`, and `Pawn`. These classes
    are derived from the `Piece` super class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For now, these child classes merely define the shortname associated with them.
    We will later expand these child classes to define and enforce rules for movement
    of each of these pieces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 3 – defining a method to return the piece instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will define a method to return the piece instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The code defines a dictionary with pieces shortname and full name as key-value
    pair.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then define a method piece which takes a piece shortname and returns the
    corresponding piece instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 4 – creating the Board class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have a basic model ready for pieces, let''s code the model to deal
    with their placement on the chessboard. We code this in `chessboard.py`.(see *code
    4.02 chessboard.py*) by creating a `Board` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Our code begins with defining the starting pattern as per the FEN notation discussed
    earlier. We do not include the castle and En passant related notation, because
    we will not be coding that in our program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then define our `Board` class as a subclass of built-in `dict` type. This
    is because we will store the pattern as a dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then define `x_axis` and `y_axis` for our chessboard as nonimmutable tuples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__init__` method of our class simply calls the `process_notation` method
    of the class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 5 – displaying pieces on board for a given FEN notation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pieces on `Board` for a given FEN notation can be displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The job of the `process_notation` method is to first expand the blank spaces
    represented by integers into actual spaces. It uses Python built-in regular expression
    module (`re`) to expand white spaces in a given FEN notation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code, `expand_whitespaces`, does something that might be tricky for Python
    beginners. It replaces each digit by the corresponding number of whitespaces,
    so you can later assume that a whitespace is an empty square. It then converts
    the FEN notation into a string corresponding to x and y alphanumeric coordinate
    for every piece. For doing this, it calls another method named `alpha_notation`,
    which is defined in step 7.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final two lines keep a track of turns taken by the players.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 6 – checking if a given coordinate is on the board
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, let''s end this iteration by defining a method to check if a given
    coordinate is on the board, as follows (see *code 4.02 chessboard.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Step 7 – generating alphabetic and numeric notation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need a way to convert the x and y coordinates for a piece to its alphabetic
    equivalent notation for example, A1, D5, E3, and so on. We accordingly define
    the `alpha_notation` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we define a method that takes in an x,y coordinate as input and
    returns its equivalent numerical notation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Step 8 – checking places occupied on the board
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before every move, we will need to check all the places occupied by all the
    pieces of a given color. This is required not only to calculate valid moves, but
    to also ensure that move by some other piece does not cause a check on the king.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, let''s define a method to return a list of coordinates occupied
    by a given color (see *code 4.02 chessboard.py*) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Step 9 – handling errors and exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For handling errors and exceptions, we define a custom exception class named
    `ChessError`, and all other exceptions will later be subclassed to it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this iteration, we created a basic `Piece` class and dummy child classes
    for each of the pieces found on the chessboard. The individual piece classes inherit
    from the parent `Piece` class. We handle color identification in the parent class
    because it is something we need to do for all child classes.
  prefs: []
  type: TYPE_NORMAL
- en: We then defined our `Board` class and added some methods that we will surely
    need every time we want to move a piece on the board.
  prefs: []
  type: TYPE_NORMAL
- en: We are yet to display those pieces on the board. We do that in the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Adding pieces on the board
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have a code that converts the FEN notation to its expanded coordinate-based
    representation. Now, let''s code to actually display chess pieces on the board,
    based on a given FEN notation, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding pieces on the board](img/7941_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use PNG images for displaying pieces on the board. We have provided
    PNG images for each piece in a folder named `pieces_image`. The images have been
    named by appending the shortname of each piece followed by the color of the piece.
    For instance, black queen is saved as `qblack.png`, and white knight is saved
    as `nwhite.png`.
  prefs: []
  type: TYPE_NORMAL
- en: We have chosen PNG over GIF because unlike GIF, PNG allows for alpha channels
    (variable transparency), automatic gamma correction on different platforms, and
    color correction.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `TkinterPhotoImage` class does not support the PNG format. We,
    therefore, use the PIL to process PNG files.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, the `TkinterPhotoImage` class supports images in GIF, PPM, XBM, and
    PGM formats only. None of these formats are in vogue currently. Unfortunately,
    support for new formats can only be added if the Tcl/Tk starts supporting those
    formats.
  prefs: []
  type: TYPE_NORMAL
- en: Up till then, you may find it handy to use the PIL, which supports most of the
    popular image formats including PNG, JPEG, GIF, TIFF, and BMP.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to displaying images in Tkinter, the PIL module can also be used
    for image processing, such as size transformations, format conversions, thumbnail
    creation, and several other image manipulation requirements.
  prefs: []
  type: TYPE_NORMAL
- en: We will add code for displaying chess pieces in our view file, `gui.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – importing PIL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because we will use the PIL module to display PNG images for our pieces, we
    start by importing `ImageTk` from the PIL module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Step 2 – defining method to draw pieces on chessboard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code for adding pieces on the board is as follows (see *code 4.03: gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by importing `ImageTk` from the PIL module. We need this to handle
    PNG images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define our `draw_pieces()` method, whose role is to draw the pieces on a
    board for a given FEN notation. Because the FEN notation is available to all class
    methods, we need not pass it as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recall that we have created an instance of the chessboard which produces a dictionary
    comprising of the coordinate-based location of a piece and the corresponding piece
    instance as the key-value pair.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We loop through the dictionary using `iteritems()`, and break down the x and
    y coordinate string into corresponding x-and-y-based number notation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there exists a piece for a given coordinate, we add it to the Canvas widget
    using `canvas.create_image()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of the most important things to note here is that we have added two tags
    to each of the pieces: the name of the piece and a static string name `occupied`.
    Tags are the most important tool that you can use to operate on objects within
    the Canvas widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two lines create the x, y coordinate for a given board size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final line of the method uses `self.canvas.coords` to place the piece at
    the calculated coordinate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we need to call our newly defined method. We do that from our `show()`
    method to invoke the pieces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's wrap this iteration by analyzing the two canvas-related methods used here.
  prefs: []
  type: TYPE_NORMAL
- en: '**canvas.create_image(x, y, *options)**: The `create_image` method takes two
    arguments that specify x and y coordinates for positioning the image. After the
    coordinates, you may specify any number of option-value pairs. In our example,
    we have used the `anchor="c"` option to keep the image in the center.'
  prefs: []
  type: TYPE_NORMAL
- en: '**canvas.coords(tag/id, x0, y0, x1, y1, ..., xn, yn)**: The `coords()` method
    decides or modifies the coordinates for items attached to a given tag or ID. If
    coordinates are not specified, it returns a tuple specifying the coordinates of
    the item referenced by given tag or ID. If coordinates are specified, then they
    replace the current coordinates for the named item. If the tag or ID is attached
    to multiple items, only the first item is used.'
  prefs: []
  type: TYPE_NORMAL
- en: We will learn about the Canvas widget in greater detail as we progress. However,
    you may find it useful to look at the interactive help for the Canvas widget,
    or a list of available methods and configurable options.
  prefs: []
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our code can now take a FEN notation and display the images for corresponding
    pieces on the chessboard. If you modify the FEN notation, the pieces on the chessboard
    will change their places accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In the process, we got acquainted with the basic features of the Canvas widget.
    We also saw two canvas-related methods to create image and to change the coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how to overcome a Tkinter limitation on image handling by using
    the PIL module to handle formats not supported by Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing rules for pieces' movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get these chess pieces to move on click of mouse, we need to know
    how many squares a given piece can move. We need to enforce rules for each of
    the chess pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start coding the rules, let''s quickly recap the rules of chess:'
  prefs: []
  type: TYPE_NORMAL
- en: 'King can move only one square in any direction: up, down, to the sides, and
    diagonally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Queen can move in any one straight direction: forward, backward, sideways,
    or diagonally; as far as possible as long as she does not move through any of
    her own pieces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rook can move as far as it wants, but only forward, backward, and to the sides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bishop can move as far as it wants, but only diagonally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knights are different from others. They must move two squares in one direction,
    and then one more move at a 90 degree angle, following the shape of *L*. Knights
    are also the only pieces that can jump over other pieces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pawns move forward, but capture diagonally. Pawns can only move forward one
    square at a time, except for their very first move where they can move forward
    two squares. Pawns can only capture one square diagonally in front of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The bottom line here is that we need to track three common things for each
    of the piece:'
  prefs: []
  type: TYPE_NORMAL
- en: Its current position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowed directions for movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distance that a piece can move
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – tracking moves available for all pieces from Pieces superclass
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because the preceding things can be tracked at a central place, let''s define
    a method named `moves_available` in our superclass, `Pieces` (see *code 4.04:
    pieces.py*), for tracking moves available for all pieces as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The method accepts four arguments: the current position of a piece, two Boolean
    values representing whether or not diagonal and orthogonal movements are allowed
    for a piece, and the number of squares a piece can move at one time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending upon these arguments, the method collects all allowed moves for a
    given piece in a list, `allowed_moves`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having collected all directions of movements, the code iterates through all
    locations to detect any possible collision. If collision is detected, it breaks
    out of the loop, else it appends the coordinate to `allowed_moveslist`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collision = True` is our way to break out of the loop. We need to break out
    of the loop in two cases: when the destination is occupied, and when it is not
    occupied, and we have already appended that position into our list of possible
    moves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second last line filters out those moves that fall out of the board, and
    the last line returns the equivalent board notations for all allowed moves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having defined our `moves_available` method, we now simply need to call it
    from different pieces class.(see *code 4.04: pieces.py*).'
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – rules for the king, queen, rook and bishop class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: King, queen, rook, and bishop pieces on the chessboard have relatively simple
    rules governing them. These pieces can capture only in the direction in which
    they move.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, they move in either orthogonal, diagonal, or a combination of these
    two directions. We have already coded `moves_available` in our superclass to handle
    these directions.
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, deciding their available moves is just a matter of passing the
    right arguments to our `moves_available` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Step 3 – rules for knight
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Knight is a different beast because it does not move orthogonally or diagonally.
    It can also jump over pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Let's, therefore override the `moves_available` method from our `Knight` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Knight` class is defined as follows (see *code 4.04: pieces.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The method is quite similar to our previous super class method. However, unlike
    the super class method, the changes are represented to capture moves two squares
    in one direction, and then one more move at a 90 degree angle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, unlike the super class, we do not need to track collisions, because
    knights can jump over other pieces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 4 – rules for pawn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pawn too has a unique movement, in that it moves forward, but captures diagonally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s similarly override the `moves_available` class from within the `Pawn`
    class as follows (see *code 4.04: pieces.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We first assign variables `startpos`, `direction`, and `enemy` depending on
    whether the pawn is black or white.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to our previous `moves_allowed` methods, this method also collects all
    allowed moves in a blank list, `allowed_moves`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then collect a list of all prohibited moves by concatenating two lists of
    squares occupied by all black and white pieces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define a list, `forward`, which holds the position of the one square immediately
    ahead of the current position of pawn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pawn cannot move forward if there is a piece in front of it. If the forward
    position is not prohibited, the position is appended to our `allowed_moves` list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pawn can move two places forward from its starting position. We check to see
    if the current position is the starting position, and if true, we append the double
    move to our `allowed_moves` list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pawn can capture only diagonally adjacent pieces in front of it. We, therefore,
    assign a variable attack to track the diagonally adjacent positions on the board.
    If the diagonally adjacent square is occupied by an enemy, that position qualifies
    to be appended to our list, `allowed_moves`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then filter our list to remove all positions which may fall off the board.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last line returns all allowed moves as a list of corresponding letter notations,
    as we had done in all our previous definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this iteration, we coded the logic for enforcing rules related to movement
    of chess pieces on the board.
  prefs: []
  type: TYPE_NORMAL
- en: The chessboard logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we allow chess pieces to move on click of the mouse button, we must have
    a record of all possible movement options on the board. At every move, we also
    need to check that it is a legitimate turn for a given player, and that the proposed
    move should not cause a check on the king.
  prefs: []
  type: TYPE_NORMAL
- en: Now a check may occur on the king, not only from a piece that was moved, but
    from any other piece on the board as a consequence of such movement. Thus, after
    every move, we need to calculate the possible moves for all the pieces of the
    opponent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly we will need two methods to:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep track of all available moves for a player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify if there is a check on the king
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add the code for the preceding methods into our `Board` class. (See
    *code 4.05: chessboard.py*)'
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Step 1: Tracking all Available Moves'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code for keeping track of all available moves for a player is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We have already coded our `moves_available` method in the previous iteration.
    This method simply iterates through every item in the dictionary and appends the
    `moves_available` result for each piece of a given color in a list named `result`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step 2: Getting Current Position of King'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we code the method to verify if a king is in check, we first need to
    know the exact position of the king. Let''s define a method to get the current
    position of the king, as follows (see *code 4.05: chessboard.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code simply iterates through all items in the dictionary. If a
    given position is an instance of the `King` class, it simply returns its position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Verifying if King is under Check'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we define a method to verify if the king is under check from the opponent
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We first obtain the current position of the king, and the color of the opponent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then iterate through all possible moves for all pieces of the opponent. If
    the position of the king coincides with any position from all possible moves,
    the king is under check, and we return `True`, else we return `False`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This completes our objectives for the iteration. We are now in a position to
    check for all available moves for a player at a given point in the game. We can
    also verify if a king is under check from the opponent team.
  prefs: []
  type: TYPE_NORMAL
- en: Making the chess functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have all pieces and board-related validation rules in place, let's
    now add life to our chess. In this iteration, we will make our chess game fully
    functional.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a game between two players, our chessboard would be like one shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making the chess functional](img/7941_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The objective for this iteration is to move pieces on click of the left mouse
    button. When a player clicks on a piece, our code should first check if it is
    a legitimate turn for that piece.
  prefs: []
  type: TYPE_NORMAL
- en: On the first click, the piece to be moved is selected, and all allowed moves
    for that piece are highlighted on the board. The second click should happen on
    the destination square. If the second click is done on a valid destination square,
    the piece should move from the source square to the destination square.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to code the events of capturing of pieces and check on king. Other
    attributes to be tracked include list of captured pieces, halfmove clock count,
    fullmove number count, and history of all previous moves.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – updating the board for change in FEN notation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have the ability to take the original FEN notation and display it
    on board. However, we need a way that takes any FEN notation and updates the display
    on the board. We define a new method named `show()` to do this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Step 2 – binding mouse click event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The pieces need to move on click of the mouse. So, we need to track the mouse
    click event. We only need to track mouse clicks on the Canvas widget. Let us,
    therefore, add an event handler to our `GUI` class immediately after the code
    that created the Canvas widget in the `init` method as follows (see *code 4.06:
    gui.py, __init__ method*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will bind the left mouse click event to a new method, `square_clicked`.
    However, before we sit down and define this method, let's pause and think about
    the attributes we need to keep tracking our program.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – adding attribute to track selected piece and remaining pieces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First of all, we need to track all pieces remaining on the board after every
    move. So we will create a dictionary pieces to keep track of this. We also need
    to track the name of the piece selected by the mouse click. We store that in an
    attribute, `selected_piece`. When a player clicks on a piece, we need to highlight
    all valid moves for that piece. We store all valid moves for that piece in a list
    named `focused`. Let''s define these three attributes in our `GUI` class before
    defining any of the methods. We modify our `GUI` class to include these attributes
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Step 4 – identifying square clicked
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will code our `square_clicked` method that gets called from the event handler
    we defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The desired functionality of this method is twofold. We should be able to locate
    the coordinate of a piece being clicked. The first click should select a given
    piece. The second click should move the piece from the source square to the destination
    square.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method is defined as follows(see *code 4.06: gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first part of code calculates the coordinates for the piece clicked. Based
    on the calculated coordinates, it stores the corresponding letter notation in
    a variable named `pos`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then tries to assign the variable piece to the corresponding piece instance.
    If there is no piece instance on the clicked square, it simply ignores the click.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second part of the method checks if this is the second click intended to
    move a piece to a destination square. If this is the second click, it calls the
    `shift` method, passing in the source and destination coordinates as its two arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If shift succeeds, it sets back all previously set attributes to their original
    empty values and calls our `draw_board` and `draw_pieces` method to redraw the
    board and pieces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this is the first click, it calls a method named `focus` to highlight all
    available moves for the first click, followed by a call to draw the fresh board.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While coding the desired functionality for the `square_clicked` method, we called
    several new methods from within it. We need to define those new methods.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 – getting the source and destination position
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have called the `shift` method from the `square_clicked` method. The following
    shift code implemented is simply responsible for collecting the necessary arguments
    required for the shift operation.
  prefs: []
  type: TYPE_NORMAL
- en: In the spirit of keeping logic separate from presentation, we do not process
    shift-related rules in this view class. Instead, we delegate the `shift` method
    work from the `GUI` to `Board` class. Once the logic or validation for shift has
    been implemented, the visible part of the shift of pieces again takes place in
    the `draw_board` method of our `GUI` class.
  prefs: []
  type: TYPE_NORMAL
- en: Although this may seem like overkill at first, structuring logic and presentation
    in different layers is very important for code reuse, scalability, and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The code first checks if there exists a piece on the destination. If a piece
    does not exist at the destination square, it calls on a method, `shift`, from
    `chessboard.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 – collecting list of moves to highlight
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have also called the focus method from `square_clicked` method. The purpose
    of this method is to collect all possible moves for a given piece in a list named
    `focused`. The actual focusing of available moves takes place in the `draw_board`
    method of our GUI class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows (see code 4.06: gui.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Step 7 – modifying draw_board to highlight allowed moves
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `square_clicked` method, we called the `draw_board` method to take care
    of redrawing or changing the coordinates for our pieces. Our current `draw_board`
    method is not equipped to handle this, because we had designed it in the first
    iteration only to provide us with a blank board. Let''s first modify our `draw_board`
    method to handle this, as follows (see *code 4.06: gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The additions made to our existing `draw_board` method are highlighted in the
    preceding code. We first define an attribute named `highlightcolor`, and assign
    it a color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In essence, the code has been modified to handle the clicks. The first section
    of highlighted code fills a different color to highlight all available moves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second section of highlighted code changes the coordinates of the piece
    instance to be located on new coordinates. Note the use of `canvas.coords(name,
    x0, y0)` to change the coordinates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two lines change the precedence of options specified by tags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If an object on the canvas is tagged to multiple tags, options defined for tags
    at the top of the stack have higher precedence. You can, however, change the precedence
    of tags by using `tag_raise(name)` or `tag_lower(name)`.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete list of canvas-related options, refer to interactive help for
    the Canvas widget using `help(Tkinter.Canvas)` in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Step 8 – defining attributes to keep game statistics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a consequence of adding mobility to our pieces, we need to add the following
    new attributes to our `Board` class to keep game statistics, as follows (see *code
    4.06: chessboard.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Step 9 – preshift validations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For that, we will code the `shift` method of our `Board` class, as follows
    (see *code 4.06: chessboard.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The code first checks if there exists a piece on the destination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then checks if it is a valid turn for the player. If not, it raises an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then checks if the move is proposed to occur to a valid location. If a player
    attempts to move a piece to an invalid location, it raises a corresponding exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It then checks if there is a check on the king. To do that, it calls a method
    named `is_in_check_after_move`, which is defined as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method creates a deep temporary copy of the object and tries to move the
    piece on the temporary copy. As a note, shallow copy of a collection is a copy
    of the collection structure, not the elements. When you do a shallow copy, the
    two collections now share the individual elements, so a modification at one place
    affects the other as well. In contrast, deep copies makes copy of everything,
    the structure as well as the elements. We need to create a deep copy of the board,
    because we want to check if the king makes a valid move before it actually moves
    and we want to do that without modifying the original object state in any way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After executing the move on the temporary copy, it checks if the king is in
    check to return `True` or `False`. If the king is in check on the temporary board,
    it raises an exception, not allowing such a move on our actual board.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, it checks for possible occurrence of checkmate or draw and raises
    exceptions accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no exceptions are made, it finally calls a method named `move`, which actually
    executes the move.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 10 – actual movement of pieces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Actual movement of pieces can be coded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Step 11 – Post movement updates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After the move has actually been executed, it calls another method named `complete_move`,
    which updates game statistics as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method does the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeps track of statistics, such as number of moves, halfmove clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes the player's turn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks if a pawn has been moved so as to reset the halfmove clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally, appends the last move to our history list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 12 – classes to handle exceptions and errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we add the following empty classes for various exceptions raised by
    us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's summarize things that we did in this iteration
  prefs: []
  type: TYPE_NORMAL
- en: We started by binding a mouse click event to a method named `square_clicked`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added attributes to track selected piece and remaining pieces on the board.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then identified the square clicked, followed by collecting the source and
    destination position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also collected a list of all possible moves for the selected piece, and then
    highlighted them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then defined attributes to keep vital game statistics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then did some preshift validations, followed by actual movement of pieces
    on the board.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After a piece had been moved, we updated statistics about the game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We had defined several exceptions in this iteration. We simply defined empty
    classes to handle them silently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our chess game is now functional. Two players can now play a game of chess on
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding menu and an info frame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though our game is fully functional, let's add two small features to it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a top menu item by navigating to **File** | **New Game**. When clicked,
    it should reset the board to a new game.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, let's add a small frame at the bottom to display game-related
    information, such as the last move, next turn, check, draw, and checkmate.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding menu and an info frame](img/7941_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Step 1 – creating top menu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our Canvas widget was set up in the the `__init__` method of our `GUI` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify it to include the top menu, as follows (see *code 4.06: gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Step 2 – adding the bottom frame to display game statistics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s also add a bottom frame to display game statistics to the same `__init__`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The modification to existing init method is highlighted. The code is self-explanatory.
    We have done similar things in all our previous projects.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – starting a new game from File | New game menu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **File** | **New game** menu item calls on our method, `new_game()`. The
    code for `new_game()` is as follows (see *code 4.06: gui.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Step 4 – updating bottom label after every move
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, after every move, we want to update the label with details of the
    move and information about the next players turn. We also want to update the frame
    to display any error or exception that may have occurred during the move attempt.
    We accordingly modify the `shift` method of our `GUI` class to do this update
    for us as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The modifications to our `shift` method are highlighted. We have simply included
    the `shift` method of our `Board` class in a try except block. If the shift is
    successful, the Label widget is updated to show the current move and the next
    players turn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the shift is not successful, either because of invalid move or a check on
    the king, the corresponding error class name is displayed in the label with `error.__class__.__name__`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This completes our goal for the iteration. The application now displays some
    useful information to the players during the course of a chess game.
  prefs: []
  type: TYPE_NORMAL
- en: We also added a **File** | **New menu** item, which can be used to reset the
    board to starting position.
  prefs: []
  type: TYPE_NORMAL
- en: Mission Accomplished
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now come to the end of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what is it that we have achieved here? Let''s list all the key learning
    from this project:'
  prefs: []
  type: TYPE_NORMAL
- en: How to structure a program into its model and view components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to represent a problem domain in a desired notation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peek into the versatility and power of the Tkinter Canvas widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic usage of Canvas coordinates, object IDs and tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with newer image formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical interaction of logic and presentation layers in a GUI program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next project onwards, we take a look at different Tkinter widgets in greater
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: A Hotshot Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the two hotshot challenges for you:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add and implement the following menu items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**File** | **Save**: Save a game state'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File** | **Open**: Loads a previously saved game'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edit**| **Undo**: To let the players undo the turns played'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edit** |**Redo**: To let the players redo any previous undo'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View** | **Moves History**: Opens a new Toplevel window to display the history
    of the game'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**About**| **About**: Displays information about the game'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement castling and En passant features in the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
