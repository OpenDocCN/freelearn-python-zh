<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer077" class="_idGenObjectStyleOverride-1">&#13;
			<h1 id="_idParaDest-168" class="chapter-number" lang="en-GB"><a id="_idTextAnchor184"/>10</h1>&#13;
			<h1 id="_idParaDest-169" lang="en-GB"><a id="_idTextAnchor185"/>A Closer Look at the ARM</h1>&#13;
			<p lang="en-GB">We have already introduced the ARM processor. Now, we will look at it in a little more depth. The ARM family of processors is probably the best vehicle to teach computer architecture. In particular, it is very easy to learn because of its streamlined instruction set and simple register model compared to many other microprocessors.Moreover, the ARM has some very interesting features, such as predicated execution when an instruction can either be executed or ignored, depending on the processor status. The introduction of the Raspberry Pi in computer education could not have happened at a better time because it enables students to get hands-on experience of the remarkable <span class="No-Break">ARM architecture.</span></p>&#13;
			<p lang="en-GB">In this chapter, we will do <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">Introduce <span class="No-Break">the ARM</span></li>&#13;
				<li lang="en-GB">Describe its <span class="No-Break">register set</span></li>&#13;
				<li lang="en-GB">Examine variations in add and <span class="No-Break">subtract operations</span></li>&#13;
				<li lang="en-GB">Cover the ARM’s <span class="No-Break">multiplication instruction</span></li>&#13;
				<li lang="en-GB">Introduce logical operations and <span class="No-Break">shifting operations</span></li>&#13;
				<li lang="en-GB">Explain flow control and the ARM’s <span class="No-Break">conditional execution</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-170" lang="en-GB"><a id="_idTextAnchor186"/>Technical requirements</h1>&#13;
			<p lang="en-GB">Because this chapter is an extension of the previous chapter, no new hardware or software is required. All you need is Raspberry Pi, configured as a general-purpose computer. The only software needed is a text editor to create assembly language programs and the GCC assembler <span class="No-Break">and loader.</span></p>&#13;
			<h1 id="_idParaDest-171" lang="en-GB"><a id="_idTextAnchor187"/>Introducing the ARM</h1>&#13;
			<p lang="en-GB">The ARM processor family has been <a id="_idIndexMarker641"/>a remarkable success story, not least because so many other microprocessors became popular for a few years and then declined into obscurity (e.g., 6502, Cyrix 486, and Itanium). At the time of its release, the Motorola 68K was widely thought of as far more elegant and powerful than Intel’s 8086. Indeed, the 68K was a true 32-bit machine at a time when the 8086 was a 16-bit machine. The 68K was adopted by Apple’s Mac, the Atari, and Amiga computers – all major players in the home computer market. How could Intel’s humble 8086 possibly ever have competed? Well, IBM selected the 8086 family for its new personal computer and the rest is history. Motorola later dropped out of the <span class="No-Break">semiconductor business.</span></p>&#13;
			<p lang="en-GB">In the late 1980s, a new company, Advanced RISC Machines, was founded to create high-performance microprocessors. The architecture of their machines followed the register-to-register paradigm of the RISC architecture, rather than Intel and Motorola’s more complicated CISC instruction sets. The ARM <span class="No-Break">was born.</span></p>&#13;
			<p lang="en-GB">Not only has ARM survived when many of the earlier microprocessors failed – it has also prospered and successfully targeted the world of mobile devices, such as netbooks, tablets, and cell phones. ARM incorporates some interesting architectural features that have given it a competitive advantage over <span class="No-Break">its rivals.</span></p>&#13;
			<p lang="en-GB">ARM is, in fact, a <em class="italic">fabless</em> company – that is, it develops the architecture of computers and allows other companies to manufacture those computers. The term <em class="italic">fabless</em> is derived from fab (short <span class="No-Break">for fabrication).</span></p>&#13;
			<p lang="en-GB">Before we describe ARM’s instructions, we will discuss its register set because all ARM data-processing instructions operate on the contents of its registers (a prime feature of the <span class="No-Break">RISC computer).</span></p>&#13;
			<p lang="en-GB">Because the ARM’s architecture has developed <a id="_idIndexMarker642"/>over the years, and because there are different versions of the ARM architecture in use, a teacher of it has a problem. Which version should be used to illustrate a computer architecture course? In this chapter, we will use the ARMv4 32-bit architecture, which has 32-bit instructions. Some ARM processors can switch between 32-bit and 16-bit instruction states (the 16-bit state is called the <em class="italic">Thumb</em> state). The Thumb state is intended to run very compact code in embedded control systems. We will not cover the Thumb <span class="No-Break">state here.</span></p>&#13;
			<p lang="en-GB">The ARM found in Raspberry Pi 4 has a 64-bit architecture that is very different from earlier 32-bit ARMs. However, since the 32-bit ARM architecture is used in most teaching texts and Raspberry Pi 4 supports it, we will use the 32-bit architecture here. In order to be consistent with other books using the ARM to illustrate computer architecture, most of the material here is based on ARMv4T 32-bit architecture. ARM’s 32-bit architectures are now referred to by the term AArch32, distinguishing them from ARM’s new 64-bit <span class="No-Break">architecture, AArch64.</span></p>&#13;
			<h1 id="_idParaDest-172" lang="en-GB"><a id="_idTextAnchor188"/>Overview of the ARM’s architecture</h1>&#13;
			<p lang="en-GB">The ARM’s architecture is interesting <a id="_idIndexMarker643"/>because it has elements of both the conventional CISC architecture such as Motorola’s 68K and Intel’s 32/64-bit architectures, together with the more radical streamlined RISC architecture of processors such as MIPS <span class="No-Break">and RISC-V.</span></p>&#13;
			<p lang="en-GB">Here, we will examine <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">The ARM’s <span class="No-Break">register set</span></li>&#13;
				<li lang="en-GB"><span class="No-Break">Arithmetic instructions</span></li>&#13;
				<li lang="en-GB">Special addition and <span class="No-Break">subtraction instructions</span></li>&#13;
				<li lang="en-GB">Multiplication and ARM’s multiplication and <span class="No-Break">addition instruction</span></li>&#13;
				<li lang="en-GB"><span class="No-Break">Bitwise instruction</span></li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB"><span class="No-Break">Shifting operations</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">We don’t cover data movement operations in detail here. We have already encountered the <strong class="source-inline">mov</strong> operation that can be used to load a literal into a register – for example, <strong class="source-inline">mov r1,#12</strong>. Similarly, the <strong class="source-inline">str</strong> and <strong class="source-inline">ldr</strong> instructions load a register from memory and store a register in memory, respectively. A typical example is <strong class="source-inline">ldr r4,[r5]</strong> and <strong class="source-inline">str r0,[r9]</strong>. These two instructions use <em class="italic">register indirect addressing</em>, and we will devote the next chapter <span class="No-Break">to them.</span></p>&#13;
			<h2 id="_idParaDest-173" lang="en-GB"><a id="_idTextAnchor189"/>Arm register set</h2>&#13;
			<p lang="en-GB">Unlike the popular MIPS processor with its 32 general-purpose registers, ARM has just 16 registers, <strong class="source-inline">r0</strong> to <strong class="source-inline">r15</strong>, and a <em class="italic">status register</em>. Remarkably, the ARM’s registers are <a id="_idIndexMarker644"/>not all the same – that is, some are special-purpose registers. <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.1</em> illustrates the ARM’s <span class="No-Break">register set.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer070" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_10.01_B19624.jpg" alt="Figure 10.1 – The ARM’s register set" width="1788" height="868"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – The ARM’s register set</p>&#13;
			<p lang="en-GB">Fourteen registers, <strong class="source-inline">r0</strong> to <strong class="source-inline">r13</strong>, are indeed general-purpose in the sense that they all behave in the same way – for example, anything you can do with <strong class="source-inline">r5</strong>, you can do with <strong class="source-inline">r10</strong>. Registers <strong class="source-inline">r13</strong>, <strong class="source-inline">r14</strong>, and <strong class="source-inline">r15</strong> are not general-purpose because they have <span class="No-Break">additional functions.</span></p>&#13;
			<p lang="en-GB">Strictly speaking, <strong class="source-inline">r13</strong> is a general-purpose register, but by convention, it’s reserved for use as a stack pointer. If you work on a project in a team, you should respect this convention. Otherwise, you do not have to follow the convention, and you can use <strong class="source-inline">r13</strong> in any way <span class="No-Break">you wish.</span></p>&#13;
			<p lang="en-GB">Register <strong class="source-inline">r14</strong> has an additional function imposed by the hardware. It is a <em class="italic">link register</em> and can be written <strong class="source-inline">lr</strong> or <strong class="source-inline">r14</strong> in assembly programs. The ARM has an instruction, branch with link (<strong class="source-inline">bl)</strong>, that lets you jump to a point in the program (i.e., a branch) and save the address of the next instruction in sequence in the link register. In other words, the instruction saves the next <strong class="source-inline">pc</strong> address in <strong class="source-inline">r14</strong> and then jumps to the specified target. Later, you can return by copying the address in the link register to the pc with <strong class="source-inline">mov pc,lr</strong> or <strong class="source-inline">mov 15,r14</strong>. This is a faster subroutine call and return mechanism than the conventional <strong class="source-inline">bsr</strong> and <strong class="source-inline">rts</strong> pair of instructions that use a stack to store the <span class="No-Break">return address.</span></p>&#13;
			<p lang="en-GB"><span class="CharOverride-1" lang="en-US" xml:lang="en-US">Register </span><strong class="source-inline CharOverride-2" lang="en-US" xml:lang="en-US">r15</strong><span class="CharOverride-1" lang="en-US" xml:lang="en-US"> is a truly different register from all the others and can never be used as a general-purpose register (even though you can apply some instructions to it as if it were general-purpose). Register </span><strong class="source-inline CharOverride-2" lang="en-US" xml:lang="en-US">r15</strong><span class="CharOverride-1" lang="en-US" xml:lang="en-US"> is the </span><em class="italic CharOverride-1" lang="en-US" xml:lang="en-US">program counter</em><span class="CharOverride-1" lang="en-US" xml:lang="en-US"> that contains the address of the next instruction to be executed and is normally written </span><strong class="source-inline CharOverride-2" lang="en-US" xml:lang="en-US">pc</strong><span class="CharOverride-1" lang="en-US" xml:lang="en-US"> rather than </span><strong class="source-inline CharOverride-2" lang="en-US" xml:lang="en-US">r15</strong><span class="CharOverride-1" lang="en-US" xml:lang="en-US"> in ARM code. Putting the program </span><span class="CharOverride-1" lang="en-US" xml:lang="en-US"><a id="_idIndexMarker645"/></span><span class="CharOverride-1" lang="en-US" xml:lang="en-US">counter in a general register is very rare in the world of computer architecture. Note that, in practice, </span><strong class="source-inline CharOverride-2" lang="en-US" xml:lang="en-US">pc</strong><span class="CharOverride-1" lang="en-US" xml:lang="en-US"> contains an address that is 8 bytes ahead of the current </span><strong class="source-inline CharOverride-2" lang="en-US" xml:lang="en-US">pc</strong><span class="CharOverride-1" lang="en-US" xml:lang="en-US"> because of the way that the ARM is </span><span class="No-Break CharOverride-1" lang="en-US" xml:lang="en-US">internally organized.</span></p>&#13;
			<p lang="en-GB">We will look at the ARM’s data processing instructions first, rather than the data movement operations. We take this approach because data movement instructions are more complicated, since they involve complex <span class="No-Break">addressing modes.</span></p>&#13;
			<h2 id="_idParaDest-174" lang="en-GB"><a id="_idTextAnchor190"/>Arithmetic instructions</h2>&#13;
			<p lang="en-GB">Let’s begin with ARM’s arithmetic instructions <a id="_idIndexMarker646"/>that perform operations on <span class="CharOverride-1" lang="en-US" xml:lang="en-US"><a id="_idIndexMarker647"/></span>data representing <span class="No-Break"><em class="italic">numeric quantities</em></span><span class="No-Break">:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">Addition<span class="CharOverride-3">          </span><span class="No-Break"><strong class="source-inline">add</strong></span></li>&#13;
				<li lang="en-GB">Subtraction<span class="CharOverride-3">        </span><span class="No-Break"><strong class="source-inline">sub</strong></span></li>&#13;
				<li lang="en-GB">Comparison <span class="CharOverride-3">       </span><strong class="source-inline">cmp</strong> (technically, <strong class="source-inline">compare</strong> is not a <span class="No-Break">data-processing operation)</span></li>&#13;
				<li lang="en-GB">Multiplication <span class="CharOverride-3">     </span><span class="sc-comment CharOverride-4">  </span><span class="No-Break"><strong class="source-inline">mul</strong></span></li>&#13;
				<li lang="en-GB">Shifting<span class="CharOverride-3">          </span><span class="sc-comment CharOverride-4">  </span><strong class="source-inline">lsl, lsr, asl, asr, </strong><span class="No-Break"><strong class="source-inline">ror, rrx</strong></span></li>&#13;
			</ul>&#13;
			<h3 lang="en-GB">Addition, subtraction, and comparison</h3>&#13;
			<p lang="en-GB">Addition is a simple operation that adds two operands to generate a sum and a carryout. In decimal arithmetic, adding 4 + 5 gives 9. Adding 4 + 9 gives 13 ; that is, a result of 3 and a carry-out of 1. Computers deal with this by storing the carryout in the carry bit. ARM instructions <a id="_idIndexMarker648"/>require you to add the suffix <strong class="source-inline">s</strong> if you wish to update condition code flags after an operation – that is, you need to write <span class="No-Break"><strong class="source-inline">add</strong></span><span class="No-Break"><span class="pcode-bold">s</span></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">r1,r2,r3</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The ARM is a 32-bit machine. How do you add 64-bit numbers? Suppose that two 64-bit numbers are <strong class="source-inline">A</strong> and <strong class="source-inline">B</strong>, where A<span class="subscript">L</span> is the lower-order 32 bits of A, and A<span class="subscript">U</span> is the upper-32 bits of <strong class="source-inline">A</strong>. Similarly, B<span class="subscript">L</span> is the lower-order 32 bits of <strong class="source-inline">B</strong>, and B<span class="subscript">U</span> is the upper-32 bits <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">B</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">We first add A<span class="subscript">L</span> to B<span class="subscript">L</span> and record the carry. Then we <span class="CharOverride-1" lang="en-US" xml:lang="en-US"><a id="_idIndexMarker649"/></span>add together A<span class="subscript">U</span> and B<span class="subscript">U</span>, plus any carry generated from the addition of the lower-order pair. In ARM assembler language, this is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>add<strong class="bold">s</strong> C<span class="subscript">L</span>,A<span class="subscript">L</span>,B<span class="subscript">L</span>         <span class="sc-comment">@ CL,AL,BL are registers, each holding the 32 lower-order bits of a word</span></span>&#13;
<span>adc  C<span class="subscript">U</span>,A<span class="subscript">U</span>,B<span class="subscript">U</span>         <span class="sc-comment">@ Add the two upper-order 32-bit registers together with the carry bit</span></span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The second addition, <strong class="source-inline">adc</strong>, means, <em class="italic">add with carry</em>, and adds any carry <a id="_idIndexMarker650"/>out from the previous addition. We’ve used C<span class="subscript">L</span>, A<span class="subscript">L</span>, B<span class="subscript">L</span>, and so on, rather than <strong class="source-inline">r1</strong>, <strong class="source-inline">r2</strong>, and <strong class="source-inline">r3</strong> to demonstrate that these are upper- and lower-order parts of a number distributed between two registers. We can extend this principle to perform extended-precision arithmetic with integers of <span class="No-Break">any length.</span></p>&#13;
			<p lang="en-GB">The ARM also provides a simple subtract operation, <strong class="source-inline">sub</strong>, together with a <strong class="source-inline">sbc</strong> or <em class="italic">subtract with carry</em> instruction to support extended-precision subtraction, which operate like the <span class="No-Break">corresponding </span><span class="No-Break"><strong class="source-inline">adc</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">As well as <strong class="source-inline">sub</strong> and <strong class="source-inline">sbc</strong>, the ARM has a <em class="italic">reverse</em> subtract operation, where <strong class="source-inline">rsc </strong><span class="pcode-bold">r1</span>, <strong class="source-inline">r2</strong>, <strong class="source-inline">r3</strong> perform the subtraction of <strong class="source-inline">r2</strong> from <strong class="source-inline">r3</strong>. This instruction may seem strange and unnecessary because you can simply reverse the order of the second two registers, can’t you? However, ARM lacks a <em class="italic">negation</em> instruction that subtracts a number from zero ; for example, the negative of <strong class="source-inline">r0</strong> is <strong class="source-inline">0 – [r0]</strong>. The reverse subtraction operation can be used to do this because <strong class="source-inline">rsb </strong><span class="pcode-bold">r1</span><strong class="source-inline">,r1,#0</strong> is equivalent to <span class="No-Break"><strong class="source-inline">neg r1</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">A comparison operation compares two values <a id="_idIndexMarker651"/>by subtracting one from the other – for example, we can compare 3 with 5. Suppose the two elements being compared are <strong class="source-inline">A</strong> and <strong class="source-inline">B</strong>. If you perform <strong class="source-inline">A</strong> – <strong class="source-inline">B</strong> and the answer is zero, then <strong class="source-inline">A</strong> and <strong class="source-inline">B</strong> are equal. If the result is positive, <strong class="source-inline">A &gt; B</strong>, and if it’s negative, <strong class="source-inline">A &lt; B</strong>. A comparison is a subtraction where you don’t care about the result ; only its sign, whether it’s zero, whether a carry was generated. Consider <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>mov <strong class="bold">r1</strong>,#6                <span class="sc-comment">@ Load r1 with 6</span></span>&#13;
<span>mov <strong class="bold">r2</strong>,#8                <span class="sc-comment">@ Load r2 with 8</span></span>&#13;
<span>cmp <strong class="bold">r1</strong>,r2                <span class="sc-comment">@ Compare r1 and r2</span></span></pre>&#13;
			<p lang="en-GB">The operation <strong class="source-inline">cmp</strong> <span class="pcode-bold">r1</span>,<strong class="source-inline">r2</strong> evaluates <strong class="source-inline">[r1] – [r2]</strong> and updates the <strong class="source-inline">Z</strong>, <strong class="source-inline">C</strong>, <strong class="source-inline">N</strong>, and <strong class="source-inline">V</strong> bits. We can then perform operations such as <strong class="source-inline">beq next</strong> that branch to label <strong class="source-inline">next</strong> if <strong class="source-inline">r1</strong> and <strong class="source-inline">r2</strong> are equal. We said that you need to append <strong class="source-inline">s</strong> to update condition codes. Comparison <a id="_idIndexMarker652"/>operations are exceptions because setting condition codes is what they do. You can write <strong class="source-inline">cmps</strong> if you want, since it’s the same <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">cmp</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">There are two types of integer comparison. Consider (in 8 bits) the <strong class="source-inline">A = 00000001</strong> and <strong class="source-inline">B = 11111111</strong> binary values. Which is the larger? You might think that it’s <strong class="source-inline">B</strong>, since <strong class="source-inline">B = 255</strong> and <strong class="source-inline">A = 1</strong>. That’s true. However, if these were assigned <strong class="source-inline">2</strong>s complement numbers, <strong class="source-inline">A</strong> would be <strong class="source-inline">1</strong> and <strong class="source-inline">B</strong> would be <strong class="source-inline">-1</strong>; therefore, <strong class="source-inline">A</strong> is the larger. Like all processors, ARM provides two <a id="_idIndexMarker653"/>sets of branch operations, one for unsigned arithmetic and one for signed arithmetic. A programmer must select the appropriate branch depending on whether they use signed or unsigned arithmetic. The simulators we constructed earlier all provided unsigned <span class="No-Break">branches only.</span></p>&#13;
			<h3 lang="en-GB">Multiplication</h3>&#13;
			<p lang="en-GB">ARM’s multiply instruction, <strong class="source-inline">mul </strong><span class="pcode-bold">Rd</span><strong class="source-inline">,Rm,Rs</strong>, generates the low-order 32 bits of the 64-bit product <strong class="source-inline">Rm</strong> <strong class="source-inline">x Rs</strong>. When using <strong class="source-inline">mul</strong>, you should ensure that the result <a id="_idIndexMarker654"/>does not go out of range because multiplying two m-bit numbers yields a <strong class="source-inline">2m</strong>-bit product. This instruction doesn’t let you multiply the contents of a register by a constant – that is, you can’t perform <strong class="source-inline">mul</strong> <span class="pcode-bold">r9</span><strong class="source-inline">,r4,#14</strong>. Moreover, you can’t use the <em class="italic">same</em> register to specify both the Rd destination and the <strong class="source-inline">Rm</strong> operand. These restrictions are due to the implementation of this instruction in hardware. The following code demonstrates the use of ARM’s multiplication to multiply 23 <span class="No-Break">by 25:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>       mov   <strong class="bold">r4</strong>,#23      <span class="sc-comment">@ Load register r4 with 23</span></span>&#13;
<span>       mov   <strong class="bold">r7</strong>,#25      <span class="sc-comment">@ Load register r7 with 25</span></span></pre>&#13;
			<pre class="source-code">       mul   <strong class="bold">r9</strong>,r4,r7    <span class="sc-comment">@ r9 is loaded with the low-order 32-bit product of r4 and r7</span></pre>&#13;
			<p lang="en-GB">We’ve already seen that ARM has a <em class="italic">multiply and accumulate instruction</em>, <strong class="source-inline">mla</strong>, with a <em class="italic">four-operand</em> format <strong class="source-inline">mla</strong> <span class="pcode-bold">Rd</span>,<strong class="source-inline">Rm</strong>,<strong class="source-inline">Rs</strong>,<strong class="source-inline">Rn</strong>, whose RTL definition is <strong class="source-inline">[Rd]</strong> <span class="CharOverride-5">←</span> <strong class="source-inline">[Rm]</strong> x <strong class="source-inline">[Rs] + [Rn]</strong>. The 32-bit by 32-bit multiplication is truncated to the lower-order 32 bits. Like the multiplication, <strong class="source-inline">Rd</strong> must not be the same as <strong class="source-inline">Rm</strong> (although this restriction was removed in the ARMv6 and <span class="No-Break">later architectures).</span></p>&#13;
			<p lang="en-GB">ARM’s <em class="italic">multiply and accumulate</em> instruction supports the calculation of an <em class="italic">inner-product</em> by performing one multiplication and addition per instruction. The inner-product is used in multimedia applications – for example, if vector <span class="pcode-bold">a</span> consists of the <em class="italic">n</em> components a<span class="subscript">1</span>, a<span class="subscript">2</span>, … a<span class="subscript">n</span> and vector <span class="pcode-bold">b</span> consists of the <em class="italic">n</em> components b<span class="subscript">1</span>, b<span class="subscript">2</span>, ... , b<span class="subscript">n</span>, then the <em class="italic">inner product</em> of <span class="pcode-bold">a</span> and <span class="pcode-bold">b</span> is the scalar value s = <strong class="bold">a·b</strong> = a<span class="subscript">1</span>·b<span class="subscript">1</span> + a<span class="subscript">2</span>·b<span class="subscript">2</span> + … + <span class="No-Break">a</span><span class="No-Break"><span class="subscript">n</span></span><span class="No-Break">·b</span><span class="No-Break"><span class="subscript">n</span></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">We will now demonstrate an application of the <a id="_idIndexMarker655"/>multiply and accumulate operations. Although we have not yet covered the ARM’s addressing modes, the following example includes the instruction <strong class="source-inline">ldr </strong><span class="pcode-bold">r0</span><strong class="source-inline">,[r5],#4</strong> that loads register <strong class="source-inline">r0</strong> with an element from the array pointed at by register <strong class="source-inline">r5</strong>, and then it updates <strong class="source-inline">r5</strong> to point at the next element (4 <span class="No-Break">bytes on):</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>       mov   <strong class="bold">r4</strong>,#n        <span class="sc-comment">@ r4 is the counter</span></span>&#13;
<span>       mov   <strong class="bold">r3</strong>,#0        <span class="sc-comment">@ Clear the inner product</span></span>&#13;
<span>       adr   <strong class="bold">r5</strong>,V1        <span class="sc-comment">@ r5 points to v1</span></span>&#13;
<span>       adr   <strong class="bold">r6</strong>,V2        <span class="sc-comment">@ r6 points to v2</span></span>&#13;
<span>Loop:  ldr   <strong class="bold">r0</strong>,[r5],#4   <span class="sc-comment">@ REPEAT read a component of v1 and update the pointer</span></span>&#13;
<span>       ldr   <strong class="bold">r1</strong>,[r6],#4   <span class="sc-comment">@ Get the second element in the pair from v2</span></span>&#13;
<span>       mla   <strong class="bold">r3</strong>,r0,r1,r3  <span class="sc-comment">@ Add new product term to the total (r3 = r3 + r0·r1)</span></span>&#13;
<span>       subs  <strong class="bold">r4</strong>,r4,#1     <span class="sc-comment">@ Decrement  the counter and set the (CCR)</span></span>&#13;
<span>       bne   Loop         <span class="sc-comment">@ UNTIL all done</span></span></pre>&#13;
			<p lang="en-GB">What about division? The ARMv4 architecture lacks a division instruction as part of its basic architecture (some variants of ARM such as the ARMv7 architecture do incorporate division). If you wish to do division on the ARM, you have to write a short program that uses an iterative loop involving shifting and subtracting to perform the division (rather like pencil and paper <span class="No-Break">long division).</span></p>&#13;
			<h3 lang="en-GB">Bitwise logical operations</h3>&#13;
			<p lang="en-GB">The ARM provides the basic <strong class="source-inline">AND</strong>, <strong class="source-inline">OR</strong>, <strong class="source-inline">NOT</strong>, and <strong class="source-inline">EOR</strong> (exclusive or) bitwise logical operations supported by most processors. These are used to set, clear, and toggle <a id="_idIndexMarker656"/>the individual bits of a word, as we already saw when assembling instructions. There is also an unusual <em class="italic">bit clear</em> operation, <strong class="source-inline">bic</strong>, that <strong class="source-inline">AND</strong>s its first operand with the <em class="italic">complement of the corresponding bits</em> of its second operand – that is, c<span class="subscript">i</span> = a<span class="subscript">i </span><span class="CharOverride-5">∧</span> <span class="No-Break">b</span><span class="No-Break"><span class="subscript">i</span></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The ARM’s NOT operation is written as <strong class="source-inline">mvn</strong> r<span class="subscript">d</span>,r<span class="subscript">s</span>. This move instruction negates, inverts the bits of the source register and copies them to the <span class="No-Break">destination register.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The following examples illustrate logical operations on r1 = 11001010<span class="subscript">2</span> and r0 = <span class="No-Break">00001111</span><span class="No-Break"><span class="subscript">2</span></span><span class="No-Break">:</span></p>&#13;
			<table id="table001-8" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><strong class="bold">Logical instruction</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><strong class="bold">Operation</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><strong class="bold">Final value </strong><span class="No-Break"><strong class="bold">in r2</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><strong class="source-inline">and </strong></span><span class="No-Break"><span class="pcode-bold">r2</span></span><span class="No-Break"><strong class="source-inline">,r1,r0</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">11001010 <span class="CharOverride-5">∧</span> <span class="No-Break">00001111</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break">00001010</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><strong class="source-inline">or  </strong><span class="No-Break"><span class="pcode-bold">r2</span></span><span class="No-Break"><strong class="source-inline">,r1,r0</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">11001010 + <span class="No-Break">00001111</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break">11001111</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><strong class="source-inline">mvn </strong></span><span class="No-Break"><span class="pcode-bold">r2</span></span><span class="No-Break"><strong class="source-inline">,r1</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break">īōōīōīō</span><span class="No-Break">￼</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break">00110101</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><strong class="source-inline">eor </strong></span><span class="No-Break"><span class="pcode-bold">r2</span></span><span class="No-Break"><strong class="source-inline">,r1,r0</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">11001010 <span class="CharOverride-5">⊕</span> <span class="No-Break">00001111￼</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break">11000101</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><strong class="source-inline">bic </strong></span><span class="No-Break"><span class="pcode-bold">r2</span></span><span class="No-Break"><strong class="source-inline">,r1,r0</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">11001010 <span class="CharOverride-5">∧</span> <span class="No-Break">ōōōōīīīī</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break">11000000</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="AlanGeneral" lang="en-GB">When you design instruction sets, one of the major tasks is to construct binary codes for instructions. These operations make it easy to implement the manipulation of bits. For example, suppose variable <strong class="source-inline">sR1</strong> specifies source register 1, and <strong class="source-inline">sR2</strong> specifies source register 2, and we have to construct a 16-bit binary code, <strong class="source-inline">C</strong>, with the format <strong class="source-inline">xxxxx</strong><span class="pcode-bold">aaa</span><strong class="source-inline">xx</strong><span class="pcode-bold">bbb</span><strong class="source-inline">xxx</strong>. Source bits <strong class="source-inline">a</strong> are in <strong class="source-inline">sR1</strong> and source bits <strong class="source-inline">b</strong> are in <strong class="source-inline">sR2</strong> in the lower-order <span class="No-Break">three bits.</span></p>&#13;
			<p lang="en-GB">We must insert the bits of <strong class="source-inline">sR1</strong> and <strong class="source-inline">sR2</strong> at the appropriate <a id="_idIndexMarker657"/>places without changing any other bits of <strong class="source-inline">C</strong>. In Python, we can do this with <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>C = C &amp; 0b11111<strong class="bold">000</strong>11<strong class="bold">000</strong>111       <span class="sc-comment"># Clear the two fields for sR1 and sR2</span></span>&#13;
<span>sR1 = sR1 &lt;&lt; 8                   <span class="sc-comment"># Move sR1 into position by shifting left 8 times</span></span>&#13;
<span>C = C | sR1                      <span class="sc-comment"># Insert sR1</span></span>&#13;
<span>sR2 = sR2 &lt;&lt; 3                   <span class="sc-comment"># Move sR2 into position by shifting left 3 times</span></span>&#13;
<span>C = C | sR2                      <span class="sc-comment"># Insert sR2</span></span></pre>&#13;
			<p lang="en-GB">We can readily translate this into ARM assembly language using <strong class="source-inline">AND</strong>, <strong class="source-inline">OR</strong>, and shift operations. Assume <strong class="source-inline">sR1</strong> is in <strong class="source-inline">r1</strong>, <strong class="source-inline">sR2</strong> is in <strong class="source-inline">r2</strong>, and <strong class="source-inline">C</strong> is in register <strong class="source-inline">r0</strong>. Moreover, assume that the register bits are already in place in their <span class="No-Break">respective registers:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>   ldr r3,=0b1111100011000111    <span class="sc-comment">@ Load r3 with 1111100011000111 mask</span></span>&#13;
<span>   and r0,r0,r3                  <span class="sc-comment">@ Mask r0 to get xxxxx000xx000xxx</span></span>&#13;
<span>   or  <strong class="bold">r0</strong>,r0,r1                  <span class="sc-comment">@ Insert r1 to get xxxxxaaaxx000xxx</span></span>&#13;
<span>   or  <strong class="bold">r0</strong>,r0,r2                  <span class="sc-comment">@ Insert r2 to get xxxxxaaaxxbbbxxx</span></span></pre>&#13;
			<h3 lang="en-GB">Shift operations</h3>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Python can shift bits left using the <strong class="source-inline">&lt;&lt;</strong> operator, or right using the <strong class="source-inline">&gt;&gt;</strong> operator. ARM’s assembly language lacks explicit instructions such as <strong class="source-inline">LSR</strong> or <strong class="source-inline">LSL</strong> that shift bits right or left. However, it does have pseudo-instructions such as <strong class="source-inline">lsl</strong> <span class="pcode-bold">r1</span>,<strong class="source-inline">r3</strong>,<strong class="source-inline">#4</strong> that shift the <a id="_idIndexMarker658"/>contents of <strong class="source-inline">r3</strong> four places left, transferring the result to <strong class="source-inline">r1</strong>. The ARM’s <em class="italic">actual</em> approach to shifting is rather more unusual, complicated, <span class="No-Break">and </span><span class="No-Break"><em class="italic">versatile</em></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The ARM includes shifting as part of conventional data operations. Consider <strong class="source-inline">add </strong><span class="pcode-bold">r1</span><strong class="source-inline">,r2,r3</strong>, which adds <strong class="source-inline">r3</strong> to <strong class="source-inline">r2</strong> and puts the result in <strong class="source-inline">r1</strong>. ARM allows you to shift the second operand <em class="italic">before</em> it is used in a data processing operation. You can write <strong class="source-inline">add r1,r2,r3, lsl r4</strong> (see <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.2</em> for an explanation of the second <span class="No-Break">destination field).</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer071" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_10.02_B19624.jpg" alt="Figure 10.2 – The structure of a dynamic shift operation" width="715" height="154"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – The structure of a dynamic shift operation</p>&#13;
			<p lang="en-GB">This instruction takes the second source operand, r3, and performs a logical shift left. The number of left shifts is determined by the contents of r4. You can also implement a fixed shift using a constant with <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>add r1,r2,r3,lsl #3</span></pre>&#13;
			<p lang="en-GB">In this case, register r3 is shifted left by three bits before it is added to <strong class="source-inline">r2</strong>. A shift is called <em class="italic">dynamic</em> if the number of shifts is specified by a register, since you can <a id="_idIndexMarker659"/>change the number of shifts at runtime by changing the shift count. If the number of shifts is given by a literal (constant), it cannot be changed at runtime. This is a <span class="No-Break"><em class="italic">static</em></span><span class="No-Break"> shift.</span></p>&#13;
			<p lang="en-GB">The ARM’s shift combines a data-processing operation with shifting (speeding up data processing), and it lets you specify four registers in an instruction. What do you do if you require a plain vanilla shift without including a data-processing instruction? You can use the <strong class="source-inline">MOV</strong> instruction, such as <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>mov <strong class="bold">r1</strong>,r1,lsr #1         <span class="sc-comment">@ Shift contents of register r1 a single bit place right before moving</span></span></pre>&#13;
			<p lang="en-GB">Today, ARM assemblers let you write the pseudo-instruction <strong class="source-inline">lsl </strong><span class="pcode-bold">r1</span><strong class="source-inline">,r3,#4</strong> and automatically substitute the move instruction <strong class="source-inline">mov </strong><span class="pcode-bold">r1</span><strong class="source-inline">,r1,lsr #4</strong>, using a shifted <span class="No-Break">second operand.</span></p>&#13;
			<h4 lang="en-GB">Shift types</h4>&#13;
			<p lang="en-GB">All shifts look the same from the middle of a string of bits – that is, the bits move one (or more) places left or right. However, what happens to <a id="_idIndexMarker660"/>the bits at the end? When bits are shifted in a register, at one end, a bit will drop out. That bit can disappear into oblivion, go to the carry bit, or move around to the other end in a circular fashion. At the end where a bit is vacated, the new bit can be set to <strong class="source-inline">0</strong>, <strong class="source-inline">1</strong>, the same as the carry bit, or the bit that fell off the <span class="No-Break">other end.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The variations in the way that the bit shifted in is treated by computers correspond to specific types of shift – <em class="italic">logical</em>, <em class="italic">arithmetic</em>, <em class="italic">rotate</em>, and <em class="italic">rotate through carry</em>. Let’s look at some shift operations (<span class="No-Break"><em class="italic">table 10.1</em></span><span class="No-Break">):</span></p>&#13;
			<table id="table002-6" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Source string</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Direction</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Number </strong><span class="No-Break"><strong class="bold">of shifts</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Destination string</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><span class="pcode-bold">0</span></span><span class="No-Break"><strong class="source-inline">110011111010111</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Left</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">110011111010111</strong></span><span class="No-Break"><em class="italic">0</em></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><span class="pcode-bold">01</span></span><span class="No-Break"><strong class="source-inline">10011111010111</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Left</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">10011111010111</strong></span><span class="No-Break"><em class="italic">00</em></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><span class="pcode-bold">011</span></span><span class="No-Break"><strong class="source-inline">0011111010111</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Left</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">3</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">0011111010111</strong></span><span class="No-Break"><em class="italic">000</em></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">011001111101011</strong></span><span class="No-Break"><span class="pcode-bold">1</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Right</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><em class="italic">0</em></span><span class="No-Break"><strong class="source-inline">011001111101011</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">01100111110101</strong></span><span class="No-Break"><span class="pcode-bold">11</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Right</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><em class="italic">00</em></span><span class="No-Break"><strong class="source-inline">01100111110101</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">0110011111010</strong></span><span class="No-Break"><span class="pcode-bold">111</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Right</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">3</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><em class="italic">000</em></span><span class="No-Break"><strong class="source-inline">0110011111010</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Figure" lang="en-GB">Table 10.1 – ARM's logical shift operations</p>&#13;
			<p lang="en-GB">The bits in the destination string in italic are the bits shifted in, and the bits in the source string in bold are the bits lost (dropped) after the shift. This type of shift is a <span class="No-Break"><em class="italic">logical </em></span><span class="No-Break">shift:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB"><strong class="bold">Logical shift</strong>: The bits shifted are <a id="_idIndexMarker661"/>moved one or more places left or right. Bits fall off at one end and zeros enter at the other end. The last bit shifted out is <a id="_idIndexMarker662"/>copied to the carry flag. <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.3</em> illustrates the logical shift left and the logical <span class="No-Break">shift right.</span></li>&#13;
			</ul>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer072" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_10.03_B19624.jpg" alt="Figure 10.3 – Logical shifts" width="1115" height="572"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Logical shifts</p>&#13;
			<ul>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB"><strong class="bold">Arithmetic shift</strong>: This arithmetic shift <a id="_idIndexMarker663"/>treats the number <a id="_idIndexMarker664"/>being shifted as a signed twos complement value. An arithmetic shift left is the same as a logical shift for left shifts. For right shifts, the most-significant bit is propagated right. This shift treats the operand as a signed value, which is either divided by two (shift right one bit) or multiplied by two (shift left one bit), as <span class="No-Break"><em class="italic">Figure </em></span><span class="No-Break"><em class="italic">10</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break"> demonstrates.</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">The purpose of an arithmetic shift is to preserve the sign of a twos complement number, when it takes part in a shifting operation that represents division by the power of 2. For example, the 8-bit value <strong class="source-inline">10001111</strong> becomes <strong class="source-inline">01000111</strong> when shifted right <em class="italic">logically</em>, but <span class="pcode-bold">11</span><strong class="source-inline">000111</strong> when shifted right <em class="italic">arithmetically</em>.</p>&#13;
			<p lang="en-GB"><em class="italic">Figure 10.4</em> illustrates the arithmetic shift left and shift right. The ARM has an <strong class="source-inline">asr</strong> operation but not <strong class="source-inline">asl</strong>, because <strong class="source-inline">asl</strong> is identical to <strong class="source-inline">LSL</strong> – that is, you use a logical shift left because it is exactly the same as asl.</p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer073" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_10.04_B19624.jpg" alt="Figure 10.4 – Arithmetic shifts" width="1294" height="686"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Arithmetic shifts</p>&#13;
			<ul>&#13;
				<li lang="en-GB"><strong class="bold">Rotate</strong>: A rotate treats the <a id="_idIndexMarker665"/>value to be shifted as a ring – that is, the two ends are adjacent. The bit shifted out at one end moves into the position <a id="_idIndexMarker666"/>vacated at the other end. If you apply n rotates to an n-bit value, you end up where you started. Consider the 8-bit value <strong class="source-inline">01101110</strong> being rotated left, one bit at <span class="No-Break">a time:</span></li>&#13;
			</ul>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer074" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_10.05_B19624.jpg" alt="Figure 10.5 – Example of successive rotate operations" width="504" height="398"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 10.5 – Example of successive rotate operations</p>&#13;
			<p lang="en-GB">The rotate operation is <em class="italic">non-destructive</em> – that is, no bit is lost or changed by the operation. It is very useful in operations such as counting the number of <strong class="source-inline">1</strong>s in a bit string. <em class="italic">Figure 10.6</em> illustrates the <em class="italic">rotate</em> operation. Note that the ARM does <em class="italic">not</em> have a rotate right instruction – that is, there is no <strong class="source-inline">ror</strong>. Since rotate is a circular operation, shifting an <em class="italic">m</em>-bit word <em class="italic">p</em> places right is achieved by shifting <strong class="source-inline">32-p</strong> places left; consequently, <strong class="source-inline">ror r0,r1,#4</strong> is achieved by <strong class="source-inline">rol r0,r1,#28</strong>.</p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer075" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_10.06_B19624.jpg" alt="Figure 10.6 – Rotate operations (ARM does not implement ROL)" width="1093" height="560"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Rotate operations (ARM does not implement ROL)</p>&#13;
			<p lang="en-GB">A variation of the <a id="_idIndexMarker667"/>rotate operation is the <em class="italic">rotate through carry</em>, where the carry bit is considered as part of the word being shifted – that is, an <em class="italic">n</em>-bit word becomes an <em class="italic">n+1</em> bit word. <em class="italic">Figure 10.7</em> demonstrates a rotate through carry operation, where the carry <a id="_idIndexMarker668"/>shifted out is copied into the carry bit, and the old value of the carry bit becomes the new bit shifted in. This operation is used in chained arithmetic (it’s the analog of the <em class="italic">add with carry and subtract with borrow</em> operations).</p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer076" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_10.07_B19624.jpg" alt="Figure 10.7 – Rotate through carry" width="984" height="303"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Rotate through carry</p>&#13;
			<p lang="en-GB">ARM implements only the following five shifts (a programmer can synthesize the rest):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>lsl     <span class="sc-comment">logical shift left</span></span>&#13;
<span>lsr     <span class="sc-comment">logical shift right</span></span>&#13;
<span>asr     <span class="sc-comment">arithmetic shift right</span></span>&#13;
<span>ror     <span class="sc-comment">rotate right</span></span></pre>&#13;
			<pre class="source-code">rrx     <span class="sc-comment">rotate right through carry (1-bit shift only)</span></pre>&#13;
			<p lang="en-GB"><strong class="source-inline">rrx</strong>, which rotates bits right through carry (<em class="italic">Figure 10.7</em>), behaves differently from other shifts. First, only one direction of shift is permitted; there is no left shift through carry. Second, the ARM supports both <em class="italic">static</em> and <em class="italic">dynamic </em>shifts for all other shift operations, whereas <strong class="source-inline">rrx</strong> allows only one single shift.</p>&#13;
			<p lang="en-GB">Although there is no rotate left operation, you can readily implement it by means of a rotate right operation. The following example demonstrates the rotation, both left and right, of a 4-bit value. After four rotations, the number is unchanged. As you can see, there is symmetry between left and right rotations. For a 32-bit value, an <em class="italic">n</em>-bit shift left is identical to a 32-<em class="italic">n</em> bit shift right:</p>&#13;
			<table id="table003-4" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1" colspan="2">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate right </p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1" colspan="2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break">Rotate left</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><span class="pcode-bold">1101</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break">Start</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><span class="pcode-bold">1101</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break">Start</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><span class="pcode-bold">1110</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate <span class="No-Break">right 1</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><span class="pcode-bold">1011</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate <span class="No-Break">left 1</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><span class="pcode-bold">0111</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate <span class="No-Break">right 2</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><span class="pcode-bold">0111</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate <span class="No-Break">left 2</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><span class="pcode-bold">1011</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate <span class="No-Break">right 3</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><span class="pcode-bold">1110</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate <span class="No-Break">left 3</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><span class="pcode-bold">1101</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate <span class="No-Break">right 4</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><span class="pcode-bold">1101</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate <span class="No-Break">left 4</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Figure" lang="en-GB">Table 10.2 - Comparing successive left and right rotates</p>&#13;
			<p lang="en-GB">Consider <strong class="source-inline">adcs </strong><span class="pcode-bold">r0</span>,<strong class="source-inline">r0</strong>,<strong class="source-inline">r0</strong> (add with carry and set status flags). This adds the contents of <strong class="source-inline">r0</strong> to the contents of <strong class="source-inline">r0</strong>, plus the carry bit, to generate <strong class="source-inline">2 x [r0] + C</strong>. Shifting left is equivalent to multiplying by 2. Moving the carry bit into the least-significant <a id="_idIndexMarker669"/>position is equivalent <a id="_idIndexMarker670"/>to adding the carry bit to get <strong class="source-inline">2 x [r0] + C</strong>. Appending <strong class="source-inline">S</strong> to the instruction forces the <strong class="source-inline">CCR</strong> to be updated, which ensures that any carryout is loaded into the C-bit. Consequently, <strong class="source-inline">adcs </strong><span class="pcode-bold">r0</span>,<strong class="source-inline">r0</strong>,<strong class="source-inline">r0</strong> and <strong class="source-inline">rlx</strong> <span class="pcode-bold">r0</span> are equivalent.</p>&#13;
			<h4 lang="en-GB">Using shift operations to merge data</h4>&#13;
			<p lang="en-GB">In the following example, we extract the <a id="_idIndexMarker671"/>least-significant byte from each of the three registers and put them together in a new word. The literals are in a hexadecimal format. Assume that the registers are, initially, <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB"><strong class="source-inline">r1</strong> = <strong class="source-inline">XXXXXX</strong><span class="pcode-bold">AA</span><span class="CharOverride-3">   </span><strong class="source-inline">r1</strong> is source 1, the Xs represent don’t <span class="No-Break">care values</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">r2</strong> = <strong class="source-inline">XXXXXX</strong><span class="pcode-bold">BB</span><span class="CharOverride-3">   </span><strong class="source-inline">r2</strong> is <span class="No-Break">source 2</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">r3</strong> = <strong class="source-inline">XXXXXX</strong><span class="pcode-bold">CC</span><span class="CharOverride-3">   </span><strong class="source-inline">r3</strong> is <span class="No-Break">source 3</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">r4</strong> = <strong class="source-inline">00</strong><span class="pcode-bold">CCBBAA</span><span class="CharOverride-3">   </span><strong class="source-inline">r4</strong> is the <span class="No-Break">final result</span></li>&#13;
			</ul>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      mov <strong class="bold">r4</strong>,#0                <span class="sc-comment">@ Clear r4</span></span>&#13;
<span>      and <strong class="bold">r1</strong>,r1,#0x000000FF    <span class="sc-comment">@ Clear r1 except least-significant byte</span></span>&#13;
<span>      and <strong class="bold">r2</strong>,r2,#0x0000FF00    <span class="sc-comment">@ Clear r2 except second byte</span></span>&#13;
<span>      and <strong class="bold">r3</strong>,r2,#0x00FF0000    <span class="sc-comment">@ Clear r3 except third byte</span></span>&#13;
<span>      or  <strong class="bold">r4</strong>,r4,r1             <span class="sc-comment">@ Copy r1 to r4. No shifting</span></span>&#13;
<span>      or  <strong class="bold">r4</strong>,r4,r2 lsl #8      <span class="sc-comment">@ Copy r2 to r4. Shifting to second byte</span></span></pre>&#13;
			<pre class="source-code">      or  <strong class="bold">r4</strong>,r4,r3 lsl #16     <span class="sc-comment">@ Copy r3 to r4. Shifting to third byte</span></pre>&#13;
			<p lang="en-GB">The preceding code is a brute-force approach. A better alternative is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      and <strong class="bold">r4</strong>,r1,#0x000000FF    <span class="sc-comment">@ Clear r4 and insert r1 0x000000AA</span></span>&#13;
<span>      or  <strong class="bold">r4</strong>,r4,r2 lsl #8      <span class="sc-comment">@ Insert r2, shifting left into place 0xXXXXBBAA</span></span>&#13;
<span>      or  <strong class="bold">r4</strong>,r4,r3 lsl #16     <span class="sc-comment">@ Insert r3, shifting left into place 0xXXCCBBAA</span></span>&#13;
<span>      and <strong class="bold">r4</strong>,r4,#0x00FFFFFF    <span class="sc-comment">@ Insert most-significant byte 0x00CCBBAA</span></span></pre>&#13;
			<p lang="en-GB">Now, consider <strong class="source-inline">r0 = 0x0000</strong><span class="pcode-bold">AA</span>, <strong class="source-inline">r1 = 0x000000</strong><span class="pcode-bold">BB</span>, and <strong class="source-inline">r2 = 0x12345678</strong>. We wish to merge the four registers to get <strong class="source-inline">0x</strong><span class="pcode-bold">AABB</span><strong class="source-inline">5678</strong>. We can do this with just <span class="No-Break">three instructions:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>add <strong class="bold">r2</strong>,r1,r2,lsl #16           <span class="sc-comment">@ r2 = 567800BB</span></span>&#13;
<span>add <strong class="bold">r2</strong>,r2,r0,lsl #8            <span class="sc-comment">@ r2 = 5678AABB</span>,</span>&#13;
<span>mov <strong class="bold">r2</strong>,r2,ror #16              <span class="sc-comment">@ r2 = AABB5678</span></span></pre>&#13;
			<p lang="en-GB"><strong class="source-inline">add r2,r1,r2,lsl #16</strong> adds <strong class="source-inline">r1</strong> to <strong class="source-inline">r2</strong> after <strong class="source-inline">r2</strong> has been shifted left 16 times. The 16-bit left shift moves the lower-order 16-bits of <strong class="source-inline">r2</strong> into the upper-order 16-bits, and it clears the lower-order 16 bits by shifting in zeros. We’ve preserved the old lower-order half of <strong class="source-inline">r2</strong>, and we’ve cleared the new lower-order 16 bits ready to insert the bytes from <strong class="source-inline">r0</strong> and <strong class="source-inline">r1</strong>. add <span class="pcode-bold">r2</span><strong class="source-inline">,r2,r0,lsl #8</strong> inserts the low-order byte of <strong class="source-inline">r0</strong> into bits 8 to 15 of <strong class="source-inline">r2</strong>, since <strong class="source-inline">r0</strong> is first shifted left by 8 bits. Since zeros are shifted into <strong class="source-inline">r0</strong>, this operation doesn’t affect bits 0 to 7 of <strong class="source-inline">r2</strong>. Executing <strong class="source-inline">mov </strong><span class="pcode-bold">r2</span><strong class="source-inline">,r2,ror #16</strong> performs a <span class="No-Break">16-bit rotation.</span></p>&#13;
			<p lang="en-GB">The next example of shifting demonstrates how we can implement <strong class="source-inline">if x &lt; 0: x = 0</strong>. This construct sets the <strong class="source-inline">x</strong> variable to zero if <strong class="source-inline">x</strong> is negative (i.e., <strong class="source-inline">msb</strong> is <strong class="source-inline">1</strong>); otherwise, <strong class="source-inline">x</strong> is unchanged. The ARM code is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>bic r0,r0,r0,asr #31</span></pre>&#13;
			<p lang="en-GB">The arithmetic shift right <a id="_idIndexMarker672"/>propagates the sign-bit 31 times, leaving <strong class="source-inline">0x00000000</strong> for a positive number and <strong class="source-inline">0xFFFFFFFF</strong> for a negative number. The <strong class="source-inline">bic</strong> operation <strong class="source-inline">AND</strong>s the first operand and the complement of the second. If <strong class="source-inline">r0</strong> was positive, all bits are <strong class="source-inline">AND</strong>ed, with 1 leaving <strong class="source-inline">r0</strong> unchanged. If <strong class="source-inline">r0</strong> was negative, the bits are <strong class="source-inline">AND</strong>ed, with <strong class="source-inline">0</strong> leaving <strong class="source-inline">0</strong>. Therefore, a positive <strong class="source-inline">x</strong> is unchanged and a negative <strong class="source-inline">x</strong> is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The next section looks at a class of instruction that does not move data or process data; it determines which instruction will be <span class="No-Break">executed next.</span></p>&#13;
			<h1 id="_idParaDest-175" lang="en-GB"><a id="_idTextAnchor191"/>Flow control instructions</h1>&#13;
			<p lang="en-GB">Computers execute instructions sequentially unless a branch causes a jump to an out-of-sequence instruction, or the flow of <a id="_idIndexMarker673"/>instructions is interrupted when a subroutine is called. The instruction flow is also changed when an interrupt occurs (we don’t deal with <span class="No-Break">interrupts here).</span></p>&#13;
			<p lang="en-GB">In this section, we will look at <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB"><span class="No-Break">Unconditional branches</span></li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB"><span class="No-Break">Conditional branches</span></li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-176" lang="en-GB"><a id="_idTextAnchor192"/>Unconditional branches</h2>&#13;
			<p lang="en-GB">ARM’s unconditional branch is expressed as <strong class="source-inline">b target</strong>, where <strong class="source-inline">target</strong> denotes the <em class="italic">branch target address</em> (the address of the next instruction to be executed). The unconditional <a id="_idIndexMarker674"/>branch forces a jump (branch) from one point in a program to another. It is exactly the <a id="_idIndexMarker675"/>same as the unconditional branch we introduced earlier. The following ARM code demonstrates how the unconditional branch <span class="No-Break">is used:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      ..   do this       <span class="sc-comment">@ Some code</span></span>&#13;
<span>      ..   then that     <span class="sc-comment">@ Some other code</span></span>&#13;
<span>      <strong class="bold">b    Next</strong>          <span class="sc-comment">@ Now skip past the next instructions and jump to Next:</span></span>&#13;
<span>      ..                 <span class="sc-comment">@ …the code being skipped past</span></span>&#13;
<span>      ..                 <span class="sc-comment">@ …the code being skipped past</span></span>&#13;
<span><strong class="bold">Next:</strong> ..                 <span class="sc-comment">@ Target address for the branch, denoted by label Next</span></span></pre>&#13;
			<p class="AlanGeneral" lang="en-GB">The ARM’s branch instructions use a 24-bit literal to provide a twos complement relative offset. This is shifted left twice to create a 26-bit <em class="italic">byte</em> offset, which is added to the current program counter to obtain the 32-bit target address. The branch range is 32 MB from the current PC (in either direction). Remember that consecutive instruction addresses differ <span class="No-Break">by four.</span></p>&#13;
			<h2 id="_idParaDest-177" lang="en-GB"><a id="_idTextAnchor193"/>Conditional branch</h2>&#13;
			<p lang="en-GB">ARM’s conditional branches consist of a mnemonic B<span class="subscript">cc</span> and a target address. The subscript defines one of 16 conditions that must <a id="_idIndexMarker676"/>be satisfied for the <a id="_idIndexMarker677"/>branch to be taken. If the condition is <strong class="source-inline">true</strong>, execution continues at the branch target address. If the condition is not <strong class="source-inline">true</strong>, the next instruction in sequence is executed. Consider the flowing example in ARM assembly language that implements <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if x == y: y = y + 1</span>&#13;
<span>else:      y = y + 2</span>&#13;
<span>       cmp <strong class="bold">r1</strong>,r2         <span class="sc-comment">@ Compare x and y (r1 contains y and r2 contains x)</span></span>&#13;
<span>       <strong class="bold">bne plus2</strong>         <span class="sc-comment">@ If not equal, then branch to the else part</span></span>&#13;
<span>       add <strong class="bold">r1</strong>,r1,#1      <span class="sc-comment">@ If equal, fall through to here and add one to y</span></span>&#13;
<span>       <strong class="bold">b   leave</strong>         <span class="sc-comment">@ Now, skip past the else part</span></span>&#13;
<span><strong class="bold">plus2</strong>: add <strong class="bold">r1</strong>,r1,#2      <span class="sc-comment">@ ELSE add 2 to y</span></span>&#13;
<span>leave:  …                <span class="sc-comment">@ Continue from here</span></span></pre>&#13;
			<p lang="en-GB">The <em class="italic">conditional branch</em> instruction tests flag bits in the processor’s condition code register and then takes the branch if the tested condition is true. Since the condition code register includes a zero bit (<strong class="source-inline">Z</strong>), negative bit (<strong class="source-inline">N</strong>), carry bit (<strong class="source-inline">C</strong>), and overflow bit (<strong class="source-inline">V</strong>), there are eight conditional branches based on the state of a single bit (four that branch on true and four that branch on <strong class="source-inline">false</strong>). <em class="italic">Table 10.3</em> defines all the ARM’s conditional branches. Note that there is a branch <em class="italic">always</em> and a branch <span class="No-Break"><em class="italic">never</em></span><span class="No-Break"> instruction.</span></p>&#13;
			<p lang="en-GB">Branch instructions can be applied to <em class="italic">signed</em> or <em class="italic">unsigned</em> data. Consider the four-bit values <strong class="source-inline">x = 0011</strong> and y = 1001. We want to branch if <strong class="source-inline">y</strong> is greater than <strong class="source-inline">x</strong>. Using unsigned arithmetic, <strong class="source-inline">x = 3</strong> and <strong class="source-inline">y</strong> is <strong class="source-inline">9</strong>, so y &gt; x. However, if we regard these as signed values, then <strong class="source-inline">x = 3</strong> and <strong class="source-inline">y = -7</strong>, so <strong class="source-inline">y &lt; x</strong>. Clearly, we have to select an unsigned comparison for <a id="_idIndexMarker678"/>unsigned arithmetic and a <a id="_idIndexMarker679"/>signed comparison for <span class="No-Break">signed arithmetic.</span></p>&#13;
			<table id="table004-2" class="No-Table-Style TableOverride-1">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><strong class="bold CharOverride-6">Encoding</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break"><strong class="bold CharOverride-6">Mnemonic</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><strong class="bold CharOverride-6">Branch on </strong><span class="No-Break"><strong class="bold CharOverride-6">flag status</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><strong class="bold CharOverride-6">Execute </strong><span class="No-Break"><strong class="bold CharOverride-6">on condition</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">0000</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">EQ</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">Z set</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="CharOverride-7">Equal (</span><span class="No-Break CharOverride-7">i.e., zero)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">0001</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">NE</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">Z clear</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="CharOverride-7">Not equal (i.e., </span><span class="No-Break CharOverride-7">not zero)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">0010</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="CharOverride-7">CS </span><span class="No-Break CharOverride-7">or HS</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">C set</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="CharOverride-7">Unsigned higher </span><span class="No-Break CharOverride-7">or same</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">0011</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="CharOverride-7">CC </span><span class="No-Break CharOverride-7">or LO</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">C clear</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">Unsigned lower</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">0100</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">MI</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">N set</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">Negative</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">0101</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">PL</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">N clear</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="CharOverride-7">Positive </span><span class="No-Break CharOverride-7">or zero</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">0110</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">VS</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">V set</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">Overflow</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">0111</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">VC</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">V clear</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">No overflow</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">1000</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">HI</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="CharOverride-7">C set and </span><span class="No-Break CharOverride-7">Z clear</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">Unsigned higher</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">1001</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">LS</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="CharOverride-7">C clear or </span><span class="No-Break CharOverride-7">Z set</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="CharOverride-7">Unsigned lower </span><span class="No-Break CharOverride-7">or same</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">1010</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">GE</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="CharOverride-7">N set and V set, or N clear and </span><span class="No-Break CharOverride-7">V clear</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="CharOverride-7">Signed greater </span><span class="No-Break CharOverride-7">or equal</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">1011</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">LT</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="CharOverride-7">N set and V clear, or N clear and </span><span class="No-Break CharOverride-7">V set</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="CharOverride-7">Signed </span><span class="No-Break CharOverride-7">less than</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">1100</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">GT</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="CharOverride-7">Z clear, and either N set and V set, or N clear and </span><span class="No-Break CharOverride-7">V clear</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="CharOverride-7">Signed </span><span class="No-Break CharOverride-7">greater than</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">1101</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">LE</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="CharOverride-7">Z set, or N set and V clear, or N clear and </span><span class="No-Break CharOverride-7">V set</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="CharOverride-7">Signed less than </span><span class="No-Break CharOverride-7">or equal</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">1110</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">AL</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">Unconditional</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">Always (default)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">1111</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">NV</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3"/>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="AlanGeneral" lang="en-GB"><span class="No-Break CharOverride-7">Never (reserved)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.3 – ARM’s conditional execution and branch control mnemonics</p>&#13;
			<p lang="en-GB">Some microprocessors have <em class="italic">synonyms</em> for conditional branch operations – that is, a branch condition has two mnemonics. For <a id="_idIndexMarker680"/>example, branch on carry set <strong class="source-inline">(bcs)</strong> can be <a id="_idIndexMarker681"/>written branch on higher or same <strong class="source-inline">(bhs)</strong>, because <strong class="source-inline">C = 1</strong> implements the ( <strong class="source-inline">&gt;</strong> ) operation in unsigned arithmetic. Similarly, <strong class="source-inline">bcc</strong> can be written branch on lower <strong class="source-inline">(blo)</strong>, because the carry <a id="_idIndexMarker682"/>clear implements an unsigned comparison that <span class="No-Break">is lower.</span></p>&#13;
			<p lang="en-GB">One of the best examples of the use of conditional branching is in repetitive structures. Consider the <span class="No-Break"><strong class="source-inline">while</strong></span><span class="No-Break"> loop:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Loop:       cmp   <strong class="bold">r0</strong>,#0         <span class="sc-comment">@ Perform test at start of loop (exit on zero)</span></span>&#13;
<span>            <strong class="bold">beq   whileExit</strong>     <span class="sc-comment">@ Exit on test true</span></span>&#13;
<span>            Code  ...           <span class="sc-comment">@ Body of the loop</span></span>&#13;
<span>            b     Loop          <span class="sc-comment">@ Repeat WHILE true</span></span>&#13;
<span><strong class="bold">whileExit:</strong>  Post-loop code...   <span class="sc-comment">@ Exit</span></span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The final section of this chapter looks at ARM’s <em class="italic">conditional execution mechanism</em>, which provides a means of squashing or <em class="italic">annulling</em> instructions – that is, you can choose to run or not run an instruction at runtime. This is a feature found on very, very few processors. However, this mechanism provides the ARM with a very interesting means of speeding execution by creating <span class="No-Break">compact code.</span></p>&#13;
			<h1 id="_idParaDest-178" lang="en-GB"><a id="_idTextAnchor194"/>Conditional executions</h1>&#13;
			<p lang="en-GB">Here, we will deal with just one topic, conditional executing, and we will demonstrate how you can ignore an instruction if it does not fulfill a <a id="_idIndexMarker683"/>specified criterion (related to the condition control status bits). This mechanism enables programmers to write more <span class="No-Break">compact code.</span></p>&#13;
			<p lang="en-GB">Consider the <strong class="source-inline">add</strong> instruction. When the computer reads it from memory, it is executed, exactly like almost every other computer. The ARM is different; each of its instructions is <em class="italic">conditionally executed</em> – that is, an instruction is executed only if a specific condition is met; otherwise, it is bypassed (annulled or squashed). Each ARM instruction is associated with a logical condition (one of the 16 in <em class="italic">Table 10.3</em>). If the stated condition is true, the instruction <span class="No-Break">is executed.</span></p>&#13;
			<p lang="en-GB">A suffix indicates conditional execution by appending <strong class="source-inline">condition</strong> – for example, <strong class="source-inline">add</strong><span class="pcode-bold">eq</span><strong class="source-inline"> </strong><span class="pcode-bold">r1</span><strong class="source-inline">,r2,r3</strong> specifies that the addition is performed <em class="italic">only if the Z-bit in the CCR is set</em>. The RTL form of this operation is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-source-bg">IF Z = 1 THEN</span> [r1] ← [r2] + [r3]</span></pre>&#13;
			<p lang="en-GB">There is, of course, nothing to stop you from combining conditional execution and shifting, since the branch and shift fields of an instruction are independent. You can write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>add<strong class="bold">cc</strong>  <strong class="bold">r1</strong>,r2,r3, lsl r4</span></pre>&#13;
			<p lang="en-GB">This is interpreted <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span> <span class="sc-source-bg">IF C = 0 THEN</span> [r1] ← [r2] + [r3] x 2<span class="superscript">[r4]</span>.</span></pre>&#13;
			<p lang="en-GB">To demonstrate the power of conditional execution, consider the following <span class="No-Break">Python statement:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if A == B: C = D – E;</span></pre>&#13;
			<p lang="en-GB">Translated into ARM code using conditional execution, we can write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      cmp    <strong class="bold">r1</strong>,r2         <span class="sc-comment">@ Compare A == B</span></span>&#13;
<span>      sub<strong class="bold">eq</strong>  <strong class="bold">r3</strong>,r1,r4      <span class="sc-comment">@ If (A== B) then C = D - E</span></span></pre>&#13;
			<p lang="en-GB">After the test, the operation is either executed or not executed, depending on the result of the test. Now, consider a construct with a <span class="No-Break">compound predicate:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if ((a == b)<strong class="bold">AND</strong>(c == d)): e = e + 1</span>&#13;
<span>      cmp    <strong class="bold">r0</strong>,r1         <span class="sc-comment">@ Compare a == b</span></span>&#13;
<span>      cmp<strong class="bold">eq</strong>  <strong class="bold">r2</strong>,r3         <span class="sc-comment">@ If a == b then test c == d</span></span>&#13;
<span>      add<strong class="bold">eq</strong>  <strong class="bold">r4</strong>,r4,#1      <span class="sc-comment">@ If a == b AND c == d THEN increment e</span></span></pre>&#13;
			<p lang="en-GB">The first line, <strong class="source-inline">cmp </strong><span class="pcode-bold">r0</span><strong class="source-inline">,r1</strong>, compares <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>. The next line, <strong class="source-inline">cmp</strong><span class="pcode-bold">eq</span><strong class="source-inline"> </strong><span class="pcode-bold">r2</span><strong class="source-inline">,r3</strong>, executes a conditional comparison only if the result of the first line was true (i.e., <strong class="source-inline">a == b</strong>). The third line, <strong class="source-inline">add</strong><span class="pcode-bold">eq</span><strong class="source-inline"> </strong><span class="pcode-bold">r4</span><strong class="source-inline">,r4,#1</strong>, is executed only if the previous line was true (i.e., <strong class="source-inline">c == d</strong>) to implement <strong class="source-inline">e = e + 1</strong>. Without conditional execution, we might write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      cmp    <strong class="bold">r0</strong>,r1           <span class="sc-comment">@ Compare a == b</span></span>&#13;
<span>      bne    Exit            <span class="sc-comment">@ Exit if a =! b</span></span>&#13;
<span>      cmp    <strong class="bold">r2</strong>,r3           <span class="sc-comment">@ Compare c == d</span></span>&#13;
<span>      bne    Exit            <span class="sc-comment">@ Exit if c =! d</span></span>&#13;
<span>      add    <strong class="bold">r4</strong>,r4,#1        <span class="sc-comment">@ Else increment e</span></span>&#13;
<span>Exit</span></pre>&#13;
			<p lang="en-GB">This conventional approach to compound logical conditions requires five instructions. You can also handle some testing with multiple conditions. Consider <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if (a == b) e = e + 4;</span>&#13;
<span>if (a &lt; b)  e = e + 7;</span>&#13;
<span>if (a &gt; b)  e = e + 12;</span></pre>&#13;
			<p lang="en-GB">Using the same register assignments as before, we can use conditional <a id="_idIndexMarker684"/>execution to implement this <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      cmp    <strong class="bold">r0</strong>,r1           <span class="sc-comment">@ Compare a == b</span></span>&#13;
<span>      add<strong class="bold">eq</strong>  <strong class="bold">r4</strong>,r4,#4        <span class="sc-comment">@ If a == b then e = e + 4</span></span>&#13;
<span>      add<strong class="bold">le</strong>  <strong class="bold">r4</strong>,r4,#7        <span class="sc-comment">@ If a &lt; b  then e = e + 7</span></span>&#13;
<span>      add<strong class="bold">gt</strong>  <strong class="bold">r4</strong>,r4,#12       <span class="sc-comment">@ If a &gt; b  then e = e + 12</span></span></pre>&#13;
			<p lang="en-GB">Using conventional non-conditional execution, we would have to write the following to implement this algorithm. This is rather less elegant than the <span class="No-Break">previous version:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>        cmp    <strong class="bold">r0</strong>,r1         <span class="sc-comment">@ Compare a == b</span></span>&#13;
<span>        bne    Test1         <span class="sc-comment">@ Not equal try next test</span></span>&#13;
<span>        add    <strong class="bold">r4</strong>,r4,#4      <span class="sc-comment">@ a == b so e = e+4</span></span>&#13;
<span>        b      ExitAll       <span class="sc-comment">@ Now leave</span></span>&#13;
<span>Test1:  blt    Test2         <span class="sc-comment">@ If a &lt; b then</span></span>&#13;
<span>        add    <strong class="bold">r4</strong>,r4,#12     <span class="sc-comment">@ If we are here a &gt; b so e = e + 12</span></span>&#13;
<span>        b      ExitAll       <span class="sc-comment">@ Now leave</span></span>&#13;
<span>Test2:  add    <strong class="bold">r4</strong>,r4,#7      <span class="sc-comment">@ If we are here a &lt; b so e = e + 7</span></span>&#13;
<span>ExitAll:</span></pre>&#13;
			<p lang="en-GB">In the next example, we use conditional execution to obtain the absolute value of a signed integer – that is, if the integer is negative, it is converted into the corresponding positive value. For example (in 8 bits), -2 is <strong class="source-inline">11111110</strong>, which would be converted into <strong class="source-inline">00000010</strong> (<span class="No-Break">i.e., +2).</span></p>&#13;
			<p lang="en-GB">We can use ARM’s <strong class="source-inline">teq</strong> instruction <strong class="bold">(test if equal)</strong> that tests whether two values are equal. <strong class="source-inline">teq</strong> is similar to <strong class="source-inline">CMP</strong>, but <strong class="source-inline">teq</strong> does not set the <strong class="source-inline">V</strong> and <strong class="source-inline">C</strong> flags during the test. <strong class="source-inline">teq</strong> is useful to test for negative values <em class="italic">because the N-bit is set to 1 if the number tested </em><span class="No-Break"><em class="italic">is negative</em></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>       teq    <strong class="bold">r0</strong>,#0          <span class="sc-comment">@ Compare r0 with zero</span></span></pre>&#13;
			<pre class="source-code">       rsbmi  <strong class="bold">r0</strong>,r0,#0       <span class="sc-comment">@ If negative then 0 - [r0]</span></pre>&#13;
			<p lang="en-GB">Here, the operand in <strong class="source-inline">r0</strong> is tested, and the N-bit is set if it is negative and is clear if it is positive. The conditional instruction, <strong class="source-inline">rsb</strong><span class="pcode-bold">mi</span>, is not executed if the tested operand was positive (no change is necessary). If the number was negative, the reverse substation performs <strong class="source-inline">0 – r0</strong>, which reverses its sign and makes <span class="No-Break">it positive.</span></p>&#13;
			<h2 id="_idParaDest-179" lang="en-GB"><a id="_idTextAnchor195"/>Sequential conditional execution</h2>&#13;
			<p lang="en-GB">Since a compare or an arithmetic operation updates the <strong class="source-inline">C</strong>, <strong class="source-inline">N</strong>, <strong class="source-inline">V</strong>, and <strong class="source-inline">Z</strong> bits, we can perform up to four conditional acts after one comparison. The following example <a id="_idIndexMarker685"/>converts uppercase ASCII-encoded characters to lowercase characters – for example, 'M' would be converted to 'm.' Bit 5 of an ASCII character is zero for uppercase letters and one for lowercase letters. Consider the code that first checks whether a character is in the range of 'A' to 'Z' and converts it to lowercase if <span class="No-Break">it is:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      cmp    <strong class="bold">r0</strong>,#'A'         <span class="sc-comment">@ Compare character with letter "A"</span></span>&#13;
<span>      rsb<strong class="bold">ge</strong><span class="sc-source-bg">s</span> <strong class="bold">r1</strong>,r0,#'Z'      <span class="sc-comment">@ Check less than Z if greater than A  Update flags</span></span>&#13;
<span>      orr<strong class="bold">ge</strong>  <strong class="bold">r0</strong>,r0,#0x20     <span class="sc-comment">@ If in "A" to "Z," then set bit 5 to force lowercase</span></span></pre>&#13;
			<p lang="en-GB">The first instruction, <strong class="source-inline">cmp</strong>, checks whether <a id="_idIndexMarker686"/>the character is 'A' or greater by subtracting the ASCII code for 'A.' If it is, the <strong class="source-inline">rsb</strong><span class="pcode-bold">ge</span><span class="pcode-bg">s</span> checks that the character is less than 'Z.' This test is performed only if the character in <strong class="source-inline">r0</strong> is greater or equal to 'A.' We use reverse subtraction because we want to test whether the ASCII code for Z minus the ASCII code for the character is positive. If we are in range, the conditional <strong class="source-inline">orr</strong> is executed, and an uppercase to lowercase conversion is performed by setting <span class="No-Break">bit 5.</span></p>&#13;
			<p lang="en-GB">In the next chapter, we will look at how operands are specified – that is, we will look at <span class="No-Break">addressing modes.</span></p>&#13;
			<h1 id="_idParaDest-180" lang="en-GB"><a id="_idTextAnchor196"/>Summary</h1>&#13;
			<p lang="en-GB">In this chapter, we’ve extended our knowledge of the ARM beyond the basic data-processing instructions we encountered in the <span class="No-Break">previous chapter.</span></p>&#13;
			<p lang="en-GB">We began with the ARM’s register set, which is different from almost every other processor. RISC processors generally have 32 general-purpose registers. The ARM has only <span class="No-Break">16 registers.</span></p>&#13;
			<p lang="en-GB">Two of the ARM’s registers have a special purpose. Register <strong class="source-inline">r14</strong> is called a <em class="italic">link register</em> and is used by the branch with link instructions to restore return addresses. Otherwise, it is a general-purpose register. Register <strong class="source-inline">r15</strong> is the program counter, and that is very unusual indeed. This makes the ARM a very interesting device because you can change the program counter by operating <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">r15</strong></span><span class="No-Break">.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">We also looked at shifting operations. Shifting simply involves bits moving one or more places left or right. However, as bits are in registers or memory locations, a shift involves bits moving into one and dropping out the other. The different types of shifts are determined by what happens to those bits that are shifted in or out at the ends of <span class="No-Break">the number.</span></p>&#13;
			<p lang="en-GB">We discovered that the ARM has another unusual feature because it doesn’t provide pure shift instructions. Instead, it can apply a shift to the second operand in a conventional data processing operation. The ARM can execute an <strong class="source-inline">add </strong><span class="pcode-bold">r0</span><strong class="source-inline">,r1,r2, lsl r3</strong> instruction that shifts the contents of register <strong class="source-inline">r2</strong> left by the value in <strong class="source-inline">r3</strong>. The shifted value is then added to <strong class="source-inline">r1</strong>, and the result is transferred to <strong class="source-inline">r0</strong>. This mechanism provides a <em class="italic">free shift</em> because you can do a shift and not have to pay any penalty to <span class="No-Break">execute it.</span></p>&#13;
			<p lang="en-GB">Probably the most intriguing feature of the ARM is its ability to perform conditional execution – that is, before an instruction is executed, the condition code bits are checked. For example, <strong class="source-inline">add</strong><span class="pcode-bold">eq</span><strong class="source-inline"> r0,r1,r2</strong> performs an addition only if the z-bit is set to <strong class="source-inline">1</strong>. This is a very powerful operation, and you can use it to write <span class="No-Break">compact code.</span></p>&#13;
			<p lang="en-GB">Sadly, it appears that conditional execution is a clever technique whose time has passed. It’s not a cost-effective operation today. Conditional execution reduces the number of branches in a program and the number of clock cycles required to execute a program. Advances in computer technology have made conditional execution redundant in new <span class="No-Break">CPU designs.</span></p>&#13;
			<p lang="en-GB">In the next chapter, we will look at the ARM’s addressing modes – one of the highlights of <span class="No-Break">this processor.</span></p>&#13;
		</div>&#13;
	</div></body></html>