<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-168" class="chapter-number" lang="en-GB"><a id="_idTextAnchor184"/>10</h1>&#13;
			<h1 id="_idParaDest-169" lang="en-GB"><a id="_idTextAnchor185"/>A Closer Look at the ARM</h1>&#13;
			<p lang="en-GB">We have already introduced the ARM processor. Now, we will look at it in a little more depth. The ARM family of processors is probably the best vehicle to teach computer architecture. In particular, it is very easy to learn because of its streamlined instruction set and simple register model compared to many other microprocessors.Moreover, the ARM has some very interesting features, such as predicated execution when an instruction can either be executed or ignored, depending on the processor status. The introduction of the Raspberry Pi in computer education could not have happened at a better time because it enables students to get hands-on experience of the remarkable ARM architecture.</p>&#13;
			<p lang="en-GB">In this chapter, we will do the following:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">Introduce the ARM</li>&#13;
				<li lang="en-GB">Describe its register set</li>&#13;
				<li lang="en-GB">Examine variations in add and subtract operations</li>&#13;
				<li lang="en-GB">Cover the ARM’s multiplication instruction</li>&#13;
				<li lang="en-GB">Introduce logical operations and shifting operations</li>&#13;
				<li lang="en-GB">Explain flow control and the ARM’s conditional execution</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-170" lang="en-GB"><a id="_idTextAnchor186"/>Technical requirements</h1>&#13;
			<p lang="en-GB">Because this chapter is an extension of the previous chapter, no new hardware or software is required. All you need is Raspberry Pi, configured as a general-purpose computer. The only software needed is a text editor to create assembly language programs and the GCC assembler and loader.</p>&#13;
			<h1 id="_idParaDest-171" lang="en-GB"><a id="_idTextAnchor187"/>Introducing the ARM</h1>&#13;
			<p lang="en-GB">The ARM processor family has been <a id="_idIndexMarker641"/>a remarkable success story, not least because so many other microprocessors became popular for a few years and then declined into obscurity (e.g., 6502, Cyrix 486, and Itanium). At the time of its release, the Motorola 68K was widely thought of as far more elegant and powerful than Intel’s 8086. Indeed, the 68K was a true 32-bit machine at a time when the 8086 was a 16-bit machine. The 68K was adopted by Apple’s Mac, the Atari, and Amiga computers – all major players in the home computer market. How could Intel’s humble 8086 possibly ever have competed? Well, IBM selected the 8086 family for its new personal computer and the rest is history. Motorola later dropped out of the semiconductor business.</p>&#13;
			<p lang="en-GB">In the late 1980s, a new company, Advanced RISC Machines, was founded to create high-performance microprocessors. The architecture of their machines followed the register-to-register paradigm of the RISC architecture, rather than Intel and Motorola’s more complicated CISC instruction sets. The ARM was born.</p>&#13;
			<p lang="en-GB">Not only has ARM survived when many of the earlier microprocessors failed – it has also prospered and successfully targeted the world of mobile devices, such as netbooks, tablets, and cell phones. ARM incorporates some interesting architectural features that have given it a competitive advantage over its rivals.</p>&#13;
			<p lang="en-GB">ARM is, in fact, a <em class="italic">fabless</em> company – that is, it develops the architecture of computers and allows other companies to manufacture those computers. The term <em class="italic">fabless</em> is derived from fab (short for fabrication).</p>&#13;
			<p lang="en-GB">Before we describe ARM’s instructions, we will discuss its register set because all ARM data-processing instructions operate on the contents of its registers (a prime feature of the RISC computer).</p>&#13;
			<p lang="en-GB">Because the ARM’s architecture has developed <a id="_idIndexMarker642"/>over the years, and because there are different versions of the ARM architecture in use, a teacher of it has a problem. Which version should be used to illustrate a computer architecture course? In this chapter, we will use the ARMv4 32-bit architecture, which has 32-bit instructions. Some ARM processors can switch between 32-bit and 16-bit instruction states (the 16-bit state is called the <em class="italic">Thumb</em> state). The Thumb state is intended to run very compact code in embedded control systems. We will not cover the Thumb state here.</p>&#13;
			<p lang="en-GB">The ARM found in Raspberry Pi 4 has a 64-bit architecture that is very different from earlier 32-bit ARMs. However, since the 32-bit ARM architecture is used in most teaching texts and Raspberry Pi 4 supports it, we will use the 32-bit architecture here. In order to be consistent with other books using the ARM to illustrate computer architecture, most of the material here is based on ARMv4T 32-bit architecture. ARM’s 32-bit architectures are now referred to by the term AArch32, distinguishing them from ARM’s new 64-bit architecture, AArch64.</p>&#13;
			<h1 id="_idParaDest-172" lang="en-GB"><a id="_idTextAnchor188"/>Overview of the ARM’s architecture</h1>&#13;
			<p lang="en-GB">The ARM’s architecture is interesting <a id="_idIndexMarker643"/>because it has elements of both the conventional CISC architecture such as Motorola’s 68K and Intel’s 32/64-bit architectures, together with the more radical streamlined RISC architecture of processors such as MIPS and RISC-V.</p>&#13;
			<p lang="en-GB">Here, we will examine the following:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">The ARM’s register set</li>&#13;
				<li lang="en-GB">Arithmetic instructions</li>&#13;
				<li lang="en-GB">Special addition and subtraction instructions</li>&#13;
				<li lang="en-GB">Multiplication and ARM’s multiplication and addition instruction</li>&#13;
				<li lang="en-GB">Bitwise instruction</li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">Shifting operations</li>&#13;
			</ul>&#13;
			<p lang="en-GB">We don’t cover data movement operations in detail here. We have already encountered the <code>mov</code> operation that can be used to load a literal into a register – for example, <code>mov r1,#12</code>. Similarly, the <code>str</code> and <code>ldr</code> instructions load a register from memory and store a register in memory, respectively. A typical example is <code>ldr r4,[r5]</code> and <code>str r0,[r9]</code>. These two instructions use <em class="italic">register indirect addressing</em>, and we will devote the next chapter to them.</p>&#13;
			<h2 id="_idParaDest-173" lang="en-GB"><a id="_idTextAnchor189"/>Arm register set</h2>&#13;
			<p lang="en-GB">Unlike the popular MIPS processor with its 32 general-purpose registers, ARM has just 16 registers, <code>r0</code> to <code>r15</code>, and a <em class="italic">status register</em>. Remarkably, the ARM’s registers are <a id="_idIndexMarker644"/>not all the same – that is, some are special-purpose registers. <em class="italic">Figure 10</em><em class="italic">.1</em> illustrates the ARM’s register set.</p>&#13;
			<div>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_10.01_B19624.jpg" alt="Figure 10.1 – The ARM’s register set" width="1788" height="868"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – The ARM’s register set</p>&#13;
			<p lang="en-GB">Fourteen registers, <code>r0</code> to <code>r13</code>, are indeed general-purpose in the sense that they all behave in the same way – for example, anything you can do with <code>r5</code>, you can do with <code>r10</code>. Registers <code>r13</code>, <code>r14</code>, and <code>r15</code> are not general-purpose because they have additional functions.</p>&#13;
			<p lang="en-GB">Strictly speaking, <code>r13</code> is a general-purpose register, but by convention, it’s reserved for use as a stack pointer. If you work on a project in a team, you should respect this convention. Otherwise, you do not have to follow the convention, and you can use <code>r13</code> in any way you wish.</p>&#13;
			<p lang="en-GB">Register <code>r14</code> has an additional function imposed by the hardware. It is a <em class="italic">link register</em> and can be written <code>lr</code> or <code>r14</code> in assembly programs. The ARM has an instruction, branch with link (<code>bl)</code>, that lets you jump to a point in the program (i.e., a branch) and save the address of the next instruction in sequence in the link register. In other words, the instruction saves the next <code>pc</code> address in <code>r14</code> and then jumps to the specified target. Later, you can return by copying the address in the link register to the pc with <code>mov pc,lr</code> or <code>mov 15,r14</code>. This is a faster subroutine call and return mechanism than the conventional <code>bsr</code> and <code>rts</code> pair of instructions that use a stack to store the return address.</p>&#13;
			<p lang="en-GB">Register <code>r15</code> is a truly different register from all the others and can never be used as a general-purpose register (even though you can apply some instructions to it as if it were general-purpose). Register <code>r15</code> is the <em class="italic CharOverride-1" lang="en-US" xml:lang="en-US">program counter</em> that contains the address of the next instruction to be executed and is normally written <code>pc</code> rather than <code>r15</code> in ARM code. Putting the program <a id="_idIndexMarker645"/>counter in a general register is very rare in the world of computer architecture. Note that, in practice, <code>pc</code> contains an address that is 8 bytes ahead of the current <code>pc</code> because of the way that the ARM is internally organized.</p>&#13;
			<p lang="en-GB">We will look at the ARM’s data processing instructions first, rather than the data movement operations. We take this approach because data movement instructions are more complicated, since they involve complex addressing modes.</p>&#13;
			<h2 id="_idParaDest-174" lang="en-GB"><a id="_idTextAnchor190"/>Arithmetic instructions</h2>&#13;
			<p lang="en-GB">Let’s begin with ARM’s arithmetic instructions <a id="_idIndexMarker646"/>that perform operations on <a id="_idIndexMarker647"/>data representing <em class="italic">numeric quantities</em>:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">Addition          <code>add</code></li>&#13;
				<li lang="en-GB">Subtraction        <code>sub</code></li>&#13;
				<li lang="en-GB">Comparison        <code>cmp</code> (technically, <code>compare</code> is not a data-processing operation)</li>&#13;
				<li lang="en-GB">Multiplication        <code>mul</code></li>&#13;
				<li lang="en-GB">Shifting            <code>lsl, lsr, asl, asr, </code><code>ror, rrx</code></li>&#13;
			</ul>&#13;
			<h3 lang="en-GB">Addition, subtraction, and comparison</h3>&#13;
			<p lang="en-GB">Addition is a simple operation that adds two operands to generate a sum and a carryout. In decimal arithmetic, adding 4 + 5 gives 9. Adding 4 + 9 gives 13 ; that is, a result of 3 and a carry-out of 1. Computers deal with this by storing the carryout in the carry bit. ARM instructions <a id="_idIndexMarker648"/>require you to add the suffix <code>s</code> if you wish to update condition code flags after an operation – that is, you need to write <code>add</code>s <code>r1,r2,r3</code>.</p>&#13;
			<p lang="en-GB">The ARM is a 32-bit machine. How do you add 64-bit numbers? Suppose that two 64-bit numbers are <code>A</code> and <code>B</code>, where AL is the lower-order 32 bits of A, and AU is the upper-32 bits of <code>A</code>. Similarly, BL is the lower-order 32 bits of <code>B</code>, and BU is the upper-32 bits of <code>B</code>.</p>&#13;
			<p lang="en-GB">We first add AL to BL and record the carry. Then we <a id="_idIndexMarker649"/>add together AU and BU, plus any carry generated from the addition of the lower-order pair. In ARM assembler language, this is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
add<strong class="bold">s</strong> CL,AL,BL         @ CL,AL,BL are registers, each holding the 32 lower-order bits of a word&#13;
adc  CU,AU,BU         @ Add the two upper-order 32-bit registers together with the carry bit</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The second addition, <code>adc</code>, means, <em class="italic">add with carry</em>, and adds any carry <a id="_idIndexMarker650"/>out from the previous addition. We’ve used CL, AL, BL, and so on, rather than <code>r1</code>, <code>r2</code>, and <code>r3</code> to demonstrate that these are upper- and lower-order parts of a number distributed between two registers. We can extend this principle to perform extended-precision arithmetic with integers of any length.</p>&#13;
			<p lang="en-GB">The ARM also provides a simple subtract operation, <code>sub</code>, together with a <code>sbc</code> or <em class="italic">subtract with carry</em> instruction to support extended-precision subtraction, which operate like the corresponding <code>adc</code>.</p>&#13;
			<p lang="en-GB">As well as <code>sub</code> and <code>sbc</code>, the ARM has a <em class="italic">reverse</em> subtract operation, where <code>rsc </code>r1, <code>r2</code>, <code>r3</code> perform the subtraction of <code>r2</code> from <code>r3</code>. This instruction may seem strange and unnecessary because you can simply reverse the order of the second two registers, can’t you? However, ARM lacks a <em class="italic">negation</em> instruction that subtracts a number from zero ; for example, the negative of <code>r0</code> is <code>0 – [r0]</code>. The reverse subtraction operation can be used to do this because <code>rsb </code>r1<code>,r1,#0</code> is equivalent to <code>neg r1</code>.</p>&#13;
			<p lang="en-GB">A comparison operation compares two values <a id="_idIndexMarker651"/>by subtracting one from the other – for example, we can compare 3 with 5. Suppose the two elements being compared are <code>A</code> and <code>B</code>. If you perform <code>A</code> – <code>B</code> and the answer is zero, then <code>A</code> and <code>B</code> are equal. If the result is positive, <code>A &gt; B</code>, and if it’s negative, <code>A &lt; B</code>. A comparison is a subtraction where you don’t care about the result ; only its sign, whether it’s zero, whether a carry was generated. Consider the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
mov <strong class="bold">r1</strong>,#6                @ Load r1 with 6&#13;
mov <strong class="bold">r2</strong>,#8                @ Load r2 with 8&#13;
cmp <strong class="bold">r1</strong>,r2                @ Compare r1 and r2</pre>&#13;
			<p lang="en-GB">The operation <code>cmp</code> r1,<code>r2</code> evaluates <code>[r1] – [r2]</code> and updates the <code>Z</code>, <code>C</code>, <code>N</code>, and <code>V</code> bits. We can then perform operations such as <code>beq next</code> that branch to label <code>next</code> if <code>r1</code> and <code>r2</code> are equal. We said that you need to append <code>s</code> to update condition codes. Comparison <a id="_idIndexMarker652"/>operations are exceptions because setting condition codes is what they do. You can write <code>cmps</code> if you want, since it’s the same as <code>cmp</code>.</p>&#13;
			<p lang="en-GB">There are two types of integer comparison. Consider (in 8 bits) the <code>A = 00000001</code> and <code>B = 11111111</code> binary values. Which is the larger? You might think that it’s <code>B</code>, since <code>B = 255</code> and <code>A = 1</code>. That’s true. However, if these were assigned <code>2</code>s complement numbers, <code>A</code> would be <code>1</code> and <code>B</code> would be <code>-1</code>; therefore, <code>A</code> is the larger. Like all processors, ARM provides two <a id="_idIndexMarker653"/>sets of branch operations, one for unsigned arithmetic and one for signed arithmetic. A programmer must select the appropriate branch depending on whether they use signed or unsigned arithmetic. The simulators we constructed earlier all provided unsigned branches only.</p>&#13;
			<h3 lang="en-GB">Multiplication</h3>&#13;
			<p lang="en-GB">ARM’s multiply instruction, <code>mul </code>Rd<code>,Rm,Rs</code>, generates the low-order 32 bits of the 64-bit product <code>Rm</code> <code>x Rs</code>. When using <code>mul</code>, you should ensure that the result <a id="_idIndexMarker654"/>does not go out of range because multiplying two m-bit numbers yields a <code>2m</code>-bit product. This instruction doesn’t let you multiply the contents of a register by a constant – that is, you can’t perform <code>mul</code> r9<code>,r4,#14</code>. Moreover, you can’t use the <em class="italic">same</em> register to specify both the Rd destination and the <code>Rm</code> operand. These restrictions are due to the implementation of this instruction in hardware. The following code demonstrates the use of ARM’s multiplication to multiply 23 by 25:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
       mov   <strong class="bold">r4</strong>,#23      @ Load register r4 with 23&#13;
       mov   <strong class="bold">r7</strong>,#25      @ Load register r7 with 25</pre>&#13;
			<pre class="source-code">       mul   <strong class="bold">r9</strong>,r4,r7    @ r9 is loaded with the low-order 32-bit product of r4 and r7</pre>&#13;
			<p lang="en-GB">We’ve already seen that ARM has a <em class="italic">multiply and accumulate instruction</em>, <code>mla</code>, with a <em class="italic">four-operand</em> format <code>mla</code> Rd,<code>Rm</code>,<code>Rs</code>,<code>Rn</code>, whose RTL definition is <code>[Rd]</code> ← <code>[Rm]</code> x <code>[Rs] + [Rn]</code>. The 32-bit by 32-bit multiplication is truncated to the lower-order 32 bits. Like the multiplication, <code>Rd</code> must not be the same as <code>Rm</code> (although this restriction was removed in the ARMv6 and later architectures).</p>&#13;
			<p lang="en-GB">ARM’s <em class="italic">multiply and accumulate</em> instruction supports the calculation of an <em class="italic">inner-product</em> by performing one multiplication and addition per instruction. The inner-product is used in multimedia applications – for example, if vector a consists of the <em class="italic">n</em> components a1, a2, … an and vector b consists of the <em class="italic">n</em> components b1, b2, ... , bn, then the <em class="italic">inner product</em> of a and b is the scalar value s = <strong class="bold">a·b</strong> = a1·b1 + a2·b2 + … + an·bn.</p>&#13;
			<p lang="en-GB">We will now demonstrate an application of the <a id="_idIndexMarker655"/>multiply and accumulate operations. Although we have not yet covered the ARM’s addressing modes, the following example includes the instruction <code>ldr </code>r0<code>,[r5],#4</code> that loads register <code>r0</code> with an element from the array pointed at by register <code>r5</code>, and then it updates <code>r5</code> to point at the next element (4 bytes on):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
       mov   <strong class="bold">r4</strong>,#n        @ r4 is the counter&#13;
       mov   <strong class="bold">r3</strong>,#0        @ Clear the inner product&#13;
       adr   <strong class="bold">r5</strong>,V1        @ r5 points to v1&#13;
       adr   <strong class="bold">r6</strong>,V2        @ r6 points to v2&#13;
Loop:  ldr   <strong class="bold">r0</strong>,[r5],#4   @ REPEAT read a component of v1 and update the pointer&#13;
       ldr   <strong class="bold">r1</strong>,[r6],#4   @ Get the second element in the pair from v2&#13;
       mla   <strong class="bold">r3</strong>,r0,r1,r3  @ Add new product term to the total (r3 = r3 + r0·r1)&#13;
       subs  <strong class="bold">r4</strong>,r4,#1     @ Decrement  the counter and set the (CCR)&#13;
       bne   Loop         @ UNTIL all done</pre>&#13;
			<p lang="en-GB">What about division? The ARMv4 architecture lacks a division instruction as part of its basic architecture (some variants of ARM such as the ARMv7 architecture do incorporate division). If you wish to do division on the ARM, you have to write a short program that uses an iterative loop involving shifting and subtracting to perform the division (rather like pencil and paper long division).</p>&#13;
			<h3 lang="en-GB">Bitwise logical operations</h3>&#13;
			<p lang="en-GB">The ARM provides the basic <code>AND</code>, <code>OR</code>, <code>NOT</code>, and <code>EOR</code> (exclusive or) bitwise logical operations supported by most processors. These are used to set, clear, and toggle <a id="_idIndexMarker656"/>the individual bits of a word, as we already saw when assembling instructions. There is also an unusual <em class="italic">bit clear</em> operation, <code>bic</code>, that <code>AND</code>s its first operand with the <em class="italic">complement of the corresponding bits</em> of its second operand – that is, ci = ai ∧ bi.</p>&#13;
			<p lang="en-GB">The ARM’s NOT operation is written as <code>mvn</code> rd,rs. This move instruction negates, inverts the bits of the source register and copies them to the destination register.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The following examples illustrate logical operations on r1 = 110010102 and r0 = 000011112:</p>&#13;
			<table id="table001-8" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><strong class="bold">Logical instruction</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><strong class="bold">Operation</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><strong class="bold">Final value </strong><strong class="bold">in r2</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><code>and </code>r2<code>,r1,r0</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">11001010 ∧ 00001111</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">00001010</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><code>or  </code>r2<code>,r1,r0</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">11001010 + 00001111</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">11001111</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><code>mvn </code>r2<code>,r1</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">īōōīōīō￼</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">00110101</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><code>eor </code>r2<code>,r1,r0</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">11001010 ⊕ 00001111￼</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">11000101</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB"><code>bic </code>r2<code>,r1,r0</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">11001010 ∧ ōōōōīīīī</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">11000000</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="AlanGeneral" lang="en-GB">When you design instruction sets, one of the major tasks is to construct binary codes for instructions. These operations make it easy to implement the manipulation of bits. For example, suppose variable <code>sR1</code> specifies source register 1, and <code>sR2</code> specifies source register 2, and we have to construct a 16-bit binary code, <code>C</code>, with the format <code>xxxxx</code>aaa<code>xx</code>bbb<code>xxx</code>. Source bits <code>a</code> are in <code>sR1</code> and source bits <code>b</code> are in <code>sR2</code> in the lower-order three bits.</p>&#13;
			<p lang="en-GB">We must insert the bits of <code>sR1</code> and <code>sR2</code> at the appropriate <a id="_idIndexMarker657"/>places without changing any other bits of <code>C</code>. In Python, we can do this with the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
C = C &amp; 0b11111<strong class="bold">000</strong>11<strong class="bold">000</strong>111       # Clear the two fields for sR1 and sR2&#13;
sR1 = sR1 &lt;&lt; 8                   # Move sR1 into position by shifting left 8 times&#13;
C = C | sR1                      # Insert sR1&#13;
sR2 = sR2 &lt;&lt; 3                   # Move sR2 into position by shifting left 3 times&#13;
C = C | sR2                      # Insert sR2</pre>&#13;
			<p lang="en-GB">We can readily translate this into ARM assembly language using <code>AND</code>, <code>OR</code>, and shift operations. Assume <code>sR1</code> is in <code>r1</code>, <code>sR2</code> is in <code>r2</code>, and <code>C</code> is in register <code>r0</code>. Moreover, assume that the register bits are already in place in their respective registers:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
   ldr r3,=0b1111100011000111    @ Load r3 with 1111100011000111 mask&#13;
   and r0,r0,r3                  @ Mask r0 to get xxxxx000xx000xxx&#13;
   or  <strong class="bold">r0</strong>,r0,r1                  @ Insert r1 to get xxxxxaaaxx000xxx&#13;
   or  <strong class="bold">r0</strong>,r0,r2                  @ Insert r2 to get xxxxxaaaxxbbbxxx</pre>&#13;
			<h3 lang="en-GB">Shift operations</h3>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Python can shift bits left using the <code>&lt;&lt;</code> operator, or right using the <code>&gt;&gt;</code> operator. ARM’s assembly language lacks explicit instructions such as <code>LSR</code> or <code>LSL</code> that shift bits right or left. However, it does have pseudo-instructions such as <code>lsl</code> r1,<code>r3</code>,<code>#4</code> that shift the <a id="_idIndexMarker658"/>contents of <code>r3</code> four places left, transferring the result to <code>r1</code>. The ARM’s <em class="italic">actual</em> approach to shifting is rather more unusual, complicated, and <em class="italic">versatile</em>.</p>&#13;
			<p lang="en-GB">The ARM includes shifting as part of conventional data operations. Consider <code>add </code>r1<code>,r2,r3</code>, which adds <code>r3</code> to <code>r2</code> and puts the result in <code>r1</code>. ARM allows you to shift the second operand <em class="italic">before</em> it is used in a data processing operation. You can write <code>add r1,r2,r3, lsl r4</code> (see <em class="italic">Figure 10</em><em class="italic">.2</em> for an explanation of the second destination field).</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_10.02_B19624.jpg" alt="Figure 10.2 – The structure of a dynamic shift operation" width="715" height="154"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – The structure of a dynamic shift operation</p>&#13;
			<p lang="en-GB">This instruction takes the second source operand, r3, and performs a logical shift left. The number of left shifts is determined by the contents of r4. You can also implement a fixed shift using a constant with the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
add r1,r2,r3,lsl #3</pre>&#13;
			<p lang="en-GB">In this case, register r3 is shifted left by three bits before it is added to <code>r2</code>. A shift is called <em class="italic">dynamic</em> if the number of shifts is specified by a register, since you can <a id="_idIndexMarker659"/>change the number of shifts at runtime by changing the shift count. If the number of shifts is given by a literal (constant), it cannot be changed at runtime. This is a <em class="italic">static</em> shift.</p>&#13;
			<p lang="en-GB">The ARM’s shift combines a data-processing operation with shifting (speeding up data processing), and it lets you specify four registers in an instruction. What do you do if you require a plain vanilla shift without including a data-processing instruction? You can use the <code>MOV</code> instruction, such as the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
mov <strong class="bold">r1</strong>,r1,lsr #1         @ Shift contents of register r1 a single bit place right before moving</pre>&#13;
			<p lang="en-GB">Today, ARM assemblers let you write the pseudo-instruction <code>lsl </code>r1<code>,r3,#4</code> and automatically substitute the move instruction <code>mov </code>r1<code>,r1,lsr #4</code>, using a shifted second operand.</p>&#13;
			<h4 lang="en-GB">Shift types</h4>&#13;
			<p lang="en-GB">All shifts look the same from the middle of a string of bits – that is, the bits move one (or more) places left or right. However, what happens to <a id="_idIndexMarker660"/>the bits at the end? When bits are shifted in a register, at one end, a bit will drop out. That bit can disappear into oblivion, go to the carry bit, or move around to the other end in a circular fashion. At the end where a bit is vacated, the new bit can be set to <code>0</code>, <code>1</code>, the same as the carry bit, or the bit that fell off the other end.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The variations in the way that the bit shifted in is treated by computers correspond to specific types of shift – <em class="italic">logical</em>, <em class="italic">arithmetic</em>, <em class="italic">rotate</em>, and <em class="italic">rotate through carry</em>. Let’s look at some shift operations (<em class="italic">table 10.1</em>):</p>&#13;
			<table id="table002-6" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Source string</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Direction</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Number </strong><strong class="bold">of shifts</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Destination string</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">0<code>110011111010111</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Left</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>110011111010111</code><em class="italic">0</em></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">01<code>10011111010111</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Left</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>10011111010111</code><em class="italic">00</em></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">011<code>0011111010111</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Left</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">3</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>0011111010111</code><em class="italic">000</em></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>011001111101011</code>1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Right</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><em class="italic">0</em><code>011001111101011</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>01100111110101</code>11</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Right</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><em class="italic">00</em><code>01100111110101</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>0110011111010</code>111</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Right</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">3</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><em class="italic">000</em><code>0110011111010</code></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Figure" lang="en-GB">Table 10.1 – ARM's logical shift operations</p>&#13;
			<p lang="en-GB">The bits in the destination string in italic are the bits shifted in, and the bits in the source string in bold are the bits lost (dropped) after the shift. This type of shift is a <em class="italic">logical </em>shift:</p>&#13;
			<ul>&#13;
				<li lang="en-GB"><strong class="bold">Logical shift</strong>: The bits shifted are <a id="_idIndexMarker661"/>moved one or more places left or right. Bits fall off at one end and zeros enter at the other end. The last bit shifted out is <a id="_idIndexMarker662"/>copied to the carry flag. <em class="italic">Figure 10</em><em class="italic">.3</em> illustrates the logical shift left and the logical shift right.</li>&#13;
			</ul>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_10.03_B19624.jpg" alt="Figure 10.3 – Logical shifts" width="1115" height="572"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Logical shifts</p>&#13;
			<ul>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB"><strong class="bold">Arithmetic shift</strong>: This arithmetic shift <a id="_idIndexMarker663"/>treats the number <a id="_idIndexMarker664"/>being shifted as a signed twos complement value. An arithmetic shift left is the same as a logical shift for left shifts. For right shifts, the most-significant bit is propagated right. This shift treats the operand as a signed value, which is either divided by two (shift right one bit) or multiplied by two (shift left one bit), as <em class="italic">Figure </em><em class="italic">10</em><em class="italic">.4</em> demonstrates.</li>&#13;
			</ul>&#13;
			<p lang="en-GB">The purpose of an arithmetic shift is to preserve the sign of a twos complement number, when it takes part in a shifting operation that represents division by the power of 2. For example, the 8-bit value <code>10001111</code> becomes <code>01000111</code> when shifted right <em class="italic">logically</em>, but 11<code>000111</code> when shifted right <em class="italic">arithmetically</em>.</p>&#13;
			<p lang="en-GB"><em class="italic">Figure 10.4</em> illustrates the arithmetic shift left and shift right. The ARM has an <code>asr</code> operation but not <code>asl</code>, because <code>asl</code> is identical to <code>LSL</code> – that is, you use a logical shift left because it is exactly the same as asl.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_10.04_B19624.jpg" alt="Figure 10.4 – Arithmetic shifts" width="1294" height="686"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Arithmetic shifts</p>&#13;
			<ul>&#13;
				<li lang="en-GB"><code>01101110</code> being rotated left, one bit at a time:</li>&#13;
			</ul>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_10.05_B19624.jpg" alt="Figure 10.5 – Example of successive rotate operations" width="504" height="398"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 10.5 – Example of successive rotate operations</p>&#13;
			<p lang="en-GB">The rotate operation is <em class="italic">non-destructive</em> – that is, no bit is lost or changed by the operation. It is very useful in operations such as counting the number of <code>1</code>s in a bit string. <em class="italic">Figure 10.6</em> illustrates the <em class="italic">rotate</em> operation. Note that the ARM does <em class="italic">not</em> have a rotate right instruction – that is, there is no <code>ror</code>. Since rotate is a circular operation, shifting an <em class="italic">m</em>-bit word <em class="italic">p</em> places right is achieved by shifting <code>32-p</code> places left; consequently, <code>ror r0,r1,#4</code> is achieved by <code>rol r0,r1,#28</code>.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_10.06_B19624.jpg" alt="Figure 10.6 – Rotate operations (ARM does not implement ROL)" width="1093" height="560"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Rotate operations (ARM does not implement ROL)</p>&#13;
			<p lang="en-GB">A variation of the <a id="_idIndexMarker667"/>rotate operation is the <em class="italic">rotate through carry</em>, where the carry bit is considered as part of the word being shifted – that is, an <em class="italic">n</em>-bit word becomes an <em class="italic">n+1</em> bit word. <em class="italic">Figure 10.7</em> demonstrates a rotate through carry operation, where the carry <a id="_idIndexMarker668"/>shifted out is copied into the carry bit, and the old value of the carry bit becomes the new bit shifted in. This operation is used in chained arithmetic (it’s the analog of the <em class="italic">add with carry and subtract with borrow</em> operations).</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_10.07_B19624.jpg" alt="Figure 10.7 – Rotate through carry" width="984" height="303"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Rotate through carry</p>&#13;
			<p lang="en-GB">ARM implements only the following five shifts (a programmer can synthesize the rest):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
lsl     logical shift left&#13;
lsr     logical shift right&#13;
asr     arithmetic shift right&#13;
ror     rotate right</pre>&#13;
			<pre class="source-code">rrx     rotate right through carry (1-bit shift only)</pre>&#13;
			<p lang="en-GB"><code>rrx</code>, which rotates bits right through carry (<em class="italic">Figure 10.7</em>), behaves differently from other shifts. First, only one direction of shift is permitted; there is no left shift through carry. Second, the ARM supports both <em class="italic">static</em> and <em class="italic">dynamic </em>shifts for all other shift operations, whereas <code>rrx</code> allows only one single shift.</p>&#13;
			<p lang="en-GB">Although there is no rotate left operation, you can readily implement it by means of a rotate right operation. The following example demonstrates the rotation, both left and right, of a 4-bit value. After four rotations, the number is unchanged. As you can see, there is symmetry between left and right rotations. For a 32-bit value, an <em class="italic">n</em>-bit shift left is identical to a 32-<em class="italic">n</em> bit shift right:</p>&#13;
			<table id="table003-4" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1" colspan="2">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate right </p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1" colspan="2">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate left</p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">1101</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Start</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">1101</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Start</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">1110</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate right 1</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">1011</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate left 1</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">0111</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate right 2</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">0111</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate left 2</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">1011</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate right 3</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">1110</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate left 3</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">1101</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate right 4</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">1101</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="AlanGeneral" lang="en-GB">Rotate left 4</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Figure" lang="en-GB">Table 10.2 - Comparing successive left and right rotates</p>&#13;
			<p lang="en-GB">Consider <code>adcs </code>r0,<code>r0</code>,<code>r0</code> (add with carry and set status flags). This adds the contents of <code>r0</code> to the contents of <code>r0</code>, plus the carry bit, to generate <code>2 x [r0] + C</code>. Shifting left is equivalent to multiplying by 2. Moving the carry bit into the least-significant <a id="_idIndexMarker669"/>position is equivalent <a id="_idIndexMarker670"/>to adding the carry bit to get <code>2 x [r0] + C</code>. Appending <code>S</code> to the instruction forces the <code>CCR</code> to be updated, which ensures that any carryout is loaded into the C-bit. Consequently, <code>adcs </code>r0,<code>r0</code>,<code>r0</code> and <code>rlx</code> r0 are equivalent.</p>&#13;
			<h4 lang="en-GB">Using shift operations to merge data</h4>&#13;
			<p lang="en-GB">In the following example, we extract the <a id="_idIndexMarker671"/>least-significant byte from each of the three registers and put them together in a new word. The literals are in a hexadecimal format. Assume that the registers are, initially, as follows:</p>&#13;
			<ul>&#13;
				<li lang="en-GB"><code>r1</code> = <code>XXXXXX</code>AA   <code>r1</code> is source 1, the Xs represent don’t care values</li>&#13;
				<li lang="en-GB"><code>r2</code> = <code>XXXXXX</code>BB   <code>r2</code> is source 2</li>&#13;
				<li lang="en-GB"><code>r3</code> = <code>XXXXXX</code>CC   <code>r3</code> is source 3</li>&#13;
				<li lang="en-GB"><code>r4</code> = <code>00</code>CCBBAA   <code>r4</code> is the final result</li>&#13;
			</ul>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      mov <strong class="bold">r4</strong>,#0                @ Clear r4&#13;
      and <strong class="bold">r1</strong>,r1,#0x000000FF    @ Clear r1 except least-significant byte&#13;
      and <strong class="bold">r2</strong>,r2,#0x0000FF00    @ Clear r2 except second byte&#13;
      and <strong class="bold">r3</strong>,r2,#0x00FF0000    @ Clear r3 except third byte&#13;
      or  <strong class="bold">r4</strong>,r4,r1             @ Copy r1 to r4. No shifting&#13;
      or  <strong class="bold">r4</strong>,r4,r2 lsl #8      @ Copy r2 to r4. Shifting to second byte</pre>&#13;
			<pre class="source-code">      or  <strong class="bold">r4</strong>,r4,r3 lsl #16     @ Copy r3 to r4. Shifting to third byte</pre>&#13;
			<p lang="en-GB">The preceding code is a brute-force approach. A better alternative is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      and <strong class="bold">r4</strong>,r1,#0x000000FF    @ Clear r4 and insert r1 0x000000AA&#13;
      or  <strong class="bold">r4</strong>,r4,r2 lsl #8      @ Insert r2, shifting left into place 0xXXXXBBAA&#13;
      or  <strong class="bold">r4</strong>,r4,r3 lsl #16     @ Insert r3, shifting left into place 0xXXCCBBAA&#13;
      and <strong class="bold">r4</strong>,r4,#0x00FFFFFF    @ Insert most-significant byte 0x00CCBBAA</pre>&#13;
			<p lang="en-GB">Now, consider <code>r0 = 0x0000</code>AA, <code>r1 = 0x000000</code>BB, and <code>r2 = 0x12345678</code>. We wish to merge the four registers to get <code>0x</code>AABB<code>5678</code>. We can do this with just three instructions:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
add <strong class="bold">r2</strong>,r1,r2,lsl #16           @ r2 = 567800BB&#13;
add <strong class="bold">r2</strong>,r2,r0,lsl #8            @ r2 = 5678AABB,&#13;
mov <strong class="bold">r2</strong>,r2,ror #16              @ r2 = AABB5678</pre>&#13;
			<p lang="en-GB"><code>add r2,r1,r2,lsl #16</code> adds <code>r1</code> to <code>r2</code> after <code>r2</code> has been shifted left 16 times. The 16-bit left shift moves the lower-order 16-bits of <code>r2</code> into the upper-order 16-bits, and it clears the lower-order 16 bits by shifting in zeros. We’ve preserved the old lower-order half of <code>r2</code>, and we’ve cleared the new lower-order 16 bits ready to insert the bytes from <code>r0</code> and <code>r1</code>. add r2<code>,r2,r0,lsl #8</code> inserts the low-order byte of <code>r0</code> into bits 8 to 15 of <code>r2</code>, since <code>r0</code> is first shifted left by 8 bits. Since zeros are shifted into <code>r0</code>, this operation doesn’t affect bits 0 to 7 of <code>r2</code>. Executing <code>mov </code>r2<code>,r2,ror #16</code> performs a 16-bit rotation.</p>&#13;
			<p lang="en-GB">The next example of shifting demonstrates how we can implement <code>if x &lt; 0: x = 0</code>. This construct sets the <code>x</code> variable to zero if <code>x</code> is negative (i.e., <code>msb</code> is <code>1</code>); otherwise, <code>x</code> is unchanged. The ARM code is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
bic r0,r0,r0,asr #31</pre>&#13;
			<p lang="en-GB">The arithmetic shift right <a id="_idIndexMarker672"/>propagates the sign-bit 31 times, leaving <code>0x00000000</code> for a positive number and <code>0xFFFFFFFF</code> for a negative number. The <code>bic</code> operation <code>AND</code>s the first operand and the complement of the second. If <code>r0</code> was positive, all bits are <code>AND</code>ed, with 1 leaving <code>r0</code> unchanged. If <code>r0</code> was negative, the bits are <code>AND</code>ed, with <code>0</code> leaving <code>0</code>. Therefore, a positive <code>x</code> is unchanged and a negative <code>x</code> is set to <code>0</code>.</p>&#13;
			<p lang="en-GB">The next section looks at a class of instruction that does not move data or process data; it determines which instruction will be executed next.</p>&#13;
			<h1 id="_idParaDest-175" lang="en-GB"><a id="_idTextAnchor191"/>Flow control instructions</h1>&#13;
			<p lang="en-GB">Computers execute instructions sequentially unless a branch causes a jump to an out-of-sequence instruction, or the flow of <a id="_idIndexMarker673"/>instructions is interrupted when a subroutine is called. The instruction flow is also changed when an interrupt occurs (we don’t deal with interrupts here).</p>&#13;
			<p lang="en-GB">In this section, we will look at the following:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">Unconditional branches</li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">Conditional branches</li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-176" lang="en-GB"><a id="_idTextAnchor192"/>Unconditional branches</h2>&#13;
			<p lang="en-GB">ARM’s unconditional branch is expressed as <code>b target</code>, where <code>target</code> denotes the <em class="italic">branch target address</em> (the address of the next instruction to be executed). The unconditional <a id="_idIndexMarker674"/>branch forces a jump (branch) from one point in a program to another. It is exactly the <a id="_idIndexMarker675"/>same as the unconditional branch we introduced earlier. The following ARM code demonstrates how the unconditional branch is used:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      ..   do this       @ Some code&#13;
      ..   then that     @ Some other code&#13;
      <strong class="bold">b    Next</strong>          @ Now skip past the next instructions and jump to Next:&#13;
      ..                 @ …the code being skipped past&#13;
      ..                 @ …the code being skipped past&#13;
<strong class="bold">Next:</strong> ..                 @ Target address for the branch, denoted by label Next</pre>&#13;
			<p class="AlanGeneral" lang="en-GB">The ARM’s branch instructions use a 24-bit literal to provide a twos complement relative offset. This is shifted left twice to create a 26-bit <em class="italic">byte</em> offset, which is added to the current program counter to obtain the 32-bit target address. The branch range is 32 MB from the current PC (in either direction). Remember that consecutive instruction addresses differ by four.</p>&#13;
			<h2 id="_idParaDest-177" lang="en-GB"><a id="_idTextAnchor193"/>Conditional branch</h2>&#13;
			<p lang="en-GB">ARM’s conditional branches consist of a mnemonic Bcc and a target address. The subscript defines one of 16 conditions that must <a id="_idIndexMarker676"/>be satisfied for the <a id="_idIndexMarker677"/>branch to be taken. If the condition is <code>true</code>, execution continues at the branch target address. If the condition is not <code>true</code>, the next instruction in sequence is executed. Consider the flowing example in ARM assembly language that implements the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if x == y: y = y + 1&#13;
else:      y = y + 2&#13;
       cmp <strong class="bold">r1</strong>,r2         @ Compare x and y (r1 contains y and r2 contains x)&#13;
       <strong class="bold">bne plus2</strong>         @ If not equal, then branch to the else part&#13;
       add <strong class="bold">r1</strong>,r1,#1      @ If equal, fall through to here and add one to y&#13;
       <strong class="bold">b   leave</strong>         @ Now, skip past the else part&#13;
<strong class="bold">plus2</strong>: add <strong class="bold">r1</strong>,r1,#2      @ ELSE add 2 to y&#13;
leave:  …                @ Continue from here</pre>&#13;
			<p lang="en-GB">The <em class="italic">conditional branch</em> instruction tests flag bits in the processor’s condition code register and then takes the branch if the tested condition is true. Since the condition code register includes a zero bit (<code>Z</code>), negative bit (<code>N</code>), carry bit (<code>C</code>), and overflow bit (<code>V</code>), there are eight conditional branches based on the state of a single bit (four that branch on true and four that branch on <code>false</code>). <em class="italic">Table 10.3</em> defines all the ARM’s conditional branches. Note that there is a branch <em class="italic">always</em> and a branch <em class="italic">never</em> instruction.</p>&#13;
			<p lang="en-GB">Branch instructions can be applied to <em class="italic">signed</em> or <em class="italic">unsigned</em> data. Consider the four-bit values <code>x = 0011</code> and y = 1001. We want to branch if <code>y</code> is greater than <code>x</code>. Using unsigned arithmetic, <code>x = 3</code> and <code>y</code> is <code>9</code>, so y &gt; x. However, if we regard these as signed values, then <code>x = 3</code> and <code>y = -7</code>, so <code>y &lt; x</code>. Clearly, we have to select an unsigned comparison for <a id="_idIndexMarker678"/>unsigned arithmetic and a <a id="_idIndexMarker679"/>signed comparison for signed arithmetic.</p>&#13;
			<table id="table004-2" class="No-Table-Style TableOverride-1">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><strong class="bold CharOverride-6">Encoding</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><strong class="bold CharOverride-6">Mnemonic</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><strong class="bold CharOverride-6">Branch on </strong><strong class="bold CharOverride-6">flag status</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB"><strong class="bold CharOverride-6">Execute </strong><strong class="bold CharOverride-6">on condition</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">0000</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">EQ</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">Z set</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">Equal (i.e., zero)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">0001</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">NE</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">Z clear</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">Not equal (i.e., not zero)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">0010</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">CS or HS</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">C set</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">Unsigned higher or same</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">0011</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">CC or LO</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">C clear</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">Unsigned lower</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">0100</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">MI</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">N set</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">Negative</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">0101</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">PL</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">N clear</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">Positive or zero</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">0110</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">VS</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">V set</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">Overflow</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">0111</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">VC</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">V clear</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">No overflow</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">1000</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">HI</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">C set and Z clear</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">Unsigned higher</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">1001</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">LS</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">C clear or Z set</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">Unsigned lower or same</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">1010</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">GE</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">N set and V set, or N clear and V clear</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">Signed greater or equal</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">1011</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">LT</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">N set and V clear, or N clear and V set</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">Signed less than</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">1100</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">GT</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">Z clear, and either N set and V set, or N clear and V clear</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">Signed greater than</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">1101</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">LE</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">Z set, or N set and V clear, or N clear and V set</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p class="AlanGeneral" lang="en-GB">Signed less than or equal</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="AlanGeneral" lang="en-GB">1110</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="AlanGeneral" lang="en-GB">AL</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="AlanGeneral" lang="en-GB">Unconditional</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="AlanGeneral" lang="en-GB">Always (default)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="AlanGeneral" lang="en-GB">1111</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="AlanGeneral" lang="en-GB">NV</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3"/>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p class="AlanGeneral" lang="en-GB">Never (reserved)</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 10.3 – ARM’s conditional execution and branch control mnemonics</p>&#13;
			<p lang="en-GB">Some microprocessors have <em class="italic">synonyms</em> for conditional branch operations – that is, a branch condition has two mnemonics. For <a id="_idIndexMarker680"/>example, branch on carry set <code>(bcs)</code> can be <a id="_idIndexMarker681"/>written branch on higher or same <code>(bhs)</code>, because <code>C = 1</code> implements the ( <code>&gt;</code> ) operation in unsigned arithmetic. Similarly, <code>bcc</code> can be written branch on lower <code>(blo)</code>, because the carry <a id="_idIndexMarker682"/>clear implements an unsigned comparison that is lower.</p>&#13;
			<p lang="en-GB">One of the best examples of the use of conditional branching is in repetitive structures. Consider the <code>while</code> loop:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Loop:       cmp   <strong class="bold">r0</strong>,#0         @ Perform test at start of loop (exit on zero)&#13;
            <strong class="bold">beq   whileExit</strong>     @ Exit on test true&#13;
            Code  ...           @ Body of the loop&#13;
            b     Loop          @ Repeat WHILE true&#13;
<strong class="bold">whileExit:</strong>  Post-loop code...   @ Exit</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The final section of this chapter looks at ARM’s <em class="italic">conditional execution mechanism</em>, which provides a means of squashing or <em class="italic">annulling</em> instructions – that is, you can choose to run or not run an instruction at runtime. This is a feature found on very, very few processors. However, this mechanism provides the ARM with a very interesting means of speeding execution by creating compact code.</p>&#13;
			<h1 id="_idParaDest-178" lang="en-GB"><a id="_idTextAnchor194"/>Conditional executions</h1>&#13;
			<p lang="en-GB">Here, we will deal with just one topic, conditional executing, and we will demonstrate how you can ignore an instruction if it does not fulfill a <a id="_idIndexMarker683"/>specified criterion (related to the condition control status bits). This mechanism enables programmers to write more compact code.</p>&#13;
			<p lang="en-GB">Consider the <code>add</code> instruction. When the computer reads it from memory, it is executed, exactly like almost every other computer. The ARM is different; each of its instructions is <em class="italic">conditionally executed</em> – that is, an instruction is executed only if a specific condition is met; otherwise, it is bypassed (annulled or squashed). Each ARM instruction is associated with a logical condition (one of the 16 in <em class="italic">Table 10.3</em>). If the stated condition is true, the instruction is executed.</p>&#13;
			<p lang="en-GB">A suffix indicates conditional execution by appending <code>condition</code> – for example, <code>add</code>eq<code> </code>r1<code>,r2,r3</code> specifies that the addition is performed <em class="italic">only if the Z-bit in the CCR is set</em>. The RTL form of this operation is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
IF Z = 1 THEN [r1] ← [r2] + [r3]</pre>&#13;
			<p lang="en-GB">There is, of course, nothing to stop you from combining conditional execution and shifting, since the branch and shift fields of an instruction are independent. You can write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
add<strong class="bold">cc</strong>  <strong class="bold">r1</strong>,r2,r3, lsl r4</pre>&#13;
			<p lang="en-GB">This is interpreted as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
 IF C = 0 THEN [r1] ← [r2] + [r3] x 2[r4].</pre>&#13;
			<p lang="en-GB">To demonstrate the power of conditional execution, consider the following Python statement:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if A == B: C = D – E;</pre>&#13;
			<p lang="en-GB">Translated into ARM code using conditional execution, we can write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      cmp    <strong class="bold">r1</strong>,r2         @ Compare A == B&#13;
      sub<strong class="bold">eq</strong>  <strong class="bold">r3</strong>,r1,r4      @ If (A== B) then C = D - E</pre>&#13;
			<p lang="en-GB">After the test, the operation is either executed or not executed, depending on the result of the test. Now, consider a construct with a compound predicate:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if ((a == b)<strong class="bold">AND</strong>(c == d)): e = e + 1&#13;
      cmp    <strong class="bold">r0</strong>,r1         @ Compare a == b&#13;
      cmp<strong class="bold">eq</strong>  <strong class="bold">r2</strong>,r3         @ If a == b then test c == d&#13;
      add<strong class="bold">eq</strong>  <strong class="bold">r4</strong>,r4,#1      @ If a == b AND c == d THEN increment e</pre>&#13;
			<p lang="en-GB">The first line, <code>cmp </code>r0<code>,r1</code>, compares <code>a</code> and <code>b</code>. The next line, <code>cmp</code>eq<code> </code>r2<code>,r3</code>, executes a conditional comparison only if the result of the first line was true (i.e., <code>a == b</code>). The third line, <code>add</code>eq<code> </code>r4<code>,r4,#1</code>, is executed only if the previous line was true (i.e., <code>c == d</code>) to implement <code>e = e + 1</code>. Without conditional execution, we might write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      cmp    <strong class="bold">r0</strong>,r1           @ Compare a == b&#13;
      bne    Exit            @ Exit if a =! b&#13;
      cmp    <strong class="bold">r2</strong>,r3           @ Compare c == d&#13;
      bne    Exit            @ Exit if c =! d&#13;
      add    <strong class="bold">r4</strong>,r4,#1        @ Else increment e&#13;
Exit</pre>&#13;
			<p lang="en-GB">This conventional approach to compound logical conditions requires five instructions. You can also handle some testing with multiple conditions. Consider the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if (a == b) e = e + 4;&#13;
if (a &lt; b)  e = e + 7;&#13;
if (a &gt; b)  e = e + 12;</pre>&#13;
			<p lang="en-GB">Using the same register assignments as before, we can use conditional <a id="_idIndexMarker684"/>execution to implement this as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      cmp    <strong class="bold">r0</strong>,r1           @ Compare a == b&#13;
      add<strong class="bold">eq</strong>  <strong class="bold">r4</strong>,r4,#4        @ If a == b then e = e + 4&#13;
      add<strong class="bold">le</strong>  <strong class="bold">r4</strong>,r4,#7        @ If a &lt; b  then e = e + 7&#13;
      add<strong class="bold">gt</strong>  <strong class="bold">r4</strong>,r4,#12       @ If a &gt; b  then e = e + 12</pre>&#13;
			<p lang="en-GB">Using conventional non-conditional execution, we would have to write the following to implement this algorithm. This is rather less elegant than the previous version:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
        cmp    <strong class="bold">r0</strong>,r1         @ Compare a == b&#13;
        bne    Test1         @ Not equal try next test&#13;
        add    <strong class="bold">r4</strong>,r4,#4      @ a == b so e = e+4&#13;
        b      ExitAll       @ Now leave&#13;
Test1:  blt    Test2         @ If a &lt; b then&#13;
        add    <strong class="bold">r4</strong>,r4,#12     @ If we are here a &gt; b so e = e + 12&#13;
        b      ExitAll       @ Now leave&#13;
Test2:  add    <strong class="bold">r4</strong>,r4,#7      @ If we are here a &lt; b so e = e + 7&#13;
ExitAll:</pre>&#13;
			<p lang="en-GB">In the next example, we use conditional execution to obtain the absolute value of a signed integer – that is, if the integer is negative, it is converted into the corresponding positive value. For example (in 8 bits), -2 is <code>11111110</code>, which would be converted into <code>00000010</code> (i.e., +2).</p>&#13;
			<p lang="en-GB">We can use ARM’s <code>teq</code> instruction <code>teq</code> is similar to <code>CMP</code>, but <code>teq</code> does not set the <code>V</code> and <code>C</code> flags during the test. <code>teq</code> is useful to test for negative values <em class="italic">because the N-bit is set to 1 if the number tested </em><em class="italic">is negative</em>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
       teq    <strong class="bold">r0</strong>,#0          @ Compare r0 with zero</pre>&#13;
			<pre class="source-code">       rsbmi  <strong class="bold">r0</strong>,r0,#0       @ If negative then 0 - [r0]</pre>&#13;
			<p lang="en-GB">Here, the operand in <code>r0</code> is tested, and the N-bit is set if it is negative and is clear if it is positive. The conditional instruction, <code>rsb</code>mi, is not executed if the tested operand was positive (no change is necessary). If the number was negative, the reverse substation performs <code>0 – r0</code>, which reverses its sign and makes it positive.</p>&#13;
			<h2 id="_idParaDest-179" lang="en-GB"><a id="_idTextAnchor195"/>Sequential conditional execution</h2>&#13;
			<p lang="en-GB">Since a compare or an arithmetic operation updates the <code>C</code>, <code>N</code>, <code>V</code>, and <code>Z</code> bits, we can perform up to four conditional acts after one comparison. The following example <a id="_idIndexMarker685"/>converts uppercase ASCII-encoded characters to lowercase characters – for example, 'M' would be converted to 'm.' Bit 5 of an ASCII character is zero for uppercase letters and one for lowercase letters. Consider the code that first checks whether a character is in the range of 'A' to 'Z' and converts it to lowercase if it is:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      cmp    <strong class="bold">r0</strong>,#'A'         @ Compare character with letter "A"&#13;
      rsb<strong class="bold">ge</strong>s <strong class="bold">r1</strong>,r0,#'Z'      @ Check less than Z if greater than A  Update flags&#13;
      orr<strong class="bold">ge</strong>  <strong class="bold">r0</strong>,r0,#0x20     @ If in "A" to "Z," then set bit 5 to force lowercase</pre>&#13;
			<p lang="en-GB">The first instruction, <code>cmp</code>, checks whether <a id="_idIndexMarker686"/>the character is 'A' or greater by subtracting the ASCII code for 'A.' If it is, the <code>rsb</code>ges checks that the character is less than 'Z.' This test is performed only if the character in <code>r0</code> is greater or equal to 'A.' We use reverse subtraction because we want to test whether the ASCII code for Z minus the ASCII code for the character is positive. If we are in range, the conditional <code>orr</code> is executed, and an uppercase to lowercase conversion is performed by setting bit 5.</p>&#13;
			<p lang="en-GB">In the next chapter, we will look at how operands are specified – that is, we will look at addressing modes.</p>&#13;
			<h1 id="_idParaDest-180" lang="en-GB"><a id="_idTextAnchor196"/>Summary</h1>&#13;
			<p lang="en-GB">In this chapter, we’ve extended our knowledge of the ARM beyond the basic data-processing instructions we encountered in the previous chapter.</p>&#13;
			<p lang="en-GB">We began with the ARM’s register set, which is different from almost every other processor. RISC processors generally have 32 general-purpose registers. The ARM has only 16 registers.</p>&#13;
			<p lang="en-GB">Two of the ARM’s registers have a special purpose. Register <code>r14</code> is called a <em class="italic">link register</em> and is used by the branch with link instructions to restore return addresses. Otherwise, it is a general-purpose register. Register <code>r15</code> is the program counter, and that is very unusual indeed. This makes the ARM a very interesting device because you can change the program counter by operating on <code>r15</code>.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">We also looked at shifting operations. Shifting simply involves bits moving one or more places left or right. However, as bits are in registers or memory locations, a shift involves bits moving into one and dropping out the other. The different types of shifts are determined by what happens to those bits that are shifted in or out at the ends of the number.</p>&#13;
			<p lang="en-GB">We discovered that the ARM has another unusual feature because it doesn’t provide pure shift instructions. Instead, it can apply a shift to the second operand in a conventional data processing operation. The ARM can execute an <code>add </code>r0<code>,r1,r2, lsl r3</code> instruction that shifts the contents of register <code>r2</code> left by the value in <code>r3</code>. The shifted value is then added to <code>r1</code>, and the result is transferred to <code>r0</code>. This mechanism provides a <em class="italic">free shift</em> because you can do a shift and not have to pay any penalty to execute it.</p>&#13;
			<p lang="en-GB">Probably the most intriguing feature of the ARM is its ability to perform conditional execution – that is, before an instruction is executed, the condition code bits are checked. For example, <code>add</code>eq<code> r0,r1,r2</code> performs an addition only if the z-bit is set to <code>1</code>. This is a very powerful operation, and you can use it to write compact code.</p>&#13;
			<p lang="en-GB">Sadly, it appears that conditional execution is a clever technique whose time has passed. It’s not a cost-effective operation today. Conditional execution reduces the number of branches in a program and the number of clock cycles required to execute a program. Advances in computer technology have made conditional execution redundant in new CPU designs.</p>&#13;
			<p lang="en-GB">In the next chapter, we will look at the ARM’s addressing modes – one of the highlights of this processor.</p>&#13;
		</div>&#13;
	</div></body></html>