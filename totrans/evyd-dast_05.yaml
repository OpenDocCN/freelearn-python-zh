- en: 'Chapter 5. Queues: FIFO Collections'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。队列：FIFO集合
- en: 'A **queue** is an abstract data structure that serves as a linear collection
    of objects that are inserted and removed based on the **first-in first-out** (**FIFO**)
    principle. The two most notable operations of a queue are **enqueue**, which adds
    objects to the tail or back of the collection, and **dequeue**, which removes
    objects from the head or front of the collection. The following figure demonstrates
    the queue data structure as well as these two basic operations. Other common operations
    include **peek**, **empty**, and **full**, all of which will be examined later
    in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**队列**是一种抽象数据结构，它作为基于**先进先出**（**FIFO**）原则插入和删除对象的线性集合。队列最显著的操作是**入队**，它将对象添加到集合的尾部或末尾，以及**出队**，它从集合的头部或前端移除对象。以下图示展示了队列数据结构以及这两个基本操作。其他常见操作包括**查看**、**空**和**满**，所有这些将在本章后面进行探讨：'
- en: '![Queues: FIFO Collections](img/00007.jpeg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![队列：FIFO集合](img/00007.jpeg)'
- en: Queues are very similar to stacks and they share some of the same functionality.
    Even two of their primary operations are very similar, just implemented on opposite
    principles. Like a stack, a queue can be either array-based or linked list-based,
    and the linked list based version is more efficient in most cases. However, unlike
    a stack, which can be sorted or unsorted, a queue is not intended to be sorted
    at all and sorting a queue whenever an object is added to the collection results
    in a terrible **O**(*n.log(n)*) operational cost. One alternative version of the
    queue, called a **priority queue**, is based on a **heap** data structure. The
    priority queue does support a type of sorting, but it is still expensive and not
    generally used outside special applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 队列与栈非常相似，它们共享一些相同的功能。甚至它们的主要操作也非常相似，只是基于相反的原则。像栈一样，队列可以是基于数组的或基于链表的，而在大多数情况下，基于链表的版本更有效率。然而，与可以排序或未排序的栈不同，队列根本不打算排序，并且每次向集合中添加对象时对队列进行排序会导致可怕的**O**(*n.log(n)*)操作成本。队列的一个替代版本，称为**优先队列**，基于**堆**数据结构。优先队列支持一种排序类型，但这仍然很昂贵，并且通常只在特殊应用中使用。
- en: Overall, a queue data structure is well suited for any application that requires
    the ability to prioritize operations on a *first-come first-served* basis. If
    you are having trouble visualizing a queue structure, just think of any time you
    had to stand in line. In primary school, we waited for the drinking fountain;
    in supermarkets, we wait for the cashier; in the deli, we wait for *our number*;
    in various government offices, we wait (and wait) for the next available teller.
    In fact, we have all been queuing since the day we were born... unless you are
    a twin in which case you started just a little sooner than most of us.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，队列数据结构非常适合任何需要基于**先来先服务**原则对操作进行优先级排序的应用程序。如果你在可视化队列结构时遇到困难，只需想想你曾经排队等待的任何时刻。在小学时，我们等待饮水机；在超市里，我们等待收银员；在熟食店，我们等待**我们的号码**；在各个政府办公室，我们等待（并且等待）下一个可用的出纳员。实际上，我们自出生以来就一直在排队...除非你是双胞胎，那样你比我们中的大多数人开始得早一点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Definition of a queue data structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列数据结构的定义
- en: Initializing queues
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化队列
- en: Case study - customer service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究 - 客户服务
- en: Queue implementations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列实现
- en: Common queue operations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见队列操作
- en: Array-based queues
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于数组的队列
- en: List-based queues
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于列表的队列
- en: Heap-based queues
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于堆的队列
- en: Double-ended queues
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双端队列
- en: Priority queues
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先队列
- en: Initializing queues
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化队列
- en: Each language provides varying levels of support for the queue data structure.
    Here are some examples of initializing the collection, adding an object to the
    back of the collection, and then removing the head object from the head of the
    collection.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每种语言对队列数据结构的支持程度不同。以下是一些初始化集合、向集合的尾部添加对象以及从集合的头部移除头对象的示例。
- en: '**C#**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'C# provides a concrete implementation of the queue data structure through the
    `Queue<T>` generic class:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: C#通过`Queue<T>`泛型类提供了队列数据结构的具体实现：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Java**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'Java provides the abstract `Queue<E>` interface, and several concrete implementations
    of the queue data structure use this interface. Queue is also extended to the
    `Deque<E>` interface that represents a **double-ended queue**. The `ArrayDeque<E>`
    class is one concrete implementation of the `Deque<E>` interface:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了抽象的 `Queue<E>` 接口，并且有几个队列数据结构的具体实现使用了这个接口。队列也被扩展到 `Deque<E>` 接口，它代表一个**双端队列**。`ArrayDeque<E>`
    类是 `Deque<E>` 接口的一个具体实现：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Objective-C**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'Objective-C does not provide a concrete implementation of the queue data structure,
    but one can be easily created using the `NSMutableArray` class cluster. Be aware
    that this will create an array-based implementation of the queue, which is *generally*
    less efficient than a linked list-based implementation:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 没有提供队列数据结构的具体实现，但可以使用 `NSMutableArray` 类簇轻松创建。请注意，这将创建一个基于数组的队列实现，这通常**不如**基于链表的实现高效：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'I was curious about the measurable difference in efficiency between a stack
    and a queue implemented with `NSMutableArray`, so I performed a series of simple
    tests. In these tests, I began by instantiating an `NSMutableArray` object with
    1,000,000 `EDSUser` objects. In the first test, I treated the array as a stack
    and sequentially *popped* each item from the tail of the array by calling the
    `removeLastObject` object. In the second test, I treated the array as a queue
    and sequentially *dequeued* each user from the head of the array by calling `removeObjectAtIndex:0`.
    Using a `for` loop, I performed each series of tests 1,000 times, then averaged
    the time it took to remove all of the objects through each iteration. I was expecting
    the queue structure to operate on-par, or slightly less efficiently than, the
    stack structure, so I was surprised by these results:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我对使用 `NSMutableArray` 实现的栈和队列在效率上的可测量差异感到好奇，因此我进行了一系列简单的测试。在这些测试中，我首先实例化了一个包含
    1,000,000 个 `EDSUser` 对象的 `NSMutableArray` 对象。在第一个测试中，我将数组视为栈，并通过调用 `removeLastObject`
    对象依次从数组的尾部弹出每个项目。在第二个测试中，我将数组视为队列，并通过调用 `removeObjectAtIndex:0` 依次从数组的头部出队每个用户。使用
    `for` 循环，我对每个测试序列进行了 1,000 次操作，然后平均了每次迭代移除所有对象所需的时间。我预计队列结构将和栈结构表现相当，或者略低效，所以我对这些结果感到惊讶：
- en: 'Average stack time: 0.202993'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 平均栈时间：0.202993
- en: 'Average queue time: 0.184913'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 平均队列时间：0.184913
- en: As you can see, the queue structure actually performed slightly *better* than
    the stack structure, clocking in at about 18 milliseconds faster on average. Of
    course, results will vary between environments and 18 milliseconds is hardly worth
    noting, but following these tests, I feel confident in saying that the `NSMutableArray`
    class is suitably efficient to function as a queue structure. If you would like
    to run the test yourself, execute the static methods `stackTest` and `queueTest`
    in `EDSCollectionTests` found in the Objective-C code files for this text.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，队列结构实际上表现得略好于栈结构，平均快了大约 18 毫秒。当然，不同环境下的结果会有所不同，18 毫秒几乎可以忽略不计，但经过这些测试，我有信心地说，`NSMutableArray`
    类足够高效，可以作为队列结构使用。如果您想亲自运行测试，请在 Objective-C 代码文件中的 `EDSCollectionTests` 执行静态方法
    `stackTest` 和 `queueTest`。
- en: '**Swift**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Like Objective-C, Swift does not provide a concrete implementation of the queue
    data structure, but the `Array` class can be used to implement the structure.
    The following example demonstrates the `append()` and `popLast()` methods:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Objective-C 类似，Swift 没有提供队列数据结构的具体实现，但可以使用 `Array` 类来实现该结构。以下示例演示了 `append()`
    和 `popLast()` 方法：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Queue operations
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 队列操作
- en: 'Not all implementations of queue data structures expose the same operational
    methods. However, the more common operations should be available or made available
    as needed by the developer:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有队列数据结构的实现都公开相同的操作方法。然而，更常见的操作应该可用，或者根据开发者的需要提供：
- en: '**enqueue**: The enqueue operation adds a new object into the back of the queue
    by either appending to the collection, if it is array-based, or adding a new node
    to the collection if it is linked list-based.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入队**：入队操作通过向集合追加（如果它是基于数组的）或向集合添加新节点（如果它是基于链表的）将新对象添加到队列的末尾。'
- en: '**dequeue**: The dequeue operation is the opposite of enqueue. In most implementations,
    the dequeue operation both removes and returns the first object from the array
    or list to the caller.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**出队**：出队操作是入队的相反操作。在大多数实现中，出队操作会从数组或列表中移除并返回第一个对象给调用者。'
- en: '**peek**: The peek operation returns the first object from the array or list
    to the caller, but does not remove the object from the collection.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看**：查看操作返回数组或列表中的第一个对象给调用者，但不从集合中移除该对象。'
- en: '**count**: The count operation returns the total number of objects or nodes
    currently in the collection.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数**：计数操作返回集合中当前对象或节点的总数。'
- en: '**empty**: The empty operation typically returns a boolean value denoting whether
    the collection has any objects.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空载**：空载操作通常返回一个布尔值，表示集合中是否有对象。'
- en: '**full**: The full operation typically returns a boolean value denoting whether
    the collection is at capacity or if there is still room to add more objects. Not
    all implementations allow the caller to define the capacity, but this detail can
    be easily added using the queue count.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**满载**：满载操作通常返回一个布尔值，表示集合是否已满载或是否仍有空间添加更多对象。并非所有实现都允许调用者定义容量，但这个细节可以通过队列计数轻松添加。'
- en: 'Case study: customer service'
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究：客户服务
- en: '**Business problem**: A small software firm wants to break into a new market
    with a mobile app for tracking customer service requests at **Department of Motor
    Vehicles** (**DMV**) service locations. The app will allow users to *take a number*
    with their mobile device as they pass into a **geofence** representing the service
    area. This will allow customers to immediately move to the next available window
    or to take a seat and wait comfortably for an associate to assist them. One primary
    business requirement states that service will be delivered to customers on a first-come,
    first-served basis. In addition to the business requirements, the team wants to
    implement the core functionality with a generic design so that they can expand
    to new markets without the need to modify the underlying business logic.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**业务问题**：一家小型软件公司希望通过一款移动应用程序进入新市场，该应用程序用于跟踪在机动车管理局（DMV）服务地点的客户服务请求。该应用程序将允许用户在通过代表服务区域的**地理围栏**时使用他们的移动设备**取号**。这将允许客户立即移动到下一个可用的窗口或坐下舒适地等待工作人员协助他们。一个主要业务需求是，服务将按照先到先得的原则向客户提供服务。除了业务需求外，团队还希望以通用设计实现核心功能，这样他们就可以在不修改底层业务逻辑的情况下扩展到新市场。'
- en: The developer in charge of creating the core functionality decides that the
    class that keeps track of each customer's position in line should be bundled with
    the web service. This class will require some mechanism for adding and removing
    customers as part of normal operation, as well as the ability to clear all of
    the customers from the waiting list when the office closes for the day. As customers
    will typically like to know how long they can expect to wait before speaking with
    an associate; the class must also be able to report the number of customers currently
    waiting to be seen in total as well as those in front of the current customer.
    In the event that the customer's mobile device crosses the geofence again, they
    have effectively left the service area and forfeited their place in line. Therefore,
    although removing an object from the middle of a queue is not a queue-like operation,
    the class should also be able to cancel a customer's position from the line when
    they leave before speaking with an associate. Finally, the class should be able
    to report when the customer list is empty and when it has reached the occupancy
    limit of the location.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 负责创建核心功能的主开发人员决定，跟踪每位客户在队列中位置的类应该与网络服务捆绑在一起。这个类在正常操作中需要一些机制来添加和删除客户，以及在办公室当天关闭时能够清除等待名单上的所有客户。由于客户通常想知道在与工作人员交谈之前他们需要等待多长时间，因此该类还必须能够报告当前等待被接待的客户总数以及当前客户前面的客户数量。如果客户的移动设备再次穿越地理围栏，他们实际上已经离开了服务区域，并放弃了他们在队列中的位置。因此，尽管从队列中间移除对象不是队列操作，但该类还应该能够在客户在与工作人员交谈之前离开时取消他们在队列中的位置。最后，该类应该能够报告客户名单是否为空以及它是否达到了位置的占用上限。
- en: '**C#**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'As seen in the implementation examples, C# has queue support in the `Queue<T>`
    class. This class is generic, and it includes all of the basic operations that
    we need to implement the `CustomerQueue` class. Here''s an example of what a simple
    implementation using C# might look like:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如实现示例所示，C# 在 `Queue<T>` 类中提供了队列支持。这个类是泛型的，它包括了实现 `CustomerQueue` 类所需的所有基本操作。以下是一个使用
    C# 的简单实现的示例：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our class declares two fields. The first is `_custQueue`, which represents
    our queue data structure and the core of this class. The field is private, so
    only methods within our class can modify it. The second field is `_cap` and it
    maintains our caller-defined maximum number of customers in the collection. Finally,
    the constructor initializes `_custQueue` and assigns `capacity` to `_cap`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个类声明了两个字段。第一个是 `_custQueue`，它代表我们的队列数据结构以及这个类的核心。该字段是私有的，因此只有我们类中的方法可以修改它。第二个字段是
    `_cap`，它维护我们调用者定义的集合中客户的最大数量。最后，构造函数初始化 `_custQueue` 并将 `capacity` 赋值给 `_cap`：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `CanCheckinCustomer()` method adds simple validation to `CustomerQueue`
    by confirming that `_custQueue.Count` is less than the defined capacity and returning
    the result:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanCheckinCustomer()` 方法通过确认 `_custQueue.Count` 小于定义的容量并返回结果来对 `CustomerQueue`
    进行简单的验证：'
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first of the two basic queue operations, *enqueue*, is wrapped in the `CustomerCheckin(Customer)`
    method. This method validates that a new `Customer` object can be added and then
    calls `Enqueue(T)` to add `c` to the `_custQueue` collection. This operation has
    an **O**(*1*) cost:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 两个基本队列操作中的第一个，*入队*，被封装在 `CustomerCheckin(Customer)` 方法中。这个方法验证一个新的 `Customer`
    对象可以被添加，然后调用 `Enqueue(T)` 将 `c` 添加到 `_custQueue` 集合中。这个操作的成本是 **O**(*1*)：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to maintain an accurate number of customers currently waiting in line,
    we don''t want to dequeue a customer until an associate has attended to their
    needs or inquiry. Therefore, when a customer has reached the head of the queue,
    the `CustomerConsultation()` method calls `Peek()`. This returns the next `Customer`
    object in `_custQueue` but does not remove that object from the collection. Effectively,
    this method provides the necessary data for a `Now Serving:` message or something
    equivalent. This operation has an **O**(*1*) cost:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持当前排队等待的客户准确数量，我们不希望在一位员工处理完客户的需求或咨询之前就出队一个客户。因此，当客户到达队列头部时，`CustomerConsultation()`
    方法会调用 `Peek()`。这个方法返回 `_custQueue` 中的下一个 `Customer` 对象，但不会从集合中移除该对象。实际上，这个方法提供了发送“正在服务：”消息或类似消息所需的数据。这个操作的成本是
    **O**(*1*)：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once an associate has completed a transaction with their current customer,
    the customer''s place in the queue can be cleared. The `CustomerCheckout()` method
    calls the `Dequeue()` method, which removes the `Customer` object from the front
    position of `_custQueue`. This operation has an **O**(*1*) cost:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一位员工完成与当前客户的交易后，客户在队列中的位置可以被清除。`CustomerCheckout()` 方法调用 `Dequeue()` 方法，从 `_custQueue`
    的前端位置移除 `Customer` 对象。这个操作的成本是 **O**(*1*)：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When it''s time to close the doors our class needs a way to clear out stragglers.
    The `ClearCustomers()` method provides the *clear* functionality, so our class
    can reset the collection to an empty state:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当是时候关闭大门时，我们的类需要一种方法来清理滞留的客户。`ClearCustomers()` 方法提供了清除功能，因此我们的类可以将集合重置为空状态：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `CustomerCancel(Customer)` method introduces the non-queue operation to
    remove the `Customer` objects from the `_custQueue` collection. As `Queue<T>`
    provides no interface for this operation, we need to improvise. This method first
    creates a temporary queue collection, `tempQueue`, then loops through every `Customer`
    object in `_custQueue`. If `cust` is not equal to `c`, it is added to `tempQueue`.
    When our `for` loop has finished, only those customers who are still in line will
    have been added to `tempQueue`. Finally, `tempQueue` is assigned to `_custQueue`.
    This operation has an **O**(*n*) cost, but this is acceptable as the method should
    not be called often as part of normal operations:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerCancel(Customer)` 方法引入了非队列操作，用于从 `_custQueue` 集合中移除 `Customer` 对象。由于
    `Queue<T>` 没有提供执行此操作的接口，我们需要进行改进。该方法首先创建一个临时的队列集合，`tempQueue`，然后遍历 `_custQueue`
    中的每一个 `Customer` 对象。如果 `cust` 不等于 `c`，则将其添加到 `tempQueue`。当我们的 `for` 循环完成后，只有仍然在队列中的客户会被添加到
    `tempQueue`。最后，将 `tempQueue` 赋值给 `_custQueue`。这个操作的成本是 **O**(*n*)，但这是可以接受的，因为这个方法不应该经常作为正常操作的一部分被调用：'
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In order to estimate a customer''s current wait time with any sort of accuracy,
    it is necessary to know their position in the queue and `CustomerPosition(Customer)`
    gives our class that functionality. Again, `Queue<T>` does not provide the functionality,
    so we need to write our own. The `CustomerPosition(Customer)` method checks whether
    `_custQueue` contains the `Customer` we are looking for. If the collection does
    not contain `Customer c`, the method returns `-1`. Otherwise, it loops through
    the entire collection until `c` is located. The `Customer c` object located at
    the back of the queue is the worst case for both the `Queue<T>.Contains(T)` method
    and the `foreach` loop, each representing an **O**(*n*) cost. Since these operations
    are nested, this method carries an overall cost of **O**(2*n*):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以任何程度的准确性估计客户的当前等待时间，有必要知道他们在队列中的位置，而`CustomerPosition(Customer)`方法为我们提供了这个功能。再次强调，`Queue<T>`不提供这个功能，因此我们需要自己编写。`CustomerPosition(Customer)`方法检查`_custQueue`是否包含我们要找的`Customer`。如果集合不包含`Customer
    c`，则该方法返回`-1`。否则，它将遍历整个集合，直到找到`c`。位于队列末尾的`Customer c`对象是`Queue<T>.Contains(T)`方法和`foreach`循环的最坏情况，每个都代表一个**O**(*n*)的成本。由于这些操作是嵌套的，因此该方法的总成本为**O**(2*n*)：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The final three methods, `CustomersInLine()`, `IsLineEmpty()`, and `IsLineFull()`,
    introduce the *count*, *empty*, and *full* functionality for our class. Each of
    these operations has an **O**(*1*) cost.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个方法，`CustomersInLine()`、`IsLineEmpty()`和`IsLineFull()`，为我们这个类引入了*计数*、*空*和*满*功能。这些操作的成本都是**O**(*1*)。
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Nested Loops**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌套循环**'
- en: Always look twice when you find yourself nesting loops. Looking at this implementation
    as a whole, the `CustomerPosition()` method is of particular concern for two reasons.
    An **O**(2*n*) operational cost is extremely pricey for such a simple operation.
    This is compounded by the fact that users have a tendency to be impatient under
    the best of circumstances and could, therefore, monitor the expected wait time
    almost constantly. This user behavior will translate into multiple calls to the
    `CustomerPosition()` method. Arguably, this inefficiency can be ignored in practice
    as the time needed to process a list of people standing in a physical line, even
    a line waiting to enter a stadium, would be minimal. However, an algorithm whose
    cost is *x^n*, where *x* > 1, has a bad *code smell* and most developers would
    try to architect a better solution to the problem before releasing this one into
    the wild.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发现自己嵌套循环时，总是要仔细检查。从整体实现来看，`CustomerPosition()`方法有两个特别需要注意的原因。对于这样一个简单的操作，**O**(2*n*)的操作成本非常高。此外，由于用户在最佳情况下也倾向于缺乏耐心，因此他们可能会几乎不断监控预期的等待时间。这种行为将转化为对`CustomerPosition()`方法的多次调用。可以说，这种低效在实践中可以忽略不计，因为处理一个物理队列中的人的列表所需的时间，即使是等待进入体育场的队列，也是微不足道的。然而，成本为*x^n*（其中*x*
    > 1）的算法有一个糟糕的*代码味道*，大多数开发者会在将其发布到野外之前尝试构建一个更好的解决方案。
- en: '**Java**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'As discussed in the implementation examples, Java supports several concrete
    implementations of lists that could be used for a queue class, but the most appropriate
    versions conform to the double-ended queue `Dequeue<E>` interface. One concrete
    implementation is the `ArrayQueue<E>` class. Here''s an example of what a simple
    implementation using Java''s `ArrayQueue<E>` class might look like:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如在实现示例中讨论的那样，Java支持几个具体的列表实现，这些实现可以用于队列类，但最合适的版本符合双端队列`Dequeue<E>`接口。一个具体的实现是`ArrayQueue<E>`类。以下是一个使用Java的`ArrayQueue<E>`类进行简单实现的示例：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our class declares two fields. The first is `_custQueue`, which represents
    our queue data structure and the core of this class. The field is private, so
    only methods within our class can modify it. The second field is `_cap`, which
    maintains our caller-defined maximum number of customers in the collection. Finally,
    the constructor initializes `_custQueue` and assigns `capacity` to `_cap`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个类声明了两个字段。第一个是`_custQueue`，它代表我们的队列数据结构以及这个类的核心。该字段是私有的，因此只有我们类中的方法可以修改它。第二个字段是`_cap`，它维护我们的调用者定义的集合中客户的最大数量。最后，构造函数初始化`_custQueue`并将`capacity`分配给`_cap`：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `canCheckinCustomer()` method adds simple validation to `CustomerQueue`
    by confirming that `_custQueue.size()` is less than the defined capacity and returning
    the result:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`canCheckinCustomer()`方法通过确认`_custQueue.size()`小于定义的容量并返回结果来为`CustomerQueue`添加简单的验证：'
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first of the two basic queue operations, *enqueue*, is wrapped in the `customerCheckin(Customer)`
    method. This method confirms that we can add a new `Customer` to the queue then
    calls `AddLast(E)` to add `c` to the `_custQueue` collection. This operation has
    an **O**(*1*) cost:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 两个基本队列操作中的第一个，*enqueue*，被封装在 `customerCheckin(Customer)` 方法中。这个方法确认我们可以向队列中添加一个新的
    `Customer`，然后调用 `AddLast(E)` 将 `c` 添加到 `_custQueue` 集合中。这个操作的成本是 **O**(*1*)：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order to maintain an accurate number of customers currently waiting in line,
    we don''t want to dequeue a customer until an associate has attended to their
    needs or inquiry. Therefore, when a customer has reached the head of the queue
    the `customerConsultation()` method calls `peek()`. This returns the next `Customer`
    in `_custQueue`, but it does not remove that object from the collection. This
    operation has an **O**(*1*) cost:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持当前排队等待的客户准确数量，我们不希望在一位员工处理完客户的需求或咨询之前就出队一个客户。因此，当客户到达队列头部时，`customerConsultation()`
    方法会调用 `peek()`。这个方法返回 `_custQueue` 中的下一个 `Customer` 对象，但不会从集合中移除该对象。这个操作的成本是 **O**(*1*)：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once an associate has completed a transaction with their current customer,
    the customer''s place in the queue can be cleared. The `customerCheckout()` method
    calls `Dequeue()`, which removes the `Customer` object from the front position
    of `_custQueue`. This operation has an **O**(*1*) cost:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一位员工完成与当前客户的交易后，客户的队列位置可以被清除。`customerCheckout()` 方法调用 `Dequeue()`，从 `_custQueue`
    的前端位置移除 `Customer` 对象。这个操作的成本是 **O**(*1*)：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `ClearCustomers()` method provides the *clear* functionality, so our class
    can reset the collection to an empty state:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClearCustomers()` 方法提供了 *clear* 功能，因此我们的类可以将集合重置为空状态：'
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `customerCancel(Customer)` method introduces the non-queue operation to
    remove `Customer` objects from the `_custQueue` collection. As `ArrayQueue<E>`
    provides the `remove(E)` method to remove any objects matching `E` from the queue,
    `customerCancel(Customer)` simply calls that method. This operation has an **O**(*n*)
    cost, but this is acceptable as the method should not be called often during normal
    operations:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`customerCancel(Customer)` 方法引入了非队列操作来从 `_custQueue` 集合中移除 `Customer` 对象。由于
    `ArrayQueue<E>` 提供了 `remove(E)` 方法来从队列中移除任何匹配 `E` 的对象，`customerCancel(Customer)`
    简单地调用该方法。这个操作的成本是 **O**(*n*)，但在正常操作中这个方法不应该经常被调用：'
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In order to estimate a customer''s current wait time with any sort of accuracy,
    it is necessary to know their position in the queue. The `customerPosition(Customer)`
    method gives our class a position functionality. The `ArrayQueue<E>` interface
    does not provide this functionality, so we need to write our own. `CustomerPosition(Customer)`
    checks whether `_custQueue` contains the `Customer` we are looking for. If the
    collection does not contain `Customer c`, the method returns `-1`. Otherwise,
    it loops through the entire collection until `c` is located. The `Customer c`
    object located at the back of the queue is the worst case for both the `Queue<T>.Contains(T)`
    method and the `foreach` loop, each representing an **O**(*n*) cost. Since these
    operations are nested, this method carries an overall cost of **O**(2*n*):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以任何形式的准确性估计客户的当前等待时间，有必要知道他们在队列中的位置。`customerPosition(Customer)` 方法为我们提供了位置功能。`ArrayQueue<E>`
    接口不提供这个功能，因此我们需要自己编写。`CustomerPosition(Customer)` 检查 `_custQueue` 是否包含我们要找的 `Customer`。如果集合不包含
    `Customer c`，该方法返回 `-1`。否则，它将遍历整个集合，直到找到 `c`。位于队列末尾的 `Customer c` 对象是 `Queue<T>.Contains(T)`
    方法和 `foreach` 循环的最坏情况，每个都代表一个 **O**(*n*) 成本。由于这些操作是嵌套的，这个方法的总成本是 **O**(2*n*)：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The final three methods, `customersInLine()`, `isLineEmpty()`, and `isLineFull()`,
    introduce the *count*, *empty*, and *full* functionality for our class. Each of
    these operations have an **O**(*1*) cost.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个方法，`customersInLine()`、`isLineEmpty()` 和 `isLineFull()`，为我们的类引入了 *count*、*empty*
    和 *full* 功能。这些操作的成本都是 **O**(*1*)。
- en: '**Objective-C**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'As discussed earlier, Objective-C does not provide a concrete implementation
    of a queue data structure, but one can be mimicked easily using the `NSMutableArray`
    class cluster. Here''s what a simple example of that implementation might look
    like:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Objective-C 不提供队列数据结构的具体实现，但可以使用 `NSMutableArray` 类簇轻松模拟。以下是一个简单实现的示例：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our class declares two **ivar** properties. The first is an `NSMutableArray`
    object named `_custQueue`, which represents our queue data structure and the core
    of this class. The second field is `_cap`. This field maintains our caller-defined
    maximum number of customers in the collection. Both of these are ivars, so only
    methods in our class can modify their values. Finally, the constructor initializes
    `_custQueue` and assigns `capacity` to `_cap`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类声明了两个 **ivar** 属性。第一个是一个名为 `_custQueue` 的 `NSMutableArray` 对象，它代表我们的队列数据结构以及这个类的核心。第二个字段是
    `_cap`。这个字段维护了我们调用者定义的集合中客户的最大数量。这两个都是 ivars，所以只有我们类中的方法可以修改它们的值。最后，构造函数初始化 `_custQueue`
    并将 `capacity` 赋值给 `_cap`：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `canCheckinCustomer:` adds simple validation to `CustomerQueue` by confirming
    that `[_custQueue count]` is less than the defined capacity and returning the
    result:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`canCheckinCustomer:` 通过确认 `[_custQueue count]` 小于定义的容量并返回结果来为 `CustomerQueue`
    添加简单的验证：'
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first of the two basic queue operations, *enqueue*, is wrapped in the `checkInCustomer:`
    method. This method confirms that we can add a new `Customer` to the queue and
    then calls `addObject:` method to add `c` to the `_custQueue` collection. This
    operation has an **O**(*1*) cost:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 两个基本队列操作中的第一个，*入队*，被封装在 `checkInCustomer:` 方法中。这个方法确认我们可以向队列中添加一个新的 `Customer`，然后调用
    `addObject:` 方法将 `c` 添加到 `_custQueue` 集合中。这个操作的成本是 **O**(*1*)：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In order to maintain an accurate number of customers currently waiting in line,
    we don''t want to *dequeue* a customer until an associate has attended to their
    needs or inquiry. Therefore, when a customer has reached the head of the queue,
    the `customerConsultation:` method returns `firstObject`. This returns the next
    `Customer` in `_custQueue`, but it does not remove that object from the collection.
    This operation has an **O**(*1*) cost:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持当前排队等待的客户准确数量，我们不希望在一位同事处理完他们的需求或咨询之前就 *出队* 一个客户。因此，当客户到达队列头部时，`customerConsultation:`
    方法返回 `firstObject`。这返回了 `_custQueue` 中的下一个 `Customer` 对象，但不会从集合中移除该对象。这个操作的成本是
    **O**(*1*)：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once an associate has completed a transaction with their current customer,
    the customer''s place in the queue can be cleared. The `checkoutCustomer:` method
    calls `removeObjectAtIndex:0`, which removes the `Customer` object from the front
    position of `_custQueue`. This operation has an **O**(*1*) cost:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一位同事完成与当前客户的交易后，可以清除客户在队列中的位置。`checkoutCustomer:` 方法调用 `removeObjectAtIndex:0`，从
    `_custQueue` 的前端位置移除 `Customer` 对象。这个操作的成本是 **O**(*1*)：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `clearCustomers:` method provides the *clear* functionality, so our class
    can reset the collection to an empty state:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`clearCustomers:` 方法提供了 *清除* 功能，因此我们的类可以将集合重置为空状态：'
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `cancelCustomer:` method introduces the non-queue operation to remove the
    `Customer` objects from the `_custQueue` collection. As `NSMutableArray` provides
    the `removeObjectAtIndex:` property, `cancelCustomer:` simply calls that method.
    This operation has an **O**(*n*+1) cost, but this is acceptable as the method
    should not be called often during normal operations:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`cancelCustomer:` 方法引入了非队列操作来从 `_custQueue` 集合中移除 `Customer` 对象。由于 `NSMutableArray`
    提供了 `removeObjectAtIndex:` 属性，`cancelCustomer:` 简单地调用该方法。这个操作的成本是 **O**(*n*+1)，但在正常操作中不应频繁调用此方法：'
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In order to estimate a customer''s current wait time with any sort of accuracy,
    it is necessary to know their position in the queue. The `positionOfCustomer:`
    property gives our class a position functionality by simply returning `indexOfObject:`.
    This operation has an **O**(*n*) cost:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以任何程度的准确性估计客户的当前等待时间，有必要知道他们在队列中的位置。`positionOfCustomer:` 属性通过简单地返回 `indexOfObject:`
    为我们的类提供位置功能。这个操作的成本是 **O**(*n*)：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The final three methods, `customersInLine()`, `isLineEmpty()`, and `isLineFull()`,
    introduce the *count*, *empty*, and *full* functionality for our class. Each of
    these operations has an **O**(*1*) cost.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个方法，`customersInLine()`、`isLineEmpty()` 和 `isLineFull()`，为我们的类引入了 *计数*、*空*
    和 *满* 功能。每个操作的成本都是 **O**(*1*)。
- en: '**Swift**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'As discussed earlier, Swift does not provide a concrete implementation of a
    queue data structure, but one can be mimicked easily using the `Array` class.
    Here''s what a simple example of that implementation might look like:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Swift 没有提供队列数据结构的具体实现，但可以使用 `Array` 类轻松模拟。以下是一个简单实现的示例：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our class declares two properties. The first is an `Array` of `Customer` named
    `_custQueue`, which represents our queue data structure and the core of this class.
    The second field is `_cap`. This field maintains our caller-defined maximum number
    of customers in the collection. Both of these are private, so only methods in
    our class can modify their values. Finally, the constructor initializes `_custQueue`
    and assigns `capacity` to `_cap`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的这个类声明了两个属性。第一个是一个名为 `_custQueue` 的 `Customer` 数组，它代表我们的队列数据结构和这个类的核心。第二个字段是
    `_cap`。这个字段维护我们的调用者定义的集合中客户的最大数量。这两个都是私有的，所以只有我们这个类的方法可以修改它们的值。最后，构造函数初始化 `_custQueue`
    并将 `capacity` 赋值给 `_cap`：
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `canCheckinCustomer()` method adds simple validation to `CustomerQueue`
    by confirming that `_custQueue.count` is less than the defined capacity and returning
    the result:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`canCheckinCustomer()` 方法通过确认 `_custQueue.count` 小于定义的容量并对结果进行返回，为 `CustomerQueue`
    添加了简单的验证：'
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The first of the two basic queue operations, *enqueue*, is wrapped in the `checkInCustomer()`
    method. This method confirms that we can add a new `Customer` to the queue and
    then calls `append()` to add `c` to the `_custQueue` collection. This operation
    has an **O**(1) cost:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 两个基本队列操作中的第一个，*入队*，被封装在 `checkInCustomer()` 方法中。这个方法确认我们可以向队列中添加一个新的 `Customer`，然后调用
    `append()` 将 `c` 添加到 `_custQueue` 集合中。这个操作的成本是 **O**(1)：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When a customer has reached the head of the queue, the `customerConsultation()`
    method calls `first!`. This returns the next `Customer` in `_custQueue`, but does
    not remove that object from the collection. This operation has an **O**(*1*) cost:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个客户到达队列头部时，`customerConsultation()` 方法调用 `first!`。这返回 `_custQueue` 中的下一个 `Customer`，但不从集合中移除该对象。这个操作的成本是
    **O**(*1*)：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once an associate has completed a transaction with their current customer,
    the customer''s place in the queue can be cleared. The `checkoutCustomer()` method
    calls `removeFirst`, which removes the `Customer` object from the front position
    of `_custQueue`. This operation has an **O**(*1*) cost:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个关联方完成了与其当前客户的交易，客户的队列位置可以被清除。`checkoutCustomer()` 方法调用 `removeFirst`，从 `_custQueue`
    的前端位置移除 `Customer` 对象。这个操作的成本是 **O**(*1*)：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `clearCustomers()` method provides the *clear* functionality, so our class
    can reset the collection to an empty state:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`clearCustomers()` 方法提供了 *清除* 功能，因此我们的类可以将集合重置为空状态：'
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `cancelCustomer(Customer)` method introduces the non-queue operation to
    remove `Customer` objects from the `_custQueue` collection. As `Array` does not
    provide a simple remove type method, we need to improvise once again. Our code
    first sets the conditional `var index` using `indexOf()`. If `index` has a value,
    the method passes `index` to `removeAtIndex()`. This operation has an **O**(*n*+1)
    cost.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`cancelCustomer(Customer)` 方法引入了非队列操作，用于从 `_custQueue` 集合中移除 `Customer` 对象。由于
    `Array` 不提供简单的移除类型方法，我们需要再次进行改进。我们的代码首先使用 `indexOf()` 设置条件 `var index`。如果 `index`
    有值，该方法将 `index` 传递给 `removeAtIndex()`。这个操作的成本是 **O**(*n*+1)：'
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the Swift implementation, we are not calling the instance method `positionOfCustomer()`.
    This is because the `let ... =` notation is an initializer for a **conditional
    binding**, and `positionOfCustomer()` returns `Int`, which is not an optional
    value. Since both `positionOfCustomer()` and this method use the same `indexOf()`
    method call, there is no difference in the operational cost.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 实现中，我们没有调用实例方法 `positionOfCustomer()`。这是因为 `let ... =` 符号是一个 **条件绑定**
    的初始化器，而 `positionOfCustomer()` 返回 `Int`，这不是一个可选值。由于 `positionOfCustomer()` 和此方法都使用了相同的
    `indexOf()` 方法调用，所以在操作成本上没有差异。
- en: 'The code for this is shown as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码的示例如下：
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In order to estimate a customer''s current wait time with any sort of accuracy,
    it is necessary to know their position in the queue. The `positionOfCustomer()`
    method gives our class position functionality by simply returning `indexOf()`.
    This operation has an **O**(*n*) cost:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以任何形式的准确性估计客户的当前等待时间，有必要知道他们在队列中的位置。`positionOfCustomer()` 方法通过简单地返回 `indexOf()`
    为我们的类提供位置功能。这个操作的成本是 **O**(*n*)：
- en: '[PRE39]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The final three methods, `customersInLine()`, `isLineEmpty()`, and `isLineFull()`,
    introduce the *count*, *empty*, and *full* functionality for our class. Each of
    these operations has an **O**(*1*) cost. Overall, the Swift queue implementation
    is very similar to its counterparts in C#, Java, and Objective-C even though the
    Swift language is considerably different from the others.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个方法，`customersInLine()`、`isLineEmpty()`和`isLineFull()`，引入了我们类的**计数**、**空**和**满**功能。每个操作的成本为**O**(*1*)。总的来说，Swift队列实现与其在C#、Java和Objective-C中的对应物非常相似，尽管Swift语言与其他语言有相当大的不同。
- en: Advanced topics
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级主题
- en: Queue data structures can be built on several different underlying data structures.
    Each foundation provides different advantages, and the type that is chosen typically
    depends on the application's needs. The three most common implementations are
    array based, linked list based, and heap-based.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 队列数据结构可以建立在几种不同的底层数据结构之上。每个基础提供了不同的优势，而选择哪种类型通常取决于应用程序的需求。最常见的三种实现是数组基础、链表基础和堆基础。
- en: Queue data structures are also found in two additional variations, including
    the double-ended queue and the priority queue. Again, each variation offers advantages
    and disadvantages and the type that is chosen will largely depend on the needs
    of your application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 队列数据结构还有两种额外的变体，包括双端队列和优先队列。同样，每种变体都提供了优势和劣势，而选择哪种类型将主要取决于应用程序的需求。
- en: Array-based queues
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于数组的队列
- en: '**Array-based queues** utilize a mutable array to represent the queue. Both
    of the examples in Objective-C and Swift take this form. In this implementation,
    the `[0]` position of the array represents the head or front of the queue. Although,
    generally speaking, queues are strictly FIFO collections and developers should
    not attempt to sort them, array-based queues are particularly difficult and costly
    to sort. If your application absolutely requires a sorted collection, you should
    consider using some other data structure entirely, such as a list.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于数组的队列**使用可变数组来表示队列。Objective-C和Swift中的两个示例都采用这种形式。在这个实现中，数组的`[0]`位置代表队列的头部或前端。尽管一般来说，队列是严格的FIFO集合，开发者不应尝试对它们进行排序，但基于数组的队列排序特别困难和昂贵。如果你的应用程序绝对需要有序集合，你应该考虑使用其他数据结构，例如列表。'
- en: Linked list-based queues
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于链表的队列
- en: The **linked list-based queues** utilize a pointer to the front of the queue,
    and subsequent pointers as each new object is appended onto the collection. Dequeing
    an object from the front of the line simply involves moving the head pointer from
    the object at node 0 to the object at node 1\. If your collection of objects must
    be a sorted queue, prefer a link-based queue to an array-based one.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于链表的队列**使用一个指向队列前端的指针，以及随着每个新对象被附加到集合上而后续的指针。从队列前端移除对象只需将头指针从节点0的对象移动到节点1的对象。如果你的对象集合必须是有序队列，则优先选择基于链表的队列而不是基于数组的队列。'
- en: Heap-based queues
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于堆的队列
- en: A **heap-based queue** is a queue created with a **heap** collection as it's
    backer. Heaps are themselves specialized **tree-based data structures** where
    the objects are naturally sorted in ascending (**min heap**) or descending (**max
    heap**) order based on some value or property native to the object.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于堆的队列**是一个使用**堆**集合作为其后盾创建的队列。堆本身是专门化的**基于树的数据库结构**，其中对象根据对象的某些值或属性自然排序为升序（**最小堆**）或降序（**最大堆**）。'
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Heaps should not be confused with the heap, or the pool of dynamically allocated
    memory, of a computer system. We will discuss the concept of heaps in greater
    detail in [Chapter 10](part0058_split_000.html#1NA0K1-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 10. Heaps: Ordered Trees"), *Heaps: Ordered Trees*. Methods for sorting
    heap data structures will be discussed extensively in [Chapter 12](part0069_split_000.html#21PMQ2-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 12. Sorting: Bringing Order Out Of Chaos"), *Sorting: Bringing Order
    Out Of Chaos*.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 堆不应与计算机系统的堆（或动态分配的内存池）混淆。我们将在第10章（[part0058_split_000.html#1NA0K1-77f2b5b248f04368a6f723b0e9357ef3
    "第10章。堆：有序树"](part0058_split_000.html#1NA0K1-77f2b5b248f04368a6f723b0e9357ef3
    "第10章。堆：有序树)）中更详细地讨论堆的概念，*堆：有序树*。将在第12章（[part0069_split_000.html#21PMQ2-77f2b5b248f04368a6f723b0e9357ef3
    "第12章。排序：从混乱中带来秩序"](part0069_split_000.html#21PMQ2-77f2b5b248f04368a6f723b0e9357ef3
    "第12章。排序：从混乱中带来秩序)）中广泛讨论排序堆数据结构的方法。
- en: Double-ended queues
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双端队列
- en: A **double-ended queue** is a collection where objects can be added to or removed
    from either the front or the back. The `ArrayQueue<E>` interface is Java's concrete
    implementation of the `Queue<E>` interface and is an example of a double-ended
    queue.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**双端队列**是一个集合，对象可以添加到或从队列的前端或后端移除。`ArrayQueue<E>`接口是Java对`Queue<E>`接口的具体实现，它是一个双端队列的例子。'
- en: Priority queues
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先队列
- en: A **priority queue** sorts objects in the collection based on some value or
    **priority**. Due to the natural hierarchical structure of a heap, priority queues
    are most often implemented as a heap-based queue. In this design, objects with
    a higher priority naturally sort closest to the front of the line so that, each
    time an object is dequeued, it is always the one with the highest priority. In
    the case where two or more objects share a priority, the object that has been
    in the queue longest will be dequeued first.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**优先队列**根据某些值或**优先级**对集合中的对象进行排序。由于堆的自然层次结构，优先队列通常被实现为一个基于堆的队列。在这种设计中，具有更高优先级的对象自然地排列在队列的前端附近，因此每次出队时，总是具有最高优先级的对象。在两个或多个对象具有相同优先级的情况下，已在队列中等待时间最长的对象将首先出队。'
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the basic definition of the queue data structure,
    including how to initialize concrete implementations of the structure in each
    of the four languages we are discussing. Next, we discussed the most common operations
    associated with the queue data structure and their operational cost. We examined
    an example application using queues to track customers waiting in a *first-come,
    first-served* line. These examples demonstrated how C# and Java provided concrete
    implementations of a queue, whereas Objective-C and Swift do not. Following this,
    we examined the three most common types of queue implementations, including array-based,
    linked-list based, and heap-based queues. Finally, we looked at double-ended and
    priority variations of the queue data structure.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了队列数据结构的基本定义，包括如何在所讨论的四种语言中初始化该结构的具体实现。接下来，我们讨论了与队列数据结构相关联的最常见操作及其操作成本。我们考察了一个使用队列跟踪在*先到先得*队列中等待的客户的应用示例。这些示例展示了C#和Java如何提供队列的具体实现，而Objective-C和Swift则没有。随后，我们考察了三种最常见的队列实现类型，包括基于数组、基于链表和基于堆的队列。最后，我们探讨了队列数据结构的双端和优先级变体。
