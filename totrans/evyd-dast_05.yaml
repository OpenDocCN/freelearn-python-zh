- en: 'Chapter 5. Queues: FIFO Collections'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **queue** is an abstract data structure that serves as a linear collection
    of objects that are inserted and removed based on the **first-in first-out** (**FIFO**)
    principle. The two most notable operations of a queue are **enqueue**, which adds
    objects to the tail or back of the collection, and **dequeue**, which removes
    objects from the head or front of the collection. The following figure demonstrates
    the queue data structure as well as these two basic operations. Other common operations
    include **peek**, **empty**, and **full**, all of which will be examined later
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Queues: FIFO Collections](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Queues are very similar to stacks and they share some of the same functionality.
    Even two of their primary operations are very similar, just implemented on opposite
    principles. Like a stack, a queue can be either array-based or linked list-based,
    and the linked list based version is more efficient in most cases. However, unlike
    a stack, which can be sorted or unsorted, a queue is not intended to be sorted
    at all and sorting a queue whenever an object is added to the collection results
    in a terrible **O**(*n.log(n)*) operational cost. One alternative version of the
    queue, called a **priority queue**, is based on a **heap** data structure. The
    priority queue does support a type of sorting, but it is still expensive and not
    generally used outside special applications.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, a queue data structure is well suited for any application that requires
    the ability to prioritize operations on a *first-come first-served* basis. If
    you are having trouble visualizing a queue structure, just think of any time you
    had to stand in line. In primary school, we waited for the drinking fountain;
    in supermarkets, we wait for the cashier; in the deli, we wait for *our number*;
    in various government offices, we wait (and wait) for the next available teller.
    In fact, we have all been queuing since the day we were born... unless you are
    a twin in which case you started just a little sooner than most of us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Definition of a queue data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case study - customer service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queue implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common queue operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array-based queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List-based queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap-based queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double-ended queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Priority queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each language provides varying levels of support for the queue data structure.
    Here are some examples of initializing the collection, adding an object to the
    back of the collection, and then removing the head object from the head of the
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: 'C# provides a concrete implementation of the queue data structure through the
    `Queue<T>` generic class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java provides the abstract `Queue<E>` interface, and several concrete implementations
    of the queue data structure use this interface. Queue is also extended to the
    `Deque<E>` interface that represents a **double-ended queue**. The `ArrayDeque<E>`
    class is one concrete implementation of the `Deque<E>` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objective-C does not provide a concrete implementation of the queue data structure,
    but one can be easily created using the `NSMutableArray` class cluster. Be aware
    that this will create an array-based implementation of the queue, which is *generally*
    less efficient than a linked list-based implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I was curious about the measurable difference in efficiency between a stack
    and a queue implemented with `NSMutableArray`, so I performed a series of simple
    tests. In these tests, I began by instantiating an `NSMutableArray` object with
    1,000,000 `EDSUser` objects. In the first test, I treated the array as a stack
    and sequentially *popped* each item from the tail of the array by calling the
    `removeLastObject` object. In the second test, I treated the array as a queue
    and sequentially *dequeued* each user from the head of the array by calling `removeObjectAtIndex:0`.
    Using a `for` loop, I performed each series of tests 1,000 times, then averaged
    the time it took to remove all of the objects through each iteration. I was expecting
    the queue structure to operate on-par, or slightly less efficiently than, the
    stack structure, so I was surprised by these results:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Average stack time: 0.202993'
  prefs: []
  type: TYPE_NORMAL
- en: 'Average queue time: 0.184913'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the queue structure actually performed slightly *better* than
    the stack structure, clocking in at about 18 milliseconds faster on average. Of
    course, results will vary between environments and 18 milliseconds is hardly worth
    noting, but following these tests, I feel confident in saying that the `NSMutableArray`
    class is suitably efficient to function as a queue structure. If you would like
    to run the test yourself, execute the static methods `stackTest` and `queueTest`
    in `EDSCollectionTests` found in the Objective-C code files for this text.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like Objective-C, Swift does not provide a concrete implementation of the queue
    data structure, but the `Array` class can be used to implement the structure.
    The following example demonstrates the `append()` and `popLast()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Queue operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not all implementations of queue data structures expose the same operational
    methods. However, the more common operations should be available or made available
    as needed by the developer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**enqueue**: The enqueue operation adds a new object into the back of the queue
    by either appending to the collection, if it is array-based, or adding a new node
    to the collection if it is linked list-based.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dequeue**: The dequeue operation is the opposite of enqueue. In most implementations,
    the dequeue operation both removes and returns the first object from the array
    or list to the caller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**peek**: The peek operation returns the first object from the array or list
    to the caller, but does not remove the object from the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**count**: The count operation returns the total number of objects or nodes
    currently in the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**empty**: The empty operation typically returns a boolean value denoting whether
    the collection has any objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**full**: The full operation typically returns a boolean value denoting whether
    the collection is at capacity or if there is still room to add more objects. Not
    all implementations allow the caller to define the capacity, but this detail can
    be easily added using the queue count.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case study: customer service'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Business problem**: A small software firm wants to break into a new market
    with a mobile app for tracking customer service requests at **Department of Motor
    Vehicles** (**DMV**) service locations. The app will allow users to *take a number*
    with their mobile device as they pass into a **geofence** representing the service
    area. This will allow customers to immediately move to the next available window
    or to take a seat and wait comfortably for an associate to assist them. One primary
    business requirement states that service will be delivered to customers on a first-come,
    first-served basis. In addition to the business requirements, the team wants to
    implement the core functionality with a generic design so that they can expand
    to new markets without the need to modify the underlying business logic.'
  prefs: []
  type: TYPE_NORMAL
- en: The developer in charge of creating the core functionality decides that the
    class that keeps track of each customer's position in line should be bundled with
    the web service. This class will require some mechanism for adding and removing
    customers as part of normal operation, as well as the ability to clear all of
    the customers from the waiting list when the office closes for the day. As customers
    will typically like to know how long they can expect to wait before speaking with
    an associate; the class must also be able to report the number of customers currently
    waiting to be seen in total as well as those in front of the current customer.
    In the event that the customer's mobile device crosses the geofence again, they
    have effectively left the service area and forfeited their place in line. Therefore,
    although removing an object from the middle of a queue is not a queue-like operation,
    the class should also be able to cancel a customer's position from the line when
    they leave before speaking with an associate. Finally, the class should be able
    to report when the customer list is empty and when it has reached the occupancy
    limit of the location.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the implementation examples, C# has queue support in the `Queue<T>`
    class. This class is generic, and it includes all of the basic operations that
    we need to implement the `CustomerQueue` class. Here''s an example of what a simple
    implementation using C# might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our class declares two fields. The first is `_custQueue`, which represents
    our queue data structure and the core of this class. The field is private, so
    only methods within our class can modify it. The second field is `_cap` and it
    maintains our caller-defined maximum number of customers in the collection. Finally,
    the constructor initializes `_custQueue` and assigns `capacity` to `_cap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CanCheckinCustomer()` method adds simple validation to `CustomerQueue`
    by confirming that `_custQueue.Count` is less than the defined capacity and returning
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first of the two basic queue operations, *enqueue*, is wrapped in the `CustomerCheckin(Customer)`
    method. This method validates that a new `Customer` object can be added and then
    calls `Enqueue(T)` to add `c` to the `_custQueue` collection. This operation has
    an **O**(*1*) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to maintain an accurate number of customers currently waiting in line,
    we don''t want to dequeue a customer until an associate has attended to their
    needs or inquiry. Therefore, when a customer has reached the head of the queue,
    the `CustomerConsultation()` method calls `Peek()`. This returns the next `Customer`
    object in `_custQueue` but does not remove that object from the collection. Effectively,
    this method provides the necessary data for a `Now Serving:` message or something
    equivalent. This operation has an **O**(*1*) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once an associate has completed a transaction with their current customer,
    the customer''s place in the queue can be cleared. The `CustomerCheckout()` method
    calls the `Dequeue()` method, which removes the `Customer` object from the front
    position of `_custQueue`. This operation has an **O**(*1*) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When it''s time to close the doors our class needs a way to clear out stragglers.
    The `ClearCustomers()` method provides the *clear* functionality, so our class
    can reset the collection to an empty state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CustomerCancel(Customer)` method introduces the non-queue operation to
    remove the `Customer` objects from the `_custQueue` collection. As `Queue<T>`
    provides no interface for this operation, we need to improvise. This method first
    creates a temporary queue collection, `tempQueue`, then loops through every `Customer`
    object in `_custQueue`. If `cust` is not equal to `c`, it is added to `tempQueue`.
    When our `for` loop has finished, only those customers who are still in line will
    have been added to `tempQueue`. Finally, `tempQueue` is assigned to `_custQueue`.
    This operation has an **O**(*n*) cost, but this is acceptable as the method should
    not be called often as part of normal operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to estimate a customer''s current wait time with any sort of accuracy,
    it is necessary to know their position in the queue and `CustomerPosition(Customer)`
    gives our class that functionality. Again, `Queue<T>` does not provide the functionality,
    so we need to write our own. The `CustomerPosition(Customer)` method checks whether
    `_custQueue` contains the `Customer` we are looking for. If the collection does
    not contain `Customer c`, the method returns `-1`. Otherwise, it loops through
    the entire collection until `c` is located. The `Customer c` object located at
    the back of the queue is the worst case for both the `Queue<T>.Contains(T)` method
    and the `foreach` loop, each representing an **O**(*n*) cost. Since these operations
    are nested, this method carries an overall cost of **O**(2*n*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The final three methods, `CustomersInLine()`, `IsLineEmpty()`, and `IsLineFull()`,
    introduce the *count*, *empty*, and *full* functionality for our class. Each of
    these operations has an **O**(*1*) cost.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Nested Loops**'
  prefs: []
  type: TYPE_NORMAL
- en: Always look twice when you find yourself nesting loops. Looking at this implementation
    as a whole, the `CustomerPosition()` method is of particular concern for two reasons.
    An **O**(2*n*) operational cost is extremely pricey for such a simple operation.
    This is compounded by the fact that users have a tendency to be impatient under
    the best of circumstances and could, therefore, monitor the expected wait time
    almost constantly. This user behavior will translate into multiple calls to the
    `CustomerPosition()` method. Arguably, this inefficiency can be ignored in practice
    as the time needed to process a list of people standing in a physical line, even
    a line waiting to enter a stadium, would be minimal. However, an algorithm whose
    cost is *x^n*, where *x* > 1, has a bad *code smell* and most developers would
    try to architect a better solution to the problem before releasing this one into
    the wild.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed in the implementation examples, Java supports several concrete
    implementations of lists that could be used for a queue class, but the most appropriate
    versions conform to the double-ended queue `Dequeue<E>` interface. One concrete
    implementation is the `ArrayQueue<E>` class. Here''s an example of what a simple
    implementation using Java''s `ArrayQueue<E>` class might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Our class declares two fields. The first is `_custQueue`, which represents
    our queue data structure and the core of this class. The field is private, so
    only methods within our class can modify it. The second field is `_cap`, which
    maintains our caller-defined maximum number of customers in the collection. Finally,
    the constructor initializes `_custQueue` and assigns `capacity` to `_cap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `canCheckinCustomer()` method adds simple validation to `CustomerQueue`
    by confirming that `_custQueue.size()` is less than the defined capacity and returning
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The first of the two basic queue operations, *enqueue*, is wrapped in the `customerCheckin(Customer)`
    method. This method confirms that we can add a new `Customer` to the queue then
    calls `AddLast(E)` to add `c` to the `_custQueue` collection. This operation has
    an **O**(*1*) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to maintain an accurate number of customers currently waiting in line,
    we don''t want to dequeue a customer until an associate has attended to their
    needs or inquiry. Therefore, when a customer has reached the head of the queue
    the `customerConsultation()` method calls `peek()`. This returns the next `Customer`
    in `_custQueue`, but it does not remove that object from the collection. This
    operation has an **O**(*1*) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once an associate has completed a transaction with their current customer,
    the customer''s place in the queue can be cleared. The `customerCheckout()` method
    calls `Dequeue()`, which removes the `Customer` object from the front position
    of `_custQueue`. This operation has an **O**(*1*) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ClearCustomers()` method provides the *clear* functionality, so our class
    can reset the collection to an empty state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `customerCancel(Customer)` method introduces the non-queue operation to
    remove `Customer` objects from the `_custQueue` collection. As `ArrayQueue<E>`
    provides the `remove(E)` method to remove any objects matching `E` from the queue,
    `customerCancel(Customer)` simply calls that method. This operation has an **O**(*n*)
    cost, but this is acceptable as the method should not be called often during normal
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to estimate a customer''s current wait time with any sort of accuracy,
    it is necessary to know their position in the queue. The `customerPosition(Customer)`
    method gives our class a position functionality. The `ArrayQueue<E>` interface
    does not provide this functionality, so we need to write our own. `CustomerPosition(Customer)`
    checks whether `_custQueue` contains the `Customer` we are looking for. If the
    collection does not contain `Customer c`, the method returns `-1`. Otherwise,
    it loops through the entire collection until `c` is located. The `Customer c`
    object located at the back of the queue is the worst case for both the `Queue<T>.Contains(T)`
    method and the `foreach` loop, each representing an **O**(*n*) cost. Since these
    operations are nested, this method carries an overall cost of **O**(2*n*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The final three methods, `customersInLine()`, `isLineEmpty()`, and `isLineFull()`,
    introduce the *count*, *empty*, and *full* functionality for our class. Each of
    these operations have an **O**(*1*) cost.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed earlier, Objective-C does not provide a concrete implementation
    of a queue data structure, but one can be mimicked easily using the `NSMutableArray`
    class cluster. Here''s what a simple example of that implementation might look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Our class declares two **ivar** properties. The first is an `NSMutableArray`
    object named `_custQueue`, which represents our queue data structure and the core
    of this class. The second field is `_cap`. This field maintains our caller-defined
    maximum number of customers in the collection. Both of these are ivars, so only
    methods in our class can modify their values. Finally, the constructor initializes
    `_custQueue` and assigns `capacity` to `_cap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `canCheckinCustomer:` adds simple validation to `CustomerQueue` by confirming
    that `[_custQueue count]` is less than the defined capacity and returning the
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first of the two basic queue operations, *enqueue*, is wrapped in the `checkInCustomer:`
    method. This method confirms that we can add a new `Customer` to the queue and
    then calls `addObject:` method to add `c` to the `_custQueue` collection. This
    operation has an **O**(*1*) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to maintain an accurate number of customers currently waiting in line,
    we don''t want to *dequeue* a customer until an associate has attended to their
    needs or inquiry. Therefore, when a customer has reached the head of the queue,
    the `customerConsultation:` method returns `firstObject`. This returns the next
    `Customer` in `_custQueue`, but it does not remove that object from the collection.
    This operation has an **O**(*1*) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once an associate has completed a transaction with their current customer,
    the customer''s place in the queue can be cleared. The `checkoutCustomer:` method
    calls `removeObjectAtIndex:0`, which removes the `Customer` object from the front
    position of `_custQueue`. This operation has an **O**(*1*) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clearCustomers:` method provides the *clear* functionality, so our class
    can reset the collection to an empty state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cancelCustomer:` method introduces the non-queue operation to remove the
    `Customer` objects from the `_custQueue` collection. As `NSMutableArray` provides
    the `removeObjectAtIndex:` property, `cancelCustomer:` simply calls that method.
    This operation has an **O**(*n*+1) cost, but this is acceptable as the method
    should not be called often during normal operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to estimate a customer''s current wait time with any sort of accuracy,
    it is necessary to know their position in the queue. The `positionOfCustomer:`
    property gives our class a position functionality by simply returning `indexOfObject:`.
    This operation has an **O**(*n*) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The final three methods, `customersInLine()`, `isLineEmpty()`, and `isLineFull()`,
    introduce the *count*, *empty*, and *full* functionality for our class. Each of
    these operations has an **O**(*1*) cost.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed earlier, Swift does not provide a concrete implementation of a
    queue data structure, but one can be mimicked easily using the `Array` class.
    Here''s what a simple example of that implementation might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Our class declares two properties. The first is an `Array` of `Customer` named
    `_custQueue`, which represents our queue data structure and the core of this class.
    The second field is `_cap`. This field maintains our caller-defined maximum number
    of customers in the collection. Both of these are private, so only methods in
    our class can modify their values. Finally, the constructor initializes `_custQueue`
    and assigns `capacity` to `_cap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `canCheckinCustomer()` method adds simple validation to `CustomerQueue`
    by confirming that `_custQueue.count` is less than the defined capacity and returning
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The first of the two basic queue operations, *enqueue*, is wrapped in the `checkInCustomer()`
    method. This method confirms that we can add a new `Customer` to the queue and
    then calls `append()` to add `c` to the `_custQueue` collection. This operation
    has an **O**(1) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When a customer has reached the head of the queue, the `customerConsultation()`
    method calls `first!`. This returns the next `Customer` in `_custQueue`, but does
    not remove that object from the collection. This operation has an **O**(*1*) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once an associate has completed a transaction with their current customer,
    the customer''s place in the queue can be cleared. The `checkoutCustomer()` method
    calls `removeFirst`, which removes the `Customer` object from the front position
    of `_custQueue`. This operation has an **O**(*1*) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clearCustomers()` method provides the *clear* functionality, so our class
    can reset the collection to an empty state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `cancelCustomer(Customer)` method introduces the non-queue operation to
    remove `Customer` objects from the `_custQueue` collection. As `Array` does not
    provide a simple remove type method, we need to improvise once again. Our code
    first sets the conditional `var index` using `indexOf()`. If `index` has a value,
    the method passes `index` to `removeAtIndex()`. This operation has an **O**(*n*+1)
    cost.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Swift implementation, we are not calling the instance method `positionOfCustomer()`.
    This is because the `let ... =` notation is an initializer for a **conditional
    binding**, and `positionOfCustomer()` returns `Int`, which is not an optional
    value. Since both `positionOfCustomer()` and this method use the same `indexOf()`
    method call, there is no difference in the operational cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to estimate a customer''s current wait time with any sort of accuracy,
    it is necessary to know their position in the queue. The `positionOfCustomer()`
    method gives our class position functionality by simply returning `indexOf()`.
    This operation has an **O**(*n*) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The final three methods, `customersInLine()`, `isLineEmpty()`, and `isLineFull()`,
    introduce the *count*, *empty*, and *full* functionality for our class. Each of
    these operations has an **O**(*1*) cost. Overall, the Swift queue implementation
    is very similar to its counterparts in C#, Java, and Objective-C even though the
    Swift language is considerably different from the others.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Queue data structures can be built on several different underlying data structures.
    Each foundation provides different advantages, and the type that is chosen typically
    depends on the application's needs. The three most common implementations are
    array based, linked list based, and heap-based.
  prefs: []
  type: TYPE_NORMAL
- en: Queue data structures are also found in two additional variations, including
    the double-ended queue and the priority queue. Again, each variation offers advantages
    and disadvantages and the type that is chosen will largely depend on the needs
    of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Array-based queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Array-based queues** utilize a mutable array to represent the queue. Both
    of the examples in Objective-C and Swift take this form. In this implementation,
    the `[0]` position of the array represents the head or front of the queue. Although,
    generally speaking, queues are strictly FIFO collections and developers should
    not attempt to sort them, array-based queues are particularly difficult and costly
    to sort. If your application absolutely requires a sorted collection, you should
    consider using some other data structure entirely, such as a list.'
  prefs: []
  type: TYPE_NORMAL
- en: Linked list-based queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **linked list-based queues** utilize a pointer to the front of the queue,
    and subsequent pointers as each new object is appended onto the collection. Dequeing
    an object from the front of the line simply involves moving the head pointer from
    the object at node 0 to the object at node 1\. If your collection of objects must
    be a sorted queue, prefer a link-based queue to an array-based one.
  prefs: []
  type: TYPE_NORMAL
- en: Heap-based queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **heap-based queue** is a queue created with a **heap** collection as it's
    backer. Heaps are themselves specialized **tree-based data structures** where
    the objects are naturally sorted in ascending (**min heap**) or descending (**max
    heap**) order based on some value or property native to the object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Heaps should not be confused with the heap, or the pool of dynamically allocated
    memory, of a computer system. We will discuss the concept of heaps in greater
    detail in [Chapter 10](part0058_split_000.html#1NA0K1-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 10. Heaps: Ordered Trees"), *Heaps: Ordered Trees*. Methods for sorting
    heap data structures will be discussed extensively in [Chapter 12](part0069_split_000.html#21PMQ2-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 12. Sorting: Bringing Order Out Of Chaos"), *Sorting: Bringing Order
    Out Of Chaos*.'
  prefs: []
  type: TYPE_NORMAL
- en: Double-ended queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **double-ended queue** is a collection where objects can be added to or removed
    from either the front or the back. The `ArrayQueue<E>` interface is Java's concrete
    implementation of the `Queue<E>` interface and is an example of a double-ended
    queue.
  prefs: []
  type: TYPE_NORMAL
- en: Priority queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **priority queue** sorts objects in the collection based on some value or
    **priority**. Due to the natural hierarchical structure of a heap, priority queues
    are most often implemented as a heap-based queue. In this design, objects with
    a higher priority naturally sort closest to the front of the line so that, each
    time an object is dequeued, it is always the one with the highest priority. In
    the case where two or more objects share a priority, the object that has been
    in the queue longest will be dequeued first.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basic definition of the queue data structure,
    including how to initialize concrete implementations of the structure in each
    of the four languages we are discussing. Next, we discussed the most common operations
    associated with the queue data structure and their operational cost. We examined
    an example application using queues to track customers waiting in a *first-come,
    first-served* line. These examples demonstrated how C# and Java provided concrete
    implementations of a queue, whereas Objective-C and Swift do not. Following this,
    we examined the three most common types of queue implementations, including array-based,
    linked-list based, and heap-based queues. Finally, we looked at double-ended and
    priority variations of the queue data structure.
  prefs: []
  type: TYPE_NORMAL
