- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Setting Up FastAPI for Starters
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为初学者设置 FastAPI
- en: In any software development work, it is always important to first know the business
    requirement of the project and the appropriate framework, tools, and deployment
    platform to use before pursuing the task. Frameworks that are easy to understand
    and use, seamless during coding, and within standards are always picked because
    of the integrity they provide to solve problems without risking too much development
    time. And a promising Python framework called **FastAPI**, created by *Sebastian
    Ramirez*, provides experienced developers, experts, and enthusiasts the best option
    for building **REST APIs** and microservices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何软件开发工作中，了解项目的业务需求和合适的框架、工具和部署平台始终是重要的，在追求任务之前。易于理解和使用、编码过程中无缝且符合标准的框架总是被选中，因为它们提供的完整性可以在不冒太多开发风险的情况下解决问题。一个名为
    **FastAPI** 的有希望的 Python 框架，由 *Sebastian Ramirez* 创建，为经验丰富的开发者、专家和爱好者提供了构建 **REST
    APIs** 和微服务的最佳选择。
- en: But before proceeding to the core details of building microservices using FastAPI,
    it is best to first learn the building blocks of this framework, such as how it
    captures clients’ requests, how it builds the rules for each HTTP method, and
    how it manages HTTP responses. Learning the basic components is always essential
    to know the strengths and weaknesses of the framework and to what extent we can
    apply FastAPI to solve different enterprise-grade and microservices-related problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续深入探讨使用 FastAPI 构建微服务的核心细节之前，最好首先了解这个框架的构建块，例如它是如何捕获客户端请求的，如何为每个 HTTP 方法构建规则，以及如何管理
    HTTP 响应。了解基本组件始终是了解框架的优缺点以及我们可以将 FastAPI 应用于解决不同企业级和微服务相关问题的程度的关键。
- en: 'Thus, in this chapter, we’re going to have a walkthrough of the basic features
    of FastAPI by covering the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将通过涵盖以下主要主题来对 FastAPI 的基本功能进行概述：
- en: The setup of the development environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发环境的设置
- en: Initialization and configuration of FastAPI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FastAPI 的初始化和配置
- en: Design and implementation of the REST APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST API 的设计和实现
- en: Managing user requests and server response
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理用户请求和服务器响应
- en: Handling form parameters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理表单参数
- en: Handling cookies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 cookies
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The software specimen for this chapter is a prototypical administrator-managed
    *online academic discussion forum*, which is an academic discussion hub where
    alumni, teachers, and students can exchange ideas. The prototype is working but
    it is open for changes, so you can tweak the code while reading this chapter.
    It is not designed to use any database management system, but all the data is
    temporarily stored in various Python collections. All the applications in this
    book are compiled and run using *Python 3.8*. Codes are all uploaded at [https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch01](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch01).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的软件示例是一个典型的管理员管理的*在线学术讨论论坛*，这是一个学术讨论中心，校友、教师和学生可以交流想法。原型正在运行，但它是开放的，因此您可以在阅读本章时修改代码。它没有设计为使用任何数据库管理系统，但所有数据都临时存储在各种
    Python 集合中。本书中的所有应用程序都是使用 *Python 3.8* 编译和运行的。所有代码都已上传至[https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch01](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch01)。
- en: Setting up the development environment
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: 'The FastAPI framework is a fast, seamless, and robust Python framework but
    can only work on Python versions *3.6* and above. The **Integrated Development
    Environment** (**IDE**) used in this reference is **Visual Studio Code** (**VS
    Code**), which is an open source tool that we can download from this site: [https://code.visualstudio.com/](https://code.visualstudio.com/).
    Just be sure to install the VSC extensions such as *Python*, *Python for VS Code*,
    *Python Extension Pack*, *Python Indent*, and *Material Icon Theme* to provide
    your editor syntax checking, syntax highlighting, and other editor support.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 框架是一个快速、无缝且健壮的 Python 框架，但只能运行在 Python 版本 *3.6* 及以上。本参考中使用的**集成开发环境**（**IDE**）是**Visual
    Studio Code**（**VS Code**），这是一个开源工具，我们可以从以下网站下载：[https://code.visualstudio.com/](https://code.visualstudio.com/)。只需确保安装
    VSC 扩展，如 *Python*、*Python for VS Code*、*Python Extension Pack*、*Python Indent*
    和 *Material Icon Theme*，以提供您的编辑器语法检查、语法高亮和其他编辑器支持。
- en: 'After the successful installation of Python and VS Code, we can now install
    FastAPI using a terminal console. To ensure correct installation, first update
    Python’s package installer (`pip`) by running this command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功安装Python和VS Code之后，我们现在可以使用终端控制台安装FastAPI。为了确保正确安装，首先通过运行以下命令更新Python的包安装程序（`pip`）：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Afterward, we install the framework by running this series of commands:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们通过运行以下一系列命令来安装框架：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you need to install the complete FastAPI platform, including all optional
    dependencies, the appropriate command is `pip install fastapi[all]`. Likewise,
    if you want to install and utilize the full-blown `uvicorn` server, you should
    run the `pip install uvicorn` command. Also, install the `bcrypt` module for encryption-related
    tasks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要安装完整的FastAPI平台，包括所有可选依赖项，适当的命令是`pip install fastapi[all]`。同样，如果您想安装并使用完整的`uvicorn`服务器，应运行`pip
    install uvicorn`命令。此外，安装`bcrypt`模块以进行加密相关任务。
- en: At this point, you should have installed all the needed FastAPI module dependencies
    from the `uvicorn`, however, is an ASGI-based server that will run your FastAPI
    applications. The `uvicorn` server has the capability to run both synchronous
    and asynchronous services.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经安装了所有需要的FastAPI模块依赖项，从`uvicorn`开始，它是一个基于ASGI的服务器，用于运行FastAPI应用程序。`uvicorn`服务器具有运行同步和异步服务的能力。
- en: After the installation and configuration of the essential tools, modules, and
    IDE, let us now start our first API implementation using the framework.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装和配置了基本工具、模块和IDE之后，现在让我们开始使用框架进行第一个API实现。
- en: Initializing and configuring FastAPI
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化和配置FastAPI
- en: 'Learning how to create applications using FastAPI is easy and straightforward.
    A simple application can be created just by creating a `main.py` file inside your
    `/ch01` project folder. In our *online academic discussion forum*, for instance,
    the application started with this code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何使用FastAPI创建应用程序既简单又直接。只需在您的`/ch01`项目文件夹内创建一个`main.py`文件，就可以创建一个简单的应用程序。例如，在我们的*在线学术讨论论坛*中，应用程序从以下代码开始：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This initializes the FastAPI framework. The application needs to instantiate
    the core `FastAPI` class from the `fastapi` module and use `app` as the reference
    variable to the object. Then, this object is used later as a Python `@app` decorator,
    which provides our application with some features such as *routes*, *middleware*,
    *exception handlers*, and *path operations*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这初始化了FastAPI框架。应用程序需要从`fastapi`模块实例化核心`FastAPI`类，并使用`app`作为引用变量到对象。然后，这个对象在以后被用作Python
    `@app`装饰器，为我们提供一些功能，如*路由*、*中间件*、*异常处理程序*和*路径操作*。
- en: Important note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can replace `app` with your preferred but valid Python variable name, such
    as `main_app`, `forum`, or `myapp`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`app`替换为您喜欢的但有效的Python变量名，例如`main_app`、`forum`或`myapp`。
- en: Now, your application is ready to manage REST APIs that are technically Python
    functions. But to declare them as REST service methods, we need to decorate them
    with the appropriate HTTP request method provided by the path operation `@app`
    decorator. This decorator contains the `get()`, `post()`, `delete()`, `put()`,
    `head()`, `patch()`, `trace()`, and `options()` path operations, which correspond
    to the eight HTTP request methods. And these *path operations* are decorated or
    annotated on top of the Python functions that we want to handle the request and
    response.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的应用程序已准备好管理技术上是Python函数的REST API。但为了将它们声明为REST服务方法，我们需要使用路径操作`@app`装饰器提供的适当HTTP请求方法来装饰它们。这个装饰器包含`get()`、`post()`、`delete()`、`put()`、`head()`、`patch()`、`trace()`和`options()`路径操作，它们对应于八个HTTP请求方法。而且，这些*路径操作*是装饰或注释在我们想要处理请求和响应的Python函数之上的。
- en: 'In our specimen, the first sample that the REST API created was this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，REST API创建的第一个样本是：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding is a `GET` API service method that returns a `JSON` object. To
    locally run our application, we need to execute the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上述是一个返回`JSON`对象的`GET` API服务方法。为了在本地上运行我们的应用程序，我们需要执行以下命令：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command will load the forum application to the uvicorn live server through
    the application’s `main.py` file with FastAPI object referencing. Live reload
    is allowed by adding the `--reload` option, which enables the restart of the development
    server whenever there are changes in the code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将通过应用程序的`main.py`文件和FastAPI对象引用将论坛应用程序加载到uvicorn实时服务器。通过添加`--reload`选项允许实时重新加载，该选项在代码有更改时重启开发服务器。
- en: '![Figure 1.1 – The uvicorn console log](img/Figure_1.1_B17975.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – uvicorn 控制台日志](img/Figure_1.1_B17975.jpg)'
- en: Figure 1.1 – The uvicorn console log
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – uvicorn 控制台日志
- en: '*Figure 1.1* shows that uvicorn uses `localhost` to run the application with
    the default port `8000`. We can access our index page through `http://localhost:8000/ch01/index`.
    To stop the server, you just need to press the *Ctrl* + *C* keyboard keys.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1.1* 显示 uvicorn 使用 `localhost` 和默认端口 `8000` 运行应用程序。我们可以通过 `http://localhost:8000/ch01/index`
    访问我们的首页。要停止服务器，只需按下 *Ctrl* + *C* 键盘键即可。'
- en: After running our first endpoint, let us now explore how to implement the other
    types of HTTP methods, namely `POST`, `DELETE`, `PUT`, and `PATCH`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行了我们的第一个端点之后，现在让我们来探讨如何实现其他类型的 HTTP 方法，即 `POST`、`DELETE`、`PUT` 和 `PATCH`。
- en: Designing and implementing REST APIs
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计和实现 REST API
- en: The **Representation State Transfer** (**REST**) API makes up the rules, processes,
    and tools that allow interaction among microservices. These are method services
    that are identified and executed through their endpoint URLs. Nowadays, focusing
    on API methods before building a whole application is one of the most popular
    and effective microservices design strategies. This approach, called an **API-first**
    microservices development, focuses first on the client’s needs and then later
    identifies what API service methods we need to implement for these client requirements.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**表示状态转移**（**REST**）API 包含了允许微服务之间交互的规则、流程和工具。这些是通过它们的端点 URL 识别和执行的方法服务。如今，在构建整个应用程序之前先关注
    API 方法是微服务设计中最流行和最有效的方法之一。这种方法称为 **API 首选** 微服务开发，首先关注客户端的需求，然后确定我们需要实现哪些 API
    服务方法来满足这些客户端需求。'
- en: In our *online academic discussion forum* app, software functionality such as
    *user sign-up*, *login*, *profile management*, *message posting*, and *managing
    post replies* are some of the crucial needs we prioritized. In a FastAPI framework,
    these features are implemented as services using functions that are defined using
    Python’s `def` keyword, with the association of the appropriate HTTP request method
    through the *path operations* provided by `@app`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 *在线学术讨论论坛* 应用中，像 *用户注册*、*登录*、*个人资料管理*、*发帖* 和 *管理帖子回复* 这样的软件功能是我们优先考虑的关键需求。在
    FastAPI 框架中，这些功能是通过使用 Python 的 `def` 关键字定义的函数实现的，并通过 `@app` 提供的 *路径操作* 关联适当的 HTTP
    请求方法。
- en: 'The `login` service, which requires `username` and `password` request parameters
    from the user, is implemented as a `GET` API method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 需要从用户那里获取 `username` 和 `password` 请求参数的 `login` 服务，被实现为一个 `GET` API 方法：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This *login* service uses bcrypt’s `checkpw()` function to check whether the
    password of the user is valid. Conversely, the *sign-up* service, which also requires
    user credentials from the client in the form of request parameters, is created
    as a `POST` API method:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 *login* 服务使用 bcrypt 的 `checkpw()` 函数来检查用户的密码是否有效。相反，同样需要从客户端以请求参数形式获取用户凭证的
    *sign-up* 服务，被创建为一个 `POST` API 方法：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Among the *profile management* services, the following `update_profile()` service
    serves as a `PUT` API service, which requires the user to use an entirely new
    model object for profile information replacement and the client’s username to
    serve as the key:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *个人资料管理* 服务中，以下 `update_profile()` 服务作为一个 `PUT` API 服务，要求用户使用一个全新的模型对象来替换个人资料信息，并且客户端的用户名作为键：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Not all services that carry out updates are `PUT` API methods, such as the
    following `update_profile_name()` service, which only requires the user to submit
    a new first name, last name, and middle initial for partial replacement of a client’s
    profile. This HTTP request, which is handier and more lightweight than a full-blown
    `PUT` method, only requires a `PATCH` action:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有执行更新的服务都是 `PUT` API 方法，例如以下 `update_profile_name()` 服务，它只要求用户提交新的名字、姓氏和中间名以部分替换客户端的个人资料。这个比完整的
    `PUT` 方法更方便、更轻量级的 HTTP 请求，只需要一个 `PATCH` 操作：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The last essential HTTP services that we included before building the application
    are the `DELETE` API methods. We use these services to delete records or information
    given a unique identification, such as `username` and a hashed `id`. An example
    is the following `delete_post_discussion()` service that allows a user to delete
    a posted discussion when given a username and the UUID (Universally Unique Identifier)
    of the posted message:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序之前，我们包括的最后必要 HTTP 服务是 `DELETE` API 方法。我们使用这些服务根据唯一的标识符（如 `username` 和散列的
    `id`）删除记录或信息。以下是一个示例 `delete_post_discussion()` 服务，允许用户在提供用户名和发布消息的 UUID（通用唯一标识符）时删除发布的讨论：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All path operations require a unique endpoint URL in the `str` format. A good
    practice is to start all URLs with the same top-level base path, such as `/ch01`,
    and then differ when reaching their respective subdirectories. After running the
    uvicorn server, we can check and validate whether all our URLs are valid and running
    by accessing the documentation URL, `http://localhost:8000/docs`. This path will
    show us a **OpenAPI** dashboard, as shown in *Figure 1.2*, listing all the API
    methods created for the application. Discussions on the OpenAPI will be covered
    in [*Chapter 9*](B17975_09.xhtml#_idTextAnchor266)*, Utilizing Other Advanced
    Features*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有路径操作都需要一个唯一的端点 URL，格式为 `str`。一个好的做法是让所有 URL 都以相同的顶级基础路径开始，例如 `/ch01`，然后在到达各自的子目录时进行区分。在运行
    uvicorn 服务器后，我们可以通过访问文档 URL `http://localhost:8000/docs` 来检查和验证我们所有的 URL 是否有效且正在运行。此路径将显示如图
    *图 1.2* 所示的 **OpenAPI** 仪表板，列出为应用程序创建的所有 API 方法。关于 OpenAPI 的讨论将在 [*第 9 章*](B17975_09.xhtml#_idTextAnchor266)
    *利用其他高级功能* 中介绍。
- en: '![Figure 1.2 – A Swagger OpenAPI dashboard](img/Figure_1.2_B17975.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – Swagger OpenAPI 仪表板](img/Figure_1.2_B17975.jpg)'
- en: Figure 1.2 – A Swagger OpenAPI dashboard
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – Swagger OpenAPI 仪表板
- en: After creating the endpoint services, let us scrutinize how FastAPI manages
    its incoming request body and the outgoing response.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建端点服务后，让我们仔细看看 FastAPI 如何管理其传入的请求体和传出的响应。
- en: Managing user requests and server response
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户请求和服务器响应
- en: Clients can pass their request data to FastAPI endpoint URLs through path parameters,
    query parameters, or headers to pursue service transactions. There are standards
    and ways to use these parameters to obtain incoming requests. Depending on the
    goal of the services, we use these parameters to influence and build the necessary
    responses the clients need. But before we discuss these various parameter types,
    let us explore first how we use *type hinting* in FastAPI’s local parameter declaration.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以通过路径参数、查询参数或头信息将他们的请求数据传递给 FastAPI 端点 URL，以进行服务事务。有标准和方式使用这些参数来获取传入的请求。根据服务目标，我们使用这些参数来影响和构建客户端需要的必要响应。但在我们讨论这些各种参数类型之前，让我们首先探索如何在
    FastAPI 的局部参数声明中使用 *类型提示*。
- en: Parameter type declaration
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数类型声明
- en: All request parameters are required to be type-declared in the method signature
    of the service method applying the `None`, `bool`, `int`, and `float` and container
    types such as `list`, `tuple`, `dict`, `set`, `frozenset`, and `deque`. Other
    complex Python types such as `datetime.date`, `datetime.time`, `datetime.datetime`,
    `datetime.delta`, `UUID`, `bytes`, and `Decimal` are also supported.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有请求参数都必须在服务方法的参数签名中声明类型，应用 `None`、`bool`、`int` 和 `float` 以及容器类型，如 `list`、`tuple`、`dict`、`set`、`frozenset`
    和 `deque`。还支持其他复杂的 Python 类型，如 `datetime.date`、`datetime.time`、`datetime.datetime`、`datetime.delta`、`UUID`、`bytes`
    和 `Decimal`。
- en: The framework also supports the data types included in Python’s `typing` module,
    responsible for *type hints*. These data types are standard notations for Python
    and variable type annotations that can help to pursue type checking and model
    validation during compilation, such as `Optional`, `List`, `Dict`, `Set`, `Union`,
    `Tuple`, `FrozenSet`, `Iterable`, and `Deque`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架还支持 Python 的 `typing` 模块中包含的数据类型，这些数据类型负责 *类型提示*。这些数据类型是 Python 的标准表示法，以及变量类型注释，有助于在编译期间进行类型检查和模型验证，例如
    `Optional`、`List`、`Dict`、`Set`、`Union`、`Tuple`、`FrozenSet`、`Iterable` 和 `Deque`。
- en: Path parameters
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径参数
- en: FastAPI allows you to obtain request data from the endpoint URL of an API through
    a path parameter or path variable that makes the URL somewhat dynamic. This parameter
    holds a value that becomes part of a URL indicated by curly braces (`{}`). After
    setting off these path parameters within the URL, FastAPI requires these parameters
    to be declared by applying *type hints*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 允许您通过 API 的端点 URL 的路径参数或路径变量来获取请求数据，这使得 URL 变得有些动态。这个参数持有一个值，该值成为由花括号
    (`{}`) 指示的 URL 的一部分。在 URL 中设置这些路径参数之后，FastAPI 需要通过应用 *类型提示* 来声明这些参数。
- en: 'The following `delete_user()` service is a `DELETE` API method that uses a
    `username` path parameter to search for a login record for deletion:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `delete_user()` 服务是一个使用 `username` 路径参数来搜索用于删除的登录记录的 `DELETE` API 方法：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Multiple path parameters are acceptable if the leftmost variables are more
    likely to be filled with values than the rightmost variables. In other words,
    the importance of the leftmost path variables will make the process more relevant
    and correct than those on the right. This standard is applied to ensure that the
    endpoint URL will not look like other URLs, which might cause some conflicts and
    confusion. The following `login_with_token()` service follows this standard, since
    `username` is a primary key and is as strong as, or even stronger than, its next
    parameter, `password`. There is an assurance that the URL will always look unique
    every time the endpoint is accessed because `username` will always be required,
    as well as `password`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最左边的变量更有可能被填充值，则可以接受多个路径参数。换句话说，最左边的路径变量的重要性将使过程比右边的更相关和正确。这个标准应用于确保端点 URL
    不会看起来像其他 URL，这可能会引起一些冲突和混淆。以下 `login_with_token()` 服务遵循这个标准，因为 `username` 是主键，其强度与下一个参数
    `password` 相当，甚至更强。可以保证每次访问端点时 URL 总是唯一的，因为 `username` 总是需要的，以及 `password`：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Unlike other web frameworks, FastAPI is not friendly with endpoint URLs that
    belong to base paths or top-level domain paths with different subdirectories.
    This occurrence happens when we have dynamic URL patterns that look the same as
    the other fixed endpoint URLs when assigned a specific path variable. These fixed
    URLs are implemented sequentially after these dynamic URLs. An example of these
    are the following services:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他 Web 框架不同，FastAPI 对属于基本路径或顶级域名路径的不同子目录的端点 URL 不友好。这种情况发生在我们具有动态 URL 模式，当分配一个特定的路径变量时，看起来与其他固定端点
    URL 相同。这些固定 URL 在这些动态 URL 之后依次实现。以下服务是这些服务的例子：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will give us an *HTTP Status Code 422* (*Unprocessable Entity*) when accessing
    `http://localhost:8080/ch01/login/details/info`. There should be no problem accessing
    the URL, since the API service is almost a stub or trivial JSON data. What happened
    in this scenario is that the fixed path’s `details` and `info` path directories
    were treated as `username` and `password` parameter values, respectively. Because
    of confusion, the built-in data validation of FastAPI will show us a JSON-formatted
    error message that says, `{"detail":[{"loc":["query","id"],"msg":"field required","type":"value_error.missing"}]}`.
    To fix this problem, all fixed paths should be declared first before the dynamic
    endpoint URLs with path parameters. Thus, the preceding `login_info()` service
    should be declared first before `login_with_token()`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问 `http://localhost:8080/ch01/login/details/info` 时，这将给我们一个 *HTTP 状态码 422*
    (*不可处理实体*)。由于 API 服务几乎是一个占位符或简单的 JSON 数据，因此访问 URL 应该没有问题。在这个场景中发生的情况是，固定路径的 `details`
    和 `info` 路径目录被分别视为 `username` 和 `password` 参数值。由于混淆，FastAPI 的内置数据验证将显示一个 JSON
    格式的错误消息，内容为：`{"detail":[{"loc":["query","id"],"msg":"field required","type":"value_error.missing"}]}`。要解决这个问题，所有固定路径应该在带有路径参数的动态端点
    URL 之前声明。因此，`login_info()` 服务应该在 `login_with_token()` 之前声明。
- en: Query parameters
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询参数
- en: 'A query parameter is a *key–value* pair supplied after the end of an endpoint
    URL, indicated by a question mark (`?`). Just like the path parameter, this also
    holds the request data. An API service can manage a series of query parameters
    separated by an ampersand (`&`). Like in path parameters, all query parameters
    are also declared in the service method. The following *login* service is a perfect
    specimen that uses query parameters:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数是一个在端点 URL 末尾提供的 *键值对*，由问号 (`?`) 表示。就像路径参数一样，这也持有请求数据。API 服务可以管理一系列由 ampersand
    (`&`) 分隔的查询参数。就像在路径参数中一样，所有查询参数也在服务方法中声明。以下 *login* 服务是一个使用查询参数的完美示例：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `login` service method uses `username` and `password` as query parameters
    in the `str` types. Both are required parameters, and assigning them with `None`
    as parameter values will give a compiler error.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`login`服务方法使用`username`和`password`作为`str`类型的查询参数。这两个都是必填参数，将它们分配给`None`作为参数值将导致编译器错误。'
- en: 'FastAPI supports query parameters that are complex types, such as `list` and
    `dict`. But these Python collection types cannot specify the type of objects to
    store unless we apply the *generic type hints* for Python collections. The following
    `delete_users()` and `update_profile_names()` APIs use generic type hints, `List`
    and `Dict`, in declaring query parameters that are container types with type checking
    and data validation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI支持复杂类型的查询参数，例如`list`和`dict`。但是，除非我们为Python集合应用*泛型类型提示*，否则这些Python集合类型无法指定要存储的对象类型。以下`delete_users()`和`update_profile_names()`API使用泛型类型提示`List`和`Dict`来声明具有类型检查和数据验证的容器类型查询参数：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: FastAPI also allows you to explicitly assign default values to service function
    parameters.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI还允许您明确地为服务函数参数分配默认值。
- en: Default parameters
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认参数
- en: 'There are times that we need to specify default values to the query parameter(s)
    and path parameter(s) of some API services to avoid validation error messages
    such as `field required` and `value_error.missing`. Setting default values to
    parameters will allow the execution of an API method with or without supplying
    the parameter values. Depending on the requirement, assigned default values are
    usually `0` for numeric types, `False` for bool types, empty string for string
    types, an empty list (`[]`) for List types, and an empty dictionary (`{}`) for
    `Dict` types. The following `delete pending users()` and `change_password()` services
    show us how to apply default values to the query parameter(s) and path parameter(s):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要为某些API服务的查询参数和路径参数指定默认值，以避免出现诸如`字段必填`和`value_error.missing`之类的验证错误信息。为参数设置默认值将允许在提供或不提供参数值的情况下执行API方法。根据需求，分配的默认值通常是数值类型的`0`，布尔类型的`False`，字符串类型的空字符串，列表类型的空列表（`[]`），以及字典类型的空字典（`{}`）。以下`delete
    pending users()`和`change_password()`服务展示了如何将默认值应用于查询参数和路径参数：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`delete_pending_users()` can be executed even without passing any accounts
    argument, since accounts will be always an empty `List` by default. Likewise,
    `change_password()` can still continue its process without passing any `old_passwd`
    and `new_passw`, since they are both always defaulted to empty `str`. `hashpw()`
    is a `bcrypt` utility function that generates a hashed passphrase from an autogenerated
    *salt*.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete_pending_users()`可以在不传递任何`accounts`参数的情况下执行，因为`accounts`默认总是一个空列表（`List`）。同样，`change_password()`也可以在不需要传递任何`old_passwd`和`new_passw`的情况下继续其过程，因为它们都默认为空字符串（`str`）。`hashpw()`是一个`bcrypt`实用函数，它从自动生成的*盐*生成散列密码。'
- en: Optional parameters
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选参数
- en: 'If the *path* and/or *query parameter(s)* of a service is/are not necessarily
    needed to be supplied by the user, meaning the API transactions can proceed with
    or without their inclusion in the request transaction, then we set them as *optional*.
    To declare an optional parameter, we need to import the `Optional` type from the
    `typing` module and then use it to set the parameter. It should wrap the supposed
    data type of the parameter using brackets (`[]`) and can have *any default value*
    if needed. Assigning the `Optional` parameter to a `None` value indicates that
    its exclusion from the parameter passing is allowed by the service, but it will
    hold a `None` value. The following services depict the use of optional parameters:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务的*路径*和/或*查询参数*不是必须由用户提供的，意味着API事务可以在请求事务中包含或不包含它们的情况下进行，那么我们将它们设置为*可选的*。为了声明一个可选参数，我们需要从`typing`模块导入`Optional`类型，然后使用它来设置参数。它应该使用括号（`[]`）包装参数的预期数据类型，如果需要，可以具有*任何默认值*。将`Optional`参数分配给`None`值表示服务允许从参数传递中排除它，但它将保留`None`值。以下服务展示了可选参数的使用：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the *online academic discussion forum* application, we have services such
    as the preceding `unlock_username()` and `unlock_password()` services that declare
    all their parameters as `optional`. Just do not forget to apply exception handling
    or defensive validation in your implementation when dealing with these kinds of
    parameters to avoid *HTTP Status 500* (*Internal Server Error*).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *在线学术讨论论坛* 应用中，我们有一些服务，如前述的 `unlock_username()` 和 `unlock_password()` 服务，它们将所有参数声明为
    `可选`。只是不要忘记在处理这些类型的参数时在你的实现中应用异常处理或防御性验证，以避免 *HTTP 状态 500* (*内部服务器错误*)。
- en: Important note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The FastAPI framework does not allow you to directly assign the `None` value
    to a parameter just to declare an *optional* parameter. Although this is allowed
    with the old Python behavior, this is no longer recommended in the current Python
    versions for the purpose of built-in type checking and model validation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 框架不允许你直接将 `None` 值分配给参数以声明一个 *可选* 参数。尽管在旧的 Python 行为中这是允许的，但在当前的 Python
    版本中，出于内置类型检查和模型验证的目的，不再推荐这样做。
- en: Mixing all types of parameters
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合所有类型的参数
- en: 'If you are planning to implement an API service method that declares optional,
    required, and default query and path parameters altogether, you can pursue it
    because the framework supports it, but approach it with some caution due to some
    standards and rules:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划实现一个声明可选、必需和默认查询和路径参数的 API 服务方法，你可以这样做，因为框架支持它，但出于一些标准和规则，需要谨慎处理：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The updated version of the preceding `update_profile_names()` service declares
    a `username` path parameter, a `UUID` id query parameter, and an optional `Dict[str,
    str]` type. With mixed parameter types, all required parameters should be declared
    first, followed by default parameters, and last in the parameter list should be
    the optional types. Disregarding this ordering rule will generate a *compiler
    error*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前述 `update_profile_names()` 服务更新的版本声明了一个 `username` 路径参数，一个 `UUID` id 查询参数，以及一个可选的
    `Dict[str, str]` 类型。在混合参数类型的情况下，所有必需参数应首先声明，然后是默认参数，最后在参数列表中是可选类型。忽略此排序规则将生成一个
    *编译器错误*。
- en: Request body
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求体
- en: A *request body* is a body of data in bytes transmitted from a client to a server
    through a `POST`, `PUT`, `DELETE`, or `PATCH` HTTP method operation. In FastAPI,
    a service must declare a model object to represent and capture this request body
    to be processed for further results.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*请求体* 是通过 `POST`、`PUT`、`DELETE` 或 `PATCH` HTTP 方法操作从客户端传输到服务器的字节数据体。在 FastAPI
    中，一个服务必须声明一个模型对象来表示和捕获这个请求体，以便进行进一步的处理。'
- en: 'To implement a model class for the *request body*, you should first import
    the `BaseModel` class from the `pydantic` module. Then, create a subclass of it
    to utilize all the properties and behavior needed by the path operation in capturing
    the request body. Here are some of the data models used by our application:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个用于 *请求体* 的模型类，你应该首先从 `pydantic` 模块导入 `BaseModel` 类。然后，创建它的子类以利用路径操作在捕获请求体时所需的所有属性和行为。以下是我们应用程序使用的一些数据模型：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The attributes of the model classes must be explicitly declared by applying
    *type hints* and utilizing the common and complex data types used in the parameter
    declaration. These attributes can also be set as required, default, and optional,
    just like in the parameters.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 模型类的属性必须通过应用 *类型提示* 和利用在参数声明中使用的常见和复杂数据类型来显式声明。这些属性也可以设置为必需、默认和可选，就像在参数中一样。
- en: 'Moreover, the `pydantic` module allows the creation of nested models, even
    the deeply nested ones. A sample of these is shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`pydantic` 模块允许创建嵌套模型，甚至是深度嵌套的模型。这里展示了一个这样的示例：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As seen in the preceding code, we have a `ForumPost` model, which has a `PostType`
    model attribute, and `ForumDiscussion`, which has a `List` attribute of `ForumPost`,
    a `ForumPost` model attribute, and a `UserProfile` attribute. This kind of model
    blueprint is called a *nested model approach*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们有一个 `ForumPost` 模型，它有一个 `PostType` 模型属性，以及 `ForumDiscussion`，它有一个
    `List` 属性为 `ForumPost`，一个 `ForumPost` 模型属性和一个 `UserProfile` 属性。这种模型蓝图被称为 *嵌套模型方法*。
- en: 'After creating these model classes, you can now *inject* these objects into
    the services that are intended to capture the *request body* from the clients.
    The following services utilize our `User` and `UserProfile` model classes to manage
    the request body:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这些模型类之后，你现在可以将这些对象注入到旨在从客户端捕获 *请求体* 的服务中。以下服务利用我们的 `User` 和 `UserProfile`
    模型类来管理请求体：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Models can be declared *required*, with a *default* instance value, or *optional*
    in the service method, depending on the specification of the API. Missing or incorrect
    details such as `invalid password` or `None` values in the `approve_user()` service
    will emit the *Status Code 500* (*Internal Server Error*). How FastAPI handles
    exceptions will be part of [*Chapter 2*](B17975_02.xhtml#_idTextAnchor033)*,*
    *Exploring the Core Features,* discussions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 API 的规范，模型可以在服务方法中声明为 *必需的*、带有 *默认实例值* 或 *可选的*。在 `approve_user()` 服务中缺少或错误的详细信息，如
    `invalid password` 或 `None` 值，将触发 *状态码 500* (*内部服务器错误*)。FastAPI 如何处理异常将是 *第 2
    章* (*Exploring the Core Features*) 讨论的一部分。
- en: Important note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There are two essential points we need to emphasize when dealing with `BaseModel`
    class types. First, the `pydantic` module has a built-in JSON encoder that converts
    the JSON-formatted request body to the `BaseModel` object. So, there is no need
    create a custom converter to map the request body to the `BaseModel` model. Second,
    to instantiate a `BaseModel` class, all its required attributes must be initialized
    immediately through the constructor’s named parameters.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 `BaseModel` 类类型时，我们需要强调两个基本点。首先，`pydantic` 模块有一个内置的 JSON 编码器，它将 JSON 格式的请求体转换为
    `BaseModel` 对象。因此，无需创建自定义转换器来将请求体映射到 `BaseModel` 模型。其次，要实例化 `BaseModel` 类，必须通过构造函数的命名参数立即初始化其所有必需的属性。
- en: Request headers
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求头
- en: In a request-response transaction, it is not only the parameters that are accessible
    by the REST API methods but also the information that describes the context of
    the client where the request originated. Some common request headers such as `User-Agent`,
    `Host`, `Accept`, `Accept-Language`, `Accept-Encoding`, `Referer`, and `Connection`
    usually appear with request parameters and values during request transactions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求-响应事务中，不仅可以通过 REST API 方法访问参数，还可以访问描述请求来源客户端上下文的信息。一些常见的请求头，如 `User-Agent`、`Host`、`Accept`、`Accept-Language`、`Accept-Encoding`、`Referer`
    和 `Connection` 通常在请求事务中与请求参数和值一起出现。
- en: To access a request header, import first the `Header` function from the `fastapi`
    module. Then, declare the variable that has the same name as the header in the
    method service as `str` types and initialize the variable by calling the `Header(None)`
    function. The `None` argument enables the `Header()` function to declare the variable
    optionally, which is a best practice. For hyphenated request header names, the
    hyphen (`-`) should be converted to an underscore (`_`); otherwise, the Python
    compiler will flag a syntax error message. It is the task of the `Header()` function
    to convert the underscore (`_`) to a hyphen (`-`) during request header processing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问请求头，首先从 `fastapi` 模块导入 `Header` 函数。然后，在方法服务中声明与头名称相同的变量为 `str` 类型，并通过调用 `Header(None)`
    函数初始化变量。`None` 参数使 `Header()` 函数能够可选地声明变量，这是一种最佳实践。对于带有连字符的请求头名称，连字符 (`-`) 应转换为下划线
    (`_`)；否则，Python 编译器将标记语法错误消息。在请求头处理期间，将下划线 (`_`) 转换为连字符 (`-`) 是 `Header()` 函数的任务。
- en: 'Our online academic discussion forum application has a `verify_headers()` service
    that retrieves core request headers needed to verify a client’s access to the
    application:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的在线学术讨论论坛应用程序有一个 `verify_headers()` 服务，用于检索验证客户端访问应用程序所需的核心请求头：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Important note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Non-inclusion of the `Header()` function call in the declaration will let FastAPI
    treat the variables as *query parameters*. Be cautious also with the spelling
    of the local parameter names, since they *are* the request header names per se
    except for the underscore.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明中省略 `Header()` 函数调用将让 FastAPI 将变量视为 *查询参数*。同时也要注意本地参数名称的拼写，因为它们本身就是请求头名称，除了下划线之外。
- en: Response data
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应数据
- en: All API services in FastAPI should return `JSON` data, or it will be invalid
    and may return `None` by default. These responses can be formed using `dict`,
    `BaseModel`, or `JSONResponse` objects. Discussions on `JSONResponse` will be
    discussed in the succeeding chapters.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 中的所有 API 服务都应该返回 `JSON` 数据，否则将无效，默认可能返回 `None`。这些响应可以使用 `dict`、`BaseModel`
    或 `JSONResponse` 对象形成。关于 `JSONResponse` 的讨论将在后续章节中讨论。
- en: 'The `pydantic` module’s built-in JSON converter will manage the conversion
    of these custom responses to a JSON object, so there is no need to create a custom
    JSON encoder:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`pydantic` 模块的内置 JSON 转换器将管理将这些自定义响应转换为 JSON 对象，因此无需创建自定义 JSON 编码器：'
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding `post_discussion()` service returns two different hardcoded `dict`
    objects, with `message` as the key and an instantiated `ForumDiscussion` model.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`post_discussion()`服务返回两个不同的硬编码的`dict`对象，以`message`作为键和一个实例化的`ForumDiscussion`模型。
- en: 'On the other hand, this framework allows us to specify the return type of a
    service method. The setting of the return type happens in the `response_model`
    attribute of any of the `@app` path operations. Unfortunately, the parameter only
    recognizes `BaseModel` class types:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这个框架允许我们指定服务方法的返回类型。返回类型的设置发生在任何`@app`路径操作的`response_model`属性中。不幸的是，该参数只识别`BaseModel`类类型：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding `approve_user()` service specifies the required return of the
    API method, which is `ValidUser`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`approve_user()`服务指定了API方法的必需返回值，即`ValidUser`。
- en: Now, let us explore how FastAPI handles form parameters.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索FastAPI如何处理表单参数。
- en: Handling form parameters
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理表单参数
- en: When API methods are designed to handle web forms, the services involved are
    required to retrieve form parameters instead of the request body because this
    form data is normally encoded as an `application/x-www-form-urlencoded` media
    type. These form parameters are conventionally `string` types, but the `pydantic`
    module’s JSON encoder can convert each parameter value to its respective valid
    type.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当API方法设计为处理Web表单时，相关的服务需要检索表单参数而不是请求体，因为这种表单数据通常编码为`application/x-www-form-urlencoded`媒体类型。这些表单参数通常是`string`类型，但`pydantic`模块的JSON编码器可以将每个参数值转换为相应的有效类型。
- en: 'All the form parameter variables can be declared *required*, with *default*
    values, or *optional* using the same set of Python types we used previously. Then,
    the `fastapi` module has a `Form` function that needs to be imported to initialize
    these form parameter variables during their declaration. To set these form parameters
    as *required*, the `Form()` function must have the ellipses (`…`) argument, thus
    calling it as `Form(…)`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有表单参数变量都可以声明为*必需的*，带有*默认值*，或者使用我们之前使用的相同Python类型来声明为*可选的*。然后，`fastapi`模块有一个`Form`函数，需要在声明时导入以初始化这些表单参数变量。要将这些表单参数设置为*必需的*，`Form()`函数必须包含省略号（`…`）参数，因此调用它为`Form(…)`：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding `add_profile()` service shows us how to call the `Form(…)` function
    to return a `Form` object during the parameter declaration.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`add_profile()`服务展示了如何调用`Form(…)`函数在参数声明期间返回一个`Form`对象。
- en: Important note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Form-handling services will not work if the `python-multipart` module is not
    installed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有安装`python-multipart`模块，表单处理服务将无法工作。
- en: Sometimes, we need browser cookies to establish an identity for our application,
    leave trails in the browser for every user transaction, or store product information
    for a purpose. If FastAPI can manage form data, it can also do the same with cookies.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要浏览器cookies来为我们的应用程序建立身份，为每个用户交易在浏览器中留下痕迹，或者为了某种目的存储产品信息。如果FastAPI可以管理表单数据，它也可以对cookies做同样的事情。
- en: Managing cookies
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理cookies
- en: A *cookie* is a piece of information stored in the browser to pursue some purpose,
    such as login user authorization, web agent response generation, and session handling-related
    tasks. One cookie is always a key-value pair that are both string types.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*cookie*是存储在浏览器中用于追求某些目的的信息片段，例如登录用户授权、网络代理响应生成和会话处理相关任务。一个cookie始终是一个键值对，都是字符串类型。'
- en: FastAPI allows services to create cookies individually through the `Response`
    library class from its `fastapi` module. To use it, it needs to appear as the
    first local parameter of the service, but we do not let the application or client
    pass an argument to it. Using the dependency injection principle, the framework
    will provide the `Response` instance to the service and not the application. When
    the service has other parameters to declare, the additional declaration should
    happen right after the declaration of the `Response` parameter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI允许服务通过其`fastapi`模块的`Response`库类单独创建cookies。要使用它，它需要作为服务的第一个局部参数出现，但我们不允许应用程序或客户端向它传递参数。使用依赖注入原则，框架将为服务提供`Response`实例，而不是应用程序。当服务有其他参数要声明时，附加声明应紧接在`Response`参数声明之后发生。
- en: 'The `Response` object has a `set_cookie()` method that contains two required
    named parameters: the *key*, which sets the cookie name, and the *value*, which
    stores the cookie value. This method only generates one cookie and stores it in
    the browser afterward:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response` 对象有一个 `set_cookie()` 方法，其中包含两个必需的命名参数：*key*，用于设置 cookie 名称，和 *value*，用于存储
    cookie 值。此方法仅生成一个 cookie 并随后存储在浏览器中：'
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding `create_cookies()` method shows us the creation of *remember-me
    tokens* such as `userkey` and `identity` for the *remember-me* authorization of
    our *online academic discussion forum* project.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `create_cookies()` 方法向我们展示了如何为 *remember-me* 授权创建 *remember-me tokens*，例如
    `userkey` 和 `identity`，用于我们的 *在线学术讨论论坛* 项目。
- en: 'To retrieve these cookies, local parameters that have the same name as the
    cookies are declared in the service method as `str` types, since cookie values
    are always strings. As with `Header` and `Form`, the `fastapi` module also provides
    a `Cookie` function that is needed to initialize each declared cookie parameter
    variable. The `Cookie()` function should always have the `None` argument to set
    the parameters optionally, ensuring that the API method executes without problems
    whenever the headers are not present in the request transaction. The following
    `access_cookie()` service retrieves all the *remember-me* authorization cookies
    created by the previous service:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索这些 cookies，在服务方法中声明与 cookies 同名的本地参数为 `str` 类型，因为 cookie 值始终是字符串。与 `Header`
    和 `Form` 类似，`fastapi` 模块还提供了一个 `Cookie` 函数，用于初始化每个声明的 cookie 参数变量。`Cookie()` 函数应始终带有
    `None` 参数，以可选地设置参数，确保当请求事务中不存在头信息时，API 方法能够无问题执行。以下 `access_cookie()` 服务检索了之前服务创建的所有
    *remember-me* 授权 cookies：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter is essential to familiarize ourselves with FastAPI and understand
    its basic components. The concept that we can get from this chapter can measure
    how much adjustment and effort we need to invest into translating or rewriting
    some existing applications to FastAPI. Knowing its basics will help us learn how
    to install its modules, structure the project directories, and learn the core
    library classes and functions needed to build a simple enterprise-grade application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本章对于熟悉 FastAPI 并理解其基本组件至关重要。从本章中我们可以获得的概念可以衡量我们需要投入多少调整和努力来翻译或重写一些现有的应用程序以适应
    FastAPI。了解其基础知识将帮助我们学习如何安装其模块、结构化项目目录，以及学习构建简单企业级应用程序所需的核心库类和函数。
- en: With the help of our recipe *online academic discussion forum* application,
    this chapter showed us how to build different REST APIs associated with HTTP methods
    using the FastAPI module class and Python `def` functions. From there, we learned
    how to capture incoming request data and headers using the local parameters of
    the API methods and how these API methods should return a response to the client.
    And through this chapter, we saw how easy it is for FastAPI to capture form data
    from `<form></form>` of any UI templates and that is using the `Form` function.
    Aside from the `Form` function, the FastAPI module also has the `Cookie` function
    to help us create and retrieve cookies from the browser, and `Header` to retrieve
    the request header part of an incoming request transaction.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 *在线学术讨论论坛* 应用程序的帮助下，本章向我们展示了如何使用 FastAPI 模块类和 Python `def` 函数构建与 HTTP 方法相关的不同
    REST APIs。从那里，我们学习了如何使用 API 方法的本地参数捕获传入的请求数据和头信息，以及这些 API 方法应该如何向客户端返回响应。通过本章，我们看到了
    FastAPI 如何轻松地捕获来自任何 UI 模板 `<form></form>` 的表单数据，这是使用 `Form` 函数实现的。除了 `Form` 函数之外，FastAPI
    模块还有一个 `Cookie` 函数，帮助我们创建和检索浏览器中的 cookies，以及 `Header` 用于检索传入请求事务的请求头部分。
- en: Overall, this chapter has prepared us for advanced discussions that will center
    on other features of FastAPI that can help us upgrade our simple applications
    to full-blown ones. The next chapter will cover these essential core features,
    which will provide our application with the needed response encoder and generator,
    exception handlers, middleware, and other components related to asynchronous transactions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，本章为我们准备了高级讨论，这些讨论将集中在 FastAPI 的其他功能上，这些功能可以帮助我们将简单应用程序升级为完整的应用程序。下一章将涵盖这些核心功能，这些功能将为我们的应用程序提供所需响应编码器、生成器、异常处理程序、中间件以及其他与异步事务相关的组件。
