["```py\n def create_app(config_file):\n    app = Flask(__name__)\n    app.config.from_file(config_file, toml.load)\n    init_db()\n    configure_logger('log_msg.txt')\n    with app.app_context():\n        from app.api import index\n        … … … … … … …\n        from app.api import orders\n    return app\n```", "```py\n<st c=\"4319\">@current_app.route(\"/index\", methods = ['GET'])</st> def index():\n   response = <st c=\"4392\">make_response</st>(<st c=\"4407\">jsonify</st>(message='This is an Online Pizza Ordering System.', today=date.today()), 200) <st c=\"4515\">index()</st> function, found in the <st c=\"4546\">app/api/index.py</st> module, is exactly similar to the web-based view function, except that <st c=\"4634\">make_response()</st> requires the <st c=\"4663\">jsonify()</st> instead of the <st c=\"4688\">render_template()</st> method.\n\t\t\t<st c=\"4713\">The</st> `<st c=\"4718\">jsonify()</st>` <st c=\"4727\">is a Flask utility method that serializes any data to produce an</st> `<st c=\"4793\">application/json</st>` <st c=\"4809\">response.</st> <st c=\"4820\">It converts</st> *<st c=\"4832\">multiple values</st>* <st c=\"4847\">into an</st> *<st c=\"4856\">array of data</st>* <st c=\"4869\">and</st> *<st c=\"4874\">key-value pairs</st>* <st c=\"4889\">to a</st> *<st c=\"4895\">dictionary</st>*<st c=\"4905\">. It can also accept a</st> *<st c=\"4928\">single-valued</st>* <st c=\"4941\">entry.</st> <st c=\"4949\">The</st> `<st c=\"4953\">jsonify()</st>` <st c=\"4962\">in the given</st> `<st c=\"4976\">index()</st>` <st c=\"4983\">function converts its arguments into a dictionary before calling Python’s</st> `<st c=\"5058\">json.dumps()</st>` <st c=\"5070\">method.</st> <st c=\"5079\">After</st> `<st c=\"5085\">json.dumps()</st>`<st c=\"5097\">’s JSON serialization,</st> `<st c=\"5121\">jsonify()</st>` <st c=\"5130\">will contain and render the result as part of</st> `<st c=\"5177\">Response</st>` <st c=\"5185\">with a mime-type of</st> `<st c=\"5206\">application/json</st>` <st c=\"5222\">instead of a plain JSON string.</st> <st c=\"5255\">Thus, running the given</st> `<st c=\"5279\">/index</st>` <st c=\"5285\">endpoint with the</st> `<st c=\"5304\">curl -i</st>` <st c=\"5311\">command will generate the following request</st> <st c=\"5356\">header result:</st>\n\t\t\t![Figure 3.2 – Running the /index endpoint using cURL](img/B19383_03_2.jpg)\n\n\t\t\t<st c=\"5653\">Figure 3.2 – Running the /index endpoint using cURL</st>\n\t\t\t<st c=\"5704\">The response body</st> <st c=\"5723\">provided by running the curl command against</st> `<st c=\"5768\">/index</st>` <st c=\"5774\">has a message body and response headers composed of</st> `<st c=\"5827\">Server</st>`<st c=\"5833\">,</st> `<st c=\"5835\">Date</st>`<st c=\"5839\">,</st> `<st c=\"5841\">Content-Type</st>`<st c=\"5853\">,</st> `<st c=\"5855\">Content-Length</st>`<st c=\"5869\">, and</st> `<st c=\"5875\">Connection</st>`<st c=\"5885\">.</st> `<st c=\"5887\">Content-Type</st>` <st c=\"5899\">indicates the resource type the</st> `<st c=\"5932\">/index</st>` <st c=\"5938\">API will return to the client.</st> <st c=\"5970\">Aside from strings, the</st> `<st c=\"5994\">jsonify()</st>` <st c=\"6003\">method can also serialize and render an array of objects like in the following API function that returns an array of string data and some</st> <st c=\"6142\">single-valued objects:</st>\n\n```", "```py\n\n\t\t\t<st c=\"6540\">When the response data is not serializable,</st> `<st c=\"6585\">jsonify()</st>` <st c=\"6594\">can throw an exception, so it is advisable to enable error handlers.</st> <st c=\"6664\">Now, it is customary to exclude</st> `<st c=\"6696\">make_response</st>` <st c=\"6709\">in returning the response data since</st> `<st c=\"6747\">jsonify()</st>` <st c=\"6756\">can already manage the</st> `<st c=\"6780\">Response</st>` <st c=\"6788\">generation alone for the endpoint function.</st> <st c=\"6833\">Thus, the following versions of the</st> `<st c=\"6869\">index()</st>`<st c=\"6876\">,</st> `<st c=\"6878\">introduction()</st>`<st c=\"6892\">, and</st> `<st c=\"6898\">list_goals()</st>` <st c=\"6910\">endpoint functions</st> <st c=\"6930\">are acceptable:</st>\n\n```", "```py\n\n\t\t\t<st c=\"7462\">Using the</st> `<st c=\"7473\">@app.route()</st>` <st c=\"7485\">decorator</st> <st c=\"7495\">to bind the URL pattern to the function and define the HTTP request is always valid.</st> <st c=\"7581\">But Flask 3.x had released some decorator shortcuts that can assign one HTTP request per endpoint function, unlike the</st> `<st c=\"7700\">@app.route()</st>`<st c=\"7712\">, which can bind more than one HTTP request.</st> <st c=\"7757\">These shortcuts are</st> <st c=\"7777\">the following:</st>\n\n\t\t\t\t*   `<st c=\"7791\">get()</st>`<st c=\"7797\">: This defines an endpoint function that will listen to incoming</st> *<st c=\"7863\">HTTP</st>* <st c=\"7868\">GET requests, such as</st> <st c=\"7890\">retrieving data from the</st> <st c=\"7915\">database servers.</st>\n\t\t\t\t*   `<st c=\"7932\">post()</st>`<st c=\"7939\">: This</st> <st c=\"7947\">defines an endpoint function to process an</st> *<st c=\"7990\">HTTP POST</st>* <st c=\"7999\">request, such as receiving a body of data for</st> <st c=\"8046\">internal processing.</st>\n\t\t\t\t*   `<st c=\"8066\">put()</st>`<st c=\"8072\">: This defines an endpoint function to cater to</st> <st c=\"8121\">any</st> *<st c=\"8125\">HTTP PUT</st>* <st c=\"8133\">requests, such as receiving a body of data containing updated details for the</st> <st c=\"8212\">database server.</st>\n\t\t\t\t*   `<st c=\"8228\">patch()</st>`<st c=\"8236\">: This defines an endpoint to listen to an</st> *<st c=\"8280\">HTTP PATCH</st>* <st c=\"8290\">request</st> <st c=\"8298\">that aims to modify some</st> <st c=\"8324\">backend resources.</st>\n\t\t\t\t*   `<st c=\"8342\">delete()</st>`<st c=\"8351\">: This defines an</st> *<st c=\"8370\">HTTP DELETE</st>* <st c=\"8381\">endpoint function</st> <st c=\"8399\">that will delete some</st> <st c=\"8422\">server resources.</st>\n\n\t\t\t<st c=\"8439\">The following</st> <st c=\"8454\">employee-related transactions of our</st> `<st c=\"8491\">ch03</st>` <st c=\"8495\">application are all implemented using the shortcut</st> <st c=\"8547\">routing decorators:</st>\n\n```", "```py\n\n\t\t\t<st c=\"8989\">The given</st> `<st c=\"9000\">add_employee()</st>` <st c=\"9014\">endpoint</st> <st c=\"9023\">function performs a database INSERT transaction of a record of employee details received from the client.</st> <st c=\"9130\">The decorated</st> `<st c=\"9144\">@current_app.post()</st>` <st c=\"9163\">makes the API function an HTTP POST request method.</st> <st c=\"9216\">On the other hand, the following is an API function that responds to an HTTP GET</st> <st c=\"9297\">client request:</st>\n\n```", "```py\n\n\t\t\t<st c=\"9581\">The</st> `<st c=\"9586\">list_all_employee()</st>`<st c=\"9605\">, defined by the</st> `<st c=\"9622\">@current_app.get()</st>` <st c=\"9640\">decorator, processes the incoming HTTP GET requests for retrieving a list of employee records from the database server.</st> <st c=\"9761\">For an HTTP PUT transaction, here is an API that updates</st> <st c=\"9818\">employee details:</st>\n\n```", "```py\n\n\t\t\t<st c=\"10243\">The given API endpoint requires an</st> `<st c=\"10279\">empid</st>` <st c=\"10284\">path variable, which will serve as the key to search for the employee record that needs updating.</st> <st c=\"10383\">Since this is an HTTP PUT request, the transaction requires all the new employee details to be replaced by their new values.</st> <st c=\"10508\">But the following is another version of the update transaction that does not need a complete</st> <st c=\"10600\">employee</st> <st c=\"10610\">detail update:</st>\n\n```", "```py\n\n\t\t\t`<st c=\"11111\">update_employee()</st>`<st c=\"11129\">, decorated by</st> `<st c=\"11144\">@current_app.patch()</st>`<st c=\"11164\">, only updates the first name, middle name, and last name of the employee identified by the given employee ID using its path variable</st> `<st c=\"11298\">empid</st>`<st c=\"11303\">. Now, the following API function deletes an employee record based on the</st> `<st c=\"11377\">empid</st>` <st c=\"11382\">path variable:</st>\n\n```", "```py\n\n\t\t\t`<st c=\"11809\">delete_employee()</st>`<st c=\"11827\">, decorated by</st> `<st c=\"11842\">@current_app.delete()</st>`<st c=\"11863\">, is an HTTP</st> `<st c=\"11876\">DELETE</st>` <st c=\"11882\">request method</st> <st c=\"11898\">with the path variable</st> `<st c=\"11921\">empid</st>`<st c=\"11926\">, used for searching employee records</st> <st c=\"11964\">for deletion.</st>\n\t\t\t<st c=\"11977\">These shortcuts of binding HTTP requests to their respective request handler methods are appropriate for implementing REST services because of their definite, simple, and straightforward one-route approach to managing incoming requests and serializing the</st> <st c=\"12234\">required responses.</st>\n\t\t\t<st c=\"12253\">Let us now explore how Flask API captures the incoming body of data for POST, PUT, and PATCH requests and, aside from</st> `<st c=\"12372\">make_response()</st>`<st c=\"12387\">, what other ways the API can generate</st> <st c=\"12426\">JSON responses.</st>\n\t\t\t<st c=\"12441\">Managing requests and responses</st>\n\t\t\t<st c=\"12473\">Unlike in other frameworks, it is</st> <st c=\"12508\">easy to capture the request body of the incoming POST, PUT, and</st> <st c=\"12571\">PATCH request in Flask, which is through the</st> `<st c=\"12617\">get_json()</st>` <st c=\"12627\">method from the</st> `<st c=\"12644\">request</st>` <st c=\"12651\">proxy object.</st> <st c=\"12666\">This utility method receives the incoming JSON data, parses the data using</st> `<st c=\"12741\">json.loads()</st>`<st c=\"12753\">, and returns the data in a Python dictionary format.</st> <st c=\"12807\">As seen in the following</st> `<st c=\"12832\">add_customer()</st>` <st c=\"12846\">API, the value of</st> `<st c=\"12865\">get_json()</st>` <st c=\"12875\">is converted into a</st> `<st c=\"12896\">kwargs</st>` <st c=\"12902\">argument by Python’s</st> `<st c=\"12924\">**</st>` <st c=\"12926\">operator before passing the request data to the model class’s constructor, an indication that the captured request data is a</st> `<st c=\"13052\">dict</st>` <st c=\"13056\">convertible</st> <st c=\"13069\">into</st> `<st c=\"13074\">kwargs</st>`<st c=\"13080\">:</st>\n\n```", "```py\n\n\t\t\t<st c=\"13521\">Another</st> <st c=\"13529\">common approach is to use the</st> `<st c=\"13560\">request.json</st>` <st c=\"13572\">property to</st> <st c=\"13585\">capture the incoming message body, which is raw and with the mime-type</st> `<st c=\"13656\">application/json</st>`<st c=\"13672\">. The following endpoint function captures the incoming request through</st> `<st c=\"13744\">request.json</st>` <st c=\"13756\">and stores the data in the database as</st> `<st c=\"13796\">category</st>` <st c=\"13804\">information:</st>\n\n```", "```py\n\n\t\t\t<st c=\"14039\">Unlike</st> `<st c=\"14047\">request.get_json()</st>`<st c=\"14065\">, which uses serialization, validation, and other utilities to transform and return incoming data to JSON, the</st> `<st c=\"14176\">request.json</st>` <st c=\"14188\">property has no validation support other than raising an</st> `<st c=\"14246\">HTTP status 400</st>` <st c=\"14261\">or</st> `<st c=\"14265\">Bad Data</st>` <st c=\"14273\">error if the data is not JSON serializable.</st> <st c=\"14318\">The</st> `<st c=\"14322\">request.get_json()</st>` <st c=\"14340\">returns</st> `<st c=\"14349\">None</st>` <st c=\"14353\">if the request data is not parsable.</st> <st c=\"14391\">That is why it is best to pair the</st> `<st c=\"14426\">request.is_json</st>` <st c=\"14441\">Boolean property with</st> `<st c=\"14464\">request.json</st>` <st c=\"14476\">to verify the incoming request and filter the non-JSON</st> <st c=\"14532\">message body to avoid</st> `<st c=\"14554\">HTTP Status Code 500</st>`<st c=\"14574\">. Another</st> <st c=\"14584\">option is to check if the</st> `<st c=\"14610\">Content-Type</st>` <st c=\"14622\">request header of the incoming request is</st> `<st c=\"14665\">application/json</st>`<st c=\"14681\">, as showcased by the following</st> <st c=\"14713\">API function:</st>\n\n```", "```py\n\n\t\t\t<st c=\"14967\">This</st> `<st c=\"14973\">add_nonpizza()</st>` <st c=\"14987\">function inserts a new record for the non-pizza menu options for the application, and it uses</st> `<st c=\"15082\">request.json</st>` <st c=\"15094\">to access the JSON-formatted input from the client.</st> <st c=\"15147\">Both</st> `<st c=\"15152\">request.json</st>` <st c=\"15164\">and</st> `<st c=\"15169\">request.get_json()</st>` <st c=\"15187\">yield a dictionary object that makes the instantiation of model objects in the</st> `<st c=\"15267\">add_category()</st>` <st c=\"15281\">and</st> `<st c=\"15286\">add_non_pizza()</st>` <st c=\"15301\">API functions easier because</st> `<st c=\"15331\">kwargs</st>` <st c=\"15337\">transformation from these JSON data</st> <st c=\"15374\">is straightforward.</st>\n\t\t\t<st c=\"15393\">On the other hand, validation of incoming requests using</st> `<st c=\"15451\">request.is_json</st>` <st c=\"15466\">and</st> `<st c=\"15471\">Content-Type</st>` <st c=\"15483\">headers is also applicable to the POST, PUT, and DELETE message body retrieval through</st> `<st c=\"15571\">request.get_json()</st>`<st c=\"15589\">. Now, another approach to accessing the message body that requires</st> `<st c=\"15657\">request.is_json</st>` <st c=\"15672\">validation is through</st> `<st c=\"15695\">request.data</st>`<st c=\"15707\">. This property captures POST, PUT, or PATCH message bodies regardless of any</st> `<st c=\"15785\">Content-Type</st>`<st c=\"15797\">, thus requiring a thorough validation mechanism.</st> <st c=\"15847\">The following API function captures user credentials through</st> `<st c=\"15908\">request.data</st>` <st c=\"15920\">and inserts the</st> <st c=\"15936\">login details</st> <st c=\"15950\">in</st> <st c=\"15954\">the database:</st>\n\n```", "```py\n\n\t\t\t<st c=\"16147\">It is always feasible to use</st> `<st c=\"16177\">request.data</st>` <st c=\"16189\">for HTTP POST transactions, such as in the given</st> `<st c=\"16239\">add_login()</st>` <st c=\"16250\">function, but the API needs to parse and serialize the</st> `<st c=\"16306\">request.data</st>` <st c=\"16318\">using Flask’s built-in</st> `<st c=\"16342\">loads()</st>` <st c=\"16349\">decoder from the</st> `<st c=\"16367\">flask.json</st>` <st c=\"16377\">module extension because the request data is not yet JSON-formatted.</st> <st c=\"16447\">Additionally, the process needs tight data type validation for each JSON object in the captured request data before using it in</st> <st c=\"16575\">the transactions.</st>\n\t\t\t<st c=\"16592\">Aside from these variations of managing the incoming requests, Flask also has approaches to dealing with outgoing JSON responses.</st> <st c=\"16723\">Instead of</st> `<st c=\"16734\">jsonify()</st>`<st c=\"16743\">, another way to render a JSON response is by instantiating and returning</st> `<st c=\"16817\">Response</st>` <st c=\"16825\">to the client.</st> <st c=\"16841\">The following is a</st> `<st c=\"16860\">list_login()</st>` <st c=\"16872\">endpoint function that retrieves a list of</st> `<st c=\"16916\">Login</st>` <st c=\"16921\">records from the database using the</st> `<st c=\"16958\">Response</st>` <st c=\"16966\">class:</st>\n\n```", "```py\n\n\t\t\t<st c=\"17327\">When</st> <st c=\"17333\">using</st> `<st c=\"17339\">Response</st>`<st c=\"17347\">, an encoder such as</st> `<st c=\"17368\">dumps()</st>` <st c=\"17375\">of the</st> `<st c=\"17383\">flask.json</st>` <st c=\"17393\">module</st> <st c=\"17400\">can be used to create a JSONable object from an object, list, or dictionary.</st> <st c=\"17478\">And the</st> `<st c=\"17486\">mime-type</st>` <st c=\"17495\">should always be</st> `<st c=\"17513\">application/json</st>` <st c=\"17529\">to force the object to</st> <st c=\"17553\">become JSON.</st>\n\t\t\t<st c=\"17565\">Let us focus now on Flask’s built-in support for JSON types and the serialization and de-serialization utilities it has to process</st> <st c=\"17697\">JSON objects.</st>\n\t\t\t<st c=\"17710\">Utilizing response encoders and decoders</st>\n\t\t\t<st c=\"17751\">Flask framework</st> <st c=\"17768\">supports the built Python</st> `<st c=\"17794\">json</st>` <st c=\"17798\">module by default.</st> <st c=\"17818\">The built-in encoders,</st> `<st c=\"17841\">dumps()</st>`<st c=\"17848\">, and</st> `<st c=\"17854\">loads()</st>`<st c=\"17861\">, are found in the</st> `<st c=\"17880\">flask.json</st>` <st c=\"17890\">module.</st> <st c=\"17899\">In the</st> *<st c=\"17906\">Managing the requests and responses</st>* <st c=\"17941\">section, the</st> `<st c=\"17955\">add_login()</st>` <st c=\"17966\">endpoint function uses the</st> `<st c=\"17994\">flask.json.loads()</st>` <st c=\"18012\">to de-serialize and transform the</st> `<st c=\"18047\">request.data</st>` <st c=\"18059\">into a JSONable dictionary.</st> <st c=\"18088\">Meanwhile, the</st> `<st c=\"18103\">flask.json.dumps()</st>` <st c=\"18121\">provided the</st> `<st c=\"18135\">Response</st>` <st c=\"18143\">class with a JSONable object for some JSON response output, as previously highlighted in the</st> `<st c=\"18237\">list_all_login()</st>` <st c=\"18253\">endpoint.</st>\n\t\t\t<st c=\"18263\">But any application can override these default encoding and decoding processes to solve some custom requirements.</st> <st c=\"18378\">Customizing an appropriate JSON provider by sub-classing Flask’s</st> `<st c=\"18443\">JSONProvider</st>`<st c=\"18455\">, found in the</st> `<st c=\"18470\">flask.json.provider</st>`<st c=\"18489\">, can allow the overriding of these JSON processes.</st> <st c=\"18541\">The following is a custom implementation of a</st> `<st c=\"18587\">JSONProvider</st>` <st c=\"18599\">with some modifications to the</st> `<st c=\"18631\">dumps()</st>` <st c=\"18638\">and</st> `<st c=\"18643\">loads()</st>` <st c=\"18650\">algorithms:</st>\n\n```", "```py\n app = create_app('../config_dev.toml') <st c=\"19835\">JSONProvider</st> requires overriding its <st c=\"19872\">dump()</st> and <st c=\"19883\">loads()</st> methods. Additional custom features, such as formatting encoded dates, filtering empty JSON properties, and validating key and value types, can be helpful to custom implementation. For the serializer and de-serializer, the preferred JSON utility in customizing the <st c=\"20156\">JSONProvider</st> is Python’s built-in <st c=\"20190\">json</st> module.\n\t\t\t<st c=\"20202\">The</st> `<st c=\"20207\">ImprovedJsonprovider</st>` <st c=\"20227\">class includes a custom</st> `<st c=\"20252\">default()</st>` <st c=\"20261\">method that validates the property value types during encoding.</st> <st c=\"20326\">It coerces the</st> `<st c=\"20341\">date</st>` <st c=\"20345\">or</st> `<st c=\"20349\">datetime</st>` <st c=\"20357\">objects to have a defined format.</st> <st c=\"20392\">For the application to utilize this method during encoding, the overridden</st> `<st c=\"20467\">dumps()</st>` <st c=\"20474\">must pass this</st> `<st c=\"20490\">default()</st>` <st c=\"20499\">to Python’s</st> `<st c=\"20512\">json.dumps()</st>` <st c=\"20524\">as the</st> `<st c=\"20532\">kwargs[\"default\"]</st>` <st c=\"20549\">value.</st> <st c=\"20557\">In addition, there are also other keyword arguments that can smoothen the encoding process, such as</st> `<st c=\"20657\">ensure_scii</st>`<st c=\"20668\">, which enables the replacement of non-ASCII characters with whitespaces, and</st> `<st c=\"20746\">sort_keys</st>`<st c=\"20755\">, which sorts the keys of the resulting dictionary in</st> <st c=\"20809\">ascending order.</st>\n\t\t\t<st c=\"20825\">On the other</st> <st c=\"20839\">hand,</st> `<st c=\"20845\">ImprovedJsonprovider</st>` <st c=\"20865\">‘s overridden</st> `<st c=\"20880\">loads()</st>` <st c=\"20887\">method initially converts the string request data into a dictionary using Python’s</st> `<st c=\"20971\">json.loads()</st>` <st c=\"20983\">before removing all the key-value pairs with empty values.</st> <st c=\"21043\">Afterward,</st> `<st c=\"21054\">json.dumps()</st>` <st c=\"21066\">serializes the sanitized dictionary back to its string type before submitting it for JSON de-serialization.</st> <st c=\"21175\">Thus, running the</st> `<st c=\"21193\">add_category()</st>` <st c=\"21207\">endpoint with a message body that has an empty description value will lead to</st> *<st c=\"21286\">HTTP Status Code 500</st>*<st c=\"21306\">, as shown in</st> *<st c=\"21320\">Figure 3</st>**<st c=\"21328\">.3</st>*<st c=\"21330\">:</st>\n\t\t\t![Figure 3.3 – Applying the overridden flask.json.loads() decoder](img/B19383_03_3.jpg)\n\n\t\t\t<st c=\"21744\">Figure 3.3 – Applying the overridden flask.json.loads() decoder</st>\n\t\t\t<st c=\"21807\">The removal of the</st> `<st c=\"21827\">description</st>` <st c=\"21838\">property by the custom</st> `<st c=\"21862\">loads()</st>` <st c=\"21869\">caused the constructor error flagged in the</st> `<st c=\"21914\">cURL</st>` <st c=\"21918\">command execution in</st> *<st c=\"21940\">Figure 3</st>**<st c=\"21948\">.3</st>*<st c=\"21950\">.</st>\n\t\t\t<st c=\"21951\">Now, the following are</st> <st c=\"21975\">the deprecated features that will not work anymore in Flask 3.x</st> <st c=\"22039\">and onwards:</st>\n\n\t\t\t\t*   `<st c=\"22051\">JSONEncoder</st>` <st c=\"22063\">and</st> `<st c=\"22068\">JSONDecoder</st>` <st c=\"22079\">APIs customize</st> `<st c=\"22095\">flask.json.dumps()</st>` <st c=\"22113\">and</st> `<st c=\"22118\">flask.json.loads()</st>`<st c=\"22136\">, respectively.</st>\n\t\t\t\t*   `<st c=\"22151\">json_encoder</st>` <st c=\"22164\">and</st> `<st c=\"22169\">json_decoder</st>` <st c=\"22181\">attributes set up</st> `<st c=\"22200\">JSONEncoder</st>` <st c=\"22211\">and</st> `<st c=\"22216\">JSONDecoder</st>`<st c=\"22227\">, respectively.</st>\n\n\t\t\t<st c=\"22242\">Also, the following setup applied in Python’s</st> `<st c=\"22289\">json</st>` <st c=\"22293\">encoder and decoder during customization will not work here in the</st> <st c=\"22361\">Flask framework:</st>\n\n\t\t\t\t*   <st c=\"22377\">Specifying the</st> `<st c=\"22393\">flask.json.loads()</st>` <st c=\"22411\">encoder directly with</st> <st c=\"22434\">the custom.</st>\n\t\t\t\t*   <st c=\"22445\">Specifying the</st> `<st c=\"22461\">flask.json.dumps()</st>` <st c=\"22479\">decoder directly with the custom implementation class using the non-existent</st> `<st c=\"22557\">cls</st>` <st c=\"22560\">kwarg.</st>\n\n\t\t\t<st c=\"22567\">Since</st> `<st c=\"22574\">JSONEcoder</st>` <st c=\"22584\">and</st> `<st c=\"22589\">JSONDecoder</st>` <st c=\"22600\">will be obsolete soon, there will be no other means to customize these JSON utilities but through</st> <st c=\"22699\">the</st> `<st c=\"22703\">JSONProvider</st>`<st c=\"22715\">.</st>\n\t\t\t<st c=\"22716\">However, there are instances where the incoming message body or the outgoing JSON responses are complex and huge, which cannot be handled optimally by the built-in JSON provider.</st> <st c=\"22896\">In this case, Flask allows replacing the existing provider with a fast, accurate, and flexible provider, such as</st> `<st c=\"23009\">ujson</st>` <st c=\"23014\">and</st> `<st c=\"23019\">orjson</st>`<st c=\"23025\">. The following class is a sub-class of the</st> `<st c=\"23069\">JSONProvider</st>` <st c=\"23081\">that uses the</st> `<st c=\"23096\">orjson</st>` <st c=\"23102\">encoder</st> <st c=\"23111\">and decoder.</st>\n\n```", "```py\n<st c=\"24905\">from flask import request, abort, Response</st>\n<st c=\"24948\">@app.before_request</st> def before_request_func():\n    api_method = request.method\n    if api_method in ['POST', 'PUT', 'PATCH']:\n        if request.json == '' or request.json == None:\n            abort(500, description=\"request body is empty\")\n    api_endpoint_func = request.endpoint\n    api_path = request.path\n    app.logger.info(f'accessing URL endpoint: {api_path}, function name: {api_endpoint_func} ') <st c=\"25315\">@app.after_request</st> def after_request_func(response:Response):\n    api_endpoint_func = request.endpoint\n    api_path = request.path\n    resp_allow_origin = response.access_control_allow_origin\n    app.logger.info(f\"access_control_allow_origin header: {resp_allow_origin}\")\n    app.logger.info(f'exiting URL endpoint: {api_path}, function name: {api_endpoint_func} ')\n    return response\n```", "```py\n<st c=\"26669\">import werkzeug.wrappers</st>\n<st c=\"26694\">import werkzeug.wsgi</st> class AppMiddleware:\n    def __init__(self, app):\n        self.app = app\n    def __call__(self, environ, start_response):\n        request = <st c=\"26832\">werkzeug.wrappers.Request</st>(environ)\n        api_path = request.url\n        app.logger.info(f'accessing URL endpoint: {api_path} ')\n        iterator:<st c=\"26956\">werkzeug.wsgi.ClosingIterator</st> = self.app(environ, start_response)\n        app.logger.info(f'exiting URL …: {api_path} ') <st c=\"27145\">AppleMiddleware</st>, the involved <st c=\"27175\">Request</st> API class is from the <st c=\"27205\">werkzeug</st> module or the core platform itself since the implementation is server-level. Instantiating the <st c=\"27309\">werkzeug.wrappers.Request</st> with the <st c=\"27344\">environ</st> parameter as its constructor argument will give us access to the details of the incoming request of the API endpoint. Unfortunately, there is no direct way of accessing the response object within the filter class. Some implementations require the creation of hook methods by registering custom decorators to Flask through the custom middleware, and others use external modules to implement a middleware that acts like a URL dispatcher. Now, our custom middleware must be a callable class type, so all the implementations must be in its overridden <st c=\"27899\">__call__()</st> method.\n\t\t\t<st c=\"27917\">Moreover, we can</st> <st c=\"27935\">also associate</st> `<st c=\"27950\">Blueprint</st>` <st c=\"27959\">modules with their respective</st> <st c=\"27990\">custom before and after filter methods, if required.</st> <st c=\"28043\">The following</st> `<st c=\"28057\">app</st>` <st c=\"28060\">configuration assigns filter methods to the</st> `<st c=\"28105\">order_cient_bp</st>` <st c=\"28119\">and</st> `<st c=\"28124\">pizza_client_bp</st>` `<st c=\"28139\">Blueprint</st>`<st c=\"28149\">s of the</st> `<st c=\"28159\">ch03-client</st>` <st c=\"28170\">application:</st>\n\n```", "```py\n\n\t\t\t<st c=\"28420\">Both</st> `<st c=\"28426\">before_request_funcs</st>` <st c=\"28446\">and</st> `<st c=\"28451\">after_request_funcs</st>` <st c=\"28470\">contain the concerned</st> `<st c=\"28493\">Blueprint</st>` <st c=\"28502\">names and their corresponding lists of implemented filter</st> <st c=\"28561\">method names.</st>\n\t\t\t<st c=\"28574\">Can we also apply the same exception-handling directives used in the web-based applications of</st> *<st c=\"28670\">Chapters 1</st>* <st c=\"28680\">and</st> *<st c=\"28685\">2</st>*<st c=\"28686\">? Let us find out in the</st> <st c=\"28711\">following discussion.</st>\n\t\t\t<st c=\"28732\">Handling exceptions</st>\n\t\t\t<st c=\"28752\">In RESTful applications, Flask</st> <st c=\"28784\">allows the endpoint function to trigger error handlers that return error messages in JSON format.</st> <st c=\"28882\">The following snippets are the error handlers of our</st> `<st c=\"28935\">ch03</st>` <st c=\"28939\">application:</st>\n\n```", "```py\n\n\t\t\t<st c=\"29214\">Error handlers can also return the JSON response through the</st> `<st c=\"29276\">jsonify()</st>`<st c=\"29285\">,</st> `<st c=\"29287\">make_response()</st>`<st c=\"29302\">, or</st> `<st c=\"29307\">Response</st>` <st c=\"29315\">class.</st> <st c=\"29323\">As shown in the given error handlers, the implementation is the same with the web-based error handlers except for the</st> `<st c=\"29441\">jsonify()</st>` <st c=\"29450\">method, which serializes the captured error message to the JSON type instead of</st> <st c=\"29531\">using</st> `<st c=\"29537\">render_template()</st>`<st c=\"29554\">.</st>\n\t\t\t<st c=\"29555\">Custom exception</st> <st c=\"29573\">classes must include both the</st> *<st c=\"29603\">HTTP Status Code</st>* <st c=\"29619\">and error message in the JSON message.</st> <st c=\"29659\">The customization must include a</st> `<st c=\"29692\">to_dict()</st>` <st c=\"29701\">method that will convert the payload and other external parameters to a dictionary object for the</st> `<st c=\"29800\">jsonify()</st>` <st c=\"29809\">to serialize.</st> <st c=\"29824\">The following is a custom exception class raised by our</st> `<st c=\"29880\">INSERT</st>` <st c=\"29886\">repository transactions and</st> <st c=\"29915\">endpoint functions:</st>\n\n```", "```py\n @app.errorhandler(<st c=\"30502\">DuplicateRecordException</st>)\ndef insert_record_exception(e):\n    return <st c=\"30686\">Database</st> <st c=\"30694\">RecordException</st>, triggering this <st c=\"30728\">insert_record_exception()</st> handler. But for Python-related exceptions, the following error handler will also render the built-in exception messages in JSON format:\n\n```", "```py\n pip install requests\n```", "```py\n @current_app.route('/client/order/add', methods = ['GET', 'POST'])\ndef add_order():\n    if request.method == 'POST':\n        order_dict = request.form.to_dict(flat=True) <st c=\"32246\">order_add_api = \"http://localhost:5000/order/add\"</st><st c=\"32295\">response: requests.Response =</st> <st c=\"32325\">requests.post(order_add_api, json=order_dict)</st><st c=\"32371\">customers_list_api =</st> <st c=\"32392\">\"http://localhost:5000/customer/list/all\"</st><st c=\"32434\">employees_list_api =</st> <st c=\"32455\">\"http://localhost:5000/employee/list/all\"</st><st c=\"32497\">resp_customers:requests.Response = requests.get(customers_list_api)</st><st c=\"32565\">resp_employees:requests.Response = requests.get(employees_list_api)</st> return render_template('add_order.html', customers=<st c=\"32747\">get()</st> method returns a <st c=\"32770\">requests.Response</st> object that contains essential details, such as <st c=\"32836\">content</st>, <st c=\"32845\">url</st>, <st c=\"32850\">status_code</st>, <st c=\"32863\">json()</st>, <st c=\"32871\">encoding</st>, and other headers from the API’s server. Our <st c=\"32926\">add_order()</st> calls the <st c=\"32948\">json()</st> for each GET response to serialize the result in JSON format.\n\t\t\t<st c=\"33016\">For the HTTP POST transaction, the</st> `<st c=\"33052\">request</st>` <st c=\"33059\">module has a</st> `<st c=\"33073\">post()</st>` <st c=\"33079\">method to send an HTTP POST request to</st> `<st c=\"33119\">http://localhost:5000/order/add</st>` <st c=\"33151\">API.</st> <st c=\"33156\">For a successful POST request handshake, the</st> `<st c=\"33201\">post()</st>` <st c=\"33207\">requires the URL of the API service and the record or object as the request body in</st> <st c=\"33292\">dictionary format.</st>\n\t\t\t<st c=\"33310\">Aside from the dictionary type, the</st> `<st c=\"33347\">post()</st>` <st c=\"33353\">method can also allow the submission of a list of</st> *<st c=\"33404\">tuples</st>*<st c=\"33410\">,</st> *<st c=\"33412\">bytes</st>*<st c=\"33417\">, or</st> *<st c=\"33422\">file entity types</st>*<st c=\"33439\">. It also has various parameter options such as</st> `<st c=\"33487\">data</st>`<st c=\"33491\">,</st> `<st c=\"33493\">json</st>`<st c=\"33497\">, or</st> `<st c=\"33502\">files</st>` <st c=\"33507\">that can accept the appropriate</st> <st c=\"33539\">request</st> <st c=\"33548\">body types.</st>\n\t\t\t<st c=\"33559\">Now, other than</st> `<st c=\"33576\">get()</st>` <st c=\"33581\">and</st> `<st c=\"33586\">post()</st>` <st c=\"33592\">methods, the</st> `<st c=\"33606\">requests</st>` <st c=\"33614\">library has other helper methods that can also send other HTTP requests to the server, such as the</st> `<st c=\"33714\">put()</st>` <st c=\"33719\">that calls the PUT API service,</st> `<st c=\"33752\">delete()</st>` <st c=\"33760\">that calls DELETE API service, and</st> `<st c=\"33796\">patch()</st>` <st c=\"33803\">for the PATCH</st> <st c=\"33818\">API service.</st>\n\t\t\t<st c=\"33830\">Summary</st>\n\t\t\t<st c=\"33838\">This chapter has proven to us that some components apply to both API-based and web-based applications, but there are specific components that fit better in API transactions than in web-based ones.</st> <st c=\"34036\">It provided details on Flask’s JSON de-serialization applied to request bodies and serialization of outgoing objects to be part of the API responses.</st> <st c=\"34186\">The many options of capturing the request body through</st> `<st c=\"34241\">request.json</st>`<st c=\"34253\">,</st> `<st c=\"34255\">request.data</st>`<st c=\"34267\">, and</st> `<st c=\"34273\">request.get_json()</st>` <st c=\"34291\">and generating responses through its</st> `<st c=\"34329\">jsonify()</st>` <st c=\"34338\">or</st> `<st c=\"34342\">make_response()</st>` <st c=\"34357\">and</st> `<st c=\"34362\">Response</st>` <st c=\"34370\">class with</st> `<st c=\"34382\">application/json</st>` <st c=\"34398\">as a mime-type show Flask’s flexibility as</st> <st c=\"34442\">a framework.</st>\n\t\t\t<st c=\"34454\">The chapter also showcased Flask’s ability to adapt to different third-party JSON providers through sub-classing its</st> `<st c=\"34572\">JSONProvider</st>` <st c=\"34584\">class.</st> <st c=\"34592\">Moreover, the many options for providing our API endpoints with route filtering mechanisms also show that the platform can manage the application’s incoming requests and outgoing responses like any good framework.</st> <st c=\"34806\">Regarding error handling mechanisms, the framework can provide error handlers for web-based applications that render templates and those that send JSON responses for</st> <st c=\"34972\">RESTful applications.</st>\n\t\t\t<st c=\"34993\">When consuming the API endpoints, this chapter exhibited that Flask could support typical Python REST client modules, such as</st> `<st c=\"35120\">requests</st>`<st c=\"35128\">, without any</st> <st c=\"35142\">additional workaround.</st>\n\t\t\t<st c=\"35164\">So, we have seen that Flask can support building web-based and API-based applications even though it is lightweight and</st> <st c=\"35285\">a microframework.</st>\n\t\t\t<st c=\"35302\">The next chapter will discuss simplifying and organizing Flask implementations using popular third-party Flask</st> <st c=\"35414\">module extensions.</st>\n\n```", "```py\n\n```", "```py\n\n```", "```py\n\n```", "```py\n\n```"]