- en: Chapter 6. More Complex Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll look at a number of built-in and standard library collection types. These
    collections offer more features than the simple tuple collection. We'll look at
    the `for` and `while` statements which allow us to process the individual items
    of a collection.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at some functions which we can use to work with collections of data;
    these include the `map()`, `filter()`, and `functools.reduce()` functions. By
    using these, we don't need to write an explicit `for` statement to process a collection.
    We'll also look at more specific kinds of reductions such as `max()`, `min()`,
    `len()`, and `sum()`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also look at the `break` and `continue` statements; these modify a `for`
    or `while` loop to allow skipping items or exiting before the loop has processed
    all items. This is a fundamental change in the semantics of a collection-processing
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: The concepts of mutability and immutability are part of understanding how an
    object behaves. The built-in types in this chapter are all mutable. This is quite
    different from the way that immutable objects like strings and tuples behave.
  prefs: []
  type: TYPE_NORMAL
- en: The mutability and immutability distinction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Simple Data Types"), *Simple Data Types*,
    we looked at the immutability issue. This is an important characteristic of Python
    objects. We'll need to look at some more aspects of mutability in [Chapter 7](ch07.html
    "Chapter 7. Basic Function Definitions"), *Basic Function Definitions*. We'll
    look at how we can create our own mutable classes in [Chapter 11](ch11.html "Chapter 11. Class
    Definitions"), *Class Definitions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen that Python''s various classes include those which create mutable
    objects and those which create immutable objects. The immutable classes include
    all of the number classes, strings, bytes, and tuples. The `tuple (247, 83, 148)`
    object cannot be changed: we cannot assign a new value to an item with an index
    of 1\.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `tuple` object has the structure of `Sequence`: we can extract items based
    on their position. However, we cannot change the internal state of a `tuple` object.'
  prefs: []
  type: TYPE_NORMAL
- en: A `list` is also a subclass of the `Sequence` class. We can, however, change
    the state of a `list` object without creating a new `list` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The abstract base class definitions for `Sequence` and `MutableSequence` are
    in the `collections.abc` module. The documentation for this module shows how the
    various complex types relate to each other.
  prefs: []
  type: TYPE_NORMAL
- en: While some of the features of `list` and `tuple` are similar, they address different
    use cases. The benefits of immutability are simplicity, reduced storage demands,
    and higher-performance for some kinds of processing. The benefit mutability is
    that a single object can undergo an internal state change.
  prefs: []
  type: TYPE_NORMAL
- en: Using the list collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python''s `list` collection is its built-in mutable sequence. We can create
    list objects easily using a literal display that simply provides expressions enclosed
    in `[]`. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As with tuples, the items are identified by their position in the `list` collection.
    Positions are numbered from the left starting from zero. Positions are also numbered
    from the right, using negative numbers. The last value in a list is at position
    -1, the next-to-last value at position -2.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Index values begin with zero. Index position 0 is the first item. Index values
    can be done in reverse with negative numbers. Index position -1 is the last item.
  prefs: []
  type: TYPE_NORMAL
- en: We can also create lists using the `list()` function. This will convert many
    kinds of collections into `list` objects. Used without arguments, `list()` creates
    an empty `list` just like `[]`. Since the `list()` function is so versatile at
    converting collections into `list` objects, we'll use it much more in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can update a `list` collection using methods like `append()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the value of `fib_list[-1]` is the last element in the list,
    and `fib_list[-2]` is the penultimate value. The expression creates a new number,
    which can be appended to the `fib_list` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can manipulate a single element in a list using a subscription, such as
    those shown in the previous example. The value in the `[]` must be a single integer,
    which identifies an item in the list. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The item in position two (the third item in the list) has a value of 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extract a sublist using slicing notation. A slicing uses a multi-part
    value in the `[]`. The result of a slicing is always a list built from the original
    list object. There are several ways to specify slicings, we''ll show a number
    of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first slicing, `[2:5]`, starts at the index of 2 and stops just before the
    index of 5\. This means that the index values of 2, 3, and 4 are sliced out of
    the original list. Since lists are indexed from zero, an index of 2 is the third
    position in the list. It's essential to think of a slicing as a "half-open" interval.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of Python uses "half-open" intervals.
  prefs: []
  type: TYPE_NORMAL
- en: When we write the slice expression `[a:b]`, position *a* is included while position
    *b* is not included. This slice specifies all index values, *i*, such that ![Using
    the list collection](img/B03671_06_01.jpg). There are ![Using the list collection](img/B03671_06_02.jpg)
    values in the slice.
  prefs: []
  type: TYPE_NORMAL
- en: The second slicing, `[2:]`, omits the ending, which means that it starts at
    an index of 2 and includes all items to the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: The third slicing, `[:-1]`, omits the starting position, which means that it
    starts at an index of 0\. The ending is given as -1, the last item in the list.
    Since slicings stop short of the given final position, this slicing will omit
    the last item from the list.
  prefs: []
  type: TYPE_NORMAL
- en: We can use `[:]` as a degenerate case where the start and end are both omitted.
    This works very well when making a shallow copy of an entire `list` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Slicings can be extended to include a third parameter. This allows us to specify
    a *start*, *stop*, and a *step* value. We can do things like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first example, the start and stop are omitted, so we''ll use the entire
    list. The step value is 2, so we''ll extract a new list using the even-numbered
    indexes: 0, 2, 4, …, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second example, we provided a start and a step value. This will begin
    with index 1, and increment by 2\. It will extract a list built from the odd-numbered
    indices: 1, 3, 5, …, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: We can use a negative step value to visit a list in reverse order. This can
    be confusing, but it works very nicely.
  prefs: []
  type: TYPE_NORMAL
- en: List objects have a few operators, including `+` and `*`. We'll also look at
    the various kinds of list assignment statements we can use that involve slicing
    expressions on the left side of the assignment statement. These can mutate a list
    by changing some of the values.
  prefs: []
  type: TYPE_NORMAL
- en: Using list operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `+` operator to concatenate two list objects: `[1, 1] + [2,
    3, 5]` for example. If we want to extend a list, we can use this augmented assignment
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that we had to create a singleton `list` collection so that the `+` operator
    would concatenate the new `list` to an existing `list`.
  prefs: []
  type: TYPE_NORMAL
- en: Since a `list` object is mutable, this `+=` assignment will update a `list`
    object; it is extended with the new `list` collection. Contrast this with a `tuple`,
    where a new `tuple` must be created from the two original tuples, and assigned
    to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html "Chapter 5. Logic, Comparisons, and Conditions"), *Logic,
    Comparisons, and Conditions*, we noted that sequences like `list` and `tuple`
    are compared item-by-item. This means that `[1, 1, 2] < [1, 2]` will be `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists and other sequences also support the `in` operator. We can ask if a specific
    value is in a `list` collection. We can also confirm that a given value is not
    in a `list` collection. These are simple Boolean expressions that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `in` operator to confirm that the value 13 is in the `fib_list`
    variable and the value 12 is not in that `list` object.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating a list with subscripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can change an item in a `list` collection using a subscription or slicing
    on the left side of an assignment statement. A subscription uses `[]` and a single
    integer value to identify an item within a `list`. We can replace an item like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will replace the item at index 0 (the first item) with a value of 1\. If
    we mention an index value which is not in the list, an `IndexError` will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can replace any simple slice of a list with a different list. The replacement
    list does not have to be the same size. Indeed, it can be an empty list, which
    will effectively remove items from the list. Here''s an example where we mutate
    a long slice by providing a shorter replacement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve specified a slicing which contains three items—index values of 2, 3,
    and 4—and replaced these items with a list that has only a single item. The resulting
    list will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Positions 0 and 1 remain untouched. Also positions from 5 to the end of the
    original list are also left untouched.
  prefs: []
  type: TYPE_NORMAL
- en: We can replace an extended slicing—one that includes a step value—but the replacement
    must be the same size. If we don't provide the proper number of replacement values,
    we'll get a `ValueError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating a list with method functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can mutate a `list` object with any of a large number of method functions.
    The mutator methods of a list almost always return a value of `None`. With the
    exception of the `pop()` method, mutators don't return a meaningful value.
  prefs: []
  type: TYPE_NORMAL
- en: There are also method functions which provide information about a list; these
    must return a value. We'll look at access-only method functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mutator methods of a list include `append()`, `clear()`, `extend()`, `insert()`,
    `pop()`, `remove()`, `reverse()`, and `sort()`. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We've shown our initial list with six items. We extended the list with a second
    list that has two more items, `[21, 34]`. The result is a single list composed
    of the two original lists.
  prefs: []
  type: TYPE_NORMAL
- en: The `insert()` method has a value and a position. In this example, both were
    zero. When we use `help(list.insert)` we see that the index position is the first
    argument value. The value to be inserted before that position is provided as the
    second argument value.
  prefs: []
  type: TYPE_NORMAL
- en: When we remove an item from a list, we provide the item value to remove. For
    very large lists, this may involve a significant amount of time searching for
    the required item.
  prefs: []
  type: TYPE_NORMAL
- en: The `pop()` method does two things. It removes an item by position, and returns
    that item as the result value. The default position is the last item, -1\. We
    can also remove items from the beginning of a list, using index position 0.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the `del` statement to remove items from a list. The statement
    `del fib_list[0]` will remove the first item from a list.
  prefs: []
  type: TYPE_NORMAL
- en: We haven't shown the `reverse()` and `sort()` methods which change the order
    of the items in the list. The `sort()` method can be quite a bit more sophisticated
    than these methods. We'll look into sorting in [Chapter 8](ch08.html "Chapter 8. More
    Advanced Functions"), *More Advanced Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't give an example of the `clear()` method. This removes all of the items
    from the list.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, with the exception of `pop()`, we must explicitly request a display
    of the `fib_list` object to see any output from Python's REPL. These mutator methods
    only return a value of `None`. It's too common a mistake to see `a = a.append(x)`;
    this statement always sets the variable `a` to `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As shown previously, we can access a list using a subscription as well as a
    slicing. A subscription gives us a single item. A slicing, on the other hand,
    makes a shallow copy of the items in the original list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method functions for accessing a list include `count()`, `index()`, and
    `copy()`. Here are some examples to show how these functions work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `count()` method counts all the items which are equal to the given value.
    In this case, there were two items equal to 1 in the list. If the given value
    is not found in the list, the count will be zero.
  prefs: []
  type: TYPE_NORMAL
- en: The `index()` method locates the given item value, and returns the index position
    of that value in the list. If the value does not exist, a `ValueError` exception
    is raised.
  prefs: []
  type: TYPE_NORMAL
- en: The `copy()` method of a list object does the same thing as the empty slicing.
    The expressions, `fib_list[:]` and `fib_list.copy()`, are both copies of the original
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Using collection functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python offers a number of functions which work with any kind of collection.
    These include `sorted()`, `max()`, `min()`, and `sum()`. We also have some higher-order
    functions, `map()`, `filter()`, and the entire `itertools` module. We'll address
    additional higher-order functions in [Chapter 8](ch08.html "Chapter 8. More Advanced
    Functions"), *More Advanced Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: The `sorted()` function returns a sorted list from a collection. It transforms
    the given collection into a `list` collection as part of the sorting process.
    If the collection doesn't define the proper iterator methods, it can't be easily
    sorted by using this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `max()` and `min()` functions reduce a collection to a single value: either
    the largest or the smallest value in the collection. This reduction presumes that
    the items can be meaningfully compared. Consider a `tuple` that has mixed values
    in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can't meaningfully evaluate `max()` or `min()` on a collection of mixed values
    like this. The functions will be forced to compare a tuple of numbers against
    a string. This will raise a `TypeError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sum()` function reduces a collection of numbers to a single value. It
    can be used on almost any kind of object that implements the `+` operator; we
    can amalgamate a list of lists to create a very long list. Here''s an example
    of using these collection functions with a simple `set` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We've created a set with four integers in it. When we evaluate the `sorted()`
    function, we get a `list` object which contains the items sorted into ascending
    order. When we evaluate `max()` or `min()` functions, we get the largest or smallest
    value in the collection. The `sum()` function adds up the values in the set collection.
  prefs: []
  type: TYPE_NORMAL
- en: Using the set collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the collections we''ve looked at previously have been sequences: `str`,
    `bytes`, `tuple`, and `list` have items which can be accessed by their position
    within the collection. A `set` collection is an unordered collection where items
    are present or absent.'
  prefs: []
  type: TYPE_NORMAL
- en: Items in a `set` collection must be immutable; they must provide a proper hash
    value as well as an equality test. This means that we can create sets of numbers,
    strings, and tuples. We can't easily create a set of lists or a set of sets.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of a `set` display is a sequence of expressions wrapped in `{}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example `set` built using numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We've created a `set` object by enclosing the values in `{}`. This syntax looks
    very similar to the syntax for creating `list` or `tuple`. Note that the elements
    in the `set` collection are displayed in a different order. There's no guarantee
    what the order will be; different implementations may show different orders.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that we tried to include two instances of the integer
    1 in the `set` collection. Since an item is either present in the `set` collection
    or absent, the item cannot be included a second time. Duplicate items are silently
    ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a `set` collection by applying the `set()` function to a
    collection of values. We can create a `set` collection from a `list` or `tuple`
    collection. We can also create a `set` collection from a simple string: each individual
    character will become an item in the resulting set. We can use `set([1, 1, 3,
    5, 8])` to apply the `set()` function to a literal list object.'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax `{}`, interestingly, does not create an empty `set`. This actually
    creates an empty `dict` class. To create an empty `set`, we must use the `set()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a fairly large number of operators for set objects. In addition to
    the operators, we also have a large number of method functions. These can be categorized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mutators**: These modify a `set` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accessors**: These access a list and return a fact about that `set` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mutator methods of a `set` collection almost always return a value of `None`.
    With the exception of the `pop()` method, mutators don't return a value. The accessors,
    which provide information about a list, must return a value. We'll look at the
    operators first.
  prefs: []
  type: TYPE_NORMAL
- en: Using set operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sets have a large number of operators which closely parallel mathematical operators
    for sets. The mapping leverages the bit-oriented operators; it interprets them
    to mean set membership instead of bits in an integer value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the following operators: `|`, `&`, `-`, and `^`, which stand for union
    (![Using set operators](img/B03671_06_03.jpg)), intersection (![Using set operators](img/B03671_06_04.jpg)),
    difference (![Using set operators](img/B03671_06_05.jpg)), and symmetric difference
    (![Using set operators](img/B03671_06_06.jpg)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of these two sets are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Each set is built by splitting a string into individual space-separated words.
    The results contain the proper elements; the order, however, may vary. Here are
    examples of each of the operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The union operator creates a new set with elements that are drawn from both
    sets. We could say that the union of `a | b` creates a set of elements, {*x*},
    where each element is either an element of *a* **or** an element of *b*. There's
    a tidy parallel between the concept of the Boolean **or** operator and the set
    union.
  prefs: []
  type: TYPE_NORMAL
- en: The intersection operator, `a & b`, finds the items which are an element of
    *a* **and** an element of *b*. Again, there's a close parallel between the Boolean
    **and** operator and set intersection.
  prefs: []
  type: TYPE_NORMAL
- en: The set difference operator will remove items from the left set which are in
    the right set. We could say that the resulting elements are elements of *a* and
    not elements of *b*. There's no commonly-used Boolean operator which parallels
    the definition of set difference.
  prefs: []
  type: TYPE_NORMAL
- en: The symmetric difference operators are the items unique to both sets; the common
    items have been removed. This corresponds to the **exclusive or** Boolean operation.
    We could say that the result is members of *a* or members of *b* but not members
    of both sets.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating a set with method functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sets have some mutators which parallel those of a `list` collection. These
    methods include `add()`, `remove()`, `discard()`, and `clear()`. Since the methods
    are mutators, they do not return a useful value. The `add()` method parallels
    `list.append()`: it adds a single item to the set.'
  prefs: []
  type: TYPE_NORMAL
- en: The `remove()` and `discard()` methods will remove an item from a set; the `remove()`
    method will raise an exception if the item is not in the set, the `discard()`
    method always succeeds, even if the item is not in the set. The `clear()` method
    discards all items from the set.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, for example, update our `fib_set` variable like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We've located the largest value in the set, and assigned this to the `f_n` variable.
    We used the set difference operator to create a new set without the maximum value.
    When we evaluate `max()` on this new set, we'll get the next-to-largest value.
    Finally, we mutated the set with the `add()` method to insert a value into the
    set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The set difference operator, `-`, does not mutate the set: like all arithmetic
    operators, it creates a new object from the operands. The `add()` method, however,
    does mutate the given set.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that Fibonacci numbers aren't the best use of a `set` collection. The first
    two Fibonacci numbers are both one.
  prefs: []
  type: TYPE_NORMAL
- en: The `pop()` method is unique; it is a mutator which also returns a value. The
    value popped from the set will be selected arbitrarily. There's no easy way to
    predict which item will be removed and returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the operators has a method function that matches the operator. The
    following operators: `|`, `&`, `-`, and `^` correspond to the `update()`, `intersection()`,
    `difference()`, and `symmetric_difference()` methods. We can write `a | b` or
    we can write `a.update(b)`. Both have the same results.'
  prefs: []
  type: TYPE_NORMAL
- en: Using augmented assignment with sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The augmented assignment statements also work well with sets. We can use `|=`,
    `&=`, `-=`, and `^=`, to update a set based on elements from another set. For
    example, consider this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `words` set will be mutated to include all the items from the `more` set.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the augmented assignment statements also has a corresponding update
    method. The method names for these mutators are `update()`, `intersection_update()`,
    `difference_update()`, and `symmetric_difference_update()`. These methods are
    mutators which match the augmented assignment statements.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a set with operators and method functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few operators which count as set accessors. Perhaps the most fundamental
    method for accessing a set is the `in` operator; this will check to see if a particular
    element exists in a set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The comparison operators for sets implement basic set theory operations. When
    we use `<`, `<=`, `>`, or `>=` between two sets, we''re doing subset and superset
    comparisons. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, the set `{'I'}` is a proper subset of the set in the words
    variable. In the second case, the improper subset comparison was `True`, because
    the two sets are actually equal.
  prefs: []
  type: TYPE_NORMAL
- en: We also have method functions that match the various comparison operators. We
    can use `isdisjoint()`, `issubset()`, and `issuperset()` in addition to the `!=`,
    `<`, and `>` operators.
  prefs: []
  type: TYPE_NORMAL
- en: There's little practical difference between `item in set` and `{item} <= set`.
    It's also true that `set–{item} != set` would be true when the given `item` is
    in the `set`. These mathematical equivalences are interesting, but often involve
    extra computation.
  prefs: []
  type: TYPE_NORMAL
- en: Mappings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has a number of mapping collections. A mapping is an association between
    a key and a value. The built-in mapping collection is the `dict` class. The other
    mappings are defined in the `collections` library, and must be imported.
  prefs: []
  type: TYPE_NORMAL
- en: Items that are keys within a mapping must be immutable; they must provide a
    proper hash value as well as a matching equality test. The values within a mapping
    have no restrictions; they can be mutable or immutable. The order of the keys
    is not maintained by the `dict` class.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a simple `dict` display using `{}`; each key and value are separated
    by the `:` character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a simple mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We've created a simple mapping with keys that are all integers, and values which
    are a mixture of Boolean and `None` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a dictionary using the `dict()` function. This function
    can build a dictionary from a variety of sources. We can provide an existing dictionary
    as an argument; the `dict()` function will make a shallow copy of that source
    dictionary. We can provide a sequence of `(key, value)` two-tuples. It would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This example created a dictionary from a list of `(key, value)` two-tuples.
    The resulting dictionary object that's created will match the literal display
    shown in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: We can also create dictionaries with string keys using the `dict()` function.
    When we provide keyword arguments, they become the keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It's important to repeat the observation that the order of the keys in a built-in
    `dict` object is not defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also build a dictionary from a set of keys, providing a single default
    value. We can do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `range()` function to iterate through a series of numbers which
    start with two and end just before ten. These numbers are then used to create
    keys for a dictionary. The value associated with each key is the default of `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Using dictionary operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All Python mappings, including the built-in `dict`, use a key in [] to get,
    set, and delete items. The syntax looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We've provided literal strings to show how we can get an item, set an item,
    and use the `del` statement to delete an item.
  prefs: []
  type: TYPE_NORMAL
- en: Note that dictionary comparisons are difficult to define in a general way. It's
    not perfectly clear if an ordering comparison should compare only the keys, only
    the values, or a combination of keys and values. Consequently, only `==` and `!=`
    comparisons among dictionaries are defined.
  prefs: []
  type: TYPE_NORMAL
- en: Using dictionary mutators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use `dict[key]` on the left side of an assignment statement to modify
    a dictionary. This will insert the given key and value if the key does not exist;
    if the key already exists, it will change the value associated with the key.
  prefs: []
  type: TYPE_NORMAL
- en: We also have a number of methods that we can use to mutate a dictionary object.
    These methods include `clear()`, `pop()`, `popitem()`, `setdefault()`, and `update()`
    to modify a dictionary object.
  prefs: []
  type: TYPE_NORMAL
- en: The `clear()` and `update()` methods don't return a useful value. The `clear()`
    method will empty the dictionary. The `update()` method will fold additional data
    into an existing dictionary. This method will accept the same variety of arguments
    as the `dict()` function that creates a dictionary. The first positional argument
    can be a dictionary object or a sequence of `(key, value)` two-tuples. Additionally,
    we can provide any number of keyword arguments; the keywords will become keys
    in the updated dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two examples that show some of the different ways in which the `update()`
    method can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We've updated the `cadaeic` dictionary object using another dictionary with
    two items. Then we applied further updates using a sequence of `(key, value)`
    two-tuples. The second example also included an additional keyword argument, which
    inserted the key `'weary'` into the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: The `setdefault()` method function is an interesting special case. This is a
    variation on the `get()` accessor. The `get()` method (and the `pop()` method)
    has a provision for a default value. The `setdefault()` method doesn't merely
    return the default value if the key is missing—paralleling what `get()` does.
    The `setdefault()` method updates the dictionary to be sure that the default value
    is now in the dictionary. All subsequent `setdefault()` or `get()` methods will
    find the key in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequence of operations might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We've created an empty dictionary and assigned it to the `counter` variable.
    When we use `counter.setdefault('a',0)`, we'll get the value associated with a
    key of `'a'`, or we'll get the default value of zero. In addition to returning,
    the default value will also be used to update the dictionary, assuring that there
    is a value associated with the given key.
  prefs: []
  type: TYPE_NORMAL
- en: We can then do a simple, easy-to-understand `counter['a'] += 1` knowing that
    the key, `'a'`, has a value in the dictionary. Either the key already existed,
    and the `setdefault()` function did nothing or the key did not exist, and the
    `setdefault()` function provided that default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `setdefault()` returns a value, we can optimize this into something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This `setdefault()` process is so common that there are two closely-related
    classes in `collections`. The `defaultdict` class simply treats all `get()` operations
    like `setdefault()`. The `Counter` class will implicitly do the `count[key]+=1`
    process for any iterable, building on the `defaultdict` class.
  prefs: []
  type: TYPE_NORMAL
- en: There are two variations on the `pop()` method. The typical implementation of
    `pop()` will remove a given key and return the value associated with that key.
    Beyond this, the `popitem()` method will remove and return one `(key, value)`
    pair from a dictionary. The pair will be chosen arbitrarily. In both cases, the
    dictionary is updated to remove the value.
  prefs: []
  type: TYPE_NORMAL
- en: Using methods for accessing items in a mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have a number of methods to access items in a mapping. First and foremost,
    we have the `dict[key]` construct which locates the value associated with the
    given key. If the key does not exist, the `KeyError` exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: The `get()` method will also return the value associated with a key in the dictionary.
    The `get()` method can also provide a default value. We can use `cadaeic.get("word",4)`
    to locate the key (`"word"` in this example). If the key is not found the default,
    `4`, is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The `copy()` method returns a shallow copy of the dictionary. We can do `a=dict(d)`
    or `a= d.copy()` to make a new dictionary, which is a copy of an original dictionary.
    Both are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three methods which expose important features of a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '`keys()` is the sequence of keys from the mapping. By default, this is used
    when converting a mapping to another collection. If we use `set(cadaeic)` or `list(cadaiec)`,
    we''ll see just the key values in the set or list object. The value of `sorted(cadaeic)`
    is the same as `sorted(cadaeic.keys())`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values()` is the sequence of values from the mapping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`items()` is the sequence of `(key, value)` pairs from the mapping. This list
    of two-tuples can be used to rebuild the dictionary. If we use `tuple(cadaeic.items())`,
    we''ve created a tuple of two-tuples. This tuple is immutable, and can be used
    as a key to another mapping or as an item in a set. This is a way of "freezing"
    a dictionary to create an immutable copy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using extensions from the collections module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *Python Standard Library* includes the `collections` module. This module
    offers us a number of alternatives to the built-in collections. This module has
    the following additional collections:'
  prefs: []
  type: TYPE_NORMAL
- en: We can import the `namedtuple` function and use this to create variations on
    the basic `tuple` that includes named attributes in addition to attributes identified
    by their positional index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `deque` class defines a double-ended queue, like a `list` collection that
    can perform fast `append()` and `pop()` functions on either end. A subset of the
    features of this class will create single-ended stack (LIFO) or queue (FIFO) structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, we can use a `ChainMap` instead of merging mappings, via `update()`.
    The result is a view of multiple mappings rather than a single, updated mapping.
    This can be built very quickly; a search takes longer than a single mapping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `OrderedDict` mapping is a mapping which maintains the order in which the
    keys were created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `defaultdict` class is a subclass of the built-in `dict` that uses a factory
    function to provide values for missing keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Counter` class is a `dict` subclass that counts objects to create frequency
    tables. It is also used as a more sophisticated data structure called a multiset
    or bag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create letter frequencies using a `Counter` class quite simply. A `Counter`
    will count the occurrences of items in the sequence. Given a string, which is
    an iterable sequence of characters, creating a `Counter` leads directly to a frequency
    table. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We've imported the `Counter` class from the `collections` module. We've also
    set a variable, `text`, to a piece of a poem by Mike Keith. For more of this poem,
    see [http://www.cadaeic.net/naraven.htm](http://www.cadaeic.net/naraven.htm).
  prefs: []
  type: TYPE_NORMAL
- en: We created a `Counter` object using the string of characters as the source.
    A `Counter` object will iterate through each item in the sequence, counting the
    number of occurrences of that item. When we use the `most_common()` method, we'll
    see the five most common items in the collection. If we were to simply print the
    value of the `freq` variable, we'd see all of the character frequencies.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these collections offers unique features. If the built-in `dict`, `list`,
    or `tuple` doesn't meet our needs, one of these additional collections may be
    more suitable for the problem we're tying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Processing collections with the for statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `for` statement is an extremely versatile way to process every item in a
    collection. We do this by defining a target variable, a source of items, and a
    suite of statements. The `for` statement will iterate through the source of items,
    assigning each item to the target variable, and also execute the suite of statements.
    All of the collections in Python provide the necessary methods, which means that
    we can use *anything* as the source of items in a `for` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s some sample data that we''ll work with. This is part of Mike Keith''s
    poem, *Near a Raven*. We''ll remove the punctuation to make the text easier to
    work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This will put the original text, with uppercase and lowercase and punctuation
    into the `text` variable. We used some method functions from [Chapter 2](ch02.html
    "Chapter 2. Simple Data Types"), *Simple Data Types*, to remove the common punctuation
    marks and return a version of the entire string entirely composed of lowercase
    letters.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use `text.split()`, we get a sequence of individual words. The `for`
    loop can iterate through this sequence of words so that we can process each one.
    The syntax looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We've created an empty dictionary, and assigned it to the `cadaeic` variable.
    The expression in the `for` loop, `text.split()`, will create a sequence of substrings.
    Each of these substrings will be assigned to the `word` variable. The `for` loop
    body—a single assignment statement—will be executed once for each value assigned
    to `word`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting dictionary might look like this (irrespective of ordering):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There's no guaranteed order for mappings or sets. Your results may differ slightly.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to iterating over a sequence, we can also iterate over the keys
    in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When we use `sorted()` on a `tuple` or a `list`, an interim list is created
    with sorted items. When we apply `sorted()` to a mapping, the sorting applies
    to the keys of the mapping, creating a sequence of sorted keys. This loop will
    print a list in alphabetical order of the various *pilish* words used in this
    poem.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pilish is a subset of English where the word lengths are important: they''re
    used as mnemonic aids.'
  prefs: []
  type: TYPE_NORMAL
- en: A `for` statement corresponds to the "for all" logical quantifier, ![Processing
    collections with the for statement](img/B03671_06_12.jpg). At the end of a simple
    `for` loop we can assert that all items in the source collection have been processed.
    In order to build the "there exists" quantifier, ![Processing collections with
    the for statement](img/B03671_06_13.jpg), we can either use the `while` statement,
    or the `break` statement inside the body of a `for` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Using literal lists in a for statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can apply the `for` statement to a sequence of literal values. One of the
    most common ways to present literals is as a `tuple`. It might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This will assign three different values to the `scheme` variable. For each of
    those values, it will evaluate the `do_something()` function.
  prefs: []
  type: TYPE_NORMAL
- en: From this, we can see that, strictly-speaking, the `()` are not required to
    delimit a `tuple` object. If the sequence of values grows, however, and we need
    to span more than one physical line, we'll want to `add ()`, making the `tuple`
    literal more explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Using the range() and enumerate() functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `range()` object will provide a sequence of numbers, often used in a `for`
    loop. The `range()` object is iterable, it's not itself a sequence object. It's
    a generator, which will produce items when required. If we use `range()` outside
    a `for` statement, we need to use a function like `list(range(x))` or `tuple(range(a,b))`
    to consume all of the generated values and create a new sequence object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `range()` object has three commonly-used forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`range(n)` produces ascending numbers including 0 but not including `n` itself.
    This is a half-open interval. We could say that `range(n)` produces numbers, *x*,
    such that ![Using the range() and enumerate() functions](img/B03671_06_07.jpg).
    The expression `list(range(5))` returns `[0, 1, 2, 3, 4]`. This produces *n* values
    including 0 and *n* - 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`range(a,b)` produces ascending numbers starting from `a` but not including
    `b`. The expression `tuple(range(-1,3))` will return `(-1, 0, 1, 2)`. This produces
    *b* - *a* values including *a* and *b* - 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`range(x,y,z)` produces ascending numbers in the sequence ![Using the range()
    and enumerate() functions](img/B03671_06_08.jpg). This produces (*y*-*x*)//*z*
    values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the `range()` object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we've used a `range()` object to produce values, *n*, such
    that ![Using the range() and enumerate() functions](img/B03671_06_09.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `range()` object to generate the index values for all items in a
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `range()` function to generate values between 0 and the length
    of the sequence object named `some_list`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for` statement allows multiple target variables. The rules for multiple
    target variables are the same as for a multiple variable assignment statement:
    a sequence object will be decomposed and items assigned to each variable. Because
    of that, we can leverage the `enumerate()` function to iterate through a sequence
    and assign the index values at the same time. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `enumerate()` function is a generator function which iterates through the
    items in source sequence and yields a sequence of two-tuple pairs with the index
    and the item. Since we've provided two variables, the two-tuple is decomposed
    and assigned to each variable.
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous use cases for this multiple-assignment `for` loop. We often
    have list-of-tuples data structures that can be handled very neatly with this
    multiple-assignment feature. In [Chapter 8](ch08.html "Chapter 8. More Advanced
    Functions"), *More Advanced Functions*, we'll look at a number of these design
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating with the while statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `while` statement is a more general iteration than the `for` statement.
    We'll use a `while` loop in two situations. We'll use this in cases where we don't
    have a finite collection to impose an upper bound on the loop's iteration; we
    may suggest an upper bound in the `while` clause itself. We'll also use this when
    writing a "search" or "there exists" kind of loop; we aren't processing all items
    in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: A desktop application that accepts input from a user, for example, will often
    have a `while` loop. The application runs until the user decides to quit; there's
    no upper bound on the number of user interactions. For this, we generally use
    a `while True:` loop. Infinite iteration is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to write a character-mode user interface, we could do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will iterate until the `quit_received` variable is set to `True`. This
    will process indefinitely; there's no upper boundary on the number of iterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `process()` function might use some kind of command processing. This should
    include a statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When the user enters `"quit"`, the `process()` function will return `True`.
    This will be assigned to the `quit_received` variable. The `while` expression,
    `not quit_received`, will become `False`, and the loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: A "there exists" loop will iterate through a collection, stopping at the first
    item that meets certain criteria. This can look complex because we're forced to
    make two details of loop processing explicit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of searching for the first value that meets a condition.
    This example assumes that we have a function, `condition()`, which will eventually
    be `True` for some number. Here''s how we can use a `while` statement to locate
    the minimum for which this function is `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `while` statement will terminate when `n == 101` or the `condition(n)` is
    `True`. If this expression is `False`, we can advance the `n` variable to the
    next value in the sequence of values. Since we're iterating through the values
    in order from the smallest to the largest, we know that `n` will be the smallest
    value for which the `condition()` function is true.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the `while` statement we have included a formal assertion that
    either `n` is 101 or the `condition()` function is `True` for the given value
    of `n`. Writing an assertion like this can help in design as well as debugging
    because it will often summarize the loop invariant condition.
  prefs: []
  type: TYPE_NORMAL
- en: We can also write this kind of loop using the `break` statement in a `for` loop,
    something we'll look at in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The continue and break statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `continue` statement is helpful for skipping items without writing deeply-nested
    `if` statements. The effect of executing a `continue` statement is to skip the
    rest of the loop's suite. In a `for` loop, this means that the next item will
    be taken from the source iterable. In a `while` loop, this must be used carefully
    to avoid an otherwise infinite iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might see file processing that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this loop, we're relying on the way files act like sequences of individual
    lines. For each line in the file, we've stripped whitespace from the input line,
    and assigned the resulting string to the `clean` variable. If the length of this
    string is zero, the line was entirely whitespace, and we'll continue the loop
    with the next line. The `continue` statement skips the remaining statements in
    the body of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll partition the line into three pieces: a portion in front of any `"#"`,
    the `"#"` (if present), and the portion after any `"#"`. We''ve assigned the `"#"`
    character and any text after the `"#"` character to the same easily-ignored variable,
    `_`, because we don''t have any use for these two results of the `partition()`
    method. We can then strip any trailing whitespace from the string assigned to
    the `data` variable. If the resulting string has a length of zero, then the line
    is entirely filled with `"#"` and any trailing comment text. Since there''s no
    useful data, we can continue the loop, ignoring this line of input.'
  prefs: []
  type: TYPE_NORMAL
- en: If the line passes the two `if` conditions, we can process the resulting data.
    By using the `continue` statement, we have avoided complex-looking, deeply-nested
    `if` statements. We'll examine files in detail in [Chapter 10](ch10.html "Chapter 10. Files,
    Databases, Networks, and Contexts"), *Files, Databases, Networks, and Contexts*.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that a `continue` statement must always be part of the
    suite inside an `if` statement, inside a `for` or `while` loop. The condition
    on that `if` statement becomes a filter condition that applies to the collection
    of data being processed. `continue` always applies to the innermost loop.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking early from a loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `break` statement is a profound change in the semantics of the loop. An
    ordinary `for` statement can be summarized by "for all." We can comfortably say
    that "for all items in a collection, the suite of statements was processed."
  prefs: []
  type: TYPE_NORMAL
- en: When we use a `break` statement, a loop is no longer summarized by "for all."
    We need to change our perspective to "there exists". A `break` statement asserts
    that at least one item in the collection matches the condition that leads to the
    execution of the `break` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple example of a `break` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We've written a loop that is bound by ![Breaking early from a loop](img/B03671_06_10.jpg).
    This loop includes a `break` statement, so it will not process all values of `n`.
    Instead, it will determine the smallest value of `n`, for which `n` is equal to
    the sum of its factors. Since the loop doesn't examine all values, it shows that
    at least one such number exists within the given range.
  prefs: []
  type: TYPE_NORMAL
- en: We've used a nested loop to determine the factors of the number `n`. This nested
    loop creates a sequence, `factors`, for all values of `x` in the range ![Breaking
    early from a loop](img/B03671_06_11.jpg), such that `x,` is a factor of the number
    `n`. This inner loop doesn't have a `break` statement, so we are sure it examines
    all values in the given range.
  prefs: []
  type: TYPE_NORMAL
- en: The least value for which this is true is the number six.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that a `break` statement must always be part of the suite
    inside an `if` statement inside a `for` or `while` loop. If the break isn't in
    an `if` suite, the loop will always terminate while processing the first item.
    The condition on that `if` statement becomes the "where exists" condition that
    summarizes the loop as a whole. Clearly, multiple `if` statements with multiple
    `break` statements mean that the overall loop can have a potentially confusing
    and difficult-to-summarize post-condition.
  prefs: []
  type: TYPE_NORMAL
- en: Using the else clause on a loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python''s `else` clause can be used on a `for` or `while` statement as well
    as on an `if` statement. The `else` clause executes after the loop body if there
    was no `break` statement executed. To see this, here''s a contrived example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `for` statement here will iterate over a short list of literal values. When
    a specific target value has been found, a message is printed. Then, the `break`
    statement will end the loop, avoiding the `else` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this, we''ll see three lines of output, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The value of three isn't shown, nor is the "Found Nothing" message in the `else`
    clause.
  prefs: []
  type: TYPE_NORMAL
- en: If we change the target value in the `if` statement from two to a value that
    won't be seen (for example, zero or four), then the output will change. If the
    `break` statement is not executed, then the `else` clause will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is to allow us to write contrasting `break` and non-`break` suites
    of statements. An `if` statement suite that includes a `break` statement can do
    some processing in the suite before the `break` statement ends the loop. An `else`
    clause allows some processing at the end of the loop when none of the `break`-related
    suites statements were executed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve looked at three mutable collections: lists, sets and dictionaries. The
    built-in dictionary class is only one of many mappings available in Python, the
    others are defined in the collections module of the standard library. The list
    allows us to collect items which are identified by their positions in the list.
    The set allows us to collect a set of unique items, in which each item is simply
    identified by itself. A mapping allows us to identify items by a key.'
  prefs: []
  type: TYPE_NORMAL
- en: For sets, each item must be immutable. For mappings, the object used as a key
    must be immutable. This means that numbers, strings, and tuples are often used
    as mapping keys.
  prefs: []
  type: TYPE_NORMAL
- en: We've looked at the `for` statement, which is the primary way we'll process
    the individual items in a collection. A simple `for` statement assures us that
    our processing has been done for all items in the collection. We've also looked
    at the general purpose `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](ch07.html "Chapter 7. Basic Function Definitions"), *Basic Function
    Definitions*, we'll look at how we can define our own functions. We'll also look
    at the wide variety of ways we can evaluate a function in Python.
  prefs: []
  type: TYPE_NORMAL
