<html><head></head><body>
		<div id="_idContainer011">
			<h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor014"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Setting Up FastAPI for Starters</h1>
			<p>In any software development work, it is always important to first know the business requirement of the project and the appropriate framework, tools, and deployment platform to use before pursuing the task. Frameworks that are easy to understand and use, seamless during coding, and within standards are always picked because of the integrity they provide to solve problems without risking too much development time. And a promising Python framework called <strong class="bold">FastAPI</strong>, created by <em class="italic">Sebastian Ramirez</em>, provides experienced developers, experts, and enthusiasts the best option for building <strong class="bold">REST APIs</strong> and microservices.</p>
			<p>But before proceeding to the core details of building microservices using FastAPI, it is best to first learn the building blocks of this framework, such as how it captures clients’ requests, how it builds the rules for each HTTP method, and how it manages HTTP responses. Learning the basic components is always essential to know the strengths and weaknesses of the framework and to what extent we can apply FastAPI to solve different enterprise-grade and microservices-related problems.</p>
			<p>Thus, in this chapter, we’re going to have a walkthrough of the basic features of FastAPI by covering the following main topics:</p>
			<ul>
				<li>The setup of the development environment</li>
				<li>Initialization and configuration of FastAPI </li>
				<li>Design and implementation of the REST APIs</li>
				<li>Managing user requests and server response</li>
				<li>Handling form parameters</li>
				<li>Handling cookies</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>The software specimen for this chapter is a prototypical administrator-managed <em class="italic">online academic discussion forum</em>, which is an academic discussion hub where alumni, teachers, and students can exchange ideas. The prototype is working but it is open for changes, so you can tweak the code while reading this chapter. It is not designed to use any database management system, but all the data is temporarily stored in various Python collections. All the applications in this book are compiled and run using <em class="italic">Python 3.8</em>. Codes are all uploaded at <a href="https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch01">https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch01</a>.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Setting up the development environment</h1>
			<p>The FastAPI framework is <a id="_idIndexMarker000"/>a fast, seamless, and robust Python framework but can only <a id="_idIndexMarker001"/>work on Python versions <em class="italic">3.6</em> and <a id="_idIndexMarker002"/>above. The <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>) used in this reference is <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>), which <a id="_idIndexMarker003"/>is an open source tool <a id="_idIndexMarker004"/>that we can download from this site: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>. Just be sure to install the VSC extensions such as <em class="italic">Python</em>, <em class="italic">Python for VS Code</em>, <em class="italic">Python Extension Pack</em>, <em class="italic">Python Indent</em>, and <em class="italic">Material Icon Theme</em> to provide your editor syntax checking, syntax highlighting, and other editor support.</p>
			<p>After the successful installation of Python and VS Code, we can now install FastAPI using a terminal console. To ensure correct installation, first update Python’s package installer (<strong class="source-inline">pip</strong>) by running this command:</p>
			<p class="source-code">python -m pip install --upgrade pip</p>
			<p>Afterward, we install the framework by running this series of commands:</p>
			<p class="source-code">pip install fastapi</p>
			<p class="source-code">pip install uvicorn[standard]</p>
			<p class="source-code">pip install python-multipart</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you need to install the complete FastAPI platform, including all optional dependencies, the appropriate command is <strong class="source-inline">pip install fastapi[all]</strong>. Likewise, if you want to install and utilize the full-blown <strong class="source-inline">uvicorn</strong> server, you should run the <strong class="source-inline">pip install uvicorn</strong> command. Also, install the <strong class="source-inline">bcrypt</strong> module for encryption-related tasks.</p>
			<p>At this point, you <a id="_idIndexMarker005"/>should have installed all <a id="_idIndexMarker006"/>the needed FastAPI <a id="_idIndexMarker007"/>module dependencies from the <strong class="bold">pydantic</strong> and <strong class="bold">starlette</strong> module components in your Python environment. Furthermore, the <strong class="bold">python-multipart</strong> module <a id="_idIndexMarker008"/>is required to create a REST API that handles form parameters. The installed <strong class="source-inline">uvicorn</strong>, however, is an ASGI-based <a id="_idIndexMarker009"/>server that will run your FastAPI applications. The <strong class="bold">Asynchronous Server Gateway Interface</strong> (<strong class="bold">ASGI</strong>) server that FastAPI uses makes it the fastest Python framework at the time of writing. The <strong class="source-inline">uvicorn</strong> server has the capability to run both synchronous and asynchronous services.</p>
			<p>After the installation and configuration of the essential tools, modules, and IDE, let us now start our first API implementation using the framework.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Initializing and configuring FastAPI</h1>
			<p>Learning how <a id="_idIndexMarker010"/>to create applications using FastAPI is easy and straightforward. A simple <a id="_idIndexMarker011"/>application can be created just by creating a <strong class="source-inline">main.py</strong> file inside your <strong class="source-inline">/ch01</strong> project folder. In our <em class="italic">online academic discussion forum</em>, for instance, the application started with this code:</p>
			<pre class="source-code">
from fastapi import <strong class="bold">FastAPI</strong>
<strong class="bold">app = FastAPI()</strong></pre>
			<p>This initializes the FastAPI framework. The application needs to instantiate the core <strong class="source-inline">FastAPI</strong> class from the <strong class="source-inline">fastapi</strong> module and use <strong class="source-inline">app</strong> as the reference variable to the object. Then, this object is used later as a Python <strong class="source-inline">@app</strong> decorator, which provides our application with some features such as <em class="italic">routes</em>, <em class="italic">middleware</em>, <em class="italic">exception handlers</em>, and <em class="italic">path operations</em>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">You can replace <strong class="source-inline">app</strong> with your preferred but valid Python variable name, such as <strong class="source-inline">main_app</strong>, <strong class="source-inline">forum</strong>, or <strong class="source-inline">myapp</strong>.</p>
			<p>Now, your application is ready to manage REST APIs that are technically Python functions. But to <a id="_idIndexMarker012"/>declare them as REST service methods, we need to decorate them <a id="_idIndexMarker013"/>with the appropriate HTTP request method provided by the path operation <strong class="source-inline">@app</strong> decorator. This decorator contains the <strong class="source-inline">get()</strong>, <strong class="source-inline">post()</strong>, <strong class="source-inline">delete()</strong>, <strong class="source-inline">put()</strong>, <strong class="source-inline">head()</strong>, <strong class="source-inline">patch()</strong>, <strong class="source-inline">trace()</strong>, and <strong class="source-inline">options()</strong> path operations, which correspond to the eight HTTP request methods. And these <em class="italic">path operations</em> are decorated or annotated on top of the Python functions that we want to handle the request and response.</p>
			<p>In our specimen, the first sample that the REST API created was this:</p>
			<pre class="source-code">
<strong class="bold">@app.get("/ch01/index")</strong>
def index():
    return {"message": "Welcome FastAPI Nerds"} </pre>
			<p>The preceding is a <strong class="source-inline">GET</strong> API service method that returns a <strong class="source-inline">JSON</strong> object. To locally run our application, we need to execute the following command:</p>
			<p class="source-code">uvicorn main:app --reload</p>
			<p>This command will load the forum application to the uvicorn live server through the application’s <strong class="source-inline">main.py</strong> file with FastAPI object referencing. Live reload is allowed by adding the <strong class="source-inline">--reload</strong> option, which enables the restart of the development server whenever there are changes in the code. </p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/Figure_1.1_B17975.jpg" alt="Figure 1.1 – The uvicorn console log"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – The uvicorn console log</p>
			<p><em class="italic">Figure 1.1</em> shows that uvicorn uses <strong class="source-inline">localhost</strong> to run the application with the default port <strong class="source-inline">8000</strong>. We <a id="_idIndexMarker014"/>can access our index page through <strong class="source-inline">http://localhost:8000/ch01/index</strong>. To <a id="_idIndexMarker015"/>stop the server, you just need to press the <em class="italic">Ctrl</em> + <em class="italic">C</em> keyboard keys.</p>
			<p>After running our first endpoint, let us now explore how to implement the other types of HTTP methods, namely <strong class="source-inline">POST</strong>, <strong class="source-inline">DELETE</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">PATCH</strong>.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Designing and implementing REST APIs</h1>
			<p>The <strong class="bold">Representation State Transfer</strong> (<strong class="bold">REST</strong>) API makes up the rules, processes, and tools that allow <a id="_idIndexMarker016"/>interaction among <a id="_idIndexMarker017"/>microservices. These are method <a id="_idIndexMarker018"/>services that are identified and executed through their endpoint URLs. Nowadays, focusing on API methods before building a whole application is one of the most <a id="_idIndexMarker019"/>popular and effective microservices design strategies. This approach, called an <strong class="bold">API-first</strong> microservices development, focuses first on the client’s needs and then later identifies what API service methods we need to implement for these client requirements.</p>
			<p>In our <em class="italic">online academic discussion forum</em> app, software functionality such as <em class="italic">user sign-up</em>, <em class="italic">login</em>, <em class="italic">profile management</em>, <em class="italic">message posting</em>, and <em class="italic">managing post replies</em> are some of the crucial needs we prioritized. In a FastAPI framework, these features are implemented as services using functions that are defined using Python’s <strong class="source-inline">def</strong> keyword, with the association of the appropriate HTTP request method through the <em class="italic">path operations</em> provided by <strong class="source-inline">@app</strong>.</p>
			<p>The <strong class="source-inline">login</strong> service, which requires <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> request parameters from the user, is implemented as a <strong class="source-inline">GET</strong> API method:</p>
			<pre class="source-code">
<strong class="bold">@app.get("/ch01/login/")</strong>
def <strong class="bold">login</strong>(username: str, password: str):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    else:
        user = valid_users.get(username)
        if checkpw(password.encode(), 
                   user.passphrase.encode()):
            return user
        else:
            return {"message": "invalid user"}</pre>
			<p>This <em class="italic">login</em> service uses bcrypt’s <strong class="source-inline">checkpw()</strong> function to check whether the password of the user <a id="_idIndexMarker020"/>is valid. Conversely, the <em class="italic">sign-up</em> service, which <a id="_idIndexMarker021"/>also requires user credentials from the client in the form of request parameters, is created as a <strong class="source-inline">POST</strong> API method:</p>
			<pre class="source-code">
<strong class="bold">@app.post("/ch01/login/signup")</strong>
def <strong class="bold">signup</strong>(uname: str, passwd: str):
    if (uname == None and passwd == None):
        return {"message": "invalid user"}
    elif not valid_users.get(uname) == None:
        return {"message": "user exists"}
    else:
        user = User(username=uname, password=passwd)
        pending_users[uname] = user
        return user</pre>
			<p>Among the <em class="italic">profile management</em> services, the following <strong class="source-inline">update_profile()</strong> service serves as a <strong class="source-inline">PUT</strong> API service, which requires the user to use an entirely new model object for profile information replacement and the client’s username to serve as the key:</p>
			<pre class="source-code">
<strong class="bold">@app.put("/ch01/account/profile/update/{username}")</strong>
def <strong class="bold">update_profile</strong>(username: str, id: UUID, 
                     <strong class="bold">new_profile: UserProfile</strong>):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    else:
        user = valid_users.get(username)
        if user.id == id:
            valid_profiles[username] = new_profile
            return {"message": "successfully updated"}
        else:
            return {"message": "user does not exist"}</pre>
			<p>Not all <a id="_idIndexMarker022"/>services that carry out updates <a id="_idIndexMarker023"/>are <strong class="source-inline">PUT</strong> API methods, such as the following <strong class="source-inline">update_profile_name()</strong> service, which only requires the user to submit a new first name, last name, and middle initial for partial replacement of a client’s profile. This HTTP request, which is handier and more lightweight than a full-blown <strong class="source-inline">PUT</strong> method, only requires a <strong class="source-inline">PATCH</strong> action:</p>
			<pre class="source-code">
<strong class="bold">@app.patch("/ch01/account/profile/update/names/{username}")</strong>
def <strong class="bold">update_profile_names</strong>(username: str, id: UUID, 
                          <strong class="bold">new_names: Dict[str, str]</strong>):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    elif new_names == None:
        return {"message": "new names are required"}
    else:
        user = valid_users.get(username)
        if user.id == id:
            profile = valid_profiles[username]
            profile.firstname = new_names['fname']
            profile.lastname = new_names['lname']
            profile.middle_initial = new_names['mi']
            valid_profiles[username] = profile
            return {"message": "successfully updated"}
        else:
            return {"message": "user does not exist"}</pre>
			<p>The last <a id="_idIndexMarker024"/>essential HTTP services that <a id="_idIndexMarker025"/>we included before building the application are the <strong class="source-inline">DELETE</strong> API methods. We use these services to delete records or information given a unique identification, such as <strong class="source-inline">username</strong> and a hashed <strong class="source-inline">id</strong>. An example is the following <strong class="source-inline">delete_post_discussion()</strong> service that allows a user to delete a posted discussion when given a username and the UUID (Universally Unique Identifier) of the posted message:</p>
			<pre class="source-code">
<strong class="bold">@app.delete("/ch01/discussion/posts/remove/{username}")</strong>
def <strong class="bold">delete_discussion</strong>(username: str, id: UUID):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    elif discussion_posts.get(id) == None:
        return {"message": "post does not exist"}
    else:
        del discussion_posts[id] 
        return {"message": "main post deleted"}</pre>
			<p>All path operations require a unique endpoint URL in the <strong class="source-inline">str</strong> format. A good practice is to start all URLs with the same top-level base path, such as <strong class="source-inline">/ch01</strong>, and then differ when reaching their respective subdirectories. After running the uvicorn server, we can check and validate whether all our URLs are valid and running by accessing the documentation <a id="_idIndexMarker026"/>URL, <strong class="source-inline">http://localhost:8000/docs</strong>. This path will show us a <strong class="bold">OpenAPI</strong> dashboard, as shown in <em class="italic">Figure 1.2</em>, listing all the API methods created for the application. Discussions on the OpenAPI will be covered in <a href="B17975_09.xhtml#_idTextAnchor266"><em class="italic">Chapter 9</em></a><em class="italic">, Utilizing Other Advanced Features</em>.</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/Figure_1.2_B17975.jpg" alt="Figure 1.2 – A Swagger OpenAPI dashboard"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – A Swagger OpenAPI dashboard</p>
			<p>After creating <a id="_idIndexMarker027"/>the endpoint services, let us scrutinize how FastAPI manages its incoming request body and the outgoing response.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Managing user requests and server response</h1>
			<p>Clients can pass their request data to FastAPI endpoint URLs through path parameters, query <a id="_idIndexMarker028"/>parameters, or headers to pursue service transactions. There are <a id="_idIndexMarker029"/>standards and ways to use these parameters to obtain incoming requests. Depending on the goal of the services, we use these parameters to influence and build the necessary responses the clients need. But before we discuss these various parameter types, let us explore first how we use <em class="italic">type hinting</em> in FastAPI’s local parameter declaration.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Parameter type declaration</h2>
			<p>All request <a id="_idIndexMarker030"/>parameters are required to be type-declared in the method signature of the service method applying the <strong class="bold">PEP 484</strong> standard called <em class="italic">type hints</em>. FastAPI supports common types <a id="_idIndexMarker031"/>such as <strong class="source-inline">None</strong>, <strong class="source-inline">bool</strong>, <strong class="source-inline">int</strong>, and <strong class="source-inline">float</strong> and container types such as <strong class="source-inline">list</strong>, <strong class="source-inline">tuple</strong>, <strong class="source-inline">dict</strong>, <strong class="source-inline">set</strong>, <strong class="source-inline">frozenset</strong>, and <strong class="source-inline">deque</strong>. Other complex Python types such as <strong class="source-inline">datetime.date</strong>, <strong class="source-inline">datetime.time</strong>, <strong class="source-inline">datetime.datetime</strong>, <strong class="source-inline">datetime.delta</strong>, <strong class="source-inline">UUID</strong>, <strong class="source-inline">bytes</strong>, and <strong class="source-inline">Decimal</strong> are also supported. </p>
			<p>The framework also supports the data types included in Python’s <strong class="source-inline">typing</strong> module, responsible for <em class="italic">type hints</em>. These data types are standard notations for Python and variable type <a id="_idIndexMarker032"/>annotations that can help to pursue type checking and model validation during compilation, such as <strong class="source-inline">Optional</strong>, <strong class="source-inline">List</strong>, <strong class="source-inline">Dict</strong>, <strong class="source-inline">Set</strong>, <strong class="source-inline">Union</strong>, <strong class="source-inline">Tuple</strong>, <strong class="source-inline">FrozenSet</strong>, <strong class="source-inline">Iterable</strong>, and <strong class="source-inline">Deque</strong>.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Path parameters</h2>
			<p>FastAPI allows you <a id="_idIndexMarker033"/>to obtain request data from the endpoint URL of an API through <a id="_idIndexMarker034"/>a path parameter or path variable that makes the URL somewhat dynamic. This parameter holds a value that becomes part of a URL indicated by curly braces (<strong class="source-inline">{}</strong>). After setting off these path parameters within the URL, FastAPI requires these parameters to be declared by applying <em class="italic">type hints</em>. </p>
			<p>The following <strong class="source-inline">delete_user()</strong> service is a <strong class="source-inline">DELETE</strong> API method that uses a <strong class="source-inline">username</strong> path parameter to search for a login record for deletion:</p>
			<pre class="source-code">
@app.delete("/ch01/login/remove/{<strong class="bold">username</strong>}")
def delete_user(<strong class="bold">username: str</strong>):
    if username == None:
    return {"message": "invalid user"}
else:
    del valid_users[username]
    return {"message": "deleted user"}</pre>
			<p>Multiple path parameters are acceptable if the leftmost variables are more likely to be filled with values than the rightmost variables. In other words, the importance of the leftmost path variables will make the process more relevant and correct than those on the right. This standard is applied to ensure that the endpoint URL will not look like other URLs, which might cause some conflicts and confusion. The following <strong class="source-inline">login_with_token()</strong> service follows this standard, since <strong class="source-inline">username</strong> is a primary key and is as strong as, or even stronger than, its next parameter, <strong class="source-inline">password</strong>. There is an assurance that the URL will always look unique every time the endpoint is accessed because <strong class="source-inline">username</strong> will always be required, as well as <strong class="source-inline">password</strong>:</p>
			<pre class="source-code">
@app.get("/ch01/login/<strong class="bold">{username}</strong>/<strong class="bold">{password}</strong>")
def login_with_token(<strong class="bold">username: str</strong>, <strong class="bold">password:str</strong>, 
                     id: UUID):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    else:
        user = valid_users[username]
        if user.id == id and checkpw(password.encode(), 
                 user.passphrase):
            return user
        else:
            return {"message": "invalid user"}</pre>
			<p>Unlike other web frameworks, FastAPI is not friendly with endpoint URLs that belong to base paths or <a id="_idIndexMarker035"/>top-level domain paths with different subdirectories. This <a id="_idIndexMarker036"/>occurrence happens when we have dynamic URL patterns that look the same as the other fixed endpoint URLs when assigned a specific path variable. These fixed URLs are implemented sequentially after these dynamic URLs. An example of these are the following services:</p>
			<pre class="source-code">
<strong class="bold">@app.get("/ch01/login/{username}/{password}")</strong>
def login_with_token(<strong class="bold">username: str</strong>, <strong class="bold">password:str</strong>, 
                     <strong class="bold">id: UUID</strong>):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    else:
        user = valid_users[username]
        if user.id == id and checkpw(password.encode(), 
                      user.passphrase.encode()):
            return user
        else:
            return {"message": "invalid user"}
<strong class="bold">@app.get("/ch01/login/details/info")</strong>
def login_info():
        return {"message": "username and password are 
                            needed"}</pre>
			<p>This will give us an <em class="italic">HTTP Status Code 422</em> (<em class="italic">Unprocessable Entity</em>) when accessing <strong class="source-inline">http://localhost:8080/ch01/login/details/info</strong>. There should be no problem accessing the URL, since the API service is almost a stub or trivial JSON data. What happened <a id="_idIndexMarker037"/>in this scenario is that the fixed path’s <strong class="source-inline">details</strong> and <strong class="source-inline">info</strong> path <a id="_idIndexMarker038"/>directories were treated as <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> parameter values, respectively. Because of confusion, the built-in data validation of FastAPI will show us a JSON-formatted error message that says, <strong class="source-inline">{"detail":[{"loc":["query","id"],"msg":"field required","type":"value_error.missing"}]}</strong>. To fix this problem, all fixed paths should be declared first before the dynamic endpoint URLs with path parameters. Thus, the preceding <strong class="source-inline">login_info()</strong> service should be declared first before <strong class="source-inline">login_with_token()</strong>.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Query parameters</h2>
			<p>A query parameter is a <em class="italic">key–value</em> pair supplied after the end of an endpoint URL, indicated by a <a id="_idIndexMarker039"/>question mark (<strong class="source-inline">?</strong>). Just like the path parameter, this also holds the <a id="_idIndexMarker040"/>request data. An API service can manage a series of query parameters separated by an ampersand (<strong class="source-inline">&amp;</strong>). Like in path parameters, all query parameters are also declared in the service method. The following <em class="italic">login</em> service is a perfect specimen that uses query parameters:</p>
			<pre class="source-code">
<strong class="bold">@app.get("/ch01/login/")</strong>
def login(<strong class="bold">username: str</strong>, <strong class="bold">password: str</strong>):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    else:
        user = valid_users.get(username)
        if checkpw(password.encode(), 
               user.passphrase.encode()):
            return user
        else:
            return {"message": "invalid user"}</pre>
			<p>The <strong class="source-inline">login</strong> service method uses <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> as query parameters in the <strong class="source-inline">str</strong> types. Both are required parameters, and assigning them with <strong class="source-inline">None</strong> as parameter values will give a compiler error.</p>
			<p>FastAPI supports <a id="_idIndexMarker041"/>query parameters that are complex types, such as <strong class="source-inline">list</strong> and <strong class="source-inline">dict</strong>. But <a id="_idIndexMarker042"/>these Python collection types cannot specify the type of objects to store unless we apply the <em class="italic">generic type hints</em> for Python collections. The following <strong class="source-inline">delete_users()</strong> and <strong class="source-inline">update_profile_names()</strong> APIs use generic type hints, <strong class="source-inline">List</strong> and <strong class="source-inline">Dict</strong>, in declaring query parameters that are container types with type checking and data validation:</p>
			<pre class="source-code">
from typing import Optional, <strong class="bold">List</strong>, <strong class="bold">Dict</strong>
<strong class="bold">@app.delete("/ch01/login/remove/all")</strong>
def delete_users(<strong class="bold">usernames: List[str]</strong>):
    for user in usernames:
        del valid_users[user]
    return {"message": "deleted users"}
<strong class="bold">@app.patch("/ch01/account/profile/update/names/{username}")</strong>
def update_profile_names(username: str, id: UUID, 
                         <strong class="bold">new_names: Dict[str, str]</strong>):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    elif new_names == None:
        return {"message": "new names are required"}
    else:
        user = valid_users.get(username)
        if user.id == id:
            profile = valid_profiles[username]
            profile.firstname = new_names['fname']
            profile.lastname = new_names['lname']
            profile.middle_initial = new_names['mi']
            valid_profiles[username] = profile
            return {"message": "successfully updated"}
        else:
            return {"message": "user does not exist"}</pre>
			<p>FastAPI also <a id="_idIndexMarker043"/>allows you to explicitly assign default values to service <a id="_idIndexMarker044"/>function parameters. </p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Default parameters</h2>
			<p>There are times that we <a id="_idIndexMarker045"/>need to specify default values to the query parameter(s) and <a id="_idIndexMarker046"/>path parameter(s) of some API services to avoid validation error messages such as <strong class="source-inline">field required</strong> and <strong class="source-inline">value_error.missing</strong>. Setting default values to parameters will allow the execution of an API method with or without supplying the parameter values. Depending on the requirement, assigned default values are usually <strong class="source-inline">0</strong> for numeric types, <strong class="source-inline">False</strong> for bool types, empty string for string types, an empty list (<strong class="source-inline">[]</strong>) for List types, and an empty dictionary (<strong class="source-inline">{}</strong>) for <strong class="source-inline">Dict</strong> types. The following <strong class="source-inline">delete pending users()</strong> and <strong class="source-inline">change_password()</strong> services show us how to apply default values to the query parameter(s) and path parameter(s):</p>
			<pre class="source-code">
<strong class="bold">@app.delete("/ch01/delete/users/pending")</strong>
def delete_pending_users(<strong class="bold">accounts: List[str] = []</strong>):
    for user in accounts:
        del pending_users[user]
    return {"message": "deleted pending users"}
<strong class="bold">@app.get("/ch01/login/password/change")</strong>
def change_password(username: str, <strong class="bold">old_passw: str = ''</strong>,
                         <strong class="bold">new_passw: str = ''</strong>):
    passwd_len = 8
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    elif old_passw == '' or new_passw == '':
        characters = ascii_lowercase
        temporary_passwd = 
             ''.join(random.choice(characters) for i in 
                     range(passwd_len))
        user = valid_users.get(username)
        user.password = temporary_passwd
        user.passphrase = 
                  hashpw(temporary_passwd.encode(),gensalt())
        return user
    else:
        user = valid_users.get(username)
        if user.password == old_passw:
            user.password = new_passw
            user.passphrase = hashpw(new_pass.encode(),gensalt())
            return user
        else:
            return {"message": "invalid user"}</pre>
			<p><strong class="source-inline">delete_pending_users()</strong> can be executed even without passing any accounts argument, since accounts will be <a id="_idIndexMarker047"/>always an empty <strong class="source-inline">List</strong> by default. Likewise, <strong class="source-inline">change_password()</strong> can <a id="_idIndexMarker048"/>still continue its process without passing any <strong class="source-inline">old_passwd</strong> and <strong class="source-inline">new_passw</strong>, since they are both always defaulted to empty <strong class="source-inline">str</strong>. <strong class="source-inline">hashpw()</strong> is a <strong class="source-inline">bcrypt</strong> utility function that generates a hashed passphrase from an autogenerated <em class="italic">salt</em>.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Optional parameters</h2>
			<p>If the <em class="italic">path</em> and/or <em class="italic">query parameter(s)</em> of a service is/are not necessarily needed to be supplied by the <a id="_idIndexMarker049"/>user, meaning the API transactions can proceed with or without <a id="_idIndexMarker050"/>their inclusion in the request transaction, then we set them as <em class="italic">optional</em>. To declare an optional parameter, we need to import the <strong class="source-inline">Optional</strong> type from the <strong class="source-inline">typing</strong> module and then use it to set the parameter. It should wrap the supposed data type of the parameter using brackets (<strong class="source-inline">[]</strong>) and can have <em class="italic">any default value</em> if needed. Assigning the <strong class="source-inline">Optional</strong> parameter to a <strong class="source-inline">None</strong> value indicates that its exclusion from the parameter passing is allowed by the service, but it will hold a <strong class="source-inline">None</strong> value. The following services depict the use of optional parameters:</p>
			<pre class="source-code">
from typing import <strong class="bold">Optional</strong>, List, Dict
<strong class="bold">@app.post("/ch01/login/username/unlock")</strong>
def unlock_username(id: <strong class="bold">Optional[UUID] = None</strong>):
    <strong class="bold">if id == None:</strong>
        return {"message": "token needed"}
    else:
        for key, val in valid_users.items():
            if val.id == id:
                return {"username": val.username}
        return {"message": "user does not exist"}
<strong class="bold">@app.post("/ch01/login/password/unlock")</strong>
def unlock_password(<strong class="bold">username: Optional[str] = None</strong>, 
                    <strong class="bold">id: Optional[UUID] = None</strong>):
    <strong class="bold">if username == None:</strong>
        return {"message": "username is required"}
    elif valid_users.get(username) == None:
        return {"message": "user does not exist"}
    else:
        <strong class="bold">if id == None:</strong>
            return {"message": "token needed"}
        else:
            user = valid_users.get(username)
            if user.id == id:
                return {"password": user.password}
            else:
                return {"message": "invalid token"}</pre>
			<p>In the <em class="italic">online academic discussion forum</em> application, we have services such as the preceding <strong class="source-inline">unlock_username()</strong> and <strong class="source-inline">unlock_password()</strong> services that declare all their parameters as <strong class="source-inline">optional</strong>. Just do not <a id="_idIndexMarker051"/>forget to apply exception handling or defensive <a id="_idIndexMarker052"/>validation in your implementation when dealing with these kinds of parameters to avoid <em class="italic">HTTP Status 500</em> (<em class="italic">Internal Server Error</em>).</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The FastAPI framework does not allow you to directly assign the <strong class="source-inline">None</strong> value to a parameter just to declare an <em class="italic">optional</em> parameter. Although this is allowed with the old Python behavior, this is no longer recommended in the current Python versions for the purpose of built-in type checking and model validation.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Mixing all types of parameters</h2>
			<p>If you are planning to <a id="_idIndexMarker053"/>implement an API service method that declares optional, required, and default query and path parameters altogether, you can pursue it because the framework supports it, but approach it with some caution due to some standards and rules:</p>
			<pre class="source-code">
@app.patch("/ch01/account/profile/update/names/<strong class="bold">{username}</strong>")
def update_profile_names(<strong class="bold">id: UUID</strong>, <strong class="bold">username: str = ''</strong> , 
           <strong class="bold">new_names: Optional[Dict[str, str]] = None</strong>):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    elif new_names == None:
        return {"message": "new names are required"}
    else:
        user = valid_users.get(username)
        if user.id == id:
            profile = valid_profiles[username]
            profile.firstname = new_names['fname']
            profile.lastname = new_names['lname']
            profile.middle_initial = new_names['mi']
            valid_profiles[username] = profile
            return {"message": "successfully updated"}
        else:
            return {"message": "user does not exist"}</pre>
			<p>The updated version of the preceding <strong class="source-inline">update_profile_names()</strong> service declares a <strong class="source-inline">username</strong> path parameter, a <strong class="source-inline">UUID</strong> id query parameter, and an optional <strong class="source-inline">Dict[str, str]</strong> type. With mixed parameter types, all required parameters should be declared <a id="_idIndexMarker054"/>first, followed by default parameters, and last in the parameter list should be the optional types. Disregarding this ordering rule will generate a <em class="italic">compiler error</em>.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Request body</h2>
			<p>A <em class="italic">request body</em> is a body <a id="_idIndexMarker055"/>of data in bytes transmitted from a client to a server <a id="_idIndexMarker056"/>through a <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">DELETE</strong>, or <strong class="source-inline">PATCH</strong> HTTP method operation. In FastAPI, a service must declare a model object to represent and capture this request body to be processed for further results.</p>
			<p>To implement a model class for the <em class="italic">request body</em>, you should first import the <strong class="source-inline">BaseModel</strong> class from the <strong class="source-inline">pydantic</strong> module. Then, create a subclass of it to utilize all the properties and behavior needed by the path operation in capturing the request body. Here are some of the data models used by our application:</p>
			<pre class="source-code">
from pydantic import <strong class="bold">BaseModel</strong>
class User(<strong class="bold">BaseModel</strong>):
    username: str
    password: str
class UserProfile(<strong class="bold">BaseModel</strong>):
    firstname: str
    lastname: str
    middle_initial: str
    age: Optional[int] = 0
    salary: Optional[int] = 0
    birthday: date
    user_type: UserType</pre>
			<p>The attributes of the model classes must be explicitly declared by applying <em class="italic">type hints</em> and utilizing the common and complex data types used in the parameter declaration. These attributes can also be set as required, default, and optional, just like in the parameters.</p>
			<p>Moreover, the <strong class="source-inline">pydantic</strong> module <a id="_idIndexMarker057"/>allows the creation of nested models, even the deeply <a id="_idIndexMarker058"/>nested ones. A sample of these is shown here:    </p>
			<pre class="source-code">
class ForumPost(<strong class="bold">BaseModel</strong>):
    id: UUID
    topic: Optional[str] = None
    message: str
    <strong class="bold">post_type: PostType</strong>
    date_posted: datetime
    username: str
class ForumDiscussion(<strong class="bold">BaseModel</strong>):
    id: UUID
    <strong class="bold">main_post: ForumPost</strong>
    <strong class="bold">replies: Optional[List[ForumPost]] = None</strong>
    <strong class="bold">author: UserProfile</strong></pre>
			<p>As seen in the preceding code, we have a <strong class="source-inline">ForumPost</strong> model, which has a <strong class="source-inline">PostType</strong> model attribute, and <strong class="source-inline">ForumDiscussion</strong>, which has a <strong class="source-inline">List</strong> attribute of <strong class="source-inline">ForumPost</strong>, a <strong class="source-inline">ForumPost</strong> model attribute, and a <strong class="source-inline">UserProfile</strong> attribute. This kind of model <a id="_idIndexMarker059"/>blueprint is called a <em class="italic">nested model approach</em>.</p>
			<p>After creating these model classes, you can now <em class="italic">inject</em> these objects into the services that are intended <a id="_idIndexMarker060"/>to capture the <em class="italic">request body</em> from the clients. The following <a id="_idIndexMarker061"/>services utilize our <strong class="source-inline">User</strong> and <strong class="source-inline">UserProfile</strong> model classes to manage the request body:</p>
			<pre class="source-code">
<strong class="bold">@app.post("/ch01/login/validate", response_model=ValidUser)</strong>
def approve_user(<strong class="bold">user: User</strong>):
    if not valid_users.get(user.username) == None:
        return <strong class="bold">ValidUser(id=None, username = None,</strong> 
             <strong class="bold">password = None, passphrase = None)</strong>
    else:
        valid_user = <strong class="bold">ValidUser(id=uuid1(),</strong> 
             <strong class="bold">username= user.username, </strong>
             <strong class="bold">password  = user.password, </strong>
             <strong class="bold">passphrase = hashpw(user.password.encode(),</strong>
                          <strong class="bold">gensalt()))</strong>
        valid_users[user.username] = valid_user
        del pending_users[user.username]
        return valid_user
<strong class="bold">@app.put("/ch01/account/profile/update/{username}")</strong>
def update_profile(<strong class="bold">username: str</strong>, <strong class="bold">id: UUID</strong>, 
                   <strong class="bold">new_profile: UserProfile</strong>):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    else:
        user = valid_users.get(username)
        if user.id == id:
            valid_profiles[username] = new_profile
            return {"message": "successfully updated"}
        else:
            return {"message": "user does not exist"}</pre>
			<p>Models can be declared <em class="italic">required</em>, with a <em class="italic">default</em> instance value, or <em class="italic">optional</em> in the service method, depending <a id="_idIndexMarker062"/>on the specification of the API. Missing or incorrect details <a id="_idIndexMarker063"/>such as <strong class="source-inline">invalid password</strong> or <strong class="source-inline">None</strong> values in the <strong class="source-inline">approve_user()</strong> service will emit the <em class="italic">Status Code 500</em> (<em class="italic">Internal Server Error</em>). How FastAPI handles exceptions will be part of <a href="B17975_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a><em class="italic">,</em> <em class="italic">Exploring the Core Features,</em> discussions.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">There are two essential points we need to emphasize when dealing with <strong class="source-inline">BaseModel</strong> class types. First, the <strong class="source-inline">pydantic</strong> module has a built-in JSON encoder that converts the JSON-formatted request body to the <strong class="source-inline">BaseModel</strong> object. So, there is no need create a custom converter to map the request body to the <strong class="source-inline">BaseModel</strong> model. Second, to instantiate a <strong class="source-inline">BaseModel</strong> class, all its required attributes must be initialized immediately through the constructor’s named parameters.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Request headers</h2>
			<p>In a request-response transaction, it <a id="_idIndexMarker064"/>is not only the parameters that are <a id="_idIndexMarker065"/>accessible by the REST API methods but also the information that describes the context of the client where the request originated. Some common request headers such as <strong class="source-inline">User-Agent</strong>, <strong class="source-inline">Host</strong>, <strong class="source-inline">Accept</strong>, <strong class="source-inline">Accept-Language</strong>, <strong class="source-inline">Accept-Encoding</strong>, <strong class="source-inline">Referer</strong>, and <strong class="source-inline">Connection</strong> usually appear with request parameters and values during request transactions. </p>
			<p>To access a request header, import first the <strong class="source-inline">Header</strong> function from the <strong class="source-inline">fastapi</strong> module. Then, declare the variable that has the same name as the header in the method service as <strong class="source-inline">str</strong> types and initialize the variable by calling the <strong class="source-inline">Header(None)</strong> function.  The <strong class="source-inline">None</strong> argument enables the <strong class="source-inline">Header()</strong> function to declare the variable optionally, which is a best practice. For hyphenated request header names, the hyphen (<strong class="source-inline">-</strong>) should be converted to an underscore (<strong class="source-inline">_</strong>); otherwise, the Python compiler will flag a syntax error message. It is the task of the <strong class="source-inline">Header()</strong> function to convert the underscore (<strong class="source-inline">_</strong>) to a hyphen (<strong class="source-inline">-</strong>) during request header processing.</p>
			<p>Our online academic discussion forum application has a <strong class="source-inline">verify_headers()</strong> service <a id="_idIndexMarker066"/>that retrieves core request headers needed to verify a client’s access to the application:</p>
			<pre class="source-code">
from fastapi import <strong class="bold">Header</strong>
<strong class="bold">@app.get("/ch01/headers/verify")</strong>
def verify_headers(<strong class="bold">host: Optional[str] = Header(None)</strong>, 
                   <strong class="bold">accept: Optional[str] = Header(None)</strong>,
                   <strong class="bold">accept_language: </strong>
                       <strong class="bold">Optional[str] = Header(None)</strong>,
                   <strong class="bold">accept_encoding: </strong>
                       <strong class="bold">Optional[str] = Header(None)</strong>,
                   <strong class="bold">user_agent</strong>: 
                       <strong class="bold">Optional[str] = Header(None)</strong>):
    request_headers["Host"] = host
    request_headers["Accept"] = accept
    request_headers["Accept-Language"] = accept_language
    request_headers["Accept-Encoding"] = accept_encoding
    request_headers["User-Agent"] = user_agent
    return request_headers</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout">Non-inclusion of the <strong class="source-inline">Header()</strong> function call in the declaration will let FastAPI treat the variables as <em class="italic">query parameters</em>. Be cautious also with the spelling of the local parameter names, since they <em class="italic">are</em> the request header names per se except for the underscore.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Response data</h2>
			<p>All API services in FastAPI <a id="_idIndexMarker067"/>should return <strong class="source-inline">JSON</strong> data, or it will be invalid and may <a id="_idIndexMarker068"/>return <strong class="source-inline">None</strong> by default. These responses can be formed using <strong class="source-inline">dict</strong>, <strong class="source-inline">BaseModel</strong>, or <strong class="source-inline">JSONResponse</strong> objects. Discussions on <strong class="source-inline">JSONResponse</strong> will be discussed in the succeeding chapters. </p>
			<p>The <strong class="source-inline">pydantic</strong> module’s built-in JSON converter will manage the conversion of these custom responses to a JSON object, so there is no need to create a custom JSON encoder:</p>
			<pre class="source-code">
@app.post("/ch01/discussion/posts/add/{username}")
def post_discussion(username: str, post: Post, 
                    post_type: PostType):
    if valid_users.get(username) == None:
        return <strong class="bold">{"message": "user does not exist"}</strong>
    elif not (discussion_posts.get(id) == None):
        return <strong class="bold">{"message": "post already exists"}</strong>
    else:
        forum_post = ForumPost(id=uuid1(), 
          topic=post.topic, message=post.message, 
          post_type=post_type, 
          date_posted=post.date_posted, username=username)
        user = valid_profiles[username]
        <strong class="bold">forum = ForumDiscussion(id=uuid1(), </strong>
         <strong class="bold">main_post=forum_post, author=user, replies=list())</strong>
        discussion_posts[forum.id] = forum
        return <strong class="bold">forum</strong></pre>
			<p>The preceding <strong class="source-inline">post_discussion()</strong> service returns two different hardcoded <strong class="source-inline">dict</strong> objects, with <strong class="source-inline">message</strong> as the key and an instantiated <strong class="source-inline">ForumDiscussion</strong> model.</p>
			<p>On the other hand, this framework allows us to specify the return type of a service method. The setting <a id="_idIndexMarker069"/>of the return type happens in the <strong class="source-inline">response_model</strong> attribute <a id="_idIndexMarker070"/>of any of the <strong class="source-inline">@app</strong> path operations. Unfortunately, the parameter only recognizes <strong class="source-inline">BaseModel</strong> class types:</p>
			<pre class="source-code">
@app.post("/ch01/login/validate", <strong class="bold">response_model=ValidUser</strong>)
def approve_user(user: User):
    
    if not valid_users.get(user.username) == None:
        return <strong class="bold">ValidUser(id=None, username = None,</strong> 
                   <strong class="bold">password = None, passphrase = None)</strong>
    else:
        <strong class="bold">valid_user = ValidUser(id=uuid1(), </strong>
         <strong class="bold">username= user.username, password = user.password,</strong>
          <strong class="bold">passphrase = hashpw(user.password.encode(),</strong>
                 <strong class="bold">gensalt()))</strong>
        valid_users[user.username] = valid_user
        del pending_users[user.username]
        return <strong class="bold">valid_user</strong></pre>
			<p>The preceding <strong class="source-inline">approve_user()</strong> service specifies the required return of the API method, which is <strong class="source-inline">ValidUser</strong>.</p>
			<p>Now, let us explore how FastAPI handles form parameters.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Handling form parameters</h1>
			<p>When API methods are designed to handle web forms, the services involved are required to <a id="_idIndexMarker071"/>retrieve form parameters instead of the request body because this form data is normally encoded as an <strong class="source-inline">application/x-www-form-urlencoded</strong> media type. These form parameters are conventionally <strong class="source-inline">string</strong> types, but the <strong class="source-inline">pydantic</strong> module’s JSON encoder can convert each parameter value to its respective valid type.  </p>
			<p>All the form parameter variables can be declared <em class="italic">required</em>, with <em class="italic">default</em> values, or <em class="italic">optional</em> using the same set of Python types we used previously. Then, the <strong class="source-inline">fastapi</strong> module has a <strong class="source-inline">Form</strong> function that needs to be imported to initialize these form parameter variables during their declaration. To set these form parameters as <em class="italic">required</em>, the <strong class="source-inline">Form()</strong> function must have the ellipses (<strong class="source-inline">…</strong>) argument, thus calling it as <strong class="source-inline">Form(…)</strong>: </p>
			<pre class="source-code">
from fastapi import FastAPI, <strong class="bold">Form</strong>
<strong class="bold">@app.post("/ch01/account/profile/add", </strong>
                        <strong class="bold">response_model=UserProfile)</strong>
def add_profile(<strong class="bold">uname: str</strong>, 
                <strong class="bold">fname: str = Form(...)</strong>, 
                <strong class="bold">lname: str = Form(...)</strong>,
                <strong class="bold">mid_init: str = Form(...)</strong>,
                <strong class="bold">user_age: int = Form(...)</strong>,
                <strong class="bold">sal: float = Form(...)</strong>,
                <strong class="bold">bday: str = Form(...)</strong>,
                <strong class="bold">utype: UserType = Form(...)</strong>):
    if valid_users.get(uname) == None:
        return UserProfile(firstname=None, lastname=None, 
              middle_initial=None, age=None, 
              birthday=None, salary=None, user_type=None)
    else:
        profile = UserProfile(firstname=fname, 
             lastname=lname, middle_initial=mid_init, 
             age=user_age, birthday=datetime.strptime(bday,
                '%m/%d/%Y'), salary=sal, user_type=utype)
        valid_profiles[uname] = profile
        return profile</pre>
			<p>The preceding <strong class="source-inline">add_profile()</strong> service shows us how to call the <strong class="source-inline">Form(…)</strong> function to return a <strong class="source-inline">Form</strong> object during the parameter declaration.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Form-handling services will not work if the <strong class="source-inline">python-multipart</strong> module is not installed.</p>
			<p>Sometimes, we need <a id="_idIndexMarker072"/>browser cookies to establish an identity for our application, leave trails in the browser for every user transaction, or store product information for a purpose. If FastAPI can manage form data, it can also do the same with cookies.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Managing cookies</h1>
			<p>A <em class="italic">cookie</em> is a piece of <a id="_idIndexMarker073"/>information stored in the browser to pursue some purpose, such <a id="_idIndexMarker074"/>as login user authorization, web agent response <a id="_idIndexMarker075"/>generation, and session handling-related tasks. One cookie is always a key-value pair that are both string types. </p>
			<p>FastAPI allows services to create cookies individually through the <strong class="source-inline">Response</strong> library class from its <strong class="source-inline">fastapi</strong> module. To use it, it needs to appear as the first local parameter of the service, but we do not let the application or client pass an argument to it. Using the dependency injection principle, the framework will provide the <strong class="source-inline">Response</strong> instance to the service and not the application. When the service has other parameters to declare, the additional declaration should happen right after the declaration of the <strong class="source-inline">Response</strong> parameter.</p>
			<p>The <strong class="source-inline">Response</strong> object has a <strong class="source-inline">set_cookie()</strong> method that contains two required named parameters: the <em class="italic">key</em>, which sets the cookie name, and the <em class="italic">value</em>, which stores the cookie value. This method only generates one cookie and stores it in the browser afterward:</p>
			<pre class="source-code">
<strong class="bold">@app.post("/ch01/login/rememberme/create/")</strong>
def create_cookies(<strong class="bold">resp: Response</strong>, id: UUID, 
                   username: str = ''):
    <strong class="bold">resp.set_cookie(key="userkey", value=username)</strong>
    <strong class="bold">resp.set_cookie(key="identity", value=str(id))</strong>
    return {"message": "remember-me tokens created"}</pre>
			<p>The preceding <strong class="source-inline">create_cookies()</strong> method shows us the creation of <em class="italic">remember-me tokens</em> such as <strong class="source-inline">userkey</strong> and <strong class="source-inline">identity</strong> for the <em class="italic">remember-me</em> authorization of our <em class="italic">online academic discussion forum</em> project. </p>
			<p>To retrieve these cookies, local parameters that have the same name as the cookies are declared in the <a id="_idIndexMarker076"/>service method as <strong class="source-inline">str</strong> types, since cookie values are <a id="_idIndexMarker077"/>always strings. As with <strong class="source-inline">Header</strong> and <strong class="source-inline">Form</strong>, the <strong class="source-inline">fastapi</strong> module also provides a <strong class="source-inline">Cookie</strong> function that is needed to initialize each declared cookie parameter variable. The <strong class="source-inline">Cookie()</strong> function should always have the <strong class="source-inline">None</strong> argument to set the parameters optionally, ensuring that the API method executes without problems whenever the headers are not present in the request transaction. The following <strong class="source-inline">access_cookie()</strong> service retrieves all the <em class="italic">remember-me</em> authorization cookies created by the previous service:</p>
			<pre class="source-code">
<strong class="bold">@app.get("/ch01/login/cookies")</strong>
def access_cookie(<strong class="bold">userkey: Optional[str] = Cookie(None)</strong>, 
           <strong class="bold">identity: Optional[str] = Cookie(None)</strong>):
    cookies["userkey"] = userkey
    cookies["identity"] = identity
    return cookies</pre>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Summary</h1>
			<p>This chapter is essential to familiarize ourselves with FastAPI and understand its basic components. The concept that we can get from this chapter can measure how much adjustment and effort we need to invest into translating or rewriting some existing applications to FastAPI. Knowing its basics will help us learn how to install its modules, structure the project directories, and learn the core library classes and functions needed to build a simple enterprise-grade application. </p>
			<p>With the help of our recipe <em class="italic">online academic discussion forum</em> application, this chapter showed us how to build different REST APIs associated with HTTP methods using the FastAPI module class and Python <strong class="source-inline">def</strong> functions. From there, we learned how to capture incoming request data and headers using the local parameters of the API methods and how these API methods should return a response to the client. And through this chapter, we saw how easy it is for FastAPI to capture form data from <strong class="source-inline">&lt;form&gt;&lt;/form&gt;</strong> of any UI templates and that is using the <strong class="source-inline">Form</strong> function. Aside from the <strong class="source-inline">Form</strong> function, the FastAPI module also has the <strong class="source-inline">Cookie</strong> function to help us create and retrieve cookies from the browser, and <strong class="source-inline">Header</strong> to retrieve the request header part of an incoming request transaction. </p>
			<p>Overall, this chapter has prepared us for advanced discussions that will center on other features of FastAPI that can help us upgrade our simple applications to full-blown ones. The next chapter will cover these essential core features, which will provide our application with the needed response encoder and generator, exception handlers, middleware, and other components related to asynchronous transactions. </p>
		</div>
		<div>
			<div id="_idContainer012">
			</div>
		</div>
	</body></html>