<html><head></head><body>
		<div><h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor014"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Setting Up FastAPI for Starters</h1>
			<p>In any software development work, it is always important to first know the business requirement of the project and the appropriate framework, tools, and deployment platform to use before pursuing the task. Frameworks that are easy to understand and use, seamless during coding, and within standards are always picked because of the integrity they provide to solve problems without risking too much development time. And a promising Python framework called <strong class="bold">FastAPI</strong>, created by <em class="italic">Sebastian Ramirez</em>, provides experienced developers, experts, and enthusiasts the best option for building <strong class="bold">REST APIs</strong> and microservices.</p>
			<p>But before proceeding to the core details of building microservices using FastAPI, it is best to first learn the building blocks of this framework, such as how it captures clients’ requests, how it builds the rules for each HTTP method, and how it manages HTTP responses. Learning the basic components is always essential to know the strengths and weaknesses of the framework and to what extent we can apply FastAPI to solve different enterprise-grade and microservices-related problems.</p>
			<p>Thus, in this chapter, we’re going to have a walkthrough of the basic features of FastAPI by covering the following main topics:</p>
			<ul>
				<li>The setup of the development environment</li>
				<li>Initialization and configuration of FastAPI </li>
				<li>Design and implementation of the REST APIs</li>
				<li>Managing user requests and server response</li>
				<li>Handling form parameters</li>
				<li>Handling cookies</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>The software specimen for this chapter is a prototypical administrator-managed <em class="italic">online academic discussion forum</em>, which is an academic discussion hub where alumni, teachers, and students can exchange ideas. The prototype is working but it is open for changes, so you can tweak the code while reading this chapter. It is not designed to use any database management system, but all the data is temporarily stored in various Python collections. All the applications in this book are compiled and run using <em class="italic">Python 3.8</em>. Codes are all uploaded at <a href="https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch01">https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch01</a>.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Setting up the development environment</h1>
			<p>The FastAPI framework is <a id="_idIndexMarker000"/>a fast, seamless, and robust Python framework but can only <a id="_idIndexMarker001"/>work on Python versions <em class="italic">3.6</em> and <a id="_idIndexMarker002"/>above. The <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>) used in this reference is <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>), which <a id="_idIndexMarker003"/>is an open source tool <a id="_idIndexMarker004"/>that we can download from this site: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>. Just be sure to install the VSC extensions such as <em class="italic">Python</em>, <em class="italic">Python for VS Code</em>, <em class="italic">Python Extension Pack</em>, <em class="italic">Python Indent</em>, and <em class="italic">Material Icon Theme</em> to provide your editor syntax checking, syntax highlighting, and other editor support.</p>
			<p>After the successful installation of Python and VS Code, we can now install FastAPI using a terminal console. To ensure correct installation, first update Python’s package installer (<code>pip</code>) by running this command:</p>
			<pre>python -m pip install --upgrade pip</pre>
			<p>Afterward, we install the framework by running this series of commands:</p>
			<pre>pip install fastapi
pip install uvicorn[standard]
pip install python-multipart</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you need to install the complete FastAPI platform, including all optional dependencies, the appropriate command is <code>pip install fastapi[all]</code>. Likewise, if you want to install and utilize the full-blown <code>uvicorn</code> server, you should run the <code>pip install uvicorn</code> command. Also, install the <code>bcrypt</code> module for encryption-related tasks.</p>
			<p>At this point, you <a id="_idIndexMarker005"/>should have installed all <a id="_idIndexMarker006"/>the needed FastAPI <a id="_idIndexMarker007"/>module dependencies from the <code>uvicorn</code>, however, is an ASGI-based <a id="_idIndexMarker009"/>server that will run your FastAPI applications. The <code>uvicorn</code> server has the capability to run both synchronous and asynchronous services.</p>
			<p>After the installation and configuration of the essential tools, modules, and IDE, let us now start our first API implementation using the framework.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Initializing and configuring FastAPI</h1>
			<p>Learning how <a id="_idIndexMarker010"/>to create applications using FastAPI is easy and straightforward. A simple <a id="_idIndexMarker011"/>application can be created just by creating a <code>main.py</code> file inside your <code>/ch01</code> project folder. In our <em class="italic">online academic discussion forum</em>, for instance, the application started with this code:</p>
			<pre class="source-code">
from fastapi import <strong class="bold">FastAPI</strong>
<strong class="bold">app = FastAPI()</strong></pre>
			<p>This initializes the FastAPI framework. The application needs to instantiate the core <code>FastAPI</code> class from the <code>fastapi</code> module and use <code>app</code> as the reference variable to the object. Then, this object is used later as a Python <code>@app</code> decorator, which provides our application with some features such as <em class="italic">routes</em>, <em class="italic">middleware</em>, <em class="italic">exception handlers</em>, and <em class="italic">path operations</em>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">You can replace <code>app</code> with your preferred but valid Python variable name, such as <code>main_app</code>, <code>forum</code>, or <code>myapp</code>.</p>
			<p>Now, your application is ready to manage REST APIs that are technically Python functions. But to <a id="_idIndexMarker012"/>declare them as REST service methods, we need to decorate them <a id="_idIndexMarker013"/>with the appropriate HTTP request method provided by the path operation <code>@app</code> decorator. This decorator contains the <code>get()</code>, <code>post()</code>, <code>delete()</code>, <code>put()</code>, <code>head()</code>, <code>patch()</code>, <code>trace()</code>, and <code>options()</code> path operations, which correspond to the eight HTTP request methods. And these <em class="italic">path operations</em> are decorated or annotated on top of the Python functions that we want to handle the request and response.</p>
			<p>In our specimen, the first sample that the REST API created was this:</p>
			<pre class="source-code">
<strong class="bold">@app.get("/ch01/index")</strong>
def index():
    return {"message": "Welcome FastAPI Nerds"} </pre>
			<p>The preceding is a <code>GET</code> API service method that returns a <code>JSON</code> object. To locally run our application, we need to execute the following command:</p>
			<pre>uvicorn main:app --reload</pre>
			<p>This command will load the forum application to the uvicorn live server through the application’s <code>main.py</code> file with FastAPI object referencing. Live reload is allowed by adding the <code>--reload</code> option, which enables the restart of the development server whenever there are changes in the code. </p>
			<div><div><img src="img/Figure_1.1_B17975.jpg" alt="Figure 1.1 – The uvicorn console log"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – The uvicorn console log</p>
			<p><em class="italic">Figure 1.1</em> shows that uvicorn uses <code>localhost</code> to run the application with the default port <code>8000</code>. We <a id="_idIndexMarker014"/>can access our index page through <code>http://localhost:8000/ch01/index</code>. To <a id="_idIndexMarker015"/>stop the server, you just need to press the <em class="italic">Ctrl</em> + <em class="italic">C</em> keyboard keys.</p>
			<p>After running our first endpoint, let us now explore how to implement the other types of HTTP methods, namely <code>POST</code>, <code>DELETE</code>, <code>PUT</code>, and <code>PATCH</code>.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Designing and implementing REST APIs</h1>
			<p>The <strong class="bold">Representation State Transfer</strong> (<strong class="bold">REST</strong>) API makes up the rules, processes, and tools that allow <a id="_idIndexMarker016"/>interaction among <a id="_idIndexMarker017"/>microservices. These are method <a id="_idIndexMarker018"/>services that are identified and executed through their endpoint URLs. Nowadays, focusing on API methods before building a whole application is one of the most <a id="_idIndexMarker019"/>popular and effective microservices design strategies. This approach, called an <strong class="bold">API-first</strong> microservices development, focuses first on the client’s needs and then later identifies what API service methods we need to implement for these client requirements.</p>
			<p>In our <em class="italic">online academic discussion forum</em> app, software functionality such as <em class="italic">user sign-up</em>, <em class="italic">login</em>, <em class="italic">profile management</em>, <em class="italic">message posting</em>, and <em class="italic">managing post replies</em> are some of the crucial needs we prioritized. In a FastAPI framework, these features are implemented as services using functions that are defined using Python’s <code>def</code> keyword, with the association of the appropriate HTTP request method through the <em class="italic">path operations</em> provided by <code>@app</code>.</p>
			<p>The <code>login</code> service, which requires <code>username</code> and <code>password</code> request parameters from the user, is implemented as a <code>GET</code> API method:</p>
			<pre class="source-code">
<strong class="bold">@app.get("/ch01/login/")</strong>
def <strong class="bold">login</strong>(username: str, password: str):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    else:
        user = valid_users.get(username)
        if checkpw(password.encode(), 
                   user.passphrase.encode()):
            return user
        else:
            return {"message": "invalid user"}</pre>
			<p>This <em class="italic">login</em> service uses bcrypt’s <code>checkpw()</code> function to check whether the password of the user <a id="_idIndexMarker020"/>is valid. Conversely, the <em class="italic">sign-up</em> service, which <a id="_idIndexMarker021"/>also requires user credentials from the client in the form of request parameters, is created as a <code>POST</code> API method:</p>
			<pre class="source-code">
<strong class="bold">@app.post("/ch01/login/signup")</strong>
def <strong class="bold">signup</strong>(uname: str, passwd: str):
    if (uname == None and passwd == None):
        return {"message": "invalid user"}
    elif not valid_users.get(uname) == None:
        return {"message": "user exists"}
    else:
        user = User(username=uname, password=passwd)
        pending_users[uname] = user
        return user</pre>
			<p>Among the <em class="italic">profile management</em> services, the following <code>update_profile()</code> service serves as a <code>PUT</code> API service, which requires the user to use an entirely new model object for profile information replacement and the client’s username to serve as the key:</p>
			<pre class="source-code">
<strong class="bold">@app.put("/ch01/account/profile/update/{username}")</strong>
def <strong class="bold">update_profile</strong>(username: str, id: UUID, 
                     <strong class="bold">new_profile: UserProfile</strong>):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    else:
        user = valid_users.get(username)
        if user.id == id:
            valid_profiles[username] = new_profile
            return {"message": "successfully updated"}
        else:
            return {"message": "user does not exist"}</pre>
			<p>Not all <a id="_idIndexMarker022"/>services that carry out updates <a id="_idIndexMarker023"/>are <code>PUT</code> API methods, such as the following <code>update_profile_name()</code> service, which only requires the user to submit a new first name, last name, and middle initial for partial replacement of a client’s profile. This HTTP request, which is handier and more lightweight than a full-blown <code>PUT</code> method, only requires a <code>PATCH</code> action:</p>
			<pre class="source-code">
<strong class="bold">@app.patch("/ch01/account/profile/update/names/{username}")</strong>
def <strong class="bold">update_profile_names</strong>(username: str, id: UUID, 
                          <strong class="bold">new_names: Dict[str, str]</strong>):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    elif new_names == None:
        return {"message": "new names are required"}
    else:
        user = valid_users.get(username)
        if user.id == id:
            profile = valid_profiles[username]
            profile.firstname = new_names['fname']
            profile.lastname = new_names['lname']
            profile.middle_initial = new_names['mi']
            valid_profiles[username] = profile
            return {"message": "successfully updated"}
        else:
            return {"message": "user does not exist"}</pre>
			<p>The last <a id="_idIndexMarker024"/>essential HTTP services that <a id="_idIndexMarker025"/>we included before building the application are the <code>DELETE</code> API methods. We use these services to delete records or information given a unique identification, such as <code>username</code> and a hashed <code>id</code>. An example is the following <code>delete_post_discussion()</code> service that allows a user to delete a posted discussion when given a username and the UUID (Universally Unique Identifier) of the posted message:</p>
			<pre class="source-code">
<strong class="bold">@app.delete("/ch01/discussion/posts/remove/{username}")</strong>
def <strong class="bold">delete_discussion</strong>(username: str, id: UUID):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    elif discussion_posts.get(id) == None:
        return {"message": "post does not exist"}
    else:
        del discussion_posts[id] 
        return {"message": "main post deleted"}</pre>
			<p>All path operations require a unique endpoint URL in the <code>str</code> format. A good practice is to start all URLs with the same top-level base path, such as <code>/ch01</code>, and then differ when reaching their respective subdirectories. After running the uvicorn server, we can check and validate whether all our URLs are valid and running by accessing the documentation <a id="_idIndexMarker026"/>URL, <code>http://localhost:8000/docs</code>. This path will show us a <strong class="bold">OpenAPI</strong> dashboard, as shown in <em class="italic">Figure 1.2</em>, listing all the API methods created for the application. Discussions on the OpenAPI will be covered in <a href="B17975_09.xhtml#_idTextAnchor266"><em class="italic">Chapter 9</em></a><em class="italic">, Utilizing Other Advanced Features</em>.</p>
			<div><div><img src="img/Figure_1.2_B17975.jpg" alt="Figure 1.2 – A Swagger OpenAPI dashboard"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – A Swagger OpenAPI dashboard</p>
			<p>After creating <a id="_idIndexMarker027"/>the endpoint services, let us scrutinize how FastAPI manages its incoming request body and the outgoing response.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Managing user requests and server response</h1>
			<p>Clients can pass their request data to FastAPI endpoint URLs through path parameters, query <a id="_idIndexMarker028"/>parameters, or headers to pursue service transactions. There are <a id="_idIndexMarker029"/>standards and ways to use these parameters to obtain incoming requests. Depending on the goal of the services, we use these parameters to influence and build the necessary responses the clients need. But before we discuss these various parameter types, let us explore first how we use <em class="italic">type hinting</em> in FastAPI’s local parameter declaration.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Parameter type declaration</h2>
			<p>All request <a id="_idIndexMarker030"/>parameters are required to be type-declared in the method signature of the service method applying the <code>None</code>, <code>bool</code>, <code>int</code>, and <code>float</code> and container types such as <code>list</code>, <code>tuple</code>, <code>dict</code>, <code>set</code>, <code>frozenset</code>, and <code>deque</code>. Other complex Python types such as <code>datetime.date</code>, <code>datetime.time</code>, <code>datetime.datetime</code>, <code>datetime.delta</code>, <code>UUID</code>, <code>bytes</code>, and <code>Decimal</code> are also supported. </p>
			<p>The framework also supports the data types included in Python’s <code>typing</code> module, responsible for <em class="italic">type hints</em>. These data types are standard notations for Python and variable type <a id="_idIndexMarker032"/>annotations that can help to pursue type checking and model validation during compilation, such as <code>Optional</code>, <code>List</code>, <code>Dict</code>, <code>Set</code>, <code>Union</code>, <code>Tuple</code>, <code>FrozenSet</code>, <code>Iterable</code>, and <code>Deque</code>.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Path parameters</h2>
			<p>FastAPI allows you <a id="_idIndexMarker033"/>to obtain request data from the endpoint URL of an API through <a id="_idIndexMarker034"/>a path parameter or path variable that makes the URL somewhat dynamic. This parameter holds a value that becomes part of a URL indicated by curly braces (<code>{}</code>). After setting off these path parameters within the URL, FastAPI requires these parameters to be declared by applying <em class="italic">type hints</em>. </p>
			<p>The following <code>delete_user()</code> service is a <code>DELETE</code> API method that uses a <code>username</code> path parameter to search for a login record for deletion:</p>
			<pre class="source-code">
@app.delete("/ch01/login/remove/{<strong class="bold">username</strong>}")
def delete_user(<strong class="bold">username: str</strong>):
    if username == None:
    return {"message": "invalid user"}
else:
    del valid_users[username]
    return {"message": "deleted user"}</pre>
			<p>Multiple path parameters are acceptable if the leftmost variables are more likely to be filled with values than the rightmost variables. In other words, the importance of the leftmost path variables will make the process more relevant and correct than those on the right. This standard is applied to ensure that the endpoint URL will not look like other URLs, which might cause some conflicts and confusion. The following <code>login_with_token()</code> service follows this standard, since <code>username</code> is a primary key and is as strong as, or even stronger than, its next parameter, <code>password</code>. There is an assurance that the URL will always look unique every time the endpoint is accessed because <code>username</code> will always be required, as well as <code>password</code>:</p>
			<pre class="source-code">
@app.get("/ch01/login/<strong class="bold">{username}</strong>/<strong class="bold">{password}</strong>")
def login_with_token(<strong class="bold">username: str</strong>, <strong class="bold">password:str</strong>, 
                     id: UUID):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    else:
        user = valid_users[username]
        if user.id == id and checkpw(password.encode(), 
                 user.passphrase):
            return user
        else:
            return {"message": "invalid user"}</pre>
			<p>Unlike other web frameworks, FastAPI is not friendly with endpoint URLs that belong to base paths or <a id="_idIndexMarker035"/>top-level domain paths with different subdirectories. This <a id="_idIndexMarker036"/>occurrence happens when we have dynamic URL patterns that look the same as the other fixed endpoint URLs when assigned a specific path variable. These fixed URLs are implemented sequentially after these dynamic URLs. An example of these are the following services:</p>
			<pre class="source-code">
<strong class="bold">@app.get("/ch01/login/{username}/{password}")</strong>
def login_with_token(<strong class="bold">username: str</strong>, <strong class="bold">password:str</strong>, 
                     <strong class="bold">id: UUID</strong>):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    else:
        user = valid_users[username]
        if user.id == id and checkpw(password.encode(), 
                      user.passphrase.encode()):
            return user
        else:
            return {"message": "invalid user"}
<strong class="bold">@app.get("/ch01/login/details/info")</strong>
def login_info():
        return {"message": "username and password are 
                            needed"}</pre>
			<p>This will give us an <em class="italic">HTTP Status Code 422</em> (<em class="italic">Unprocessable Entity</em>) when accessing <code>http://localhost:8080/ch01/login/details/info</code>. There should be no problem accessing the URL, since the API service is almost a stub or trivial JSON data. What happened <a id="_idIndexMarker037"/>in this scenario is that the fixed path’s <code>details</code> and <code>info</code> path <a id="_idIndexMarker038"/>directories were treated as <code>username</code> and <code>password</code> parameter values, respectively. Because of confusion, the built-in data validation of FastAPI will show us a JSON-formatted error message that says, <code>{"detail":[{"loc":["query","id"],"msg":"field required","type":"value_error.missing"}]}</code>. To fix this problem, all fixed paths should be declared first before the dynamic endpoint URLs with path parameters. Thus, the preceding <code>login_info()</code> service should be declared first before <code>login_with_token()</code>.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Query parameters</h2>
			<p>A query parameter is a <em class="italic">key–value</em> pair supplied after the end of an endpoint URL, indicated by a <a id="_idIndexMarker039"/>question mark (<code>?</code>). Just like the path parameter, this also holds the <a id="_idIndexMarker040"/>request data. An API service can manage a series of query parameters separated by an ampersand (<code>&amp;</code>). Like in path parameters, all query parameters are also declared in the service method. The following <em class="italic">login</em> service is a perfect specimen that uses query parameters:</p>
			<pre class="source-code">
<strong class="bold">@app.get("/ch01/login/")</strong>
def login(<strong class="bold">username: str</strong>, <strong class="bold">password: str</strong>):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    else:
        user = valid_users.get(username)
        if checkpw(password.encode(), 
               user.passphrase.encode()):
            return user
        else:
            return {"message": "invalid user"}</pre>
			<p>The <code>login</code> service method uses <code>username</code> and <code>password</code> as query parameters in the <code>str</code> types. Both are required parameters, and assigning them with <code>None</code> as parameter values will give a compiler error.</p>
			<p>FastAPI supports <a id="_idIndexMarker041"/>query parameters that are complex types, such as <code>list</code> and <code>dict</code>. But <a id="_idIndexMarker042"/>these Python collection types cannot specify the type of objects to store unless we apply the <em class="italic">generic type hints</em> for Python collections. The following <code>delete_users()</code> and <code>update_profile_names()</code> APIs use generic type hints, <code>List</code> and <code>Dict</code>, in declaring query parameters that are container types with type checking and data validation:</p>
			<pre class="source-code">
from typing import Optional, <strong class="bold">List</strong>, <strong class="bold">Dict</strong>
<strong class="bold">@app.delete("/ch01/login/remove/all")</strong>
def delete_users(<strong class="bold">usernames: List[str]</strong>):
    for user in usernames:
        del valid_users[user]
    return {"message": "deleted users"}
<strong class="bold">@app.patch("/ch01/account/profile/update/names/{username}")</strong>
def update_profile_names(username: str, id: UUID, 
                         <strong class="bold">new_names: Dict[str, str]</strong>):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    elif new_names == None:
        return {"message": "new names are required"}
    else:
        user = valid_users.get(username)
        if user.id == id:
            profile = valid_profiles[username]
            profile.firstname = new_names['fname']
            profile.lastname = new_names['lname']
            profile.middle_initial = new_names['mi']
            valid_profiles[username] = profile
            return {"message": "successfully updated"}
        else:
            return {"message": "user does not exist"}</pre>
			<p>FastAPI also <a id="_idIndexMarker043"/>allows you to explicitly assign default values to service <a id="_idIndexMarker044"/>function parameters. </p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Default parameters</h2>
			<p>There are times that we <a id="_idIndexMarker045"/>need to specify default values to the query parameter(s) and <a id="_idIndexMarker046"/>path parameter(s) of some API services to avoid validation error messages such as <code>field required</code> and <code>value_error.missing</code>. Setting default values to parameters will allow the execution of an API method with or without supplying the parameter values. Depending on the requirement, assigned default values are usually <code>0</code> for numeric types, <code>False</code> for bool types, empty string for string types, an empty list (<code>[]</code>) for List types, and an empty dictionary (<code>{}</code>) for <code>Dict</code> types. The following <code>delete pending users()</code> and <code>change_password()</code> services show us how to apply default values to the query parameter(s) and path parameter(s):</p>
			<pre class="source-code">
<strong class="bold">@app.delete("/ch01/delete/users/pending")</strong>
def delete_pending_users(<strong class="bold">accounts: List[str] = []</strong>):
    for user in accounts:
        del pending_users[user]
    return {"message": "deleted pending users"}
<strong class="bold">@app.get("/ch01/login/password/change")</strong>
def change_password(username: str, <strong class="bold">old_passw: str = ''</strong>,
                         <strong class="bold">new_passw: str = ''</strong>):
    passwd_len = 8
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    elif old_passw == '' or new_passw == '':
        characters = ascii_lowercase
        temporary_passwd = 
             ''.join(random.choice(characters) for i in 
                     range(passwd_len))
        user = valid_users.get(username)
        user.password = temporary_passwd
        user.passphrase = 
                  hashpw(temporary_passwd.encode(),gensalt())
        return user
    else:
        user = valid_users.get(username)
        if user.password == old_passw:
            user.password = new_passw
            user.passphrase = hashpw(new_pass.encode(),gensalt())
            return user
        else:
            return {"message": "invalid user"}</pre>
			<p><code>delete_pending_users()</code> can be executed even without passing any accounts argument, since accounts will be <a id="_idIndexMarker047"/>always an empty <code>List</code> by default. Likewise, <code>change_password()</code> can <a id="_idIndexMarker048"/>still continue its process without passing any <code>old_passwd</code> and <code>new_passw</code>, since they are both always defaulted to empty <code>str</code>. <code>hashpw()</code> is a <code>bcrypt</code> utility function that generates a hashed passphrase from an autogenerated <em class="italic">salt</em>.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Optional parameters</h2>
			<p>If the <em class="italic">path</em> and/or <em class="italic">query parameter(s)</em> of a service is/are not necessarily needed to be supplied by the <a id="_idIndexMarker049"/>user, meaning the API transactions can proceed with or without <a id="_idIndexMarker050"/>their inclusion in the request transaction, then we set them as <em class="italic">optional</em>. To declare an optional parameter, we need to import the <code>Optional</code> type from the <code>typing</code> module and then use it to set the parameter. It should wrap the supposed data type of the parameter using brackets (<code>[]</code>) and can have <em class="italic">any default value</em> if needed. Assigning the <code>Optional</code> parameter to a <code>None</code> value indicates that its exclusion from the parameter passing is allowed by the service, but it will hold a <code>None</code> value. The following services depict the use of optional parameters:</p>
			<pre class="source-code">
from typing import <strong class="bold">Optional</strong>, List, Dict
<strong class="bold">@app.post("/ch01/login/username/unlock")</strong>
def unlock_username(id: <strong class="bold">Optional[UUID] = None</strong>):
    <strong class="bold">if id == None:</strong>
        return {"message": "token needed"}
    else:
        for key, val in valid_users.items():
            if val.id == id:
                return {"username": val.username}
        return {"message": "user does not exist"}
<strong class="bold">@app.post("/ch01/login/password/unlock")</strong>
def unlock_password(<strong class="bold">username: Optional[str] = None</strong>, 
                    <strong class="bold">id: Optional[UUID] = None</strong>):
    <strong class="bold">if username == None:</strong>
        return {"message": "username is required"}
    elif valid_users.get(username) == None:
        return {"message": "user does not exist"}
    else:
        <strong class="bold">if id == None:</strong>
            return {"message": "token needed"}
        else:
            user = valid_users.get(username)
            if user.id == id:
                return {"password": user.password}
            else:
                return {"message": "invalid token"}</pre>
			<p>In the <em class="italic">online academic discussion forum</em> application, we have services such as the preceding <code>unlock_username()</code> and <code>unlock_password()</code> services that declare all their parameters as <code>optional</code>. Just do not <a id="_idIndexMarker051"/>forget to apply exception handling or defensive <a id="_idIndexMarker052"/>validation in your implementation when dealing with these kinds of parameters to avoid <em class="italic">HTTP Status 500</em> (<em class="italic">Internal Server Error</em>).</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The FastAPI framework does not allow you to directly assign the <code>None</code> value to a parameter just to declare an <em class="italic">optional</em> parameter. Although this is allowed with the old Python behavior, this is no longer recommended in the current Python versions for the purpose of built-in type checking and model validation.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Mixing all types of parameters</h2>
			<p>If you are planning to <a id="_idIndexMarker053"/>implement an API service method that declares optional, required, and default query and path parameters altogether, you can pursue it because the framework supports it, but approach it with some caution due to some standards and rules:</p>
			<pre class="source-code">
@app.patch("/ch01/account/profile/update/names/<strong class="bold">{username}</strong>")
def update_profile_names(<strong class="bold">id: UUID</strong>, <strong class="bold">username: str = ''</strong> , 
           <strong class="bold">new_names: Optional[Dict[str, str]] = None</strong>):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    elif new_names == None:
        return {"message": "new names are required"}
    else:
        user = valid_users.get(username)
        if user.id == id:
            profile = valid_profiles[username]
            profile.firstname = new_names['fname']
            profile.lastname = new_names['lname']
            profile.middle_initial = new_names['mi']
            valid_profiles[username] = profile
            return {"message": "successfully updated"}
        else:
            return {"message": "user does not exist"}</pre>
			<p>The updated version of the preceding <code>update_profile_names()</code> service declares a <code>username</code> path parameter, a <code>UUID</code> id query parameter, and an optional <code>Dict[str, str]</code> type. With mixed parameter types, all required parameters should be declared <a id="_idIndexMarker054"/>first, followed by default parameters, and last in the parameter list should be the optional types. Disregarding this ordering rule will generate a <em class="italic">compiler error</em>.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Request body</h2>
			<p>A <em class="italic">request body</em> is a body <a id="_idIndexMarker055"/>of data in bytes transmitted from a client to a server <a id="_idIndexMarker056"/>through a <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, or <code>PATCH</code> HTTP method operation. In FastAPI, a service must declare a model object to represent and capture this request body to be processed for further results.</p>
			<p>To implement a model class for the <em class="italic">request body</em>, you should first import the <code>BaseModel</code> class from the <code>pydantic</code> module. Then, create a subclass of it to utilize all the properties and behavior needed by the path operation in capturing the request body. Here are some of the data models used by our application:</p>
			<pre class="source-code">
from pydantic import <strong class="bold">BaseModel</strong>
class User(<strong class="bold">BaseModel</strong>):
    username: str
    password: str
class UserProfile(<strong class="bold">BaseModel</strong>):
    firstname: str
    lastname: str
    middle_initial: str
    age: Optional[int] = 0
    salary: Optional[int] = 0
    birthday: date
    user_type: UserType</pre>
			<p>The attributes of the model classes must be explicitly declared by applying <em class="italic">type hints</em> and utilizing the common and complex data types used in the parameter declaration. These attributes can also be set as required, default, and optional, just like in the parameters.</p>
			<p>Moreover, the <code>pydantic</code> module <a id="_idIndexMarker057"/>allows the creation of nested models, even the deeply <a id="_idIndexMarker058"/>nested ones. A sample of these is shown here:    </p>
			<pre class="source-code">
class ForumPost(<strong class="bold">BaseModel</strong>):
    id: UUID
    topic: Optional[str] = None
    message: str
    <strong class="bold">post_type: PostType</strong>
    date_posted: datetime
    username: str
class ForumDiscussion(<strong class="bold">BaseModel</strong>):
    id: UUID
    <strong class="bold">main_post: ForumPost</strong>
    <strong class="bold">replies: Optional[List[ForumPost]] = None</strong>
    <strong class="bold">author: UserProfile</strong></pre>
			<p>As seen in the preceding code, we have a <code>ForumPost</code> model, which has a <code>PostType</code> model attribute, and <code>ForumDiscussion</code>, which has a <code>List</code> attribute of <code>ForumPost</code>, a <code>ForumPost</code> model attribute, and a <code>UserProfile</code> attribute. This kind of model <a id="_idIndexMarker059"/>blueprint is called a <em class="italic">nested model approach</em>.</p>
			<p>After creating these model classes, you can now <em class="italic">inject</em> these objects into the services that are intended <a id="_idIndexMarker060"/>to capture the <em class="italic">request body</em> from the clients. The following <a id="_idIndexMarker061"/>services utilize our <code>User</code> and <code>UserProfile</code> model classes to manage the request body:</p>
			<pre class="source-code">
<strong class="bold">@app.post("/ch01/login/validate", response_model=ValidUser)</strong>
def approve_user(<strong class="bold">user: User</strong>):
    if not valid_users.get(user.username) == None:
        return <strong class="bold">ValidUser(id=None, username = None,</strong> 
             <strong class="bold">password = None, passphrase = None)</strong>
    else:
        valid_user = <strong class="bold">ValidUser(id=uuid1(),</strong> 
             <strong class="bold">username= user.username, </strong>
             <strong class="bold">password  = user.password, </strong>
             <strong class="bold">passphrase = hashpw(user.password.encode(),</strong>
                          <strong class="bold">gensalt()))</strong>
        valid_users[user.username] = valid_user
        del pending_users[user.username]
        return valid_user
<strong class="bold">@app.put("/ch01/account/profile/update/{username}")</strong>
def update_profile(<strong class="bold">username: str</strong>, <strong class="bold">id: UUID</strong>, 
                   <strong class="bold">new_profile: UserProfile</strong>):
    if valid_users.get(username) == None:
        return {"message": "user does not exist"}
    else:
        user = valid_users.get(username)
        if user.id == id:
            valid_profiles[username] = new_profile
            return {"message": "successfully updated"}
        else:
            return {"message": "user does not exist"}</pre>
			<p>Models can be declared <em class="italic">required</em>, with a <em class="italic">default</em> instance value, or <em class="italic">optional</em> in the service method, depending <a id="_idIndexMarker062"/>on the specification of the API. Missing or incorrect details <a id="_idIndexMarker063"/>such as <code>invalid password</code> or <code>None</code> values in the <code>approve_user()</code> service will emit the <em class="italic">Status Code 500</em> (<em class="italic">Internal Server Error</em>). How FastAPI handles exceptions will be part of <a href="B17975_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a><em class="italic">,</em> <em class="italic">Exploring the Core Features,</em> discussions.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">There are two essential points we need to emphasize when dealing with <code>BaseModel</code> class types. First, the <code>pydantic</code> module has a built-in JSON encoder that converts the JSON-formatted request body to the <code>BaseModel</code> object. So, there is no need create a custom converter to map the request body to the <code>BaseModel</code> model. Second, to instantiate a <code>BaseModel</code> class, all its required attributes must be initialized immediately through the constructor’s named parameters.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Request headers</h2>
			<p>In a request-response transaction, it <a id="_idIndexMarker064"/>is not only the parameters that are <a id="_idIndexMarker065"/>accessible by the REST API methods but also the information that describes the context of the client where the request originated. Some common request headers such as <code>User-Agent</code>, <code>Host</code>, <code>Accept</code>, <code>Accept-Language</code>, <code>Accept-Encoding</code>, <code>Referer</code>, and <code>Connection</code> usually appear with request parameters and values during request transactions. </p>
			<p>To access a request header, import first the <code>Header</code> function from the <code>fastapi</code> module. Then, declare the variable that has the same name as the header in the method service as <code>str</code> types and initialize the variable by calling the <code>Header(None)</code> function.  The <code>None</code> argument enables the <code>Header()</code> function to declare the variable optionally, which is a best practice. For hyphenated request header names, the hyphen (<code>-</code>) should be converted to an underscore (<code>_</code>); otherwise, the Python compiler will flag a syntax error message. It is the task of the <code>Header()</code> function to convert the underscore (<code>_</code>) to a hyphen (<code>-</code>) during request header processing.</p>
			<p>Our online academic discussion forum application has a <code>verify_headers()</code> service <a id="_idIndexMarker066"/>that retrieves core request headers needed to verify a client’s access to the application:</p>
			<pre class="source-code">
from fastapi import <strong class="bold">Header</strong>
<strong class="bold">@app.get("/ch01/headers/verify")</strong>
def verify_headers(<strong class="bold">host: Optional[str] = Header(None)</strong>, 
                   <strong class="bold">accept: Optional[str] = Header(None)</strong>,
                   <strong class="bold">accept_language: </strong>
                       <strong class="bold">Optional[str] = Header(None)</strong>,
                   <strong class="bold">accept_encoding: </strong>
                       <strong class="bold">Optional[str] = Header(None)</strong>,
                   <strong class="bold">user_agent</strong>: 
                       <strong class="bold">Optional[str] = Header(None)</strong>):
    request_headers["Host"] = host
    request_headers["Accept"] = accept
    request_headers["Accept-Language"] = accept_language
    request_headers["Accept-Encoding"] = accept_encoding
    request_headers["User-Agent"] = user_agent
    return request_headers</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout">Non-inclusion of the <code>Header()</code> function call in the declaration will let FastAPI treat the variables as <em class="italic">query parameters</em>. Be cautious also with the spelling of the local parameter names, since they <em class="italic">are</em> the request header names per se except for the underscore.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Response data</h2>
			<p>All API services in FastAPI <a id="_idIndexMarker067"/>should return <code>JSON</code> data, or it will be invalid and may <a id="_idIndexMarker068"/>return <code>None</code> by default. These responses can be formed using <code>dict</code>, <code>BaseModel</code>, or <code>JSONResponse</code> objects. Discussions on <code>JSONResponse</code> will be discussed in the succeeding chapters. </p>
			<p>The <code>pydantic</code> module’s built-in JSON converter will manage the conversion of these custom responses to a JSON object, so there is no need to create a custom JSON encoder:</p>
			<pre class="source-code">
@app.post("/ch01/discussion/posts/add/{username}")
def post_discussion(username: str, post: Post, 
                    post_type: PostType):
    if valid_users.get(username) == None:
        return <strong class="bold">{"message": "user does not exist"}</strong>
    elif not (discussion_posts.get(id) == None):
        return <strong class="bold">{"message": "post already exists"}</strong>
    else:
        forum_post = ForumPost(id=uuid1(), 
          topic=post.topic, message=post.message, 
          post_type=post_type, 
          date_posted=post.date_posted, username=username)
        user = valid_profiles[username]
        <strong class="bold">forum = ForumDiscussion(id=uuid1(), </strong>
         <strong class="bold">main_post=forum_post, author=user, replies=list())</strong>
        discussion_posts[forum.id] = forum
        return <strong class="bold">forum</strong></pre>
			<p>The preceding <code>post_discussion()</code> service returns two different hardcoded <code>dict</code> objects, with <code>message</code> as the key and an instantiated <code>ForumDiscussion</code> model.</p>
			<p>On the other hand, this framework allows us to specify the return type of a service method. The setting <a id="_idIndexMarker069"/>of the return type happens in the <code>response_model</code> attribute <a id="_idIndexMarker070"/>of any of the <code>@app</code> path operations. Unfortunately, the parameter only recognizes <code>BaseModel</code> class types:</p>
			<pre class="source-code">
@app.post("/ch01/login/validate", <strong class="bold">response_model=ValidUser</strong>)
def approve_user(user: User):
    
    if not valid_users.get(user.username) == None:
        return <strong class="bold">ValidUser(id=None, username = None,</strong> 
                   <strong class="bold">password = None, passphrase = None)</strong>
    else:
        <strong class="bold">valid_user = ValidUser(id=uuid1(), </strong>
         <strong class="bold">username= user.username, password = user.password,</strong>
          <strong class="bold">passphrase = hashpw(user.password.encode(),</strong>
                 <strong class="bold">gensalt()))</strong>
        valid_users[user.username] = valid_user
        del pending_users[user.username]
        return <strong class="bold">valid_user</strong></pre>
			<p>The preceding <code>approve_user()</code> service specifies the required return of the API method, which is <code>ValidUser</code>.</p>
			<p>Now, let us explore how FastAPI handles form parameters.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Handling form parameters</h1>
			<p>When API methods are designed to handle web forms, the services involved are required to <a id="_idIndexMarker071"/>retrieve form parameters instead of the request body because this form data is normally encoded as an <code>application/x-www-form-urlencoded</code> media type. These form parameters are conventionally <code>string</code> types, but the <code>pydantic</code> module’s JSON encoder can convert each parameter value to its respective valid type.  </p>
			<p>All the form parameter variables can be declared <em class="italic">required</em>, with <em class="italic">default</em> values, or <em class="italic">optional</em> using the same set of Python types we used previously. Then, the <code>fastapi</code> module has a <code>Form</code> function that needs to be imported to initialize these form parameter variables during their declaration. To set these form parameters as <em class="italic">required</em>, the <code>Form()</code> function must have the ellipses (<code>…</code>) argument, thus calling it as <code>Form(…)</code>: </p>
			<pre class="source-code">
from fastapi import FastAPI, <strong class="bold">Form</strong>
<strong class="bold">@app.post("/ch01/account/profile/add", </strong>
                        <strong class="bold">response_model=UserProfile)</strong>
def add_profile(<strong class="bold">uname: str</strong>, 
                <strong class="bold">fname: str = Form(...)</strong>, 
                <strong class="bold">lname: str = Form(...)</strong>,
                <strong class="bold">mid_init: str = Form(...)</strong>,
                <strong class="bold">user_age: int = Form(...)</strong>,
                <strong class="bold">sal: float = Form(...)</strong>,
                <strong class="bold">bday: str = Form(...)</strong>,
                <strong class="bold">utype: UserType = Form(...)</strong>):
    if valid_users.get(uname) == None:
        return UserProfile(firstname=None, lastname=None, 
              middle_initial=None, age=None, 
              birthday=None, salary=None, user_type=None)
    else:
        profile = UserProfile(firstname=fname, 
             lastname=lname, middle_initial=mid_init, 
             age=user_age, birthday=datetime.strptime(bday,
                '%m/%d/%Y'), salary=sal, user_type=utype)
        valid_profiles[uname] = profile
        return profile</pre>
			<p>The preceding <code>add_profile()</code> service shows us how to call the <code>Form(…)</code> function to return a <code>Form</code> object during the parameter declaration.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Form-handling services will not work if the <code>python-multipart</code> module is not installed.</p>
			<p>Sometimes, we need <a id="_idIndexMarker072"/>browser cookies to establish an identity for our application, leave trails in the browser for every user transaction, or store product information for a purpose. If FastAPI can manage form data, it can also do the same with cookies.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Managing cookies</h1>
			<p>A <em class="italic">cookie</em> is a piece of <a id="_idIndexMarker073"/>information stored in the browser to pursue some purpose, such <a id="_idIndexMarker074"/>as login user authorization, web agent response <a id="_idIndexMarker075"/>generation, and session handling-related tasks. One cookie is always a key-value pair that are both string types. </p>
			<p>FastAPI allows services to create cookies individually through the <code>Response</code> library class from its <code>fastapi</code> module. To use it, it needs to appear as the first local parameter of the service, but we do not let the application or client pass an argument to it. Using the dependency injection principle, the framework will provide the <code>Response</code> instance to the service and not the application. When the service has other parameters to declare, the additional declaration should happen right after the declaration of the <code>Response</code> parameter.</p>
			<p>The <code>Response</code> object has a <code>set_cookie()</code> method that contains two required named parameters: the <em class="italic">key</em>, which sets the cookie name, and the <em class="italic">value</em>, which stores the cookie value. This method only generates one cookie and stores it in the browser afterward:</p>
			<pre class="source-code">
<strong class="bold">@app.post("/ch01/login/rememberme/create/")</strong>
def create_cookies(<strong class="bold">resp: Response</strong>, id: UUID, 
                   username: str = ''):
    <strong class="bold">resp.set_cookie(key="userkey", value=username)</strong>
    <strong class="bold">resp.set_cookie(key="identity", value=str(id))</strong>
    return {"message": "remember-me tokens created"}</pre>
			<p>The preceding <code>create_cookies()</code> method shows us the creation of <em class="italic">remember-me tokens</em> such as <code>userkey</code> and <code>identity</code> for the <em class="italic">remember-me</em> authorization of our <em class="italic">online academic discussion forum</em> project. </p>
			<p>To retrieve these cookies, local parameters that have the same name as the cookies are declared in the <a id="_idIndexMarker076"/>service method as <code>str</code> types, since cookie values are <a id="_idIndexMarker077"/>always strings. As with <code>Header</code> and <code>Form</code>, the <code>fastapi</code> module also provides a <code>Cookie</code> function that is needed to initialize each declared cookie parameter variable. The <code>Cookie()</code> function should always have the <code>None</code> argument to set the parameters optionally, ensuring that the API method executes without problems whenever the headers are not present in the request transaction. The following <code>access_cookie()</code> service retrieves all the <em class="italic">remember-me</em> authorization cookies created by the previous service:</p>
			<pre class="source-code">
<strong class="bold">@app.get("/ch01/login/cookies")</strong>
def access_cookie(<strong class="bold">userkey: Optional[str] = Cookie(None)</strong>, 
           <strong class="bold">identity: Optional[str] = Cookie(None)</strong>):
    cookies["userkey"] = userkey
    cookies["identity"] = identity
    return cookies</pre>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Summary</h1>
			<p>This chapter is essential to familiarize ourselves with FastAPI and understand its basic components. The concept that we can get from this chapter can measure how much adjustment and effort we need to invest into translating or rewriting some existing applications to FastAPI. Knowing its basics will help us learn how to install its modules, structure the project directories, and learn the core library classes and functions needed to build a simple enterprise-grade application. </p>
			<p>With the help of our recipe <em class="italic">online academic discussion forum</em> application, this chapter showed us how to build different REST APIs associated with HTTP methods using the FastAPI module class and Python <code>def</code> functions. From there, we learned how to capture incoming request data and headers using the local parameters of the API methods and how these API methods should return a response to the client. And through this chapter, we saw how easy it is for FastAPI to capture form data from <code>&lt;form&gt;&lt;/form&gt;</code> of any UI templates and that is using the <code>Form</code> function. Aside from the <code>Form</code> function, the FastAPI module also has the <code>Cookie</code> function to help us create and retrieve cookies from the browser, and <code>Header</code> to retrieve the request header part of an incoming request transaction. </p>
			<p>Overall, this chapter has prepared us for advanced discussions that will center on other features of FastAPI that can help us upgrade our simple applications to full-blown ones. The next chapter will cover these essential core features, which will provide our application with the needed response encoder and generator, exception handlers, middleware, and other components related to asynchronous transactions. </p>
		</div>
		<div><div></div>
		</div>
	</body></html>