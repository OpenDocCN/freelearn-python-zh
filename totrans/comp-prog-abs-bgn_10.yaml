- en: '*Chapter 8:* Understanding Functions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of useful concepts that we, as programmers, always should
    follow. One is to write code that is easy to read and understand. Another is to
    avoid duplicating code. When you start out your career as a programmer, you will
    find yourself copying and pasting code and just changing some small things here
    and there. This is a bad habit as it nullifies the first concept of code that
    is easy to read because reading more or less the same lines over and over is tedious
    and it is hard to spot the tiny differences.
  prefs: []
  type: TYPE_NORMAL
- en: A better solution is to package code that we want to reuse several times into
    a function. A function is a way for us to give a name to a block of code and then,
    with this name, the code block can be called over and over every time we want
    it to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Deciding what goes into a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning values from a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing arguments to a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with local and global variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciding what goes into a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function is a way for us to package a code block and give it a name. This
    is a good idea for several reasons. Back in [*Chapter 4*](B15554_04_Final_NM_ePub.xhtml#_idTextAnchor067)*,
    Software Projects and How We Organize Our Code,* we talked about software modules
    and that dividing our code into small parts is wise as it will give us code that
    is easier to read, update, and maintain. The same reason applies to functions
    as they, too, package our code into smaller units. Another reason we want to use
    functions is so we can easily reuse parts of our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When deciding what will go into a function, we can have one rule of thumb.
    A function should always do only one thing and it will be named after what reflects
    that. What this means is that if we have a function called `send_email_and_print_invoice`,
    we are doing things wrong. This function does two distinct tasks and should, therefore,
    be two separate functions. We can rephrase this rule with a quote by Robert C.
    Martin, the author of an excellent book on writing clean code:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A function should do something or answer something, but not both."'
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that a function either should have a very well-specified
    task and only do that task and nothing else or it should answer a well-specified
    question and only answer that question and nothing else, and a single function
    should absolutely not do both of these things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quote from Robert C. Martin about functions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The first rule of functions is that they should be small."'
  prefs: []
  type: TYPE_NORMAL
- en: This is an interesting quote because it raises some questions. What if I have
    a very well-defined problem that I would like to package within a function so
    it follows the first quote, but the problem is rather complex and the resulting
    function ends up being several hundred lines of code? Would that not contradict
    the second quote? Yes, it would and we will need to deal with it. We can take
    this long function and find subtasks and move these subtasks into separate functions.
    How we split a function into several smaller functions might not be that obvious
    at first glance, but this is something we will see in the *Splitting the code
    further* section.
  prefs: []
  type: TYPE_NORMAL
- en: If we create a function with the first quote in mind, it does only one thing,
    and if this is true, would not breaking it up into smaller things contradict the
    second quote, meaning that the function does several things? No, not necessarily.
    Think of something you often do, such as making breakfast. That is one single
    thing, but it can be broken down into several smaller things that together make
    up the tasks of cooking breakfast. You would make coffee or tea, toast some bread,
    boil an egg, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1\. A function that uses other functions to fulfill its task](img/B15554_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – A function that uses other functions to fulfill its task
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure illustrates how a function, here called **function A**,
    has been broken up into several smaller functions, and to accomplish its task,
    it uses subtasks of **function B**, **function C**, and **function D**. Compare
    this to the following figure, where we illustrate making breakfast in the same
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2\. The task of making breakfast broken down into subtasks](img/B15554_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The task of making breakfast broken down into subtasks
  prefs: []
  type: TYPE_NORMAL
- en: Functions are an important building block of computer programs; let's see how
    we can write them. So, after understanding what comprises a function, let's see
    how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see what a function looks like in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see that a function has a name, just like a variable. The conventions
    used by a language for naming functions are usually the same as those used for
    variables. If you don't remember what those were, you can find them in [*Chapter
    6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)*, Working with Data – Variables*,
    in the *Naming conventions* section.
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, we find open and close parentheses. Whenever we refer
    to this function, they will be included after the name. They will also have another
    use, which we will see later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we see a code block, the body of loops and `if` statements, for
    example. This is the code that will be executed when the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function can be called just by using its name, and we must not forget the
    parentheses. Calling the preceding function would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All of the code within this function will now run. Once this is done, the program
    execution will return to where the call occurred and continue from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if the code for the function is above the rest of the function, it will
    not execute until we call the function, so the output when running this program
    will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now call the function as often as we like, and all of the code within
    it will run each time. So, for example, check the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we are making three calls to the function. This is reflected
    in the output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know what a function looks like, we can try to write a more realistic
    one and see how it can make code easier to read and better structured.
  prefs: []
  type: TYPE_NORMAL
- en: Moving code into a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assume that we are writing a program that calculates how many seconds have passed
    since midnight.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code will first get the current date and time. Note that it is the full
    date-time, that is, the year, month, day, hour, minute, and second. All of this
    is stored in the `time_now` variable.
  prefs: []
  type: TYPE_NORMAL
- en: On the second line, we create an object that will hold the date and time for
    the previous midnight. We are using the current year, month, and day. As we have
    the current date and time in the `time_now` variable, we can use it to get the
    current year, month, and day. This will set the hour, minutes, and seconds to
    0 as we did not provide a value for them. The idea is that today's date with `hour
    = 0`, `minute = 0`, and `second = 0` is the previous midnight.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we take the current date and time and subtract the date and time for midnight.
    This will give us the time difference between now and past midnight.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use this difference and convert it into the total number of seconds.
    In this case, the `time_difference` variable is an object that can hold time information,
    that is, how many hours, minutes, and seconds have elapsed since midnight. How
    this works will differ from language to language. Here, this object provides the
    functionality to give us this time in the total number of seconds. Now we have
    a variable called `seconds_since_midnight` that contains the number of seconds
    since the last midnight.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we want to do this now and again in a number of places in our program,
    we will end up with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the four lines that calculate the time get repeated. And we would
    need to do this every time we want to get the number of seconds that has passed
    since midnight.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better solution would be to move the code where we perform the calculation
    into a function. It would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Every time we need the calculation, we can now call the function and we no longer
    need to repeat the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full program will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, this is much better as we only need to code for calculating the
    time once. But we do have a problem. The result from the calculation is *trapped*
    within the function. By trapped, I mean that we calculate the correct number of
    seconds but the value obtained can't get out of the function so there is no way
    for us to use this value outside of it. To solve this problem, we will need to
    return the result back out to the caller. Let's see how that works.
  prefs: []
  type: TYPE_NORMAL
- en: Returning values from a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea behind a function is that it not only can be used to package code so
    we can reuse it over and over but can also do something that will produce some
    sort of value. In our example with the time calculator, the function has calculated
    a result, the number of seconds that have elapsed since midnight, and we now want
    that value at the location where we called the function. Functions have the ability
    to return data, and this is a feature we can use to get the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplest form, returning a value from a function works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a function called `greet`. All it does is return a string containing
    the greeting, `Hello my friend`. Remember that the code within a function is not
    executed until the function is actually called. The call happens below the function.
    Consider what happens when the following row is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Things work as they always do. The thing to the right of the assignment operator
    (`=`) is executed first. This is the call to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the program will jump to the actual function, executing the code within
    it. The only thing inside the function is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We must understand two things about this line. First, a line with the `return`
    keyword will exit the function, even if there is more code following it. This
    might sound strange, and we will soon come back to that. Secondly, it will return
    whatever follows the word `return` back to the location that called the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will take us back to this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We are now done with the operation on the right of `=`, and that has returned
    the `Hello my friend` string. That string is now assigned to the `result` variable.
  prefs: []
  type: TYPE_NORMAL
- en: On the last line, the content of that variable is printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this is a silly program, as the function always returns the same thing,
    but it illustrates how `return` works. We can now use this in our function that
    calculates the number of seconds since midnight, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We did this by just adding one line at the end that returns the content of the
    `seconds_since_midnight` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'As this variable is created on the line just above `return`, we could actually
    remove it and instead return the result immediately like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now call this function over and over and get the current number of seconds
    since midnight, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we take the result returned back from the function and store it in a
    variable called `seconds_since_midnight`. We then print a text together with the
    result. The output might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is great because now we can package a piece of code and we can call it
    whenever we want that code to run. We can also get data back from the function.
    But there is one piece missing. What if we would like to send data to the function?
    We can do that with the help of function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Function arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, we want our functions to be somewhat flexible, so they don''t do exactly
    the same thing every time we call them. Consider the following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These two functions add two numbers and return the result. The first one adds
    `2` and `3`, and the second one does the same but with `5` and `9`. Now, these
    are just two pairs of numbers. If we would like to have a function that could
    add any numbers, we would need to create an endless number of functions.
  prefs: []
  type: TYPE_NORMAL
- en: But if we look at what the functions do, we can see that they are actually doing
    the same thing. They add two numbers and return the result. The only thing that
    changes are the numbers that are used in the addition operation.
  prefs: []
  type: TYPE_NORMAL
- en: What we want is to be able to pass the numbers we want to be added to the function
    so it can use them in the calculation, and by that, only have one function that
    can add any two numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass data to functions. We say that the function can accept arguments.
    For a function that can add two numbers, this can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we now have made use of the parenthesis that has followed
    the function name. This is where we can specify variables that will receive the
    data we want to pass to the function. Now we can use this function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, when running this program, will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we can now serve any two numbers using only one single function.
    Let's examine this a bit closer to really understand how this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s remove two of the calls to the function and only focus on what happens
    when we call the function the first time. We will have this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When we make the call to the function, we are passing in the values, `73` and
    `8`. These are called arguments. On the receiving side, that is, in the `add`
    function, these two values will be assigned to two variables, `number1` and `number2`.
    These are called the parameters of the function. The first argument that we pass
    in, the value, `73`, is assigned to the first parameter, `number1`, and the second
    argument, the value, `8`, will be assigned to the parameter called `number2`.
  prefs: []
  type: TYPE_NORMAL
- en: When we enter the function body, we now have these two variables and they are
    assigned the values that were passed to the function. So, this time, the variables
    will have the values 73 and 8 respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call the function with the values, `2` and `3`, then `number1` will
    get `2` and `number2` will get `3`. This means that the parameters in the function
    will receive data in the same order as the paramters are passed to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `number1` will get the value `4`, and `number2` will get the value `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, things are reversed as `number1` gets `5` and `number2` gets `4`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can create functions that can take arguments and return values. Let's
    put all of this together and use it in a more realistic application, our automatic
    light app.
  prefs: []
  type: TYPE_NORMAL
- en: Now, having a function that adds two numbers together is pointless as we already
    have an operator that performs addition. It is only used here to illustrate the
    concept of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Functions in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we again go back to our application for turning on the lights outside our
    house and focus on the application running on our phone, we will see that we have
    at least two distinct things we need to do over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to get our current position and we need to calculate our distance
    to home so we know whether it is time to turn on the lights or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are two distinct tasks, and they are very well suited to being packaged
    up into two different functions, namely, `get_current_position` and `calculate_distance_to_home`,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: main_application calls two different functions](img/B15554_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – main_application calls two different functions
  prefs: []
  type: TYPE_NORMAL
- en: This diagram shows that we have a block that we call `main_application`. This
    is a function, and it calls a function called `get_current_position` that will
    return the longitude and latitude, indicating the current position of the phone.
    Equipped with this information, `main_application` can now make another function
    call, this time, to a function called `calculate_distance_to_home`, and pass the
    longitude and latitude just obtained to it. This function will do some calculations
    and return either `true` or `false`, indicating whether we are within the range
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: The question is, how did I decide to divide the code into these functions? Would
    we even need to have them, or could this program be written without the use of
    them? The answer is yes, it could, and we will now see why it is a good idea to
    use functions instead of just having all of the code in one place.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 7*](B15554_07_Final_NM_ePub.xhtml#_idTextAnchor103)*, Program
    Control Structures*, we had the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4\. Flowchart of the phone application](img/B15554_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Flowchart of the phone application
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that we have a loop that runs forever (remember that forever
    in programming means as long as the program is running). We also have a selection
    statement that checks whether we are within the range and if we are, the signal
    is sent. After that, no matter whether we sent a signal or not, we will go back
    to the beginning and ask for our current position again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine the code for this application. It might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Every line that starts with some code will most likely be made up of several
    code lines in the real application.
  prefs: []
  type: TYPE_NORMAL
- en: If we read the code, we can see that we start ours with a `while` loop that
    runs as long as `true` is true. `true` will always be true so this is how we can
    create an endless loop that will just go on and run forever.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you compare the program to the flowchart in *figure 8.4*, you can see that
    the logic is identical:'
  prefs: []
  type: TYPE_NORMAL
- en: The oval at the top is the two lines in the code, which is connecting to the
    GPS and communicating with the GPS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rectangle that follows the oval is represented by the code that calculates
    the distance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The diamond shape is the `if` statement and the code within the `if` statement
    is the final rectangle in the flow chart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two arrows that bring us back to the top is the `while` loop that encapsulates
    the rest of the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the code, it might not look that bad, but remember that this is just
    an outline of what needs to be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now start to change this to see what the program actually might look
    like, we can change the two first lines into something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates some sort of `location` object that can be used to communicate
    with the GPS. Note that we store this object in a variable called `location`,
    with all lowercase letters. `Location` with a capital *L*, to the right, is the
    thing that creates this object for us. To see how this is actually done, we will
    need to read the documentation for the programming language we are currently using.
    Most likely, it will be done in a line that resembles this.
  prefs: []
  type: TYPE_NORMAL
- en: We can then use this `location` variable to get the current latitude and longitude.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculating the distance between two geographical coordinates is something
    that most of us can''t even imagine how we should do. Searching online might scare
    us. What we will get back is that we must use something called the *haversine
    formula* (there are other ways to accomplish this too, but for this example, we
    will stick with this formula). Then, we get something like this that will explain
    the formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_08_001.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_08_002.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_08_003.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, *ϕ* is latitude, *λ* is longitude, and *R* is the Earth's radius (the
    mean radius is 6,371 km). Note that all angles need to be in radians.
  prefs: []
  type: TYPE_NORMAL
- en: Don't be scared if you don't understand any of that. Most likely, someone else
    has already looked at that formula and translated it into source code for the
    language you are using. This is good as we can use it without actually understanding
    the formula. We must make sure, though, that the calculations done with it match
    other tools that do the same things. We will soon do such a test, but first, let's
    just see what such an implementation can look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we pretend that we are at the *Musée des Lettres et Manuscrits*
    in Paris and that we rent a home on *Avenue Victor-Hugo* in the same city. Musée
    des Lettres et Manuscrits is located at latitude 48.855421 and longitude 2.327688\.
    Our pretend home on Avenue Victor Hugo is located at latitude 48.870320 and longitude
    2.286560:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Wow, scary stuff, but the good thing is that we don''t need to understand it
    to use it. We must just make sure that it works. As we can see at the top, we
    have the coordinates to the museum (that we pretend that we are visiting), followed
    by the coordinates to our home (that we pretend that we are renting). Running
    this program will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Plugging these same coordinates into an online geo coordinate distance calculator
    will give us the result shown in *figure 8.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: Online geo coordinate distance calculator](img/B15554_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Online geo coordinate distance calculator
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the result matches ours. We should perform more tests by trying
    other coordinates, both in our program and the calculator, to verify that the
    results match.
  prefs: []
  type: TYPE_NORMAL
- en: Great, now we can perform this calculation even if we don't understand all of
    the details for how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a distance that tells us how far we are from our Paris home. Now
    we need to decide how close we need to be to our home before we turn on the light.
    Maybe 500 meters is a good distance as we don''t want to turn it on too early
    and not too late; 500 meters is 0.5 kilometers, so this is the value we can compare
    our distance to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, let''s ignore the code that connects to the home computer and sends
    the notification, and just put everything together that we have so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Reading this code is hard and confusing. What can we do about it? Functions
    are the answer. Let's see how that works.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting the code further
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When breaking a long code into small functions, we must remember that a function
    should do one thing or answer one question.
  prefs: []
  type: TYPE_NORMAL
- en: 'One trick we can use to identify separate tasks within the code is to read
    it from beginning to end, and when we feel that the application shifts its focus
    from one thing to another, we can insert a blank line into the code. Let''s do
    that for the application that we have used so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, there are now blocks of code separated by blank lines. Let's
    study them closely.
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing we can do about the first line with `while`, at least not at
    this point. It will just sit at the top and make sure that we repeat the code
    over and over.
  prefs: []
  type: TYPE_NORMAL
- en: After the line with `while`, three lines follow that all have to do with establishing
    our location. When reading the code, we should ask ourselves, what task does this
    line help us to accomplish? For all of these lines, the answer will be, answer
    the question where we are. But when we hit the line that begins with `home_latitude`,
    this is no longer true. We are now in a block of code that does something else.
    The code has shifted focus, so we insert a blank line.
  prefs: []
  type: TYPE_NORMAL
- en: We now have two lines that answer the question "where do we live?". They obviously
    belong together. But after these two lines, there is a line defining the radius
    of the earth. This is a noticeable shift in the focus so why did I not insert
    a blank line here?
  prefs: []
  type: TYPE_NORMAL
- en: The answer can be found if we look closer at these three lines. All three do
    have something in common. They all have fixed values that will never change. We
    say that these are constant values. We will deal with them later, but let's move
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we come to a larger block that deals with the distance calculation. That
    is a single task.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we have the `if` statement containing the signaling to the home
    computer that we have left unimplemented so far.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we have two strong candidates for becoming functions here and
    that is where we get our current location and the distance calculation. Let's
    try to turn them into functions and we start with the part that tells us where
    we are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, that part of the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can move these three lines into a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, we must check two things. First, does this function need any data as input?
    The answer is no. To accomplish its task, it does not need any more data. This
    means that this function will not take any arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, will this function need to return any data back to the location where
    we called the function? The answer to this is yes, but it is a bit tricky.
  prefs: []
  type: TYPE_NORMAL
- en: The current longitude and latitude are now created inside a function and this
    makes it inaccessible outside it. These are called *local variables*, a topic
    we will discuss in more detail at the end of this chapter. We had the same problem
    with the function that calculated the number of seconds since midnight. We solved
    it then by returning the result using the `return` keyword. We will need to do
    that here too, but most programming languages will only let us return one single
    value from a function, but we need to return two values, both the latitude and
    longitude.
  prefs: []
  type: TYPE_NORMAL
- en: We can get around this limitation by putting the two values inside an array.
    Remember that an array is a sequence of things, and an array is treated as one
    single item, even if it contains many values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change our function so it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that the two values are inside square brackets. This creates an array and
    inserts `latitude` as its first value and `longitude` as its second.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must now call the function and receive the coordinates in `location` in
    the code where we previously fetched the location. The `while` loop now looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: On the first line inside the `while` loop, we are now making a call to the function.
    We will get the array containing the latitude and longitude and we store them
    in a variable we call `position`.
  prefs: []
  type: TYPE_NORMAL
- en: We have a problem now as, later on, when we calculate the distance, we will
    be using the variables, `my_latitude` and `my_longitude`. These two now only exist
    inside the function, so when we reach the lines that convert them into radians,
    we will get an error saying that `my_latitude` is undefined. This is how a programming
    language will tell you that it has no idea what `my_latitude` is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem here is that we have packaged the coordinates inside an array that
    we have named `position`. We could solve this by replacing the two problematic
    lines with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Remember that we can access individual items within an array by using the index
    to the position that the item has within the array. Also, remember that the indexing
    starts at 0.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you need a reminder on how arrays work, we talked about them in [*Chapter
    6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)*, Working with Data – Variables*
    in the *Composite types* section.
  prefs: []
  type: TYPE_NORMAL
- en: As we added the latitude as the first element in the array, it can be found
    at index 0 and the longitude at index 1\. This code is harder to read through
    as we must know how the array was created within the function to know that the
    latitude came before the longitude.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option that would make our code easier to read would be to unpack these
    two values into variables again like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, after we are making the call, we insert the first value into a variable
    called `my_latitude` and the second into a variable called `my_longitude`. As
    we picked the same name that was later used in the calculation, we will not need
    to change it at all if we use this option.
  prefs: []
  type: TYPE_NORMAL
- en: I will go with a third option and will leave the variables in the array for
    now and not change the code in the calculation. We will soon see why.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now turn our attention to the calculation code and turn that into a
    function. This function will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Again, we will now check to see whether this function needs any more data to
    fulfill its task. Yes, as this is written, we are missing several things. This
    function does not know about our latitude and longitude. It does not know the
    home latitude and longitude either and `earth_radius` is also unknown to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s turn the attention back to the three lines where we defined the home
    location and the radius of the earth. Who will need this data? When we think about
    it, the answer is, only the function we just created. This means that we can move
    these three lines into the function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We add them at the top, so they are all defined when they are needed later on
    in the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are only missing the latitude and longitude for our current position.
    This function must accept them as their arguments. We can now either say that
    this function takes two arguments, `latitude` and `longitude`, as separate parameters
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Another option is that we can let this function accept an array with the values.
    This suits our needs as we know that we will get an array back from the other
    function we wrote. So, let's use that option.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We now accept an array, and we call it `current_position`. We must now make
    one change inside the function on the lines where we use `my_latitude` and `my_longitude`.
    We can do the same as we saw before and index into the array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The full function now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Putting it all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we must check whether this function needs to return something. It calculates
    the distance and we need that outside the function, so that value needs to be
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we have two options. We can either return the value contained inside
    the variable distance like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if not the previous option, we can make this shorter, though, as the `distance`
    variable is only used to hold the distance for one line. So, instead of using
    it to hold the value we want to return, we can return the result from the calculation
    directly and get rid of the `distance` variable. It would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'That is better. The function is now finished and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now need to call it. Our `while` loop is now much cleaner and its main
    responsibility is to call our two functions. The loop now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We call the new function by passing the `position` array to it, and we will
    get the distance back and store it in a variable called `distance`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this is more pleasant to look at. If you think about it, you can treat
    this as a table of contents in a book. On the first line, we call a function called
    `get_current_position`. The name of the function is chosen to reflect what it
    does. So, reading this line explains what happens. We can now decide whether we
    are interested in seeing what happens when we get the current position or not.
    If not, we can just accept that we get the current position back. If we do want
    to know how it works, we can go to the function and read the code there.
  prefs: []
  type: TYPE_NORMAL
- en: We can then treat the next line in the same way. The name tells us what the
    function does, so there is no need for us to go and read that. We can trust that
    it does its job and that we get a distance back.
  prefs: []
  type: TYPE_NORMAL
- en: The code is easier to read, maintain, and update, thanks to the use of functions.
    Another benefit is that complex distance calculation is hidden away in a function
    and we don't need to see it if we don't want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now only have the part inside the `if` statement left. To communicate with
    the home computer, we can use something called *sockets*. The concept of sockets
    is rather advanced, and we will not go into any details of it here. We can just
    say that all of that code will go into a function of its own and we can call that
    function from within the `if` statement by using a final `while` loop that looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare this to the code we started with, which looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This is a major clean up of the code and is indeed very helpful, not to mention
    less scary and more pleasing to the eye!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have seen that when we create a variable inside a function,
    it becomes inaccessible for all of the code outside that function. We will now
    discuss this further with local and global variables.
  prefs: []
  type: TYPE_NORMAL
- en: Local and global variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A variable declared (created) inside a function is called a local variable,
    and it can only be accessed from within the function. Outside the function, it
    is as if the variable never existed at all. Check the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create and assign a value to the `name` variable inside the `my_function`
    function. Outside the function, we first call the function, and then we try to
    print the name. The program will crash with an error on the line where we try
    to print the name. The reason is that the `name` variable is unknown in this part
    of the program. It is only valid as long as we execute code inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: This is a local variable. It is local as it is created inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we instead change the program so it looks like this, things will be different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'It might be hard to see what happens here. To understand this, we must read
    the code as the compiler/interpreter will read the code when it executes it:'
  prefs: []
  type: TYPE_NORMAL
- en: It will start at the first line and see that we create a variable called `name`
    and assign the `Bill` string to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will then continue and see the function. It will not run the function; just
    remember that it exists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we call the function, so the execution of the program will now jump up
    and run the code inside the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here we find a line where we assign the `Lisa` string to a variable called `name`.
    As it already knows about this variable, it will change its content and will store
    `Lisa` in it and the `Bill` string is now gone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The end of the function is now reached, so the execution jumps back down to
    where it came from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the last line, the content of the variable name will be printed, which is
    `Lisa`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the working of the preceding code, we saw that as we moved the declaration
    of the variable out of the function, it turned global (for use in code) and so
    it is now a global variable. A global variable can be accessed from any location.
  prefs: []
  type: TYPE_NORMAL
- en: Some programming languages will not let us modify a global variable, as we did
    in the preceding example, but instead of the assignment of `Lisa` within the function,
    it will create a new variable with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: It might sound as if global variables are the way to go. But it is actually
    the opposite. We shall always strive to use local variables as often as we can.
    The reason is that it is hard to control global variables.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you have a program that is thousands of lines long, and all variables
    are global. They get changed here and there and all over, and then you discover
    that one of the variables has a value that would be impossible for it to have.
    Somewhere, a code line has changed this variable in a bad way. This is an error
    in our program, and we need to find it and fix it. But where is that line? As
    all parts of the program can change that variable (and all of the others that
    are declared global), it can be extremely hard to find that location. It might
    also be so that the reason this variable has a bad value is that some other variable
    had a bad value and that we discovered the error was just a side effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code like this is called *spaghetti code*. The reason it is called this will
    be obvious if you look at figure 8.6, which illustrates how five functions change
    four global variables. Look at it and try to figure out how changed what and when:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6\. Five functions changing four global variables](img/B15554_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Five functions changing four global variables
  prefs: []
  type: TYPE_NORMAL
- en: By using local variables, we will make things much cleaner and easier to understand.
    We can do this by passing data into a function using arguments and returning results
    from the function to the location that called it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also note that function parameters are considered local variables.
    What this means is that if we look at the `calculate_distance_from_home` function
    that we created earlier, we can see that we have a parameter called `current_position`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: It will be treated as a local variable within this function.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen that functions are a powerful tool we can use
    to organize and structure our code to make it more readable and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how functions have a name, and that name can be used to call them. Calling
    a function makes the code inside it to execute. This is something we can do over
    and over again as often as we need to.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we want functions to produce a value as a result of its operations.
    In those cases, we can let the function return something. We can then use that
    value in the location where we called the function.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we learned that we can also pass data into a function. This can be done
    using function arguments. The function receives these arguments in local variables
    called parameters.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of functions, we also have the concepts of variables being
    either global or local. We saw that global variables can be accessed from any
    location within the program and local variables can only be used within the function
    where they are created.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, things will not go according to plan, and we will discover that our
    program either produces the wrong results or simply crashes. In the next chapter,
    we will see how we can identify bugs in our programs and handle errors that can
    be harder to predict.
  prefs: []
  type: TYPE_NORMAL
