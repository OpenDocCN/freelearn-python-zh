- en: '*Chapter 8:* Understanding Functions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章：理解函数*'
- en: There are a number of useful concepts that we, as programmers, always should
    follow. One is to write code that is easy to read and understand. Another is to
    avoid duplicating code. When you start out your career as a programmer, you will
    find yourself copying and pasting code and just changing some small things here
    and there. This is a bad habit as it nullifies the first concept of code that
    is easy to read because reading more or less the same lines over and over is tedious
    and it is hard to spot the tiny differences.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们始终应该遵循一些有用的概念。一个是编写易于阅读和理解的代码。另一个是避免代码重复。当你作为程序员开始职业生涯时，你会发现自己正在复制粘贴代码，只是在这里或那里做一些小的改动。这是一个坏习惯，因为它抵消了代码易于阅读的第一个概念，因为反复阅读几乎相同的行是乏味的，而且很难发现微小的差异。
- en: A better solution is to package code that we want to reuse several times into
    a function. A function is a way for us to give a name to a block of code and then,
    with this name, the code block can be called over and over every time we want
    it to execute.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是将我们希望多次重用的代码打包成一个函数。函数是我们给代码块命名的一种方式，然后，通过这个名称，代码块可以在我们想要它执行时被反复调用。
- en: 'In this chapter, you will learn the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Deciding what goes into a function
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定什么放入函数
- en: Writing a function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写函数
- en: Returning values from a function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从函数返回值
- en: Passing arguments to a function
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向函数传递参数
- en: Working with local and global variables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与局部和全局变量一起工作
- en: Deciding what goes into a function
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定什么放入函数
- en: A function is a way for us to package a code block and give it a name. This
    is a good idea for several reasons. Back in [*Chapter 4*](B15554_04_Final_NM_ePub.xhtml#_idTextAnchor067)*,
    Software Projects and How We Organize Our Code,* we talked about software modules
    and that dividing our code into small parts is wise as it will give us code that
    is easier to read, update, and maintain. The same reason applies to functions
    as they, too, package our code into smaller units. Another reason we want to use
    functions is so we can easily reuse parts of our code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是我们将代码块打包并给它命名的一种方式。这有几个原因。在[*第4章*](B15554_04_Final_NM_ePub.xhtml#_idTextAnchor067)*，软件项目和我们的代码组织方式*中，我们讨论了软件模块，将我们的代码分成小块是明智的，因为它会给我们带来易于阅读、更新和维护的代码。同样的原因也适用于函数，因为它们也将我们的代码打包成更小的单元。我们想要使用函数的另一个原因是我们可以轻松地重用代码的某些部分。
- en: 'When deciding what will go into a function, we can have one rule of thumb.
    A function should always do only one thing and it will be named after what reflects
    that. What this means is that if we have a function called `send_email_and_print_invoice`,
    we are doing things wrong. This function does two distinct tasks and should, therefore,
    be two separate functions. We can rephrase this rule with a quote by Robert C.
    Martin, the author of an excellent book on writing clean code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定将什么放入函数时，我们可以遵循一条经验法则。函数应该始终只做一件事，并且它的命名应该反映这一点。这意味着如果我们有一个名为 `send_email_and_print_invoice`
    的函数，我们就是在做错事。这个函数执行了两个不同的任务，因此应该有两个独立的函数。我们可以用罗伯特·C·马丁（Robert C. Martin）的话来重新表述这个规则，他是关于编写干净代码的优秀书籍的作者：
- en: '"A function should do something or answer something, but not both."'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “函数应该做某事或回答某个问题，但不能两者兼而有之。”
- en: What this means is that a function either should have a very well-specified
    task and only do that task and nothing else or it should answer a well-specified
    question and only answer that question and nothing else, and a single function
    should absolutely not do both of these things.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着函数要么应该有一个非常明确的任务并且只做那个任务，不做其他任何事情，要么应该回答一个明确的问题并且只回答那个问题，不做其他任何事情，而且一个函数绝对不应该同时做这两件事。
- en: 'Another quote from Robert C. Martin about functions is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 罗伯特·C·马丁关于函数的另一个引言如下：
- en: '"The first rule of functions is that they should be small."'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: “函数的第一规则是它们应该是小的。”
- en: This is an interesting quote because it raises some questions. What if I have
    a very well-defined problem that I would like to package within a function so
    it follows the first quote, but the problem is rather complex and the resulting
    function ends up being several hundred lines of code? Would that not contradict
    the second quote? Yes, it would and we will need to deal with it. We can take
    this long function and find subtasks and move these subtasks into separate functions.
    How we split a function into several smaller functions might not be that obvious
    at first glance, but this is something we will see in the *Splitting the code
    further* section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一句有趣的话，因为它提出了一些问题。如果我有一个非常明确的问题，我想要将其包装在一个函数中，以便它遵循第一个引号，但问题相当复杂，结果函数最终变成了几百行代码？这不会与第二个引号相矛盾吗？是的，它会，我们需要处理它。我们可以将这个长函数分解成子任务，并将这些子任务移动到单独的函数中。我们如何将函数分解成几个更小的函数可能一开始看起来并不明显，但这是我们在*进一步拆分代码*部分将要看到的内容。
- en: If we create a function with the first quote in mind, it does only one thing,
    and if this is true, would not breaking it up into smaller things contradict the
    second quote, meaning that the function does several things? No, not necessarily.
    Think of something you often do, such as making breakfast. That is one single
    thing, but it can be broken down into several smaller things that together make
    up the tasks of cooking breakfast. You would make coffee or tea, toast some bread,
    boil an egg, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们带着第一个引号来创建一个函数，它只做一件事，如果这是真的，那么将其分解成更小的事情是否会与第二个引号相矛盾，意味着函数做了几件事？不，不一定。想想你经常做的事情，比如制作早餐。这是一件单独的事情，但它可以分解成几个更小的部分，这些部分共同构成了烹饪早餐的任务。你会做咖啡或茶，烤一些面包，煮一个鸡蛋，等等。
- en: 'Observe the following figure:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下图：
- en: '![Figure 8.1\. A function that uses other functions to fulfill its task](img/B15554_08_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1. 使用其他函数来完成其任务的函数](img/B15554_08_01.jpg)'
- en: Figure 8.1 – A function that uses other functions to fulfill its task
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 使用其他函数来完成其任务的函数
- en: 'The preceding figure illustrates how a function, here called **function A**,
    has been broken up into several smaller functions, and to accomplish its task,
    it uses subtasks of **function B**, **function C**, and **function D**. Compare
    this to the following figure, where we illustrate making breakfast in the same
    way:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示说明了如何将一个函数（这里称为**函数A**）分解成几个更小的函数，为了完成其任务，它使用了**函数B**、**函数C**和**函数D**的子任务。将此与以下图示进行比较，其中我们以相同的方式展示制作早餐：
- en: '![Figure 8.2\. The task of making breakfast broken down into subtasks](img/B15554_08_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2. 将制作早餐的任务分解为子任务](img/B15554_08_02.jpg)'
- en: Figure 8.2 – The task of making breakfast broken down into subtasks
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 将制作早餐的任务分解为子任务
- en: Functions are an important building block of computer programs; let's see how
    we can write them. So, after understanding what comprises a function, let's see
    how to use it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是计算机程序的重要构建块；让我们看看我们如何编写它们。因此，在了解一个函数由什么组成之后，让我们看看如何使用它。
- en: Writing a function
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个函数
- en: 'Let''s see what a function looks like in code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看函数在代码中的样子：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we see that a function has a name, just like a variable. The conventions
    used by a language for naming functions are usually the same as those used for
    variables. If you don't remember what those were, you can find them in [*Chapter
    6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)*, Working with Data – Variables*,
    in the *Naming conventions* section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一个函数有一个名字，就像一个变量一样。一种语言用于命名函数的约定通常与用于变量的约定相同。如果你不记得那些是什么，你可以在[*第6章*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)*，*与数据一起工作
    – 变量*，*命名约定*部分找到它们。
- en: After the function name, we find open and close parentheses. Whenever we refer
    to this function, they will be included after the name. They will also have another
    use, which we will see later in this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名之后，我们找到开括号和闭括号。每次我们提到这个函数时，它们都会跟在名字后面。它们还会有另一个用途，我们将在本章后面看到。
- en: After that, we see a code block, the body of loops and `if` statements, for
    example. This is the code that will be executed when the function is called.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们看到一个代码块，循环和`if`语句的主体等。这是当函数被调用时将执行的代码。
- en: 'A function can be called just by using its name, and we must not forget the
    parentheses. Calling the preceding function would look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以通过其名称来调用，我们绝不能忘记括号。调用前面的函数看起来像这样：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All of the code within this function will now run. Once this is done, the program
    execution will return to where the call occurred and continue from there.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数内的所有代码现在都会运行。一旦完成，程序执行将返回到调用发生的地方，并继续执行。
- en: 'The following program illustrates this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序说明了这一点：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Even if the code for the function is above the rest of the function, it will
    not execute until we call the function, so the output when running this program
    will be this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 即使函数的代码在函数的其他部分之上，它也不会执行，直到我们调用函数，所以运行这个程序时的输出将是这样的：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now call the function as often as we like, and all of the code within
    it will run each time. So, for example, check the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以像我们喜欢的那样频繁地调用函数，并且每次调用时它内部的代码都会运行。例如，检查以下代码：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can see that we are making three calls to the function. This is reflected
    in the output, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们调用了三次函数。这在输出中得到了反映，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we know what a function looks like, we can try to write a more realistic
    one and see how it can make code easier to read and better structured.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了函数的样子，我们可以尝试编写一个更现实的函数，看看它如何使代码更容易阅读和结构化。
- en: Moving code into a function
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将代码移动到函数中
- en: Assume that we are writing a program that calculates how many seconds have passed
    since midnight.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在编写一个程序，计算自午夜以来过去了多少秒。
- en: 'The code for this might look like the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码可能看起来像以下这样：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code will first get the current date and time. Note that it is the full
    date-time, that is, the year, month, day, hour, minute, and second. All of this
    is stored in the `time_now` variable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先获取当前的日期和时间。请注意，这是一个完整的日期时间，即年、月、日、小时、分钟和秒。所有这些都被存储在`time_now`变量中。
- en: On the second line, we create an object that will hold the date and time for
    the previous midnight. We are using the current year, month, and day. As we have
    the current date and time in the `time_now` variable, we can use it to get the
    current year, month, and day. This will set the hour, minutes, and seconds to
    0 as we did not provide a value for them. The idea is that today's date with `hour
    = 0`, `minute = 0`, and `second = 0` is the previous midnight.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们创建了一个对象，它将保存上一个午夜的时间和日期。我们使用当前年、月和日。因为我们有当前日期和时间存储在`time_now`变量中，我们可以使用它来获取当前年、月和日。这将把小时、分钟和秒设置为0，因为我们没有为它们提供值。这个想法是，今天的日期，`hour
    = 0`、`minute = 0`和`second = 0`就是上一个午夜。
- en: Then, we take the current date and time and subtract the date and time for midnight.
    This will give us the time difference between now and past midnight.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们取当前的日期和时间，减去午夜的时间和日期。这将给出现在和过去午夜之间的时间差。
- en: Finally, we use this difference and convert it into the total number of seconds.
    In this case, the `time_difference` variable is an object that can hold time information,
    that is, how many hours, minutes, and seconds have elapsed since midnight. How
    this works will differ from language to language. Here, this object provides the
    functionality to give us this time in the total number of seconds. Now we have
    a variable called `seconds_since_midnight` that contains the number of seconds
    since the last midnight.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用这个差值并将其转换为总秒数。在这种情况下，`time_difference`变量是一个可以保存时间信息的对象，即自午夜以来过去了多少小时、分钟和秒。这如何工作会因语言而异。在这里，这个对象提供了给我们这个时间以总秒数的功能。现在我们有一个名为`seconds_since_midnight`的变量，它包含了自上次午夜以来经过的秒数。
- en: 'But if we want to do this now and again in a number of places in our program,
    we will end up with something like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想在程序中的多个地方反复这样做，我们最终会得到类似这样的结果：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see, the four lines that calculate the time get repeated. And we would
    need to do this every time we want to get the number of seconds that has passed
    since midnight.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，计算时间的四行代码被重复了。而且我们每次想要得到自午夜以来经过的秒数时都需要这样做。
- en: 'A better solution would be to move the code where we perform the calculation
    into a function. It would look something like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是将执行计算的代码移动到函数中。它可能看起来像这样：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Every time we need the calculation, we can now call the function and we no longer
    need to repeat the code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们需要进行计算时，现在都可以调用函数，我们不再需要重复编写代码。
- en: 'The full program will now look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的程序现在看起来是这样的：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see, this is much better as we only need to code for calculating the
    time once. But we do have a problem. The result from the calculation is *trapped*
    within the function. By trapped, I mean that we calculate the correct number of
    seconds but the value obtained can't get out of the function so there is no way
    for us to use this value outside of it. To solve this problem, we will need to
    return the result back out to the caller. Let's see how that works.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这要好得多，因为我们只需要编写一次计算时间的代码。但我们确实有一个问题。计算的结果被*困住*在函数内部。通过困住，我的意思是，我们计算了正确的秒数，但获得的价值无法从函数中出来，所以我们无法在函数外部使用这个值。为了解决这个问题，我们需要将结果返回给调用者。让我们看看这是如何工作的。
- en: Returning values from a function
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从函数返回值
- en: The idea behind a function is that it not only can be used to package code so
    we can reuse it over and over but can also do something that will produce some
    sort of value. In our example with the time calculator, the function has calculated
    a result, the number of seconds that have elapsed since midnight, and we now want
    that value at the location where we called the function. Functions have the ability
    to return data, and this is a feature we can use to get the value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 函数背后的思想是，它不仅可以用作封装代码以便我们可以重复使用，还可以执行某种会产生某种值的事情。在我们的时间计算器示例中，函数已经计算了一个结果，即从午夜开始经过的秒数，我们现在想在调用函数的位置得到这个值。函数具有返回数据的能力，这是我们用来获取值的功能。
- en: 'In its simplest form, returning a value from a function works like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，从函数返回值的工作方式如下：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we have a function called `greet`. All it does is return a string containing
    the greeting, `Hello my friend`. Remember that the code within a function is not
    executed until the function is actually called. The call happens below the function.
    Consider what happens when the following row is called:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为`greet`的函数。它所做的只是返回一个包含问候语`Hello my friend`的字符串。记住，函数内的代码只有在函数实际被调用时才会执行。调用发生在函数下方。考虑以下行被调用时会发生什么：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Things work as they always do. The thing to the right of the assignment operator
    (`=`) is executed first. This is the call to the function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 事情就像往常一样进行。赋值运算符（`=`）右侧的内容首先被执行。这是对函数的调用。
- en: 'Now the program will jump to the actual function, executing the code within
    it. The only thing inside the function is this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，程序将跳转到实际的函数，执行其中的代码。函数内部只有这一行：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We must understand two things about this line. First, a line with the `return`
    keyword will exit the function, even if there is more code following it. This
    might sound strange, and we will soon come back to that. Secondly, it will return
    whatever follows the word `return` back to the location that called the function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须理解关于这一行两件事。首先，带有`return`关键字的行将退出函数，即使它后面还有更多的代码。这听起来可能有些奇怪，我们很快就会回到这一点。其次，它将返回`return`一词之后的内容返回给调用函数的位置。
- en: 'This will take us back to this line:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们回到这一行：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We are now done with the operation on the right of `=`, and that has returned
    the `Hello my friend` string. That string is now assigned to the `result` variable.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了对`=`右侧的操作，这返回了`Hello my friend`字符串。这个字符串现在被分配给了`result`变量。
- en: On the last line, the content of that variable is printed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，打印了该变量的内容。
- en: 'Now, this is a silly program, as the function always returns the same thing,
    but it illustrates how `return` works. We can now use this in our function that
    calculates the number of seconds since midnight, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是一个愚蠢的程序，因为函数总是返回相同的东西，但它说明了`return`是如何工作的。我们现在可以在我们的计算午夜以来秒数的函数中使用它，如下所示：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We did this by just adding one line at the end that returns the content of the
    `seconds_since_midnight` variable.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在末尾添加一行返回`seconds_since_midnight`变量的内容来实现这一点。
- en: 'As this variable is created on the line just above `return`, we could actually
    remove it and instead return the result immediately like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个变量是在`return`上方的一行创建的，我们实际上可以删除它，而是立即返回结果，如下所示：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now call this function over and over and get the current number of seconds
    since midnight, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以反复调用这个函数，并得到午夜以来的当前秒数，如下所示：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we take the result returned back from the function and store it in a
    variable called `seconds_since_midnight`. We then print a text together with the
    result. The output might look something like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将从函数返回的内容存储在一个名为`seconds_since_midnight`的变量中。然后我们打印一个与结果一起的文本。输出可能看起来像这样：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is great because now we can package a piece of code and we can call it
    whenever we want that code to run. We can also get data back from the function.
    But there is one piece missing. What if we would like to send data to the function?
    We can do that with the help of function arguments.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，因为现在我们可以封装一段代码，并且我们可以随时调用它来运行这段代码。我们还可以从函数中获取数据。但还有一件事情缺失。如果我们想向函数发送数据怎么办？我们可以通过函数参数来实现这一点。
- en: Function arguments
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数参数
- en: 'Often, we want our functions to be somewhat flexible, so they don''t do exactly
    the same thing every time we call them. Consider the following two functions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望我们的函数具有一定的灵活性，这样它们每次调用时都不做完全相同的事情。考虑以下两个函数：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These two functions add two numbers and return the result. The first one adds
    `2` and `3`, and the second one does the same but with `5` and `9`. Now, these
    are just two pairs of numbers. If we would like to have a function that could
    add any numbers, we would need to create an endless number of functions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数相加两个数字并返回结果。第一个相加`2`和`3`，第二个做同样的事情，但使用`5`和`9`。现在，这些只是两对数字。如果我们想有一个可以相加任何数字的函数，我们需要创建无数个函数。
- en: But if we look at what the functions do, we can see that they are actually doing
    the same thing. They add two numbers and return the result. The only thing that
    changes are the numbers that are used in the addition operation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们看看函数做了什么，我们可以看到它们实际上是在做同样的事情。它们相加两个数字并返回结果。唯一改变的是用于加法操作的数字。
- en: What we want is to be able to pass the numbers we want to be added to the function
    so it can use them in the calculation, and by that, only have one function that
    can add any two numbers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够传递我们想要相加的数字给函数，以便它可以在计算中使用它们，并且通过这种方式，只有一个可以相加任何两个数字的函数。
- en: 'We can pass data to functions. We say that the function can accept arguments.
    For a function that can add two numbers, this can look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向函数传递数据。我们说函数可以接受参数。对于一个可以相加两个数字的函数，它可以看起来像这样：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we can see that we now have made use of the parenthesis that has followed
    the function name. This is where we can specify variables that will receive the
    data we want to pass to the function. Now we can use this function like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们现在已经使用了跟随函数名称的括号。这就是我们可以指定接收我们想要传递给函数的数据的变量。现在我们可以这样使用这个函数：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output, when running this program, will be this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此程序时，输出将是这样的：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we can see, we can now serve any two numbers using only one single function.
    Let's examine this a bit closer to really understand how this works.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们现在可以使用一个单独的函数来处理任何两个数字。让我们更仔细地检查一下，以真正理解它是如何工作的。
- en: 'Let''s remove two of the calls to the function and only focus on what happens
    when we call the function the first time. We will have this code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们移除对函数的两次调用，只关注我们第一次调用函数时会发生什么。我们将得到以下代码：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we make the call to the function, we are passing in the values, `73` and
    `8`. These are called arguments. On the receiving side, that is, in the `add`
    function, these two values will be assigned to two variables, `number1` and `number2`.
    These are called the parameters of the function. The first argument that we pass
    in, the value, `73`, is assigned to the first parameter, `number1`, and the second
    argument, the value, `8`, will be assigned to the parameter called `number2`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用函数时，我们正在传递值`73`和`8`。这些被称为参数。在接收方，即在`add`函数中，这两个值将被分配给两个变量，`number1`和`number2`。这些被称为函数的参数。我们传递的第一个参数，值`73`，被分配给第一个参数`number1`，而第二个参数，值`8`，将被分配给名为`number2`的参数。
- en: When we enter the function body, we now have these two variables and they are
    assigned the values that were passed to the function. So, this time, the variables
    will have the values 73 and 8 respectively.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入函数体时，我们现在有两个变量，并且它们被分配了传递给函数的值。所以这次，变量将分别具有73和8的值。
- en: 'When we call the function with the values, `2` and `3`, then `number1` will
    get `2` and `number2` will get `3`. This means that the parameters in the function
    will receive data in the same order as the paramters are passed to the function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用值`2`和`3`调用函数时，`number1`将得到`2`，而`number2`将得到`3`。这意味着函数中的参数将以与传递给函数的参数相同的顺序接收数据：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, `number1` will get the value `4`, and `number2` will get the value `5`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`number1`将得到值`4`，而`number2`将得到值`5`：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, things are reversed as `number1` gets `5` and `number2` gets `4`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，情况相反，`number1`得到`5`，而`number2`得到`4`。
- en: Now we can create functions that can take arguments and return values. Let's
    put all of this together and use it in a more realistic application, our automatic
    light app.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建可以接受参数并返回值的函数。让我们把这些放在一起，并在一个更现实的应用中使用它，我们的自动灯光应用。
- en: Now, having a function that adds two numbers together is pointless as we already
    have an operator that performs addition. It is only used here to illustrate the
    concept of arguments.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一个将两个数字相加的函数是没有意义的，因为我们已经有了执行加法的运算符。这里只用来说明参数的概念。
- en: Functions in action
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数在行动
- en: If we again go back to our application for turning on the lights outside our
    house and focus on the application running on our phone, we will see that we have
    at least two distinct things we need to do over and over again.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次回到我们打开户外灯光的应用程序，并关注运行在手机上的应用程序，我们会看到我们至少需要反复做两件不同的事情。
- en: We will need to get our current position and we need to calculate our distance
    to home so we know whether it is time to turn on the lights or not.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要获取我们的当前位置，并计算我们到家的距离，这样我们才知道是否是时候打开灯光了。
- en: 'These are two distinct tasks, and they are very well suited to being packaged
    up into two different functions, namely, `get_current_position` and `calculate_distance_to_home`,
    as shown in the following figure:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是两个不同的任务，非常适合打包成两个不同的函数，即`get_current_position`和`calculate_distance_to_home`，如图所示：
- en: '![Figure 8.3: main_application calls two different functions](img/B15554_08_03.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：main_application调用两个不同的函数](img/B15554_08_03.jpg)'
- en: Figure 8.3 – main_application calls two different functions
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – main_application调用两个不同的函数
- en: This diagram shows that we have a block that we call `main_application`. This
    is a function, and it calls a function called `get_current_position` that will
    return the longitude and latitude, indicating the current position of the phone.
    Equipped with this information, `main_application` can now make another function
    call, this time, to a function called `calculate_distance_to_home`, and pass the
    longitude and latitude just obtained to it. This function will do some calculations
    and return either `true` or `false`, indicating whether we are within the range
    or not.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图示显示我们有一个我们称之为`main_application`的块。这是一个函数，它调用一个名为`get_current_position`的函数，该函数将返回经纬度，指示手机的当前位置。有了这些信息，`main_application`现在可以调用另一个函数，这次是调用名为`calculate_distance_to_home`的函数，并将刚刚获得的经纬度传递给它。这个函数将进行一些计算，并返回`true`或`false`，指示我们是否在范围内。
- en: The question is, how did I decide to divide the code into these functions? Would
    we even need to have them, or could this program be written without the use of
    them? The answer is yes, it could, and we will now see why it is a good idea to
    use functions instead of just having all of the code in one place.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，我是如何决定将代码分成这些函数的？我们是否真的需要它们，或者这个程序能否在不使用它们的情况下编写？答案是肯定的，它可以，我们现在将看到为什么使用函数而不是将所有代码放在一个地方是一个好主意。
- en: 'In [*Chapter 7*](B15554_07_Final_NM_ePub.xhtml#_idTextAnchor103)*, Program
    Control Structures*, we had the following figure:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B15554_07_Final_NM_ePub.xhtml#_idTextAnchor103)*，程序控制结构*中，我们有以下图示：
- en: '![Figure 8.4\. Flowchart of the phone application](img/B15554_08_04.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4. 电话应用的流程图](img/B15554_08_04.jpg)'
- en: Figure 8.4 – Flowchart of the phone application
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 电话应用的流程图
- en: Here, we can see that we have a loop that runs forever (remember that forever
    in programming means as long as the program is running). We also have a selection
    statement that checks whether we are within the range and if we are, the signal
    is sent. After that, no matter whether we sent a signal or not, we will go back
    to the beginning and ask for our current position again.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们有一个无限循环（记住编程中的无限意味着只要程序在运行）。我们还有一个选择语句，检查我们是否在范围内，如果是，则发送信号。之后，无论是否发送了信号，我们都会回到开始处再次请求我们的当前位置。
- en: 'Now, imagine the code for this application. It might look something like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下这个应用的代码。它可能看起来像这样：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Every line that starts with some code will most likely be made up of several
    code lines in the real application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行以代码开头的内容，在真实应用中很可能是由几行代码组成的。
- en: If we read the code, we can see that we start ours with a `while` loop that
    runs as long as `true` is true. `true` will always be true so this is how we can
    create an endless loop that will just go on and run forever.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们阅读代码，我们可以看到我们从一个`while`循环开始，只要`true`为真，这个循环就会运行。`true`始终为真，所以这就是我们如何创建一个无限循环，它会一直运行下去。
- en: 'If you compare the program to the flowchart in *figure 8.4*, you can see that
    the logic is identical:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将程序与*图8.4*中的流程图进行比较，你会发现逻辑是相同的：
- en: The oval at the top is the two lines in the code, which is connecting to the
    GPS and communicating with the GPS.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部的椭圆形是代码中的两行，它连接到GPS并与GPS通信。
- en: The rectangle that follows the oval is represented by the code that calculates
    the distance.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随后跟随椭圆形的矩形表示计算距离的代码。
- en: The diamond shape is the `if` statement and the code within the `if` statement
    is the final rectangle in the flow chart.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钻石形状是`if`语句，而`if`语句中的代码是流程图中的最后一个矩形。
- en: The two arrows that bring us back to the top is the `while` loop that encapsulates
    the rest of the code.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们带回到顶部的两个箭头是封装其余代码的`while`循环。
- en: Looking at the code, it might not look that bad, but remember that this is just
    an outline of what needs to be done.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 看着代码，可能看起来并不那么糟糕，但请记住，这只是一个需要完成的任务的概要。
- en: 'If we now start to change this to see what the program actually might look
    like, we can change the two first lines into something like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在开始修改它，看看程序实际上可能是什么样子，我们可以将前两行修改成这样：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first line creates some sort of `location` object that can be used to communicate
    with the GPS. Note that we store this object in a variable called `location`,
    with all lowercase letters. `Location` with a capital *L*, to the right, is the
    thing that creates this object for us. To see how this is actually done, we will
    need to read the documentation for the programming language we are currently using.
    Most likely, it will be done in a line that resembles this.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个可以用来与GPS通信的某种`位置`对象。请注意，我们将此对象存储在一个名为`location`的变量中，所有字母均为小写。右侧的`Location`（首字母大写*L*）是我们用来创建此对象的东西。要了解这是如何实际完成的，我们需要阅读我们目前正在使用的编程语言的文档。很可能会在类似这样的行中完成。
- en: We can then use this `location` variable to get the current latitude and longitude.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用这个`location`变量来获取当前的纬度和经度。
- en: 'Calculating the distance between two geographical coordinates is something
    that most of us can''t even imagine how we should do. Searching online might scare
    us. What we will get back is that we must use something called the *haversine
    formula* (there are other ways to accomplish this too, but for this example, we
    will stick with this formula). Then, we get something like this that will explain
    the formula:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 计算两个地理坐标之间的距离是我们大多数人甚至无法想象应该如何去做的事情。在网上搜索可能会让我们感到害怕。我们可能会得到这样的结果：我们必须使用一种称为*哈弗辛公式*的东西（还有其他方法可以完成这个任务，但在这个例子中，我们将坚持使用这个公式）。然后，我们会得到一些解释公式的类似内容：
- en: '![](img/Formula_08_001.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_08_001.png)'
- en: '![](img/Formula_08_002.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_08_002.png)'
- en: '![](img/Formula_08_003.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_08_003.png)'
- en: Here, *ϕ* is latitude, *λ* is longitude, and *R* is the Earth's radius (the
    mean radius is 6,371 km). Note that all angles need to be in radians.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*ϕ*是纬度，*λ*是经度，*R*是地球的半径（平均半径为6,371公里）。请注意，所有角度都需要以弧度为单位。
- en: Don't be scared if you don't understand any of that. Most likely, someone else
    has already looked at that formula and translated it into source code for the
    language you are using. This is good as we can use it without actually understanding
    the formula. We must make sure, though, that the calculations done with it match
    other tools that do the same things. We will soon do such a test, but first, let's
    just see what such an implementation can look like.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些都不理解，不要害怕。很可能是其他人已经看过这个公式，并将其翻译成了你使用的语言的源代码。这是好事，因为我们可以在不了解公式的情况下使用它。不过，我们必须确保使用它所做的计算与其他执行相同任务的工具相匹配。我们很快就会进行这样的测试，但首先，让我们看看这样的实现可能是什么样子。
- en: 'In this example, we pretend that we are at the *Musée des Lettres et Manuscrits*
    in Paris and that we rent a home on *Avenue Victor-Hugo* in the same city. Musée
    des Lettres et Manuscrits is located at latitude 48.855421 and longitude 2.327688\.
    Our pretend home on Avenue Victor Hugo is located at latitude 48.870320 and longitude
    2.286560:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们假装自己在巴黎的*字母和手稿博物馆*，并在同一城市的*维克多·雨果大道*上租了一栋房子。字母和手稿博物馆位于纬度48.855421和经度2.327688。我们在维克多·雨果大道上的假想家园位于纬度48.870320和经度2.286560：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Wow, scary stuff, but the good thing is that we don''t need to understand it
    to use it. We must just make sure that it works. As we can see at the top, we
    have the coordinates to the museum (that we pretend that we are visiting), followed
    by the coordinates to our home (that we pretend that we are renting). Running
    this program will give us the following output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这很可怕，但好事是我们不需要理解它就能使用它。我们只需确保它工作。如我们所见，在顶部，我们有博物馆（我们假装我们要参观）的坐标，然后是我们家（我们假装我们要租）的坐标。运行这个程序将给出以下输出：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Plugging these same coordinates into an online geo coordinate distance calculator
    will give us the result shown in *figure 8.5*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些相同的坐标输入在线地理坐标距离计算器，将给出*图8.5*中所示的结果：
- en: '![Figure 8.5: Online geo coordinate distance calculator](img/B15554_08_08.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5：在线地理坐标距离计算器](img/B15554_08_08.jpg)'
- en: Figure 8.5 – Online geo coordinate distance calculator
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 在线地理坐标距离计算器
- en: As we can see, the result matches ours. We should perform more tests by trying
    other coordinates, both in our program and the calculator, to verify that the
    results match.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，结果与我们的相符。我们应该通过尝试其他坐标来执行更多测试，无论是在我们的程序中还是在计算器中，以验证结果是否匹配。
- en: Great, now we can perform this calculation even if we don't understand all of
    the details for how it works.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在即使我们不完全理解它是如何工作的，我们也可以进行这个计算。
- en: 'We now have a distance that tells us how far we are from our Paris home. Now
    we need to decide how close we need to be to our home before we turn on the light.
    Maybe 500 meters is a good distance as we don''t want to turn it on too early
    and not too late; 500 meters is 0.5 kilometers, so this is the value we can compare
    our distance to:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个距离，它告诉我们我们离巴黎家有多远。现在我们需要决定在打开灯之前我们需要离家多近。也许500米是一个好的距离，因为我们不想太早或太晚打开它；500米是0.5公里，所以这是我们比较距离的值：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For now, let''s ignore the code that connects to the home computer and sends
    the notification, and just put everything together that we have so far:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们忽略连接到家用电脑并发送通知的代码，只是把到目前为止我们所拥有的所有东西放在一起：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Reading this code is hard and confusing. What can we do about it? Functions
    are the answer. Let's see how that works.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读这段代码很难，也很令人困惑。我们能做什么？函数是答案。让我们看看它是如何工作的。
- en: Splitting the code further
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步拆分代码
- en: When breaking a long code into small functions, we must remember that a function
    should do one thing or answer one question.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当将长代码拆分成小函数时，我们必须记住一个函数应该做一件事或回答一个问题。
- en: 'One trick we can use to identify separate tasks within the code is to read
    it from beginning to end, and when we feel that the application shifts its focus
    from one thing to another, we can insert a blank line into the code. Let''s do
    that for the application that we have used so far:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用来识别代码中单独任务的一个技巧是从头到尾阅读它，当我们感觉到应用程序的焦点从一件事转移到另一件事时，我们可以在代码中插入一个空行。让我们为到目前为止我们所使用的应用程序做这件事：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As we can see, there are now blocks of code separated by blank lines. Let's
    study them closely.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，现在有通过空行分隔的代码块。让我们仔细研究它们。
- en: There is nothing we can do about the first line with `while`, at least not at
    this point. It will just sit at the top and make sure that we repeat the code
    over and over.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一行中的`while`，我们无能为力，至少不是现在。它将静置在顶部并确保我们反复执行代码。
- en: After the line with `while`, three lines follow that all have to do with establishing
    our location. When reading the code, we should ask ourselves, what task does this
    line help us to accomplish? For all of these lines, the answer will be, answer
    the question where we are. But when we hit the line that begins with `home_latitude`,
    this is no longer true. We are now in a block of code that does something else.
    The code has shifted focus, so we insert a blank line.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`语句的下一行之后，有三行都与确定我们的位置有关。在阅读代码时，我们应该问自己，这一行帮助我们完成什么任务？对于所有这些行，答案将是回答我们在哪里的问题。但当我们遇到以`home_latitude`开头的行时，这不再成立。我们现在在一个执行其他操作的代码块中。代码的焦点已经转移，所以我们插入了一个空白行。
- en: We now have two lines that answer the question "where do we live?". They obviously
    belong together. But after these two lines, there is a line defining the radius
    of the earth. This is a noticeable shift in the focus so why did I not insert
    a blank line here?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两行代码回答了“我们住在哪里？”的问题。它们显然是相关的。但在这两行代码之后，有一行定义了地球的半径。这是一个明显的焦点转移，那么为什么我没有在这里插入一个空白行呢？
- en: The answer can be found if we look closer at these three lines. All three do
    have something in common. They all have fixed values that will never change. We
    say that these are constant values. We will deal with them later, but let's move
    on.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察这三行，会发现它们都有共同点。它们都有固定值，这些值永远不会改变。我们称这些为常量值。我们稍后会处理它们，但让我们继续前进。
- en: Then, we come to a larger block that deals with the distance calculation. That
    is a single task.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们来到了一个处理距离计算的较大代码块。这是一个单一的任务。
- en: In the end, we have the `if` statement containing the signaling to the home
    computer that we have left unimplemented so far.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个包含向家用电脑发送信号的`if`语句，但我们迄今为止还没有实现。
- en: To begin with, we have two strong candidates for becoming functions here and
    that is where we get our current location and the distance calculation. Let's
    try to turn them into functions and we start with the part that tells us where
    we are.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有两个强有力的候选者可以成为函数，那就是我们获取当前位置和距离计算的地方。让我们尝试将它们转换为函数，并从告诉我们我们所在位置的部分开始。
- en: 'Currently, that part of the code looks like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这部分代码看起来是这样的：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can move these three lines into a function like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这三行移动到一个函数中，如下所示：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, we must check two things. First, does this function need any data as input?
    The answer is no. To accomplish its task, it does not need any more data. This
    means that this function will not take any arguments.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须检查两件事。首先，这个函数需要任何输入数据吗？答案是肯定的。为了完成其任务，它不需要更多的数据。这意味着这个函数将不接受任何参数。
- en: Secondly, will this function need to return any data back to the location where
    we called the function? The answer to this is yes, but it is a bit tricky.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这个函数是否需要将任何数据返回到我们调用函数的位置？对这个问题的答案是肯定的，但有点棘手。
- en: The current longitude and latitude are now created inside a function and this
    makes it inaccessible outside it. These are called *local variables*, a topic
    we will discuss in more detail at the end of this chapter. We had the same problem
    with the function that calculated the number of seconds since midnight. We solved
    it then by returning the result using the `return` keyword. We will need to do
    that here too, but most programming languages will only let us return one single
    value from a function, but we need to return two values, both the latitude and
    longitude.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当前经纬度现在是在一个函数内部创建的，这使得它在外部不可访问。这些被称为*局部变量*，我们将在本章末尾详细讨论这个话题。我们之前在计算午夜以来秒数的函数中也遇到了相同的问题。我们当时通过使用`return`关键字返回结果来解决它。我们在这里也需要这样做，但大多数编程语言只允许我们从函数中返回一个单一值，但我们需要返回两个值，即纬度和经度。
- en: We can get around this limitation by putting the two values inside an array.
    Remember that an array is a sequence of things, and an array is treated as one
    single item, even if it contains many values.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将这两个值放入一个数组中来解决这个问题。记住，数组是一系列事物，即使它包含许多值，数组也被视为一个单一的项目。
- en: 'We can change our function so it looks like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改我们的函数，使其看起来像这样：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that the two values are inside square brackets. This creates an array and
    inserts `latitude` as its first value and `longitude` as its second.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个值都在方括号内。这创建了一个数组，并将`latitude`作为其第一个值，`longitude`作为第二个值。
- en: 'We must now call the function and receive the coordinates in `location` in
    the code where we previously fetched the location. The `while` loop now looks
    like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须调用这个函数，并在我们之前获取位置的代码中接收`location`坐标。现在的`while`循环看起来是这样的：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: On the first line inside the `while` loop, we are now making a call to the function.
    We will get the array containing the latitude and longitude and we store them
    in a variable we call `position`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环的第一行内部，我们现在正在调用函数。我们将得到包含纬度和经度的数组，并将它们存储在我们称为`position`的变量中。
- en: We have a problem now as, later on, when we calculate the distance, we will
    be using the variables, `my_latitude` and `my_longitude`. These two now only exist
    inside the function, so when we reach the lines that convert them into radians,
    we will get an error saying that `my_latitude` is undefined. This is how a programming
    language will tell you that it has no idea what `my_latitude` is.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个问题，因为我们稍后计算距离时将使用变量`my_latitude`和`my_longitude`。这两个现在只存在于函数内部，所以当我们到达将它们转换为弧度的行时，我们会得到一个错误，说`my_latitude`未定义。这就是编程语言告诉你它不知道`my_latitude`是什么的方式。
- en: 'The problem here is that we have packaged the coordinates inside an array that
    we have named `position`. We could solve this by replacing the two problematic
    lines with this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，我们将坐标包装在一个名为`position`的数组中。我们可以通过用以下内容替换这两个有问题的行来解决这个问题：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Remember that we can access individual items within an array by using the index
    to the position that the item has within the array. Also, remember that the indexing
    starts at 0.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们可以通过使用数组中项目的索引来访问数组中的单个项目。也要记住，索引从0开始。
- en: Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you need a reminder on how arrays work, we talked about them in [*Chapter
    6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)*, Working with Data – Variables*
    in the *Composite types* section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要关于数组如何工作的提醒，我们已经在[*第6章*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)*，在*复合类型*部分中讨论了它们*，即*使用数据
    – 变量*。
- en: As we added the latitude as the first element in the array, it can be found
    at index 0 and the longitude at index 1\. This code is harder to read through
    as we must know how the array was created within the function to know that the
    latitude came before the longitude.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将纬度作为数组的第一个元素添加，它可以在索引0处找到，经度在索引1处。由于我们必须知道函数内部数组是如何创建的，以便知道纬度在经度之前，所以这段代码更难阅读。
- en: 'Another option that would make our code easier to read would be to unpack these
    two values into variables again like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以使我们的代码更容易阅读的选项是将这两个值再次解包到变量中，如下所示：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, after we are making the call, we insert the first value into a variable
    called `my_latitude` and the second into a variable called `my_longitude`. As
    we picked the same name that was later used in the calculation, we will not need
    to change it at all if we use this option.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在调用之后，我们将第一个值插入到名为`my_latitude`的变量中，第二个值插入到名为`my_longitude`的变量中。由于我们选择了后来在计算中使用的相同名称，如果我们使用这个选项，我们根本不需要更改它。
- en: I will go with a third option and will leave the variables in the array for
    now and not change the code in the calculation. We will soon see why.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我将选择第三个选项，现在暂时保留数组中的变量，不更改计算代码。我们很快就会看到原因。
- en: 'We can now turn our attention to the calculation code and turn that into a
    function. This function will now look like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将注意力转向计算代码，并将其转换为函数。这个函数现在看起来是这样的：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Again, we will now check to see whether this function needs any more data to
    fulfill its task. Yes, as this is written, we are missing several things. This
    function does not know about our latitude and longitude. It does not know the
    home latitude and longitude either and `earth_radius` is also unknown to it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们现在将检查这个函数是否需要更多的数据来完成其任务。是的，按照现在的写法，我们遗漏了几件事。这个函数不知道我们的纬度和经度。它也不知道家庭纬度和经度，`earth_radius`对它来说也是未知的。
- en: 'Let''s turn the attention back to the three lines where we defined the home
    location and the radius of the earth. Who will need this data? When we think about
    it, the answer is, only the function we just created. This means that we can move
    these three lines into the function like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把注意力转回到定义家庭位置和地球半径的三个地方。谁会需要这些数据？当我们思考这个问题时，答案是，只有我们刚刚创建的函数。这意味着我们可以将这些三行移动到函数中，如下所示：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We add them at the top, so they are all defined when they are needed later on
    in the function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将它们添加到顶部，这样它们在函数稍后需要时就已经定义了。
- en: 'Now, we are only missing the latitude and longitude for our current position.
    This function must accept them as their arguments. We can now either say that
    this function takes two arguments, `latitude` and `longitude`, as separate parameters
    like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只缺少我们当前位置的纬度和经度。这个函数必须接受它们作为它们的参数。我们现在可以说这个函数接受两个参数，`latitude` 和 `longitude`，作为单独的参数，如下所示：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Another option is that we can let this function accept an array with the values.
    This suits our needs as we know that we will get an array back from the other
    function we wrote. So, let's use that option.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是，我们可以让这个函数接受一个包含值的数组。这符合我们的需求，因为我们知道我们将从我们编写的另一个函数中得到一个数组。所以，让我们使用这个选项。
- en: 'It will look like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来会是这样：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We now accept an array, and we call it `current_position`. We must now make
    one change inside the function on the lines where we use `my_latitude` and `my_longitude`.
    We can do the same as we saw before and index into the array as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在接受一个数组，我们称它为 `current_position`。我们现在必须在函数内部使用 `my_latitude` 和 `my_longitude`
    的行上进行一个更改。我们可以像之前看到的那样做，并按如下方式索引到数组中：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The full function now looks like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的函数现在看起来是这样的：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Putting it all together
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 把它们放在一起
- en: Now we must check whether this function needs to return something. It calculates
    the distance and we need that outside the function, so that value needs to be
    returned.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须检查这个函数是否需要返回某些内容。它计算距离，我们需要这个值在函数外部，所以这个值需要被返回。
- en: 'Again, we have two options. We can either return the value contained inside
    the variable distance like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们有两种选择。我们可以返回变量 `distance` 中包含的值，如下所示：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Or, if not the previous option, we can make this shorter, though, as the `distance`
    variable is only used to hold the distance for one line. So, instead of using
    it to hold the value we want to return, we can return the result from the calculation
    directly and get rid of the `distance` variable. It would look like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果不是前面的选项，我们可以使它更短，因为 `distance` 变量只用于保存一行距离。所以，我们不是用它来保存我们想要返回的值，而是可以直接从计算中返回结果，并去掉
    `distance` 变量。它看起来会是这样：
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'That is better. The function is now finished and looks like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好。函数现在已经完成，看起来是这样的：
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will now need to call it. Our `while` loop is now much cleaner and its main
    responsibility is to call our two functions. The loop now looks like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要调用它。我们的 `while` 循环现在更加简洁，其主要职责是调用我们的两个函数。循环现在看起来是这样的：
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We call the new function by passing the `position` array to it, and we will
    get the distance back and store it in a variable called `distance`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过传递 `position` 数组来调用这个新函数，并将得到的距离存储在一个名为 `distance` 的变量中。
- en: Now, this is more pleasant to look at. If you think about it, you can treat
    this as a table of contents in a book. On the first line, we call a function called
    `get_current_position`. The name of the function is chosen to reflect what it
    does. So, reading this line explains what happens. We can now decide whether we
    are interested in seeing what happens when we get the current position or not.
    If not, we can just accept that we get the current position back. If we do want
    to know how it works, we can go to the function and read the code there.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这看起来更令人愉快。如果你这么想，你可以把它当作一本书的目录。在第一行，我们调用一个名为 `get_current_position` 的函数。函数的名称被选择来反映它所做的事情。所以，阅读这一行解释了发生了什么。我们现在可以决定我们是否对看到我们获取当前位置时发生的事情感兴趣。如果不感兴趣，我们就可以接受我们得到了当前位置。如果我们想了解它是如何工作的，我们可以去函数那里阅读代码。
- en: We can then treat the next line in the same way. The name tells us what the
    function does, so there is no need for us to go and read that. We can trust that
    it does its job and that we get a distance back.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以同样的方式处理下一行。函数的名称告诉我们它做什么，所以我们不需要去读它。我们可以相信它完成了它的任务，并且我们得到了一个距离。
- en: The code is easier to read, maintain, and update, thanks to the use of functions.
    Another benefit is that complex distance calculation is hidden away in a function
    and we don't need to see it if we don't want to.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了函数，代码现在更容易阅读、维护和更新。另一个好处是，复杂的距离计算被隐藏在函数中，如果我们不想看到它，我们就不需要看到它。
- en: 'We now only have the part inside the `if` statement left. To communicate with
    the home computer, we can use something called *sockets*. The concept of sockets
    is rather advanced, and we will not go into any details of it here. We can just
    say that all of that code will go into a function of its own and we can call that
    function from within the `if` statement by using a final `while` loop that looks
    like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在只剩下`if`语句内部的这部分。为了与家用电脑通信，我们可以使用一种叫做*套接字*的东西。套接字的概念相当高级，我们在这里不会深入细节。我们只能说，所有这些代码都将进入它自己的函数，并且我们可以通过使用一个看起来像这样的最终`while`循环在`if`语句内部调用该函数：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Compare this to the code we started with, which looked like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与我们的起始代码进行比较，它看起来像这样：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is a major clean up of the code and is indeed very helpful, not to mention
    less scary and more pleasing to the eye!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对代码的重大清理，确实非常有帮助，不仅不那么令人恐惧，而且看起来更令人愉悦！
- en: In this section, we have seen that when we create a variable inside a function,
    it becomes inaccessible for all of the code outside that function. We will now
    discuss this further with local and global variables.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了当我们在一个函数内部创建一个变量时，它对函数外部的所有代码都不可访问。我们现在将进一步讨论局部变量和全局变量。
- en: Local and global variables
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局部变量和全局变量
- en: 'A variable declared (created) inside a function is called a local variable,
    and it can only be accessed from within the function. Outside the function, it
    is as if the variable never existed at all. Check the following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部声明（创建）的变量被称为局部变量，并且只能从函数内部访问。在函数外部，它就像变量根本不存在一样。请检查以下代码：
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we create and assign a value to the `name` variable inside the `my_function`
    function. Outside the function, we first call the function, and then we try to
    print the name. The program will crash with an error on the line where we try
    to print the name. The reason is that the `name` variable is unknown in this part
    of the program. It is only valid as long as we execute code inside the function.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们在`my_function`函数内部创建并给`name`变量赋值。在函数外部，我们首先调用函数，然后尝试打印名称。程序将在尝试打印名称的行上崩溃并出现错误。原因是`name`变量在这个程序部分是未知的。它只在我们执行函数内部的代码时有效。
- en: This is a local variable. It is local as it is created inside the function.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个局部变量。因为它是在函数内部创建的，所以它是局部的。
- en: 'If we instead change the program so it looks like this, things will be different:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改变程序，使其看起来像这样，事情将会不同：
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'It might be hard to see what happens here. To understand this, we must read
    the code as the compiler/interpreter will read the code when it executes it:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能很难看出发生了什么。为了理解这一点，我们必须像编译器/解释器在执行它时那样阅读代码：
- en: It will start at the first line and see that we create a variable called `name`
    and assign the `Bill` string to it.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将从第一行开始，看到我们创建了一个名为`name`的变量，并将`Bill`字符串赋值给它。
- en: It will then continue and see the function. It will not run the function; just
    remember that it exists.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它将继续并看到函数。它不会运行函数；只是记住它存在。
- en: Then, we call the function, so the execution of the program will now jump up
    and run the code inside the function.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们调用函数，因此程序的执行将现在跳上去运行函数内部的代码。
- en: Here we find a line where we assign the `Lisa` string to a variable called `name`.
    As it already knows about this variable, it will change its content and will store
    `Lisa` in it and the `Bill` string is now gone.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里我们找到了一行，我们将`Lisa`字符串赋值给一个名为`name`的变量。因为它已经知道这个变量，它会更改其内容，并将`Lisa`存储在其中，而`Bill`字符串现在消失了。
- en: The end of the function is now reached, so the execution jumps back down to
    where it came from.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的结尾现在到达了，所以执行跳回到它来的地方。
- en: On the last line, the content of the variable name will be printed, which is
    `Lisa`.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最后一行，变量`name`的内容将被打印出来，它是`Lisa`。
- en: From the working of the preceding code, we saw that as we moved the declaration
    of the variable out of the function, it turned global (for use in code) and so
    it is now a global variable. A global variable can be accessed from any location.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面代码的工作原理中，我们看到当我们将变量的声明从函数中移出时，它变成了全局的（用于代码），因此现在它是一个全局变量。全局变量可以从任何位置访问。
- en: Some programming languages will not let us modify a global variable, as we did
    in the preceding example, but instead of the assignment of `Lisa` within the function,
    it will create a new variable with the same name.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言不会让我们修改全局变量，就像我们在前面的例子中所做的那样，但取而代之的是，在函数内部对`Lisa`的赋值，它将创建一个新的具有相同名称的变量。
- en: It might sound as if global variables are the way to go. But it is actually
    the opposite. We shall always strive to use local variables as often as we can.
    The reason is that it is hard to control global variables.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来可能全球变量是最佳选择。但实际上正好相反。我们应该始终努力尽可能多地使用局部变量。原因是控制全局变量很困难。
- en: Imagine that you have a program that is thousands of lines long, and all variables
    are global. They get changed here and there and all over, and then you discover
    that one of the variables has a value that would be impossible for it to have.
    Somewhere, a code line has changed this variable in a bad way. This is an error
    in our program, and we need to find it and fix it. But where is that line? As
    all parts of the program can change that variable (and all of the others that
    are declared global), it can be extremely hard to find that location. It might
    also be so that the reason this variable has a bad value is that some other variable
    had a bad value and that we discovered the error was just a side effect.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个数千行代码的程序，所有变量都是全局的。它们在这里和那里以及各个地方都被改变，然后你发现其中一个变量的值变得不可能。某个地方，有一行代码以错误的方式改变了这个变量。这是我们程序中的一个错误，我们需要找到并修复它。但那行代码在哪里？由于程序的所有部分都可以改变这个变量（以及所有被声明为全局的变量），找到这个位置可能非常困难。也可能是因为这个变量有错误值的原因是其他某个变量也有错误值，而我们发现的错误只是一个副作用。
- en: 'Code like this is called *spaghetti code*. The reason it is called this will
    be obvious if you look at figure 8.6, which illustrates how five functions change
    four global variables. Look at it and try to figure out how changed what and when:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的代码被称为*意大利面代码*。如果你查看图8.6，它展示了五个函数如何改变四个全局变量，那么这个名称的由来就会变得明显。看看它，并尝试弄清楚是什么被改变了，以及何时被改变的：
- en: '![Figure 8.6\. Five functions changing four global variables](img/B15554_08_09.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6\. 五个函数改变四个全局变量](img/B15554_08_09.jpg)'
- en: Figure 8.6 – Five functions changing four global variables
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 五个函数改变四个全局变量
- en: By using local variables, we will make things much cleaner and easier to understand.
    We can do this by passing data into a function using arguments and returning results
    from the function to the location that called it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用局部变量，我们可以使事情变得更加清晰和易于理解。我们可以通过将数据作为参数传递给函数，并将函数的结果返回到调用它的位置来实现这一点。
- en: 'We should also note that function parameters are considered local variables.
    What this means is that if we look at the `calculate_distance_from_home` function
    that we created earlier, we can see that we have a parameter called `current_position`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该注意，函数参数被认为是局部变量。这意味着如果我们查看我们之前创建的`calculate_distance_from_home`函数，我们可以看到我们有一个名为`current_position`的参数：
- en: '[PRE52]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: It will be treated as a local variable within this function.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在该函数内被当作局部变量处理。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen that functions are a powerful tool we can use
    to organize and structure our code to make it more readable and reusable.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了函数是一个强大的工具，我们可以用它来组织和结构我们的代码，使其更易于阅读和重用。
- en: We saw how functions have a name, and that name can be used to call them. Calling
    a function makes the code inside it to execute. This is something we can do over
    and over again as often as we need to.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了函数有一个名字，并且可以使用这个名字来调用它们。调用函数会使函数内部的代码执行。这是我们可以在需要时重复多次的操作。
- en: Sometimes, we want functions to produce a value as a result of its operations.
    In those cases, we can let the function return something. We can then use that
    value in the location where we called the function.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们希望函数在操作后产生一个结果值。在这种情况下，我们可以让函数返回一些东西。然后我们可以在调用函数的位置使用那个值。
- en: Then, we learned that we can also pass data into a function. This can be done
    using function arguments. The function receives these arguments in local variables
    called parameters.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了我们还可以将数据传递给函数。这可以通过函数参数来实现。函数通过这些参数接收局部变量，称为参数。
- en: With the introduction of functions, we also have the concepts of variables being
    either global or local. We saw that global variables can be accessed from any
    location within the program and local variables can only be used within the function
    where they are created.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 随着函数的引入，我们也有了变量是全局还是局部的概念。我们看到了全局变量可以从程序中的任何位置访问，而局部变量只能在创建它们的函数内部使用。
- en: Sometimes, things will not go according to plan, and we will discover that our
    program either produces the wrong results or simply crashes. In the next chapter,
    we will see how we can identify bugs in our programs and handle errors that can
    be harder to predict.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，事情可能不会按照计划进行，我们会发现我们的程序要么产生了错误的结果，要么简单地崩溃了。在下一章中，我们将看到我们如何识别程序中的错误并处理那些难以预测的错误。
