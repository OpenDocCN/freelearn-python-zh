- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stacks and Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss two very important data structures: stacks
    and queues. Stacks and queues have many important applications, such as form operating
    system architecture, arithmetic expression evaluation, load balancing, managing
    printing jobs, and traversing data. In stack and queue data structures, the data
    is stored sequentially, like arrays and linked lists, but unlike arrays and linked
    lists, the data is handled in a specific order with certain constraints, which
    we will be discussing in detail in this chapter. Moreover, we will also examine
    how we can implement stacks and queues using linked lists and arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss constraints and methods to handle the data
    in stacks and queues. We will also implement these data structures and learn how
    to apply different operations to these data structures in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to implement stacks and queues using various methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some real-life example applications of stacks and queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stack is a data structure that stores data, similar to a stack of plates in
    a kitchen. You can put a plate on the top of the stack, and when you need a plate,
    you take it from the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last plate that was added to the stack will be the first to be picked up
    from the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Example of a stack'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram depicts a stack of plates. Adding a plate to the pile
    is only possible by leaving that plate on top of the pile. To remove a plate from
    the pile of plates means to remove the plate that is on top of the pile.
  prefs: []
  type: TYPE_NORMAL
- en: 'A stack is a data structure that stores the data in a specific order similar
    to arrays and linked lists, with several constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: Data elements in a stack can only be inserted at the end (`push` operation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data elements in a stack can only be deleted from the end (`pop` operation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the last data element can be read from the stack (`peek` operation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stack data structure allows us to store and read data from one end, and the
    element which is added last is picked up first. Thus, a stack is a **last in first
    out** (**LIFO)** structure, or **last in last out** (**LILO**).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two primary operations performed on stacks – `push` and `pop`. When
    an element is added to the top of the stack, it is called a `push` operation,
    and when an element is to be picked up (that is, removed) from the top of the
    stack, it is called a `pop` operation. Another operation is `peek`, in which the
    top element of the stack can be viewed without removing it from the stack. All
    the operations in the stack are performed through a pointer, which is generally
    named `top`. All these operations are shown in *Figure 5.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Demonstration of push and pop operations in a stack'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table demonstrates the use of two important stack operations
    (`push` and `pop`) in the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Stack operation** | **Size** | **Contents** | **Operation results** |'
  prefs: []
  type: TYPE_TB
- en: '| `stack()` | 0 | `[]` | Stack object created, which is empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `push "egg"` | 1 | `[''egg'']` | One item `egg` is added to the stack. |'
  prefs: []
  type: TYPE_TB
- en: '| `push "ham"` | 2 | `[''egg'', ''ham'']` | One more item, `ham`, is added
    to the stack. |'
  prefs: []
  type: TYPE_TB
- en: '| `peek()` | 2 | `[''egg'', ''ham'']` | The top element, `ham`, is returned.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pop()` | 1 | `[''egg'']` | The `ham` item is popped off and returned. (This
    item was added last, so it is removed first.) |'
  prefs: []
  type: TYPE_TB
- en: '| `pop()` | 0 | `[]` | The `egg` item is popped off and returned. (This is
    the first item added, so it is returned last.) |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1: Illustration of different operations in a stack with examples'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stacks are used for a number of things. One common usage for stacks is to keep
    track of the return address during function calls. Let’s imagine that we have
    the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When the program execution gets to the call to `a()`, a sequence of events
    will be followed in order to complete the execution of this program. A visualization
    of all these steps is shown in *Figure 5.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Steps for a sequence of events during function calls in our sample
    program'
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequence of events is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the address of the current instruction is pushed onto the stack, and
    then execution jumps to the definition of `a`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside function `a()`, function `b()` is called
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The return address of function `b()` is pushed onto the stack. Once the execution
    of the instructions and functions in `b()` are complete, the return address is
    popped off the stack, which takes us back to function `a()`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When all the instructions in function `a()` are completed, the return address
    is again popped off the stack, which takes us back to the main program and the
    `print` statement
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output of the above program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have now discussed the concept of the stack data structure. Now, let us understand
    its implementation in Python using array and linked list data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Stack implementation using arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stacks store data in sequential order like arrays and linked lists, with a specific
    constraint that the data can only be stored and read from one end of the stack
    following the **last in first out** (**LIFO**) principle. In general, stacks can
    be implemented using arrays and linked lists. Array-based implementations will
    have fixed lengths for the stack, whereas linked list-based implementations can
    have stacks of variable lengths.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the array-based implementation of a stack (where the stack has
    a fixed size), it is important to check whether the stack is full or not, since
    trying to push an element into a full stack will generate an error, called an
    overflow. Likewise, trying to apply a `pop` operation to an empty stack causes
    an error known as an underflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us understand the implementation of a stack using an array with an example
    in which we wish to push three data elements, “egg”, “ham”, and “spam”, into the
    stack. Firstly, to insert new elements into a stack using the `push` operation,
    we check the overflow condition, which is when the `top` pointer is pointing to
    the end index of the array. The `top` pointer is the index position of the top
    element in the stack. If the top element is equal to the overflow condition, the
    new element cannot be added. This is a stack overflow condition. If there is free
    space in the array to insert new elements, new data is pushed into the stack.
    An overview of the `push` operation on a stack using an array is shown in *Figure
    5.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Sequence of push operations in a stack implementation using an
    array'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code for the `push` operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above code, we initialize the stack with a fixed size (say, 3 in this
    example), and also the `top` pointer to –1, which indicates that the stack is
    empty. Further, in the push method, the `top` pointer is compared with the size
    of the stack to check the overflow condition and, if the stack is full, the stack
    overflow message is printed. If the stack is not full, the top pointer is incremented
    by 1, and the new data element is added to the top of the stack. The following
    code is used to insert data elements into the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above code, when we try to insert the first three elements, they are
    added since there was enough space, but when we try to add the data elements `new`
    and `new2`, the stack is already full, hence these two elements cannot be added
    to the stack. The output of this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `pop` operation returns the value of the top element of the stack
    and removes it from the stack. Firstly, we check if the stack is empty or not.
    If the stack is already empty, a stack underflow message is printed. Otherwise,
    the top is removed from the stack. An overview of the `pop` operation is shown
    in *Figure 5.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Sequence of the pop operation in a stack implementation using an
    array'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code for the `pop` operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we first check the underflow condition by checking whether
    the stack is empty or not. If the `top` pointer has a value of –1, it means the
    stack is empty. Otherwise, the data elements in the stack are removed by decrementing
    the `top` pointer by 1, and the top data element is returned to the main function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we already added three data elements to the stack, and then we
    call the `pop` function four times. Since there are only three elements in the
    stack, the initial three data elements are removed, and when we try to call the
    `pop` operation a fourth time, the stack underflow message is printed. This is
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let us see an implementation of the `peek` operation in which we return
    the value of the top element of the stack. The Python code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, firstly, we check the position of the `top` pointer in the
    stack. If the value of the `top` pointer is –1, it means that the stack is empty,
    otherwise, we print the value of the top element of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed the Python implementation of a stack using an array, so next
    let us discuss stack implementation using linked lists.
  prefs: []
  type: TYPE_NORMAL
- en: Stack implementation using linked lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to implement the stacks using linked lists, we will write the `Stack`
    class in which all the methods will be declared; however, we will also use the
    `node` class similar to what we discussed in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As we know, a `node` in a linked list holds data and a reference to the next
    item in the linked list. Implementing the stack data structure using a linked
    list can be treated as a standard linked list with some constraints, including
    that elements can be added or removed from the end of the list (`push` and `pop`
    operations) through the `top` pointer. This is shown in *Figure 5.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Representation of the stack using a linked list'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us look at the `stack` class. Its implementation is quite similar to
    a singly linked list. In addition, we need two things to implement a stack:'
  prefs: []
  type: TYPE_NORMAL
- en: We first need to know which node is at the top of the stack so that we can apply
    the `push` and `pop` operations through this node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We would also like to keep track of the number of nodes in the stack, so we
    add a `size` variable to the `Stack` class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we have declared the `top` and `size` variables, which are
    initialized to `None` and `0`. Once we have initialized the `Stack` class, next,
    we will implement different operations in the `Stack` class. First, let us start
    with a discussion of the `push` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Push operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `push` operation is an important operation on a stack; it is used to add
    an element at the top of the stack. In order to add a new node to the stack, firstly,
    we check if the stack already has some items in it or if it is empty. We are not
    required here to check the overflow condition because we are not required to fix
    the length of the stack, unlike the stack implementation using arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the stack already has some elements, then we have to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: The new node must have its next pointer pointing to the node that was at the
    top earlier
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We put this new node at the top of the stack by pointing `self.top` to the newly
    added node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the two instructions in the following *Figure 5.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: Workings of the push operation on the stack'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the existing stack is empty, and the new node to be added is the first element,
    we need to make this node the top node of the element. Thus, `self.top` will point
    to this new node. See the following *Figure 5.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: Insertion of the data element “egg” into an empty stack'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the complete implementation of the `push` operation, which
    should be defined in the `Stack` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we create a new node and store the data in that. Then we
    check the position of the `top` pointer. If it is not null, that means the stack
    is not empty, and we add the new node, updating two pointers as shown in *Figure
    5.7*. In the `else` part, we make the `top` pointer point to the new node. Finally,
    we increase the size of the stack by incrementing the `self.size` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a stack of three data elements, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we created a stack of three elements – egg, ham, and spam.
    Next, we will discuss the `pop` operation in stack data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Pop operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important operation that is applied to the stack is the `pop` operation.
    In this operation, the topmost element of the stack is read, and then removed
    from the stack. The `pop` method returns the topmost element of the stack and
    returns `None` if the stack is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the `pop` operation on a stack, we do following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, check if the stack is empty. The `pop` operation is not allowed on an
    empty stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the stack is not empty, check whether the top node has its next attribute
    pointing to some other node. If so, it means the stack contains elements, and
    the topmost node is pointing to the next node in the stack. To apply the `pop`
    operation, we have to change the top pointer. The next node should be at the top.
    We do this by pointing `self.top` to `self.top.next`. See the following *Figure
    5.9* to understand this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17217_05_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: Workings of the pop operation on the stack'
  prefs: []
  type: TYPE_NORMAL
- en: 'When there is only one node in the stack, the stack will be empty after the
    `pop` operation. We have to change the top pointer to `None`. See the following
    *Figure 5.10*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Diagram, engineering drawing  Description automatically generated](img/B17217_05_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: The pop operation on a stack with one element'
  prefs: []
  type: TYPE_NORMAL
- en: Removing this node results in `self.top` pointing to `None`, as shown in *Figure
    5.10*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also decrement the size of the stack by `1` if the stack is not empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the code for the `pop` operation for the stack in Python, which should
    be defined in the `Stack` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, firstly, we check the position of the `top` pointer. If it
    is not null, it means the stack is not empty, and we can apply the `pop` operation
    such that if there is more than one data element in the stack, we move the `top`
    pointer to point to the next node (see *Figure 5.9*), and if that is the last
    node, we make the `top` pointer point to `None` (see *Figure 5.10*). We also decrease
    the size of the stack by decrementing the `self.size` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we have three data elements in a stack. We can use the following
    code to apply the `pop` operation to the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we popped off the top element from the stack of three elements
    – `egg`, `ham`, `spam`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss the `peek` operation used on stack data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Peek operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is another important operation that can be applied to stacks—the `peek`
    method. This method returns the top element from the stack without deleting it
    from the stack. The only difference between `peek` and `pop` is that the `peek`
    method just returns the topmost element; however, in the case of a `pop` method,
    the topmost element is returned, and that element is also deleted from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `peek` operation allows us to look at the top element without changing
    the stack. This operation is very straightforward. If there is a top element,
    return its data; otherwise, return `None` (thus, the behavior of `peek` matches
    that of `pop`). The implementation of the `peek` method is as follows (this should
    be defined in the `Stack` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above code, we first check the position of the `top` pointer using `self.top`.
    If it is not null, this means the stack is not empty, and we return the data value
    of the topmost node, otherwise, we print the message that the stack is empty.
    We can use the `peek` method to get the top element of the stack through the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As per our original example of the three data elements being added to the stack,
    if we use the `peek` method, we get the top element, `spam`, as an output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stacks are an important data structure with several real-world applications.
    To better understand the concept of the stack, we will discuss one of these applications:
    bracket matching utilizing stacks.'
  prefs: []
  type: TYPE_NORMAL
- en: Applications of stacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we know, array and linked list data structures can do whatever the stack
    or queue data structures (that we will discuss shortly) can do.
  prefs: []
  type: TYPE_NORMAL
- en: Despite this, these data structures are important because of their many applications.
    For example, in any application, it may be required to add or delete any element
    in a particular order. stack and queues can be used for this to avoid any potential
    bug in the program, perhaps accessing/deleting an element from the middle of the
    list (which can happen in the cases of arrays and linked lists).
  prefs: []
  type: TYPE_NORMAL
- en: Now let us look at an example bracket-matching application and see how we can
    use our stack to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Let us write a function `check_brackets` that will verify whether a given expression
    containing brackets—`( )`, `[ ]`, or `{ }`— is balanced or not, that is, whether
    the number of closing brackets matches the number of opening brackets. Stacks
    can be used for traversing a list of items in reverse order since they follow
    the **LILO** rule, which makes them a good choice for this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is for a separate `check_brackets` method defined outside
    the `Stack` class. This method will use the `Stack` class that we discussed in
    the previous section. The method takes an expression consisting of alphabetical
    characters and brackets as input and produces `True` or `False` as output for
    whether the given expression is valid or not, respectively. The code for the `check_brackets`
    method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The above function parses each character in the expression passed to it. If
    it gets an open bracket, it pushes it onto the stack. If it gets a closing bracket,
    it pops the top element off the stack and compares the two brackets to make sure
    their types match-`(` should match `)`, `[` should match `]`, and `{` should match
    `}`. If they don’t, we return `False`; otherwise, we continue parsing.
  prefs: []
  type: TYPE_NORMAL
- en: Once we reach the end of the expression, we need to do one last check. If the
    stack is empty, then it is fine and we can return `True`. But if the stack is
    not empty, then we have an opening bracket that does not have a matching closing
    bracket and we will return `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test the bracket-matcher with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the first of the three statements should match. When we run the code,
    we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the above sample three expressions, we can see that the first expression
    is valid, while the other two are not valid expressions. Hence, the output of
    the preceding code is `True`, `False`, and `False`.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the `push`, `pop`, and `peek` operations of the stack data structure
    have a time complexity of `O(1)` since the addition and deletion operations can
    be directly performed in constant time through the `top` pointer. The stack data
    structure is simple; however, it is used to implement many functionalities in
    real-world applications. For example, the back and forward buttons in web browsers
    are implemented using stacks. Stacks are also used to implement the undo and redo
    functionalities in word processors.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed the stack data structure and its implementations using arrays
    and linked lists. In the next section, we will discuss the queue data structure
    and the different operations that can be applied to queues.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important data structure is the queue, which is used to store data similarly
    to stacks and linked lists, with some constraints and in a specific order. The
    queue data structure is very similar to the regular queue you are accustomed to
    in real life. It is just like a line of people waiting to be served in sequential
    order at a shop. Queues are a fundamentally important concept to grasp since many
    other data structures are built on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A queue works as follows. The first person to join the queue usually gets served
    first, and everyone will be served in the order in which they joined the queue.
    The acronym **FIFO** best explains the concept of a queue. **FIFO** stands for
    **first in, first out**. When people are standing in a queue waiting for their
    turn to be served, service is only rendered at the front of the queue. Therefore,
    people are dequeued from the front of the queue and enqueued from the back where
    they wait their turn. The only time people exit the queue is when they have been
    served, which only occurs at the very front of the queue. Refer to the following
    diagram, where people are standing in the queue, and the person at the front will
    be served first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: Illustration of a queue'
  prefs: []
  type: TYPE_NORMAL
- en: To join the queue, participants must stand behind the last person in the queue.
    This is the only legal or permitted way the queue accepts new entrants. The length
    of the queue does not matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'A queue is a list of elements stored in sequence with the following constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: Data elements can only be inserted from one end, the rear end/tail of the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data elements can only be deleted from the other end, the front/head of the
    queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only data elements from the front of the queue can be read.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The operation to add an element to the queue is known as `enqueue`. Deleting
    an element from the queue uses the `dequeue` operation. Whenever an element is
    enqueued, the length or size of the queue increments by 1, and dequeuing an item
    reduces the number of elements in the queue by 1\.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this concept in the doubly linked list shown in *Figure 5.12*, in
    which we can add new elements to the tail/rear end and elements can only be deleted
    from the head/front end of the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: Queue implementation using the stack data structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reader is advised to not confuse the notation: the `enqueue` operation
    will be performed only at the **tail/rear** end and the `dequeue` operation will
    be performed from the **head/front** end. It should be fixed that one end will
    be used for `enqueue` operations and the other end will be used for `dequeue`
    operations; however, either end can be used for each of these operations. It is
    good in general practice to fix that we perform `enqueue` operations from the
    **rear** end and `dequeue` operations from the **front** end. To demonstrate these
    two operations, the following table shows the effects of adding and removing elements
    from a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Queue operation** | **Size** | **Contents** | **Operation results** |'
  prefs: []
  type: TYPE_TB
- en: '| `queue()` | 0 | `[]` | Queue object created, which is empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `enqueue- "packt"` | 1 | `[''packt'']` | One item, `packt`, is added to the
    queue. |'
  prefs: []
  type: TYPE_TB
- en: '| `enqueue "publishing"` | 2 | `[ ''packt'', ''publishing'']` | One more item,
    `publishing`, is added to the queue. |'
  prefs: []
  type: TYPE_TB
- en: '| `Size()` | 2 | `[ ''packt'', ''publishing'']` | Return the number of items
    in the queue, which is 2 in this example. |'
  prefs: []
  type: TYPE_TB
- en: '| `dequeue()` | 1 | `[''publishing'']` | The `packt` item is dequeued and returned.
    (This item was added first, so it is removed first.) |'
  prefs: []
  type: TYPE_TB
- en: '| `dequeue()` | 0 | `[]` | The `publishing` item is dequeued and returned.
    (This is the last item added, so it is returned last.) |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.2: Illustration of different operations on an example queue'
  prefs: []
  type: TYPE_NORMAL
- en: Queue data structures in Python have a built-in implementation, `queue.Queue`,
    and can also be implemented using the `deque` class from the `collections` module.
    Queue data structures can be implemented using various methods in Python, namely,
    (1) Python’s built-in list, (2) stacks, and (3) node-based linked lists. We will
    discuss them one by one in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Python’s list-based queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, in order to implement a queue based on Python’s `list` data structure,
    we create a `ListQueue` class, in which we declare and define the different functionalities
    of queue. In this method, we store the actual data in Python’s `list` data structure.
    The `ListQueue` class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the `__init__` initialization method, the `items` instance variable is set
    to `[]`, which means the queue is empty when created. The size of the queue is
    also set to `4` (as an example in this code), which is the maximum capacity for
    the number of elements that can be stored in the queue. Moreover, the initial
    position of the rear and front indices are also set to `0`. `enqueue` and `dequeue`
    are important methods in queues, and we will discuss them next.
  prefs: []
  type: TYPE_NORMAL
- en: The enqueue operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `enqueue` operation adds an item at the end of the queue. Consider the example
    of adding elements to the queue to understand the concept shown in *Figure 5.13*.
    We start with an empty list. Initially, we add an item `3` at index `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add an item `11` at index `1`, and move the rear pointer every time
    we add an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: Example of an enqueue operation on the queue'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement the enqueue operation, we use the `append` method of
    the `List` class to append items (or data) to the end of the queue. See the following
    code for the implementation of the `enqueue` method. This should be defined in
    the `ListQueue` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first check whether the queue is full by comparing the maximum capacity
    of the queue with the position of the `rear` index. Further, if there is space
    in the queue, we use the `append` method of the `List` class to add the data at
    the end of the queue and increase the rear pointer by `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a queue using the `ListQueue` class, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we add can a maximum of three data elements since we have
    set the maximum capacity of the queue to be `3`. After adding three elements,
    when we try to add another new element, we get a message that the queue is full.
  prefs: []
  type: TYPE_NORMAL
- en: The dequeue operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `dequeue` operation is used to read and delete items from the queue. This
    method returns the front item from the queue and deletes it. Consider the example
    of dequeuing elements from the queue shown in *Figure 5.14*. Here, we have a queue
    containing elements `{3, 11, 7, 1, 4, 2}`. In order to dequeue any element from
    this queue, the element inserted first will be removed first, so the item `3`
    is removed. When we dequeue any element from the queue, we also decrease the `rear`
    pointer by 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_14.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14\. Example of a dequeue operation on a queue
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the implementation of the `dequeue` method, which should be
    defined in the `ListQueue` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above code, we firstly check whether the queue is already empty by comparing
    the front and rear pointers. If both rear and front pointers are same, it means
    the queue is empty. If there are some elements in the queue, we use the `pop`
    method to dequeue an element. The Python `List` class has a method called `pop()`.
    The `pop` method does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Deletes the last item from the list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returns the deleted item from the list back to the user or code that called
    it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The item at the first position pointed to by the front variable is popped and
    saved in the `data` variable. We also decrease the rear variable by `1`, since
    one data item has been deleted from the queue. Finally, in the last line of the
    method, the data is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'To dequeue any element from an existing queue (say items `{20, 30, 40}`), we
    use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, when we dequeue an element from the queue, we get the element
    20, which was the first added.
  prefs: []
  type: TYPE_NORMAL
- en: The limitation of this approach to queue implementation is that the length of
    the queue is fixed, which may be not desirable for an efficient implementation
    of a queue. Now, let’s discuss the linked list-based implementation of queues.
  prefs: []
  type: TYPE_NORMAL
- en: Linked list based queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A queue data structure can also be implemented using any linked list, such as
    singly-linked or doubly-linked lists. We already discussed the implementation
    of singly or doubly linked lists in the previous *Chapter 4*, *Linked Lists*.
    We implement queues using linked lists that follow the **FIFO** property of the
    queue data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us discuss the implementation of a queue using a doubly-linked list. For
    this, we start with the implementation of the `node` class the same as the `node`
    we defined when we discussed doubly-linked lists in the previous *Chapter 4*,
    *Linked Lists*. Moreover, the `Queue` class is very similar to that of the doubly-linked
    list class. Here, we have `head` and `tail` pointers, where `tail` points to the
    end of the queue (the rear end) that will be used for adding new elements, and
    the `head` pointer points to the start of the queue (the front end) that will
    be used for dequeuing the elements from the queue. The implementation of the `Queue`
    class is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Initially, the `self.head` and `self.tail` pointers are set to `None` upon creation
    of an instance of the `Queue` class. To keep a count of the number of nodes in
    `Queue`, the `count` instance variable is also maintained here and initially set
    to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The enqueue operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Elements are added to a `Queue` object via the `enqueue` method. The data elements
    are added through nodes. The `enqueue` method code is very similar to the `append`
    operation of the doubly-linked list that we discussed in *Chapter 4,* *Linked
    Lists*.
  prefs: []
  type: TYPE_NORMAL
- en: The enqueue operation creates a node from the data passed to it and appends
    it to the `tail` of the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we check if the new node to be enqueued is the first node, and whether
    the queue is empty or not. If it is empty, the new node becomes the first node
    of the queue, as shown in *Figure 5.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: Illustration of enqueuing a new node in an empty queue'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the queue is not empty, the new node is appended to the rear end of the
    queue. In order to do this and enqueue an element to an existing queue, we append
    the node by updating three links: (1) the previous pointer of the new node should
    point to the tail of the queue, (2) the next pointer of the tail node should point
    to the new node, and (3) the tail pointer should be updated to the new node. All
    these links are shown in *Figure 5.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.16: Illustration of links to be updated for an enqueue operation in
    a queue'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enqueue` operation is implemented in the `Queue` class, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we first check whether the queue is empty or not. If `head`
    points to `None`, this means the queue is empty. If it is empty, the new node
    is made the first node of the queue, and we make both `self.head` and `self.tail`
    point to the newly created node. If the queue is not empty, we append the new
    node to the rear of the queue by updating the three links shown in *Figure 5.16*.
    Finally, the total count of elements in the queue is increased by the line `self.count
    += 1`.
  prefs: []
  type: TYPE_NORMAL
- en: The worst-case time complexity of an `enqueue` operation on the queue is `O(1)`,
    since any item can be appended directly through the `tail` pointer in constant
    time.
  prefs: []
  type: TYPE_NORMAL
- en: The dequeue operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The other operation that makes a doubly-linked list behave like a queue is
    the `dequeue` method. This method removes the node at the front of the queue,
    as shown in *Figure 5.17*. Here, we first check whether the dequeuing element
    is the last node in the queue, and if so, we will make the queue empty after the
    `dequeue` operation. If this is not the case, we dequeue the first element by
    updating the front/head pointer to the next node and the previous pointer of the
    new head to `None`, as shown in *Figure 5.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.17: Illustration of the dequeue operation on a queue'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the `dequeue` operation on a queue is very similar to
    deleting the first element from the given doubly-linked list, as the following
    code for the `dequeue` operation shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In order to dequeue any element from the queue, we firstly check the number
    of items in the queue using the `self.count` variable. If the `self.count` variable
    is equal to `1`, it means the dequeuing element is the last element, and we update
    the head and tail pointers to `None`.
  prefs: []
  type: TYPE_NORMAL
- en: If the queue has many nodes, then the head pointer is shifted to point to the
    next node after `self.head` by updating the two links shown in *Figure 5.17*.
    We also check whether there is an item left in the queue, and if not, then a message
    is printed that the queue is empty. Finally, the `self.count` variable is decremented
    by `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The worst-case time complexity of a dequeue operation in the queue is `O(1)`,
    since any item can be directly removed via the `head` pointer in constant time.
  prefs: []
  type: TYPE_NORMAL
- en: Stack-based queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A queue is a linear data structure in which enqueue operations are performed
    from one end and deletion (dequeue) operations are performed from the other end
    following the **FIFO** principle. There are two methods to implement queues using
    stacks:'
  prefs: []
  type: TYPE_NORMAL
- en: When the dequeue operation is costly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the enqueue operation is costly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Approach 1: When the dequeue operation is costly'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use two stacks for the implementation of the queue. In this approach, the
    enqueue operation is straightforward. A new element can be enqueued in the queue
    using the push operation on the first of the two stacks (in other words, Stack-1)
    used for the implementation of the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The enqueue operation is depicted in *Figure 5.18*, showing an example of enqueuing
    elements `{23, 13, 11}` to the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.18: Illustration of an enqueue operation in the queue using approach
    1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Further more, the dequeue operation can be implemented with two stacks (Stack-1
    and Stack-2) using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the elements are removed (popped off) from Stack-1, and then one by
    one all the elements are added (pushed) to Stack-2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The topmost data element will be popped off Stack-2 and will be returned as
    the desired element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the remaining elements are popped off Stack-2 one by one and then pushed
    again to Stack-1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s look at an example to help understand this concept. Let’s say we have
    three elements stored in the queue `{23, 13, 11}`, and now we want to dequeue
    an element from this queue. The complete process is shown in *Figure 5.19* following
    the above three steps. As you might notice, this implementation follows the **FIFO**
    property of queues and hence 23 is returned, as it was added first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.19: Illustration of a dequeue operation in the queue using approach
    1'
  prefs: []
  type: TYPE_NORMAL
- en: The worst-case time complexity of enqueue operations is `O(1)`, since any element
    can be added directly to the first stack, and the time complexity of the dequeue
    operation is `O(n)`, since all elements are accessed and transferred from Stack-1
    to Stack-2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Approach 2: When the enqueue operation is costly'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this method, the enqueue operation is quite similar to the dequeue operation
    of the previous approach we just discussed, and the dequeue operation is likewise
    similar to the previous enqueue operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement the enqueue operation, we follow the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Move all the elements from Stack-1 to Stack-2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the element we want to enqueue to Stack-2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move all the elements from Stack-2 to Stack-1 one by one. Pop the elements from
    Stack-2 and push them to Stack-1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take an example to understand this concept. Let’s say we want to enqueue
    three elements `{23, 13, 11}` in the queue one by one. We do this by following
    the above three steps, as shown in *Figure 5.20*, *Figure 5.21*, and *Figure 5.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.20: Enqueueing element 23 to an empty queue using approach 2'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.21: Enqueueing element 13 to the existing queue using approach 2'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.22: Enqueueing element 11 to the queue using approach 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dequeue operation can be directly implemented by applying a pop operation
    to Stack-1\. Let’s take an example to understand this. Assuming we have already
    enqueued three elements, and we want to apply the dequeue operation, we can simply
    pop the top element off the stack, as shown in *Figure 5.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.23: Illustration of a dequeue operation on a queue using approach
    2'
  prefs: []
  type: TYPE_NORMAL
- en: In this second approach, the time complexity for the enqueue operation is `O(n)`,
    and for the dequeue operation, it is `O(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we discuss the implementation of a queue using two stacks using approach-1,
    in which the dequeue operation is costly. In order to implement queues using two
    stacks, we initially set two stack instance variables to create an empty queue
    upon initialization. The stacks, in this case, are simply Python lists that allow
    us to call the `push` and `pop` methods on them, which allow us to get the functionality
    of the `enqueue` and `dequeue` operations. Here is the `Queue` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`Stack1` is only used to store elements that are added to the queue. No other
    operation can be performed on this stack.'
  prefs: []
  type: TYPE_NORMAL
- en: Enqueue operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `enqueue` method is used to add items to the queue. This method only receives
    the `data` that is to be appended to the queue. This data is then passed to the
    `append` method of `Stack1` in the `Queue` class. Further, the `append` method
    is used to mimic the `push` operation, which pushes elements to the top of the
    stack. The following code is the implementation of `enqueue` using the stack in
    Python, which should be defined in the `Queue` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To enqueue data onto `Stack1`, the following code does the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of `Stack1` on the queue is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will examine the implementation of the `dequeue` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Dequeue operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `dequeue` operation is used to delete the elements from the queue in the
    same order in which the items were added, according to the **FIFO** principle.
    New elements are added to the queue in `Stack1`. Further, we use another stack,
    that is, `Stack2`, to delete the elements from the queue. The delete (dequeue)
    operation will only be performed through `Stack2`. To better understand how `Stack2`
    can be used to delete the items from the queue, let us consider the following
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, assume that `Stack2` was filled with the elements **5**, **6**,
    and **7**, as shown in *Figure 5.24*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_24.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.24\. Example of Stack1 in a queue
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we check if the `Stack2` is empty or not. As it is empty at the start,
    we move all the elements delete from `Stack1` to `Stack2` using the `pop` operation
    on `Stack1` for all the element and then push them to `Stack2`. Now, `Stack1`
    becomes empty and `Stack2` has all the elements. We show this in *Figure 5.25*
    for more clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_05_25.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.25\. Demonstration of Stack1 and Stack2 in a queue
  prefs: []
  type: TYPE_NORMAL
- en: Now, if the `Stack` is not empty, in order to pop an element from this queue,
    we apply the `pop` operation to `Stack2`, and we get the element `5`, which is
    correct as it was added first and should be the first element to be popped off
    from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of the `dequeue` method for the queue, which should
    be defined in the `Queue` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if` statement first checks whether `Stack2` is empty. If it is not empty,
    we proceed to remove the element at the front of the queue using the `pop` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If `Stack2` is empty, all the elements of `Stack1` are moved to `Stack2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `while` loop will continue to be executed as long as there are elements
    in `Stack1`.
  prefs: []
  type: TYPE_NORMAL
- en: The `self.Stack1.pop()` statement will remove the last element added to `Stack1`
    and immediately pass the popped data to the `self.Stack2.append()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us consider some example code to understand the operations on the queue.
    We firstly use the `Queue` implementation to add three items to the queue, that
    is, `5`, `6`, and `7`. Next, we apply `dequeue` operations to remove items from
    the queue using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The enqueue and dequeue operations on the queue data structure using a stack
    with approach 1 have time complexities of `O(1)`, and `O(n)` respectively. The
    reason for this is that the enqueue operation is straightforward as a new element
    can be appended directly, whereas in the dequeue operation, all the n elements
    need to be accessed and moved to the other stack.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the linked list-based implementation is the most efficient since both
    the enqueue and dequeue operations can be performed in `O(1)` time and there is
    no constraint on the size of the queue. In the stack-based implementation of queues,
    one of the operations is costly, be it enqueue or dequeue.
  prefs: []
  type: TYPE_NORMAL
- en: Applications of queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Queues can be used to implement a variety of functionalities in many real computer-based
    applications. For instance, instead of providing each computer on a network with
    its own printer, a network of computers can be made to share one printer by queuing
    what each computer wants to print. When the printer is ready to print, it will
    pick one of the items (usually called jobs) in the queue to print out. It will
    print the command from the computer that has given the command first and will
    choose the following jobs in the order in which they were submitted by the different
    computers.
  prefs: []
  type: TYPE_NORMAL
- en: Operating systems also queue processes to be executed by the CPU. Let’s create
    an application that makes use of a queue to create a bare-bones media player.
  prefs: []
  type: TYPE_NORMAL
- en: Most music player software allows users to add songs to a playlist. Upon hitting
    the play button, all the songs in the main playlist are played one after the other.
    Sequential playing of the songs can be implemented with queues because the first
    song to be queued is the first song that is to be played. This aligns with the
    **FIFO** acronym. We will implement our own playlist queue to play songs in the
    **FIFO** manner.
  prefs: []
  type: TYPE_NORMAL
- en: Our media player queue will only allow for the addition of tracks and a way
    to play all the tracks in the queue. In a full-blown music player, threads would
    be used to improve how the queue is interacted with, while the music player continues
    to be used to select the next song to be played, paused, or even stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `track` class will simulate a musical track:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Each track holds a reference to the title of the song and also the length of
    the song. The length of the song is a random number between `5` and `10`. The
    `random` module in Python provides the `randint` function to enable us to generate
    random numbers. The class represents any MP3 track or file that contains music.
    The random length of a track is used to simulate the number of seconds it takes
    to play a track.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a few tracks and print out their lengths, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Your output may be different depending on the random length generated for the
    two tracks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create our queue using inheritance. We simply inherit from the `Queue`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To add tracks to the queue, an `add_track` method is created in the `MediaPlayerQueue`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The method passes a `track` object to the `enqueue` method of the queue `super`
    class. This will, in effect, create a `Node` using the `track` object (as the
    node’s data) and point either the tail if the queue is not empty, or both the
    head and tail if the queue is empty, to this new node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the tracks in the queue are played sequentially, from the first track
    added to the last (**FIFO**), then the `play` function has to loop through the
    elements in the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`self.count` keeps count of when a track is added to our queue and when tracks
    have been dequeued. If the queue is not empty, a call to the `dequeue` method
    will return the node (which houses the `track` object) at the front of the queue.
    The `print` statement then accesses the title of the track through the `data`
    attribute of the node. To further simulate the playing of a track, the `time.sleep()`
    method halts program execution till the number of seconds for the track has elapsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The media player queue is made up of nodes. When a track is added to the queue,
    the track is hidden in a newly created node and associated with the data attribute
    of the node. That explains why we access a node’s `track` object through the data
    property of the node returned by the call to `dequeue`.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that, instead of our `node` object just storing any data, it stores
    tracks in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take our music player for a spin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We create five track objects with random words as titles, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The output may be different from what you get on your machine due to the random
    length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, an instance of the `MediaPlayerQueue` class is created using the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The tracks will be added, and the output of the `play` function should print
    out the tracks being played in the same order in which we queued them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Upon execution of the program, it can be seen that the tracks are played in
    the order in which they were queued. When playing each track, the system also
    pauses for the number of seconds equal to the length of the track.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed two important data structures, namely, stacks
    and queues. We have seen how these data structures closely mimic stacks and queues
    in the real world. Concrete implementations, together with their varying types,
    were explored. We later applied the concepts of stacks and queues to write real-life
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: We will consider trees in the next chapter. The major operations on trees will
    be discussed, along with the different spheres of application of this data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following options is a true queue implementation using linked lists?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If, in the enqueue operation, new data elements are added at the start of the
    list, then the dequeue operation must be performed from the end.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If, in the enqueue operation, new data elements are added to the end of the
    list, then the enqueue operation must be performed from the start of the list.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Both of the above.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Assume a queue is implemented using a singly-linked list that has head and tail
    pointers. The enqueue operation is implemented at the head, and the dequeue operation
    is implemented at the tail of the queue. What will be the time complexity of the
    enqueue and dequeue operations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the minimum number of stacks required to implement a queue?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The enqueue and dequeue operations in a queue are implemented efficiently using
    an array. What will be the time complexity for both of these operations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we print the data elements of a queue data structure in reverse order?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1421249772551223062.png)'
  prefs: []
  type: TYPE_IMG
