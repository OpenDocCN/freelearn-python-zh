- en: Chapter 2. Working with Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn basic image conversion and manipulation techniques
    using the Python Imaging Library. The chapter ends with an exciting project where
    we create an image processing application.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn various image I/O operations for reading and writing images using the
    **Python Imaging Library** (PIL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the help of several examples and code snippets, perform some basic manipulations
    on the image, such as resizing, rotating/ flipping, cropping, pasting, and so
    on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write an image-processing application by making use of PIL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the QT library as a frontend (GUI) for this application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's get on with it!
  prefs: []
  type: TYPE_NORMAL
- en: Installation prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump in to the main chapter, it is necessary to install the following
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this book we will use Python Version 2.6, or to be more specific, Version
    2.6.4\. It can be downloaded from the following location: [http://python.org/download/releases/](http://python.org/download/releases/)'
  prefs: []
  type: TYPE_NORMAL
- en: Windows platform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For Windows, just download and install the platform-specific binary distribution
    of Python 2.6.4.
  prefs: []
  type: TYPE_NORMAL
- en: Other platforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For other platforms, such as Linux, Python is probably already installed on
    your machine. If the installed version is not 2.6, build and install it from the
    source distribution. If you are using a package manager on a Linux system, search
    for Python 2.6\. It is likely that you will find the Python distribution there.
    Then, for instance, Ubuntu users can install Python from the command prompt as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that for this, you must have administrative permission on the machine on
    which you are installing Python.
  prefs: []
  type: TYPE_NORMAL
- en: Python Imaging Library (PIL)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will learn image-processing techniques by making extensive use of the Python
    Imaging Library (PIL) throughout this chapter. As mentioned in [Chapter 1](ch01.html
    "Chapter 1. Python and Multimedia"), PIL is an open source library. You can download
    it from [http://www.pythonware.com/products/pil/](http://www.pythonware.com/products/pil/).
    Install the PIL Version 1.1.6 or later.
  prefs: []
  type: TYPE_NORMAL
- en: Windows platform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For Windows users, installation is straightforward use the binary distribution
    PIL 1.1.6 for Python 2.6.
  prefs: []
  type: TYPE_NORMAL
- en: Other platforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For other platforms, install PIL 1.1.6 from the source. Carefully review the
    README file in the source distribution for the platform-specific instructions.
    Libraries listed in the following table are required to be installed before installing
    PIL from the source. For some platforms like Linux, the libraries provided in
    the OS should work fine. However, if those do not work, install a pre-built "libraryName-devel"
    version of the library. For example, for JPEG support, the name will contain "jpeg-devel-",
    and something similar for the others. This is generally applicable to rpm-based
    distributions. For Linux flavors like Ubuntu, you can use the following command
    in a shell window.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, you should make sure that this installs Version 1.1.6 or later. Check
    PIL documentation for further platform-specific instructions. For Mac OSX, see
    if you can use `fink` to install these libraries. See [http://www.finkproject.org/](http://www.finkproject.org/)
    for more details. You can also check the website [http://pythonmac.org](http://pythonmac.org)
    or Darwin ports website [http://darwinports.com/](http://darwinports.com/) to
    see if a binary package installer is available. If such a pre-built version is
    not available for any library, install it from the source.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PIL prerequisites for installing PIL from source are listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Library | URL | Version | Installation options(a) or (b) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `libjpeg`(JPEG support) | [http://www.ijg.org/files](http://www.ijg.org/files)
    | 7 or 6a or 6b | (a) Pre-built version. For example:`jpeg-devel-7`Check if you
    can do:`sudo apt-install libjpeg` (works on some flavors of Linux)(b) Source tarball.
    For example: `jpegsrc.v7.tar.gz` |'
  prefs: []
  type: TYPE_TB
- en: '| `zib`(PNG support) | [http://www.gzip.org/zlib/](http://www.gzip.org/zlib/)
    | 1.2.3 or later | (a) Pre-built version. For example:`zlib-devel-1.2.3.`.(b)
    Install from the source. |'
  prefs: []
  type: TYPE_TB
- en: '| `freetype2`(OpenType /TrueType support) | [http://www.freetype.org](http://www.freetype.org)
    | 2.1.3 or later | (a) Pre-built version. For example:`freetype2-devel-2.1.3.`.(b)
    Install from the source. |'
  prefs: []
  type: TYPE_TB
- en: PyQt4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This package provides Python bindings for Qt libraries. We will use PyQt4 to
    generate GUI for the image-processing application that we will develop later in
    this chapter. The GPL version is available at: [http://www.riverbankcomputing.co.uk/software/pyqt/download](http://www.riverbankcomputing.co.uk/software/pyqt/download).'
  prefs: []
  type: TYPE_NORMAL
- en: Windows platform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Download and install the binary distribution pertaining to Python 2.6\. For
    example, the executable file's name could be 'PyQt-Py2.6-gpl-4.6.2-2.exe'. Other
    than Python, it includes everything needed for GUI development using PyQt.
  prefs: []
  type: TYPE_NORMAL
- en: Other platforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before building PyQt, you must install SIP Python binding generator. For further
    details, refer to the SIP homepage: [http://www.riverbankcomputing.com/software/sip/](http://www.riverbankcomputing.com/software/sip/).'
  prefs: []
  type: TYPE_NORMAL
- en: After installing SIP, download and install PyQt 4.6.2 or later, from the source
    tarball. For Linux/Unix source, the filename will start with `PyQt-x11-gpl-.`.
    and for Mac OS X, `PyQt-mac-gpl-..`. Linux users should also check if PyQt4 distribution
    is already available through the package manager.
  prefs: []
  type: TYPE_NORMAL
- en: Summary of installation prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Package | Download location | Version | Windows platform | Linux/Unix/OS
    X platforms |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Python | [http://python.org/download/releases/](http://python.org/download/releases/)
    | 2.6.4 (or any 2.6.x) | Install using binary distribution | (a) Install from
    binary; Also install additional developer packages (For example, with `python-devel`
    in the package name in the rpm systems) OR(b) Build and install from the source
    tarball.(c) MAC users can also check websites such as [http://darwinports.com/](http://darwinports.com/)
    or [http://pythonmac.org/](http://pythonmac.org/). |'
  prefs: []
  type: TYPE_TB
- en: '| PIL | [www.pythonware.com/products/pil/](http://www.pythonware.com/products/pil/)
    | 1.1.6 or later | Install PIL 1.1.6 (binary) for Python 2.6 | (a) Install prerequisites
    if needed. Refer to Table #1 and the README file in PIL source distribution.(b)
    Install PIL from source.(c) MAC users can also check websites like [http://darwinports.com/](http://darwinports.com/)
    or [http://pythonmac.org/](http://pythonmac.org/). |'
  prefs: []
  type: TYPE_TB
- en: '| PyQt4 | [http://www.riverbankcomputing.co.uk/software/pyqt/download](http://www.riverbankcomputing.co.uk/software/pyqt/download)
    | 4.6.2 or later | Install using binary pertaining to Python 2.6 | (a) First install
    SIP 4.9 or later.(b) Then install PyQt4. |'
  prefs: []
  type: TYPE_TB
- en: Reading and writing images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To manipulate an existing image, we must open it first for editing and we also
    require the ability to save the image in a suitable file format after making changes.
    The `Image` module in PIL provides methods to read and write images in the specified
    image file format. It supports a wide range of file formats.
  prefs: []
  type: TYPE_NORMAL
- en: To open an image, use `Image.open` method. Start the Python interpreter and
    write the following code. You should specify an appropriate path on your system
    as an argument to the `Image.open` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will open an image file by the name `image1.jpg`. If the file can't be
    opened, an `IOError` will be raised, otherwise, it returns an instance of class
    `Image`.
  prefs: []
  type: TYPE_NORMAL
- en: For saving image, use the `save` method of the `Image` class. Make sure you
    replace the following string with an appropriate `/path/to/your/image/file`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can view the image just saved, using the `show` method of `Image` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, it is essentially the same image as the input image, because we did not
    make any changes to the output image.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - image file converter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this basic information, let's build a simple image file converter. This
    utility will batch-process image files and save them in a user-specified file
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, download the file `ImageFileConverter.py` from the Packt website,
    [www.packtpub.com](http://www.packtpub.com). This file can be run from the command
    line as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `[arguments]` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--input_dir:` The directory path where the image files are located.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--input_format:` The format of the image files to be converted. For example,
    `jpg`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--output_dir:` The location where you want to save the converted images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--output_format:` The output image format. For example, `jpg, png, bmp`, and
    so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following screenshot shows the image conversion utility in action on Windows
    XP, that is, running image converter from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Here, it will batch-process all the `.jpg` images within `C:\PythonTest\images`
    and save them in `png` format in the directory `C:\PythonTest\images\OUTPUT_IMAGES`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action - image file converter](img/0165_2_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The file defines `class ImageConverter` . We will discuss the most important
    methods in this class.
  prefs: []
  type: TYPE_NORMAL
- en: '`def processArgs:` This method processes all the command-line arguments listed
    earlier. It makes use of Python''s built-in module `getopts` to process these
    arguments. Readers are advised to review the code in the file `ImageConverter.py`
    in the code bundle of this book for further details on how these arguments are
    processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def convertImage:` This is the workhorse method of the image-conversion utility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's review the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Our first task is to get a list of all the image files to be saved in a different
    format. This is achieved by using `glob` module in Python. Line 4 in the code
    snippet finds all the file path names that match the pattern specified by the
    local variable `fileType`. On line 5, we check whether the image file in `fileList`
    exists. This operation can be efficiently performed over the whole list using
    the built-in `filter` functionality in Python.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code block between lines 7 to 14 ensures that one or more images exist.
    If so, it will record the time before beginning the image conversion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next code block (lines 17-23) carries out the image file conversion. On
    line 18, we use `Image.open` to open the image file. Line 18 creates an `Image`
    object. Then the appropriate output path is derived and finally the output image
    is saved using the `save` method of the `Image` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this simple example, we learned how to open and save image files in a specified
    image format. We accomplished this by writing an image file converter that batch-processes
    a specified image file. We used PIL's `Image.open` and `Image.save` functionality
    along with Python's built-in modules such as `glob` and `filter`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will discuss other key aspects related to the image reading and writing.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an image from scratch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far we have seen how to open an existing image. What if we want to create
    our own image? As an example, it you want to create fancy text as an image, the
    functionality that we are going to discuss now comes in handy. Later in this book,
    we will learn how to use such an image containing some text to embed into another
    image. The basic syntax for creating a new image is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Where, `new` is the built-in method of class `Image. Image.new` takes three
    arguments, namely, `mode, size`, and `color`. The `mode` argument is a string
    that gives information about the number and names of image bands. Following are
    the most common values for mode argument: `L` (gray scale) and `RGB` (true color).
    The `size` is a `tuple` specifying dimensions of the image in pixels, whereas,
    `color` is an optional argument. It can be assigned an RGB value (a `3-tuple)`
    if it''s a multi-band image. If it is not specified, the image is filled with
    black color.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - creating a new image containing some text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As already stated, it is often useful to generate an image containing only some
    text or a common shape. Such an image can then be pasted onto another image at
    a desired angle and location. We will now create an image with text that reads,
    "Not really a fancy text!"
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a Python source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's analyze the code line by line. The first two lines import the necessary
    modules from PIL. The variable `txt` is the text we want to include in the image.
    On line 7, the new image is created using `Image.new`. Here we specify the `mode`
    and `size` arguments. The optional `color` argument is specified as a `tuple`
    with RGB values pertaining to the "dark green" color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ImageDraw` module in PIL provides graphics support for an `Image` object.
    The function `ImageDraw.Draw` takes an image object as an argument to create a
    `Draw` instance. In output code, it is called `imgDrawer`, as used on line 7\.
    This `Draw` instance enables drawing various things in the given image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On line 8, we call the text method of the Draw instance and supply position
    (a `tuple)` and the text (stored in the string `txt)` as arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the image can be viewed using `img.show()` call. You can optionally
    save the image using `Image.save` method. The following screenshot shows the resultant
    image.![Time for action - creating a new image containing some text](img/0165_2_2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just learned how to create an image from scratch. An empty image was created
    using the `Image.new` method. Then, we used the `ImageDraw` module in PIL to add
    text to this image.
  prefs: []
  type: TYPE_NORMAL
- en: Reading images from archive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the image is part of an archived container, for example, a TAR archive, we
    can use the `TarIO` module in PIL to open it and then call `Image.open` to pass
    this `TarIO` instance as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - reading images from archives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose there is an archive file `images.tar` containing image file `image1.jpg`.
    The following code snippet shows how to read `image1.jpg` from the tarball.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned how to read an image located in an archived container.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero add new features to the image file converter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modify the image conversion code so that it supports the following new functionality,
    which:'
  prefs: []
  type: TYPE_NORMAL
- en: Takes a ZIP file containing images as input
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates a TAR archive of the converted images
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Basic image manipulations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to open and save images, let's learn some basic techniques
    to manipulate images. PIL supports a variety of geometric manipulation operations,
    such as resizing an image, rotating it by an angle, flipping it top to bottom
    or left to right, and so on. It also facilitates operations such as cropping,
    cutting and pasting pieces of images, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Resizing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Changing the dimensions of an image is one of the most frequently used image
    manipulation operations. The image resizing is accomplished using `Image.resize`
    in PIL. The following line of code explains how it is achieved.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, `img` is an image (an instance of class `Image)` and the result of resizing
    operation is stored in `foo` (another instance of class `Image)`. The `size` argument
    is a `tuple` (width, `height)`. Note that the `size` is specified in pixels. Thus,
    resizing the image means modifying the number of pixels in the image. This is
    also known as **image re-sampling.** The `Image.resize` method also takes `filter`
    as an optional argument. A `filter` is an interpolation algorithm used while re-sampling
    the given image. It handles deletion or addition of pixels during re-sampling,
    when the resize operation is intended to make image smaller or larger in size
    respectively. There are four filters available. The resize filters in the increasing
    order of quality are `NEAREST, BILINEAR, BICUBIC`, and `ANTIALIAS`. The default
    filter option is `NEAREST`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - resizing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now resize images by modifying their pixel dimensions and applying various
    filters for re-sampling.
  prefs: []
  type: TYPE_NORMAL
- en: Download the file `ImageResizeExample.bmp` from the Packt website. We will use
    this as the reference file to create scaled images. The original dimensions of
    `ImageResizeExample.bmp` are `200 x 212` pixels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the following code in a file or in Python interpreter. Replace the `inPath`
    and `outPath` strings with the appropriate image path on your machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The image specified by the `inPath` will be resized and saved as the image specified
    by the `outPath`. Line 6 in the code snippet does the resizing job and finally
    we save the new image on line 9\. You can see how the resized image looks by calling
    `foo.show()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's now specify the `filter` argument. In the following code, on line 14,
    the `filterOpt` argument is specified in the `resize` method. The valid `filter`
    options are specified as values in the dictionary `filterDict`. The keys of `filterDict`
    are used as the filenames of the output images. The four images thus obtained
    are compared in the next illustration. You can clearly notice the difference between
    the `ANTIALIAS` image and the others (particularly, look at the flower petals
    in these images). When the processing time is not an issue, choose the `ANTIALIAS`
    filter option as it gives the best quality image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resized images with different filter options appear as follows. Clockwise
    from left, Image.NEAREST, Image.BILENEAR, Image.BICUBIC, and Image.ANTIALIAS:![Time
    for action - resizing](img/0165_2_3.jpg)![Time for action - resizing](img/0165_2_4.jpg)![Time
    for action - resizing](img/0165_2_5.jpg)![Time for action - resizing](img/0165_2_6.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `resize` functionality illustrated here, however, doesn't preserve the aspect
    ratio of the resulting image. The image will appear distorted if one dimension
    is stretched more or stretched less in comparison with the other dimension. PIL's
    `Image` module provides another built-in method to fix this. It will override
    the larger of the two dimensions, such that the aspect ratio of the image is maintained.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code will override the maximum pixel dimension value (width in this case)
    specified by the programmer and replace it with a value that maintains the aspect
    ratio of the image. In this case, we have an image with pixel dimensions (47,
    50). The resultant images are compared in the following illustration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It shows the comparison of output images for methods Image.thumbnail and Image.resize.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - resizing](img/0165_2_7.jpg)![Time for action - resizing](img/0165_2_8.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just learned how image resizing is done using PIL's `Image` module, by writing
    a few lines of code. We also learned different types of filters used in image
    resizing (re-sampling). And finally, we also saw how to resize an image while
    still keeping the aspect ratio intact (that is, without distortion), using the
    `Image.thumbnail` method.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like image resizing, rotating an image about its center is another commonly
    performed transformation. For example, in a composite image, one may need to rotate
    the text by certain degrees before embedding it in another image. For such needs,
    there are methods such as `rotate` and `transpose` available in PIL''s `Image`
    module. The basic syntax to rotate an image using `Image.rotate` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Where, the `angle` is provided in degrees and `filter`, the optional argument,
    is the image-re-sampling filter. The valid `filter` value can be `NEAREST, BILINEAR`,
    or `BICUBIC`. You can rotate the image using `Image.transpose` only for 90-, 180-,
    and 270-degree rotation angles.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - rotating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download the file `Rotate.png` from the Packt website. Alternatively, you can
    use any supported image file of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the following code in Python interpreter or in a Python file. As always,
    specify the appropriate path strings for `inPath` and `outPath` variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upon running this code, the output image, rotated by 45 degrees, is saved to
    the `outPath`. The filter option `Image.BICUBIC` ensures highest quality. The
    next illustration shows the original and the images rotated by 45 and 180 degrees
    respectively the original and rotated images.![Time for action - rotating](img/0165_2_9.jpg)![Time
    for action - rotating](img/0165_2_10.jpg)![Time for action - rotating](img/0165_2_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is another way to accomplish rotation for certain angles by using the
    `Image.transpose` functionality. The following code achieves a 270-degree rotation.
    Other valid options for rotation are `Image.ROTATE_90` and `Image.ROTATE_180`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we used `Image.rotate` to accomplish rotating an image
    by the desired angle. The image filter `Image.BICUBIC` was used to obtain better
    quality output image after rotation. We also saw how `Image.transpose` can be
    used for rotating the image by certain angles.
  prefs: []
  type: TYPE_NORMAL
- en: Flipping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple ways in PIL to flip an image horizontally or vertically.
    One way to achieve this is using the `Image.transpose` method. Another option
    is to use the functionality from the `ImageOps` module . This module makes the
    image-processing job even easier with some ready-made methods. However, note that
    the PIL documentation for Version 1.1.6 states that `ImageOps` is still an experimental
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - flipping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you are building a symmetric image using a bunch of basic shapes.
    To create such an image, an operation that can flip (or mirror) the image would
    come in handy. So let's see how image flipping can be accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: Write the following code in a Python source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this code, the image is flipped horizontally by calling the `transpose`
    method. To flip the image vertically, replace line 5 in the code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The following illustration shows the output of the preceding code when the image
    is flipped horizontally and vertically.![Time for action - flipping](img/0165_2_12.jpg)![Time
    for action - flipping](img/0165_2_13.jpg)![Time for action - flipping](img/0165_2_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The same effect can be achieved using the `ImageOps` module. To flip the image
    horizontally, use `ImageOps.mirror`, and to flip the image vertically, use `ImageOps.flip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the help of example, we learned how to flip an image horizontally or vertically
    using `Image.transpose` and also by using methods in class `ImageOps`. This operation
    will be applied later in this book for further image processing such as preparing
    composite images.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing screenshots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How do you capture the desktop screen or a part of it using Python? There is
    `ImageGrab` module in PIL. This simple line of code will capture the whole screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Where, `img` is an instance of class `Image`.
  prefs: []
  type: TYPE_NORMAL
- en: However, note that in PIL Version 1.1.6, the `ImageGrab` module supports screen
    grabbing only for Windows platform.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - capture screenshots at intervals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you are developing an application, where, after certain time interval,
    the program needs to automatically capture the whole screen or a part of the screen.
    Let's develop code that achieves this.
  prefs: []
  type: TYPE_NORMAL
- en: Write the following code in a Python source file. When the code is executed,
    it will capture part of the screen after every two seconds. The code will run
    for about three seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will now review the important aspects of this code. First, import the necessary
    modules. The `time.clock()` keeps track of the time spent. On line 11, a bounding
    box is defined. It is a `4-tuple` that defines the boundaries of a rectangular
    region. The elements in this `tuple` are specified in pixels. In PIL, the origin
    (0, 0) is defined in the top-left corner of an image. The next illustration is
    a representation of a bounding box for image cropping; see how left, upper and
    right, lower are specified as the ends of a diagonal of rectangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Example of a bounding box used for image cropping.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - capture screenshots at intervals](img/0165_02_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The `while` loop runs till the `time.clock()` reaches three seconds. Inside
    the loop, the part of the screen bounded within `bbox` is captured (see line 16)
    and then the image is saved on line 18\. The image name corresponds to the time
    at which it is taken.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `time.sleep(2)` call suspends the execution of the application for two seconds.
    This ensures that it grabs the screen every two seconds. The loop repeats until
    the given time is reached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this example, it will capture two screenshots, one when it enters the loop
    for the first time and the next after a two-second time interval. In the following
    illustration, the two images grabbed by the code are shown. Notice the time and
    console prints in these images.![Time for action - capture screenshots at intervals](img/0165_2_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding screenshot is taken at time 00:02:15 as shown dialog. The next
    screenshot is taken after 2 seconds, at wall clock time, 00:02:17.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - capture screenshots at intervals](img/0165_2_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, we wrote a simple application that captures the screen
    at regular time intervals. This helped us to learn how to grab a screen region
    using `ImageGrab`.
  prefs: []
  type: TYPE_NORMAL
- en: Cropping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous section, we learned how to grab a part of the screen with `ImageGrab`.
    Cropping is a very similar operation performed on an image. It allows you to modify
    a region within an image.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - cropping an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This simple code snippet crops an image and applies some changes on the cropped
    portion.
  prefs: []
  type: TYPE_NORMAL
- en: Download the file `Crop.png` from Packt website. The size of this image is `400
    x 400` pixels. You can also use your own image file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the following code in a Python source file. Modify the path of the image
    file to an appropriate path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will crop a region of the image bounded by `bbox`. The specification of
    the bounding box is identical to what we have seen in the *Capturing screenshots*
    section. The output of this example is shown in the following illustration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Original image (left) and its cropped region (right).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - cropping an image](img/0165_2_18.jpg)![Time for action
    - cropping an image](img/0165_2_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we used `Image.crop` functionality to crop a region
    within an image and save the resultant image. In the next section, we will apply
    this while pasting a region of an image onto another.
  prefs: []
  type: TYPE_NORMAL
- en: Pasting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pasting a copied or cut image onto another one is a commonly performed operation
    while processing images. Following is the simplest syntax to paste one image on
    another.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here `image` is an instance of class `Image` and `box` is a rectangular bounding
    box that defines the region of `img`, where the `image` will be pasted. The `box`
    argument can be a `4-tupleError: Reference source not found` or a `2-tuple`. If
    a `4-tuple` box is specified, the size of the image to be pasted must be same
    as the size of the region. Otherwise, PIL will throw an error with a message `ValueError:
    images do not match`. The `2-tuple` on the other hand, provides pixel coordinates
    of the upper-left corner of the region to be pasted.'
  prefs: []
  type: TYPE_NORMAL
- en: Now look at the following line of code. It is a copy operation on an image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The copy operation can be viewed as pasting the whole image onto a new image.
    This operation is useful when, for instance, you want to keep the original image
    unaltered and make alterations to the copy of the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for action - pasting: mirror the smiley face!'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider the example in earlier section where we cropped a region of an image.
    The cropped region contained a smiley face. Let's modify the original image so
    that it has a 'reflection' of the smiley face.
  prefs: []
  type: TYPE_NORMAL
- en: If not already, download the file `Crop.png` from the Packt website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write this code by replacing the file path with appropriate file path on your
    system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First we open an image and crop it to extract a region containing the smiley
    face. This was already done in section `Error: Reference source not found''Cropping''`.
    The only minor difference you will notice is the value of the tuple element `upper`.
    It is intentionally kept as 25 pixels from the top to make sure that the crop
    image has a size that can fit in the blank portion below the original smiley face.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The cropped image is then flipped horizontally with code on line 13.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we define a box, `bbox_2`, for pasting the cropped smiley face back on to
    the original image. Where should it be pasted? We intend to make a 'reflection'
    of the original smiley face. So the coordinate of the top-right corner of the
    pasted image should be greater than or equal to the bottom y coordinate of the
    cropped region, indicated by 'lower' variable (see line 8) . The bounding box
    is defined on line 15, as a `2-tuple` representing the upper-left coordinates
    of the smiley.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, on line 17, the paste operation is performed to paste the smiley on
    the original image. The resulting image is then saved with a different name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The original image and the output image after the paste operation is shown
    in the next illustration.![Time for action - pasting: mirror the smiley face!](img/0165_2_20.jpg)![Time
    for action - pasting: mirror the smiley face!](img/0165_2_21.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The illustration shows the comparison of original and resulting images after
    the paste operation.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using a combination of `Image.crop` and `Image.paste`, we accomplished cropping
    a region, making some modifications, and then pasting the region back on the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project: Thumbnail Maker'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take up a project now. We will apply some of the operations we learned
    in this chapter to create a simple Thumbnail Maker utility. This application will
    accept an image as an input and will create a resized image of that image. Although
    we are calling it a thumbnail maker, it is a multi-purpose utility that implements
    some basic image-processing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding further, make sure that you have installed all the packages
    discussed at the beginning of this chapter. The screenshot of the Thumbnail Maker
    dialog is show in the following illustration.
  prefs: []
  type: TYPE_NORMAL
- en: '![Project: Thumbnail Maker](img/0165_2_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Thumbnail Maker GUI has two components:'
  prefs: []
  type: TYPE_NORMAL
- en: The left panel is a 'control area', where you can specify certain image parameters
    along with options for input and output paths.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A graphics area on the right-hand side where you can view the generated image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In short, this is how it works:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The application takes an image file as an input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It accepts user input for image parameters such as dimensions in pixel, filter
    for re-sampling and rotation angle in degrees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user clicks the **OK** button in the dialog, the image is processed
    and saved at a location indicated by the user in the specified output image format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Time for action - play with Thumbnail Maker application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will run the Thumbnail Maker application as an end user. This warm-up
    exercise intends to give us a good understanding of how the application works.
    This, in turn, will help us develop/learn the involved code quickly. So get ready
    for action!
  prefs: []
  type: TYPE_NORMAL
- en: Download the files `ThumbnailMaker.py, ThumbnailMakeDialog.py`, and `Ui_ThumbnailMakerDialog.py`
    from Packt website. Place these files in some directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the command prompt, change to this directory location and type the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Thumbnail Maker dialog that pops up was shown in the earlier screenshot.
    Next, we will specify the input-output paths and various image parameters. You
    can open any image file of your choice. Here, the flower image shown in some previous
    sections will be used as an input image. To specify an input image, click on the
    small button with three dots …. It will open a file dialog. The following illustration
    shows the dialog with all the parameters specified.![Time for action - play with
    Thumbnail Maker application](img/0165_2_23.jpg)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If **Maintain Aspect Ratio** checkbox is checked, internally it will scale the
    image dimension so that the aspect ratio of the output image remains the same.
    When the **OK** button is clicked, the resultant image is saved at the location
    specified by the **Output Location** field and the saved image is displayed in
    the right-hand panel of the dialog. The following screenshot shows the dialog
    after clicking **OK** button.![Time for action - play with Thumbnail Maker application](img/0165_2_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now try modifying different parameters such as output image format or
    rotation angle and save the resulting image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See what happens when the **Maintain Aspect Ratio** checkbox is unchecked. The
    aspect ratio of the resulting image will not be preserved and the image may appear
    distorted if the width and height dimensions are not properly specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Experiment with different re-sampling filters; you can notice the difference
    between the quality of the resultant image and the earlier image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are certain limitations to this basic utility. It is required to specify
    reasonable values for all the parameters fields in the dialog. The program will
    print an error if any of the parameters is not specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We got ourselves familiar with the user interface of the thumbnail maker dialog
    and saw how it works for processing an image with different dimensions and quality.
    This knowledge will make it easier to understand the Thumbnail Maker code.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the UI code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Thumbnail Maker GUI is written using PyQt4 (Python bindings for Qt4 GUI
    framework). Detailed discussion on how the GUI is generated and how the GUI elements
    are connected to the main functions is beyond the scope of this book. However,
    we will cover certain main aspects of this GUI to get you going. The GUI-related
    code in this application can simply be used 'as-is' and if this is something that
    interests you, go ahead and experiment with it further! In this section, we will
    briefly discuss how the UI code is generated using PyQt4.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - generating the UI code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PyQt4 comes with an application called QT Designer. It is a GUI designer for
    QT-based applications and provides a quick way to develop a graphical user interface
    containing some basic widgets. With this, let's see how the Thumbnail Maker dialog
    looks in QT Designer and then run a command to generate Python source code from
    the `.ui` file.
  prefs: []
  type: TYPE_NORMAL
- en: Download the `thumbnailMaker.ui` file from the Packt website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the QT Designer application that comes with PyQt4 installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file `thumbnailMaker.ui` in QT Designer. Notice the red-colored borders
    around the UI elements in the dialog. These borders indicate a 'layout' in which
    the widgets are arranged. Without a layout in place, the UI elements may appear
    distorted when you run the application and, for instance, resize the dialog. Three
    types of `QLayouts` are used, namely `Horizontal, Vertical`, and `Grid layout`.![Time
    for action - generating the UI code](img/0165_2_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can add new UI elements, such as a `QCheckbox` or a `QLabel`, by dragging
    and dropping it from the 'Widget Box' of QT Designer. It is located in the left
    panel by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the field next to the label "Input file". In the right-hand panel of
    QT Designer, there is a Property Editor that displays the properties of the selected
    widget (in this case it's a `QLineEdit)`. This is shown in the following illustration.
    The Property Editor allows us to assign values to various attributes such as the
    `objectName, width`, and `height` of the widget, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Qt Designer shows the details of the selected widget in Property Editor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - generating the UI code](img/0165_2_26.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'QT designer saves the file with extension `.ui`. To convert this into Python
    source code, PyQt4 provides a conversion utility called `pyuic4`. On Windows XP,
    for standard Python installation, it is present at the following location `C:\Python26\Lib\site-packages\PyQt4\pyuic4.bat`.
    Add this path to your environment variable. Alternatively specify the whole path
    each time you want to convert `ui` file to Python source file. The conversion
    utility can be run from the command prompt as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script will generate `Ui_ThumbnailMakerDialog.py` with all the GUI elements
    defined. You can further review this file to understand how the UI elements are
    defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned how to autogenerate the Python source code defining UI elements of
    Thumbnail Maker Dialog from a Qt designer file.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero tweak UI of Thumbnail Maker dialog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify the `thumbnailMaker.ui` file in QT Designer and implement the following
    list of things in the Thumbnail Maker dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Change the color of all the line edits in the left panel to pale yellow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tweak the default file extension displayed in the **Output file Format** combobox
    such that the first option is `.png` instead of `.jpeg`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Double click on this combobox to edit it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add new option `.tiff` to the output format combobox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Align the **OK** and **Cancel** buttons to the right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the range of rotation angle 0 to 360 degrees instead of the current -180
    to +180 degrees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need to break layouts, move the spacer around, and recreate the layouts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After this, create `Ui_ThumbnailMakerDialog.py` by running the `pyuic4` script
    and then run the Thumbnail Maker application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Connecting the widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the earlier section, the Python source code representing UI was automatically
    generated using the `pyuic4` script. This, however, only has the widgets defined
    and placed in a nice layout. We need to teach these widgets what they should do
    when a certain event occurs. To do this, QT's slots and signals will be used.
    A signal is emitted when a particular GUI event occurs. For example, when the
    user clicks on the **OK** button, internally, a `clicked()` signal is emitted.
    A slot is a function that is called when a particular signal is emitted. Thus,
    in this example, it will call a specified method, whenever the **OK** button is
    clicked. See PyQt4 documentation for a complete list of available signals for
    various widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - connecting the widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will notice several different widgets in the dialog. For example, the field
    which accepts the input image path or the output directory path is a `QLineEdit`.
    The widget where image format is specified is a `QCombobox`. On similar lines,
    the **OK** and **Cancel** buttons are `QPushButton`. As an exercise, you can open
    up the `thumbnailMaker.ui` file and click on each element to see the associated
    QT class from the Property Editor.
  prefs: []
  type: TYPE_NORMAL
- en: With this, let's learn how the widgets are connected.
  prefs: []
  type: TYPE_NORMAL
- en: Open the file `ThumbnailMakerDialog.py`. The `_connect` method of class `ThumbnailMakerDialog`
    is copied. The method is called in the constructor of this class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`self._dialog` is an instance of class `Ui_ThumbnailMakerDialog. self.connect`
    is the inherited method of Qt class `QDialog`. Here, it takes the following arguments
    (QObject, `signal, callable)`, where `QObject` is any widget type (all inherit
    `QObject), signal` is the QT `SIGNAL` that tells us about what event occurred
    and `callable` is any method handling this event.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, consider the highlighted lines of the code snippet. They connect
    the **OK** button to a method that handles image processing. The first argument
    , `self._dialog.okPushButton` refers to the button widget defined in class `Ui_ThumbnailMakerDialog`.
    Referring to `QPushButton` documentation, you will find there is a "clicked()"
    signal that it can emit. The second argument `SIGNAL("clicked()")` tells Qt that
    we want to know when that button is clicked by the user. The third argument is
    the method `self._processImage` that gets called when this signal is emitted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, you can review the other connections in this method. Each of these
    connects a widget to a method of the class `ThumbnailMakerDialog`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We reviewed `ThumbnailMakerDialog._connect()` method to understand how the UI
    elements are connected to various internal methods. The previous two sections
    helped us learn some preliminary concepts of GUI programming using QT.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the image processing code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous sections were intended to get ourselves familiar with the application
    as an end user and to understand some basic aspects of the GUI elements in the
    application. With all necessary pieces together, let's focus our attention on
    the class that does all the main image processing in the application.
  prefs: []
  type: TYPE_NORMAL
- en: The class `ThumbnailMaker` handles the pure image processing code. It defines
    various methods to achieve this. For example, the class methods such as `_rotateImage,
    _makeThumbnail`, and `_resizeImage` manipulate the given image to accomplish rotation,
    thumbnail generation, and resizing respectively. This class accepts input from
    `ThumbnailMakerDialog`. Thus, no QT related UI code is required here. If you want
    to use some other GUI framework to process input, you can do that easily. Just
    make sure to implement the public API methods defined in class `ThumbnailMakerDialog`,
    as those are used by the `ThumbnailMaker` class.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - developing image processing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus, with `ThumbnailMakerDialog` at your disposal, you can develop your own
    code in scratch, in class `ThumbnailMaker`. Just make sure to implement the method
    `processImage` as this is the only method called by `ThumbnailMakerDialog`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's develop some important methods of class `ThumbnailMaker`.
  prefs: []
  type: TYPE_NORMAL
- en: Write the constructor for class `ThumbnailMaker`. It takes `dialog` as an argument.
    In the constructor, we only initialize `self._dialog`, which is an instance of
    class `ThumbnailMakerDialog`. Here is the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, write the `processImage` method in class `ThumbnailMaker`. The code is
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: You can download the file `ThumbnailMaker.py` from Packt website. The
    code written is from this file. The only difference is that some code comments
    are removed here.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On line 2, it gets the full path of the input image file. Note that it relies
    on `self._dialog` to provide this information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then the image file is opened the usual way. On line 4, it checks a flag that
    decides whether or not to process the image by maintaining the aspect ratio. Accordingly,
    `_makeThumbnail` or `_resizeImage` methods are called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On line 10, it rotates the image resized earlier, using the `_rotateImage` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, on line 15, the processed image is saved at a path obtained from the
    `getOutImagePath` method of class `ThumbnailMakerDialog`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now write the `_makeThumbnail` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First a copy of the original image is made. We will manipulate this copy and
    the method will return it for further processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then the necessary parameters such as the image dimension and filter for re-sampling
    are obtained from `self._dialog` and `_getImageFilter` respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally the thumbnail is created on line 5 and then method returns this image
    instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have already discussed how to resize and rotate image. The related code is
    straightforward to write and the readers are suggested to write it as an exercise.
    You will need to review the code from file `ThumbnailMakerDialog.py` for getting
    appropriate parameters. Write remaining routines namely, `_resizeImage, _rotateImage`
    and `_getImageFilter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once all methods are in place, run the code from the command line as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should show our application dialog. Play around with it to make sure everything
    works!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we completed an exciting project. Several things learned
    in this chapter, such as image I/O, resizing, and so on, were applied in the project.
    We developed a GUI application where some basic image manipulation features, such
    as creating thumbnails, were implemented. This project also helped us gain some
    insight into various aspects of GUI programming using QT.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero enhance the ThumbnailMaker application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Want to do something more with the Thumbnail Maker. Here you go! As you will
    add more features to this application, the first thing you would need to do is
    to change its name at least from the caption of the dialog that pops up! Edit
    the `thumbnailMaker.ui` file in QT designer, change the name to something like
    "Image Processor", and recreate the corresponding `.py` file. Next, add the following
    features to this application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't want to deal with any UI code, that is fine too! You can write
    a class similar to `ThumbnailMakerDialog`. Do the input argument processing in
    your own way. All that class `ThumbnailMaker` requires is implementation of certain
    public methods in this new class, to get various input parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Accept output filename from the user. Currently, it gives the same name as the
    input file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the .ui file. You would need to break the layouts before adding a QLineEdit
    and its QLabel and then recreate the layouts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If there is a previously created output image file in the output directory,
    clicking **OK** would simply overwrite that file. Add a checkbox reading, "Overwrite
    existing file (if any)". If the checkbox in deselected, it should pop up a warning
    dialog and exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the latter part, there is a commented out code block in ThumbnailMakerDialog._processImage.
    Just enable the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a feature that can add specified text in the lower-left corner of the output
    image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an image with this text, and use the combination of crop and paste to
    achieve desired results. For user input, you will need to add a new `QLineEdit`
    for accepting text input and then connect signals with a callable method in `ThumbnailMakerDialog._connect`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot in this chapter about basic image manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we covered image input-output operations that enable reading and
    writing of images, and creation of images from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the help of numerous examples and code snippets, we learned several image
    manipulation operations. Some of them are:'
  prefs: []
  type: TYPE_NORMAL
- en: How to resize an image with or without maintaining aspect ratio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating or flipping an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cropping an image, manipulating it using techniques learned earlier in the chapter,
    and then pasting it on the original image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an image with a text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We developed a small application that captures a region of your screen at regular
    time intervals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created an interesting project implementing some image processing functionality
    learned in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this basic image manipulation knowledge, we are ready to learn how to add
    some cool effects to an image. In the next chapter, we will see how to enhance
    an image.
  prefs: []
  type: TYPE_NORMAL
