- en: '*Chapter 12*: Applying GOF Design Patterns – Part 1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at the concept of design patterns in Python 3
    and its various categories, along with examples of how they can be applied while
    developing software using Python.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of design patterns originated from the book Design Patterns Elements
    of Reusable Object-Oriented Software by Erich Gamma, Richard Helm, Ralph Johnson,
    and John Vlissides, Addison-Wesley, which was written in C++. This concept was
    later extended to other o**bject-oriented programming** (**OOP**) languages.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at how these design patterns can be applied
    in Python using our core example of *ABC Megamart*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring behavioral design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should understand some important behavioral
    design patterns and how they can be implemented in various applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples in this chapter are available in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter12](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: An overview of design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every programming language has its elements uniquely designed and communicated
    to others. Design patterns give a structured and well-designed approach to developing
    software or applications in Python. In Python, every element is an object. Design
    patterns express how we are going to sequence or structure these objects to perform
    various operations. This allows them to become reusable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design patterns are divided into three categories – behavioral, structural,
    and creational. In this chapter, we will cover behavioral design patterns and
    look at three in particular, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The chain of responsibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More than 20 different design patterns are available in Python and covering
    all of them would require a book of its own. Therefore, we will only focus on
    some of the most interesting design patterns in this chapter and the next. With
    that, let’s explore some behavioral design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring behavioral design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, behavioral design patterns deal with the behavior of objects
    and how they talk to each other. In this section, we will learn about the elements
    of the chain of responsibility, command, and strategy design patterns, which belong
    to the behavioral design pattern category, and understand them by applying them
    to *ABC Megamart*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the chain of responsibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The chain of responsibility is a design pattern where the responsibility of
    the actions that can be performed by objects are transferred from one object to
    another, similar to a chain of events or actions. To explain this further and
    to implement this design pattern, we need the following elements to be developed
    in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parent handler**: A base class that defines a base function that specifies
    how a sequence of actions should be handled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Child handlers**: One or more subclasses that overwrite the base function
    from the base class to perform the respective action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exception handler**: A default handler that performs a specific action in
    case of exceptions. It also overwrites the base function from the base class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Requestor**: A function or method that calls the child handlers to initiate
    a chain of responsibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at the chain of responsibility with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will be calculating tax by state and generating an invoice
    for the New York and California branches of *ABC Megamart*. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the design pattern further, let’s create a parent handler class
    named `InvoiceHandler`. In this class, we will initiate a `next_action` variable
    to handle the next action in the chain and define a `handle` method to handle
    the requested action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create a supporting class to support the actions that we are
    going to perform in this example. Here, we want to calculate tax for a state based
    on the request and generate an invoice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `InputState` class has two attributes for the list of acceptable values
    for the states of New York and California.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create another class that adds a header to the invoice, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create a class for the child handler that has a method for generating
    an invoice, calculating New York’s state-specific tax for a product, and overwriting
    the `handle` method from the `InvoiceHandler` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will create a class for the child handler that has a method for generating
    an invoice, calculating California’s state-specific tax for a product, and overwriting
    the `handle` method from the `InvoiceHandler` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s define a class that will handle exceptions such as scenarios where
    the request does not invoke one of the child handler’s methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create a requestor function that instantiates one of the child handler
    subclasses and initiates a chain of responsibility that transfers from one action
    to another:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, we defined the requestor to set the next action for
    `NYCHandler` to `CAHandler` and the next action for `CAHandler` to be the exception
    handler. Let’s test this design pattern by calling the `invoice_requestor` function
    with the input state’s name; that is, `CA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code returns the invoice for the state of California since we
    provided the input as `CC` instead of `NY`. If `NY` was provided as input, the
    design pattern would have invoked `NYHandler`. However, since CA was provided,
    the next-in-the-chain and relevant `CAHandler` is invoked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If `invoice_requestor` is provided with `NY` as the input state name instead,
    it should call `NYHandler`, not `CAHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code returns the `NYHandler` class’s invoice and not the `CAHandler`
    class’s invoice, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As the final part of the request, let’s call `ExceptionHandler` by providing
    an input state that is neither `NY` nor `CA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code returns the following output by invoking the action from
    `ExceptionHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s connect the elements of this design pattern with its corresponding objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Chain of responsibility classes ](img/Figure_12.1_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Chain of responsibility classes
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at the chain of responsibility design pattern. Now,
    let’s look at the command design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the command design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will look at the next design pattern of interest: the command
    design pattern. The command design pattern can be used to create a sequence for
    executing commands and reverting to a previous state if a command is executed
    by mistake. Similar to the chain of responsibility pattern, the command design
    pattern is also created by defining multiple elements that can execute an action
    and revert the action that’s performed by an object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To explain this further and to implement this design pattern, we need to develop
    the following elements in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parent command**: This is a base class that defines the base functions for
    one or more commands that need to be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Child commands**: Child commands specify one or more actions that are inherited
    from the parent command class and overwritten at the individual child command
    level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Executor**: This is a base class for executing the child commands. It provides
    a method to execute the action and a method to revoke the action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sub-executors**: These inherit executors and overwrite the methods to execute
    while also revoking the actions that are performed by the child commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Requestor**: The requestor is a class that requests the executors to execute
    commands and revert to a previous state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tester**: This class tests if the design pattern is working as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s look at this design pattern in action. To understand this design
    pattern, we’ll go back to *ABC Megamart* and calculate the selling price for a
    product, as well as apply a discount to the selling price. The command pattern
    can help us design billing in such a way that we can either sell at the actual
    selling price or apply a discount. Whenever a discount is applied by mistake,
    we can revert it. Similarly, whenever a discount is not applied, we can reapply
    it. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating the `Billing` class. This is going to be the parent
    command and it will have an attribute named `sales`. This is a dictionary object.
    There will be two abstract methods – one to apply a discount and another to remove
    the discount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create the first child command class, `DiscountedBilling`, which
    will overwrite the `apply_discount` method from its parent class, `Billing`. Applying
    the `Discount` method will take in the sales dictionary object from the `Billing`
    class and calculate the discounted price, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create the next child command class, `ActualBilling`, which will
    remove the discount. – That is, it will calculate the selling price without a
    discount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create the base class for the executor. This will have two methods:
    `exec_discount` and `revoke_discount`. The first is an abstract method for executing
    the command that applies the discount. And the second is an abstract method for
    executing the command that revokes the discount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s define a child class named `ExecuteDiscountedBilling` that inherits
    from the `ExecuteBilling` class. This will overwrite the `exec_discount` and `revoke_discount`
    methods from its superclass. We will call the `apply_discount` method from the
    `DiscountedBilling` class within the `exec_discount` method of this child class.
    We will also set the `ActualBilling` command class from the `ExecuteActualBilling`
    class within the `revoke_discount` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s define a child class named `ExecuteActualBilling` that inherits
    from the `ExecuteBilling` class. This will overwrite the `exec_discount` and `revoke_discount`
    methods from its superclass. We will call the `remove_discount` method from the
    `ActualBilling` class within the `exec_discount` method of this child class. We
    will also set the `DiscountedBilling` command class from the `ExecuteDiscountedBilling`
    class within the `revoke_discount` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will define the requestor class, `RequestAction`, which will request
    the commands to be executed and reverted as required. We will also define three
    methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `reset` method, which will set or reset the command
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `runcalc` method, which will execute the discount calculation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `revert` method, which will revert to the previous action by revoking the
    discount calculation:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must create the final class in this design pattern to test that
    the command design pattern works as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we defined an object instance of the `Billing` class,
    followed by the instances that can be discounted and the actual `ExecuteBilling`
    subclasses. We also created an instance of the `RequestAction` requestor class.
    After that, we sequenced a set of operations to run the discount calculation,
    then the `reset` command, followed by rerunning the calculation to remove the
    discount. This will revert the previous command and thus reapply the discount
    before reverting the previous command, which will, in turn, remove the discount.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s call the `Tester` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s connect the elements of this design pattern with its corresponding
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Command design pattern classes ](img/Figure_12.2_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Command design pattern classes
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at the concept of the command design pattern. Now,
    let’s look at the strategy design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at the final design pattern under the category
    of behavioral design patterns that we will be covering in this chapter. Let’s
    look at the elements of the strategy pattern, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Domain**: A domain or base class defines all the base methods and attributes
    required for Python objects to perform a sequence of operations. This class also
    makes decisions concerning the operation that’s performed within the class according
    to the strategy method defined in the strategy classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategies**: These are one or more independent classes that define one specific
    strategy within its strategy method. The same strategy method name will be used
    in each of the strategy classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tester**: A tester function calls the domain class and executes the strategy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand how the strategy design pattern is implemented, we’ll look at
    various billing counters that we covered in [*Chapter 8*](B13426_08_Final_PG_epub.xhtml#_idTextAnchor107).
    There are various billing counters in *ABC Megamart*, including a vegetable counter,
    a less than 10 item counter, an electronics counter, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will define a vegetable counter and an electronics counter
    as strategy classes. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we will define a domain class named `SuperMarket` with methods
    that do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize attributes
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Display details about the items in the cart
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to a specific counter
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is what the code for this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will define methods that do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scan the bar codes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the bill details
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the tax details
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The operations for calculating the bill and printing the invoice are also defined
    in the `SuperMarket` class. Refer to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final method within the `SuperMarket` class is the `pipeline_template`
    method, which creates a pipeline for running the sequence of methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, we have called the strategy method to change the strategy that’s
    performed by the `SuperMarket` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s define a simple strategy class for the vegetable counter, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s also create a simple strategy class for the electronic counter, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we must define a tester function to test the strategy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s test the strategy for the vegetable counter by running the pipeline and
    providing `VegeCounter` as the strategy value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output for the `VegeCounter` strategy is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s test the strategy for the electronics counter by running the pipeline
    and providing `ElectronicsCounter` as the strategy value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output for the `ElectronicsCounter` strategy is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s connect the elements of this design pattern with its corresponding
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Strategy pattern with classes ](img/Figure_12.3_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Strategy pattern with classes
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have learned about the strategy design pattern. Now, let’s summarize
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about behavioral design patterns by applying some
    of them in Python 3\. In particular, we implemented the chain of responsibility,
    command, and strategy patterns and understood each of their elements.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the other chapters in this book, this chapter has been split into
    two parts – this chapter explained design patterns and focused on metaprogramming
    and its impact on Python code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue looking at the concept of design patterns
    by covering examples of structural and creational design patterns.
  prefs: []
  type: TYPE_NORMAL
