<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;A More Complex Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. A More Complex Application</h1></div></div></div><p>Web applications commonly provide a set of features such as user authentication and data storage. As we know from the previous chapter, App Engine provides the services and tools needed to implement such features and the best way to learn how to use them is by writing a web application and seeing the platform in action.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Further details of the webapp2 framework</li><li class="listitem" style="list-style-type: disc">How to authenticate users</li><li class="listitem" style="list-style-type: disc">Storing data on Google Cloud Datastore</li><li class="listitem" style="list-style-type: disc">Building HTML pages using templates</li><li class="listitem" style="list-style-type: disc">Serving static files</li></ul></div><div class="section" title="Experimenting on the Notes application"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Experimenting on the Notes application</h1></div></div></div><p>To better<a id="id119" class="indexterm"/> explore App Engine and Cloud Platform capabilities, we need a real-world application to experiment on; something that's not trivial to write, with a reasonable list of requirements so that it can fit in this book. A good candidate is a note-taking application; we will name it Notes.</p><p>Notes enable the users to add, remove, and modify a list of notes; a note has a title and a body of text. Users can only see their personal notes, so they must authenticate before using the application.</p><p>The main page of the application will show the list of notes for logged-in users and a form to add new ones.</p><p>The code from the <code class="literal">helloworld</code> example in the previous chapter is a good starting point. We can simply change the name of the root folder and the <code class="literal">application</code> field in the <code class="literal">app.yaml</code> file to match the new name we chose for the application, or we can start a new project from scratch named <code class="literal">notes</code>.</p></div></div>
<div class="section" title="Authenticating users"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Authenticating users</h1></div></div></div><p>The first<a id="id120" class="indexterm"/> requirement for our Notes application is showing the home page only to users who are logged in and redirect others to the login form; the <span class="strong"><strong>users</strong></span> service provided by App Engine is exactly what we need and adding it to our <code class="literal">MainHandler</code> class is quite simple:</p><div class="informalexample"><pre class="programlisting">import webapp2

from google.appengine.api import users

class MainHandler(webapp2.RequestHandler):
    def get(self):
        user = users.get_current_user()
        if user is not None:
            self.response.write('Hello Notes!')
        else:
        login_url = users.create_login_url(self.request.uri)
        self.redirect(login_url)
app = webapp2.WSGIApplication([
    ('/', MainHandler)
], debug=True)</pre></div><p>The <code class="literal">user</code> package we import on the second line of the previous code provides access to users' service functionalities. Inside the <code class="literal">get()</code> method of the <code class="literal">MainHandler</code> class, we first check whether the user visiting the page has logged in or not. If they have, the <code class="literal">get_current_user()</code> method returns an instance of the <code class="literal">user</code> class provided<a id="id121" class="indexterm"/> by App Engine and representing an authenticated user; otherwise, it returns <code class="literal">None</code> as output. If the user is valid, we provide the response as we did before; otherwise, we redirect them to the Google login form. The URL of the login form is returned using the <code class="literal">create_login_url()</code> method, and we call it, passing as a parameter the URL we want to redirect users to after a successful authentication. In this case, we want to redirect users to the same URL they are visiting, provided by webapp2 in the <code class="literal">self.request.uri</code> property. The webapp2 framework also provides handlers with a <code class="literal">redirect()</code> method<a id="id122" class="indexterm"/> we can use to conveniently set the right status and location properties of the response object so that the client browsers will be redirected to the login page.</p></div>
<div class="section" title="HTML templates with Jinja2"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>HTML templates with Jinja2</h1></div></div></div><p>Web<a id="id123" class="indexterm"/> applications provide rich and complex HTML <a id="id124" class="indexterm"/>user interfaces, and Notes is no exception but, so far, response objects in our applications contained just small pieces of text. We could include HTML tags as strings in our Python modules and write them in the response body but we can imagine how easily it could become messy and hard to maintain the code. We need to completely separate the Python code from HTML pages and that's exactly<a id="id125" class="indexterm"/> what a template engine does. A<a id="id126" class="indexterm"/> template is a piece of HTML code living in its own file and possibly containing additional, special tags; with the help of a template engine, from the Python script, we can load this file, properly parse special tags, if any, and return valid HTML code in the response body. App Engine includes in the Python runtime a well-known template engine: the Jinja2 library.</p><p>To make the Jinja2 library available to our application, we need to add this code to the <code class="literal">app.yaml</code> file under the <code class="literal">libraries</code> section:</p><div class="informalexample"><pre class="programlisting">libraries:
- name: webapp2
  version: "2.5.2"
- name: jinja2
  version: latest</pre></div><p>We can put the HTML code for the main page in a file called <code class="literal">main.html</code> inside the application root. We start with a very simple page:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Notes&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class="container"&gt;

    &lt;h1&gt;Welcome to Notes!&lt;/h1&gt;

    &lt;p&gt;
      Hello, &lt;b&gt;{{user}}&lt;/b&gt; - &lt;a href="{{logout_url}}"&gt;Logout&lt;/a&gt;
    &lt;/p&gt;

  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>Most of the content is static, which means that it will be rendered as standard HTML as we see it but there is a part that is dynamic and whose content depend on which data will be passed at runtime <a id="id127" class="indexterm"/>to the rendering process. This data is commonly referred to as <span class="strong"><strong>template context</strong></span>.</p><p>What has to be dynamic is the username of the current user and the link used to log out from the application. The HTML code contains two special elements written in the Jinja2 template syntax, <code class="literal">{{user}}</code> and <code class="literal">{{logout_url}}</code>, that will be substituted before the final output occurs.</p><p>Back<a id="id128" class="indexterm"/> to the Python script; we need to add the code to<a id="id129" class="indexterm"/> initialize the template engine before the <code class="literal">MainHandler</code> class definition:</p><div class="informalexample"><pre class="programlisting">import os
import jinja2

jinja_env = jinja2.Environment(
    loader=jinja2.FileSystemLoader(os.path.dirname(__file__)))</pre></div><p>The environment instance stores engine configuration and global objects, and it's used to load templates instances; in our case, instances are loaded from HTML files on the filesystem in the same directory as the Python script.</p><p>To load and render our template, we add the following code to the <code class="literal">MainHandler.get()</code> method:</p><div class="informalexample"><pre class="programlisting">class MainHandler(webapp2.RequestHandler):
    def get(self):
        user = users.get_current_user()
        if user is not None:
            logout_url = users.create_logout_url(self.request.uri)
            template_context = {
                'user': user.nickname(),
                'logout_url': logout_url,
            }
            template = jinja_env.get_template('main.html')
               self.response.out.write(
                template.render(template_context))
        else:
            login_url = users.create_login_url(self.request.uri)
            self.redirect(login_url)</pre></div><p>Similar to<a id="id130" class="indexterm"/> how we get the login URL, the <code class="literal">create_logout_url()</code> method provided by the user service returns the absolute URI to the logout procedure that we assign to the <code class="literal">logout_url</code> variable.</p><p>We then create the <code class="literal">template_context</code> dictionary that contains the context values we want to pass to the template engine for the rendering process. We assign the nickname of the current user to the <code class="literal">user</code> key in the dictionary and the logout URL string to the <code class="literal">logout_url</code> key.</p><p>The <code class="literal">get_template()</code> method<a id="id131" class="indexterm"/> from the <code class="literal">jinja_env</code> instance takes the name of the file that contains the HTML code and returns a Jinja2 template object. To obtain the final output, we call the <code class="literal">render()</code> method on the <code class="literal">template</code> object passing in the <code class="literal">template_context</code> dictionary whose values will be accessed, specifying their respective keys in the HTML file with the template syntax elements <code class="literal">{{user}}</code> and <code class="literal">{{logout_url}}</code>.</p><p>This<a id="id132" class="indexterm"/> is the<a id="id133" class="indexterm"/> result of the template rendering:</p><div class="mediaobject"><img src="graphics/8194OS_02_01.jpg" alt="HTML templates with Jinja2"/></div></div>
<div class="section" title="Handling forms"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Handling forms</h1></div></div></div><p>The main page <a id="id134" class="indexterm"/>of the application is supposed to list all the notes that belong to the current user but there isn't any way to create such notes at the moment. We need to display a web form on the main page so that users can submit details and create a note.</p><p>To display<a id="id135" class="indexterm"/> a form to collect data and create notes, we put the following HTML code right below the username and the logout link in the <code class="literal">main.html</code> template file:</p><div class="informalexample"><pre class="programlisting">{% if note_title %}
&lt;p&gt;Title: {{note_title}}&lt;/p&gt;
&lt;p&gt;Content: {{note_content}}&lt;/p&gt;
{% endif %}

&lt;h4&gt;Add a new note&lt;/h4&gt;
&lt;form action="" method="post"&gt;
  &lt;div class="form-group"&gt;
    &lt;label for="title"&gt;Title:&lt;/label&gt;
    &lt;input type="text" id="title" name="title" /&gt;
  &lt;/div&gt;
  &lt;div class="form-group"&gt;
      &lt;label for="content"&gt;Content:&lt;/label&gt;
      &lt;textarea id="content" name="content"&gt;&lt;/textarea&gt;
  &lt;/div&gt;
  &lt;div class="form-group"&gt;
      &lt;button type="submit"&gt;Save note&lt;/button&gt;
  &lt;/div&gt;
&lt;/form&gt;</pre></div><p>Before showing the form, a message is displayed only when the template context contains a variable named <code class="literal">note_title</code>. To do this, we use an <code class="literal">if</code> statement, executed between the <code class="literal">{% if note_title %}</code> and <code class="literal">{% endif %}</code> delimiters; similar delimiters are used to perform <code class="literal">for</code> loops or assign values inside a template.</p><p>The <code class="literal">action</code> property<a id="id136" class="indexterm"/> of the <code class="literal">form</code> tag is empty; this means that upon form submission, the browser will perform a <code class="literal">POST</code> request to the same URL, which in this case is the home page URL. As our WSGI application maps the home page to the <code class="literal">MainHandler</code> class, we need to add a method to this class so that it can handle <code class="literal">POST</code> requests:</p><div class="informalexample"><pre class="programlisting">class MainHandler(webapp2.RequestHandler):
    def get(self):
        user = users.get_current_user()
        if user is not None:
            logout_url = users.create_logout_url(self.request.uri)
            template_context = {
                'user': user.nickname(),
                'logout_url': logout_url,
            }
            template = jinja_env.get_template('main.html')
            self.response.out.write(
                template.render(template_context))
        else:
            login_url = users.create_login_url(self.request.uri)
            self.redirect(login_url)

    def post(self):
        user = users.get_current_user()
        if user is None:
            self.error(401)

        logout_url = users.create_logout_url(self.request.uri)
        template_context = {
            'user': user.nickname(),
            'logout_url': logout_url,
            'note_title': self.request.get('title'),
            'note_content': self.request.get('content'),
        }
        template = jinja_env.get_template('main.html')
        self.response.out.write(
            template.render(template_context))</pre></div><p>When the <a id="id137" class="indexterm"/>form is submitted, the handler is invoked and the <code class="literal">post()</code> method is called. We first check whether a valid user is logged in; if not, we raise an <span class="strong"><strong>HTTP 401: Unauthorized</strong></span> error without serving any content in the response body. Since the HTML template is the same served by the <code class="literal">get()</code> method, we still need to add the logout URL and the user name to the context. In this case, we also store the data coming from the HTML form in the context. To access the form data, we call the <code class="literal">get()</code> method on the <code class="literal">self.request</code> object. The last three lines are boilerplate code to load and render the home page template. We can move this code in a separate method to avoid duplication:</p><div class="informalexample"><pre class="programlisting">def _render_template(self, template_name, context=None):
    if context is None:
        context = {}
    template = jinja_env.get_template(template_name)
    return template.render(context)</pre></div><p>In the handler class, we will then use something like this to output the template rendering result:</p><div class="informalexample"><pre class="programlisting">self.response.out.write(
    self._render_template('main.html', template_context))</pre></div><p>We can try to submit the form and check whether the note title and content are actually displayed above the form.</p></div>
<div class="section" title="Persisting data in Datastore"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Persisting data in Datastore</h1></div></div></div><p>Even if <a id="id138" class="indexterm"/>users can log in and submit a note, our application <a id="id139" class="indexterm"/>isn't very useful until notes are stored somewhere. Google Cloud Datastore is the perfect place to store our notes. As part of App Engine's infrastructure, it takes care of data distribution and replication, so all we have to <a id="id140" class="indexterm"/>do is define store and retrieve our entities using the Python <span class="strong"><strong>NDB </strong></span>(<span class="strong"><strong>Next DB</strong></span>)<span class="strong"><strong> Datastore API</strong></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>There are currently two APIs available in the Python runtime to interact with Datastore: the<a id="id141" class="indexterm"/> <span class="strong"><strong>DB Datastore API</strong></span>, also known as <code class="literal">ext.db</code>, and the NDB Datastore API. Even if both the APIs store exactly the same data in Datastore, in this book, we will only use NDB; it is more recent, provides more features, and its API is slightly more robust.</p></div></div><p>An entity has one or more properties that in turn have a name and a type; each entity has a unique key that identifies it, and instead of storing different data in different tables as in a relational database, every entity in Datastore is categorized by a kind. In the Python world, a kind is determined by its model class that we need to define in our application.</p><div class="section" title="Defining the models"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Defining the models</h2></div></div></div><p>To <a id="id142" class="indexterm"/>represent a kind, Datastore models must derive from the <code class="literal">ndb.Model</code> class<a id="id143" class="indexterm"/> provided by the NDB API. We define our models in a Python module called <code class="literal">models.py</code> that contains the following code:</p><div class="informalexample"><pre class="programlisting">from google.appengine.ext import ndb

class Note(ndb.Model):
    title = ndb.StringProperty()
    content = ndb.TextProperty(required=True)
    date_created = ndb.DateTimeProperty(auto_now_add=True)</pre></div><p>The <code class="literal">Note</code> class has a property named <code class="literal">title</code> that contains small text (up to 500 characters), another one named <code class="literal">content</code> that contains text of unlimited length, and a property named <code class="literal">date_created</code> that contains a date and a time. Entities of this kind must contain at least a value for the <code class="literal">user</code> and <code class="literal">content</code> properties, and if not provided, the <code class="literal">date_created</code> property value will store the date and time at the moment the entity was created. We can now add new entities of the type <code class="literal">Note</code> class to the Datastore when users submit the form in the main page of the Notes application. In the <code class="literal">main.py</code> module, we first need to import the <code class="literal">Note</code> class from the <code class="literal">models</code> module:</p><div class="informalexample"><pre class="programlisting">from models import Note</pre></div><p>Then, we modify the <code class="literal">post()</code> method as follows:</p><div class="informalexample"><pre class="programlisting">def post(self):
    user = users.get_current_user()
    if user is None:
        self.error(401)

    note = Note(title=self.request.get('title'),
                content=self.request.get('content'))
    note.put()
        
    logout_url = users.create_logout_url(self.request.uri)
    template_context = {
        'user': user.nickname(),
        'logout_url': logout_url,
    }
    self.response.out.write(
        self._render_template('main.html', template_context))</pre></div><p>From <a id="id144" class="indexterm"/>now on, each time a user submits the form in the main page, an<a id="id145" class="indexterm"/> instance of the <code class="literal">Note</code> class is created and an entity is persisted in the Datastore right after the <code class="literal">put()</code> method is called. As we have not modified the <code class="literal">template_context</code> dictionary, the storing process won't do anything apparently. To verify that data is actually stored, we can use the local Development Console by opening the browser at <code class="literal">http://localhost:8000</code> and checking out Datastore Viewer.</p></div><div class="section" title="Basic querying"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Basic querying</h2></div></div></div><p>An entity <a id="id146" class="indexterm"/>can optionally specify another entity as its <span class="strong"><strong>parent</strong></span> and an <a id="id147" class="indexterm"/>entity <a id="id148" class="indexterm"/>without a parent is a <span class="strong"><strong>root entity</strong></span>; entities in Datastore form a hierarchically structured space similar to the directory structure in <a id="id149" class="indexterm"/>a filesystem. An entity together with all its descendants form an <span class="strong"><strong>entity group</strong></span> and <a id="id150" class="indexterm"/>the key of the common ancestor is defined as the <span class="strong"><strong>parent key</strong></span>.</p><p>It's important to understand entities' relationship because of the intrinsic distributed nature of the Datastore. Without digging too much into the details, what we have to know is that queries across multiple entity groups cannot guarantee consistent results and the result of such queries can sometimes fail to reflect recent changes to the data.</p><p>We have an <a id="id151" class="indexterm"/>alternative though; to get strongly consistent results, we can perform a so-called <span class="strong"><strong>ancestor query</strong></span>, which is a query that limits the results to a particular entity group. To use ancestor queries in our code, the first thing to do is add a parent to our note entities when we create the model instance:</p><div class="informalexample"><pre class="programlisting">note = Note(parent=ndb.Key("User", user.nickname()),
            title=self.request.get('title'),
            content=self.request.get('content'))
note.put()</pre></div><p>As every note belongs to the user who creates it, we can use the same logic to structure our data; we use the currently logged-in user as the parent key for an entity group that contains all the notes belonging to that user. This is why we specify the <code class="literal">parent</code> keyword when calling<a id="id152" class="indexterm"/> the <code class="literal">Note</code> constructor in the previous code. To obtain the key of the currently logged-in user, we use the <code class="literal">ndb.Key</code> class constructor, passing in the kind and the identifier of the corresponding entity.</p><p>What we need to do now is retrieve our notes from Datastore and show them to our users. As we will use ancestor queries, before proceeding, we add a utility method to the <code class="literal">Note</code> model class:</p><div class="informalexample"><pre class="programlisting">class Note(ndb.Model):
    title = ndb.StringProperty()
    content = ndb.TextProperty(required=True)
    date_created = ndb.DateTimeProperty(auto_now_add=True)

    @classmethod
    def owner_query(cls, parent_key):
        return cls.query(ancestor=parent_key).order(
            -cls.date_created)</pre></div><p>The <code class="literal">owner_query()</code> method returns a query object already filtered and containing the group<a id="id153" class="indexterm"/> entities for the parent key specified with the <code class="literal">parent_key</code> function parameter.</p><p>To load all notes belonging to the current user, we then write the following:</p><div class="informalexample"><pre class="programlisting">user = users.get_current_user()
ancestor_key = ndb.Key("User", user.nickname())
qry = Note.owner_query(ancestor_key)
notes = qry.fetch()</pre></div><p>As we want to show the notes in the main page in the case of the <code class="literal">GET</code> and <code class="literal">POST</code> requests, we can load the entities inside the <code class="literal">_render_template()</code> method, which is called by the handler in both cases:</p><div class="informalexample"><pre class="programlisting">def _render_template(self, template_name, context=None):
    if context is None:
        context = {}

    user = users.get_current_user()
    ancestor_key = ndb.Key("User", user.nickname())
    qry = Note.owner_query(ancestor_key)
    context['notes'] = qry.fetch()

    template = jinja_env.get_template(template_name)
    return template.render(context)</pre></div><p>We add the list of the notes as a value for the <code class="literal">notes</code> key in the <code class="literal">context</code> dictionary so that we can <a id="id154" class="indexterm"/>use them in the HTML template by writing the following right below the form:</p><div class="informalexample"><pre class="programlisting">{% for note in notes %}
&lt;div class="note"&gt;
  &lt;h4&gt;{{ note.title }}&lt;/h4&gt;
  &lt;p class="note-content"&gt;{{ note.content }}&lt;/p&gt;
&lt;/div&gt;
{% endfor %}</pre></div><p>A <code class="literal">div</code> element will be printed out for each note in the query result and nothing will be printed out if the query returned an empty list. Even if the <code class="literal">title</code> property is optional for entities of the kind Note, we can safely access it. If it's not present, an empty string will be returned.</p></div><div class="section" title="Transactions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Transactions</h2></div></div></div><p>It's very <a id="id155" class="indexterm"/>common for web applications to define and use Datastore models<a id="id156" class="indexterm"/> that depend on each other so that when we update an entity, we will likely need to update dependent entities as well. However, what happens if, during a series of Datastore operations, some of them fail? In such cases, we can encapsulate these operations in a transaction so that either all of them succeed or all of them fail.</p><p>To see a use case for transactions, we add a small feature to our Note model: a checklist. A checklist is a list of items that provide a Boolean property that determines their checked state. We first need to define a Datastore model for a single checklist item:</p><div class="informalexample"><pre class="programlisting">class CheckListItem(ndb.Model):
    title = ndb.StringProperty()
    checked = ndb.BooleanProperty(default=False)</pre></div><p>The entity has<a id="id157" class="indexterm"/> two properties, the <code class="literal">title</code> property for the string that will be displayed<a id="id158" class="indexterm"/> and the <code class="literal">checked</code> property to store whether the item is checked or not.</p><p>We then add a property to the <code class="literal">Node</code> model class referencing item entities:</p><div class="informalexample"><pre class="programlisting">class Note(ndb.Model):
    title = ndb.StringProperty()
    content = ndb.TextProperty(required=True)
    date_created = ndb.DateTimeProperty(auto_now_add=True)
    checklist_items = ndb.KeyProperty("CheckListItem",
                                      repeated=True)

    @classmethod
    def owner_query(cls, parent_key):
        return cls.query(ancestor=parent_key).order(
            -cls.date_created)</pre></div><p>The <code class="literal">checklist_items</code> property<a id="id159" class="indexterm"/> stores key values of the <code class="literal">CheckListItem</code> kind; the <code class="literal">repeated=True</code> parameter is needed to define that the property can hold more than one value.</p><p>Users<a id="id160" class="indexterm"/> can create checklist items for a note filling the creation<a id="id161" class="indexterm"/> form with a comma-separated list of values, so we add the following to the HTML template:</p><div class="informalexample"><pre class="programlisting">  &lt;form action="" method="post"&gt;
    &lt;div class="form-group"&gt;
      &lt;label for="title"&gt;Title:&lt;/label&gt;
      &lt;input type="text" id="title" name="title"/&gt;
    &lt;/div&gt;
    &lt;div class="form-group"&gt;
        &lt;label for="content"&gt;Content:&lt;/label&gt;
        &lt;textarea id="content" name="content"&gt;&lt;/textarea&gt;
    &lt;/div&gt;
    &lt;div class="form-group"&gt;
        &lt;label for="checklist_items"&gt;Checklist items:&lt;/label&gt;
        &lt;input type="text" id="checklist_items" name="checklist_items" placeholder="comma,separated,values"/&gt;
    &lt;/div&gt;
    &lt;div class="form-group"&gt;
        &lt;button type="submit"&gt;Save note&lt;/button&gt;
    &lt;/div&gt;
  &lt;/form&gt;</pre></div><p>Now, we have to handle the comma-separated list in the <code class="literal">MainHandler</code> class:</p><div class="informalexample"><pre class="programlisting">note = Note(parent=ndb.Key("User", user.nickname()),
            title=self.request.get('title'),
            content=self.request.get('content'))
note.put()

item_titles = self.request.get('checklist_items').split(',')
for item_title in item_titles:
    item = CheckListItem(parent=note.key, title=item_title)
    item.put()
    note.checklist_items.append(item.key)

note.put()</pre></div><p>We first retrieve the comma-separated values representing checklist items from the request. Then, for each of them, we create a <code class="literal">CheckListItem</code> instance. Until a model instance is not persisted, Datastore does not assign any key to it. So, we need to first store each item by calling the <code class="literal">put()</code> method before accessing the <code class="literal">key</code> property and retrieving a <code class="literal">Key</code> instance for that entity. Once we have a valid key, we append it to the list of items of the <code class="literal">Note</code> instance. We pass the key of the note as parent for the items so that all these entities will be<a id="id162" class="indexterm"/> part of the same entity group. The last step is to call <a id="id163" class="indexterm"/>the <code class="literal">put()</code> method and update the Node entity and store the new data for the <code class="literal">checklist_items</code> property.</p><p>Now what happens if the <code class="literal">note.put()</code> method fails? We have a bunch of entities of <code class="literal">CheckListItem</code> type that are not tied to any note, and this is a consistency problem. Transactions can help us refactor the creation of a note so that it can either succeed or fail, without leaving behind any dangling data. We encapsulate the creation of note objects in a separate <code class="literal">_create_node()</code> method in the handler class:</p><div class="informalexample"><pre class="programlisting">@ndb.transactional
def _create_note(self, user):
    note = Note(parent=ndb.Key("User", user.nickname()),
                title=self.request.get('title'),
                content=self.request.get('content'))
    note.put()

    item_titles = self.request.get('checklist_items').split(',')
    for item_title in item_titles:
        item = CheckListItem(parent=note.key, title=item_title)
        item.put()
        note.checklist_items.append(item.key)

    note.put()</pre></div><p>The <code class="literal">@ndb.transactional</code> decorator is all the Python code we need. Datastore will then ensure that any operation in the decorated method happens within a transaction. In this way, either we create a note entity along with all the checklist items entities or we get an error without touching the underlying data. To complete the code, we have to call the <code class="literal">_create_node()</code> method inside the <code class="literal">post()</code> method:</p><div class="informalexample"><pre class="programlisting">def post(self):
    user = users.get_current_user()
    if user is None:
        self.error(401)

    self._create_note(user)

    logout_url = users.create_logout_url(self.request.uri)
    template_context = {
        'user': user.nickname(),
        'logout_url': logout_url,
    }
    self.response.out.write(
        self._render_template('main.html', template_context))</pre></div><p>To show the list of items in a checklist for our notes, we must add the code needed in the HTML template:</p><div class="informalexample"><pre class="programlisting">{% for note in notes %}
&lt;div class="note"&gt;
  &lt;h4&gt;{{ note.title }}&lt;/h4&gt;
  &lt;p class="note-content"&gt;{{ note.content }}&lt;/p&gt;
  {% if note.checklist_items %}
  &lt;ul&gt;
    {% for item in note.checklist_items %}
    &lt;li class="{%if item.get().checked%}checked{%endif%}"&gt;{{item.get().title}}&lt;/li&gt;
    {% endfor %}
  &lt;/ul&gt;
  {% endif %}
&lt;/div&gt;
{% endfor %}</pre></div><p>We add <a id="id164" class="indexterm"/>an unordered list if the <code class="literal">checklist_items</code> property <a id="id165" class="indexterm"/>is not empty. We then iterate the list of items, adding a <code class="literal">class</code> attribute containing the <code class="literal">checked</code> parameter whenever an item has its <code class="literal">checked</code> property set to the <code class="literal">true</code> value: later in this chapter, we'll learn how to add a <span class="strong"><strong>CSS (Cascading Style Sheets)</strong></span> rule <a id="id166" class="indexterm"/>so that when this class is present, the item is shown with a horizontal line through its center.</p></div></div>
<div class="section" title="Using static files"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Using static files</h1></div></div></div><p>Usually <a id="id167" class="indexterm"/>web applications make use of CSS and JavaScript resources to provide a better user experience. For efficiency reasons, such content is not dynamically served by the WSGI application and are delivered by App Engine as static files instead.</p><p>We know from the previous chapter that App Engine provides two types of handlers, script handlers and static file handlers. We add a static file handler to our <code class="literal">app.yaml</code> configuration file like this:</p><div class="informalexample"><pre class="programlisting">handlers:
- url: /static
  static_dir: static

- url: .*
  script: main.app</pre></div><p>The syntax is almost the same as for script handlers. We specify a URL to map as a regular <a id="id168" class="indexterm"/>expression but instead of providing a Python script to handle requests, we specify a filesystem path relative to the application root where the files and directories that need to be served as static resources are located.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>We are now going to provide a minimal style for our HTML pages by manually coding some CSS rules. While it is acceptable for the scope of the book to get our hands dirty learning how to build a custom design from scratch, in the real world, we <a id="id169" class="indexterm"/>might prefer to use frontend frameworks such as<a id="id170" class="indexterm"/> Bootstrap (<a class="ulink" href="http://getbootstrap.com/">http://getbootstrap.com/</a>) or Foundation (<a class="ulink" href="http://foundation.zurb.com/">http://foundation.zurb.com/</a>) to easily provide state-of-the-art aesthetics, cross-browser capabilities, and responsive layouts for mobile devices.</p></div></div><p>To provide a CSS for our application, we then create the <code class="literal">static/css</code> folder into our application root:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mkdir -p static/css</strong></span>
</pre></div><p>This folder should contain a file called <code class="literal">notes.css</code> that will contain the style sheet  for our application:</p><div class="informalexample"><pre class="programlisting">body {
    font-family: "helvetica", sans-serif;
    background: #e8e8e8;
    color: rgba(39,65,90,.9);
    text-align: center;
}

div.container {
    width: 600px;
    display: inline-block;
}</pre></div><p>The first part is for global layout elements; we will put the form and the notes one below another in a centered container. We then style the form:</p><div class="informalexample"><pre class="programlisting">form {
    background: white;
    padding-bottom: 0.5em;
    margin-bottom: 30px;
}
h4,legend {
    margin-bottom: 10px;
    font-size: 21px;
    font-weight: 400;
}</pre></div><p>The form <a id="id171" class="indexterm"/>will be contained in a white box and the legend will look like a note title. Form elements will be styled as follows:</p><div class="informalexample"><pre class="programlisting">   div.form-group {
    margin-bottom: 1em;
}

label {
    display: inline-block;
    width: 120px;
    text-align: right;
    padding-right: 15px;
}

input, textarea {
    width: 250px;
    height: 35px;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    border: 1px solid #999;
    font-size: 14px;
    border-radius: 4px;
    padding: 6px;
}

textarea {
    vertical-align: top;
    height: 5em;
    resize: vertical;
}</pre></div><p>We then proceed with styling the white boxes that contain the Notes data:</p><div class="informalexample"><pre class="programlisting">div.note {
    background: white;
    vertical-align: baseline;
    display: block;
    margin: 0 auto 30px auto;
}

legend, div.note &gt; h4 {
    padding: 18px 0 15px;
    margin: 0 0 10px;
    background: #00a1ff;
    color: white;
}</pre></div><p>The last part of the style sheet is dedicated to notes checklists. We provide a style for unordered lists <a id="id172" class="indexterm"/>contained in <code class="literal">div</code> elements with a <code class="literal">note</code> class and a style for list items in checked state:</p><div class="informalexample"><pre class="programlisting">div.note &gt; ul {
    margin: 0;
    padding: 0;
    list-style: none;
    border-top: 2px solid #e7f2f0;
}

div.note &gt; ul &gt; li {
    font-size: 21px;
    padding: 18px 0 18px 18px;
    border-bottom: 2px solid #e7f2f0;
    text-align: left;
}
div.note-content {
    text-align: left;
    padding: 0.5em;
}

.checked {
    text-decoration: line-through;
}</pre></div><p>To use the style sheet, we add this in our HTML template, inside the <code class="literal">&lt;meta&gt;</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;link rel="stylesheet" type="text/css" href="static/css/notes.css"&gt;</pre></div><p>This is how the application should appear once the style sheet is applied:</p><div class="mediaobject"><img src="graphics/8194OS_02_02.jpg" alt="Using static files"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Summary</h1></div></div></div><p>Thanks to App Engine, we have already implemented a rich set of features with a relatively small effort so far.</p><p>In this chapter, we have discovered some more details about the webapp2 framework and its capabilities, implementing a nontrivial request handler. We have learned how to use the App Engine users service to provide users authentication. We have delved into some fundamental details of Datastore and now we know how to structure data in grouped entities and how to effectively retrieve data with ancestor queries. In addition, we have created an HTML user interface with the help of the Jinja2 template library, learning how to serve static content such as CSS files.</p><p>In the next chapter, we will keep on adding more and more features to the Notes application, learning how to store uploaded files on Google Cloud Storage, manipulate images, and deal with long operations and scheduled tasks. We will also make the application capable of sending and receiving e-mails.</p></div></body></html>