<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building RESTful APIs</h1>
                </header>
            
            <article>
                
<p><strong>Representational State Transfer</strong> (<strong>REST</strong>) is an architectural style that is used to implement web services. It was defined by Roy Fielding in his PhD dissertation in 2000. REST aims to implement a standard for uniform and predefined operations between systems. These systems can be client browsers, mobile applications, servers running parallel worker processes—you name it. By using HTTP methods, REST is platform- and programming-language-agnostic, and decouples the client and the server for easier development. This is typically used in web <strong>single-page applications</strong> (<strong>SPAs</strong>) that need to pull or update user information on the server. REST is also used to provide outside developers with a common interface to access user data. For example, Facebook and Twitter use REST in their application program interface, or API.</p>
<div class="packt_tip">You can take a look at <span>Roy Fielding's </span><span>original dissertation on REST at </span><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a>.</div>
<p>In this chapter, you will learn about the following topics:</p>
<ul>
<li>The HTTP protocol: requests, responses, methods, headers, and the URI format</li>
<li>How to build a REST service</li>
<li>How to secure a REST service using JWT</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is REST?</h1>
                </header>
            
            <article>
                
<p><span>Before getting into the details of REST, </span>and since it is a style for communication between systems, let's first have a quick dive into the actual protocol that it uses, on which this whole book is based.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP</h1>
                </header>
            
            <article>
                
<p>The <strong>Hypertext Transfer Protocol</strong> (<strong>HTTP</strong>) is a request–response protocol that belongs to layer 7 (the application layer). This layer interacts with the application itself. Some other protocols that belong to layer 7 are the <strong>Simple Mail Transfer protoco</strong><span>l</span> (<strong>SMTP</strong>), <strong>Network File System</strong> (<strong>NFS</strong>), and the <strong>File Transfer Protocol</strong> (<strong>FTP</strong>), to name a few.</p>
<p>HTTP was designed to be used by clients (user agents) to request resources from a server. These resources can be HTML files or any other content, such as JSON, XML, or media files. These requests for resources are identified by the network using <strong>unified resource locators</strong> (<strong>URLs</strong>).</p>
<p>A URL is a specific type of URI, composed of the following elements:</p>
<pre>&lt;scheme&gt;://&lt;authority&gt;/&lt;path&gt;/&lt;query&gt;&lt;fragment&gt;</pre>
<p>The preceding <kbd>&lt;authority&gt;</kbd> part:</p>
<pre>&lt;userinfo&gt;@&lt;host&gt;:&lt;port&gt;</pre>
<p>The following is an example URL using our application:</p>
<pre>http://someserver.com:5000/blog/user/user1?title=sometitle#1</pre>
<p>Let's separate out the elements of this:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Scheme</strong></td>
<td><strong>HTTP</strong></td>
</tr>
<tr>
<td><kbd>authority.host</kbd></td>
<td><kbd>someserver.com</kbd></td>
</tr>
<tr>
<td><kbd>authority.port</kbd></td>
<td><kbd>5000</kbd></td>
</tr>
<tr>
<td><kbd>path</kbd></td>
<td><kbd>blog/user/user1</kbd></td>
</tr>
<tr>
<td><kbd>query</kbd></td>
<td><kbd>title=sometitle</kbd></td>
</tr>
<tr>
<td><kbd>fragment</kbd></td>
<td><kbd>1</kbd></td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Next, we will quickly look at an HTTP request message from a user agent to a server. This is a GET request from a Mozilla browser, as shown in the highlighted text in the following code:</p>
<pre class="code-command"><strong>GET /blog/user/user1</strong> HTTP/1.1
Host: someserver.com
Accept: image/gif, image/jpeg, */*
Accept-Language: en-us
Accept-Encoding: gzip, deflate
User-Agent: <strong>Mozilla</strong>/4.0 (compatible; MSIE 6.0; Windows NT 5.1)<br/>Cookie: cookie1=somevalue; cookie2=othervalue; session:dsofksdfok439349i3sdkfoskfoskfosdkfo
(blank line)</pre>
<p>So an HTTP request is composed of the following:</p>
<ul>
<li><strong>Request line</strong>: Further composed of <kbd>&lt;Request method&gt; &lt;Request URI&gt; &lt;HTTP version&gt;</kbd></li>
<li><strong>Request header</strong>: Contains information about what the client accepts, the user agent, cookies, and even basic authentication credentials</li>
<li><strong>A</strong> <strong>blank line</strong>: Separates the header from the body section</li>
<li><strong>Request body</strong>: Optional</li>
</ul>
<p>Accepted HTTP request methods are <kbd>GET</kbd>, <kbd>HEAD</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, <kbd>DELETE</kbd>, <kbd>CONNECT</kbd>, <kbd>OPTIONS</kbd>, <kbd>TRACE</kbd>, and <kbd>PATCH</kbd>. The REST specification will use them to identify application type operations.</p>
<p>An HTTP response to a request looks like the following:</p>
<pre>HTTP/1.0 200 OK<br/>Content-Type: application/json<br/>Content-Length: 1330<br/>Server: Werkzeug/0.14.1 Python/2.7.10<br/>Date: Thu, 19 Jul 2018 11:14:16 GMT<br/>{ "author": "user1" ... }</pre>
<p class="mce-root"/>
<p>It's composed of the following elements: </p>
<ul>
<li><strong>Status line</strong>: The status of the response</li>
<li><strong>Response headers</strong>: <span>Contains information about the content type, length, the server type (in our example, it's Flask's development server itself), date, and whether it can send set-cookie operations</span></li>
<li>A blank line</li>
<li><strong>Response body</strong>: In our example, this is a JSON response, probably a REST service response</li>
</ul>
<p>Status response codes are also very significant to REST. These fall into the following categories:</p>
<ul>
<li><strong>Informational</strong>: 1XX</li>
<li><strong>Successful</strong>: 2XX</li>
<li><strong>Redirection</strong>: 3XX</li>
<li><strong>Client error</strong>: 4XX</li>
<li><strong>Server error</strong>: 5XX</li>
</ul>
<div class="packt_tip">For further details on status response codes, take a look at RFC2616 at <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">REST definition and best practices</h1>
                </header>
            
            <article>
                
<p>Before getting into the details of REST, let's look at an example. With a client—in this case, a web browser—and a server, the client sends a request to the server over HTTP for some models, as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/dec57efd-0837-4883-bd2d-9971b1a10913.png" style="width:42.92em;height:8.75em;"/></div>
<p>The server will then respond with a document containing all the models, as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/6ea3f8b0-ab4c-4648-a50b-5b69e62d2552.png" style="width:42.83em;height:13.92em;"/></div>
<p>The client can then modify the data on the server through a <kbd>PUT</kbd> HTTP request, as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/f8282865-f224-433a-b137-67f923f75a0a.png" style="width:43.00em;height:10.58em;"/></div>
<p>Then, the server will respond that it has modified the data. This is a very simplified example, but it will serve as a backdrop to how REST is defined.</p>
<p>Rather than a strict standard, REST lays out a set of constraints on communications to define a methodology that can be implemented in many ways. These constraints are born out of years of trial and error with other communication protocols, such as the <strong>Remote Procedure Call</strong> (<strong>RPC</strong>) or <strong>Simple Object Access Protocol</strong> (<strong>SOAP</strong>). These protocols fell by the wayside because of their strictness, verbosity, and the fact that it is difficult to use them to create APIs. The issues with these systems were identified, and REST's constraints were created to keep these issues from happening again.</p>
<p class="mce-root"/>
<p>REST provides the following guiding constraints:</p>
<ul>
<li><strong>Separation of concerns between the client and server</strong>: <span>The client and server should be able to evolve or change independently as long as the API does not change.</span></li>
<li><strong>Stateless</strong>: A<span>ny information that is necessary to handle requests is stored in the request itself or by the client. An example of the server being stateless is the </span><kbd>session</kbd><span> object in Flask. The </span><kbd>session</kbd><span> object does not store its information on the server, but stores it on the client in a cookie. The cookie is sent along with every request for the server to parse and determine whether the necessary data for the requested resource is stored inside it, rather than the server storing session information for every user.</span></li>
<li><strong>Uniform interface</strong>: There are many different parts to this constraint, which are as follows:
<ul>
<li>The interface is based around resources, which in our case are models.</li>
<li>Data sent by the server is not the actual data in the server, but a representation. For example, a JSON abstraction of the data is sent with each request, rather than the actual database.</li>
<li>The data sent by the server is enough to allow the client to modify the data on the server. In the preceding example, the IDs that are passed to the client fill this role.</li>
<li>Every resource provided by the API must be represented and accessed in the same manner. For example, one resource cannot be represented in XML and while another is represented in JSON.</li>
</ul>
</li>
<li><strong>Layered system:</strong> <span>Load balancers, proxies, caches, and other servers and services can act between the client and the server, as long as the final result is the same as if they were not there. This improves performance, scalability, and availability.</span></li>
<li><strong>Cacheability: </strong>Clients can cache responses, so a server must define whether a response is cacheable or not. This improves performance.</li>
</ul>
<p>When a system adheres to all these constraints, it is considered to be a RESTful system. The most common forms of RESTful systems are built of HTTP and JSON. Each resource is located on its own URL path and is modified with different HTTP request methods. Generally, this takes the following form:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>HTTP method</strong></p>
</td>
<td>
<p class="CDPAlignLeft CDPAlign"><strong>URL</strong></p>
</td>
<td>
<p><strong>Action</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p><kbd>http://host/resource</kbd></p>
</td>
<td>
<p>Get all the resource representations</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p><kbd>http://host/resource/1</kbd></p>
</td>
<td>
<p>Get the resource with an ID of <kbd>1</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>POST</kbd></p>
</td>
<td>
<p><kbd>http://host/resource</kbd></p>
</td>
<td>
<p>Create a new resource from the form data in the <kbd>POST</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>PUT</kbd></p>
</td>
<td>
<p><kbd>http://host/resource/1</kbd></p>
</td>
<td>
<p>Modify the existing data of the resource with the ID of <kbd>1</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>DELETE</kbd></p>
</td>
<td>
<p><kbd>http://host/resource/1</kbd></p>
</td>
<td>
<p>Delete the resource with the ID of <kbd>1</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>As an example, a response to the second <kbd>GET</kbd> request would look like the following:</p>
<pre>HTTP/1.0 200 OK<br/>Content-Type: application/json<br/>Content-Length: 1330<br/>Server: Werkzeug/0.14.1 Python/2.7.10<br/>Date: Thu, 19 Jul 2018 11:14:16 GMT<br/><br/>{ "id": 100, "title": "Some blog post title" }</pre>
<p>In RESTful APIs, it is also very important that we return the correct HTTP status code with the response data to notify the clients of what actually happened on the server without the clients resorting to parsing the returned message. Here is a list of the main HTTP codes that are used in RESTful APIs, along with their meaning:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>HTTP code</strong></p>
</td>
<td>
<p><strong>Name</strong></p>
</td>
<td>
<p><strong>Meaning</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>200</kbd></p>
</td>
<td>
<p>OK</p>
</td>
<td>
<p>The default code of HTTP. The request was successful, and the data was returned.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>201</kbd></p>
</td>
<td>
<p>Created</p>
</td>
<td>
<p>The request was successful, and a new resource was created on the server.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>204</kbd></p>
</td>
<td>
<p>No content</p>
</td>
<td>
<p>The request was successful, but the response returned no content.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>400</kbd></p>
</td>
<td>
<p>Bad request</p>
</td>
<td>
<p>The request was denied because of some perceived client error—either it was a malformed request or it was missing the required data.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>401</kbd></p>
</td>
<td>
<p>Unauthorized</p>
</td>
<td>
<p>The request was denied because the client was not authenticated, and it should be authenticated before requesting this resource again.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>403</kbd></p>
</td>
<td>
<p>Forbidden</p>
</td>
<td>
<p>The request was denied because the client does not have permission to access this resource. This is in contrast to the <kbd>401</kbd> code, which assumes that the user is not authenticated. The <kbd>403</kbd> code says the resource is not accessible regardless of authentication.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>404</kbd></p>
</td>
<td>
<p>Not found</p>
</td>
<td>
<p>The requested resource does not exist.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>405</kbd></p>
</td>
<td>
<p>Method not allowed</p>
</td>
<td>
<p>The request was denied because the HTTP method is not available for the URL.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>500</kbd></p>
</td>
<td>
<p>Internal server error</p>
</td>
<td>
<p><span>The web server responds with this status code when it has encountered an unexpected condition that prevented it from fulfilling the request from the client.</span></p>
</td>
</tr>
<tr>
<td>
<p><kbd>501</kbd></p>
</td>
<td>
<p>Not implemented</p>
</td>
<td>
<p><span>This error is shown when it does not support the functionality required to process the request. This is the appropriate response when the server does not recognize the request method.</span></p>
</td>
</tr>
<tr>
<td><kbd>502</kbd>
<p> </p>
</td>
<td>Bad gateway</td>
<td>When the server is acting as a gateway or proxy and receives an invalid response from the upstream server.</td>
</tr>
<tr>
<td><kbd>503</kbd>
<p> </p>
</td>
<td>Service unavailable</td>
<td><span>Currently unable to handle the request because of temporary overloading or maintenance of the server. </span></td>
</tr>
<tr>
<td><kbd>504</kbd></td>
<td>Gateway timeout</td>
<td><span>Did not receive a timely response from the upstream server.</span></td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up a RESTful Flask API</h1>
                </header>
            
            <article>
                
<p>In our app, we will create a RESTful interface to the blog post data in our database. The representations of the data will be sent as JSON. The data will be retrieved and modified using the general form in the preceding table, but the URI will be <kbd>/api/posts</kbd>.</p>
<p>If you haven't already downloaded and accessed the example code given for this chapter and taken a look at the Flask URL maps for the API, then a simple way of doing this can be seen in the root directory of the application, as shown in the following code:</p>
<pre><strong>$ # Initialise the virtual environment and database with test data<br/>$ ./init.sh<br/>$ # Activate the python virtual environment<br/>$ source venv/bin/activate<br/>$</strong> <strong>export FLASK_APP=main.py<br/>$ echo app.url_map | flask shell | grep api<br/></strong><strong>..</strong><br/> &lt;Rule '/auth/api' (POST, OPTIONS) -&gt; auth.api&gt;,<br/> &lt;Rule '/api/post' (HEAD, GET, PUT, POST, OPTIONS, DELETE) -&gt; postapi&gt;,<br/> &lt;Rule '/api/post/&lt;post_id&gt;' (HEAD, GET, PUT, POST, OPTIONS, DELETE) <br/> -&gt; postapi&gt;,<strong><br/></strong></pre>
<p>We are going to implement an authentication endpoint for the API and the necessary endpoints to create a CRUD API for the blog posts.</p>
<p class="mce-root"/>
<p>We could just use the standard Flask views to create the API, but the Flask extension <strong>Flask Restful</strong> makes the task much easier and will help us adhere to a full REST compliance (RESTful).</p>
<p>To include this new dependency in our application, you can find the following in the <kbd>requirements.txt</kbd><span> file</span>:</p>
<pre>... <br/><strong>Flask-Restful<br/></strong>...</pre>
<p>We are going to create a new module for the API. The application structure looks like the following code:</p>
<pre>./<br/>  main.py<br/>  config.py<br/>  ...<br/>  webapp/<br/>    blog/<br/>    main/<br/>    auth/<br/>    <strong>api/</strong><br/><strong>      __init__.py<br/></strong>      <strong>blog/</strong><br/><strong>          controlers.py<br/>          fields.py</strong><br/><strong>          parsers.py</strong><br/>    templates/<br/>    static/</pre>
<p>Once again, the idea is to structure our application so that it can grow easily. This time, for each application module we add—such as a blog, shared photos, you name it—we create a new module inside the <kbd>api/</kbd><span> module itself </span>where all the API logic is defined. A different approach could be to include the REST API inside each module.</p>
<p>Just like with all the other modules, there is a <kbd>create_module</kbd><span> function on the <kbd>api/__init__.py</kbd> that handles its own initialization for the main factory function, <kbd>create_app</kbd> . The <kbd>PostApi</kbd> class will also have its route defined with the <kbd>add_resource()</kbd> method of the <kbd>Api</kbd> object.</span></p>
<p>This can be seen in the provided code file, <kbd>api/__init__.py</kbd>, as follows:</p>
<pre><span>from </span>flask_restful <span>import </span>Api<br/><span>from </span>.blog.controllers <span>import </span>PostApi<br/><br/>rest_api = Api()<br/><br/><br/><span>def </span><span>create_module</span>(app<span>, </span><span>**kwargs</span>):<br/>    rest_api.add_resource(<br/>        PostApi<span>,<br/></span><span>        </span><span>'/api/post'</span><span>,<br/></span><span>        </span><span>'/api/post/&lt;int:post_id&gt;'</span><span>,<br/></span><span>    </span>)<br/>    rest_api.init_app(app)</pre>
<p>It can also be seen in the<span> </span><kbd>create_app</kbd><span> function in</span> <kbd>__init__.py</kbd> file, as follows:</p>
<pre>...<br/><span>def </span><span>create_app</span>(object_name):<br/>...<br/>    <span>from </span>api <span>import </span>create_module <span>as </span>api_create_module<br/>    ...<br/>    api_create_module(app)<br/><br/>    <span>return </span>app</pre>
<p>The control logic and views for our <kbd>Post</kbd> API are stored in a new folder named <kbd>api/blog</kbd> in the <kbd>controllers.py</kbd> file. Inside the <kbd>controllers.py</kbd>, we are going to create the API itself, as follows:</p>
<pre>from flask_restful import Resource 
 
class PostApi(Resource): 
  ...</pre>
<p>In Flask Restful, every REST resource is defined as a class that inherits from the <kbd>Resource</kbd> object. Much like the <kbd>MethodView</kbd> object shown in <a href="33c572f2-ce0e-40da-b46a-a7e13ba85496.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Creating Controllers with Blueprints</em>, any class that inherits from the <kbd>Resource</kbd> object defines its logic with methods named after the HTTP methods. For example, when the <kbd>GET</kbd> HTTP method hits the <kbd>PostApi</kbd> class, the <kbd>get</kbd> method will be executed.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JWT authentication</h1>
                </header>
            
            <article>
                
<p>To solve our authentication problems, <kbd>Flask-Login</kbd> could be used and the cookie data from the login could be checked. However, this would require developers who wish to use our API to have their program login through the web interface. We could also have developers send their login data with every request, but it's a good design practice to only send sensitive information when absolutely necessary. Instead, our API will provide an<span> </span><kbd>auth/api</kbd><span> </span>endpoint that allows them to send login credentials and get an access token back.</p>
<p>For the authentication mechanism, we are going to use <strong>JSON Web Token</strong> (<strong><span>JWT</span></strong>) to create access tokens for the consumers of our API upon login. A JWT token asserts which user is logged in, thereby saving the server another call to the database for authentication. <span>This token has an expiration date encoded inside it that will not allow the token to be used after it expires. This means that even if the token is stolen by a malicious user, it will only be useful for a limited amount of time before the client has to reauthenticate. As always, be sure to use HTTPS to encrypt all your client–server connections.</span></p>
<p>To leverage this feature, we are going to use another Flask extension—Flask-JWT-extended. You will find its dependency declared in the <kbd>requirements.txt</kbd> file, as follows:</p>
<pre>...<br/>flask-jwt-extended<br/>...</pre>
<p>The initialization of the extension is going to be made on the <kbd>auth</kbd><span> module.</span></p>
<p>Look at the following <kbd>auth/__init__.py</kbd> file:</p>
<pre><span>from </span>flask_jwt_extended <span>import </span>JWTManager<br/>...<br/>jwt = JWTManager()<br/>...<br/><span>def </span><span>create_module</span>(app<span>, </span><span>**kwargs</span>):<br/>    ...<br/>    jwt.init_app(app)<br/>    ...</pre>
<p class="mce-root"/>
<p>Next, we use the following helper function to authenticate users that are defined on the same file:</p>
<pre><br/><span>def </span><span>authenticate</span>(username<span>, </span>password):<br/>    <span>from </span>.models <span>import </span>User<br/>    user = User.query.filter_by(<span>username</span>=username).first()<br/>    <span>if not </span>user:<br/>        <span>return </span><span>None<br/></span><span>    </span><span># Do the passwords match<br/></span><span>    </span><span>if not </span>user.check_password(password):<br/>        <span>return </span><span>None<br/></span><span>    </span><span>return </span>user</pre>
<p>The definition of the login endpoint itself can be found at <kbd>auth/controllers.py</kbd>, as shown in the following code:</p>
<pre>@<span>auth_blueprint.route</span>(<span>'/api'</span><span>, </span><span>methods</span>=[<span>'POST'</span>])<br/><span>def </span><span>api</span>():<br/>    <strong><span>if not </span>request.is_json</strong>:<br/>        <span>return </span>jsonify({<span>"msg"</span>: <span>"Missing JSON in request"</span>})<span>, </span><span>400<br/></span><span><br/></span><span>    </span><strong>username = request.json.get(<span>'username'</span><span>, </span><span>None</span>)</strong><br/><strong>    password = request.json.get(<span>'password'</span><span>, </span><span>None</span>)</strong><br/>    <span>if not </span>username:<br/>        <span>return </span>jsonify({<span>"msg"</span>: <span>"Missing username parameter"</span>})<span>, </span><span>400<br/></span><span>    </span><span>if not </span>password:<br/>        <span>return </span>jsonify({<span>"msg"</span>: <span>"Missing password parameter"</span>})<span>, </span><span>400<br/></span><span><strong>    user = authenticate(username, password)</strong><br/></span><span>    </span><strong><span>if not user</span>:</strong><br/>        <span>return </span>jsonify({<span>"msg"</span>: <span>"Bad username or password"</span>})<span>, </span><span>401</span><span><br/></span><span>    </span><span># Identity can be any data that is json serializable<br/></span><span>    </span><strong>access_token = create_access_token(<span>identity</span>=user.id)</strong><br/>    <span>return </span>jsonify(<span>access_token</span>=access_token)<span>, </span><span>200</span></pre>
<p>First, we verify whether the request includes a JSON body. For this, we use a <kbd>request.is_json</kbd><span> function from Flask. Next, we extract the username and password from the JSON body using <kbd>request.json.get</kbd>. Then we check the user's credentials using the previous help function, <kbd>authenticate</kbd>. Finally, we return the JWT access token using the username as our identity. </span></p>
<p class="mce-root"/>
<p><span>Users of our API will have to pass the token that is received from this resource to any method that requires user credentials. In order to test this code, a tool named <strong>curl</strong> will be used. </span>Curl <span>is a command-line tool included in</span> Bash <span>that allows for the creation and manipulation of HTTP requests. To test it, use the <kbd>curl</kbd><strong> </strong>utility to first log in, as shown in the following code:</span></p>
<pre><strong>$ curl -H "Content-Type: application/json" -d '{"username":"user1","password":"password"}' http://localhost:5000/auth/api<br/></strong>{<br/>  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyOGZjMDNkOC0xY2MyLTQwZDQtODJlMS0xMGQ0Mjc2YTk1ZjciLCJleHAiOjE1MzIwMTg4NDMsImZyZXNoIjpmYWxzZSwiaWF0IjoxNTMyMDE3OTQzLCJ0eXBlIjoiYWNjZXNzIiwibmJmIjoxNTMyMDE3OTQzLCJpZGVudGl0eSI6InVzZXIxIn0.Cs-ANWq0I2M2XMrZpQof-_cX0gsKE7U4UG1t1rB0UoY"<br/>}<strong><br/></strong></pre>
<p>We then use the <kbd>-H</kbd><span> flag to send the request header stating that the content body is JSON and the <kbd>-d</kbd> flag to send the request body data. Next, we can use the token to access API-protected resources, as follows:</span></p>
<pre><strong>$ export ACCESS="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyOGZjMDNkOC0xY2MyLTQwZDQtODJlMS0xMGQ0Mjc2YTk1ZjciLCJleHAiOjE1MzIwMTg4NDMsImZyZXNoIjpmYWxzZSwiaWF0IjoxNTMyMDE3OTQzLCJ0eXBlIjoiYWNjZXNzIiwibmJmIjoxNTMyMDE3OTQzLCJpZGVudGl0eSI6InVzZXIxIn0.Cs-ANWq0I2M2XMrZpQof-_cX0gsKE7U4UG1t1rB0UoY"</strong><br/><strong>$ curl -H "Authorization: Bearer $ACCESS" http://localhost:5000/api/post</strong></pre>
<p>Note how the access token is sent on the request header user <kbd>Authorization: Bearer &lt;TOKEN&gt;</kbd> convention. If we try to access the same resource without any token, we get the following:</p>
<pre><strong>$ curl -v http://localhost:5000/api/post</strong><br/>...<br/>&lt; HTTP/1.0 401 UNAUTHORIZED<br/>...<br/>{<br/>  "msg": "Missing Authorization Header"<br/>}</pre>
<p>As expected, we get an HTTP <kbd>401</kbd> status code. To protect API endpoints, we just have to use the <kbd>flask-jwt-extended</kbd> decorator <kbd>@jwt_required</kbd><span>, and to fetch the username, we use the <kbd>get_jwt_identity()</kbd> function.</span></p>
<p class="mce-root"/>
<div class="packt_tip">The <kbd>flask-jwt-extended</kbd> decorator provides some extra functionalities, such as token expiration, the ability to refresh token endpoints, and many configuration options. You can read more about it at <a href="http://flask-jwt-extended.readthedocs.io/en/latest/">http://flask-jwt-extended.readthedocs.io/en/latest/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Get requests</h1>
                </header>
            
            <article>
                
<p>For some of our <kbd>GET</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd> requests, our API will need the ID of the post that is to be modified.</p>
<p>The data to be sent to the client must be a representation of the <kbd>Post</kbd> objects in JSON, so how will our <kbd>Post</kbd> objects be translated? Flask Restful provides a way of translating any object into JSON through the <kbd>fields</kbd> object and the <kbd>marshal_with</kbd> function decorator.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Output formatting</h1>
                </header>
            
            <article>
                
<p>The output format is defined by creating a dictionary of <kbd>field</kbd> objects that represent basic types. The key of the field defines what attribute the field will try to translate. By passing the dictionary to the <kbd>marshal_with</kbd> decorator, any object that the <kbd>get</kbd> method attempts to return will be first translated using the dictionary. This also works for lists of objects. Let's look at a simple way of implementing this API endpoint. The following example code takes pagination into account, but we will show you how this works later.</p>
<p>Look at the following <kbd>api/blog/controllers.py</kbd> file:</p>
<pre><span>import </span>datetime<br/><br/><span>from </span>flask <span>import </span>abort<br/><span>from </span>flask_restful <span>import </span>Resource<span>, </span>fields<span>, </span>marshal_with<br/><span>from </span>flask_jwt_extended <span>import </span>jwt_required<span>, </span>get_jwt_identity<br/><span>from </span>webapp.blog.models <span>import </span>db<span>, </span>Post<span>, </span>Tag<br/><span>from </span>webapp.auth.models <span>import </span>User<br/>...<br/><br/><strong>post_fields = {</strong><br/><strong>    <span>'id'</span>: fields.Integer()<span>,<br/></span><span>    </span><span>'author'</span>: fields.String(<span>attribute</span>=<span>lambda </span>x: x.user.username)<span>,<br/></span><span>    </span><span>'title'</span>: fields.String()<span>,<br/></span><span>    </span><span>'text'</span>: HTMLField()<span>,<br/></span><span>    </span><span>'tags'</span>: fields.List(fields.Nested(nested_tag_fields))<span>,<br/></span><span>    </span><span>'publish_date'</span>: fields.DateTime(<span>dt_format</span>=<span>'iso8601'</span>)</strong><br/><strong>}</strong><br/><br/><br/><span>class </span><span>PostApi</span>(Resource):<br/>    <strong>@<span>marshal_with</span>(post_fields)</strong><br/>    @<span>jwt_required<br/></span><span>    </span><span>def </span><span>get</span>(<span>self</span><span>, </span>post_id=<span>None</span>):<br/>        <span>if </span>post_id:<br/>            post = Post.query.get(post_id)<br/>            <span>if not </span>post:<br/>                abort(<span>404</span>)<br/>            <span>return </span>post<br/>        <span>else</span>:<br/>            posts = Post.query.all()<br/>            return posts</pre>
<p>While reloading the API in the browser, every <kbd>Post</kbd> object will be shown in JSON format. Note the <kbd>HTMLField</kbd><span> on the fields declaration.</span> The problem is that the API should not return HTML from the WYSIWYG editor in the post creation form. As stated earlier, the server should not be concerned with the UI, and the HTML is purely for output specification. To solve this, we will need a custom field object that strips HTML from the strings. In a new file in the <kbd>api/blog/</kbd> folder named <kbd>fields.py</kbd>, we have the following:</p>
<pre><strong><span>try</span>:</strong><br/><strong>    <span># Try python3<br/></span><span>    </span><span>from </span>html.parser <span>import </span>HTMLParser</strong><br/><strong><span>except </span><span>Exception </span><span>as </span>e:</strong><br/><strong>    <span># Nop python2<br/></span><span>    </span><span>from </span>HTMLParser <span>import </span>HTMLParser</strong><br/><br/><span>from </span>flask_restful <span>import </span>fields<br/><br/><br/><span>class </span><span>HTMLStripper</span>(HTMLParser):<br/>    fed = <span>list</span>()<br/><br/>    <span>def </span><span>__init__</span>(<span>self</span>):<br/>        <span>self</span>.reset()<br/>        <span>self</span>.fed = []<br/><br/>    <span>def </span><span>handle_data</span>(<span>self</span><span>, </span>d):<br/>        <span>self</span>.fed.append(d)<br/><br/>    <span>def </span><span>get_data</span>(<span>self</span>):<br/>        <span>return </span><span>''</span>.join(<span>self</span>.fed)<br/><br/><br/><span>def </span><span>strip_tags</span>(html):<br/>    s = HTMLStripper()<br/>    s.feed(html)<br/>    <span>return </span>s.get_data()<br/><br/><br/><span>class </span><span>HTMLField</span>(fields.Raw):<br/>    <span>def </span><span>format</span>(<span>self</span><span>, </span>value):<br/>        <span>return </span>strip_tags(<span>str</span>(value))</pre>
<p>The exception block is to take into account Python2 and Python3 compatibility, since <span>the standard library has changed for the </span><kbd>HTMLParser</kbd><span> module </span><span>in Python3.</span><span> W</span><span>e now have a</span> <kbd>strip_tags</kbd> <span>function that will return any string that has been cleaned of HTML tags. A new field type, called </span><kbd>HTMLfield</kbd><span>, is defined by inheriting from the</span> <kbd>fields.Raw</kbd> <span>class and sending values through the</span> <kbd>strip_tags</kbd> <span>function. If the page is reloaded, all HTML is gone and only the text will remain.</span></p>
<p>Flask Restful provides many default fields, as shown in the following list:</p>
<ul>
<li><kbd>fields.String</kbd>: This converts the value using <kbd>str()</kbd>.</li>
<li><kbd>fields.FormattedString</kbd>: This passes the formatted string in Python with the variable name in brackets.</li>
<li><kbd>fields.Url</kbd>: This provides the same functionality as the Flask <kbd>url_for</kbd> function.</li>
<li><kbd>fields.DateTime</kbd>: This converts a Python <kbd>date</kbd> or <kbd>datetime</kbd> object to a string. The <kbd>format</kbd> keyword argument specifies whether the string should be an <kbd>ISO8601</kbd> date or an <kbd>RFC822</kbd> date.</li>
<li><kbd>fields.Float</kbd>: This converts the value to a string representation of a float.</li>
<li><kbd>fields.Integer</kbd>: This converts the value to a string representation of an integer.</li>
<li><kbd>fields.Nested</kbd>: This allows nested objects to be represented by another dictionary of field objects.</li>
<li><kbd>fields.List</kbd>: Much like the MongoEngine API, this field takes another field type as an argument and tries to convert a list of values into a JSON list of the field types.</li>
<li><kbd>fields.Boolean</kbd>: This converts the value to a string representation of a <kbd>boolean</kbd> argument.</li>
</ul>
<p>There are two more fields that are added to the returned data: the author and the tags. The comments will be left out because they should be contained under their own resource.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>author</kbd> field uses the attribute keyword argument of the <kbd>field</kbd> class. This allows any attribute of the object to be represented rather than just base-level properties. Because the many-to-many relationship of the tags returns a list of objects, the same solution cannot be used with the tags. A<span> list of tag dictionaries can now be returned u</span><span>sing the</span> <kbd>NestedField</kbd> <span>type inside a</span> <kbd>ListField</kbd> <span>and another dictionary of fields. This has the added benefit </span><span>of giving</span> <span>the end users of the API</span> <span>a tag ID so that they can query as easily as if there were a tag API.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Request arguments</h1>
                </header>
            
            <article>
                
<p>While sending a <kbd>GET</kbd> request to the base of the resource, our API currently sends all the <kbd>Post</kbd> objects in the database. This is acceptable if the number of objects is low or the number of people using the API is low. However, if either increases, the API will put a large amount of stress on the database. Much like the web interface, the API should be paginated as well.</p>
<p>In order to achieve this, our API will need to accept a <kbd>GET</kbd> query string parameter called <kbd>page</kbd> that specifies which page is to be loaded. Flask Restful provides a method to grab request data and parse it. If the required arguments aren't there, or the types don't match, Flask Restful will autocreate a JSON error message. In a new file in the <kbd>api/blog/</kbd> folder named <kbd>parsers.py</kbd>, you will find the following code:</p>
<pre>...<br/>from flask_restful import reqparse <br/>...
post_get_parser = reqparse.RequestParser() 
post_get_parser.add_argument( 
  'page', 
  type=int, 
  location=['args', 'headers'], 
  required=False,
) </pre>
<p>The following code is what we should have on the <kbd>PostApi</kbd> class when the request has no post ID key:</p>
<pre>from .parsers import post_get_parser <br/>...
class PostApi(Resource): 
  @marshal_with(post_fields)<br/>  @jwt_required 
  def get(self, post_id=None):
    if post_id: 
      .. 
      return post
    else:
      <strong>args = post_get_parser.parse_args() 
      page = args['page'] or 1 <br/>      ...
      posts = Post.query.order_by( 
        Post.publish_date.desc() 
      ).paginate(page, current_app.config.get('POSTS_PER_PAGE', 10))</strong> <br/>      ...
      return posts.items </pre>
<p>In the preceding example, <kbd>RequestParser</kbd> looks for the <kbd>page</kbd> variable in either the query string or the request header and returns the page of <kbd>Post</kbd> objects from that page. Again, we are making the page size configurable with the same value as for the web view page version. We use the <kbd>current_app</kbd><span> Flask proxy to fetch any value from our configuration.</span></p>
<p>After a parser object is created with <kbd>RequestParser</kbd>, arguments can be added using the <kbd>add_argument</kbd> method. The first argument of <kbd>add_argument</kbd> is the key of the argument that is to be parsed, but <kbd>add_argument</kbd> also takes a lot of keyword arguments, as shown in the following list:</p>
<ul>
<li><kbd>action</kbd>: This is what the parser does with the value after it has been successfully parsed. The two available options are <kbd>store</kbd> and <kbd>append</kbd>. The <kbd>store</kbd> option adds the parsed value to the returned dictionary. The <kbd>append</kbd> options adds the parsed value to the end of a list in the dictionary.</li>
<li><kbd>case_sensitive</kbd>: This is a boolean argument to allow or disallow the keys to be case insensitive.</li>
<li><kbd>choices</kbd>: This is like MongoEngine, a list of the allowed values for the argument.</li>
<li><kbd>default</kbd>: This is the value that is produced if the argument is absent from the request.</li>
<li><kbd>dest</kbd>: This is the key to add the parsed value to in the returned data.</li>
<li><kbd>help</kbd>: This is a message to return to the user if validation fails.</li>
<li><kbd>ignore</kbd>: This is a boolean argument to allow or disallow failures of the type conversion.</li>
<li><kbd>location</kbd>: This indicates where to look for the data. The locations available are as follows:
<ul>
<li><kbd>args</kbd> to look in the <kbd>GET</kbd> query string</li>
<li><kbd>headers</kbd> to look in the HTTP request headers</li>
<li><kbd>form</kbd> to look in the HTTP <kbd>POST</kbd> data</li>
<li><kbd>cookies</kbd> to look in the HTTP cookies</li>
<li><kbd>json</kbd> to look in any sent JSON</li>
<li><kbd>files</kbd> to look in the <kbd>POST</kbd> file data</li>
</ul>
</li>
<li><kbd>required</kbd>: This is a boolean argument to determine whether the argument is optional.</li>
<li><kbd>store_missing</kbd>: This is a boolean argument to determine whether the default value should be stored if the argument is not in the request.</li>
<li><kbd>type</kbd>: This is the Python type to convert the passed value.</li>
</ul>
<p>Using the Flask Restful parser, it is very easy to add new parameters to the API. For example, let's add a user argument that allows us to search for all posts that have been made by a user. First, in the <kbd>api/blog/parsers.py</kbd> file, we have the following:</p>
<pre><span>post_get_parser</span> = reqparse.RequestParser()<br/><span>post_get_parser</span>.add_argument(<span>'page'</span><span>, </span><span>type</span>=<span>int</span><span>, </span><span>location</span>=[<span>'args'</span><span>, </span><span>'headers'</span>])<br/><span>post_get_parser</span>.add_argument(<span>'user'</span><span>, </span><span>type</span>=<span>str</span><span>, </span><span>location</span>=[<span>'args'</span><span>, </span><span>'headers'</span>])</pre>
<p>Then, in the <kbd>api/blog/controllers.py</kbd> file, we have the following:</p>
<pre><span>class </span><span>PostApi</span>(Resource):<br/>    @<span>marshal_with</span>(post_fields)<br/>    @<span>jwt_required<br/></span><span>    </span><span>def </span><span>get</span>(<span>self</span><span>, </span>post_id=<span>None</span>):<br/>        <span>if </span>post_id:<br/>            ...<br/>            <span>return </span>post<br/>        <span>else</span>:<br/>            args = post_get_parser.parse_args()<br/>            page = args[<span>'page'</span>] <span>or </span><span>1<br/></span><span><br/></span><span>            </span><strong><span>if </span>args[<span>'user'</span>]:</strong><br/><strong>                user = User.query.filter_by(<span>username</span>=args[<span>'user'</span>]).first()</strong><br/><strong>                <span>if not </span>user:</strong><br/><strong>                    abort(<span>404</span>)</strong><br/><br/>                posts = user.posts.order_by(<br/>                    Post.publish_date.desc()<br/>         ).paginate(page<span>, </span>current_app.config.get(<span>'POSTS_PER_PAGE'</span><span>, </span><span>10</span>))<br/>            <span>else</span>:<br/>                posts = Post.query.order_by(<br/>                    Post.publish_date.desc()<br/>        ).paginate(page<span>, </span>current_app.config.get(<span>'POSTS_PER_PAGE'</span><span>, </span><span>10</span>))<br/>          <span>return </span>posts.items</pre>
<p class="mce-root"/>
<p>When Flask's <kbd>abort</kbd> function is called from <kbd>Resource</kbd>, Flask Restful will automatically create an error message to be returned with the status code.</p>
<p>To test the API, we use <kbd>curl</kbd><strong> </strong>for the sake of simplicity, but feel free to use any other tool available to interact with HTTP APIs. After requesting an access token from our authentication endpoint, request <kbd>post</kbd> with <kbd>id=1</kbd>, as follows:</p>
<pre><strong>$ curl -H "Authorization: Bearer $ACCESS" "http://localhost:5000/api/post/1"</strong></pre>
<p>Or you can request all posts as follows:</p>
<pre><strong>$ curl -H "Authorization: Bearer $ACCESS" "http://localhost:5000/api/post"</strong></pre>
<p>Note that the response only fetches the first page, as intended. Now let's request page two, as follows:</p>
<pre><strong>$ curl -H "Authorization: Bearer $ACCESS" "http://localhost:5000/api/post?page=2"</strong></pre>
<p>Finally, you can request for posts from a certain user as follows:</p>
<pre><strong>$ curl -H "Authorization: Bearer $ACCESS" "http://localhost:5000/api/post?user=user1"</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Post requests</h1>
                </header>
            
            <article>
                
<p>The <kbd>POST</kbd> methods on REST are used for resource creation, not that this isn't considered an idempotent method. Using our new knowledge of the Flask Restful parser, we can cover the <kbd>POST</kbd> endpoint. First, we will need a parser that will take a title, the body text, and a list of tags. In the <kbd>parser.py</kbd> file, find the following:</p>
<pre>post_post_parser = reqparse.RequestParser()<br/>post_post_parser.add_argument(<br/>    <span>'title'</span><span>,<br/></span><span>    </span><span>type</span>=<span>str</span><span>,<br/></span><span>    </span><span>required</span>=<span>True</span><span>,<br/></span><span>    </span><span>help</span>=<span>"Title is required"</span><span>,<br/></span><span>    </span><span>location</span>=(<span>'json'</span><span>, </span><span>'values'</span>)<br/>)<br/>post_post_parser.add_argument(<br/>    <span>'text'</span><span>,<br/></span><span>    </span><span>type</span>=<span>str</span><span>,<br/></span><span>    </span><span>required</span>=<span>True</span><span>,<br/></span><span>    </span><span>help</span>=<span>"Body text is required"</span><span>,<br/></span><span>    </span><span>location</span>=(<span>'json'</span><span>, </span><span>'values'</span>)<br/>)<br/>post_post_parser.add_argument(<br/>    <span>'tags'</span><span>,<br/></span><span>    </span><span>type</span>=<span>str</span><span>,<br/></span><span>    </span><span>action</span>=<span>'append'</span><span>,<br/></span><span>    </span><span>location</span>=(<span>'json'</span><span>, </span><span>'values'</span>)<br/>)</pre>
<p>Next, we have created a helper function, called <kbd>add_tags_to_post</kbd>, to add tags to a post. If the tags don't exist, it will add them to the database. We will use it on <kbd>POST</kbd> and <kbd>PUT</kbd> requests. Nothing new here—just a simple SQLAlchemy helper function to help us keep our code concise.</p>
<p>Next, the <kbd>PostApi</kbd> class will need a <kbd>post</kbd> method to handle incoming requests. The <kbd>post</kbd> method will use the given values for the title and body text. Also, if the <kbd>tags</kbd> key exists, then add the tags to the post, which creates new tags if the passed ones do not exist, as shown in the following code:</p>
<pre>import datetime 
from .parsers import ( 
  post_get_parser, 
  post_post_parser 
) 
from webapp.models import db, User, Post, Tag 
class PostApi(Resource): 
  ... <br/>  @jwt_required
  def post(self, post_id=None):  
      args = post_post_parser.parse_args(strict=True) 
      new_post = Post(args['title'])<br/>      <strong>new_post.user_id = get_jwt_identity()</strong>
      new_post.text = args['text'] 
      if args['tags']:
        <strong>add_tags_to_post(post, args['tags'])</strong> 
      db.session.add(new_post) 
      db.session.commit()
      <strong>return {'id': new_post.id}, 201</strong></pre>
<p>At the <kbd>return</kbd> statement, if a tuple is returned, the second argument is treated as the status code. There is also a third value that acts as extra header values by passing a dictionary. Also, note the <kbd>get_jwt_identity</kbd><span> that we use to fetch the user ID from the JWT token. This was set up at the login phase where we used the user ID to set the JWT identity.</span></p>
<p class="mce-root"/>
<p>To pass <kbd>POST</kbd> variables, the <kbd>d</kbd> flag is used, as follows:</p>
<pre><strong>$ curl -X POST -H "Authorization: Bearer $ACCESS" -H "Content-Type: application/json" -d '{"title":"Text Title", "text":"Some text"}' "http://localhost:5000/api/post"<br/></strong>{<br/>    "id": 310<br/>}</pre>
<p>The ID of the newly created post should be returned. If you go to the browser, you should see our newly created post, which was made by the user that you used to generate the authentication token.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Put requests</h1>
                </header>
            
            <article>
                
<p>As listed in the table at the beginning of this chapter, <kbd>PUT</kbd> requests are used to change the values of an existing resource. Like the <kbd>post</kbd> method, the first thing that we should do is create a new parser in <kbd>parsers.py</kbd>, as follows:</p>
<pre>post_put_parser = reqparse.RequestParser()<br/>post_put_parser.add_argument(<br/>    <span>'title'</span><span>,<br/></span><span>    </span><span>type</span>=<span>str</span><span>,<br/></span><span>    </span><span>location</span>=(<span>'json'</span><span>, </span><span>'values'</span>)<br/>)<br/>post_put_parser.add_argument(<br/>    <span>'text'</span><span>,<br/></span><span>    </span><span>type</span>=<span>str</span><span>,<br/></span><span>    </span><span>location</span>=(<span>'json'</span><span>, </span><span>'values'</span>)<br/>)<br/>post_put_parser.add_argument(<br/>    <span>'tags'</span><span>,<br/></span><span>    </span><span>type</span>=<span>str</span><span>,<br/></span><span>    </span><span>action</span>=<span>'append'</span><span>,<br/></span><span>    </span><span>location</span>=(<span>'json'</span><span>, </span><span>'values'</span>)<br/>)</pre>
<p>The logic for the <kbd>put</kbd> method is very similar to the <kbd>post</kbd> method. The main difference is that each change is optional and any request that does not provide <kbd>post_id</kbd> is denied, as shown in the following code:</p>
<pre>...<br/><span>def </span><span>add_tags_to_post</span>(post<span>, </span>tags_list):<br/>    <span>for </span>item <span>in </span>tags_list:<br/>        tag = Tag.query.filter_by(<span>title</span>=item).first()<br/><br/>        <span># Add the tag if it exists. If not, make a new tag<br/></span><span>        </span><span>if </span>tag:<br/>            post.tags.append(tag)<br/>        <span>else</span>:<br/>            new_tag = Tag(item)<br/>            post.tags.append(new_tag)<br/>...<br/><span><br/></span><span>    </span>@<span>jwt_required<br/></span><span>    </span><span>def </span><span>put</span>(<span>self</span><span>, </span>post_id=<span>None</span>):<br/>        <span>if not </span>post_id:<br/>            abort(<span>400</span>)<br/>        post = Post.query.get(post_id)<br/>        <span>if not </span>post:<br/>            abort(<span>404</span>)<br/>        args = post_put_parser.parse_args(<span>strict</span>=<span>True</span>)<br/>        <span>if </span>get_jwt_identity() != post.user_id:<br/>            abort(<span>403</span>)<br/>        <span>if </span>args[<span>'title'</span>]:<br/>            post.title = args[<span>'title'</span>]<br/>        <span>if </span>args[<span>'text'</span>]:<br/>            post.text = args[<span>'text'</span>]<br/>        <span>if </span>args[<span>'tags'</span>]:<br/>            <span>print</span>(<span>"Tags %s" </span>% args[<span>'tags'</span>])<br/>            add_tags_to_post(post<span>, </span>args[<span>'tags'</span>])<br/><br/>        db.session.merge(post)<br/>        db.session.commit()<br/>        <span>return </span>{<span>'id'</span>: post.id}<span>, </span><span>201</span></pre>
<p>Also note that, just as we did with the controller for web views, we are denying any request to change a blog post that was not made by the creator of the blog post him or herself.</p>
<p>To test this method, <kbd>curl</kbd> can also create <kbd>PUT</kbd> requests with the <kbd>-X</kbd> flag, as follows:</p>
<pre><strong>$ curl -X PUT -H "Authorization: Bearer $ACCESS" -H "Content-Type: application/json" \</strong><br/><strong>    -d '{"title": "Modified From REST", "text": "this is from REST", "tags": ["tag1","tag2"]}' \</strong><br/><strong>http://localhost:5000/api/post/5</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Delete requests</h1>
                </header>
            
            <article>
                
<p>Finally, in the following code we have the <kbd>DELETE</kbd> request, which is the simplest of the four supported methods. The main difference with the <kbd>delete</kbd> method is that it returns no content, which is the accepted standard with <kbd>DELETE</kbd> requests:</p>
<pre>@<span>jwt_required<br/></span><span>def </span><span>delete</span>(<span>self</span><span>, </span>post_id=<span>None</span>):<br/>    <span>if </span>post_id:<br/>        abort(<span>400</span>)<br/>    post = Post.query.get(post_id)<br/>    <span>if not </span>post:<br/>        abort(<span>404</span>)<br/>    <span>if </span>get_jwt_identity() != post.user_id:<br/>        abort(<span>401</span>)<br/>    db.session.delete(post)<br/>    db.session.commit()<br/>    <span>return </span><span>""</span><span>, </span><span>204</span></pre>
<p>Again, we can test using the following:</p>
<pre><strong>$ curl -X DELETE -H "Authorization: Bearer $ACCESS"</strong>
<strong>http://localhost:5000/api/post/102</strong></pre>
<p>If everything is successfully deleted, you should receive a <kbd>204</kbd> status code and nothing should show up.</p>
<p>Before we move on from REST completely, there is one final challenge for you to test your understanding of Flask Restful. Try to create a comments API that is not only modifiable from <kbd>http://localhost:5000/api/comments</kbd>, but that also allows developers to modify only those comments on a specific post by using the URL format <kbd>http://localhost:5000/api/post/&lt;int:post_id&gt;/comments</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Our <kbd>Post</kbd> API is now a complete feature. If a developer wants, then they can create a desktop or mobile application using this API, all without using HTML scraping, which is a very <span>long</span><span> </span><span>and</span><span> </span><span>tedious process. Giving the developers who wish to use your website as a platform the ability to do so will increase your site's popularity, as they will essentially give you free advertising with their app or website.</span></p>
<p>In the next chapter, we will use the popular program Celery to run programs and tasks asynchronously with our application.</p>


            </article>

            
        </section>
    </body></html>