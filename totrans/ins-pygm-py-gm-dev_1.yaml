- en: Chapter 1. Instant Pygame for Python Game Development How-to
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Welcome to *Pygame for Python Game Development How-to*. This book is for developers
    who want to create games with Pygame quickly and easily and get familiar with
    the important aspects of it. The typical things you would learn are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Pygame basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pygame is part of the Python framework, originally written by Pete Shinners,
    that as its name suggests can be used to create video games. Pygame is free and
    open source since 2004 and licensed under the GPL license, which means that you
    are allowed to basically make any type of game. Pygame is built on top of the
    **Simple DirectMedia Layer** (**SDL**). SDL is a C framework that gives access
    to graphics, sound, keyboard, and other input devices on various operating systems
    including Linux, Mac OS X, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing your development environment (Simple)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will install Python, Pygame, and other software we will need.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we install Pygame, we need to have Python installed. On some operating
    systems Python is already installed. Pygame should be compatible with all Python
    versions. We will also need the NumPy numerical library. I am the author of two
    books published by Packt Publishing about NumPy – *NumPy Beginner's Guide* and
    *NumPy Cookbook*. Please refer to these books for more info about NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing on Debian and Ubuntu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python might be already installed on Debian and Ubuntu, but the development
    headers are usually not. On Debian and Ubuntu, install python and python-dev with
    these commands:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pygame can be found in the Debian archives [http://packages.qa.debian.org/p/pygame.html](http://packages.qa.debian.org/p/pygame.html).
    We can install NumPy with the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Installing on Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Windows Python installer can be found on [www.python.org/download](http://www.python.org/download).
    On this website we can also find installers for Mac OS X and source tarballs for
    Linux, Unix, and Mac OS X.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From the Pygame website ([http://www.pygame.org/download.shtml](http://www.pygame.org/download.shtml)),
    we can download the appropriate binary installer for the Python version we are
    using.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Download a NumPy installer for Windows from the SourceForge website ([http://sourceforge.net/projects/numpy/files/](http://sourceforge.net/projects/numpy/files/)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Installing Python on the Mac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python comes preinstalled on Mac OS X. We can also get Python via MacPorts,
    Fink, or similar projects. We can install for instance the Python 2.6 port by
    running the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Binary Pygame packages for Mac OS X 10.3 and up can be found on [http://www.pygame.org/download.shtml](http://www.pygame.org/download.shtml).
    We can get a NumPy installer from the SourceForge website ([http://sourceforge.net/projects/numpy/files/](http://sourceforge.net/projects/numpy/files/)).
    Download the appropriate `.DMG` file. Usually the latest one is the best.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Installing from source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pygame is using the `distutils` system for compiling and installing. To start
    installing Pygame with the default options, simply run the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you need more information about the available options, type the following
    command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to compile the code, you need to have a compiler for your operating
    system. Setting this up is beyond the scope of this book. More information about
    compiling Pygame on Windows can be found on [http://pygame.org/wiki/CompileWindows](http://pygame.org/wiki/CompileWindows).
    More information about compiling Pygame on Mac OS X can be found at [http://pygame.org/wiki/MacCompile](http://pygame.org/wiki/MacCompile).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Running a simple game (Simple)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a simple game that we will improve on further in the book. As
    is traditional in books about programming, we will start with a Hello World! example.
    It's not a game per se. It's important to notice the so-called main game loop
    where all the action happens and the usage of the `Font` module to render text.
    In this program we will manipulate a Pygame's `Surface` object, that is used for
    drawing and we will handle a quit event.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Imports**: First we will import the required Pygame modules. If Pygame is
    installed properly, we should get no errors, otherwise please return to the *Preparing
    your development environment (Simple)* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Initialization**: We will initialize Pygame by creating a display of 400
    by 300 pixels and setting the window title to `Hello world`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**The main game loop**: Games usually have a game loop, which runs forever
    until, for instance, a quit event occurs. In this example, we will only set a
    label with the text `Hello world` at coordinates (100, 100). The text has a font
    size of 19, red color, and falls back to the default font:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We get the following screenshot as the end result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/2865OS_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The following is the complete code for the Hello World example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It might not seem like much, but we learned a lot in this recipe. The functions
    that passed the review are summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.init()` | This function performs the initialization and needs to
    be called before any other Pygame functions are called. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.display.set_mode((400, 300))` | This function creates a so-called
    `Surface` object to draw on. We give this function a tuple representing the width
    and height of the surface. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.display.set_caption(''Hello World!'')` | This function sets the window
    title to a specified string value. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.font.SysFont("None", 19)` | This function creates a system font from
    a comma-separated list of fonts (in this case none) and a font size parameter.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `sysFont.render(''Hello World'', 0, (255, 100, 100))` | This function draws
    text on a surface. The second parameter indicates whether anti-aliasing is used.
    The last parameter is a tuple representing the RGB values of a color. |'
  prefs: []
  type: TYPE_TB
- en: '| `screen.blit(rendered, (100, 100))` | This function draws on a surface. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.event.get()` | This function gets a list of `Event` objects. Events
    represent some special occurrence in the system, such as a user quitting the game.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.quit()` | This function cleans up resources used by Pygame. Call
    this function before exiting the game. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.display.update()` | This function refreshes the surface. |'
  prefs: []
  type: TYPE_TB
- en: Drawing with Pygame (Simple)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start creating cool games, we need an introduction to the drawing
    functionality of Pygame. As we noticed in the previous recipe, in Pygame we draw
    on the `Surface` objects. There is a myriad of drawing options—different colors,
    rectangles, polygons, lines, circles, ellipses, animation, and different fonts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps will help you diverge into the different drawing options
    you can use with Pygame:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Imports**: We will need the NumPy library to randomly generate RGB values
    for the colors, so we will add an extra import for that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Initializing colors**: Generate four tuples containing three RGB values each
    with NumPy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then define the white color as a variable:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Set the background color**: We can make the whole screen white with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Drawing a circle**: Draw a circle in the center with the window using the
    first color we generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Drawing a line**: To draw a line we need a start point and an end point.
    We will use the second random color and give the line a thickness of `3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Drawing a rectangle**: When drawing a rectangle, we are required to specify
    a color, the coordinates of the upper-left corner of the rectangle, and its dimensions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Drawing an ellipse**: You might be surprised to discover that drawing an
    ellipse requires similar parameters as for rectangles. The parameters actually
    describe an imaginary rectangle that can be drawn around the ellipse:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting window with a circle, line, rectangle, and ellipse using random
    colors:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/2685OS_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The code for the drawing demo is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Animating objects (Simple)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to draw with Pygame, it's time to try something more dynamic.
    Most games, even the most static ones, have some level of animation. From a programmer's
    standpoint, animation is nothing more than displaying an object at a different
    place at a different time, thus simulating movement.
  prefs: []
  type: TYPE_NORMAL
- en: Pygame offers a `Clock` object that manages how many frames are drawn per second.
    This ensures that animation is independent of how fast the user's CPU is.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load an image and use NumPy again to define a clockwise path around
    the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a clock as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Loading an image**: As part of the source code accompanying this book, there
    should be a picture of a head. We will load this image and move it around on the
    screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Initializing arrays**: We will define some arrays to hold the coordinates
    of the positions, where we would like to put the image during the animation. Since
    the object will be moved, there are four logical sections of the path: right,
    down, left, and up. Each of these sections will have 40 equidistant steps. We
    will initialize all the values in the sections to 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Setting the coordinates of the positions**: It''s trivial to set the coordinates
    of the positions of the image. However, there is one tricky bit to notice, the
    `[::-1]` notation leads to reversing the order of the array elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Joining the sections**: The path sections can be joined, but before we can
    do this, the arrays have to be transposed with the `T` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Setting the clock rate**: In the main event loop, we will let the clock tick
    at a rate of 30 frames per second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot is of the moving head:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/2865OS_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You should be able to watch a movie of this animation on [https://www.youtube.com/watch?v=m2TagGiq1fs](https://www.youtube.com/watch?v=m2TagGiq1fs).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The code of this example uses almost everything we learned so far, but should
    still be simple enough to understand:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We learned a bit about animation in this recipe. The most important concept
    we learned is the clock. The new functions that we used are described in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.time.Clock()` | This function creates a game clock |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.linspace(20, 360, 40)` | This function creates an array with 40 equidistant
    values between 20 and 360 |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.zeros((2, len(steps)))` | This function creates an array of the specified
    dimensions filled with zeroes |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.concatenate((right.T, down.T, left.T, up.T))` | This function concatenates
    arrays to form a new array |'
  prefs: []
  type: TYPE_TB
- en: '| `clock.tick(30)` | This function executes a tick of the game clock, where
    30 is the number of frames per second |'
  prefs: []
  type: TYPE_TB
- en: Using fonts (Simple)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Frequently there is a need to display some text, for instance, a counter or
    a message.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pygame has a `font` module that can help us to show text.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a font**: We can create a font by specifying, the font filename,
    and font size as constructor parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Displaying text**: Since we made an image move around the edge in the previous
    recipe, it would be great to display a counter and the position of the image in
    the center of the screen with a blue background and red letters. The following
    code snippet accomplishes this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: A screenshot of the animation is shown as follows and should be on YouTube too
    at [https://www.youtube.com/watch?v=xhjfcFhaXN0](https://www.youtube.com/watch?v=xhjfcFhaXN0).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/2865OS_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The code is almost the same as for the previous recipe, with the addition of
    code for the creation and display of fonts:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using Matplotlib with Pygame (Simple)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Matplotlib is an open source library for easy plotting. We can integrate Matplotlib
    into Pygame game and create various plots. You can find the Matplotlib installation
    instructions at [http://matplotlib.org/users/installing.html](http://matplotlib.org/users/installing.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe we will take the position coordinates of the previous recipe
    and make a graph of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using a non-interactive backend**: In order to integrate Matplotlib with
    Pygame, we need to use a non-interactive backend, otherwise Matplotlib will present
    us with a GUI window by default. We will import the main Matplotlib module and
    call the `use` function. This function has to be called immediately after importing
    the main `matplotlib` module and before other `matplotlib` modules are imported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Creating a Matplotlib canvas**: Non-interactive plots can be drawn on a Matplotlib
    canvas. Creating this canvas requires imports, a figure, and a subplot. We will
    specify the figure to be 3 by 3 inches large. More details can be found at the
    end of this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Plotting data**: In a non-interactive mode, plotting data is a bit more complicated
    than in the default mode. Since we need to plot repeatedly, it makes sense to
    organize the plotting code in a function. The plot is eventually drawn on the
    canvas. The canvas adds a bit of complexity to our setup. At the end of this example,
    you can find more detailed explanation of the functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The following screenshot shows the animation in action. You can also view a
    screencast on YouTube at [https://www.youtube.com/watch?v=t6qTeXxtnl4](https://www.youtube.com/watch?v=t6qTeXxtnl4).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/2865OS_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We get the following code after the changes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The plotting-related functions are explained in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `matplotlib.use("Agg")` | This function specifies to use the non-interactive
    backend |'
  prefs: []
  type: TYPE_TB
- en: '| `plt.figure(figsize=[3, 3])` | This function creates a figure of 3 by 3 inches
    |'
  prefs: []
  type: TYPE_TB
- en: '| `fig.add_subplot(111)` | This function creates a subplot (in this case we
    only need 1 subplot) |'
  prefs: []
  type: TYPE_TB
- en: '| `agg.FigureCanvasAgg(fig)` | This function creates a canvas in non-interactive
    mode |'
  prefs: []
  type: TYPE_TB
- en: '| `ax.plot(data)` | This function creates a plot using specified data |'
  prefs: []
  type: TYPE_TB
- en: '| `canvas.draw()` | This function draws on the canvas |'
  prefs: []
  type: TYPE_TB
- en: '| `canvas.get_renderer()` | This function gets a renderer for the canvas |'
  prefs: []
  type: TYPE_TB
- en: Accessing surface pixel data (Intermediate)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Pygame `surfarray` module handles the conversion between Pygame `Surface`
    objects and NumPy arrays. As you may recall, NumPy can manipulate big arrays in
    a fast and efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we will tile a small image to fill the game screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**Copying pixels to array**: The `array2d` function copies pixels into a two-dimensional
    array. There is a similar function for three-dimensional arrays. We will copy
    the pixels from the avatar image into an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Creating the game screen**: A NumPy array has a shape attribute that corresponds
    to the dimensions of the array. This attribute is a tuple. A two-dimensional array
    for instance, will have a two-element shape tuple. Let''s create the game screen
    from the shape of the pixels array using the `shape` attribute of the array. The
    screen will be seven times larger in both directions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Tiling the image**: Tiling the image is easy with the NumPy `tile` function.
    The data needs to be converted to integer values, since colors are defined as
    integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Displaying the array**: The `surfarray` module has the following special
    function (`blit_array`) to display the array on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot displays the result of the code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/2865OS_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The following code does the tiling of the image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table gives us a brief description of the new functions and attributes
    we used:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.surfarray.array2d(img)` | This copies pixel data into a 2D array
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pixels.shape[0]` | The `shape` attribute holds the dimensions of a NumPy
    array as a tuple |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.tile(pixels, (7, 7))` | This tiles an array the given dimensions specified
    as a tuple |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.surfarray.blit_array(screen, new_pixels)` | This displays array values
    on the screen |'
  prefs: []
  type: TYPE_TB
- en: Accessing sound data (Simple)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good game needs to have great music and sound effects. The Pygame `mixer`
    module lets us play a sound or any audio for that matter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will download a WAV audio file using standard Python. We will play this sound
    when the game quits. This example requires you to actually execute the example
    code, because this book has no audio support.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a sound object**: We can create a Pygame `Sound` object after specifying
    the name of the audio file. This class as you would expect embodies the concept
    of sounds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Playing the sound**: The `Sound` object has a `play` method, which has a
    number of loops parameters. If the value of this parameter is set to -1, the sound
    will loop indefinitely:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Pausing the game**: Sometimes we need to pause the execution of a game, as
    in our case in order to be able to hear a sound. We can do this with the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The delay is specified in milliseconds, that's why we are multiplying by 1000.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Stopping the sound**: After a while we need to stop the sound with the corresponding
    `stop` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The audio demo code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most important functions of this demo are summed up in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.mixer.Sound(WAV_FILE)` | This function creates a `Sound` object given
    a filename. |'
  prefs: []
  type: TYPE_TB
- en: '| `audio.play(-1)` | This function plays and loops indefinitely (-1 means indefinitely).
    By default the sound is played only once. This corresponds with 0 loops. If the
    value is 2, the sound will be played once and then repeated 2 more times. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.time.delay(TIMEOUT * 1000)` | This function pauses the game for a
    specified number of milliseconds. |'
  prefs: []
  type: TYPE_TB
- en: '| `audio.stop()` | This function stops audio playback. |'
  prefs: []
  type: TYPE_TB
- en: Playing a movie (Intermediate)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most commercial games these days have small movie clips that try to explain
    the plot to us. For instance, a first-person shooter could have a movie showing
    a briefing about the next mission. Movie playback is a cool feature to have. Pygame
    offers limited support for MPEG movies.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to have a MPEG movie for this demo. Once you have a movie you can convert
    it to be used in a Pygame game with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Installing `ffmpeg` and the command-line options are outside the scope of this
    book, but shouldn't be too difficult (see [http://ffmpeg.org/](http://ffmpeg.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The movie playback is set up similarly to the audio playback that we covered
    in the previous recipe. The following code demonstrates playing a MPEG video.
    Pay particular attention to the `play` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The relevant functions for the movie playback can found in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.movie.Movie(''out.mpg'')` | This function creates a `Movie` object
    given the filename of the MPEG movie |'
  prefs: []
  type: TYPE_TB
- en: '| `movie.play()` | This function starts playing the movie |'
  prefs: []
  type: TYPE_TB
- en: '| `movie.stop()` | This function stops playback of the movie |'
  prefs: []
  type: TYPE_TB
- en: Pygame on Android (Intermediate)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android is an open source smartphone operating system initially developed by
    Google. Most of the Android apps are written in the Java programming language
    and run on a Java-based virtual machine. Fortunately, we can create Pygame games
    for Android phones. This is not a trivial matter and we will only cover the bare
    basics.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will install the **Pygame Subset For Android** (**PGS4A**). You will need
    to have the JDK, Python 2.7 or a later version installed before we start. Download
    the appropriate software for your operating system from [http://pygame.renpy.org/dl](http://pygame.renpy.org/dl).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the necessary software, we will require an Internet connection and
    quite a lot of room on your hard drive. If you don''t have a couple of gigabytes
    to spare, you may need to make more space. We can install the Android SDK and
    other software we will need such as Apache Ant by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This will start a wizard that will guide you through the installation. It's
    safe to accept all the default options during the installation procedure, but
    you do have to generate a key. Unless you are really serious about creating apps,
    you don't have to worry how secure this key is.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a simple game that prints "Hello World From Android!" and call
    it `mygame`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting up the game**: Create a directory with the same name as the name
    of the game and place a `main.py` file in there with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is basically the code from the PGS4A website changed to print a welcome
    message. A more thorough explanation will be given at the end of the recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Configuring the game**: We can configure the game with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will accept all the defaults and set the storage setting to internal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Building, installing, and running the game**: Android is essentially a Java
    framework, so there is a lot of compiling involved. This is a bit different than
    in the Python world. Since this game is simple, building will not take that long.
    First we will start the emulator—this is an application that mimics the behavior
    of an actual phone. Find the `android` executable that is part of the Android
    SDK. Launch it and choose **Tools** | **Manage AVDs…** | **New…** in the GUI application
    that opens. Create an **Android Virtual Device** (**AVD**) and give it a name.
    Hit the **Launch…** button. A phone emulator will start. If it is locked, you
    can unlock it by pressing *F2*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now build and install the game with the command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The relevant functions used in this code are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `android.init()` | This function initializes Android |'
  prefs: []
  type: TYPE_TB
- en: '| `android.map_key(android.KEYCODE_BACK, pygame.K_ESCAPE)` | This function
    maps the Android back button to the Pygame escape button |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.time.set_timer(TIMEREVENT, 1000 / FPS)` | This function fires events
    at specified time intervals given in milliseconds |'
  prefs: []
  type: TYPE_TB
- en: '| `android.check_pause()` | This function checks for a pause request |'
  prefs: []
  type: TYPE_TB
- en: '| `android.wait_for_resume()` | This function puts the game in sleep mode |'
  prefs: []
  type: TYPE_TB
- en: Artificial intelligence (Intermediate)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often we need to mimic intelligent behavior within a game. The `scikits-learn`
    project aims to provide an API for Machine Learning. What I like most about it
    is the amazing documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can install `scikit-learn` by typing the following command at the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This might not work because of permissions, so you might need to put `sudo`
    in front of the commands or log in as admin.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will generate some random points and cluster them, which means that points
    that are close to each other are put in the same cluster. This is only one of
    the many techniques that you can apply with `scikits-learn`. **Clustering** is
    a type of machine learning algorithm that aims to group items based on similarities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Generating random points**: We will generate 30 random point positions within
    a square of 400 by 400 pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Calculating the affinity matrix**: We will use the Euclidean distance to
    the origin as the **affinity metric**. The affinity matrix is a matrix holding
    affinity scores, in this case distances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Clustering the points**: Give the `AffinityPropagation` class the result
    from the previous step. This class labels the points with the appropriate cluster
    number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Drawing polygons**: We will draw polygons for each cluster. The function
    involved requires a list of points, a color (let''s paint it red), and a surface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is a bunch of polygons for each cluster as shown in the following
    screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/2865OS_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The clustering example code is shown as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most important lines in the artificial intelligence recipe are described
    in more detail in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.random.randint(0, 400, size=(30, 2))` | This creates an array of 30
    by 2 random integers. This corresponds to 30 points in two-dimensional space.
    The values are between 0 and 400. |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.sum(positions ** 2, axis=1)` | This sums an array of the square of
    the positions array. |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.dot(positions, positions.T)` | This computes the dot product of the
    positions array and its transpose. |'
  prefs: []
  type: TYPE_TB
- en: '| `sklearn.cluster.AffinityPropagation().fit(S)` | This creates an `AffinityPropagation`
    object and performs a fit using an affinity matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.draw.polygon(screen, (255, 0, 0), polygon_points[i])` | This draws
    a polygon given a surface, a color (red in this case), and a list of points. |'
  prefs: []
  type: TYPE_TB
- en: Drawing sprites (Intermediate)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Sprite** is a term from computer graphics meaning a two-dimensional visible
    object, that has been optimized for rendering. Pygame offers the `Sprite` class
    that deals with sprites. It can draw sprites on a `Surface` object. It also has
    collision functions. For complex games, we can group sprites together for easy
    management. Sprites are not thread safe, so you should take care when using multiple
    threads.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will redo the animation demo, but this time with sprites and using `Rect`
    objects, which represent rectangles. A `Rect` object has `left`, `top`, `width`,
    and `height` attributes. We will use these and other attributes throughout the
    example. Also we will let the avatar spin when the mouse button is clicked. However,
    we will not care for now where we click exactly.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a class that extends the `Sprite` class. Sprite classes have
    an `update` method which fires for each frame. All logic involving the movement
    of the sprite should be placed here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructor**: First, we need to create the sprite and perform subclassing.
    All the initialization logic goes here. Further details for the functions can
    be found in the next section. We define an image, rectangle, and variables tracking
    the movement of the avatar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**The update method**: The `update` method calls helper methods that either
    cause the head to spin or move it in clockwise direction. The movement is achieved
    with this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following line take care of the rotation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find a short clip of the game on YouTube ([https://www.youtube.com/watch?v=EFQlc_siPrI](https://www.youtube.com/watch?v=EFQlc_siPrI)).
    A screenshot of the game is shown as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/2865OS_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The complete code of the Sprite demo is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A more in-depth description of the various functions used in this demo is given
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.sprite.Sprite.__init__(self)` | This creates sprites. |'
  prefs: []
  type: TYPE_TB
- en: '| `screen.get_rect()` | This gets a `Rect` object. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.display.get_surface()` | This gets a `Surface` object. |'
  prefs: []
  type: TYPE_TB
- en: '| `self.rect.move((self.xstep, self.ystep))` | This moves a rectangle given
    a `x` and `y` coordinate. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.transform.rotate(self.original, self.degrees)` | This rotates an
    image given a `Surface` object and angle in degrees. Positive values correspond
    with counter clockwise rotation, negative with clockwise rotation. |'
  prefs: []
  type: TYPE_TB
- en: '| `self.image.get_rect(center=center)` | This gets the rectangle for the image
    given its center coordinates. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.sprite.RenderPlain(head)` | This renders the sprite. |'
  prefs: []
  type: TYPE_TB
- en: Using OpenGL with Pygame (Advanced)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL specifies an API for 2D and 3D computer graphics. The API consists of
    functions and constants. We will be concentrating on the Python implementation
    called **PyOpenGL**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install PyOpenGL with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'You might need to have root access to execute this command. The corresponding
    `easy_install` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the purpose of demonstration we will draw a Sierpinski gasket with OpenGL.
    This is a fractal pattern in the shape of a triangle created by the mathematician
    Waclaw Sierpinski. The triangle is obtained via a recursive and in principle infinite
    procedure.
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenGL Initialization**: First, we will start out by initializing some of
    the OpenGL-related primitives. This includes setting the display mode and background
    color. A line-by-line explanation is given at the end of the recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Displaying points**: The algorithm requires us to display points, the more
    the better. First, we set the drawing color to red. Second, we define the vertices
    (I call them points myself) of a triangle. Then we define random indices, which
    are to be used to choose one of the three triangle vertices. We pick a random
    point somewhere in the middle, it doesn''t really matter where. After that we
    draw points halfway between the previous point and one of the vertices picked
    at random. Finally, we "flush" the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Sierpinski triangle looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/2865OS_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The full Sierpinski gasket demo code with all the imports is shown as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As promised here is a line-by-line explanation of the most important parts
    of the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.display.set_mode((w,h), pygame.OPENGL&#124;pygame.DOUBLEBUF)` | This
    sets the display mode to the required width, height, and OpenGL display. |'
  prefs: []
  type: TYPE_TB
- en: '| `glClear(GL_COLOR_BUFFER_BIT&#124;GL_DEPTH_BUFFER_BIT)` | This clears the
    buffers using a mask. Here we clear the color buffer and depth buffer bits. |'
  prefs: []
  type: TYPE_TB
- en: '| `gluOrtho2D(0, w, 0, h)` | This defines a 2D orthographic projection matrix
    with the coordinates of the left, right, top, and bottom clipping planes. |'
  prefs: []
  type: TYPE_TB
- en: '| `glColor3f(1.0, 0, 0)` | This defines the current drawing color using three
    float values for RGB (0-1 instead of 0-255 that is usual for Pygame). In this
    case we will be painting in red. |'
  prefs: []
  type: TYPE_TB
- en: '| `glBegin(GL_POINTS)` | This delimits the vertices of primitives or a group
    of primitives. Here the primitives are points. |'
  prefs: []
  type: TYPE_TB
- en: '| `glVertex2fv(point)` | This renders a point given a vertex. |'
  prefs: []
  type: TYPE_TB
- en: '| `glEnd()` | This closes a section of code started with `glBegin`. |'
  prefs: []
  type: TYPE_TB
- en: '| `glFlush()` | This forces execution of GL commands. |'
  prefs: []
  type: TYPE_TB
- en: Detecting collisions (Intermediate)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the sprite demo, we left out the collision detection bit. Pygame has a number
    of useful collision detection functions in the `Rect` class. For instance, we
    can check whether a point is in a rectangle or whether two rectangles overlap.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Beside the collision detection we will replace the mouse cursor with an image
    of a hammer that we created. It's not a very pretty image, but it beats the boring
    old cursor.
  prefs: []
  type: TYPE_NORMAL
- en: '**Updating the hit method**: We will update the `hit` method of the sprite
    demo code. In the new version, we check whether the mouse cursor is within the
    avatar sprite. Actually to make it easier to hit the head, we create a slightly
    bigger rectangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Replacing the mouse cursor**: All the steps necessary to replace the mouse
    cursor were already covered. Except making the mouse cursor invisible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A screenshot of the game is shown as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/2865OS_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The complete code for this example can be found in the code bundle of this book.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We learned a bit about collision detection, the mouse cursor, and rectangles
    in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.mouse.get_pos()` | This gets the mouse position as a tuple. |'
  prefs: []
  type: TYPE_TB
- en: '| `self.rect.inflate(40, 40)` | This creates a bigger rectangle based on an
    offset. If the offset is negative this results in a smaller rectangle. |'
  prefs: []
  type: TYPE_TB
- en: '| `bigger_rect.collidepoint(mouse_x, mouse_y)` | This checks whether a point
    is within a rectangle. |'
  prefs: []
  type: TYPE_TB
- en: '| `pygame.mouse.set_visible(False)` | This hides the mouse cursor. |'
  prefs: []
  type: TYPE_TB
- en: Adding networking functionality (Advanced)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Games become more engaging when you are able to play against other people. Usually
    this means playing over the Internet using some sort of client-server architecture.
    In the Python world, Twisted is commonly used for this kind of architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Twisted can be installed in several ways depending on your operating system.
    For more information see [https://twistedmatrix.com/trac/wiki/Downloads](https://twistedmatrix.com/trac/wiki/Downloads).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, we cannot create a massive multiplayer game in this tutorial,
    but we can create a simple client-server setup, which will lay the foundations
    for a puzzle we will create in a later recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '**The server**: First, we will set up the server, which will echo the message
    from the client and prepend it with a sequence number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see the server runs on port 8888 over TCP (see [http://en.wikipedia.org/wiki/Transmission_Control_Protocol](http://en.wikipedia.org/wiki/Transmission_Control_Protocol)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Client setup**: The client sends messages over the same port as the server
    and also shows the messages from the server in a Pygame GUI. We will go over the
    details in the next section. In a later example we will do more interesting things
    with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to start the server, before we can start the client. In the game GUI,
    you should see **Hello** being displayed followed by **1 IMPORTANT MESSAGE!**
    to **19 IMPORTANT MESSAGE!** as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/2865OS_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw in this example how to create a simple server and client with a Pygame
    GUI. In principle, we can now extend this setup to create a multiplayer game.
    The details of the Twisted client and server setup are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `self.transport.write("%d %s" % (self.count, msg))` | This writes a message.
    In this case we are prepending a sequence number to the message. |'
  prefs: []
  type: TYPE_TB
- en: '| `factory = protocol.ServerFactory()` | This creates a Twisted server factory,
    which itself creates Twisted servers. |'
  prefs: []
  type: TYPE_TB
- en: '| `reactor.listenTCP(8888,factory)` | This listens to port 8888 using the given
    factory. |'
  prefs: []
  type: TYPE_TB
- en: '| `reactor.run()` | This starts the server or client. |'
  prefs: []
  type: TYPE_TB
- en: '| `reactor.stop()` | This stops the client or server. |'
  prefs: []
  type: TYPE_TB
- en: '| `reactor.callLater(i * .1, p.sendMessage, "IMPORTANT MESSAGE!")` | This registers
    a callback function with a parameter to be executed after a specified time in
    seconds. |'
  prefs: []
  type: TYPE_TB
- en: '| `protocol.ClientCreator(reactor, Client)` | This creates a Twisted client.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `c.connectTCP("localhost", 8888).addCallback(send)` | This connects the client
    via TCP on port 8888 and registers a callback function. |'
  prefs: []
  type: TYPE_TB
- en: Debugging your game (Intermediate)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is one of those things that nobody really likes, but is very important
    to master. It can take hours, and because of Murphy's law you, most likely, don't
    have that time. Therefore, it is important to be systematic and know your tools
    well. After you are done finding the bug and implementing a fix, you should have
    a test in place. This way at least you will not have to go through the hell of
    debugging again.
  prefs: []
  type: TYPE_NORMAL
- en: PuDB is a visual full screen, console-based Python debugger that is easy to
    install. PuDB supports cursor keys and vi commands. The debugger can also be integrated
    with IPython, if required.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to install puDB, we only need to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To debug the collision demo code, type the following command on the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code should be available for download from the Packt Publishing website.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the most important debugging commands at the
    top:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2865OS_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can also see the code being debugged, variables, the stack, and the defined
    breakpoints. Typing `q` exits most menus. Typing `n` moves the debugger to the
    next line. We can also move with the cursor keys or vi *J* and *K* keys to, for
    instance, set a breakpoint by typing `b`.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling your code (Intermediate)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance is important for games, luckily there are many Python profiling
    tools. Profiling is about building a profile of a software program in order to
    collect information about memory usage or time complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '`cProfile` is a C extension introduced in Python 2.5\. It can be used for **deterministic
    profiling**. Deterministic profiling means that the time measurements are precise
    and no sampling is used. Contrast this with statistical profiling, where measurements
    come from random samples.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps will help you profile your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a profile file**: We will profile the collision demo code and store
    the profile output in a file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**The pstats browser**: After creating the file, we can view and sort the data
    in a special command-line browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Getting help**: Being able to get help is always a good thing, just type
    the following commands at the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Sorting**: We can sort with the following `sort` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Top 3 called functions**: We can get the top 3 called functions by sorting
    and calling `stats`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We profiled the collision demo. The following table summarizes the profiler
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Column | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Ncalls` | Number of calls |'
  prefs: []
  type: TYPE_TB
- en: '| `Tottime` | Total time spent in a function |'
  prefs: []
  type: TYPE_TB
- en: '| `Percall` | Time per call, calculated by dividing the total time by the calls
    count |'
  prefs: []
  type: TYPE_TB
- en: '| `Cumtime` | Cumulative time spent in function and functions called by the
    function, including recursive calls |'
  prefs: []
  type: TYPE_TB
- en: Puzzle game with Pygame (Advanced)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will pick up where we left in the networking example. This time we will create
    a puzzle game that lets us guess a word. This is just a prototype mind you. It
    still needs a lot of polishing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps will help you to create the intended puzzle game:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server changes**: The changes in the server are pretty trivial. We just check
    whether we guessed the correct word:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Client changes**: The most important changes are the handling of key presses
    in an input box and handling of the response from the server. The input box lets
    us type text, edit it with the *Backspace* key, and submit with the *Enter* key.
    A label above the textbox displays the number of attempts and the game status.
    We use a Twisted looping callback to update the GUI every 30 milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot was taken after guessing the word:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/2865OS_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although this seems to be a pretty extensive recipe, only a few lines of the
    code might require some explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `LoopingCall(handle_events, p)` | This creates a looping callback. A callback
    function that is called periodically. |'
  prefs: []
  type: TYPE_TB
- en: '| `tick.start(.03)` | This starts the looping callback with a period of 30
    milliseconds. |'
  prefs: []
  type: TYPE_TB
- en: Simulating with Pygame (Advanced)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the last example, we will simulate life with Conway's Game of Life. The original
    game of life is based on a few basic rules. We start out with a random configuration
    on a two-dimensional square grid. Each cell in the grid can be either dead or
    alive. This state depends on the eight neighbors of the cell. Convolution can
    be used to evaluate the basic rules of the game. We will need the SciPy package
    for the convolution bit.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install SciPy with either of the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo pip install scipy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`easy_install scipy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code is an implementation of Game of Life with some modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: Clicking once with the mouse draws a cross until we click again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *R* key resets the grid to a random state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pressing *B* creates blocks based on the mouse position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*G* creates gliders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most important data structure in the code is a two-dimensional array holding
    the color values of the pixels on the game screen. This array is initialized with
    random values and then recalculated in the game loop. More information about the
    involved functions can be found in the next section. As previously mentioned,
    the following is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should be able to view a screencast on YouTube at [https://www.youtube.com/watch?v=NNsU-yWTkXM](https://www.youtube.com/watch?v=NNsU-yWTkXM).
  prefs: []
  type: TYPE_NORMAL
- en: 'A screenshot of the game in action is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2865OS_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We used some NumPy and SciPy functions that need explaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ndimage.convolve(arr, weights, mode=''wrap'')` | This applies the convolve
    operation on the given array, using weights in wrap mode. The mode has to do with
    the array borders. See [http://en.wikipedia.org/wiki/Convolution](http://en.wikipedia.org/wiki/Convolution)
    for the mathematical details. |'
  prefs: []
  type: TYPE_TB
- en: '| `bools.astype(int)` | This converts the array of Booleans to integers. |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.arange(0, pos[0], 10)` | This creates an array from `0` to `pos[0]`
    in steps of 10\. So if `pos[0]` is equal to 1000, we will get 0, 10, 20 … 990.
    |'
  prefs: []
  type: TYPE_TB
