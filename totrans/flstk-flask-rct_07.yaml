- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We sufficiently discussed the fundamentals of React in the preceding chapters.
    You have been exposed to React tools and resources to master modern frontend techniques
    in your full stack development journey. We explored in-depth useful information
    required to build rich interactive interfaces with React. We discussed the topics
    of components, props and state, JSX, event handling, forms, and routing in React.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on unit testing in React applications, a type
    of software testing that focuses on isolated piece(s) of code. Also, we will explore
    **Jest**, a Node-based test runner. The test runner allows you to discover test
    files, run tests, and find out whether tests passed or failed automatically. You
    will then end with a report in a very clear, expressive, and human-readable format.
  prefs: []
  type: TYPE_NORMAL
- en: Jest is a popular testing framework developed with React in mind. The project
    was formally owned by *Meta*, the same company behind React. However, with the
    recent transfer of Jest from Meta to the *OpenJs Foundation*, Jest now has an
    independent core team working actively on it to ensure stability, security, and
    code bases that can stand the test of time.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we will briefly examine a useful testing tool in the React ecosystem
    – the **React Testing Library** (**RTL**). This library provides us with arrays
    of methods to virtually run tests on React components.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in this chapter, we will deep-dive into **test-driven development**
    (**TDD**), a software development paradigm that places priority on test implementation
    before actual coding. The coding and testing are interlaced. Testing always comes
    first, although it is obviously not a fun part of the software development process.
  prefs: []
  type: TYPE_NORMAL
- en: Most experienced developers still struggle with testing just as beginners do.
    Companies have different policies around testing, but in real-world development,
    you can’t have industrial-strength web applications without testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing ensures that you follow the best practice of the software development
    life cycle and that you and your application end users have confidence in your
    web application functionalities. With appropriate testing, the features of your
    web application will perform efficiently as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is software testing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests in Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit-testing React components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter07](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter07)'
  prefs: []
  type: TYPE_NORMAL
- en: What is software testing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Software testing** is a process that ensures all the pieces of code in software
    or application development work as expected by all stakeholders. The process of
    testing is one of the key phases in software development life cycles that explains
    the standardized methodology of designing and developing an application.'
  prefs: []
  type: TYPE_NORMAL
- en: Software testing ensures that web applications have fewer bugs, technical requirements
    are implemented as expected efficiently, development costs are reduced, and ultimately,
    business needs are met.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, testing, if carried out effectively, usually gives software engineers
    the confidence to know full well that the product they ship to production is maintainable,
    readable, reliable, and well structured.
  prefs: []
  type: TYPE_NORMAL
- en: This creates less panic about possible costly bugs in an application, which
    may cost a company embarrassment or the erosion of customers’ confidence. There
    are various types of software testing worthy of note – unit testing, integration
    testing, performance testing, usability testing, acceptance testing, and regression
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s briefly discuss the types of testing that we have in software development
    to refresh our minds and have a solid base to build on in the subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: In this type of testing, the smallest piece of code or unit
    in software or application development is tested. In unit testing, you systematically
    go through three stages – planning, case scripting, and testing. You are primarily
    concerned with the functionality of the independent units of your application.
    In the *Unit-testing React components* section, we will deep-dive into unit testing
    and how you can implement unit tests in your React applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing**: In this type of testing, groups of individual units
    of codes are combined and tested for effective interaction with one another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance testing**: In this type of testing, the speed and effectiveness
    of your application are tested against a given workload. This approach is used
    to identify early bottlenecks in the smooth running of a software application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability testing**: In this type of testing, intended users of your application
    are allowed to get a feel for your product. The feedback from direct evaluations
    of your application design through usability testing ensures you are able to capture
    users’ frustration while interacting with your application so early. The report
    on usability testing can also provide other useful insights that might improve
    your product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acceptance testing**: In this type of testing, client satisfaction is gauged
    – customer requirements are evaluated against a developed software or application.
    The customer is able to check that those requirements are captured properly and
    work as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regression testing**: In this type of testing, we check whether code changes
    occasioned by the addition of new functionality into your software or application
    do not break down the previously tested working functionality. Regression prevents
    the introduction of errors or unintended side effects as a result of modifying
    the code base of your application. With regression testing, all test cases are
    rerun so that no new bugs are introduced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will explore one of the leading testing frameworks you can confidently
    work with when testing the functionality of your frontend applications.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Jest** is an open source, robust, well-documented, fast, and safe JavaScript
    testing framework. Jest provides the tools and resources that you need to have
    absolute confidence in your JavaScript code base. Testing is fundamental to quality
    code writing, and Jest with almost zero configuration delightfully handles test
    implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Jest is very popular in the JavaScript community. You can write tests in Jest
    leveraging its feature-rich set of APIs, such as matchers, mocked functions, code
    coverage, and snapshot testing. Jest can be used to test React components, and
    the React team actually recommends Jest to test React projects.
  prefs: []
  type: TYPE_NORMAL
- en: Jest is a Node.js test runner, which means that the tests always run in a Node
    environment. Jest is built with performance in mind. You can run a suite of tests
    in parallel effectively. The Jest toolkit comes with code coverage that enables
    you to have information about tested and untested files in your project. And when
    your tests fail, you are provided with insightful information about why they failed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s set up a Jest environment for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Jest environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js is required for Jest to run. Jest comes with the `npx create-react-app`
    command we used to the `create-react-app` boilerplate code in [*Chapter 2*](B18554_02.xhtml#_idTextAnchor038),
    *Getting Started* *with React*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will create a new working folder named `bizza-test` to
    better explore how Jest works with JavaScript functions, before we move on to
    using it in the unit testing of React components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `path/to/bizza-test/`, let’s execute the following commands in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm init -y` in the command terminal.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Jest as a dependency in the working folder (`bizza-test`) with `npm
    install --``save-dev jest`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `package.json` to be able to run Jest via `npm test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The complete `package.json` should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The following is a screenshot showing the installation of Jest in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – A screenshot of the Jest library setup](img/Figure_7.1_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – A screenshot of the Jest library setup
  prefs: []
  type: TYPE_NORMAL
- en: With this set, you are on the right path to run your test. Next, we will explore
    some key testing terminologies and write the actual tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests in Jest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have set up the test running environment, let’s briefly understand
    some of the keywords we will encounter in this section. In Jest, you have some
    test keywords and functions from the Jest API to structure your tests; let’s examine
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test()` or `it()`: This is a descriptive unit test or test case. It contains
    three parameters – a descriptive test case string, a function that contains the
    expectations to test, and an optional timeout argument, specifying how long to
    wait before aborting a test case. The default timeout is five seconds:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`describe()`: This groups related test cases together. It is used to group
    several related tests and describe their behaviors. `describe()` takes two parameters
    – a string describing your test group and a callback function that holds test
    cases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`beforeAll()`: This function is run before any of the tests in the test file
    run. And when you have a promise or generator returned from a function, Jest waits
    for that promise to resolve before running tests:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`beforeEach()`: This function runs before each of the tests in the test file
    runs. When you have a promise or generator returned from a function, Jest waits
    for that promise to resolve before running tests as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect()`: In writing a test, you will need to check that a value meets certain
    conditions at the very least. `expect()` allows you to conditionally check a value
    with the help of matchers, which we will talk about in a little while. It is noteworthy
    that there are situations whereby a single test case could have multiple `expect()`
    functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Matchers`: Jest uses matchers to test value validation. A matcher lets you
    test values in different ways to make the right assertion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assertion`: An assertion is defined as an expression that contains testable
    logic to verify assumptions made by programmers about a specific piece of code.
    This allows you to identify errors and other defects in your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, with all these functions and terms well defined, let’s write our first
    test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `bizza-test` working directory, create a `__tests__` folder. Jest
    searches your working directory for `__tests__` or a test suite file ending with
    `.test.js` or `.spec.js`, and then it runs the file or all the files in the `__tests__`
    folder. The `__tests__`, `.test.js`, and `.spec.js` trio are test naming conventions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To name the test directory in this book, we will adopt the naming convention
    `__tests__` case; create a `__tests__` directory inside `path/to/bizza-test/`.
    This is the folder we will keep the testing files in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create `basicFunctions.js` inside the `bizza-test` directory and add the
    following snippet to `basicFunctions.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This snippet depicts a small JS function that multiplies two numbers together.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside `__tests__`, create a test suite file, `basicFunctions.test.js`, and
    paste the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s briefly explain the working of the preceding test file code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first line imports the `basicFunctions.js` module we want to test into scope.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Test()` sets the test case description with its function to verify that the
    multiplication of `9` and `5` equals `45`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toBe(45)` lets us know we expect to have `45` as the expected result. If it’s
    anything else, the test will fail.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, inside the Terminal, run the `npm` `test` command.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output after running the `npm` `test` command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Showing the screenshot for the test case output](img/Figure_7.2_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Showing the screenshot for the test case output
  prefs: []
  type: TYPE_NORMAL
- en: The preceding demonstrates how testing works in Jest.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with these solid fundamentals on how we test simple JS functions, let’s
    dive into unit-testing React components.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of Jest’s useful functions can be found here: [https://jestjs.io/docs/api](https://jestjs.io/docs/api).'
  prefs: []
  type: TYPE_NORMAL
- en: A list of commonly used matchers can also be found at [https://jestjs.io/docs/expect](https://jestjs.io/docs/expect).
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing React components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is hinged on the component-driven development philosophy, and testing
    a unit of a React component further takes us closer to the basic elements that
    make up a React component. The essence of unit testing is to test an individual
    chunk of code to ascertain that the functionality works as expected by the users.
  prefs: []
  type: TYPE_NORMAL
- en: As stated earlier, in unit testing, you systematically go through three stages
    – planning, case scripting, and testing. Writing a unit test should be thoroughly
    planned, descriptive test cases should be implemented, and assertions should be
    clear enough to be understood by everyone on the team.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we delve into unit-testing a React component, how do we know
    what to test in a React application? It is simple. Every React application has
    one or more components with specific functions. So, what to test in a React application
    is subjective. Every project is different and so is the functionality of the applications.
    The application features to test in an e-commerce web application will be different
    from features of interest to test in a social media application.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are general rules of thumb for selecting features to test. In
    application development, testing provides us with confidence and assurance that
    our software product still works as expected, even with code refactoring. It then
    boils down basically to the business values of those functions, in addition to
    those functionalities that significantly impact the end user experience with your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: To test React components, there is another simple, useful testing tool called
    RTL. RTL can be used along with Jest to achieve React components testing objectives.
    RTL lets you test your component units just as a real user of your application
    would interact with your application UI.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas Jest is a test runner to find tests in a testing environment, run the
    tests, and affirm whether the tests fail or pass, RTL provides utility functions
    on top of VDOM. You will come across methods such as `render()` to simulate the
    rendering of components, `fireEvent` to dispatch a desired event as if a user
    interacts with the browser, and a screen to query the rendered elements.
  prefs: []
  type: TYPE_NORMAL
- en: RTL also uses the `waitFor()` method to wait for asynchronous codes and `expect()`,
    which is a function used for making assertions, determining whether the expected
    outcomes match the actual outcomes, and indicating success or failure.With a React
    project set up using `npx create-react-app`, you don’t have to explicitly install
    RTL. In a real-world application development environment, you would want to test
    that your components work as expected. RTL facilitates a simulation of how users
    would interact with your component.
  prefs: []
  type: TYPE_NORMAL
- en: This is achievable with the in-built utility in RTL that allows you to write
    tests that interact with DOM nodes directly, without actually rendering React
    components. Shortly, we will dive into the implementation of how RTL closely mimics
    how humans can interact with a React application UI in both stateless and stateful
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by writing a simple unit test to check whether a component renders.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a unit test for a stateless component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For testing purposes, let’s create a fresh React test project with `npx create-react-app
    bizzatest`. Delete some of the boilerplate files and let the directory structure
    appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `App.js` file should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Index.js` file should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the testing environment set up, let’s create a stateless component
    and write a unit test to check whether `WelcomeScreen.js` renders the `WelcomeScreen.js`
    will render the intended text paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: Follow the proceeding steps to create the component, and unit-test it for the
    presence of the specified paragraph text.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a WelcomeScreen.jsx component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s create a `src/WelcomeScreen.jsx` component and add the proceeding code
    snippet. This component displays the `<``h1>React</h1>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating a test case file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside the `src/__tests__` folder, create a test case file and name it `WelcomeScreen.test.js`.
    Use it to store all your test cases. You can also write your test in each of your
    component’s folders. However, in this case, we will store it inside the `src/__tests__`
    folder. Add the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let’s briefly discuss what is happening in the preceding snippet.
  prefs: []
  type: TYPE_NORMAL
- en: The `render`, `screen`, and `cleanup` utilities are imported from `@testing-library/react`.
    `render` helps you to virtually render a component in a container that is appended
    to the body of the HTML document (DOM).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `screen` object from RTL provides you with methods to find the rendered
    DOM elements to make the necessary assertions. Essentially, `screen` is used to
    interact with rendered components, and the `cleanup` function is used to clean
    up the rendered component after each test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `WelcomeScreen` component is imported as a required file for the test. This
    is the component to be tested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `afterEach()` method is added to unmount every rendered component test before
    the next component is rendered to prevent memory leaks. The `afterEach()` block
    is a Jest life cycle method that runs after each test. In this case, it calls
    the `cleanup` function to clean up any rendered components after each test. Using
    this cleanup utility from TRL is regarded as a best practice in React component
    testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `test()` function defines the actual test, named `"should show Welcome text
    to screen"`, and a callback function to hold the test case. The test first calls
    the `render` function to render the `WelcomeScreen` component. Then, it uses the
    `screen.getByText` function to get the DOM element that contains the text `expect()`
    function is then used to verify that the text is in the document, using the `toBeInTheDocument`
    matcher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `WelcomeScreen` component is rendered, we expect it to contain **Welcome
    to Bizza** **Conference Platform**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, run the test with `npm test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – A screenshot showing failed test case output](img/Figure_7.3_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – A screenshot showing failed test case output
  prefs: []
  type: TYPE_NORMAL
- en: As expected, the test failed. The paragraph text in the RTL-simulated rendered
    container in `WelcomeScreen.jsx` is `<h1>React</h1>` and not `<h1>Welcome to Bizza`
    `Conference Platform</h1>`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the WelcomeScreen component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s now update `WelcomeScreen.jsx` with the expected text to be rendered
    on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome, the test passed! The updated test report now shows a passed test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – A screenshot showing a passed test case output](img/Figure_7.4_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – A screenshot showing a passed test case output
  prefs: []
  type: TYPE_NORMAL
- en: 'You can write unit tests for the elements of your various components and use
    the appropriate queries from RTL. These RTL queries allow you to find elements
    in the same way that users of your application will interact with your UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getByRole()`: This function is used to locate an element by its role attribute,
    such as button, link, checkbox, radio, and heading. The `getByRole()` function
    is useful for testing the accessibility of a component, as well as for general
    testing purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getByLabelText()`: This function is used to locate a form element that is
    associated with a label element using the `for` attribute. `getByLabelText()`
    is useful for testing form components and their accessibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getByPlaceholderText()`: This function is used to locate an input element
    by its placeholder attribute. `getByPlaceholderText()` is useful for testing input
    fields and their behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getByText()`: This function is used to locate an element by its text content.
    `getByText()` is useful for testing the rendering of specific text or locating
    buttons or links that are identified by their text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getByDisplayValue()`: This function is used to locate a form element by its
    displayed value, such as an input or select element that has a pre-filled value.
    `getByDisplayValue()` is useful for testing form components and their behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getByAltText()`: This function is used to locate an image element by its `alt`
    attribute, which provides a textual description of the image. `getByAltText()`
    is useful for testing the accessibility of images in a component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getByTitle()`: This function is used to locate an element by its `title` attribute.
    The `getByTitle()` is useful for testing the accessibility and behavior of elements
    that have a `title` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getByTestId()`: This function is used to locate an element by its `data-testid`
    attribute. `getByTestId()` is useful for testing specific elements that are identified
    by a unique test ID, without relying on other attributes such as class or ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s now examine how you can write a unit test for a stateful component. We
    will make use of a speaker card and test its units to our satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a unit test for a stateful component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `components` folder, create a stateful component named `SpeakerCard`.
    The `SpeakerCard` component is a functional component that renders a card with
    information about a speaker. The component takes a `speaker` object as a prop,
    which contains properties such as the speaker’s name, occupation, company, phone
    number, and email address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the following snippet shows the test snippet for the `SpeakerCard` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet presented is explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: The component takes a `speaker` object as a prop, which contains properties
    such as the speaker’s `name`, `occupation`, `company`, `phone number`, and `email
    address`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component uses the `useState` hook to manage a Boolean state variable called
    `showDetails`, which controls whether additional details about the speaker are
    shown or hidden. The `toggleDetails` function toggles the value of the `showDetails`
    variable when the toggle button is clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `showDetails` variable is `true`, the component renders additional details
    about the speaker, including their email and phone number, within a nested `div`
    element with a `data-testid` attribute of `test-details`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `toggleDetails()` function’s initial state is `false`; when the toggle button
    is clicked, the state changes to `true`. The `data-testid` attribute in `<div
    data-testid="card">` is used to identify the DOM node that you test. The `data-testid`
    attribute has `card` as its value. This value allows `expect()`, a Jest utility,
    to make assertions about whether the test fails or passes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the toggle button, we set the `data-testid` attribute to `toggle-test`
    to assert that no button has been clicked yet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `data-testid="test-details"` is used to assert that the toggle button is
    clicked and details are displayed on the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditionally, when `showDetails` is set to `true`, email and phone details
    are displayed on the screen; otherwise, they would be hidden.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s write the unit test to show that `<SpeakerCard/>` can render on screen
    and when the toggle button is clicked, we can see more details about the `speaker`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `/src/__tests__/`, create a test file, `SpeakerCard.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s go over the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SpeakerCard` component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import `SpeakerCard.jsx` as a required file for the test.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the `test()` function from the `@testing-library/react` library with
    a `test` string describing what the test should do, which in this test case is
    `"should render the SpeakerCard component"`, and a function that contains the
    test code.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, import and use the `render` and `screen` utilities to simulate the rendering
    of the `<``SpeakerCard/>` component.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SpeakerCard` component accepts the props defined `speaker` object.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Query the node with `.getByTestId("card")` and assign its value to `card`. This
    allows you to access the DOM node needed to make an assertion. You can then use
    `expect()` from the Jest utility to ascertain that `<SpeakerCard/>` is rendered.
    Expect it to be defined!
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows a passed test for the rendering React component:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.5 – A screenshot showing a passed rendering component test](img/Figure_7.5_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – A screenshot showing a passed rendering component test
  prefs: []
  type: TYPE_NORMAL
- en: '`test()`function from the `@testing-library/react` library with a `test` string
    describing what the test should do, which in this test case is `"should make sure
    the toggle button shows or hides details"`, and a function that contains the test
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render the `SpeakerCard` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When no button is clicked, we expect the `data-testid` attribute value `toggle-test`
    to be *n*. The first assertion checks that the details section is not initially
    displayed, by checking that the element with `test-details data-testid` is not
    in the document. This is done using the `screen.queryByTestId()` function, which
    returns `null` if the element is not found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, import and use the `fireEvent` function. The `fireEvent.click(toggleButton)`
    simulates a user clicking on a toggle button in the `SpeakerCard` component. The
    `fireEvent` utility is a part of the `@testing-library/react` package, which provides
    a way of simulating user interactions in a test environment. The `fireEvent.click()`
    function is used to simulate a click on the toggle button. This will trigger the
    `toggleDetails` function in the component, which should show or hide the details
    section based on the `showDetails` state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query the node with `getByTestId` and assign its value to `toggleButton`. The
    `data-testid` attribute in the `SpeakerCard` component checks whether the details
    are displayed or not by searching for the `test-details` element using `screen.getByTestId`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We expect `test-details` from `data-testid` to display on the screen. If `test-details`
    is present in the document, the test passes; otherwise, the test fails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the testing of the toggle button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Screenshot showing the passed toggle button test](img/Figure_7.6_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Screenshot showing the passed toggle button test
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss TDD. This is a software development practice that encourages
    the testing of every functional unit of an application first before coding it.
  prefs: []
  type: TYPE_NORMAL
- en: TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD is a development paradigm that puts writing tests first. You write the test
    first and then write code to validate. The main purpose of TDD is rapid feedback.
    You write a test, run it, and it fails. You then write minimal code to pass the
    test. Once the test passes, you then refactor your code appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: These processes are iteratively repeated. Focusing on writing tests before code
    implementation allows developers to see the product from the users’ point of view,
    thus ensuring a working functionality that meets the users’ needs.
  prefs: []
  type: TYPE_NORMAL
- en: TDD enables software developers to come up with units of code base with a single
    responsibility – allowing code to do just one thing that works properly. However,
    the traditional approach is to code and then test. The idea of testing a code
    base at the end of the development process has been proven to be flawed and comes
    with a high cost of code maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Most software developers are more agile than test-driven. The urgent need to
    get a product to market with often unrealistic deadlines places less priority
    on the quality of the units of code powering such software products. With the
    traditional approach to development, you have errors sneaking into production.
  prefs: []
  type: TYPE_NORMAL
- en: As we all know, web applications in production do have additional features added
    from time to time based on business demands. However, without quality tests, you
    can have a situation where new feature addition or fixes create more problems.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with the traditional approach is having a software development
    team for a product different from the testing team. This separation of teams can
    make the long-time maintenance of the code base difficult and may result in a
    terrible decline in code quality, owing to a chaotic clash of intents.
  prefs: []
  type: TYPE_NORMAL
- en: With TDD, you and other stakeholders have proof that your code does work and
    is of high quality. Right now, we will wear the hat and shoes of a web developer
    who is agile and simultaneously test-driven. We will examine a case study where
    we build a login component as part of our *Bizza* project using a TDD methodology.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component development will comply with a TDD principle:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a single test case. This test will be expected to fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write minimal code that satisfies the test and makes it pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, refactor your code and run it to pass/fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These steps are repeated.
  prefs: []
  type: TYPE_NORMAL
- en: So, now let’s write our initial tests. We expect them to fail anyway. This is
    the essence of TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a single test case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `bizzatest` directory for testing, create the `bizzatest/src/components/Auth/SignInForm/SignInForm.jsx`
    component and update the file as follows. This is a `SignInForm` component with
    no labels and functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `App.js`, add the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run `npm s` to render the following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – A screenshot showing a rendered SignInForm component](img/Figure_7.7_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – A screenshot showing a rendered SignInForm component
  prefs: []
  type: TYPE_NORMAL
- en: In TDD, you want to start with a unit test of a component that will fail, and
    then work around to make it pass after the actual development of the component
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Check the *Technical requirements* section for this chapter to get the styles
    for this form component ([https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter07/05](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter07/05)).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s write and run the test for the `SignInForm` component.
  prefs: []
  type: TYPE_NORMAL
- en: Create the `test` file inside `bizzatest/src/__tests__/ SignInForm.test.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s explain the workings of the preceding snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Import { render, screen } from ''@testing-library/react''` brings to scope
    the `render` and `screen` functions in RTL. This allows us to render components
    with VDOM in the testing environment.'
  prefs: []
  type: TYPE_NORMAL
- en: The required `SignInForm` component file under test is then imported.
  prefs: []
  type: TYPE_NORMAL
- en: '`test("Email Address should be rendered to screen", () => {render(<SignInForm
    />)` defines a test case with a description and renders `SignInForm-component`.
    The `render()` method comes from the RTL. The same thing is repeated for the `Password`
    and `Sign In` buttons with the individual test case descriptions.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first test, the test checks that the `Email Address` label is rendered
    on the screen by using the `getByText()` method from `@testing-library/react`.
    The test passes if the label is found on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the second test, the test checks that the `Password` label is rendered on
    the screen by using the `getByText()` method. The test passes if the label is
    found on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The third test checks that the button with the text `SignIn` is rendered on
    the screen by using the `getByTestId()` method. The test passes if the button
    is found on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '`expect(linkElEmailInput).toBeInTheDocument()` is for the assertion. This is
    to verify that the values of the declared variables are present in the `SignInForm`
    component.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the Terminal, run the `npm test` command. The test case descriptions
    are shown here with failed statuses.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – A screenshot of a failed SignInForm test](img/Figure_7.8_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – A screenshot of a failed SignInForm test
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows a detailed report of the Jest test runner. It
    shows one test suite and three failed tests.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – A screenshot of the failed SignInForm component test](img/Figure_7.9_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – A screenshot of the failed SignInForm component test
  prefs: []
  type: TYPE_NORMAL
- en: Writing minimal code that satisfies the test and making it pass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, update the `SignInForm` component to meet the expectations of the test
    cases in the test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we refactored the code to pass the test as expected
    and complete the principle of TDD. The Jest test runner runs automatically and
    passes the test based on the refactoring of the `SignInForm` component.
  prefs: []
  type: TYPE_NORMAL
- en: In the following figure, we have the detailed Jest success report of our test-driven
    component development.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – A screenshot of a successful pass of the SignInForm component
    test](img/Figure_7.10_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – A screenshot of a successful pass of the SignInForm component
    test
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SignInForm` component now appears, as shown in *Figure 7**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – A screenshot of a rendered SignInForm component after passing
    the test](img/Figure_7.11_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – A screenshot of a rendered SignInForm component after passing
    the test
  prefs: []
  type: TYPE_NORMAL
- en: Code refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Code refactoring** is the process of modifying existing code to improve its
    quality, maintainability, and efficiency without changing its behavior. Code refactoring
    involves analyzing and improving the code structure, design, and implementation
    to make it easier to understand, modify, and maintain. Refactoring is typically
    done to improve code readability, remove code duplication, and increase performance.'
  prefs: []
  type: TYPE_NORMAL
- en: During code refactoring, it is important to test your code to ensure that any
    changes made do not affect the behavior of the system. The code is run multiple
    times after each refactoring step to ensure that it still passes all the positive
    tests or fails all the negative tests.
  prefs: []
  type: TYPE_NORMAL
- en: If a test fails when you expect it to pass, that means that the refactoring
    step introduced a bug and the code needs to be reverted to its previous state,
    or additional changes need to be made to fix the issue. Refactoring can be done
    manually, but there are also automated tools such as Jest, RTL, Enzyme, and React
    testing utilities that can help identify areas of the code that need refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring as a part of TDD methodology allows you to refactor your code and
    run it to pass/fail until you are confident in the test results. These code refactoring
    steps can be repeated as many times as desired.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s refactor `SignForm.test.js` and examine one of the ways you can refactor
    your test code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `test` file inside `bizzatest/src/__tests__/ RefactorSignInForm.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some of the changes that were made in the refactored test code:'
  prefs: []
  type: TYPE_NORMAL
- en: The tests were wrapped in a `describe` block to group them under the same heading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test()` was replaced with `it()` for consistency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The text matching was changed from `getByText` to `getByLabelText` for the email
    and password inputs, as this is a more appropriate way to target form inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getByTest` query for the `Signin` button was replaced with `getByRole`
    and a name option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is crucial to the successful deployment of an application product into
    production. In this chapter, we examined various testing types available, especially
    unit testing for code base quality and ease of maintainability. This ensures a
    lower cost of producing software with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored Jest, a Node test runner that delightfully tests JavaScript
    code and, by extension, React applications. The Jest testing framework ensures
    that you work in an integrated testing environment, with virtually all your testing
    tools in one place and only a stone’s throw away.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed RTL with its implementation and then, in depth, the unit testing
    of React components using Jest and RTL, which comes with the **Create React App**
    (**CRA**) boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: We wrote useful component tests to showcase the ability of the combined tools
    of Jest and TLR. Finally, we discussed a testing methodology, TDD, in software
    development and how it can be used in React-based applications with examples.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will temporarily shift the focus of this book and delve into the backend
    development aspect of full stack web development, which is what this book is all
    about. We will begin a backend application in the next chapter, discussing SQL
    and data modeling.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 – Backend Development with Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Part 2* of our book, where we will delve into the dynamics of backend
    development with Flask. In this section, we will explore the fundamental concepts
    and techniques used in modern web development using the Flask framework.
  prefs: []
  type: TYPE_NORMAL
- en: You will gain the knowledge and tools necessary to tackle the complexities of
    backend development. From setting up your Flask environment to designing efficient
    RESTful APIs, implementing database integration, and integrating React frontends
    with Flask, we will cover it all.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this part, you will have a solid grasp of Flask’s core concepts
    and be well on your way to becoming a proficient full stack web developer. Let’s
    embark on this exciting journey together!
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18554_08.xhtml#_idTextAnchor158), *SQL and Data Modeling*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18554_09.xhtml#_idTextAnchor186), *API Development and Documentation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18554_10.xhtml#_idTextAnchor221), *Integrating React Frontend
    with the Flask Backend*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18554_11.xhtml#_idTextAnchor232), *Fetching and Displaying
    Data in a React-Flask Application*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18554_12.xhtml#_idTextAnchor252), *Authentication and Authorization*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B18554_13.xhtml#_idTextAnchor273), *Error Handling*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B18554_14.xhtml#_idTextAnchor285), *Modular Architecture – The
    Power of Blueprints*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B18554_15.xhtml#_idTextAnchor298), *Flask Unit Testing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B18554_16.xhtml#_idTextAnchor328), *Containerization and Flask
    Application Deployment*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
