- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: React Unit Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 单元测试
- en: We sufficiently discussed the fundamentals of React in the preceding chapters.
    You have been exposed to React tools and resources to master modern frontend techniques
    in your full stack development journey. We explored in-depth useful information
    required to build rich interactive interfaces with React. We discussed the topics
    of components, props and state, JSX, event handling, forms, and routing in React.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的章节中充分讨论了 React 的基础知识。你已经接触到了 React 工具和资源，以便在完整的全栈开发旅程中掌握现代前端技术。我们深入探讨了构建丰富交互式界面所需的
    React 的有用信息。我们讨论了 React 中的组件、属性和状态、JSX、事件处理、表单和路由等主题。
- en: In this chapter, we will focus on unit testing in React applications, a type
    of software testing that focuses on isolated piece(s) of code. Also, we will explore
    **Jest**, a Node-based test runner. The test runner allows you to discover test
    files, run tests, and find out whether tests passed or failed automatically. You
    will then end with a report in a very clear, expressive, and human-readable format.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于 React 应用程序中的单元测试，这是一种专注于隔离代码片段的软件测试类型。我们还将探索基于 Node 的测试运行器 **Jest**。测试运行器允许你发现测试文件、运行测试，并自动找出测试是否通过或失败。你将以一个非常清晰、表达丰富且易于阅读的格式结束报告。
- en: Jest is a popular testing framework developed with React in mind. The project
    was formally owned by *Meta*, the same company behind React. However, with the
    recent transfer of Jest from Meta to the *OpenJs Foundation*, Jest now has an
    independent core team working actively on it to ensure stability, security, and
    code bases that can stand the test of time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 是一个针对 React 开发的流行测试框架。该项目最初由 *Meta* 公司拥有，该公司也是 React 的背后公司。然而，随着 Jest 从
    Meta 转移到 *OpenJs Foundation*，Jest 现在有一个独立的内核团队正在积极工作，以确保其稳定性、安全性和经得起时间考验的代码库。
- en: In addition, we will briefly examine a useful testing tool in the React ecosystem
    – the **React Testing Library** (**RTL**). This library provides us with arrays
    of methods to virtually run tests on React components.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将简要探讨 React 生态系统中的一个有用的测试工具——**React 测试库**（**RTL**）。这个库为我们提供了一系列方法，可以在虚拟环境中对
    React 组件进行测试。
- en: Finally, in this chapter, we will deep-dive into **test-driven development**
    (**TDD**), a software development paradigm that places priority on test implementation
    before actual coding. The coding and testing are interlaced. Testing always comes
    first, although it is obviously not a fun part of the software development process.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在本章中，我们将深入探讨**测试驱动开发**（**TDD**），这是一种软件开发范式，它将测试实现放在实际编码之前。编码和测试是交织在一起的。测试始终是第一位的，尽管它显然不是软件开发过程中的有趣部分。
- en: Most experienced developers still struggle with testing just as beginners do.
    Companies have different policies around testing, but in real-world development,
    you can’t have industrial-strength web applications without testing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是经验丰富的开发者，在测试方面仍然会像初学者一样遇到困难。公司对测试有不同的政策，但在现实世界的开发中，没有测试就无法拥有工业级的 Web 应用程序。
- en: Testing ensures that you follow the best practice of the software development
    life cycle and that you and your application end users have confidence in your
    web application functionalities. With appropriate testing, the features of your
    web application will perform efficiently as expected.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 测试确保你遵循软件开发生命周期的最佳实践，并且你和你的应用程序最终用户对你的 Web 应用程序功能有信心。通过适当的测试，你的 Web 应用程序的功能将像预期的那样高效运行。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is software testing?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是软件测试？
- en: Introducing Jest
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest 简介
- en: Writing tests in Jest
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Jest 中编写测试
- en: Unit-testing React components
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试 React 组件
- en: TDD
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter07](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter07)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在 GitHub 上找到：[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter07](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter07)
- en: What is software testing?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是软件测试？
- en: '**Software testing** is a process that ensures all the pieces of code in software
    or application development work as expected by all stakeholders. The process of
    testing is one of the key phases in software development life cycles that explains
    the standardized methodology of designing and developing an application.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件测试**是一个确保软件或应用开发中的所有代码片段都能按照所有利益相关者的预期工作的过程。测试过程是软件开发生命周期中的关键阶段之一，它解释了设计和开发应用程序的标准方法论。'
- en: Software testing ensures that web applications have fewer bugs, technical requirements
    are implemented as expected efficiently, development costs are reduced, and ultimately,
    business needs are met.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试确保网络应用程序具有更少的错误，技术需求被高效地按预期实现，开发成本降低，最终满足业务需求。
- en: Interestingly, testing, if carried out effectively, usually gives software engineers
    the confidence to know full well that the product they ship to production is maintainable,
    readable, reliable, and well structured.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果有效地执行，测试通常会给软件工程师足够的信心，使他们确信他们向生产环境推出的产品是可维护的、可读的、可靠的，并且结构良好。
- en: This creates less panic about possible costly bugs in an application, which
    may cost a company embarrassment or the erosion of customers’ confidence. There
    are various types of software testing worthy of note – unit testing, integration
    testing, performance testing, usability testing, acceptance testing, and regression
    testing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这减少了关于应用程序中可能出现的昂贵错误所带来的恐慌，这些错误可能使公司蒙羞或损害客户信心。有许多值得注意的软件测试类型——单元测试、集成测试、性能测试、可用性测试、验收测试和回归测试。
- en: Let’s briefly discuss the types of testing that we have in software development
    to refresh our minds and have a solid base to build on in the subsequent sections.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论一下我们在软件开发中拥有的测试类型，以刷新我们的思维，并为后续章节提供一个坚实的基础。
- en: '**Unit testing**: In this type of testing, the smallest piece of code or unit
    in software or application development is tested. In unit testing, you systematically
    go through three stages – planning, case scripting, and testing. You are primarily
    concerned with the functionality of the independent units of your application.
    In the *Unit-testing React components* section, we will deep-dive into unit testing
    and how you can implement unit tests in your React applications.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：在这种测试中，软件或应用开发中最小的代码片段或单元被测试。在单元测试中，你系统地经过三个阶段——规划、用例脚本编写和测试。你主要关注你应用程序中独立单元的功能。在“单元测试React组件”部分，我们将深入探讨单元测试以及如何在你的React应用程序中实现单元测试。'
- en: '**Integration testing**: In this type of testing, groups of individual units
    of codes are combined and tested for effective interaction with one another.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：在这种测试中，将代码的各个独立单元组合起来，并测试它们之间的有效交互。'
- en: '**Performance testing**: In this type of testing, the speed and effectiveness
    of your application are tested against a given workload. This approach is used
    to identify early bottlenecks in the smooth running of a software application.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能测试**：在这种测试中，你的应用程序的速度和效率与给定的负载进行测试。这种方法用于识别软件应用程序平稳运行中的早期瓶颈。'
- en: '**Usability testing**: In this type of testing, intended users of your application
    are allowed to get a feel for your product. The feedback from direct evaluations
    of your application design through usability testing ensures you are able to capture
    users’ frustration while interacting with your application so early. The report
    on usability testing can also provide other useful insights that might improve
    your product.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性测试**：在这种测试中，你的应用程序的预期用户被允许体验你的产品。通过可用性测试对应用程序设计进行直接评估的反馈确保你能够尽早捕捉到用户在使用应用程序时的挫败感。可用性测试的报告还可以提供其他可能改进产品的有用见解。'
- en: '**Acceptance testing**: In this type of testing, client satisfaction is gauged
    – customer requirements are evaluated against a developed software or application.
    The customer is able to check that those requirements are captured properly and
    work as expected.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验收测试**：在这种测试中，客户满意度被衡量——客户需求与开发的软件或应用程序进行比较。客户能够检查这些需求是否被正确捕捉并按预期工作。'
- en: '**Regression testing**: In this type of testing, we check whether code changes
    occasioned by the addition of new functionality into your software or application
    do not break down the previously tested working functionality. Regression prevents
    the introduction of errors or unintended side effects as a result of modifying
    the code base of your application. With regression testing, all test cases are
    rerun so that no new bugs are introduced.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归测试**：在这种测试中，我们检查将新功能添加到你的软件或应用程序中引起的代码更改是否破坏了之前测试过的正常功能。回归测试可以防止在修改应用程序代码库时引入错误或意外的副作用。通过回归测试，所有测试用例都会重新运行，以确保不会引入新的错误。'
- en: Next, we will explore one of the leading testing frameworks you can confidently
    work with when testing the functionality of your frontend applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索你可以在测试前端应用程序的功能时，有信心与之合作的领先测试框架之一。
- en: Introducing Jest
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Jest
- en: '**Jest** is an open source, robust, well-documented, fast, and safe JavaScript
    testing framework. Jest provides the tools and resources that you need to have
    absolute confidence in your JavaScript code base. Testing is fundamental to quality
    code writing, and Jest with almost zero configuration delightfully handles test
    implementation.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jest**是一个开源的、健壮的、文档齐全的、快速且安全的JavaScript测试框架。Jest提供了你需要的工具和资源，让你对你的JavaScript代码库有绝对的信心。测试是编写高质量代码的基础，而Jest几乎无需配置，就能愉快地处理测试实现。'
- en: Jest is very popular in the JavaScript community. You can write tests in Jest
    leveraging its feature-rich set of APIs, such as matchers, mocked functions, code
    coverage, and snapshot testing. Jest can be used to test React components, and
    the React team actually recommends Jest to test React projects.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Jest在JavaScript社区中非常受欢迎。你可以利用Jest丰富的API集编写测试，例如匹配器、模拟函数、代码覆盖率以及快照测试。Jest可以用来测试React组件，实际上React团队也推荐使用Jest来测试React项目。
- en: Jest is a Node.js test runner, which means that the tests always run in a Node
    environment. Jest is built with performance in mind. You can run a suite of tests
    in parallel effectively. The Jest toolkit comes with code coverage that enables
    you to have information about tested and untested files in your project. And when
    your tests fail, you are provided with insightful information about why they failed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Jest是一个Node.js测试运行器，这意味着测试总是在Node环境中运行。Jest在构建时考虑了性能。你可以有效地并行运行一系列测试。Jest工具包附带代码覆盖率，它使你能够了解项目中已测试和未测试的文件。并且当你的测试失败时，你会得到关于为什么它们失败的有见地的信息。
- en: Let’s set up a Jest environment for testing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为测试设置一个Jest环境。
- en: Setting up the Jest environment
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Jest环境
- en: Node.js is required for Jest to run. Jest comes with the `npx create-react-app`
    command we used to the `create-react-app` boilerplate code in [*Chapter 2*](B18554_02.xhtml#_idTextAnchor038),
    *Getting Started* *with React*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Jest运行需要Node.js。Jest附带了我们用于[*第2章*](B18554_02.xhtml#_idTextAnchor038)，“*使用React*入门”中`create-react-app`脚手架代码的`npx
    create-react-app`命令。
- en: 'In this section, we will create a new working folder named `bizza-test` to
    better explore how Jest works with JavaScript functions, before we move on to
    using it in the unit testing of React components:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个名为`bizza-test`的新工作文件夹，以便在继续使用它进行React组件的单元测试之前，更好地探索Jest如何与JavaScript函数协同工作：
- en: 'Inside `path/to/bizza-test/`, let’s execute the following commands in the terminal:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`path/to/bizza-test/`目录下，让我们在终端中执行以下命令：
- en: Run `npm init -y` in the command terminal.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令终端中运行`npm init -y`。
- en: Install Jest as a dependency in the working folder (`bizza-test`) with `npm
    install --``save-dev jest`.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm install --save-dev jest`在工作文件夹（`bizza-test`）中安装Jest作为依赖项。
- en: 'Update the `package.json` to be able to run Jest via `npm test`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`package.json`以能够通过`npm test`运行Jest：
- en: '[PRE0]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The complete `package.json` should look like this:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的`package.json`应如下所示：
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The following is a screenshot showing the installation of Jest in the terminal.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了在终端中安装Jest的过程。
- en: '![Figure 7.1 – A screenshot of the Jest library setup](img/Figure_7.1_B18554.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – Jest库设置截图](img/Figure_7.1_B18554.jpg)'
- en: Figure 7.1 – A screenshot of the Jest library setup
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – Jest库设置截图
- en: With this set, you are on the right path to run your test. Next, we will explore
    some key testing terminologies and write the actual tests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完成后，你就可以正确地运行测试了。接下来，我们将探讨一些关键的测试术语，并编写实际的测试。
- en: Writing tests in Jest
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Jest中编写测试
- en: 'Now that we have set up the test running environment, let’s briefly understand
    some of the keywords we will encounter in this section. In Jest, you have some
    test keywords and functions from the Jest API to structure your tests; let’s examine
    them:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了测试运行环境，让我们简要了解一下在这个部分我们将遇到的一些关键字。在 Jest 中，你有一些来自 Jest API 的测试关键字和函数来构建你的测试；让我们来检查它们：
- en: '`test()` or `it()`: This is a descriptive unit test or test case. It contains
    three parameters – a descriptive test case string, a function that contains the
    expectations to test, and an optional timeout argument, specifying how long to
    wait before aborting a test case. The default timeout is five seconds:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test()` 或 `it()`: 这是一个描述性的单元测试或测试用例。它包含三个参数——一个描述性的测试用例字符串、一个包含要测试的期望值的函数，以及一个可选的超时参数，指定在终止测试用例之前要等待多长时间。默认超时时间为五秒：'
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`describe()`: This groups related test cases together. It is used to group
    several related tests and describe their behaviors. `describe()` takes two parameters
    – a string describing your test group and a callback function that holds test
    cases:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe()`: 这将相关测试用例组合在一起。它用于组合几个相关的测试并描述它们的行为。`describe()` 接受两个参数——一个描述你的测试组的字符串和一个包含测试用例的回调函数：'
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`beforeAll()`: This function is run before any of the tests in the test file
    run. And when you have a promise or generator returned from a function, Jest waits
    for that promise to resolve before running tests:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeAll()`: 这个函数在测试文件中的任何测试运行之前执行。当你从函数中返回一个 promise 或 generator 时，Jest
    会等待该 promise 解决后再运行测试：'
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`beforeEach()`: This function runs before each of the tests in the test file
    runs. When you have a promise or generator returned from a function, Jest waits
    for that promise to resolve before running tests as well.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach()`: 这个函数在测试文件中的每个测试运行之前执行。当你从函数中返回一个 promise 或 generator 时，Jest
    也会等待该 promise 解决后再运行测试。'
- en: '`expect()`: In writing a test, you will need to check that a value meets certain
    conditions at the very least. `expect()` allows you to conditionally check a value
    with the help of matchers, which we will talk about in a little while. It is noteworthy
    that there are situations whereby a single test case could have multiple `expect()`
    functions:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect()`: 在编写测试时，你至少需要检查一个值是否符合某些条件。`expect()` 允许你使用匹配器有条件地检查一个值，我们稍后会讨论匹配器。值得注意的是，存在这样的情况，一个单独的测试用例可能有多个
    `expect()` 函数：'
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Matchers`: Jest uses matchers to test value validation. A matcher lets you
    test values in different ways to make the right assertion.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Matchers`: Jest 使用匹配器来测试值验证。匹配器让你以不同的方式测试值，以便做出正确的断言。'
- en: '`Assertion`: An assertion is defined as an expression that contains testable
    logic to verify assumptions made by programmers about a specific piece of code.
    This allows you to identify errors and other defects in your application.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assertion`: 断言被定义为包含可测试逻辑的表达式，用于验证程序员对特定代码块所做的假设。这允许你识别应用程序中的错误和其他缺陷。'
- en: 'So, with all these functions and terms well defined, let’s write our first
    test suite:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在所有这些函数和术语都定义清楚之后，让我们编写我们的第一个测试套件：
- en: Inside the `bizza-test` working directory, create a `__tests__` folder. Jest
    searches your working directory for `__tests__` or a test suite file ending with
    `.test.js` or `.spec.js`, and then it runs the file or all the files in the `__tests__`
    folder. The `__tests__`, `.test.js`, and `.spec.js` trio are test naming conventions.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bizza-test` 工作目录中，创建一个 `__tests__` 文件夹。Jest 会搜索你的工作目录中的 `__tests__` 或以 `.test.js`
    或 `.spec.js` 结尾的测试套件文件，然后运行该文件或 `__tests__` 文件夹中的所有文件。`__tests__`、`.test.js` 和
    `.spec.js` 这三个是测试命名约定。
- en: To name the test directory in this book, we will adopt the naming convention
    `__tests__` case; create a `__tests__` directory inside `path/to/bizza-test/`.
    This is the folder we will keep the testing files in.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了命名本书中的测试目录，我们将采用 `__tests__` 的命名约定；在 `path/to/bizza-test/` 内创建一个 `__tests__`
    目录。这是我们存放测试文件的地方。
- en: 'Now, create `basicFunctions.js` inside the `bizza-test` directory and add the
    following snippet to `basicFunctions.js`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `bizza-test` 目录中创建 `basicFunctions.js` 并将以下片段添加到 `basicFunctions.js` 中：
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This snippet depicts a small JS function that multiplies two numbers together.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个片段描述了一个简单的 JS 函数，用于将两个数字相乘。
- en: 'Inside `__tests__`, create a test suite file, `basicFunctions.test.js`, and
    paste the following code snippet:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `__tests__` 中创建一个测试套件文件，`basicFunctions.test.js`，并粘贴以下代码片段：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s briefly explain the working of the preceding test file code:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们简要解释一下前面的测试文件代码的工作原理：
- en: The first line imports the `basicFunctions.js` module we want to test into scope.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行将我们要测试的`basicFunctions.js`模块导入到作用域中。
- en: '`Test()` sets the test case description with its function to verify that the
    multiplication of `9` and `5` equals `45`.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Test()`函数设置测试用例描述，并使用其功能来验证`9`乘以`5`等于`45`。'
- en: '`toBe(45)` lets us know we expect to have `45` as the expected result. If it’s
    anything else, the test will fail.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toBe(45)`让我们知道我们期望得到`45`作为预期结果。如果结果不是`45`，测试将失败。'
- en: Then, inside the Terminal, run the `npm` `test` command.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在终端中运行`npm test`命令。
- en: 'The following screenshot shows the output after running the `npm` `test` command:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的截图显示了运行`npm test`命令后的输出：
- en: '![Figure 7.2 – Showing the screenshot for the test case output](img/Figure_7.2_B18554.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 显示测试用例输出的截图](img/Figure_7.2_B18554.jpg)'
- en: Figure 7.2 – Showing the screenshot for the test case output
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 显示测试用例输出的截图
- en: The preceding demonstrates how testing works in Jest.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容展示了Jest中测试是如何工作的。
- en: Now, with these solid fundamentals on how we test simple JS functions, let’s
    dive into unit-testing React components.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这些关于如何测试简单JS函数的坚实基础，让我们深入了解React组件的单元测试。
- en: Note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'A list of Jest’s useful functions can be found here: [https://jestjs.io/docs/api](https://jestjs.io/docs/api).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这里找到Jest的有用函数列表：[https://jestjs.io/docs/api](https://jestjs.io/docs/api)。
- en: A list of commonly used matchers can also be found at [https://jestjs.io/docs/expect](https://jestjs.io/docs/expect).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这里找到常用匹配器的列表：[https://jestjs.io/docs/expect](https://jestjs.io/docs/expect)。
- en: Unit-testing React components
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试React组件
- en: React is hinged on the component-driven development philosophy, and testing
    a unit of a React component further takes us closer to the basic elements that
    make up a React component. The essence of unit testing is to test an individual
    chunk of code to ascertain that the functionality works as expected by the users.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: React依赖于组件驱动的开发哲学，测试React组件的单元进一步使我们接近构成React组件的基本元素。单元测试的本质是测试单个代码块，以确保其功能符合用户的预期。
- en: As stated earlier, in unit testing, you systematically go through three stages
    – planning, case scripting, and testing. Writing a unit test should be thoroughly
    planned, descriptive test cases should be implemented, and assertions should be
    clear enough to be understood by everyone on the team.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在单元测试中，你需要系统地经历三个阶段——规划、用例脚本编写和测试。编写单元测试应该进行彻底的规划，应该实现描述性的测试用例，并且断言应该足够清晰，以便团队中的每个人都能理解。
- en: However, before we delve into unit-testing a React component, how do we know
    what to test in a React application? It is simple. Every React application has
    one or more components with specific functions. So, what to test in a React application
    is subjective. Every project is different and so is the functionality of the applications.
    The application features to test in an e-commerce web application will be different
    from features of interest to test in a social media application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们深入探讨React组件的单元测试之前，我们如何知道在React应用程序中要测试什么？很简单。每个React应用程序都有一个或多个具有特定功能的组件。因此，在React应用程序中要测试的内容是主观的。每个项目都是不同的，应用程序的功能也是如此。在电子商务Web应用程序中要测试的应用程序功能将不同于在社交媒体应用程序中要测试的感兴趣的功能。
- en: However, there are general rules of thumb for selecting features to test. In
    application development, testing provides us with confidence and assurance that
    our software product still works as expected, even with code refactoring. It then
    boils down basically to the business values of those functions, in addition to
    those functionalities that significantly impact the end user experience with your
    application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在选择要测试的功能时有一些一般性的经验法则。在应用程序开发中，测试为我们提供了信心和保证，即我们的软件产品仍然按预期工作，即使在代码重构之后也是如此。这基本上归结为那些函数的商业价值，以及那些对最终用户使用应用程序的体验有显著影响的功能。
- en: To test React components, there is another simple, useful testing tool called
    RTL. RTL can be used along with Jest to achieve React components testing objectives.
    RTL lets you test your component units just as a real user of your application
    would interact with your application UI.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试React组件，还有一个简单而有用的测试工具，称为RTL。RTL可以与Jest一起使用，以实现React组件测试目标。RTL允许你像你的应用程序的实际用户一样测试你的组件单元，与你的应用程序UI交互。
- en: Whereas Jest is a test runner to find tests in a testing environment, run the
    tests, and affirm whether the tests fail or pass, RTL provides utility functions
    on top of VDOM. You will come across methods such as `render()` to simulate the
    rendering of components, `fireEvent` to dispatch a desired event as if a user
    interacts with the browser, and a screen to query the rendered elements.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Jest 是一个测试运行器，用于在测试环境中查找测试、运行测试并确认测试是否失败或通过，但 RTL 在 VDOM 上提供了实用函数。你将遇到如 `render()`
    这样的方法来模拟组件的渲染，`fireEvent` 来派发用户与浏览器交互时希望触发的事件，以及一个用于查询渲染元素的 `screen`。
- en: RTL also uses the `waitFor()` method to wait for asynchronous codes and `expect()`,
    which is a function used for making assertions, determining whether the expected
    outcomes match the actual outcomes, and indicating success or failure.With a React
    project set up using `npx create-react-app`, you don’t have to explicitly install
    RTL. In a real-world application development environment, you would want to test
    that your components work as expected. RTL facilitates a simulation of how users
    would interact with your component.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'RTL 还使用 `waitFor()` 方法等待异步代码，以及 `expect()`，这是一个用于进行断言的函数，用于确定预期的结果是否与实际结果匹配，并指示成功或失败。使用
    `npx create-react-app` 设置的 React 项目，你不需要显式安装 RTL。在实际的应用程序开发环境中，你希望测试你的组件是否按预期工作。RTL
    促进了模拟用户如何与你的组件交互。 '
- en: This is achievable with the in-built utility in RTL that allows you to write
    tests that interact with DOM nodes directly, without actually rendering React
    components. Shortly, we will dive into the implementation of how RTL closely mimics
    how humans can interact with a React application UI in both stateless and stateful
    components.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过 RTL 内置的实用工具实现，它允许你编写直接与 DOM 节点交互的测试，而无需实际渲染 React 组件。简而言之，我们很快将深入了解 RTL
    如何在无状态和有状态组件中模拟人类与 React 应用程序 UI 的交互。
- en: Let’s start by writing a simple unit test to check whether a component renders.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写一个简单的单元测试来检查组件是否渲染开始。
- en: Writing a unit test for a stateless component
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为无状态组件编写单元测试
- en: 'For testing purposes, let’s create a fresh React test project with `npx create-react-app
    bizzatest`. Delete some of the boilerplate files and let the directory structure
    appear as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，让我们使用 `npx create-react-app bizzatest` 创建一个新的 React 测试项目。删除一些样板文件，让目录结构如下所示：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `App.js` file should contain the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.js` 文件应包含以下代码：'
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Index.js` file should contain the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Index.js` 文件应包含以下代码：'
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we have the testing environment set up, let’s create a stateless component
    and write a unit test to check whether `WelcomeScreen.js` renders the `WelcomeScreen.js`
    will render the intended text paragraph.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了测试环境，让我们创建一个无状态组件，并编写一个单元测试来检查 `WelcomeScreen.js` 是否渲染了预期的文本段落。
- en: Follow the proceeding steps to create the component, and unit-test it for the
    presence of the specified paragraph text.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建组件，并对其是否存在指定的段落文本进行单元测试。
- en: Creating a WelcomeScreen.jsx component
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个 WelcomeScreen.jsx 组件
- en: 'Let’s create a `src/WelcomeScreen.jsx` component and add the proceeding code
    snippet. This component displays the `<``h1>React</h1>` element:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 `src/WelcomeScreen.jsx` 组件，并添加以下代码片段。此组件显示 `<h1>React</h1>` 元素：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating a test case file
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建测试用例文件
- en: 'Inside the `src/__tests__` folder, create a test case file and name it `WelcomeScreen.test.js`.
    Use it to store all your test cases. You can also write your test in each of your
    component’s folders. However, in this case, we will store it inside the `src/__tests__`
    folder. Add the following code snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/__tests__` 文件夹内，创建一个测试用例文件，并将其命名为 `WelcomeScreen.test.js`。使用它来存储所有的测试用例。你也可以在每个组件的文件夹中编写测试。然而，在这种情况下，我们将将其存储在
    `src/__tests__` 文件夹中。添加以下代码片段：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let’s briefly discuss what is happening in the preceding snippet.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论一下前面代码片段中发生的事情。
- en: The `render`, `screen`, and `cleanup` utilities are imported from `@testing-library/react`.
    `render` helps you to virtually render a component in a container that is appended
    to the body of the HTML document (DOM).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render`、`screen` 和 `cleanup` 工具是从 `@testing-library/react` 导入的。`render` 帮助你在
    HTML 文档（DOM）的 body 中附加一个容器中虚拟渲染一个组件。'
- en: The `screen` object from RTL provides you with methods to find the rendered
    DOM elements to make the necessary assertions. Essentially, `screen` is used to
    interact with rendered components, and the `cleanup` function is used to clean
    up the rendered component after each test.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RTL 提供的 `screen` 对象为您提供了查找渲染 DOM 元素的方法，以便进行必要的断言。本质上，`screen` 用于与渲染组件交互，而 `cleanup`
    函数用于在每个测试后清理渲染组件。
- en: The `WelcomeScreen` component is imported as a required file for the test. This
    is the component to be tested.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WelcomeScreen` 组件作为测试所需的文件被导入。这是要测试的组件。'
- en: The `afterEach()` method is added to unmount every rendered component test before
    the next component is rendered to prevent memory leaks. The `afterEach()` block
    is a Jest life cycle method that runs after each test. In this case, it calls
    the `cleanup` function to clean up any rendered components after each test. Using
    this cleanup utility from TRL is regarded as a best practice in React component
    testing.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterEach()` 方法被添加到卸载每个渲染的组件测试之前，以便在渲染下一个组件之前防止内存泄漏。`afterEach()` 块是 Jest
    生命周期方法，在每个测试之后运行。在这种情况下，它调用 `cleanup` 函数来清理每个测试后渲染的任何组件。使用来自 TRL 的此清理实用工具被视为 React
    组件测试的最佳实践。'
- en: The `test()` function defines the actual test, named `"should show Welcome text
    to screen"`, and a callback function to hold the test case. The test first calls
    the `render` function to render the `WelcomeScreen` component. Then, it uses the
    `screen.getByText` function to get the DOM element that contains the text `expect()`
    function is then used to verify that the text is in the document, using the `toBeInTheDocument`
    matcher.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test()` 函数定义了实际的测试，命名为 `"should show Welcome text to screen"`，以及一个回调函数来包含测试用例。测试首先调用
    `render` 函数来渲染 `WelcomeScreen` 组件。然后，它使用 `screen.getByText` 函数获取包含文本的 DOM 元素，使用
    `expect()` 函数来验证文本是否在文档中，使用 `toBeInTheDocument` 匹配器。'
- en: When the `WelcomeScreen` component is rendered, we expect it to contain **Welcome
    to Bizza** **Conference Platform**.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `WelcomeScreen` 组件被渲染时，我们期望它包含 **Welcome to Bizza** **Conference Platform**。
- en: Now, run the test with `npm test`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `npm test` 运行测试。
- en: 'The following screenshot shows the output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![Figure 7.3 – A screenshot showing failed test case output](img/Figure_7.3_B18554.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 展示失败的测试用例输出](img/Figure_7.3_B18554.jpg)'
- en: Figure 7.3 – A screenshot showing failed test case output
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 展示失败的测试用例输出
- en: As expected, the test failed. The paragraph text in the RTL-simulated rendered
    container in `WelcomeScreen.jsx` is `<h1>React</h1>` and not `<h1>Welcome to Bizza`
    `Conference Platform</h1>`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，测试失败了。在 `WelcomeScreen.jsx` 中 RTL 模拟的渲染容器中的段落文本是 `<h1>React</h1>`，而不是
    `<h1>Welcome to Bizza` `Conference Platform</h1>`。
- en: Updating the WelcomeScreen component
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新 WelcomeScreen 组件
- en: 'Let’s now update `WelcomeScreen.jsx` with the expected text to be rendered
    on the screen:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新 `WelcomeScreen.jsx`，以包含要在屏幕上渲染的预期文本：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Awesome, the test passed! The updated test report now shows a passed test:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，测试通过了！更新的测试报告现在显示一个通过测试：
- en: '![Figure 7.4 – A screenshot showing a passed test case output](img/Figure_7.4_B18554.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 展示通过测试用例输出的截图](img/Figure_7.4_B18554.jpg)'
- en: Figure 7.4 – A screenshot showing a passed test case output
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 展示通过测试用例输出的截图
- en: 'You can write unit tests for the elements of your various components and use
    the appropriate queries from RTL. These RTL queries allow you to find elements
    in the same way that users of your application will interact with your UI:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为您的各种组件的元素编写单元测试，并使用 RTL 的适当查询。这些 RTL 查询允许您以用户与应用程序 UI 交互相同的方式查找元素：
- en: '`getByRole()`: This function is used to locate an element by its role attribute,
    such as button, link, checkbox, radio, and heading. The `getByRole()` function
    is useful for testing the accessibility of a component, as well as for general
    testing purposes.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getByRole()`: 此函数用于通过其角色属性定位元素，例如按钮、链接、复选框、单选按钮和标题。`getByRole()` 函数对于测试组件的可访问性以及一般测试目的都很有用。'
- en: '`getByLabelText()`: This function is used to locate a form element that is
    associated with a label element using the `for` attribute. `getByLabelText()`
    is useful for testing form components and their accessibility.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getByLabelText()`: 此函数用于通过 `for` 属性定位与标签元素关联的表单元素。`getByLabelText()` 对于测试表单组件及其可访问性非常有用。'
- en: '`getByPlaceholderText()`: This function is used to locate an input element
    by its placeholder attribute. `getByPlaceholderText()` is useful for testing input
    fields and their behavior.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getByPlaceholderText()`: 此函数用于通过其占位符属性定位输入元素。`getByPlaceholderText()`对于测试输入字段及其行为非常有用。'
- en: '`getByText()`: This function is used to locate an element by its text content.
    `getByText()` is useful for testing the rendering of specific text or locating
    buttons or links that are identified by their text.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getByText()`: 此函数用于通过其文本内容定位元素。`getByText()`对于测试特定文本的渲染或定位通过其文本识别的按钮或链接非常有用。'
- en: '`getByDisplayValue()`: This function is used to locate a form element by its
    displayed value, such as an input or select element that has a pre-filled value.
    `getByDisplayValue()` is useful for testing form components and their behavior.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getByDisplayValue()`: 此函数用于通过其显示值定位表单元素，例如具有预填充值的输入或选择元素。`getByDisplayValue()`对于测试表单组件及其行为非常有用。'
- en: '`getByAltText()`: This function is used to locate an image element by its `alt`
    attribute, which provides a textual description of the image. `getByAltText()`
    is useful for testing the accessibility of images in a component.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getByAltText()`: 此函数用于通过其`alt`属性定位图像元素，该属性提供了图像的文本描述。`getByAltText()`对于测试组件中图像的可用性非常有用。'
- en: '`getByTitle()`: This function is used to locate an element by its `title` attribute.
    The `getByTitle()` is useful for testing the accessibility and behavior of elements
    that have a `title` attribute.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getByTitle()`: 此函数用于通过其`title`属性定位元素。`getByTitle()`对于测试具有`title`属性的元素的可用性和行为非常有用。'
- en: '`getByTestId()`: This function is used to locate an element by its `data-testid`
    attribute. `getByTestId()` is useful for testing specific elements that are identified
    by a unique test ID, without relying on other attributes such as class or ID.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getByTestId()`: 此函数用于通过其`data-testid`属性定位元素。`getByTestId()`对于测试通过唯一测试ID识别的特定元素非常有用，而不依赖于其他属性，如class或ID。'
- en: Let’s now examine how you can write a unit test for a stateful component. We
    will make use of a speaker card and test its units to our satisfaction.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何编写有状态组件的单元测试。我们将使用演讲者卡片并测试其单元，直到我们满意。
- en: Writing a unit test for a stateful component
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写有状态组件的单元测试
- en: In the `components` folder, create a stateful component named `SpeakerCard`.
    The `SpeakerCard` component is a functional component that renders a card with
    information about a speaker. The component takes a `speaker` object as a prop,
    which contains properties such as the speaker’s name, occupation, company, phone
    number, and email address.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`components`文件夹中，创建一个名为`SpeakerCard`的有状态组件。`SpeakerCard`组件是一个函数组件，它渲染一个包含演讲者信息的卡片。该组件接受一个`speaker`对象作为属性，该对象包含诸如演讲者的姓名、职业、公司、电话号码和电子邮件地址等属性。
- en: 'Now, the following snippet shows the test snippet for the `SpeakerCard` component:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以下代码片段显示了`SpeakerCard`组件的测试片段：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code snippet presented is explained here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提供的代码片段在此处解释：
- en: The component takes a `speaker` object as a prop, which contains properties
    such as the speaker’s `name`, `occupation`, `company`, `phone number`, and `email
    address`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件接受一个`speaker`对象作为属性，该对象包含诸如演讲者的`name`、`occupation`、`company`、`phone number`和`email
    address`等属性。
- en: The component uses the `useState` hook to manage a Boolean state variable called
    `showDetails`, which controls whether additional details about the speaker are
    shown or hidden. The `toggleDetails` function toggles the value of the `showDetails`
    variable when the toggle button is clicked.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件使用`useState`钩子来管理一个名为`showDetails`的布尔状态变量，该变量控制是否显示关于演讲者的额外详细信息。当切换按钮被点击时，`toggleDetails`函数会切换`showDetails`变量的值。
- en: If the `showDetails` variable is `true`, the component renders additional details
    about the speaker, including their email and phone number, within a nested `div`
    element with a `data-testid` attribute of `test-details`.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`showDetails`变量为`true`，组件将在具有`data-testid`属性为`test-details`的嵌套`div`元素中渲染关于演讲者的额外详细信息，包括他们的电子邮件和电话号码。
- en: The `toggleDetails()` function’s initial state is `false`; when the toggle button
    is clicked, the state changes to `true`. The `data-testid` attribute in `<div
    data-testid="card">` is used to identify the DOM node that you test. The `data-testid`
    attribute has `card` as its value. This value allows `expect()`, a Jest utility,
    to make assertions about whether the test fails or passes.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the toggle button, we set the `data-testid` attribute to `toggle-test`
    to assert that no button has been clicked yet.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `data-testid="test-details"` is used to assert that the toggle button is
    clicked and details are displayed on the screen.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditionally, when `showDetails` is set to `true`, email and phone details
    are displayed on the screen; otherwise, they would be hidden.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s write the unit test to show that `<SpeakerCard/>` can render on screen
    and when the toggle button is clicked, we can see more details about the `speaker`
    object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `/src/__tests__/`, create a test file, `SpeakerCard.test.js`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s go over the preceding code snippet:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '`SpeakerCard` component.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import `SpeakerCard.jsx` as a required file for the test.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the `test()` function from the `@testing-library/react` library with
    a `test` string describing what the test should do, which in this test case is
    `"should render the SpeakerCard component"`, and a function that contains the
    test code.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, import and use the `render` and `screen` utilities to simulate the rendering
    of the `<``SpeakerCard/>` component.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SpeakerCard` component accepts the props defined `speaker` object.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Query the node with `.getByTestId("card")` and assign its value to `card`. This
    allows you to access the DOM node needed to make an assertion. You can then use
    `expect()` from the Jest utility to ascertain that `<SpeakerCard/>` is rendered.
    Expect it to be defined!
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows a passed test for the rendering React component:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.5 – A screenshot showing a passed rendering component test](img/Figure_7.5_B18554.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – A screenshot showing a passed rendering component test
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '`test()`function from the `@testing-library/react` library with a `test` string
    describing what the test should do, which in this test case is `"should make sure
    the toggle button shows or hides details"`, and a function that contains the test
    code.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render the `SpeakerCard` component.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When no button is clicked, we expect the `data-testid` attribute value `toggle-test`
    to be *n*. The first assertion checks that the details section is not initially
    displayed, by checking that the element with `test-details data-testid` is not
    in the document. This is done using the `screen.queryByTestId()` function, which
    returns `null` if the element is not found.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, import and use the `fireEvent` function. The `fireEvent.click(toggleButton)`
    simulates a user clicking on a toggle button in the `SpeakerCard` component. The
    `fireEvent` utility is a part of the `@testing-library/react` package, which provides
    a way of simulating user interactions in a test environment. The `fireEvent.click()`
    function is used to simulate a click on the toggle button. This will trigger the
    `toggleDetails` function in the component, which should show or hide the details
    section based on the `showDetails` state.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，导入并使用`fireEvent`函数。`fireEvent.click(toggleButton)`模拟用户在`SpeakerCard`组件中点击切换按钮。`fireEvent`实用工具是`@testing-library/react`包的一部分，它提供了一种在测试环境中模拟用户交互的方法。`fireEvent.click()`函数用于模拟点击切换按钮。这将触发组件中的`toggleDetails`函数，该函数应根据`showDetails`状态显示或隐藏详细信息部分。
- en: Query the node with `getByTestId` and assign its value to `toggleButton`. The
    `data-testid` attribute in the `SpeakerCard` component checks whether the details
    are displayed or not by searching for the `test-details` element using `screen.getByTestId`.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getByTestId`查询节点并将其值分配给`toggleButton`。`SpeakerCard`组件中的`data-testid`属性通过使用`screen.getByTestId`搜索`test-details`元素来检查是否显示详细信息。
- en: We expect `test-details` from `data-testid` to display on the screen. If `test-details`
    is present in the document, the test passes; otherwise, the test fails.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们期望`data-testid`中的`test-details`在屏幕上显示。如果文档中存在`test-details`，则测试通过；否则，测试失败。
- en: 'The following screenshot shows the testing of the toggle button:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了切换按钮的测试：
- en: '![Figure 7.6 – Screenshot showing the passed toggle button test](img/Figure_7.6_B18554.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 展示通过切换按钮测试的截图](img/Figure_7.6_B18554.jpg)'
- en: Figure 7.6 – Screenshot showing the passed toggle button test
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 展示通过切换按钮测试的截图
- en: Next, we will discuss TDD. This is a software development practice that encourages
    the testing of every functional unit of an application first before coding it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论TDD。这是一种软件开发实践，它鼓励在编码之前首先测试应用程序的每个功能单元。
- en: TDD
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD
- en: TDD is a development paradigm that puts writing tests first. You write the test
    first and then write code to validate. The main purpose of TDD is rapid feedback.
    You write a test, run it, and it fails. You then write minimal code to pass the
    test. Once the test passes, you then refactor your code appropriately.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一种将编写测试放在首位的开发范式。你先写测试，然后编写代码来验证。TDD的主要目的是快速反馈。你写一个测试，运行它，然后它失败。然后你编写最小的代码来通过测试。一旦测试通过，你然后适当地重构你的代码。
- en: These processes are iteratively repeated. Focusing on writing tests before code
    implementation allows developers to see the product from the users’ point of view,
    thus ensuring a working functionality that meets the users’ needs.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过程是迭代重复的。在代码实现之前专注于编写测试，使开发者能够从用户的角度看待产品，从而确保一个符合用户需求的工作功能。
- en: TDD enables software developers to come up with units of code base with a single
    responsibility – allowing code to do just one thing that works properly. However,
    the traditional approach is to code and then test. The idea of testing a code
    base at the end of the development process has been proven to be flawed and comes
    with a high cost of code maintenance.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: TDD使软件开发者能够创建具有单一职责的代码库单元 – 允许代码只做一件正确的事情。然而，传统的做法是先编码再测试。在开发过程结束时测试代码库的想法已被证明是错误的，并且伴随着高昂的代码维护成本。
- en: Most software developers are more agile than test-driven. The urgent need to
    get a product to market with often unrealistic deadlines places less priority
    on the quality of the units of code powering such software products. With the
    traditional approach to development, you have errors sneaking into production.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数软件开发者比测试驱动更敏捷。将产品推向市场并经常面临不切实际的截止日期的迫切需求，使得对支撑这些软件产品的代码单元的质量关注较少。使用传统的开发方法，错误会悄悄地进入生产环境。
- en: As we all know, web applications in production do have additional features added
    from time to time based on business demands. However, without quality tests, you
    can have a situation where new feature addition or fixes create more problems.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，基于业务需求，生产中的Web应用程序确实会不时添加额外的功能。然而，如果没有质量测试，新功能添加或修复可能会带来更多问题。
- en: Another problem with the traditional approach is having a software development
    team for a product different from the testing team. This separation of teams can
    make the long-time maintenance of the code base difficult and may result in a
    terrible decline in code quality, owing to a chaotic clash of intents.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: With TDD, you and other stakeholders have proof that your code does work and
    is of high quality. Right now, we will wear the hat and shoes of a web developer
    who is agile and simultaneously test-driven. We will examine a case study where
    we build a login component as part of our *Bizza* project using a TDD methodology.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The component development will comply with a TDD principle:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Write a single test case. This test will be expected to fail.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write minimal code that satisfies the test and makes it pass.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, refactor your code and run it to pass/fail.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These steps are repeated.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: So, now let’s write our initial tests. We expect them to fail anyway. This is
    the essence of TDD.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Writing a single test case
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `bizzatest` directory for testing, create the `bizzatest/src/components/Auth/SignInForm/SignInForm.jsx`
    component and update the file as follows. This is a `SignInForm` component with
    no labels and functionalities:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Inside `App.js`, add the following code snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, run `npm s` to render the following component:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – A screenshot showing a rendered SignInForm component](img/Figure_7.7_B18554.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – A screenshot showing a rendered SignInForm component
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: In TDD, you want to start with a unit test of a component that will fail, and
    then work around to make it pass after the actual development of the component
    features.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Check the *Technical requirements* section for this chapter to get the styles
    for this form component ([https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter07/05](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter07/05)).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s write and run the test for the `SignInForm` component.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Create the `test` file inside `bizzatest/src/__tests__/ SignInForm.test.js`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the file as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s explain the workings of the preceding snippet:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '`Import { render, screen } from ''@testing-library/react''` brings to scope
    the `render` and `screen` functions in RTL. This allows us to render components
    with VDOM in the testing environment.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The required `SignInForm` component file under test is then imported.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '`test("Email Address should be rendered to screen", () => {render(<SignInForm
    />)` defines a test case with a description and renders `SignInForm-component`.
    The `render()` method comes from the RTL. The same thing is repeated for the `Password`
    and `Sign In` buttons with the individual test case descriptions.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: In the first test, the test checks that the `Email Address` label is rendered
    on the screen by using the `getByText()` method from `@testing-library/react`.
    The test passes if the label is found on the screen.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: In the second test, the test checks that the `Password` label is rendered on
    the screen by using the `getByText()` method. The test passes if the label is
    found on the screen.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The third test checks that the button with the text `SignIn` is rendered on
    the screen by using the `getByTestId()` method. The test passes if the button
    is found on the screen.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '`expect(linkElEmailInput).toBeInTheDocument()` is for the assertion. This is
    to verify that the values of the declared variables are present in the `SignInForm`
    component.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the Terminal, run the `npm test` command. The test case descriptions
    are shown here with failed statuses.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – A screenshot of a failed SignInForm test](img/Figure_7.8_B18554.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – A screenshot of a failed SignInForm test
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows a detailed report of the Jest test runner. It
    shows one test suite and three failed tests.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – A screenshot of the failed SignInForm component test](img/Figure_7.9_B18554.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – A screenshot of the failed SignInForm component test
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Writing minimal code that satisfies the test and making it pass
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, update the `SignInForm` component to meet the expectations of the test
    cases in the test suite:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding snippet, we refactored the code to pass the test as expected
    and complete the principle of TDD. The Jest test runner runs automatically and
    passes the test based on the refactoring of the `SignInForm` component.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: In the following figure, we have the detailed Jest success report of our test-driven
    component development.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – A screenshot of a successful pass of the SignInForm component
    test](img/Figure_7.10_B18554.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – A screenshot of a successful pass of the SignInForm component
    test
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SignInForm` component now appears, as shown in *Figure 7**.11*:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – A screenshot of a rendered SignInForm component after passing
    the test](img/Figure_7.11_B18554.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – A screenshot of a rendered SignInForm component after passing
    the test
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Code refactoring
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Code refactoring** is the process of modifying existing code to improve its
    quality, maintainability, and efficiency without changing its behavior. Code refactoring
    involves analyzing and improving the code structure, design, and implementation
    to make it easier to understand, modify, and maintain. Refactoring is typically
    done to improve code readability, remove code duplication, and increase performance.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: During code refactoring, it is important to test your code to ensure that any
    changes made do not affect the behavior of the system. The code is run multiple
    times after each refactoring step to ensure that it still passes all the positive
    tests or fails all the negative tests.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: If a test fails when you expect it to pass, that means that the refactoring
    step introduced a bug and the code needs to be reverted to its previous state,
    or additional changes need to be made to fix the issue. Refactoring can be done
    manually, but there are also automated tools such as Jest, RTL, Enzyme, and React
    testing utilities that can help identify areas of the code that need refactoring.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring as a part of TDD methodology allows you to refactor your code and
    run it to pass/fail until you are confident in the test results. These code refactoring
    steps can be repeated as many times as desired.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Let’s refactor `SignForm.test.js` and examine one of the ways you can refactor
    your test code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `test` file inside `bizzatest/src/__tests__/ RefactorSignInForm.test.js`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the file as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here are some of the changes that were made in the refactored test code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The tests were wrapped in a `describe` block to group them under the same heading
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test()` was replaced with `it()` for consistency'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The text matching was changed from `getByText` to `getByLabelText` for the email
    and password inputs, as this is a more appropriate way to target form inputs
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getByTest` query for the `Signin` button was replaced with `getByRole`
    and a name option
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is crucial to the successful deployment of an application product into
    production. In this chapter, we examined various testing types available, especially
    unit testing for code base quality and ease of maintainability. This ensures a
    lower cost of producing software with confidence.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: We also explored Jest, a Node test runner that delightfully tests JavaScript
    code and, by extension, React applications. The Jest testing framework ensures
    that you work in an integrated testing environment, with virtually all your testing
    tools in one place and only a stone’s throw away.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: We discussed RTL with its implementation and then, in depth, the unit testing
    of React components using Jest and RTL, which comes with the **Create React App**
    (**CRA**) boilerplate code.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: We wrote useful component tests to showcase the ability of the combined tools
    of Jest and TLR. Finally, we discussed a testing methodology, TDD, in software
    development and how it can be used in React-based applications with examples.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will temporarily shift the focus of this book and delve into the backend
    development aspect of full stack web development, which is what this book is all
    about. We will begin a backend application in the next chapter, discussing SQL
    and data modeling.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 – Backend Development with Flask
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Part 2* of our book, where we will delve into the dynamics of backend
    development with Flask. In this section, we will explore the fundamental concepts
    and techniques used in modern web development using the Flask framework.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: You will gain the knowledge and tools necessary to tackle the complexities of
    backend development. From setting up your Flask environment to designing efficient
    RESTful APIs, implementing database integration, and integrating React frontends
    with Flask, we will cover it all.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得解决后端开发复杂性的知识和工具。从设置你的Flask环境到设计高效的RESTful API，实现数据库集成，以及将React前端与Flask集成，我们将涵盖所有内容。
- en: By the end of this part, you will have a solid grasp of Flask’s core concepts
    and be well on your way to becoming a proficient full stack web developer. Let’s
    embark on this exciting journey together!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 到这部分结束时，你将牢固掌握Flask的核心概念，并朝着成为一名熟练的全栈Web开发者迈进。让我们共同踏上这段激动人心的旅程吧！
- en: 'This part has the following chapters:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 8*](B18554_08.xhtml#_idTextAnchor158), *SQL and Data Modeling*'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18554_08.xhtml#_idTextAnchor158), *SQL和数据建模*'
- en: '[*Chapter 9*](B18554_09.xhtml#_idTextAnchor186), *API Development and Documentation*'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18554_09.xhtml#_idTextAnchor186), *API开发与文档*'
- en: '[*Chapter 10*](B18554_10.xhtml#_idTextAnchor221), *Integrating React Frontend
    with the Flask Backend*'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18554_10.xhtml#_idTextAnchor221), *整合React前端与Flask后端*'
- en: '[*Chapter 11*](B18554_11.xhtml#_idTextAnchor232), *Fetching and Displaying
    Data in a React-Flask Application*'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18554_11.xhtml#_idTextAnchor232), *在React-Flask应用程序中获取和显示数据*'
- en: '[*Chapter 12*](B18554_12.xhtml#_idTextAnchor252), *Authentication and Authorization*'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18554_12.xhtml#_idTextAnchor252), *身份验证和授权*'
- en: '[*Chapter 13*](B18554_13.xhtml#_idTextAnchor273), *Error Handling*'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18554_13.xhtml#_idTextAnchor273), *错误处理*'
- en: '[*Chapter 14*](B18554_14.xhtml#_idTextAnchor285), *Modular Architecture – The
    Power of Blueprints*'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B18554_14.xhtml#_idTextAnchor285), *模块化架构 – 蓝图的威力*'
- en: '[*Chapter 15*](B18554_15.xhtml#_idTextAnchor298), *Flask Unit Testing*'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B18554_15.xhtml#_idTextAnchor298), *Flask单元测试*'
- en: '[*Chapter 16*](B18554_16.xhtml#_idTextAnchor328), *Containerization and Flask
    Application Deployment*'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B18554_16.xhtml#_idTextAnchor328), *容器化与Flask应用程序部署*'
