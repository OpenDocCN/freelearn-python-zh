<html><head></head><body>
		<div><h1 id="_idParaDest-779" class="chapter-number"><a id="_idTextAnchor990"/>18</h1>
			<h1 id="_idParaDest-780"><a id="_idTextAnchor991"/>Automated Test Cases</h1>
			<p>When it comes to developing large applications, using automated test cases is good practice to improve the reliability of your module. This makes your module more robust. Every year, Odoo releases a new version of its software, and automated test cases are very helpful in detecting regression in your application, which may have been caused by a version upgrade. Luckily, any Odoo framework comes with different automated testing utilities. Odoo includes the following three main types of tests:</p>
			<ul>
				<li><strong class="bold">A Python test case</strong>: Used to test Python business logic</li>
				<li><strong class="bold">A JavaScript QUnit test</strong>: Used to test JavaScript implementation in Odoo</li>
				<li><strong class="bold">Tours</strong>: An integration test to check that Python and JavaScript work with each other properly</li>
			</ul>
			<p>In this chapter, we will cover the following recipes:</p>
			<ul>
				<li>Adding Python test cases</li>
				<li>Running tagged Python test cases</li>
				<li>Setting up Headless Chrome for client-side test cases</li>
				<li>Adding client-side QUnit test cases</li>
				<li>Adding tour test cases</li>
				<li>Running client-side test cases from the UI</li>
				<li>Debugging client-side test cases</li>
				<li>Generating videos/screenshots for failed test cases</li>
				<li>Populating random data for testing</li>
			</ul>
			<h1 id="_idParaDest-781"><a id="_idTextAnchor992"/>Technical requirements</h1>
			<p>In this chapter, we will look at all the test cases in detail. In order to cover all of the test cases in a single module, we have created a small module. Its Python definition is as follows:</p>
			<pre class="source-code">
import logging
from odoo import api, fields, models
from odoo.exceptions import UserError
from odoo.tools.translate import _
_logger = logging.getLogger(__name__)
class HostelRoom(models.Model):
    _name = 'hostel.room'
    _description = "Information about hostel Room"
    name = fields.Char(string="Hostel Name", required=True)
    room_no = fields.Char(string="Room Number", required=True)
    other_info = fields.Text("Other Information",
                             help="Enter more information")
    description = fields.Html('Description')
    room_rating = fields.Float('Hostel Average Rating', digits=(14, 4))
    member_ids = fields.Many2many('hostel.room.member', string='Members')
    state = fields.Selection([
        ('draft', 'Unavailable'),
        ('available', 'Available'),
        ('closed', 'Closed')],
        'State', default="draft")
    @api.model
    def is_allowed_transition(self, old_state, new_state):
        allowed = [('draft', 'available'),
                   ('available', 'closed'),
                   ('closed', 'draft')]
        return (old_state, new_state) in allowed
    def change_state(self, new_state):
        for room in self:
            if room.is_allowed_transition(room.state, new_state):
                room.state = new_state
            else:
                message = _('Moving from %s to %s is not allowed') % (room.state, new_state)
                raise UserError(message)
    def make_available(self):
        self.change_state('available')
        return True
    def make_closed(self):
        self.change_state('closed')
class HostelRoomMember(models.Model):
    _name = 'hostel.room.member'
    _inherits = {'res.partner': 'partner_id'}
    _description = "Hostel Room member"
    partner_id = fields.Many2one('res.partner', ondelete='cascade')
    date_start = fields.Date('Member Since')
    date_end = fields.Date('Termination Date')
    member_number = fields.Char()
    date_of_birth = fields.Date('Date of birth')</pre>			<p>The Python code given here will help us to write test cases for Python business cases.</p>
			<p>For JavaScript test cases, we have added the <code>int_color</code> widget from the <em class="italic">Creating custom widgets</em> recipe in <a href="B20997_15.xhtml#_idTextAnchor861"><em class="italic">Chapter 15</em></a>, <em class="italic">Web </em><em class="italic">Client Development</em>.</p>
			<p>You can grab this initial module from the GitHub repository of this room at the following link: <a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter18/00_initial_module">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter18/00_initial_module</a>.</p>
			<h1 id="_idParaDest-782"><a id="_idTextAnchor993"/>Adding Python test cases</h1>
			<p>Python test cases are <a id="_idIndexMarker1224"/>used to check the correctness of business logic. In <a href="B20997_05.xhtml#_idTextAnchor238"><em class="italic">Chapter 5</em></a>, <em class="italic">Basic Server-Side Development</em>, you saw how you can modify the business logic of our existing app. This makes it even more important, as customization might break the app’s functionality. In this chapter, we will write a test case to validate the business logic to change a hostel room’s state.</p>
			<h2 id="_idParaDest-783"><a id="_idTextAnchor994"/>Getting ready</h2>
			<p>We will use the <code>my_hostel</code> module from the <code>Chapter18/00_initial_module</code> directory of the GitHub repository.</p>
			<h2 id="_idParaDest-784"><a id="_idTextAnchor995"/>How to do it...</h2>
			<p>Follow these steps to add Python test cases to the <code>my_hostel</code> module:</p>
			<ol>
				<li>Add a new file, <code>tests/__init__.py</code>, as follows:<pre class="source-code">
from . import test_hostel_room_state</pre></li>				<li>Add a <code>tests/test_hostel_room_state.py</code> file, and then add the test case, as follows:<pre class="source-code">
from odoo.tests.common import TransactionCase
class TestHostelRoomState(TransactionCase):
    def setUp(self, *args, **kwargs):
        super(TestHostelRoomState, self).setUp(*args, **kwargs)
        self.partner_nikul = self.env['res.partner'].create({'name': 'Nikul Chaudhary'})
        self.partner_deepak = self.env['res.partner'].create({'name': 'Deepak Ahir'})
        self.member_ids = self.env['hostel.room.member'].create([
            {'partner_id': self.partner_nikul.id, 'member_number': '007'},
            {'partner_id': self.partner_deepak.id, 'member_number': '357'}])
        self.test_hostel_room = self.env['hostel.room'].create({
            'name': 'Hostel Room 01',
            'room_no': '1',
            'member_ids': [(6, 0, self.member_ids.ids)]
        })
    def test_button_available(self):
        """Make available button"""
        self.test_hostel_room.make_available()
        self.assertIn(self.partner_nikul, self.test_hostel_room.mapped('member_ids.partner_id'))
        self.assertEqual(
            self.test_hostel_room.state, 'available', 'Hostel Room state should changed to available')
    def test_button_closed(self):
        """Make closed button"""
        self.test_hostel_room.make_available()
        self.test_hostel_room.make_closed()
        self.assertEqual(
            self.test_hostel_room.state, 'closed', 'Hostel Room state should changed to closed')</pre></li>				<li>To run the test cases, start the Odoo server with the following option:<pre class="source-code">
<strong class="bold">./odoo-bin -c server.conf -d db_name -i my_hostel --test-enable</strong></pre></li>				<li>Now, check the <a id="_idIndexMarker1225"/>server log. You will find the following logs if our test cases ran successfully:<pre class="source-code">
<strong class="bold">INFO test odoo.addons.my_hostel.tests.test_hostel_room_state: Starting TestHostelRoomState.test_button_available ...</strong>
<strong class="bold">INFO test odoo.addons.my_hostel.tests.test_hostel_room_state: Starting TestHostelRoomState.test_button_closed ...</strong>
<strong class="bold">INFO test odoo.modules.loading: Module my_hostel loaded in 0.31s (incl. 0.05s test), 240 queries (+33 test, +240 other)</strong></pre></li>			</ol>
			<p>You will see the <code>ERROR</code> log instead of <code>INFO</code> if a test case fails or there is an error.</p>
			<h2 id="_idParaDest-785"><a id="_idTextAnchor996"/>How it works...</h2>
			<p>In Odoo, Python test cases are added to the <code>tests/</code> directory of the module. Odoo will automatically identify this directory and run the test under the folder.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><em class="italic">You also need to list your test case files in </em><code>tests/__init__.py.</code><em class="italic"> If you don’t do that, that test case will </em><em class="italic">not execute.</em></p>
			<p>Odoo uses <a id="_idIndexMarker1226"/>Python’s <code>unittest</code> for Python test cases. To learn more about <code>unittest</code>, refer to <a href="https://docs.python.org/3.5/library/unittest.html">https://docs.python.org/3.5/library/unittest.html</a>. Odoo provides the following helper classes:</p>
			<ul>
				<li>The <code>Common</code> class: This <a id="_idIndexMarker1227"/>class provides common methods and setup for test cases. It includes functionalities such as creating and managing database transactions during the tests.</li>
				<li>The <code>SavepointCase</code> class: This <a id="_idIndexMarker1228"/>extends the Common class.</li>
				<li>The <code>SavepointCase</code> provides additional features to handle savepoints during tests. This is useful when you want to roll back the changes made to the database during a test, ensuring that each test starts with a clean state,</li>
				<li>The <code>TransactionCase</code> class: This class extends <code>SavepointCase</code> and provides <a id="_idIndexMarker1229"/>transaction-related functionality. It helps to manage database transactions during the tests.</li>
				<li>The <code>HttpCase</code> class: This <a id="_idIndexMarker1230"/>class is used to test HTTP requests and responses. It allows you to simulate HTTP requests and test the responses.</li>
				<li>The <code>BaseCase</code> class: This is <a id="_idIndexMarker1231"/>a base class for various test cases in Odoo. It provides common functionality that can be reused in different test scenarios,</li>
				<li>The <code>SingleTransactionCase</code> class: This class extends <code>TransactionCase</code> and <a id="_idIndexMarker1232"/>ensures that each test case is executed within a single database transaction. This can be useful in scenarios where you want to isolate tests completely from each other.</li>
				<li>The <code>FormCase</code> class: This <a id="_idIndexMarker1233"/>class is used to test form views and their interactions. It provides methods to simulate user interactions with form views.</li>
				<li>The <code>FunctionCase</code> class: This class is designed to test server-side Python functions. It <a id="_idIndexMarker1234"/>helps in testing various functions and methods within the Odoo framework, wrapped over <code>unittest</code>.</li>
			</ul>
			<p>These classes simplify the process of developing test cases. In our case, we have used <code>TransactionCase</code>. Now, <code>TransactionCase</code> runs each test case method in a different transaction. Once a test case method runs successfully, a transaction is automatically rolled back. This means the next test case will not have any modification made by the previous test case.</p>
			<p>The class method <a id="_idIndexMarker1235"/>starts from <code>test_</code> and is considered a test case. In our example, we have added two test cases. This checks the methods that change the hostel room’s state. The <code>self.assertEqual</code> method (<code>assertEqual()</code> in Python) is a <code>unittest</code> library function that is used in unit testing to check the equality of two values. This function will take three parameters as input and return a Boolean value, depending upon the <code>assert</code> condition. If both input values are equal <code>assertEqual()</code> will return <code>true</code> else return <code>false</code>) is used to check whether the test case runs successfully. We have checked the hostel room state after performing operations on the hostel room’s record. So, if the developer makes a mistake and the method does <a id="_idIndexMarker1236"/>not change states as expected, the test case will fail.</p>
			<p class="callout-heading">Important information</p>
			<p class="callout"><em class="italic">Note that the </em><code>setUp()</code><em class="italic"> method will automatically call for every test case we run, so, in this recipe, we have added two test cases so that </em><code>setUp()</code><em class="italic"> will call twice. As per the code in this recipe, there will only be one record of the hostel room present during testing because, with </em><code>TransactionCase</code><em class="italic">, the transaction is rolled back with every </em><em class="italic">test case.</em></p>
			<p>In Python, a docstring is a string literal that occurs as the first statement in a module, function, class, or method definition. Docstrings are used to provide documentation about what a piece of code does. They serve as a form of inline documentation that can be accessed using various tools, such as the <code>help()</code> function.. This can be very helpful to check the status of a particular test case.</p>
			<h2 id="_idParaDest-786"><a id="_idTextAnchor997"/>There’s more...</h2>
			<p>The test suite provides the following additional test utility classes:</p>
			<ul>
				<li><code>SingleTransactionCase</code>: Test cases generated through this class will run all cases in a single transaction, so changes made from one test case will be available in a second test case. In this way, the transaction begins with the first test method and is only rolled back at the end of the last test case.</li>
				<li><code>SavepointCase</code>: This is the same as <code>SingleTransactionCase</code>, but in this case, test methods run inside a rolled-back save point, instead of having all test methods in a single transaction. This is used to create large test cases and make them faster, by generating test data only once. Here, we use the <code>setUpClass()</code> method to generate the initial test data.</li>
			</ul>
			<h1 id="_idParaDest-787"><a id="_idTextAnchor998"/>Running tagged Python test cases</h1>
			<p>When you run the Odoo server with the <code>--test-enabled</code> module name, the test cases run <a id="_idIndexMarker1237"/>immediately after the module is installed. If you want to run a test case after the installation of all the modules, or if you just want to run a test case for only one module, a <code>tagged()</code> decorator is the answer.</p>
			<p>In this recipe, we’ll show you how to utilize this decorator specifically for shaping test cases. It’s important to note that this decorator only applies to classes; it doesn’t affect functions or methods. Tags can be modified by adding a minus (-) sign as a prefix, which removes them instead of adding or selecting them. For example, if you want to prevent your test from being executed by default, you can remove the standard tag.</p>
			<h2 id="_idParaDest-788"><a id="_idTextAnchor999"/>Getting ready</h2>
			<p>For this recipe, we will use the <code>my_hostel</code> module from the last recipe. We will modify the sequence of the test case.</p>
			<h2 id="_idParaDest-789"><a id="_idTextAnchor1000"/>How to do it...</h2>
			<p>Follow these steps to add tags to the Python test cases:</p>
			<ol>
				<li>Add a <code>tagged()</code> decorator (such as the following) to the test class to run it after the <a id="_idIndexMarker1238"/>installation of all modules:<pre class="source-code">
from odoo.tests.common import TransactionCase, tagged
@tagged('-at_install', 'post_install')
class TestHostelRoomState(TransactionCase):
    def setUp(self, *args, **kwargs):
        super(TestHostelRoomState, self).setUp(*args, **kwargs)
        self.partner_nikul = self.env['res.partner'].create({'name': 'Nikul Chaudhary'})
        self.partner_deepak = self.env['res.partner'].create({'name': 'Deepak Ahir'})
        self.member_ids = self.env['hostel.room.member'].create([
            {'partner_id': self.partner_nikul.id, 'member_number': '007'},
            {'partner_id': self.partner_deepak.id, 'member_number': '357'}])
        self.test_hostel_room = self.env['hostel.room'].create({
            'name': 'Hostel Room 01',
            'room_no': '1',
            'member_ids': [(6, 0, self.member_ids.ids)]
        })
    def test_button_available(self):
        """Make available button"""
        self.test_hostel_room.make_available()
        self.assertIn(self.partner_nikul, self.test_hostel_room.mapped('member_ids.partner_id'))
        self.assertEqual(
            self.test_hostel_room.state, 'available', 'Hostel Room state should changed to available')
    def test_button_closed(self):
        """Make closed button"""
        self.test_hostel_room.make_available()
        self.test_hostel_room.make_closed()
        self.assertEqual(
            self.test_hostel_room.state, 'closed', 'Hostel Room state should changed to closed')</pre></li>				<li>After that, run the test case as follows, just like before:<pre class="source-code">
<strong class="bold">./odoo-bin -c server.conf -d db_name -i my_hostel --test-enable</strong></pre></li>				<li>Now, check <a id="_idIndexMarker1239"/>the server log. This time, you will see our test case log after the following logs, meaning that our test cases were run after all of the modules were installed, as follows:<pre class="source-code">
<strong class="bold">INFO test odoo.modules.loading: Module my_hostel loaded in 0.21s, 240 queries (+240 other)</strong>
<strong class="bold">INFO test odoo.modules.loading: Modules loaded</strong>
<strong class="bold">INFO test odoo.service.server: Starting post tests</strong>
<strong class="bold">INFO test odoo.addons.my_hostel.tests.test_hostel_room_state: Starting TestHostelRoomState.test_button_available ...</strong>
<strong class="bold">INFO test odoo.addons.my_hostel.tests.test_hostel_room_state: Starting TestHostelRoomState.test_button_closed ...</strong>
<strong class="bold">INFO test odoo.service.server: 2 post-tests in 0.04s, 36 queries</strong>
<strong class="bold">INFO test odoo.tests.stats: my_hostel: 4 tests 0.04s 36 queries</strong></pre></li>			</ol>
			<p>In these logs, the first line shows that nine modules were loaded. The second line shows that all requested <a id="_idIndexMarker1240"/>modules and their dependencies were installed successfully, and the third line shows that it will start running the test cases that are tagged as <code>post_install</code>.</p>
			<h2 id="_idParaDest-790"><a id="_idTextAnchor1001"/>How it works...</h2>
			<p>By default, all of the test cases are tagged with <code>standard</code>, <code>at_install</code>, and the current module’s technical name (in our case, the technical name is <code>my_hostel</code>). Consequently, if you do not use a <code>tagged()</code> decorator, your test case will have these three tags.</p>
			<p>In our case, we want to run the test case after installing all of the modules. To do so, we have added a <code>tagged()</code> decorator to the <code>TestHostelRoomState</code> class. By default, the test case has the <code>at_install</code> tag. Because of this tag, your test case will run immediately after the module is installed; it will not wait for other modules to be installed. We don’t want this, so to remove the <code>at_install</code> tag, we have added <code>-at_install</code> to the tagged function. The tags that are prefixed by <code>-</code> will remove that tag.</p>
			<p>By adding <code>-at_install</code> to the <code>tagged()</code> function, we stopped the test case execution after the module installation. As we haven’t specified any other tag in this, the test case won’t run.</p>
			<p>So, we have added a <code>post_install</code> tag. This tag specifies that the test case needs to be run after the installation of all modules is completed.</p>
			<p>As you have seen, all test cases are tagged with the <code>standard</code> tag, by default. Odoo will run all of the test cases tagged with the <code>standard</code> tag, in case you don’t want to run the specific test case all of the time and only want to run it when it is requested. To do so, you need to remove the <code>standard</code> tag by adding <code>-standard</code> to the <code>tagged()</code> decorator, and you need to add a custom tag like this:</p>
			<pre class="source-code">
@tagged('-standard', 'my_custom_tag')
class TestClass(TransactionCase):
...</pre>			<p>All of the <a id="_idIndexMarker1241"/>non-standard test cases will not run with the <code>--test-enable</code> option. To run the preceding test case, you need to use the <code>--test-tags</code> option, as follows (note that, here, we do not need to pass the <code>--test-enable</code> option explicitly):</p>
			<pre class="console">
./odoo-bin -c server.conf -d db_name -i my_hostel --test-tags=my_custom_tag</pre>			<h2 id="_idParaDest-791"><a id="_idTextAnchor1002"/>There’s more...</h2>
			<p>During the development of the test case, it is important to run the test case for just one module. By default, the technical name of the module is added as a tag, so you can use the module’s technical name with the <code>--test-tags</code> option. For example, if you want to run test cases for the <code>my_hostel</code> module, then you can run the server like this:</p>
			<pre class="console">
./odoo-bin -c server.conf -d db_name -i my_hostel --test-tags=my_hostel</pre>			<p>The command given here will run the test case in the <code>my_hostel</code> module, but it will still decide the sequence based on the <code>at_install</code> and <code>post_install</code> options.</p>
			<h1 id="_idParaDest-792"><a id="_idTextAnchor1003"/>Setting up Headless Chrome for client-side test cases</h1>
			<p>Odoo <a id="_idIndexMarker1242"/>employs Headless Chrome to execute JavaScript and tour test cases, facilitating the simulation of end-user environments. Headless Chrome, devoid of the complete UI, enables seamless execution of JavaScript test cases, ensuring a consistent testing environment.</p>
			<h2 id="_idParaDest-793"><a id="_idTextAnchor1004"/>How to do it...</h2>
			<p>You will need to install Chrome to enable a JavaScript test case. For the development of the modules, we will mostly use the desktop OS. Consequently, if you have a Chrome browser installed on your system, then there is no need to install it separately. You can run client-side test cases with desktop Chrome. Make sure that you have a Chrome version higher than Chrome 59. Odoo also supports the Chromium browser.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Headless Chrome client-side test cases work fine with macOS and Linux, but Odoo does not support Headless Chrome test cases on Windows.</p>
			<p>The situation changes slightly when you want to run test cases on the production server or Server <a id="_idIndexMarker1243"/>OS. Server OS does not have a GUI, so you need to install Chrome differently. If you are using a Debian-based OS, you can install Chromium with the following command:</p>
			<pre class="console">
apt-get install chromium-browser</pre>			<p class="callout-heading">Important information</p>
			<p class="callout"><em class="italic">Ubuntu 22.04 Server Edition has not enabled the </em><code>universe</code><em class="italic"> repository by default. So, it’s possible that installing </em><code>chromium-browser</code><em class="italic"> will show an installation candidate error. To fix this error, enable the </em><code>universe</code><em class="italic"> repository with the following command – </em><code>sudo </code><code>add-apt-repository universe</code><em class="italic">.</em></p>
			<p>Odoo also uses <code>websocket-client</code> Python library. To install it, use the following command:</p>
			<pre class="console">
pip3 install websocket-client</pre>			<p>Now, your system is ready to run client-side test cases.</p>
			<h2 id="_idParaDest-794"><a id="_idTextAnchor1005"/>How it works...</h2>
			<p>Odoo uses Headless Chrome for JavaScript test cases. The reason behind this is that it runs test cases in the background, so it can be run on Server OS, too. Headless Chrome prefers to run the Chrome browser in the background, without opening a GUI browser. Odoo opens a Chrome tab in the background and starts running the test cases in it. It also uses <strong class="bold">jQuery’s</strong> <strong class="bold">QUnit</strong> for JavaScript <a id="_idIndexMarker1245"/>test cases. In the next few recipes, we will create a QUnit test case for our custom JavaScript widgets.</p>
			<p>For test cases, Odoo opens Headless Chrome in a separate process, so to find out the status of <a id="_idIndexMarker1246"/>a test case running in that process, the Odoo server uses WebSockets. The <code>websocket-client</code> Python library is used to manage WebSockets to communicate with Chrome from the Odoo server.</p>
			<h1 id="_idParaDest-795"><a id="_idTextAnchor1006"/>Adding client-side QUnit test cases</h1>
			<p>Building new fields or views is very simple in Odoo. In just a few lines of XML, you can define a <a id="_idIndexMarker1247"/>new view. However, under the hood, it uses a lot of JavaScript. Modifying/adding new features on the client side is complex, and it might break a few things. Most client-side issues go unnoticed, as most errors are only displayed in the console. So, QUnit test cases are used in Odoo to check the correctness of different JavaScript components.</p>
			<p>QUnit is a JavaScript testing framework primarily used for client-side testing. It’s commonly associated with testing JavaScript code in web applications, particularly for frontend development. QUnit is often used to test the logic and behavior of JavaScript functions, modules, and components in a web browser environment.</p>
			<h2 id="_idParaDest-796"><a id="_idTextAnchor1007"/>Getting ready</h2>
			<p>For this recipe, we will continue using the <code>my_hostel</code> module from the previous recipe. We will add a QUnit test case for the <code>int_color</code> widget.</p>
			<h2 id="_idParaDest-797"><a id="_idTextAnchor1008"/>How to do it...</h2>
			<p>Follow these steps to add JavaScript test cases to the <code>int_color</code> widget:</p>
			<ol>
				<li>We have already implemented a widget for <code>int_color</code> using JavaScript in our module.</li>
				<li>Add <code>/static/tests/colorpicker_tests.js</code> with the following code:</li>
				<li>Create a <code>beforeEach</code> function <a id="_idIndexMarker1248"/>to load the data field-wise before applying the test case:<pre class="source-code">
/** @odoo-module */
import { registry } from "@web/core/registry";
import { session } from "@web/session";
import { uiService } from "@web/core/ui/ui_service";
import { makeView, setupViewRegistries} from "@web/../tests/views/helpers";
import { click, getFixture, patchWithCleanup } from "@web/../tests/helpers/utils";
const serviceRegistry = registry.category("services");
QUnit.module("Color Picker Widget Tests", (hooks) =&gt; {
    let serverData;
    let target;
    hooks.beforeEach(async function (assert) {
        target = getFixture();
        serverData = {
            models: {
                'hostel.room': {
                    fields: {
                        name: { string: "Hostel Name", type: "char" },
                        room_no: { string: "Room Number", type: "char" },
                        color: { string: "color", type: "integer"},
                    },
                    records: [{
                        id: 1,
                        name: "Hostel Room 01",
                        room_no: 1,
                        color: 1,
                    }, {
                        id: 2,
                        name: "Hostel Room 02",
                        room_no: 2,
                        color: 3
                    }],
                },
            },
            views: {
                "hostel.room,false,form": `&lt;form&gt;
                    &lt;field name="name"/&gt;
                    &lt;field name="room_no"/&gt;
                    &lt;field name="color" widget="int_color"/&gt;
                &lt;/form&gt;`,
            },
        };
        serviceRegistry.add("ui", uiService);
        setupViewRegistries();
    });</pre></li>				<li>Add a <code>QUnit</code> test case <a id="_idIndexMarker1249"/>for the color picker field, like this:<pre class="source-code">
    QUnit.module("IntColorField");
    QUnit.test("factor is applied in IntColorField", async function (assert) {
        const form = await makeView({
            serverData,
            type: "form",
            resModel: "hostel.room",
        });
        assert.containsOnce(target, '.o_field_int_color');
        assert.strictEqual(target.querySelectorAll(".o_int_color .o_color_pill").length, 10, "Color picker should have 10 pills");
        await click(target.querySelectorAll(".o_int_color .o_color_pill")[3]);
        assert.strictEqual(target.querySelector('.o_int_color .o_color_4').classList.contains("active"), true, "Click on pill should make pill active");
    });
});</pre></li>				<li>Add the following <a id="_idIndexMarker1250"/>code to <code>__manifest__.py</code> to register it in the test suite:<pre class="source-code">
'assets': {
'web.qunit_suite_tests': [
    'my_hostel/static/tests/**/*',
],
 },</pre></li>			</ol>
			<p>To run this test case, start your server with the following command in the Terminal:</p>
			<pre class="console">
./odoo-bin -c server.conf -i my_hostel,web --test-enable</pre>			<p>To check <a id="_idIndexMarker1251"/>that the tests have run successfully, search for the following log:</p>
			<pre class="console">
... INFO test odoo.addons.web.tests.test_js.WebSuite: console log: "Color Picker Widget Tests" passed 2 tests.</pre>			<h2 id="_idParaDest-798"><a id="_idTextAnchor1009"/>How it works...</h2>
			<p>In Odoo, JavaScript test cases are added to the <code>/static/tests/</code> directory. In <em class="italic">step 1</em>, we added a <code>colorpicker_test.js</code> file for the test case. In that file, we imported the registry for use in <code>serviceRegistry</code> and <code>setupViewRegistries</code> and<code>makeView</code> from test helpers. <code>makeView</code>  is imported because we created the <code>int_color</code> widget for the form view, so to test the widget, we will need the form view.</p>
			<p><code>@web/../tests/helpers/utils</code> will provide us with the test utilities we require to build the JavaScript test cases. If you don’t know how JavaScript import works, refer to the <em class="italic">Extending CSS and JavaScript for the website</em> recipe in <a href="B20997_14.xhtml#_idTextAnchor734"><em class="italic">Chapter 14</em></a>, <em class="italic">CMS </em><em class="italic">Website Development</em>.</p>
			<p>Odoo client-side test cases are built with the QUnit framework, which is the jQuery framework for the JavaScript unit test case. Refer to <a href="https://qunitjs.com/">https://qunitjs.com/</a> to learn more about this. The <code>beforeEach</code> function is called before running the test cases, and this helps to initialize the test data. The reference of the <code>beforeEach</code> function is provided by the QUnit framework itself.</p>
			<p>We initialized some data in the <code>beforeEach</code> function. Let’s see how that data is used in the test case. The client-side test case runs in an isolated (mock) environment, and it doesn’t make a connection to the database, so for these test cases, we need to create test data. Internally, Odoo creates the mock server to mimic the <code>serverData</code> property as the database. Consequently, in <code>beforeEach</code>, we initialized our test data in the <code>serverData</code> property. The keys in the <code>serverData</code> property are considered a table, and the values contain information about the fields and the table rows. The <code>fields</code> key is used to define table fields, and the <code>records</code> key is used for the table rows. In our example, we added a <code>room</code> table with three fields – <code>name(char)</code>, <code>room_no(char)</code>, and <code>color(integer)</code>. Note that, here, you can use any Odoo fields, even relational fields – for example, <code>{string: "M2o Field", type: "many2one", relation: 'partner'}</code>. We also added two room records with the <code>records</code> key.</p>
			<p>Then, we added the test cases with the <code>QUnit.test</code> function. The first argument in the function is <code>string</code> to describe the test case. The second argument is the function to which you <a id="_idIndexMarker1253"/>need to add code for the test cases. This function is called from the QUnit framework, and it passes the assert utilities as the argument. In our example, we passed the number of expected test cases in the <code>assert.expect</code> function. We are adding two test cases, so we passed <code>2</code>.</p>
			<p>We want to add to the test case the <code>int_color</code> widget in the editable form view, so we created the editable form view with <code>makeView</code>. The <code>makeView</code> function accepts different arguments, as follows:</p>
			<ul>
				<li><code>resModel</code> is the name <a id="_idIndexMarker1254"/>of the model for which the given view is created. All of the models are listed in the <code>resModel</code> as properties. We want to create a view for the room model, so in our example, we used the room as a model.</li>
				<li><code>serverData</code> is the record <a id="_idIndexMarker1255"/>that we are going to use in the view. The views key from <code>serverData</code> is the definition of the view you want to create. Because we want to test the <code>int_color</code> widget, we passed the view definition with the widget. Note that you can only use the fields that are defined in the model.</li>
				<li><code>Type</code>: The type <a id="_idIndexMarker1256"/>of view.</li>
			</ul>
			<p>After creating the form view with the <code>int_color</code> widget, we added two test cases. The first one is used to check the number of color pills on the UI, and the second test case is used to check that the pill is activated correctly after the click. We have the <code>strictEqual</code> function from the asserted utility of the QUnit framework. The <code>strictEqual</code> function passes the test case if the first two arguments match. If they do not match, it will fail the test case.</p>
			<h2 id="_idParaDest-799"><a id="_idTextAnchor1010"/>There’s more...</h2>
			<p>There are a few more assert functions available for QUnit test cases, such as <code>assert.deepEqual</code>, <code>assert.ok</code>, and <code>assert.notOk</code>. To learn more about QUnit, refer <a id="_idIndexMarker1257"/>to its documentation at <a href="https://qunitjs.com/">https://qunitjs.com/</a>.</p>
			<h1 id="_idParaDest-800"><a id="_idTextAnchor1011"/>Adding tour test cases</h1>
			<p>You have now seen the Python and JavaScript test cases. Both of these work in an isolated <a id="_idIndexMarker1258"/>environment, and they don’t interact with each other. To test integration between JavaScript and Python code, tour test cases are used.</p>
			<h2 id="_idParaDest-801"><a id="_idTextAnchor1012"/>Getting ready</h2>
			<p>For this recipe, we will continue using the <code>my_hostel</code> module from the previous recipe. We will add a tour test case to check the flow of the room model. Also, make sure you have installed the <code>web_tour</code> module or have added the <code>web_tour</code> module dependency to the manifest.</p>
			<h2 id="_idParaDest-802"><a id="_idTextAnchor1013"/>How to do it...</h2>
			<p>Follow these steps to add a tour test case for <code>rooms</code>:</p>
			<ol>
				<li>Add a <code>/static/src/js/my_hostel_tour.js</code> file, and then add a tour as follows:<pre class="source-code">
/** @odoo-module **/
import { _t } from "@web/core/l10n/translation";
import { registry } from "@web/core/registry";
import { stepUtils } from "@web_tour/tour_service/tour_utils";
import { markup } from "@odoo/owl";
registry.category("web_tour.tours").add("hostel_tour", {
    url: "/web",
    rainbowMan: false,
    sequence: 20,
    steps: () =&gt; [stepUtils.showAppsMenuItem(), {
    trigger: '.o_app[data-menu-xmlid="my_hostel.hostel_base_menu"]',
    content: markup(_t("Ready to launch your &lt;b&gt;Hostel&lt;/b&gt;?")),
    position: 'bottom',
    edition: 'community',
}</pre></li>				<li>Add steps for <a id="_idIndexMarker1259"/>the test tour:<pre class="source-code">
    trigger: '.o_app[data-menu-xmlid="my_hostel.hostel_base_menu"]',
    content: markup(_t("Ready to launch your &lt;b&gt;Hostel&lt;/b&gt;?")),
    position: 'bottom',
    edition: 'enterprise',
}, {
    trigger: '.o_list_button_add',
    content: markup(_t("Let's create new room.")),
    position: 'bottom',
}, {
    trigger: ".o_form_view .o_field_char[name='name']",
    content: markup(_t('Add a new &lt;b&gt; Hostel Room &lt;/b&gt;.')),
    position: "top",
    run: function (actions) {
    actions.text("Hostel Room 01", this.$anchor.find("input"));
},
}, {
    trigger: ".ui-menu-item &gt; a",
    auto: true,
    in_modal: false,
}, {
    trigger: ".breadcrumb-item:not(.active):first",
    content: _t("Click on the breadcrumb to go back to your Pipeline. Odoo will save all modifications as you navigate."),
    position: "bottom",
    run: function (actions) {
    actions.auto(".breadcrumb-item:not(.active):last");
},
},]});</pre></li>				<li>Add the <code>my_hostel_tour.js</code> file to the test assets:<pre class="source-code">
'web.assets_backend': [
'my_hostel/static/src/js/tours/my_hostel_tour.js',
],</pre></li>				<li>Add a <code>/tests/test_tour.py</code> file, and <a id="_idIndexMarker1260"/>run the tour through <code>HttpCase</code>, as follows:<pre class="source-code">
from odoo.tests.common import TransactionCase, tagged
from odoo.tests import HttpCase
@tagged('post_install', '-at_install')
class TestUi(HttpCase):
    def test_01_hostel_tour(self):
        self.start_tour("/web", 'hostel_tour', login="admin")</pre></li>			</ol>
			<p>In order to run test cases, start the Odoo server with the following option:</p>
			<pre class="console">
./odoo-bin -c server.conf -i my_hostel --test-enable</pre>			<p>Now, check the server log. Here, you will find the following logs if our test cases ran successfully:</p>
			<pre class="console">
...INFO test odoo.addons.my_hostel.tests.test_tour.TestroomUI: console log: Tour hostel_tour succeeded</pre>			<h2 id="_idParaDest-803"><a id="_idTextAnchor1014"/>How it works...</h2>
			<p>In order to create tour test cases, you need to create the UI tour first. If you want to learn more <a id="_idIndexMarker1261"/>about UI tours, refer to the <em class="italic">Improve onboarding with tours</em> recipe in <a href="B20997_15.xhtml#_idTextAnchor861"><em class="italic">Chapter 15</em></a>, <em class="italic">Web </em><em class="italic">Client Development</em>.</p>
			<p>In <em class="italic">step 1</em>, we registered a new tour with the name <code>hostel_tour</code>. This tour is exactly like the tour we created in the <em class="italic">Improve onboarding with tours</em> recipe in <a href="B20997_15.xhtml#_idTextAnchor861"><em class="italic">Chapter 15</em></a>. In <em class="italic">step 2</em>, we added the steps for the tours.</p>
			<p>Here, we have two main changes compared to the onboarding tour. First, we added a <code>test=true</code> parameter for the tour definition; second, we added one extra property, <code>run</code>. In the <code>run</code> function, you have to write the logic to perform the operation that is normally done by the user. For example, in the fourth step of the tour, we ask the user to enter the room title.</p>
			<p>To automate this step, we added a <code>run</code> function to set the value in the <code>title</code> field. The <code>run</code> function passes the action utility as the parameter. This provides some shortcuts to perform basic actions. The most important ones are as follows:</p>
			<ul>
				<li><code>actions.click(element)</code> is used to click on a given element.</li>
				<li><code>actions.dblclick(element)</code> is used to double-click on a given element.</li>
				<li><code>actions.tripleclick(element)</code> is used to triple-click on a given element.</li>
				<li><code>actions.text(string)</code> is used to set the input values.</li>
				<li><code>actions.drag_and_drop(to, element)</code> is used to drag and drop an element.</li>
				<li><code>actions.keydown(keyCodes, element)</code> is used to trigger particular keyboard events on an element.</li>
				<li><code>actions.auto()</code> is the default action. When you don’t pass the <code>run</code> function in the tour step, <code>actions.auto()</code> is performed. This usually clicks on the trigger element of the tour step. The only exception here is an input element. If the trigger element is <code>input</code>, the tour will set the default value, <code>Test</code>, in the input. That is why we don’t need to add <code>run</code> functions to all of the steps.</li>
			</ul>
			<p>Alternatively, you can perform whole actions manually if default actions are not enough. In the next tour step, we want to set a value for the color picker. Note that we used the manual action because default values won’t help here. Consequently, we added the <code>run</code> method with the basic jQuery code to click on the third pill of the color picker. Here, you will find the trigger element with the <code>this.$anchor</code> property.</p>
			<p>By default, registered <a id="_idIndexMarker1262"/>tours are displayed to the end user to improve the onboarding experience. In order to run them as a test case, you need to run them in Headless Chrome. To do so, you need to use the <code>HttpCase</code> Python test case. This provides the <code>browser_js</code> method, which opens the URL and executes the command passed as the second parameter. You can run the tour manually, like this:</p>
			<pre class="source-code">
odoo.__DEBUG__.services['web_tour.tour'].run('hostel_tour')</pre>			<p>In our example, we passed the name of the tour as the argument in the <code>browser_js</code> method. The next parameter is used to wait for a given object to be ready before performing the first command. The last parameter in the <code>browser_js()</code> method is the name of the user. This username will be used to create a new test environment, and all of the test actions will be performed on behalf of this user.</p>
			<h1 id="_idParaDest-804"><a id="_idTextAnchor1015"/>Running client-side test cases from the UI</h1>
			<p>Odoo provides a way <a id="_idIndexMarker1263"/>to run client-side test cases from the UI. By running the test case from the UI, you will be able to see each step of the test case in action. This way, you can verify that the UI test case works exactly as you wanted.</p>
			<h2 id="_idParaDest-805"><a id="_idTextAnchor1016"/>How to do it...</h2>
			<p>You can run both the <code>QUnit</code> test case and the tours test case from the UI. It is not possible to run Python test cases from the UI, as it runs on the server side. In order to see the options to run test cases from the UI, you need to enable developer mode.</p>
			<h3>Running QUnit test cases from the UI</h3>
			<p>Click on the <a id="_idIndexMarker1264"/>bug icon to open the <a id="_idIndexMarker1265"/>drop-down menu, as shown in the following figure. Click on the <strong class="bold">Run JS </strong><strong class="bold">Tests</strong> option:</p>
			<div><div><img src="img/B20997_18_01.jpg" alt="Figure 18.1 – The option to run test cases"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.1 – The option to run test cases</p>
			<p>This will open the QUnit suite, and it will start running the test cases one by one, as shown in the following screenshot. By default, it will only show the failed test cases. To show all the passed test cases, uncheck the <strong class="bold">Hide passed tests</strong> checkbox, as shown in the following screenshot:</p>
			<div><div><img src="img/B20997_18_02.jpg" alt="Figure 18.2 – The results of the QUnit test cases"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.2 – The results of the QUnit test cases</p>
			<h3>Running tours from the UI</h3>
			<p>Click on the <a id="_idIndexMarker1266"/>bug icon to open the drop-down menu, as shown <a id="_idIndexMarker1267"/>in the following screenshot, and then click on <strong class="bold">Start Tour</strong>:</p>
			<div><div><img src="img/B20997_18_03.jpg" alt="Figure 18.3 – The option to run tour test cases"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.3 – The option to run tour test cases</p>
			<p>This will open a dialog with a list of registered tours, as you can see in the following screenshot. Click on the play button on the side to run the tour:</p>
			<div><div><img src="img/B20997_18_04.jpg" alt="Figure 18.4 – A list of tour test cases"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.4 – A list of tour test cases</p>
			<p>The test tours only <a id="_idIndexMarker1268"/>display in a list if you have enabled test assets <a id="_idIndexMarker1269"/>mode. If you can’t find the <code>hostel_tour</code> tour in the list, make sure you have activated test assets mode.</p>
			<h2 id="_idParaDest-806"><a id="_idTextAnchor1017"/>How it works...</h2>
			<p>The UI for QUnit is provided by the QUnit framework itself. Here, you can filter the test cases for the modules. You can even run a test case for just one module. With the UI, you can see the progress of each test case, and you can drill down to each step of the test case. Internally, Odoo just opens the same URL in Headless Chrome.</p>
			<p>Clicking on the <strong class="bold">Run tours</strong> option will display the list of available tours. By clicking on the play button on the list, you can run the tour. Note that when the tour runs via the command-line options, it runs in the rolled-back transaction, so changes made through the tour are rolled back after the tour is successful. However, when the tour runs from the UI, it works just as though a user was operating it, meaning changes made from the tour are not rolled back and stay there, so use this option carefully.</p>
			<h1 id="_idParaDest-807"><a id="_idTextAnchor1018"/>Debugging client-side test cases</h1>
			<p>Developing complex client-side test cases can be a headache. In this recipe, you will learn how <a id="_idIndexMarker1270"/>you can debug the client-side test cases in Odoo. Instead of running all of the test cases, we will run just the one. Additionally, we will display the UI of the test case.</p>
			<h2 id="_idParaDest-808"><a id="_idTextAnchor1019"/>Getting ready</h2>
			<p>For this recipe, we will continue using the <code>my_hostel</code> module from the previous recipe.</p>
			<h2 id="_idParaDest-809"><a id="_idTextAnchor1020"/>How to do it...</h2>
			<p>Follow these steps to run a test case in debug mode:</p>
			<ol>
				<li>Open the <code>/static/tests/colorpicker_test.js</code> file and update and add the <code>makeView</code> function, like this:<pre class="source-code">
await makeView({
    type: "form",
    resModel: "hostel.room",
    serverData: {
        models: {
            'hostel.room': {
                fields: {
                    name: { string: "Hostel Name", type: "char" },
                    room_no: { string: "Room Number", type: "char" },
                    color: { string: "color", type: "integer"},
                },
                records: [
                    {
                        id: 1,
                        name: "Hostel Room 01",
                        room_no: 1,
                        color: 1,
                    },
                    {
                        id: 2,
                        name: "Hostel Room 02",
                        room_no: 2,
                        color: 3
                    }
                ],
            },
        },
        views: { },
    },
    arch: `
    &lt;form&gt;
        &lt;field name="name"/&gt;
        &lt;field name="room_no"/&gt;
        &lt;field name="color" widget="int_color"/&gt;
    &lt;/form&gt;`,
});</pre></li>				<li>Check the <code>target</code> parameter <a id="_idIndexMarker1271"/>in the <code>containtsN</code> function, as follows:<pre class="source-code">
assert.containsN(
            target,
            ".o_field_int_color",
            1,
            "Both records are rendered"
        );
    });
});</pre></li>			</ol>
			<p>Open developer mode and open the drop-down menu by clicking on the bug icon on the top menu, and then click on <strong class="bold">Run JS Tests</strong>. This will open the QUnit suite:</p>
			<div><div><img src="img/B20997_18_05.gif" alt="Figure 18.5 – The option to run test cases"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.5 – The option to run test cases</p>
			<p>This will <a id="_idIndexMarker1272"/>run only one test case, which is our color picker test case.</p>
			<div><div><img src="img/B20997_18_06.jpg" alt="Figure 18.6 – Color picker test case"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.6 – Color picker test case</p>
			<h2 id="_idParaDest-810"><a id="_idTextAnchor1021"/>How it works...</h2>
			<p>In <em class="italic">step 1</em>, we replaced <code>QUnit.test</code> with <code>QUnit.only</code>. This will run this test case only. During the development of the test case, this can be time-saving. Note that using <code>QUnit.only</code> will stop the test case from running via the command-line options. This can only be used for debugging or testing, and it can only work when you open the test case from the UI, so don’t forget to replace it with <code>QUnit.test</code> after the development.</p>
			<p>In our QUnit test <a id="_idIndexMarker1273"/>case example, we created the form view to test the <code>int_color</code> widget. If you run the QUnit test cases from the UI, you will find that you are not able to see the created form views in the UI. From the UI of the QUnit suite, you are only able to see the logs. This makes developing a QUnit test case very difficult. To solve this issue, the <code>debug</code> parameter is used in the <code>makeView</code> function. In <em class="italic">step 2</em>, we added <code>debug: true</code> in the <code>makeView</code> function. This will <a id="_idIndexMarker1274"/>display the test form view in the browser. Here, you will be able to locate <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) elements via the browser debugger.</p>
			<p class="callout-heading">Warning</p>
			<p class="callout"><em class="italic">At the end of the test case, we destroy the view through the </em><code>destroy()</code><em class="italic"> method. If you have destroyed the view, then you won’t be able to see the form view in the UI, so in order to see it in the browser, remove that line during development. This will help you debug the </em><em class="italic">test case.</em></p>
			<p>Running QUnit test cases in debug mode helps you develop test cases very easily and quickly.</p>
			<h1 id="_idParaDest-811"><a id="_idTextAnchor1022"/>Generating videos/screenshots for failed test cases</h1>
			<p>Odoo uses <a id="_idIndexMarker1275"/>Headless Chrome, which <a id="_idIndexMarker1276"/>opens new possibilities. Starting from Odoo 12, you can record videos of the failed test cases, and you can take screenshots of them as well.</p>
			<h2 id="_idParaDest-812"><a id="_idTextAnchor1023"/>How to do it...</h2>
			<p>Recording a video for a test case requires an <code>ffmpeg</code> package:</p>
			<ol>
				<li>To install this, you need to execute the following command in the terminal (note that this command only works on a Debian-based OS):<pre class="source-code">
<strong class="bold">apt-get install ffmpeg</strong></pre></li>				<li>To generate a video or screenshot, you will need to provide a directory location to store the video or screenshots.</li>
				<li>If you want to generate a screencast (video) of a test case, use the <code>--screencasts</code> command, like this:<pre class="source-code">
<code>--screenshosts</code> command, like this:<pre class="source-code">
<strong class="bold">./odoo-bin -c server.conf -i my_hostel --test-enable --screenshots=/home/pga/odoo_test/</strong></pre></li>			</ol>
			<h2 id="_idParaDest-813"><a id="_idTextAnchor1024"/>How it works...</h2>
			<p>In order to generate screenshots/screencasts for failed test cases, you need to run the server <a id="_idIndexMarker1277"/>with the path to save the video or image files. When you run the test cases, and if a test case fails, Odoo will save <a id="_idIndexMarker1278"/>a screenshot/video of the failed test case in the given directory.</p>
			<p>To generate a video of a test case, Odoo uses the <code>ffmpeg</code> package. If you haven’t installed this package on the server, then it will only save a screenshot of a failed test case. After installing the package, you will be able to see the <code>mp4</code> file of any failed test case.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Generating videos for test cases can consume more space on disks, so use this option with caution and only when it is really necessary.</p>
			<p>Keep in mind that screenshots and videos are only generated for failed test cases, so if you want to test them, you need to write a test case that fails.</p>
			<h1 id="_idParaDest-814"><a id="_idTextAnchor1025"/>Populating random data for testing</h1>
			<p>So far, we have seen test cases that have been used to detect errors or bugs in business logic. However, at times, we need to test our development with large amounts of data. Generating <a id="_idIndexMarker1279"/>large amounts of data can be a tedious job. Odoo provides a set of tools that helps you generate a lot of random data for your model. In this recipe, we will use the <code>populate</code> command to generate test data for the <code>hostel.room</code> and <code>hostel.room.member</code> models.</p>
			<h2 id="_idParaDest-815"><a id="_idTextAnchor1026"/>Getting ready</h2>
			<p>For this recipe, we will continue using the <code>my_hostel</code> module from the previous recipe. We will add the <code>_populate_factories</code> method, which will be used to generate test data.</p>
			<h2 id="_idParaDest-816"><a id="_idTextAnchor1027"/>How to do it...</h2>
			<p>Follow these steps to generate data for the <code>hostel.room</code> model:</p>
			<ol>
				<li>Add a <code>populate</code> folder to the <code>my_hostel</code> module. Also, add an <code>__init__.py</code> file with this content:<pre class="source-code">
from . import hostel_data</pre></li>				<li>Add a <code>my_hostel/populate/hostel_data.py</code> file, and then add this code to generate the hostel room’s data:<pre class="source-code">
import logging
import random
from odoo import models
from odoo.tools import populate
_logger = logging.getLogger(__name__)
class RoomData(models.Model):
    _inherit = 'hostel.room.member'
    _populate_sizes = {'small': 10, 'medium': 100, 'large': 500}
    _populate_dependencies = ["res.partner"]
    def _populate_factories(self):
        partner_ids = self.env.registry.populated_models['res.partner']
        return [
            ('partner_id', populate.randomize(partner_ids)),
        ]
class HostelData(models.Model):
    _inherit = 'hostel.room'
    _populate_sizes = {'small': 10, 'medium': 100, 'large': 500}
    _populate_dependencies = ["hostel.room.member"]
    def _populate_factories(self):
        member_ids = self.env.registry.populated_models['hostel.room.member']
        def get_member_ids(values, counter, random):
            return [
                (6, 0, [
                    random.choice(member_ids) for i in range(random.randint(1, 2))
                ])
            ]
        return [
            ('name', populate.constant('Hostel Room {counter}')),
            ('room_no', populate.constant('{counter}')),
            ('member_ids', populate.compute(get_member_ids)),
        ]</pre></li>				<li>Run this <a id="_idIndexMarker1280"/>command to generate the hostel’s data:<pre class="source-code">
<strong class="bold">./odoo-bin -c server.conf -d db_name -i my_hostel</strong>
<strong class="bold">./odoo-bin populate --models=hostel.room --size=medium -c server.conf -d db_name</strong></pre></li>			</ol>
			<p>This will generate 100 units of data for the hostel rooms. After generating the data, the process will be terminated. To see the hostel room’s data, run the command without the <code>populate</code> parameters.</p>
			<h2 id="_idParaDest-817"><a id="_idTextAnchor1028"/>How it works...</h2>
			<p>In <em class="italic">step 1</em>, we added the <code>populate</code> folder to the <code>my_hostel</code> module. This folder contains the code to populate the test data.</p>
			<p>In <em class="italic">step 2</em>, we added code to populate the room data. To generate random data, the <code>_populate_factories</code> method was used. The <code>_populate_factories</code> method returns factories for model fields, which will be used to generate random data. The <code>hostel.room</code> model has the required <code>name</code> and <code>room_no</code> fields, so in our example, we returned the generator for those fields. This generator <a id="_idIndexMarker1281"/>will be used to generate random data for the <code>hostel room</code> record. We used the <code>populate.constant</code> generator for the name field; this will generate different names when we iterate during data generation.</p>
			<p>Just like <code>populate.constant</code>, Odoo provides several other generators to populate data; here is a list of those generators:</p>
			<ul>
				<li><code>populate.randomize(list)</code> will return a random element from the given list.</li>
				<li><code>populate.cartesian(list)</code> is just like <code>randomize()</code>, but it will try to include all the values from the list.</li>
				<li><code>populate.iterate(list)</code> will iterate over a given list, and once all the elements are iterated, it will return based on <code>randomize</code> or random elements.</li>
				<li><code>populate.constant(str)</code> is used to generate formatted strings. You can also pass the <code>formatter</code> parameter to format values. By default, the formatter is a string-format function.</li>
				<li><code>populate.compute(function)</code> is used when you want to compute a value based on your function.</li>
				<li><code>populate.randint(a,</code> <code>b)</code> is used to generate a random number between the <code>a</code> and <code>b</code> parameters.</li>
			</ul>
			<p>These generators can be used to generate test data of your choice.</p>
			<p>Another important attribute is <code>_populate_sizes</code>. It is used to define the number of records you want to generate based on the <code>--size</code> parameter. Its value always depends on the business object.</p>
			<p>In <em class="italic">step 3</em>, we generated a data hostel room model. To populate test data, you will need to use the <code>--size</code> and <code>--model</code> parameters. Internally, Odoo uses the <code>_populate</code> method to generate random records. The <code>_populate</code> method itself uses the <code>_populate_factories</code> method to get random data for records. The <code>_populate</code> method will generate data for the models given in the <code>--model</code> parameter, and the <a id="_idIndexMarker1282"/>amount of test data will be based on the <code>_populate_sizes</code> attribute of the model. Based on our example, if we use <code>–-size=medium</code>, the data for 100 hostel rooms will be generated.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you run the <code>populate</code> command multiple times, the data will be generated multiple times as well. It’s important to use this carefully; if you run the command in a production database, it will generate test data in the production database itself. This is something you want to avoid.</p>
			<h2 id="_idParaDest-818"><a id="_idTextAnchor1029"/>There’s more…</h2>
			<p>At times, you might like to generate relational data too. For example, with rooms, you might also want to create member records. To manage such records, you can use the <code>_populate_dependencies</code> attribute:</p>
			<pre class="source-code">
class RoomData(models.Model):
    _inherit = 'hostel.room.member'
    _populate_sizes = {'small': 10, 'medium': 100, 'large': 500}
    _populate_dependencies = ["res.partner"]
    . . .</pre>			<p>This will populate the data for dependencies before populating the current model. Once that is done, you can access the populated data via the <code>populated_models</code> registry:</p>
			<pre class="source-code">
partner_ids = self.env.registry.populated_models['res.partner']</pre>			<p>The preceding <a id="_idIndexMarker1283"/>line will give you the list of companies that are populated before generating test data for the current model.</p>
		</div>
	</body></html>