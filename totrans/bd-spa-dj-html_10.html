<html><head></head><body>
		<div><h1 id="_idParaDest-84"><a id="_idTextAnchor152"/>Chapter 7: Creating a Real-Time Blog Using Only Django</h1>
			<p>In <a href="B18321_06_ePub.xhtml#_idTextAnchor139"><em class="italic">Chapter 6</em></a>,<em class="italic"> Creating SPAs on the Backends</em>, we learned essential features for setting up an SPA using HTML over WebSockets, such as changing pages, components, and sessions. We even went a step further by creating a server-side rendering system for each page so that search engines can index all content – a feature that didn’t require much effort as we are inside Django. </p>
			<p>We now have the skills and maturity to make applications with all the features that SPA development entails. Now is the time! We will unify all the knowledge acquired in the creation of a perfectly prepared blog. Undoubtedly, this is an excellent exercise regardless of the language or framework that we want to assimilate; it encompasses all the basic tasks of any web development: querying, filtering, and adding to a database (search engine and comments), generating HTML from results (a list of articles and an individual page), use of views (SSR), routing (static pages), processing and validating forms (incorporating a new comment), and finally, pagination. </p>
			<p>This is an exam to prove to the world, and to yourself, that you have the basic knowledge in the subject you are learning. It can even be a good technical test.</p>
			<p>During the creation of the blog, we will be doing the following: </p>
			<ul>
				<li>Creating models for the database</li>
				<li>Generating fake articles and comments</li>
				<li>Listing of articles</li>
				<li>Navigating between articles with pagination</li>
				<li>Adding an article search engine</li>
				<li>Creating a static page</li>
				<li>Moving between pages and generating a browser</li>
				<li>Implementing an individual page per article</li>
				<li>Adding a list of comments</li>
				<li>Adding new comments</li>
				<li>Offering an <strong class="bold">Really Simple Syndication</strong> (<strong class="bold">RSS</strong>) feed</li>
			</ul>
			<p>During the chapter, we will work in small milestones, following an order that allows us to incorporate each element organically, without jumping from one feature to another until it is finished. You can find the code for each of the features (in the preceding list) that we will be implementing separately. </p>
			<p>In order not to extend the example too much, we will start with a code base that we have used in previous chapters.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor153"/>Technical requirements</h1>
			<p>All the code of the different sections can be found at the following link:</p>
			<p><a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-7">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-7</a></p>
			<p>As in other examples, I will start from the template that we built in <a href="B18321_04_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 4</em></a>, <em class="italic">Working with the Database</em>:</p>
			<p><a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/initial-template">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/initial-template</a></p>
			<p>If you find some small differences, it is because I have made some minor adjustments. For example, I have named the project <code>blog</code>, the app <code>website</code>, and changed the path to <code>http://blog.localhost</code>, although, as always, you are free to name each element freely.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor154"/>Creating models for the database</h1>
			<p>We will start by building two <a id="_idIndexMarker347"/>tables in the database: <code>Post</code>, which will <a id="_idIndexMarker348"/>contain the articles, and <code>Comment</code>, so that readers can leave their opinions next to the articles.</p>
			<p>In <code>app/website/models.py</code>, add the<a id="_idIndexMarker349"/> following database <a id="_idIndexMarker350"/>structure:</p>
			<pre class="source-code">from django.db import models</pre>
			<pre class="source-code">from django.utils.text import slugify</pre>
			<pre class="source-code">from django.urls import reverse</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">class Post(models.Model):</pre>
			<pre class="source-code">    # Fields: Title of the article, name of the author, </pre>
			<pre class="source-code">    content of the article and date of creation.</pre>
			<pre class="source-code">    title = models.CharField(max_length=200, unique=True)</pre>
			<pre class="source-code">    author = models.CharField(max_length=20)</pre>
			<pre class="source-code">    content = models.TextField()</pre>
			<pre class="source-code">    created_at = models.DateTimeField(auto_now_add=True)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    class Meta:</pre>
			<pre class="source-code">        ordering = ["-created_at"]</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    @property</pre>
			<pre class="source-code">    def slug(self):</pre>
			<pre class="source-code">        return slugify(self.title)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    @property</pre>
			<pre class="source-code">    def summary(self):</pre>
			<pre class="source-code">        return self.content[:100] + "..."</pre>
			<pre class="source-code">    @property </pre>
			<pre class="source-code">    def get_absolute_url(self):</pre>
			<pre class="source-code">        return reverse("single post", kwargs={"slug": </pre>
			<pre class="source-code">            self.slug})</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def __str__(self):</pre>
			<pre class="source-code">        return self.title</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">class Comment(models.Model):</pre>
			<pre class="source-code">    # Fields: Name of the author, content of the comment, </pre>
			<pre class="source-code">    relation to the article and date of creation.</pre>
			<pre class="source-code">    author = models.CharField(max_length=20)</pre>
			<pre class="source-code">    content = models.TextField()</pre>
			<pre class="source-code">    post = models.ForeignKey(Post, on_delete=models.</pre>
			<pre class="source-code">        CASCADE)</pre>
			<pre class="source-code">    created_at = models.DateTimeField(auto_now_add=True)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def __str__(self):</pre>
			<pre class="source-code">        return self.n<a id="_idTextAnchor155"/>ame</pre>
			<p>Let’s look at the<a id="_idIndexMarker351"/> properties of <code>Post</code>:</p>
			<ul>
				<li><code>slug</code>: We will <a id="_idIndexMarker352"/>use the title of the article to differentiate the routes. For example, if it is titled <code>Penguins have just conquered the world</code>, its final path will be <code>http://blog.localhost/penguins-have-just-conquered-the-world</code>. With this property, we get the title ready to be used for different purposes, such as feeding other properties or searching for the ID of an article.</li>
			</ul>
			<p class="callout-heading">Slug</p>
			<p class="callout">Slug is a format used in URLs to make them more readable, where spaces are replaced by single dashes and text is converted to lowercase. In areas such as SEO, it is used to explain the content of the page.</p>
			<ul>
				<li><code>summary</code>: When <a id="_idIndexMarker353"/>we list the articles, we will show a small portion of the original article. With this property, we limit the portion of the article shown to 100 characters, plus we add some nice dots at the end of the<a id="_idIndexMarker354"/> sentence. It’s not perfect, as it counts spaces and doesn’t check the initial length, but it’s certainly sufficient for the purpose.</li>
				<li><code>get_absolute_url</code>: Through the paths defined in <code>urls.py</code>, we will build the hyperlinks for each article. Why? We will move dynamically. They are for the RSS feed, for example, or a future site map.</li>
			</ul>
			<p>The next step, as we have done in each activity, is to enter the Django container terminal and execute the following:</p>
			<pre>python3 manage.py makemigrations
python3 manage.py migrate</pre>
			<p>The database is ready. However, without data, it is not practical. As on other occasions, we will create fake content that simulates the final appearance of the blog. </p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor156"/>Generating fake articles and comments</h1>
			<p>After defining the database<a id="_idIndexMarker355"/> from the models, we are going to generate random data that we will use to work more comfortably.</p>
			<p>We create <code>make_fake_data.py</code> with the following <a id="_idTextAnchor157"/><a id="_idTextAnchor158"/>content:</p>
			<pre class="source-code">from app.website.models import Post, Comment</pre>
			<pre class="source-code">from faker import Faker</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code"># Delete all posts and comments</pre>
			<pre class="source-code">Post.objects.all().delete()</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code"># Create fake object</pre>
			<pre class="source-code">fake = Faker()</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">def get_full_name():</pre>
			<pre class="source-code">    return f"{fake.first_name()} {fake.last_name()}"</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code"># Create 30 posts</pre>
			<pre class="source-code">for _ in range(30):</pre>
			<pre class="source-code">    post = Post(</pre>
			<pre class="source-code">        title=fake.sentence()[:200],</pre>
			<pre class="source-code">        content=fake.text(),</pre>
			<pre class="source-code">        author=get_full_name()[:20],</pre>
			<pre class="source-code">    )</pre>
			<pre class="source-code">    post.save()</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code"># Create 150 comments</pre>
			<pre class="source-code">for _ in range(150):</pre>
			<pre class="source-code">    comment = Comment(</pre>
			<pre class="source-code">        author=get_full_name()[:20],</pre>
			<pre class="source-code">        content=fake.text(),</pre>
			<pre class="source-code">        post=Post.objects.order_by("?").first(),</pre>
			<pre class="source-code">    )</pre>
			<pre class="source-code">    comment.save()</pre>
			<p>The code we are going to run will generate random information. The steps we follow are as follows:</p>
			<ol>
				<li>We delete all the articles, or <code>Post</code>. The first time we run it, there will be nothing to delete, but thereafter, it will delete everything it finds.</li>
				<li>We generate 30 new articles.</li>
				<li>We generate 150 comments, or <code>Comment</code>, and assign them to articles randomly. This<a id="_idIndexMarker356"/> way, they will be distributed irregularly, with cases where there are articles with no comments and others with a large number.</li>
			</ol>
			<p>Finally, in the Django container terminal, we execute the script we have just built:</p>
			<pre>python3 manage.py shell &lt; make_fake_data.py</pre>
			<p>Our database is populated with information. Now, we are going to focus on the logic of the blog – for example, listing all the articles in HTML.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor159"/>Listing of articles</h1>
			<p>We have prepared the database through the models and by including fake information with the necessary<a id="_idIndexMarker357"/> elements, enabling us to focus on how the customer is going to visualize the content.</p>
			<p>Before building the different pages, we will need a base for all templates. In <code>app/website/templates/base.html</code>, we include the main layout:</p>
			<pre class="source-code">{% load static %}</pre>
			<pre class="source-code">&lt;!doctype html&gt;</pre>
			<pre class="source-code">&lt;html lang="en"&gt;</pre>
			<pre class="source-code">&lt;head&gt;</pre>
			<pre class="source-code">    &lt;meta charset="UTF-8"&gt;</pre>
			<pre class="source-code">    &lt;meta name="viewport" content="width=device-width,</pre>
			<pre class="source-code">        user-scalable=no, initial-scale=1.0, maximum-</pre>
			<pre class="source-code">            scale=1.0, minimum-scale=1.0"&gt;</pre>
			<pre class="source-code">    &lt;title&gt;Example website&lt;/title&gt;</pre>
			<pre class="source-code">    &lt;link rel="stylesheet" href="{% static 'css/main.css' </pre>
			<pre class="source-code">        %}"&gt;</pre>
			<pre class="source-code">    &lt;script defer src="img/index.js' %}"&gt;</pre>
			<pre class="source-code">    &lt;/script&gt;</pre>
			<pre class="source-code">&lt;/head&gt;</pre>
			<pre class="source-code">&lt;body</pre>
			<pre class="source-code">        data-host="{{ request.get_host }}"</pre>
			<pre class="source-code">        data-scheme="{{ request.scheme }}"</pre>
			<pre class="source-code">&gt;</pre>
			<pre class="source-code">    &lt;div class="container"&gt;</pre>
			<pre class="source-code">        &lt;header&gt;</pre>
			<pre class="source-code">            &lt;nav id="nav" class="nav"&gt;{% include </pre>
			<pre class="source-code">                'components/_nav.html' %}&lt;/nav&gt;</pre>
			<pre class="source-code">        &lt;/header&gt;</pre>
			<pre class="source-code">        &lt;main id="main"&gt;{% include page %}&lt;/main&gt;</pre>
			<pre class="source-code">        &lt;footer class="footer"&gt;My footer&lt;/footer&gt;</pre>
			<pre class="source-code">    &lt;/di<a id="_idTextAnchor160"/>v&gt;</pre>
			<pre class="source-code">&lt;/body&gt;</pre>
			<pre class="source-code">&lt;/html&gt;</pre>
			<p>We have included areas to redraw elements such as the browser, with <code>#nav</code>, and the main content of future pages, with <code>#main</code>.</p>
			<p>Now, we are going to create the welcome page of the blog where we will list the articles.</p>
			<p>The first step will be<a id="_idIndexMarker358"/> creating an HTML template to generate the list of the different blog articles, which will be fed by a future database query. In <code>app/website/templates/pages/all_posts.html</code>, we add the following code:</p>
			<pre class="source-code">&lt;h1&gt; All posts&lt;/h1&gt;</pre>
			<pre class="source-code">&lt;hr&gt;</pre>
			<pre class="source-code">&lt;section&gt;</pre>
			<pre class="source-code">    {# List posts #}</pre>
			<pre class="source-code">    &lt;div id="all-posts"&gt;</pre>
			<pre class="source-code">        {% include "components/all_posts/list.html" %}</pre>
			<pre class="source-code">    &lt;/div&gt;</pre>
			<pre class="source-code">    {# End list posts #}</pre>
			<pre class="source-code">&lt;/section&gt;</pre>
			<p>We have separated the list of articles in a component hosted in <code>app/website/templates/components/all_posts/list.html</code> because it will be useful when we do the pagination.</p>
			<p>With the following code, let’s show the list of all the articles that will be displayed inside <code>#all-posts</code> by means of <code>include</code>: </p>
			<pre class="source-code">{% for post in posts %}</pre>
			<pre class="source-code">    &lt;article&gt;</pre>
			<pre class="source-code">        &lt;header&gt;</pre>
			<pre class="source-code">            &lt;h2&gt;{{ post.title }}&lt;/h2&gt;</pre>
			<pre class="source-code">        &lt;/header&gt;</pre>
			<pre class="source-code">        &lt;p&gt;{{ post.summary }}&lt;/p&gt;</pre>
			<pre class="source-code">        &lt;p&gt;{{ post.author }}&lt;/p&gt;</pre>
			<pre class="source-code">        &lt;footer&gt;</pre>
			<pre class="source-code">            &lt;p&gt;</pre>
			<pre class="source-code">                &lt;a class="post-item__link" href="#" data-</pre>
			<pre class="source-code">                    target="single post" data-id="{{ </pre>
			<pre class="source-code">                        post.id }}"&gt; Read more&lt;/a&gt;</pre>
			<pre class="source-code">            &lt;/p&gt;</pre>
			<pre class="source-code">        &lt;/footer&gt;</pre>
			<pre class="source-code">    &lt;/article&gt;</pre>
			<pre class="source-code">{% endfor %}</pre>
			<p>At the moment, the hyperlink to go to the individual page of the article does not work. When we have the<a id="_idIndexMarker359"/> right template, we will come back to give it the logic with JavaScript. However, we have already prepared the dataset for the dynamic page change: the name of the page to load (<code>data-target</code>) and its ID (<code>data-id</code>).</p>
			<p>In <code>app/website/views.py</code>, we create the following view:</p>
			<pre class="source-code">from django.shortcuts import render</pre>
			<pre class="source-code">from .forms import SearchForm, CommentForm</pre>
			<pre class="source-code">from .models import Post, Comment</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">def all_posts(request):</pre>
			<pre class="source-code">    return render(</pre>
			<pre class="source-code">        request,</pre>
			<pre class="source-code">        "base.html",</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            "posts": Post.objects.all()[:5],</pre>
			<pre class="source-code">            "page": "pages/all_posts.html",</pre>
			<pre class="source-code">            "active_nav": "all posts",</pre>
			<pre class="source-code">    <a id="_idTextAnchor161"/>    },</pre>
			<pre class="source-code">    )</pre>
			<pre class="source-code">    </pre>
			<p>We will only list the first five items; this is the number of items we will display per page.</p>
			<p>In <code>blog/urls.py</code>, we <a id="_idIndexMarker360"/>assign the root of the site:</p>
			<pre class="source-code">from django.contrib import admin</pre>
			<pre class="source-code">from django.urls import path</pre>
			<pre class="source-code">from app.website import views, feed</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    path("", views.all_posts, name="all posts"),</pre>
			<pre class="source-code">    path("admin/", admi<a id="_idTextAnchor162"/>n.site.urls),</pre>
			<pre class="source-code">]</pre>
			<p>When you pull up Docker, via <code>docker-compose.yaml</code>, and go to <code>http://blog.localhost</code>, you will find the articles:</p>
			<div><div><img src="img/Figure_7.01_B18321.jpg" alt="Figure 7.1 – Displays the first five articles at the root of the blog&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Displays the first five articles at the root of the blog</p>
			<p>What if I want to<a id="_idIndexMarker361"/> see more articles? We can’t, although we will resolve this in the next section. The next challenge will be to solve the problem by pagination, or rendering the next five posts continuously.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor163"/>Navigating between articles with pagination</h1>
			<p>We are able to<a id="_idIndexMarker362"/> show visitors the latest articles, but they are<a id="_idIndexMarker363"/> unable to view previous posts. We are going to include a button that allows us to render other articles on the welcome page, and we will incorporate them in blocks of five.</p>
			<p>We add a component with the button. In <code>app/website/templates/components/all_posts/_button_paginator.html</code>, add the following HTML:</p>
			<pre class="source-code">{% if not is_last_page %}</pre>
			<pre class="source-code">&lt;button class="button" id="paginator" data-next-page="{{ </pre>
			<pre class="source-code">    next_page }}"&gt;More posts&lt;/button&gt;</pre>
			<pre class="source-code">{% endif %}</pre>
			<p>We will only show the <a id="_idIndexMarker364"/>button if we are not on the last page, which we will manage with the <code>is_last_page</code> variable. In addition, we will include <a id="_idIndexMarker365"/>a dataset with the <code>next_page</code> variable to tell the backend the next page we want to render.</p>
			<p>The component is embedded in <code>app/website/templates/components/all_posts/list.html</code>:</p>
			<pre class="source-code">&lt;h1&gt;All posts&lt;/h1&gt;</pre>
			<pre class="source-code">&lt;hr&gt;</pre>
			<pre class="source-code">&lt;section&gt;</pre>
			<pre class="source-code">    {# List posts #}</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    {# End list posts #}</pre>
			<pre class="source-code">    {# Paginator #}</pre>
			<pre class="source-code">    &lt;div id="paginator"&gt;</pre>
			<pre class="source-code">        {% include </pre>
			<pre class="source-code">           "components/all_posts/_button_paginator.html" %}</pre>
			<pre class="source-code">    &lt;/div&gt;</pre>
			<pre class="source-code">    {# End paginator #}</pre>
			<pre class="source-code">&lt;/section&gt;</pre>
			<p>After designing the visual part, we will focus on the usual flow to give the logic. </p>
			<p>We go to <code>static/js/index.js</code> to capture the click event and send to the Consumer the <code>"Add next posts"</code> action <a id="_idIndexMarker366"/>with the number of the page we want to render.</p>
			<p>I have omitted the lines that are already<a id="_idIndexMarker367"/> present in the template to simplify the example:</p>
			<pre class="source-code">  </pre>
			<pre class="source-code">/**</pre>
			<pre class="source-code">* Event to add a next page with the pagination</pre>
			<pre class="source-code">* @param event</pre>
			<pre class="source-code">*/</pre>
			<pre class="source-code">function addNextPaginator(event) {</pre>
			<pre class="source-code">    const nextPage = event.target.dataset.nextPage;</pre>
			<pre class="source-code">    sendData({</pre>
			<pre class="source-code">        action: "Add next posts",</pre>
			<pre class="source-code">        data: {</pre>
			<pre class="source-code">            page: nextPage</pre>
			<pre class="source-code">        },</pre>
			<pre class="source-code">    }, myWebSocket);</pre>
			<pre class="source-code">} </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">/**</pre>
			<pre class="source-code">* Update events in every page</pre>
			<pre class="source-code">* return {void}</pre>
			<pre class="source-code">*/</pre>
			<pre class="source-code">function updateEvents() {</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">    // Paginator</pre>
			<pre class="source-code">    const paginator = document.querySelector("#paginator");</pre>
			<pre class="source-code">    if (paginator !== null) {</pre>
			<pre class="source-code">        paginator.removeEventListener("click", </pre>
			<pre class="source-code">            addNextPaginator, false);</pre>
			<pre class="source-code">        paginator.addEventListener("click", </pre>
			<pre class="source-code">            addNextPaginator, false);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">…</pre>
			<pre class="source-code">}</pre>
			<p>We add to the Consumer, hosted in <code>app/website/consumers.py</code>, the appropriate call to action if we receive <code>"Add next posts"</code>.</p>
			<p>As we have done on<a id="_idIndexMarker368"/> several occasions, we will create a <a id="_idIndexMarker369"/>link in the Consumer class between the action required by the frontend and the function hosted in <code>actions.py</code>:</p>
			<pre class="source-code">from channels.generic.websocket import </pre>
			<pre class="source-code">    JsonWebsocketConsumer</pre>
			<pre class="source-code">from asgiref.sync import async_to_sync</pre>
			<pre class="source-code">import app.website.actions as actions</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">class BlogConsumer(JsonWebsocketConsumer):</pre>
			<pre class="source-code">    room_name = "broadcast"</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def connect(self):</pre>
			<pre class="source-code">        """Event when client connects"""</pre>
			<pre class="source-code">        # Accept the connection</pre>
			<pre class="source-code">        self.accept()</pre>
			<pre class="source-code">        # Assign the Broadcast group</pre>
			<pre class="source-code">        async_to_sync(self.channel_layer.group_add)</pre>
			<pre class="source-code">            (self.room_name, self.channel_name)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def disconnect(self, close_code):</pre>
			<pre class="source-code">        """Event when client disconnects"""</pre>
			<pre class="source-code">        pass</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def receive_json(self, data_received):</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        # Get the data</pre>
			<pre class="source-code">        data = data_received["data"]</pre>
			<pre class="source-code">        # Depending on the action we will do one task or </pre>
			<pre class="source-code">         another.</pre>
			<pre class="source-code">        match data_received["action"]:</pre>
			<pre class="source-code">            case "Change page":</pre>
			<pre class="source-code">                actions.send_page(self, data)</pre>
			<pre class="source-code">            case "Add next posts":</pre>
			<pre class="source-code">                actions.add_next_posts(self, data)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def send_html(self, event):</pre>
			<pre class="source-code">        ...</pre>
			<p>In <code>app/website/actions.py</code>, we declare<a id="_idIndexMarker370"/> the <code>add_next_posts</code> function:</p>
			<pre class="source-code">POST_PER_PAGE = 5</pre>
			<pre class="source-code">def add_next_posts(self, data={}):</pre>
			<pre class="source-code">    """Add next posts from pagination"""</pre>
			<pre class="source-code">    # Prepare context data for page</pre>
			<pre class="source-code">    page = int(data["page"]) if "page" in data else 1</pre>
			<pre class="source-code">    start_of_slice = (page - 1) * POST_PER_PAGE</pre>
			<pre class="source-code">    end_of_slice = start_of_slice + POST_PER_PAGE</pre>
			<pre class="source-code">    context = {</pre>
			<pre class="source-code">        "posts": Post.objects.all()[start_of_slice:end_of_slice],</pre>
			<pre class="source-code">        "next_page": page + 1,</pre>
			<pre class="source-code">        "is_last_page": (Post.objects.count() // </pre>
			<pre class="source-code">            POST_PER_PAGE) == page,</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    # Add and render HTML with new posts</pre>
			<pre class="source-code">    self.send_html(</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            "selector": "#all-posts",</pre>
			<pre class="source-code">            "html": render_to_string</pre>
			<pre class="source-code">               ("components/all_posts/list.html", context),</pre>
			<pre class="source-code">            "append: True,</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    # Update paginator</pre>
			<pre class="source-code">    self.send_html(</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            "selector": "#paginator",</pre>
			<pre class="source-code">            "html": render_to_string(</pre>
			<pre class="source-code">                "components/all_posts/_button_paginator.</pre>
			<pre class="source-code">                     html", context</pre>
			<pre class="source-code">            ),</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    </pre>
			<p>We are undertaking <a id="_idIndexMarker371"/>a number of important actions:</p>
			<ul>
				<li>We’re saving the <a id="_idIndexMarker372"/>page to display. If it is not provided, we assume it is the first one.</li>
				<li>We’re calculating the initial and final cut-off of the results.</li>
				<li>We’re carrying out the query.</li>
				<li>We’re calculating what the next page will be – the current page plus one.</li>
				<li>We’re checking whether we are on the last page. It will be important to know whether we should print the paging button or not.</li>
				<li>We’re rendering new articles and adding them to <code>#all-posts</code>.</li>
				<li>We’re redrawing <a id="_idIndexMarker373"/>the paging button, as it<a id="_idIndexMarker374"/> needs to store what the next page is and hide it if there are no more articles.</li>
			</ul>
			<p>There is only one detail left. Give the initial parameters to the view (<code>app/website/views.py</code>):</p>
			<pre class="source-code">def all_posts(request):</pre>
			<pre class="source-code">    return render(</pre>
			<pre class="source-code">        request,</pre>
			<pre class="source-code">        "base.html",</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            "posts": Post.objects.all()[:5],</pre>
			<pre class="source-code">            "page": "pages/all_posts.html",</pre>
			<pre class="source-code">            "active_nav": "all posts",</pre>
			<pre class="source-code">            "next_page": 2, # New</pre>
			<pre class="source-code">            "is_last_page": (Post.objects.count() //</pre>
			<pre class="source-code">               POST_PER_PAGE) == 2, # New</pre>
			<pre class="source-code">        },</pre>
			<pre class="source-code">    </pre>
			<p>We can now start rendering new results:</p>
			<div><div><img src="img/Figure_7.02_B18321.jpg" alt="Figure 7.2 – The pagination of articles&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – The pagination of articles</p>
			<p>The experience <a id="_idIndexMarker375"/>would be more pleasant with a nice<a id="_idIndexMarker376"/> animation or delay; it is so fast loading that a visitor may not notice the new elements. We can leave an issue to the future web designer. Our task is not finished yet – what if the visitor is looking for a specific article? The pagination becomes cumbersome; everything would be easier with a simple search engine.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor164"/>Adding an article search engine</h1>
			<p>Offering visitors pagination is a <a id="_idIndexMarker377"/>good idea to optimize resources and offer controlled navigation. In addition, including a search engine for articles will provide complete exploration. That is why we are going to integrate a text field to find articles by title.</p>
			<p>In <code>app/website/forms.py</code>, we incorporate the following form, which will only have one field:</p>
			<pre class="source-code">from django import forms</pre>
			<pre class="source-code">from . models import Comment</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">class SearchForm(forms.Form):</pre>
			<pre class="source-code">    search = forms.CharField(</pre>
			<pre class="source-code">        label="Search",</pre>
			<pre class="source-code">        max_length=255,</pre>
			<pre class="source-code">        required=False,</pre>
			<pre class="source-code">        widget=forms.TextInput(</pre>
			<pre class="source-code">            attrs={</pre>
			<pre class="source-code">                "id": "search",</pre>
			<pre class="source-code">                "class": "input",</pre>
			<pre class="source-code">                "placeholder": "Title...",</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        ),</pre>
			<pre class="source-code">    </pre>
			<p>We will need a component to render the form we just defined. We create the <code>app/website/templates/components/all_posts/form_search.html</code> file and add the <code>search</code> field inside a form:</p>
			<pre class="source-code">&lt;form id="search-form" action=""&gt;</pre>
			<pre class="source-code">    {{ form.search }}</pre>
			<pre class="source-code">    &lt;input class="button" type="submit" value="Search"&gt;</pre>
			<pre class="source-code">&lt;/form&gt;</pre>
			<p>In the article listing page, <code>app/website/templates/pages/all_posts.html</code>, we include<a id="_idIndexMarker378"/> the <code>search</code> component:</p>
			<pre class="source-code">&lt;h1&gt; All posts&lt;/h1&gt;</pre>
			<pre class="source-code">&lt;hr&gt;</pre>
			<pre class="source-code">{# Search #}</pre>
			<pre class="source-code">&lt;section id="form-search"&gt;</pre>
			<pre class="source-code">    {% include "components/all_posts/form_search.html" %}</pre>
			<pre class="source-code">&lt;/section&gt;</pre>
			<pre class="source-code">{# End search #}</pre>
			<pre class="source-code">&lt;hr&gt;</pre>
			<pre class="source-code">&lt;section&gt;</pre>
			<pre class="source-code">    {# List posts #}</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    {# End list posts #}</pre>
			<pre class="source-code">    {# Paginator #}</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    {# End paginator #}</pre>
			<pre class="source-code">&lt;/section&gt;</pre>
			<p>Don’t forget to include it in the view (<code>app/website/views.py</code>):</p>
			<pre class="source-code">def all_posts(request):</pre>
			<pre class="source-code">    return render(</pre>
			<pre class="source-code">        request,</pre>
			<pre class="source-code">        "base.html",</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            "posts": Post.objects.all()[:5],</pre>
			<pre class="source-code">            "page": "pages/all_posts.html",</pre>
			<pre class="source-code">            "active_nav": "all posts",</pre>
			<pre class="source-code">            "form": SearchForm(), # New</pre>
			<pre class="source-code">            "next_page": 2,</pre>
			<pre class="source-code">            "is_last_page": (Post.objects.count() // </pre>
			<pre class="source-code">                POST_PER_PAGE) == 2,</pre>
			<pre class="source-code">        },</pre>
			<pre class="source-code">    </pre>
			<p>We will see the<a id="_idIndexMarker379"/> form when the page loads, although for the moment it is decorative, as there is no logic behind it:</p>
			<div><div><img src="img/Figure_7.03_B18321.jpg" alt="Figure 7.3 – Displaying the browser&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Displaying the browser</p>
			<p>Now, let’s go<a id="_idIndexMarker380"/> to <code>static/js/index.js</code> to make it work. We’ll capture the form’s submit event and send the Consumer the <code>"Search"</code> action with the text to search for:</p>
			<pre class="source-code">/**</pre>
			<pre class="source-code">* Event to request a search</pre>
			<pre class="source-code">* @param event</pre>
			<pre class="source-code">*/</pre>
			<pre class="source-code">function search(event) {</pre>
			<pre class="source-code">    event.preventDefault();</pre>
			<pre class="source-code">    const search = event.target.querySelector("#search"). value;</pre>
			<pre class="source-code">    sendData({</pre>
			<pre class="source-code">        action: "Search",</pre>
			<pre class="source-code">        data: {</pre>
			<pre class="source-code">            search: search</pre>
			<pre class="source-code">        },</pre>
			<pre class="source-code">    }, myWebSocket);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">/**</pre>
			<pre class="source-code">* Update events in every page</pre>
			<pre class="source-code">* return {void}</pre>
			<pre class="source-code">*/</pre>
			<pre class="source-code">function updateEvents() {</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">    // Search form</pre>
			<pre class="source-code">    const searchForm = document.querySelector("#search-</pre>
			<pre class="source-code">        form");</pre>
			<pre class="source-code">    if (searchForm !== null) {</pre>
			<pre class="source-code">        searchForm.removeEventListener("submit", search,         </pre>
			<pre class="source-code">            false);</pre>
			<pre class="source-code">        searchForm.addEventListener("submit", search, </pre>
			<pre class="source-code">            false);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">}</pre>
			<p>The frontend has <a id="_idIndexMarker381"/>already sent us the request and the information we need. Now, the Consumer (<code>app/website/consumers.py</code>) should execute the appropriate action:</p>
			<pre class="source-code">match data_received["action"]:</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">             case "Search":</pre>
			<pre class="source-code">                actions.search(self, data)</pre>
			<pre class="source-code">...</pre>
			<p>Then, in the action (<code>app/website/actions.py</code>), we include the <code>search</code> function:</p>
			<pre class="source-code">def search(self, data={}):</pre>
			<pre class="source-code">    "Search for posts"    ""</pre>
			<pre class="source-code">    # Prepare context data for page</pre>
			<pre class="source-code">    context = {</pre>
			<pre class="source-code">        "posts": Post.objects.filter</pre>
			<pre class="source-code">            (title__icontains=data["search"])</pre>
			<pre class="source-code">                [:POST_PER_PAGE].</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    # Render HTML page and send to client</pre>
			<pre class="source-code">    self.send_html(</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            "selector": "#all-posts",</pre>
			<pre class="source-code">            "html": render_to_string</pre>
			<pre class="source-code">               ("components/all_posts/list.html", context),</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    </pre>
			<p>As you can see, the code is simple. All we <a id="_idIndexMarker382"/>do is filter the database by getting all articles containing <code>data["search"]</code>, ignoring uppercase or lowercase text (<code>icontains</code>).  We also limit the results to five articles.</p>
			<p>That’s it. We can search and dynamically display the results:</p>
			<div><div><img src="img/Figure_7.04_B18321.jpg" alt="Figure 7.4 – Shows the results of a search for the word &quot;why&quot;&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Shows the results of a search for the word "why"</p>
			<p>If you search by leaving the string empty, you will return to the previous state where the items are listed without filtering.</p>
			<p>The next point to discuss is the navigation between pages. For this, we will create a static page, where we can describe the blog or or display the <strong class="bold">About us</strong> page, and a navigator to move between the existing pages.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor165"/>Creating a static page</h1>
			<p>We are in a situation where<a id="_idIndexMarker383"/> we need to grow with new pages to split logic and HTML structures. The first step will be to create a static page.</p>
			<p>We create <code>app/website/templates/pages/about_us.html</code> with simple text:</p>
			<pre class="source-code">&lt;h1&gt; About us&lt;/h1&gt;</pre>
			<pre class="source-code">&lt;p&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Ad animi aut beatae commodi consectetur cumque ipsam iste labore laudantium magni molestiae nobis nulla quod quos tempore totam velit, voluptas voluptates!&lt;/p&gt;</pre>
			<p>We edit the views (<code>app/website/views.py</code>), including <code>about</code>:</p>
			<pre class="source-code">def about(request):</pre>
			<pre class="source-code">    return render(</pre>
			<pre class="source-code">        request,</pre>
			<pre class="source-code">        "base.html",</pre>
			<pre class="source-code">        { "page": "pages/about_us.html", "active_nav": </pre>
			<pre class="source-code">           "about us"},</pre>
			<pre class="source-code">    </pre>
			<p>Then, we give it a path in <code>blog/urls.py</code>:</p>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">        path("about-us/", views.about, name="about us"),</pre>
			<pre class="source-code">...</pre>
			<p>We can now go to <code>http://blog.localhost/about-us/</code> to view the page:</p>
			<div><div><img src="img/Figure_7.05_B18321.jpg" alt="Figure 7.5 – Rendering the About us page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Rendering the About us page</p>
			<p>I totally agree with<a id="_idIndexMarker384"/> you; this section hasn’t been very... I plead guilty! Creating a static page is the most basic thing we can do in Django. Now, it’s time for the hard part: dynamically scrolling between pages and creating a browser.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor166"/>Moving between pages and generating a browser</h1>
			<p>Visitors need to navigate between different pages; a simple button structure and corresponding logic for loading the appropriate templates will need to be incorporated.</p>
			<p>We are going to create a browser to <a id="_idIndexMarker385"/>dynamically jump between pages or, in other <a id="_idIndexMarker386"/>words, request the backend to render the page in the right place:</p>
			<ol>
				<li value="1">The first step is to create a component with hyperlinks. We create a file in <code>app/website/templates/components/_nav.html</code> with the following structure:<pre>&lt;ul class="nav__ul"&gt;
    &lt;li&gt;
        &lt;a
                href="#"
                class="nav__link nav__link nav__link--page{% if active_nav == "all posts" %} active{% endif %}""
                data-target="all posts"
        &gt;
            All posts
        &lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a
                href="#"
                class="nav__link nav__link nav__link
                    page{% if active_nav == "about us" 
                        %} active{% endif %}"
                data-target="about us"
        &gt;
            About us
        &lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;</pre></li>
			</ol>
			<p><code>The active_nav</code> variable is worth mentioning. We have defined it in each view for this particular <a id="_idIndexMarker387"/>component. It will add a CSS class that visually<a id="_idIndexMarker388"/> marks where the visitor is. We also include the <code>target</code> dataset to know where each hyperlink should point to.</p>
			<p>Next, we are going to capture the events of the hyperlinks in JavaScript whose objective is to change the page, both those present in the browser and the list of articles:</p>
			<ol>
				<li value="2">We add the<a id="_idIndexMarker389"/> following in <code>static/js/index.js</code>:<pre>/**
* Send message to update page
* @param {Event} event
* @returns {void}
*/
function changePage(event) {
    event.preventDefault();
    sendData({
        action: "Change page",
        data: {
            page: event.target.dataset.target,
            id: event.target. dataset?.id
        }
    }, myWebSocket);
}
/**
* Update events in every page
* return {void}
*/
function updateEvents() {
...
    // Navigation
    document.querySelectorAll(".nav__link--page").forEach(link =&gt; {
        link.removeEventListener("click", changePage, false);
        link.addEventListener("click", changePage, false);
    });
    // Link to single post
    const linksPostItem = document.querySelectorAll
        (".post-item__link");
    if (linksPostItem !== null) {
        linksPostItem.forEach(link =&gt; {
            link.removeEventListener("click", 
                changePage, false);
            link.addEventListener("click", changePage,       
                false);
        });
    }
…
 }</pre></li>
			</ol>
			<p>When the<a id="_idIndexMarker390"/> hyperlinks are clicked, a request will be made to the Consumer to <a id="_idIndexMarker391"/>change the page by sending the name of the template and, if it exists, the ID of the post.</p>
			<ol>
				<li value="3">We include in the Consumer (<code>app/website/consumers.py</code>) the <code>send_page</code> call when we receive <code>"Change page"</code>:<pre>...
ca"e "Change page":
actions.send_page(self, data)
...</pre></li>
				<li>In action, we<a id="_idIndexMarker392"/> edit the <code>send_page</code> function, as we have done in previous projects, by adding <a id="_idIndexMarker393"/>the template context template: <pre>POST_PER_PAGE = 5
 
def send_page(self, data={}):
...
     match page:
        case "all posts":
            context = {
                "posts": Post.objects.all()
                    [:POST_PER_PAGE],
                "form": SearchForm(),
                "next_page": 2,
                "is_last_page": (Post.objects.count() 
                // POST_PER_PAGE) == 2,
            }
 ...</pre></li>
			</ol>
			<p>It is practically the same as the view in charge of displaying all items.</p>
			<p>We can now move<a id="_idIndexMarker394"/> between pages and visualize where we are with the CSS styling:</p>
			<div><div><img src="img/Figure_7.06_B18321.jpg" alt="Figure 7.6 – The browser shows that we are in All posts&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – The browser shows that we are in All posts</p>
			<p>We manage all cases. The visitor can navigate from any type of page, from a dynamic page to another where the content is static.</p>
			<div><div><img src="img/Figure_7.07_B18321.jpg" alt="Figure 7.7 – The browser shows that we are in About us&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – The browser shows that we are in About us</p>
			<p>However, the dynamic <a id="_idIndexMarker395"/>page showing the full text of the article and comments is still missing. By having a system for navigation, it will be relatively easy to incorporate it.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor167"/>Implementing an individual page per article</h1>
			<p>We have the opportunity to create a <a id="_idIndexMarker396"/>page that renders an entire article, which will be the basis for the entire commenting system.</p>
			<p>We create the template in <code>app/website/templates/pages/single_post.html</code> with basic but sufficient HTML for the minimum <code>Post</code> fields:</p>
			<pre class="source-code">&lt;section&gt;</pre>
			<pre class="source-code">    {# Post #}</pre>
			<pre class="source-code">    &lt;article&gt;</pre>
			<pre class="source-code">        &lt;header&gt;</pre>
			<pre class="source-code">            &lt;h1&gt;{{ post.title }}&lt;/h1&gt;</pre>
			<pre class="source-code">        &lt;/header&gt;</pre>
			<pre class="source-code">        &lt;div&gt;{{ post.content }}&lt;/div&gt;</pre>
			<pre class="source-code">        &lt;footer&gt;</pre>
			<pre class="source-code">            &lt;p&gt;{{ post.author }}&lt;/p&gt;</pre>
			<pre class="source-code">        &lt;/footer&gt;</pre>
			<pre class="source-code">    &lt;/article&gt;</pre>
			<pre class="source-code">    {# End post #}</pre>
			<pre class="source-code">&lt;/section&gt;</pre>
			<p>Now, we are going to<a id="_idIndexMarker397"/> focus on server-side rendering by creating the view and its path.</p>
			<p>In <code>app/website/views.py</code>, we include the following function:</p>
			<pre class="source-code">from .models import Post</pre>
			<pre class="source-code">def single_post(request, slug):</pre>
			<pre class="source-code">    post = list(filter(lambda post: post.slug == slug, Post.objects.all()))[0]</pre>
			<pre class="source-code">    return render(</pre>
			<pre class="source-code">        request,</pre>
			<pre class="source-code">        "base.html",</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            "post: post,</pre>
			<pre class="source-code">            "page": "pages/single_post.html",</pre>
			<pre class="source-code">        },</pre>
			<pre class="source-code">    </pre>
			<p>Why use the <code>filter</code> function? As we have decided that the URL will be formed by a slug, when we receive the request to render the view, we will need to look for the post with the <code>slug</code> property. Django <a id="_idIndexMarker398"/>does not allow you to perform a query through a property. In other words, we will have to perform manual filtering.</p>
			<p>We incorporate the route in <code>blog/urls.py</code>: </p>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    path("article/&lt;slug:slug&gt;/", views.single_post, </pre>
			<pre class="source-code">        name="single post"),</pre>
			<pre class="source-code">    ...</pre>
			<p>Now, we need to incorporate a context, or a set of variables needed to render the new HTML, when the frontend request to switch pages. In <code>app/website/actions.py</code>, we add the following: </p>
			<pre class="source-code">data_reverse = {}</pre>
			<pre class="source-code">match page:</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">        case "single post":</pre>
			<pre class="source-code">            post = Post.objects.get(id=data["id"])</pre>
			<pre class="source-code">            context = {</pre>
			<pre class="source-code">                "post: post,</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            data_reverse = {"slug": post.slug}</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">self.send_html(</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            "selector": "#main",</pre>
			<pre class="source-code">            "html": render_to_string(f </pre>
			<pre class="source-code">                "pages/{template_page}.html", context),</pre>
			<pre class="source-code">            "url": reverse(page, kwargs=data_reverse),</pre>
			<pre class="source-code">        }</pre>
			<p>At this moment, from the list of<a id="_idIndexMarker399"/> articles, we will be able to load the single template. Also, the path will change with the URL structure of the slug:</p>
			<div><div><img src="img/Figure_7.08_B18321.jpg" alt="Figure 7.8 – The individual article page is rendered&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – The individual article page is rendered</p>
			<p>However, the page is not finished; we still need to list the comments at the bottom of the template and include a form to add new ones.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor168"/>Adding a list of comments</h1>
			<p>The blog is functional: we can<a id="_idIndexMarker400"/> list articles, navigate between pages, paginate, and perform a search. But an essential element is still missing: comments. That’s why we are going to print all the comments that belong to an article.</p>
			<p>We start by creating a template that lists all the comments. We add a new component in <code>app/website/templates/components/_list_of_comments.html</code> with the following content:</p>
			<pre class="source-code">{% for comment in comments %}</pre>
			<pre class="source-code">    {% include "components/_single_comment.html" with </pre>
			<pre class="source-code">       comment=comment %}</pre>
			<pre class="source-code">{% endfor %}</pre>
			<p>This, in turn, will need the <code>app/website/templates/components/_single_comment.html</code> component:</p>
			<pre class="source-code">&lt;article&gt;</pre>
			<pre class="source-code">    &lt;h2&gt;{{ comment.author }}&lt;/h2&gt;</pre>
			<pre class="source-code">    &lt;p&gt;{{ comment.content }}&lt;/p&gt;</pre>
			<pre class="source-code">    &lt;p&gt;{{ comment.created_at }}&lt;/p&gt;</pre>
			<pre class="source-code">&lt;/article&gt;</pre>
			<p>In the views (<code>app/website/views.py</code>), we make a query with all the comments that belong to the post we <a id="_idIndexMarker401"/>are viewing and send it to the template:</p>
			<pre class="source-code">from .models import Post, Comment</pre>
			<pre class="source-code">def single_post(request, slug):</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            "post: post,</pre>
			<pre class="source-code">            "page": "pages/single_post.html",</pre>
			<pre class="source-code">            "active_nav": "single post",</pre>
			<pre class="source-code">            "comments": Comment.objects.filter(post=post), # New</pre>
			<pre class="source-code">        },</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">...</pre>
			<p>We can now display a list of comments on the article.</p>
			<div><div><img src="img/Figure_7.09_B18321.jpg" alt="Figure 7.9 – All comments are rendered on the article page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – All comments are rendered on the article page</p>
			<p>However, to also <a id="_idIndexMarker402"/>display comments when we dynamically change pages, we must include the comment variable inside <code>send_page</code> in actions:</p>
			<pre class="source-code">def send_page(self, data={}):</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        case "single post":</pre>
			<pre class="source-code">            post = Post.objects.get(id=data["id"])</pre>
			<pre class="source-code">            context = {</pre>
			<pre class="source-code">                "post: post,</pre>
			<pre class="source-code">                "form": CommentForm(),</pre>
			<pre class="source-code">                "comments": Comment.objects.filter(post=post), # New</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            data_reverse = {"slug": post.slug}</pre>
			<pre class="source-code"> ...</pre>
			<p>We will now incorporate a form for visitors to add comments. But that’s not all: we have generated random information, article listings, a single page per article, a system for dynamically switching <a id="_idIndexMarker403"/>between pages, a browser, a search engine, and a server-side rendering system. At the moment, we have a very interesting blog. Next, we’ll see how to add new comments.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor169"/>Adding new comments</h1>
			<p>If all the comments were <a id="_idIndexMarker404"/>written by us, it would be a bit immoral. We’re going to incorporate a form so that anyone reading the article can leave a personal opinion. If you don’t like what they say, you can always "manage" it with Django’s admin panel. But for now, let’s not be tricky; let’s focus on the more technical side.</p>
			<p>First, we add the following form in <code>app/website/forms.py</code>:</p>
			<pre class="source-code">class CommentForm(forms.ModelForm):</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    author = forms.CharField(</pre>
			<pre class="source-code">        widget=forms.TextInput(</pre>
			<pre class="source-code">            attrs={</pre>
			<pre class="source-code">                "id": "author",</pre>
			<pre class="source-code">                "class": "input",</pre>
			<pre class="source-code">                "placeholder": "Your name...",</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        ),</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    content = forms.CharField(</pre>
			<pre class="source-code">        widget=forms.Textarea(</pre>
			<pre class="source-code">            attrs={</pre>
			<pre class="source-code">                "id": "content",</pre>
			<pre class="source-code">                "class": "input",</pre>
			<pre class="source-code">                "placeholder": "Your comment...",</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        ),</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    class Meta:</pre>
			<pre class="source-code">        model = Comment</pre>
			<pre class="source-code">        fields = ("author", "content", "post")</pre>
			<p>There is an important difference with respect to the search engine form: we use <code>ModelForm</code>. Now we can create a new comment from the form object itself.</p>
			<p>In the views (<code>app/website/views.py</code>), we import and include the form object in the template:</p>
			<pre class="source-code">from . forms import SearchForm, CommentForm</pre>
			<pre class="source-code">def single_post(request, slug):</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            "post: post,</pre>
			<pre class="source-code">            "page": "pages/single_post.html",</pre>
			<pre class="source-code">            "active_nav": "single post",</pre>
			<pre class="source-code">            "comments": Comment.objects.filter(post=post),</pre>
			<pre class="source-code">            "form": CommentForm(), # New</pre>
			<pre class="source-code">        },</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">...</pre>
			<p>Now, in <code>app/website/templates/pages/single_post.html</code>, we<a id="_idIndexMarker405"/> render the form:</p>
			<pre class="source-code">   ...</pre>
			<pre class="source-code">{# Comments #}</pre>
			<pre class="source-code">    &lt;div id="comments"&gt;</pre>
			<pre class="source-code">        &lt;h2&gt; Comments&lt;/h2&gt;</pre>
			<pre class="source-code">        &lt;form id="comment-form" action="" data-post-id="{{ </pre>
			<pre class="source-code">            post.id }}"&gt;</pre>
			<pre class="source-code">            {{ form.author }}</pre>
			<pre class="source-code">            {{ form.content }}</pre>
			<pre class="source-code">            &lt;input class="button" type="submit" </pre>
			<pre class="source-code">                value="Add"&gt;</pre>
			<pre class="source-code">        &lt;/form&gt;</pre>
			<pre class="source-code">        &lt;div id="list-of-comments"&gt;</pre>
			<pre class="source-code">            {% include "components/_list_of_comments.html" %}</pre>
			<pre class="source-code">        &lt;/div&gt;</pre>
			<pre class="source-code">    &lt;/div&gt;</pre>
			<pre class="source-code">    {# End comments #}</pre>
			<pre class="source-code">&lt;/section&gt;</pre>
			<p>By clicking on any <a id="_idIndexMarker406"/>item, you will be able to view the form:</p>
			<div><div><img src="img/Figure_7.10_B18321.jpg" alt="Figure 7.10 – Render the form to add new comments&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Render the form to add new comments</p>
			<p>Now, we are going<a id="_idIndexMarker407"/> to process the form from the frontend. We capture the submit event and when it fires, we will get the three fields: author, content, and the article ID. We will send a request to execute the <code>"Add comment"</code> action.</p>
			<p>We add in <code>static/js/index.js</code> the following functions:</p>
			<pre class="source-code">function addComment(event) {</pre>
			<pre class="source-code">    event.preventDefault();</pre>
			<pre class="source-code">    const author = event.target.querySelector("#author"). value;</pre>
			<pre class="source-code">    const content = event.target.querySelector("#content"). value;</pre>
			<pre class="source-code">    const postId = event.target.dataset.postId;</pre>
			<pre class="source-code">    sendData({</pre>
			<pre class="source-code">        action: "Add comment",</pre>
			<pre class="source-code">        data: {</pre>
			<pre class="source-code">            author: author,</pre>
			<pre class="source-code">            content: content,</pre>
			<pre class="source-code">            post_id: postId</pre>
			<pre class="source-code">        },</pre>
			<pre class="source-code">    }, myWebSocket);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">function updateEvents() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    // Comment form</pre>
			<pre class="source-code">    const commentForm = document.querySelector("#comment-form");</pre>
			<pre class="source-code">    if (commentForm !== null) {</pre>
			<pre class="source-code">        commentForm.removeEventListener("submit", addComment, false);</pre>
			<pre class="source-code">        commentForm.addEventListener("submit", addComment, false);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">}</pre>
			<p>In the Consumer, <code>app/website/consumers.py</code>, we call the <code>add_comment</code> function inside actions if we receive <code>"Add comment"</code>:</p>
			<pre class="source-code">        match data_received["action"]:</pre>
			<pre class="source-code">...            </pre>
			<pre class="source-code">            case "Add comment":</pre>
			<pre class="source-code">                actions.add_comment(self, data)</pre>
			<p>To finish the flow, in actions (<code>app/website/actions.py</code>), we create the function that invokes the<a id="_idIndexMarker408"/> Consumer – <code>add_comment</code>:</p>
			<pre class="source-code">from . models import Post, Comment</pre>
			<pre class="source-code">from . forms import SearchForm, CommentForm</pre>
			<pre class="source-code">def add_comment(self, data):</pre>
			<pre class="source-code">    """Add new comment to database""""</pre>
			<pre class="source-code">    # Add post</pre>
			<pre class="source-code">    data_with_post = data.copy()</pre>
			<pre class="source-code">    post = Post.objects.get(id=data["post_id"])</pre>
			<pre class="source-code">    data_with_post["post"] = post</pre>
			<pre class="source-code">    # Set initial values by CommentForm</pre>
			<pre class="source-code">    form = CommentForm(data_with_post)</pre>
			<pre class="source-code">    # Check if form is valid</pre>
			<pre class="source-code">    if form.is_valid():</pre>
			<pre class="source-code">        # Save comment</pre>
			<pre class="source-code">        form.save()</pre>
			<pre class="source-code">        # Render HTML with new comment to all clients</pre>
			<pre class="source-code">        async_to_sync(self.channel_layer.group_send)(</pre>
			<pre class="source-code">            self.room_name,</pre>
			<pre class="source-code">            {</pre>
			<pre class="source-code">                "type": "send.html", # Run "send_html()" </pre>
			<pre class="source-code">                    method</pre>
			<pre class="source-code">                "selector": "#comments",</pre>
			<pre class="source-code">                "html": render_to_string(</pre>
			<pre class="source-code">                    "components/_single_comment.html", </pre>
			<pre class="source-code">                      {"comment": data}, {"comment": data}.</pre>
			<pre class="source-code">                ),</pre>
			<pre class="source-code">                "append": True,</pre>
			<pre class="source-code">                "broadcast: True,</pre>
			<pre class="source-code">                "url": reverse("single post", </pre>
			<pre class="source-code">                    kwargs={"slug": post.slug}),</pre>
			<pre class="source-code">            },</pre>
			<pre class="source-code">        </pre>
			<p>We are carrying out<a id="_idIndexMarker409"/> a set of actions that must be in the following order:</p>
			<ol>
				<li value="1">We obtain the post from the ID received.</li>
				<li>We include the post inside the dictionary with all the information. We need to add the object to perform the validation of the form.</li>
				<li>With the dictionary, we initialize the form.</li>
				<li>We validate that the fields are correct. If they are not, the rest of the code will simply be ignored.</li>
				<li>If they are correct, we create the new comment in the database with <code>form.save()</code>. The form knows which model to create because, internally, it is <code>ModelForm</code>, and we tell it in <code>forms.py</code>.</li>
				<li>We send to all connected clients the HTML of the new comment.</li>
				<li>Not only is the comment validated and saved, but it is also sent to all readers of the article in real time. However, you should be aware that we are not giving feedback in case<a id="_idIndexMarker410"/> the fields are not valid. Simply, until all fields are filled in, the information will not be processed.</li>
			</ol>
			<p>We could stop here, but there is still one detail that I think is indispensable if we create a blog: an RSS feed so that our future visitors can be informed of the latest news.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor170"/>Offering an RSS feed</h1>
			<p>Tech blogs are often<a id="_idIndexMarker411"/> consumed by robots, in particular by feed readers. If we want to build a feed in Django, it’s really convenient. Django incorporates a framework called <strong class="bold">Syndication</strong> that automates tasks <a id="_idIndexMarker412"/>such as dynamic generation of XML, fields, and caching.</p>
			<p>In <code>app/website/feed.py</code>, we add the following class that inherits from <code>Feed</code>:</p>
			<pre class="source-code">from django.contrib.syndication.views import Feed</pre>
			<pre class="source-code">from django.urls import reverse</pre>
			<pre class="source-code">from .models import Post</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">class LatestEntriesFeed(Feed):</pre>
			<pre class="source-code">    title = "My blog"</pre>
			<pre class="source-code">    link = "/feed/"</pre>
			<pre class="source-code">    description = "Updates to posts."</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def items(self):</pre>
			<pre class="source-code">        return Post.objects.all()[:5]</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def item_title(self, item):</pre>
			<pre class="source-code">        return item.title</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def item_description(self, item):</pre>
			<pre class="source-code">        return item.summary</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def item_link(self, item):</pre>
			<pre class="source-code">        return reverse("single post", kwargs={"slug": </pre>
			<pre class="source-code">            item.slug})</pre>
			<p>Finally, we include its path in <code>blog/urls.py</code>:</p>
			<pre class="source-code">...</pre>
			<pre class="source-code">from app.website import views, feed</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    path("feed/", feed.LatestEntriesFeed(), name="feed"),</pre>
			<pre class="source-code">    ...</pre>
			<p>You can give your favorite feed<a id="_idIndexMarker413"/> reader client the <code>http://blog.localhost/feed/</code> path. If you enter it directly from the browser, an XML file will be downloaded.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor171"/>Summary</h1>
			<p>We could consider this chapter as a consummation of all the skills acquired throughout the book. Not only are we able to incorporate a WebSockets server into Django, through channels; we now also have techniques to create a real-time, single-page application using Python. We now have a deep knowledge that matches the results we can achieve with other similar projects, such as LiveView in Phoenix (the most popular framework in the Elixir ecosystem), StimulusReflex, Turbo, Action Cable, or Hotwire in Ruby on Rails.</p>
			<p>If we are looking to abstract part of the process, there are some frameworks within Django that can be useful, such as Django Sockpuppet or Django Reactor. Unfortunately, neither of them is receiving updates, although it is a great idea to find out how they are constructed in order to further expand our knowledge.</p>
			<p>Although the backend is covered, it is still cumbersome to work with the frontend. Events have to be redeclared on every draw, and there are tasks that we repeat recurrently on every element we want to manage. We need to simplify the process.</p>
			<p>In the next chapter, <a href="B18321_08_ePub.xhtml#_idTextAnchor173"><em class="italic">Chapter 8</em></a>, <em class="italic"> Simplifying the Frontend</em>, we will use a JavaScript event library specially designed to rebuild the DOM without altering the way it works. </p>
		</div>
		<div><div></div>
		</div>
	</body></html>