- en: Chapter 2. Digging Deep into Requests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 深入挖掘请求
- en: In this chapter, we are going to deal with advanced topics in the Requests module.
    There are many more features in the Requests module that makes the interaction
    with the web a cakewalk. Let us get to know more about different ways to use Requests
    module which helps us to understand the ease of using it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Requests 模块的高级主题。Requests 模块中还有许多更多功能，使得与网络的交互变得轻而易举。让我们更深入地了解使用
    Requests 模块的不同方法，这有助于我们理解其使用的便捷性。
- en: 'In a nutshell, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们将涵盖以下主题：
- en: Persisting parameters across requests using Session objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Session 对象在请求间持久化参数
- en: Revealing the structure of request and response
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭示请求和响应的结构
- en: Using prepared requests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预定义请求
- en: Verifying SSL certificate with Requests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Requests验证SSL证书
- en: Body Content Workflow
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体内容工作流程
- en: Using generator for sending chunk encoded requests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成器发送分块编码的请求
- en: Getting the request method arguments with event hooks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件钩子获取请求方法参数
- en: Iterating over streaming API
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历流式API
- en: Self-describing the APIs with link headers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用链接头描述API
- en: Transport Adapter
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输适配器
- en: Persisting parameters across Requests using Session objects
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Session 对象在请求间持久化参数
- en: The Requests module contains a `session` object, which has the capability to
    persist settings across the requests. Using this `session` object, we can persist
    cookies, we can create prepared requests, we can use the keep-alive feature and
    do many more things. The Session object contains all the methods of Requests API
    such as `GET`, `POST`, `PUT`, `DELETE` and so on. Before using all the capabilities
    of the Session object, let us get to know how to use sessions and persist cookies
    across requests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Requests模块包含一个`session`对象，该对象具有在请求之间持久化设置的能力。使用这个`session`对象，我们可以持久化cookies，我们可以创建准备好的请求，我们可以使用keep-alive功能，并且可以做更多的事情。Session对象包含了Requests
    API的所有方法，如`GET`、`POST`、`PUT`、`DELETE`等等。在使用Session对象的所有功能之前，让我们了解一下如何使用会话并在请求之间持久化cookies。
- en: Let us use the session method to get the resource.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用会话方法来获取资源。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, we created a `session` object with `requests` and
    its `get` method is used to access a web resource.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用`requests`创建了一个`session`对象，并使用其`get`方法来访问网络资源。
- en: The `cookie` value which we had set in the previous example will be accessible
    using `response.request.headers`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中我们设置的`cookie`值可以通过`response.request.headers`来访问。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With `session` object, we can specify some default values of the properties,
    which needs to be sent to the server using GET, POST, PUT and so on. We can achieve
    this by specifying the values to the properties like `headers`, `auth` and so
    on, on a `Session` object.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `session` 对象，我们可以指定一些属性的默认值，这些值需要通过 GET、POST、PUT 等方式发送到服务器。我们可以通过在 `Session`
    对象上指定 `headers`、`auth` 等属性的值来实现这一点。
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding example, we have set some default values to the properties—`params`,
    `auth`, and `headers` using the `session` object. We can override them in the
    subsequent request, as shown in the following example, if we want to:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`session`对象为属性设置了一些默认值——`params`、`auth`和`headers`。如果我们想在后续请求中覆盖它们，可以像以下示例中那样操作：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Revealing the structure of a request and response
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭示请求和响应的结构
- en: 'A Requests object is the one which is created by the user when he/she tries
    to interact with a web resource. It will be sent as a prepared request to the
    server and does contain some parameters which are optional. Let us have an eagle
    eye view on the parameters:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请求对象是用户在尝试与网络资源交互时创建的。它将以准备好的请求形式发送到服务器，并且包含一些可选的参数。让我们来仔细看看这些参数：
- en: '`Method`: This is the HTTP method to be used to interact with the web service.
    For example: GET, POST, PUT.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`方法`: 这是与网络服务交互所使用的 HTTP 方法。例如：GET、POST、PUT。'
- en: '`URL`: The web address to which the request needs to be sent.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URL`: 需要发送请求的网页地址。'
- en: '`headers`: A dictionary of headers to be sent in the request.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`: 请求中要发送的头部信息字典。'
- en: '`files`: This can be used while dealing with the multipart upload. It''s the
    dictionary of files, with key as file name and value as file object.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`files`: 在处理分片上传时可以使用。这是一个文件字典，键为文件名，值为文件对象。'
- en: '`data`: This is the body to be attached to the `request.json`. There are two
    cases that come in to the picture here:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这是要附加到`request.json`的正文。这里有两种情况会出现：'
- en: If `json` is provided, `content-type` in the header is changed to `application/json`
    and at this point, `json` acts as a body to the request.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供了`json`，则头部中的`content-type`会被更改为`application/json`，在此点，`json`作为请求的主体。
- en: In the second case, if both `json` and `data` are provided together, `data`
    is silently ignored.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二种情况下，如果同时提供了`json`和`data`，则`data`会被静默忽略。
- en: '`params`: A dictionary of URL parameters to append to the URL.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params`：一个字典，包含要附加到URL的URL参数。'
- en: '`auth`: This is used when we need to specify the authentication to the request.
    It''s a tuple containing username and password.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth`: 这用于我们在需要指定请求的认证时。它是一个包含用户名和密码的元组。'
- en: '`cookies`: A dictionary or a cookie jar of cookies which can be added to the
    request.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookies`：一个字典或饼干罐，可以添加到请求中。'
- en: '`hooks`: A dictionary of callback hooks.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hooks`: 回调钩子的字典。'
- en: A Response object contains the response of the server to a HTTP request. It
    is generated once Requests gets a response back from the server. It contains all
    of the information returned by the server and also stores the Request object we
    created originally.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 响应对象包含服务器对 HTTP 请求的响应。它是在 Requests 从服务器收到响应后生成的。它包含了服务器返回的所有信息，同时也存储了我们最初创建的请求对象。
- en: 'Whenever we make a call to a server using the `requests`, two major transactions
    are taking place in this context which are listed as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们使用 `requests` 向服务器发起调用时，在此背景下会发生两个主要的事务，具体如下：
- en: We are constructing a Request object which will be sent out to the server to
    request a resource
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在构建一个请求对象，该对象将被发送到服务器以请求资源
- en: A Response object is generated by the `requests` module
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由`requests`模块生成一个响应对象
- en: Now, let us look at an example of getting a resource from Python's official
    site.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个从Python官方网站获取资源的例子。
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding line of code, a `requests` object gets constructed and will
    be sent to `''https://python.org''`. Thus obtained Requests object will be stored
    in the `response.request` variable. We can access the headers of the Request object
    which was sent off to the server in the following way:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，创建了一个`requests`对象，并将发送到`'https://python.org'`。因此获得的Requests对象将被存储在`response.request`变量中。我们可以以下这种方式访问发送到服务器的请求对象的头部信息：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The headers returned by the server can be accessed with its ''headers'' attribute
    as shown in the following example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器返回的标题可以通过其 'headers' 属性进行访问，如下例所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `response` object contains different attributes like `_content`, `status_code`,
    `headers`, `url`, `history`, `encoding`, `reason`, `cookies`, `elapsed`, `request`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`response` 对象包含不同的属性，如 `_content`、`status_code`、`headers`、`url`、`history`、`encoding`、`reason`、`cookies`、`elapsed`、`request`。'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using prepared Requests
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用准备好的 Requests
- en: Every request we send to the server turns to be a `PreparedRequest` by default.
    The `request` attribute of the `Response` object which is received from an API
    call or a session call is actually the `PreparedRequest` that was used.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发送给服务器的每个请求默认都会转换为`PreparedRequest`。从API调用或会话调用中接收到的`Response`对象的`request`属性实际上就是使用的`PreparedRequest`。
- en: 'There might be cases in which we ought to send a request which would incur
    an extra step of adding a different parameter. Parameters can be `cookies`, `files`,
    `auth`, `timeout` and so on. We can handle this extra step efficiently by using
    the combination of sessions and prepared requests. Let us look at an example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在需要发送请求并额外添加不同参数的情况。参数可以是`cookies`、`files`、`auth`、`timeout`等等。我们可以通过使用会话和预请求的组合来高效地处理这个额外步骤。让我们来看一个例子：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are trying to send a `get` request with a header in the previous example.
    Now, take an instance where we are planning to send the request with the same
    method, URL, and headers, but we want to add some more parameters to it. In this
    condition, we can use the session method to receive complete session level state
    to access the parameters of the initial sent request. This can be done by using
    the `session` object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的例子中尝试发送一个带有头部的`get`请求。现在，假设我们打算使用相同的方法、URL和头部信息发送请求，但想要添加一些额外的参数。在这种情况下，我们可以使用会话方法来接收完整的会话级别状态，以便访问最初发送请求的参数。这可以通过使用`session`对象来实现。
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let us prepare a request using the `session` object to get the values
    of the `session` level state:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`session`对象来准备一个请求，以获取`session`级别的状态值：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can send the request object `request` with more parameters now, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以发送带有更多参数的请求对象 `request`，如下所示：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Voila! Huge time saving!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！节省了大量时间！
- en: The `prepare` method prepares the complete request with the supplied parameters.
    In the previous example, the `prepare_request` method was used. There are also
    some other methods like `prepare_auth`, `prepare_body`, `prepare_cookies`, `prepare_headers`,
    `prepare_hooks`, `prepare_method`, `prepare_url` which are used to create individual
    properties.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`prepare` 方法使用提供的参数准备完整的请求。在之前的示例中使用了 `prepare_request` 方法。还有一些其他方法，如 `prepare_auth`、`prepare_body`、`prepare_cookies`、`prepare_headers`、`prepare_hooks`、`prepare_method`、`prepare_url`，这些方法用于创建单个属性。'
- en: Verifying an SSL certificate with Requests
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Requests验证SSL证书
- en: Requests provides the facility to verify an SSL certificate for HTTPS requests.
    We can use the `verify` argument to check whether the host's SSL certificate is
    verified or not.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Requests 提供了验证 HTTPS 请求的 SSL 证书的功能。我们可以使用 `verify` 参数来检查主机的 SSL 证书是否已验证。
- en: Let us consider a website which has got no SSL certificate. We shall send a
    GET request with the argument `verify` to it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个没有SSL证书的网站。我们将向其发送带有参数`verify`的GET请求。
- en: 'The syntax to send the request is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 发送请求的语法如下：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As the website doesn''t have an SSL certificate, it will result an error similar
    to the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该网站没有SSL证书，将会导致类似以下错误：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let us verify the SSL certificate for a website which is certified. Consider
    the following example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证一个已认证网站的SSL证书。考虑以下示例：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding example, the result was `200,` as the mentioned website is
    SSL certified one.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，结果是`200`，因为提到的网站是SSL认证的。
- en: If we do not want to verify the SSL certificate with a request, then we can
    put the argument `verify=False`. By default, the value of `verify` will turn to
    `True`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想通过请求验证SSL证书，那么我们可以将参数设置为`verify=False`。默认情况下，`verify`的值将变为`True`。
- en: Body Content Workflow
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主体内容工作流程
- en: 'Take an instance where a continuous stream of data is being downloaded when
    we make a request. In this situation, the client has to listen to the server continuously
    until it receives the complete data. Consider the case of accessing the content
    from the response first and the worry about the body next. In the above two situations,
    we can use the parameter `stream`. Let us look at an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个在我们发起请求时正在下载连续数据流的例子来说明。在这种情况下，客户端必须持续监听服务器，直到接收到完整的数据。考虑先访问响应内容，然后再担心体（body）的情况。在上面的两种情况下，我们可以使用参数`stream`。让我们来看一个例子：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we make a request with the parameter `stream=True,` the connection remains
    open and only the headers of the response will be downloaded. This gives us the
    capability to fetch the content whenever we need by specifying the conditions
    like the number of bytes of data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用参数 `stream=True,` 发起请求，连接将保持开启状态，并且只会下载响应的头信息。这使我们能够通过指定条件，如数据字节数，在需要时随时获取内容。
- en: 'The syntax is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By setting the parameter `stream=True` and by accessing the response as a file-like
    object that is `response.raw`, if we use the method `iter_content,` we can iterate
    over `response.data`. This will avoid reading of larger responses at once.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置参数 `stream=True` 并将响应作为类似文件的 `response.raw` 对象访问，如果我们使用 `iter_content` 方法，我们可以遍历
    `response.data`。这将避免一次性读取较大的响应。
- en: 'The syntax is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the same way, we can iterate through the content using `iter_lines` method
    which will iterate over the response data one line at a time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们可以使用`iter_lines`方法遍历内容，该方法将逐行遍历响应数据。
- en: 'The syntax is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The important thing that should be noted while using the `stream` parameter
    is it doesn't release the connection when it is set as `True,` unless all the
    data is consumed or `response.close` is executed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`stream`参数时需要注意的重要事项是，当它被设置为`True`时，并不会释放连接，除非所有数据都被消耗或者执行了`response.close`。
- en: The Keep-alive facility
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Keep-alive功能
- en: As the `urllib3` supports the reuse of the same socket connection for multiple
    requests, we can send many requests with one socket and receive the responses
    using the keep-alive feature in the `Requests` library.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`urllib3`支持对同一套接字连接进行多次请求的重用，我们可以使用一个套接字发送多个请求，并通过`Requests`库中的keep-alive功能接收响应。
- en: Within a session, it turns to be automatic. Every request made within a session
    automatically uses the appropriate connection by default. The connection that
    is being used will be released after all the data from the body is read.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个会话中，它变成了自动的。会话中提出的每个请求默认都会自动使用适当的连接。在读取完所有来自主体的数据后，所使用的连接将被释放。
- en: Streaming uploads
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流式上传
- en: A file-like object which is of massive size can be streamed and uploaded using
    the `Requests` library. All we need to do is to supply the contents of the stream
    as a value to the `data` attribute in the `request` call as shown in the following
    lines.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类似文件的大尺寸对象可以使用`Requests`库进行流式传输和上传。我们所需做的只是将流的内容作为值提供给`request`调用中的`data`属性，如下面的几行所示。
- en: 'The syntax is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using generator for sending chunk encoded Requests
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用生成器发送分块编码的请求
- en: Chunked transfer encoding is a mechanism for transferring data in an HTTP request.
    With this mechanism, the data is sent in a series of chunks. Requests supports
    chunked transfer encoding, for both outgoing and incoming requests. In order to
    send a chunk encoded request, we need to supply a generator for your body.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 分块传输编码是HTTP请求中传输数据的一种机制。通过这个机制，数据被分成一系列的数据块进行发送。请求支持分块传输编码，适用于出站和入站请求。为了发送一个分块编码的请求，我们需要提供一个用于你主体的生成器。
- en: 'The usage is shown in the following example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法如下所示：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Getting the request method arguments with event hooks
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件钩子获取请求方法参数
- en: 'We can alter the portions of the request process signal event handling using
    hooks. For example, there is hook named `response` which contains the response
    generated from a request. It is a dictionary which can be passed as a parameter
    to the request. The syntax is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用钩子来修改请求过程信号事件的处理部分。例如，有一个名为`response`的钩子，它包含了从请求生成的响应。它是一个可以作为请求参数传递的字典。其语法如下：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `callback_function` parameter may or may not return a value. When it returns
    a value, it is assumed that it is to replace the data that was passed in. If the
    callback function doesn't return any value, there won't be any effect on the data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`callback_function` 参数可能返回也可能不返回值。当它返回值时，假设它是用来替换传入的数据。如果回调函数不返回任何值，则对数据没有任何影响。'
- en: 'Here is an example of a callback function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个回调函数的示例：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If there is an error in the execution of `callback_function`, you'll receive
    a warning message in the standard output.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行`callback_function`函数时出现错误，你将在标准输出中收到一个警告信息。
- en: 'Now let us print some of the attributes of the request, using the preceding
    `callback_function`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用前面的`callback_function`来打印一些请求的属性：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Iterating over streaming APIs
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历流式API
- en: Streaming API tends to keep the request open allowing us to collect the stream
    data in real time. While dealing with a continuous stream of data, to ensure that
    none of the messages being missed from it we can take the help of `iter_lines()`
    in Requests. The `iter_lines()` iterates over the response data line by line.
    This can be achieved by setting the parameter stream as `True` while sending the
    request.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 流式API通常会保持请求开启，使我们能够实时收集流数据。在处理连续数据流时，为确保不遗漏任何消息，我们可以借助Requests库中的`iter_lines()`方法。`iter_lines()`会逐行遍历响应数据。这可以通过在发送请求时将参数stream设置为`True`来实现。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: It's better to keep in mind that it's not always safe to call the `iter_lines()`
    function as it may result in loss of received data.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最好记住，调用 `iter_lines()` 函数并不总是安全的，因为它可能会导致接收到的数据丢失。
- en: 'Consider the following example taken from [http://docs.python-requests.org/en/latest/user/advanced/#streaming-requests](http://docs.python-requests.org/en/latest/user/advanced/#streaming-requests):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑以下例子，它来自[http://docs.python-requests.org/en/latest/user/advanced/#streaming-requests](http://docs.python-requests.org/en/latest/user/advanced/#streaming-requests):'
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, the response contains a stream of data. With the help
    of `iter_lines()`, we tried to print the data by iterating through every line.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，响应包含了一系列数据。借助`iter_lines()`函数，我们尝试通过遍历每一行来打印这些数据。
- en: Encodings
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码
- en: As specified in the HTTP protocol (RFC 7230), applications can request the server
    to return the HTTP responses in an encoded format. The process of encoding turns
    the response content into an understandable format which makes it easy to access
    it. When the HTTP header fails to return the type of encoding, Requests will try
    to assume the encoding with the help of `chardet`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如HTTP协议（RFC 7230）中所述，应用程序可以请求服务器以编码格式返回HTTP响应。编码过程将响应内容转换为可理解格式，使其易于访问。当HTTP头无法返回编码类型时，Requests将尝试借助`chardet`来假设编码。
- en: 'If we access the response headers of a request, it does contain the keys of
    `content-type`. Let us look at a response header''s `content-type`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问请求的响应头，它确实包含`content-type`键。让我们看看响应头的`content-type`：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding example the content type contains `'text/html; charset=ISO-8859-1'`.
    This happens when the Requests finds the `charset` value to be `None` and the
    `'content-type'` value to be `'Text'`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，内容类型包含 `'text/html; charset=ISO-8859-1'`。这种情况发生在Requests库发现`charset`值为`None`且`'content-type'`值为`'Text'`时。
- en: It follows the protocol RFC 7230 to change the value of `charset` to `ISO-8859-1`
    in this type of a situation. In case we are dealing with different types of encodings
    like `'utf-8',` we can explicitly specify the encoding by setting the property
    to `Response.encoding`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它遵循RFC 7230协议，在这种情况下将`charset`的值更改为`ISO-8859-1`。如果我们处理的是像`'utf-8'`这样的不同编码类型，我们可以通过将属性设置为`Response.encoding`来显式指定编码。
- en: HTTP verbs
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 动词
- en: Requests support the usage of the full range of HTTP verbs which are defined
    in the following table. To most of the supported verbs, `'url'` is the only argument
    that must be passed while using them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请求支持使用以下表中定义的完整范围的 HTTP 动词。在使用这些动词的大多数情况下，`'url'` 是必须传递的唯一参数。
- en: '| Method | Description |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GET | GET method requests a representation of the specified resource. Apart
    from retrieving the data, there will be no other effect of using this method.Definition
    is given as `requests.get(url, **kwargs)` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| GET | GET 方法请求获取指定资源的表示形式。除了检索数据外，使用此方法不会产生其他效果。定义如下 `requests.get(url, **kwargs)`
    |'
- en: '| POST | The POST verb is used for the creation of new resources. The submitted
    `data` will be handled by the server to a specified resource.Definition is given
    as `requests.post(url, data=None, json=None, **kwargs)` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| POST | POST 方法用于创建新的资源。提交的 `data` 将由服务器处理到指定的资源。定义如下 `requests.post(url,
    data=None, json=None, **kwargs)` |'
- en: '| PUT | This method uploads a representation of the specified URI. If the URI
    is not pointing to any resource, the server can create a new object with the given
    `data` or it will modify the existing resource.Definition is given as `requests.put(url,
    data=None, **kwargs)` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| PUT | 此方法上传指定URI的表示。如果URI不指向任何资源，服务器可以使用给定的`data`创建一个新的对象，或者修改现有的资源。定义如下`requests.put(url,
    data=None, **kwargs)` |'
- en: '| DELETE | This is pretty easy to understand. It is used to delete the specified
    resource.Definition is given as `requests.delete(url, **kwargs)` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | 这很容易理解。它用于删除指定的资源。定义如下 `requests.delete(url, **kwargs)` |'
- en: '| HEAD | This verb is useful for retrieving meta-information written in response
    headers without having to fetch the response body.Definition is given as `requests.head(url,
    **kwargs)` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 头部 | 此动词用于检索响应头中写入的元信息，而无需获取响应体。定义如下 `requests.head(url, **kwargs)` |'
- en: '| OPTIONS | OPTIONS is a HTTP method which returns the HTTP methods that the
    server supports for a specified URL.Definition is given as `requests.options(url,
    **kwargs)` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 选项是一个HTTP方法，它返回服务器为指定URL支持的HTTP方法。定义如下 `requests.options(url, **kwargs)`
    |'
- en: '| PATCH | This method is used to apply partial modifications to a resource.Definition
    is given as `requests.patch(url, data=None, **kwargs)` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| PATCH | 此方法用于对资源应用部分修改。定义如下 `requests.patch(url, data=None, **kwargs)` |'
- en: Self-describing the APIs with link headers
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用链接头描述API
- en: Take a case of accessing a resource in which the information is accommodated
    in different pages. If we need to approach the next page of the resource, we can
    make use of the link headers. The link headers contain the meta data of the requested
    resource, that is the next page information in our case.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以访问一个信息分布在不同页面的资源为例。如果我们需要访问资源的下一页，我们可以利用链接头。链接头包含了请求资源的元数据，即在我们这个例子中的下一页信息。
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding example, we have specified in the URL that we want to access
    page number one and it should contain four records. The Requests automatically
    parses the link headers and updates the information about the next page. When
    we try to access the link header, it showed the output with the values of the
    page and the number of records per page.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在URL中指定了想要访问第一页，并且该页应包含四条记录。Requests会自动解析链接头并更新关于下一页的信息。当我们尝试访问链接头时，它显示了包含页码和每页记录数的输出值。
- en: Transport Adapter
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输适配器
- en: It is used to provide an interface for Requests sessions to connect with HTTP
    and HTTPS. This will help us to mimic the web service to fit our needs. With the
    help of Transport Adapters, we can configure the request according to the HTTP
    service we opt to use. Requests contains a Transport Adapter called **HTTPAdapter**
    included in it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它用于为Requests会话提供一个接口，以便连接到HTTP和HTTPS。这将帮助我们模拟网络服务以满足我们的需求。借助传输适配器，我们可以根据我们选择的HTTP服务来配置请求。Requests包含一个名为**HTTPAdapter**的传输适配器。
- en: 'Consider the following example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, we created a request session in which every request we make
    retries only six times, when the connection fails.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个请求会话，在这个会话中，每次请求在连接失败时只会重试六次。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learnt about creating sessions and using the session with
    different criteria. We also looked deeply into HTTP verbs and using proxies. We
    learnt about streaming requests, dealing with SSL certificate verifications and
    streaming responses. We also got to know how to use prepared requests, link headers
    and chunk encoded requests.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了创建会话以及根据不同标准使用会话。我们还深入探讨了HTTP动词和代理的使用。我们了解了流式请求、处理SSL证书验证和流式响应。此外，我们还了解了如何使用预定义请求、链接头和分块编码请求。
- en: In the next chapter, we will learn about various types of authentication and
    ways to use them with Requests.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习各种认证类型以及如何使用Requests库来应用它们。
