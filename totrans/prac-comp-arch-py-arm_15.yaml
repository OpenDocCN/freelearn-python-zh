- en: Appendices – Summary of Key Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In these appendices, we will provide a brief summary of several of the aspects
    we introduced in this book. We will begin with an introduction to IDLE, the Python
    interpreter that lets you rapidly develop programs and test Python’s features.
  prefs: []
  type: TYPE_NORMAL
- en: The second appendix provides a very brief summary of some of the Linux commands
    that you might need when developing ARM assembly language programs with Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: The third appendix provides a demonstration of the running and debugging of
    an ARM assembly program. The purpose of this example is to bring together in one
    place all the steps required to debug a program.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth appendix covers some concepts that can cause students confusion,
    such as the computer use of the terms up and down, which sometimes mean something
    different from the normal meaning of up and down. For example, adding something
    to a computer stack causes the computer stack to grow up toward lower addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The final appendix defines some of the concepts that we use when discussing
    computer languages such as Python.
  prefs: []
  type: TYPE_NORMAL
- en: Using IDLE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python programs in this book have been written in Python, saved as a `.py`
    file, and then executed in an *integrated development environment*. However, there
    is another approach to executing Python that you will see mentioned in many texts.
    This is the Python IDLE environment (included with the Python package) that lets
    you execute Python code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: IDLE is an interpreter that reads a line of Python as it is input and then executes
    it. This is very helpful if you want to test a few lines of code without going
    to the trouble of creating a source program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example, where the text in bold font is my input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When you run a compiled Python program, the output is displayed in the run window.
    Here, as you can see, each input line after the `>>>` prompt is read and interpreted,
    and the result is printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This window is, in fact, part of the IDLE environment. This means that if your
    program crashes, you are able to examine variables *after* the crash. Consider
    the following example, where we create and run a program that contains an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this program, the execution window displays the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python interpreter has indicated a *type error* because we entered a string
    and tried to add it to an integer. We can continue in the display window and look
    at the `x` and `y` variables and then modify the code as follows. All keyboard
    input is in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have now located and corrected the problem. Of course, it would be necessary
    to edit the original Python program to correct the source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because IDLE executes a statement at a time, it appears impossible to execute
    a loop because that requires more than one line of code. There is a way. IDLE
    automatically indents instructions in loops, which allows multiple statements.
    In order to finish (close) the loop, you must type TWO enters. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Instructions and commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This appendix lists some of the popular commands you will use when running
    programs on Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Assembler directives
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: gdb debugger
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Template for an ARM assembly language program
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Running an ARM program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we’ve put together all the information you need to run and debug a program
    on Raspberry Pi. We’re going to take the string copying example from [*Chapter
    11*](B19624_11.xhtml#_idTextAnchor197) and go through it in more detail to provide
    a template for program development. This program takes an ASCII string and reverses
    it. In this case, the string is `"Hello!!!".` We have made it eight characters
    long so that it fits into two consecutive words (8 * 8 bits = 64 bits = 2 words).
  prefs: []
  type: TYPE_NORMAL
- en: We have located the source string, `string1`, in the body of the program, in
    the `.text` section, because it is only read from and never written to.
  prefs: []
  type: TYPE_NORMAL
- en: The destination, `str2`, that will receive the reversed string is in read/write
    memory in the `.data` section. Consequently, we have to use the technique of indirect
    pointers – that is, the .text portion has a pointer at `adr_str2` that contains
    the address of the actual string, `str2`.
  prefs: []
  type: TYPE_NORMAL
- en: The program contains several labels that are not accessed by the code (e.g.,
    `preLoop` and `Wait`). The purpose of these labels is to make it easy to use breakpoints
    when debugging by giving them names.
  prefs: []
  type: TYPE_NORMAL
- en: A final feature is the use of *markers*. We have inserted markers in memory
    that follow both strings – that is, `0xAAFFFFBB` and `0xCCFFFFCC`. These make
    it easier to locate data when you look at memory because they stand out.
  prefs: []
  type: TYPE_NORMAL
- en: 'This program tests pointer-based addressing, bytes load and store, and auto-incrementing
    and decrementing of pointer registers. We will step through the execution of this
    program using `gdb`’s facilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The program is loaded into the `gdb` and debugged by the following. Note that
    my input is in bold font:'
  prefs: []
  type: TYPE_NORMAL
- en: '`alan@raspberrypi:~/Desktop $` gdb pLoop'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to place three breakpoints on the labels so that we can execute
    code up to those points and then examine registers or memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We have set three breakpoints by using `b <label>` three times. We can check
    these breakpoints by using the `info b` command, which displays the state of the
    breakpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to run the program as far as the first instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s not a lot to see here. So, we hit `c` to continue to the next breakpoint,
    and then enter `i r` to display the registers. Note we have not displayed registers
    that have not been accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s have a look at the data section in the code. Register `r2` points at
    this area, and the command means four words of memory in the hexadecimal form
    are displayed, starting at `0x100A8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The three highlighted values present the string `"Hello!!!"` and the marker
    `0xCCFFFFCC`. Note how these values appear *back to front*. This is a consequence
    of the little-endian byte ordering mode. The least-significant byte is located
    at the least-significant end of a word. In terms of ASCII characters, these are
    `lleH !!!o`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We next perform a single step and display the memory in the data region. At
    this stage, the code had not been executed fully and this region should be as
    originally set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see the zeros loaded at bytes and the marker following them.
    We then enter `c` again and continue to the `Wait` breakpoint when the code should
    have been completed. Finally, we look at the registers and then the data memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the data is changed. As you can see, the order has been reversed.
    Again, note the effect of the little-endianism on the byte order within words.
    The sequence of the data is now `o!!! Hell`. Finally, we enter `c` again and the
    program is completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Common confusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The growth of computing from the 1960s to today was rapid and chaotic. The chaos
    arose because the technology developed so rapidly that systems became obsolete
    in months, and that meant much of the design was obsolete but had been incorporated
    in systems that were now being held back by it. Similarly, many different notations
    and conventions arose – for example, does `MOVE A,B` move `A` to `B`, or `B` to
    `A`? Both conventions were used at the same time by different computers. Here
    are a few pointers to help with the confusion.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will largely adopt the right-to-left convention for data movement.
    For example, `add` r1`,r2,r2` indicates the addition of `r2` and `r3`, and the
    sum is put in `r1`. As a means of highlighting this, I often put the destination
    operand of an operation in bold font.
  prefs: []
  type: TYPE_NORMAL
- en: Symbols are often used with different meanings. This is particularly true of
    `#`, `@`,and `%`.
  prefs: []
  type: TYPE_NORMAL
- en: '`if x > y: z = 2`. `#` Reset `z` if `x` ever exceeds `y`. The hash is used
    in ARM assembly language to indicate a literal value – for example, `add` r0`,r1,#5`.
    `@` Add the integer `5` to the contents of `r1` and put in `r2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@**: The *at* symbol is used to indicate a comment in the ARM assembly language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add` r1`,r2,#%1010` means add the literal value expressed in the binary form.
    Python uses the prefix `0b` to indicate binary values (e.g., 0b1010).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x` to indicate hexadecimal values (e.g., 0xA10C).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Register indirect addressing**: A key concept in programming at the assembly
    language level is the pointer – that is, a variable that is the address of an
    element in memory. This addressing mode is called register indirect, pointer-based,
    or even indexed addressing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Up and down**: In normal everyday use, up and down indicate the direction
    toward the sky (up) or toward the ground (down). In arithmetic, they indicate
    increasing a number (up) or decreasing it (down). In computing, when data items
    are added to a stack, the stack grows up. However, by convention, the address
    grows down as items are added. Consequently, the stack pointer is decremented
    when items are added to the stack and incremented when items are removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ldr r0,=0x12345678`, a big endian computer would store the bytes in byte memory
    at increasing addresses in the order 12,34,56,78, whereas a little endian computer
    would store the bytes in the order 78,56,34,12\. The ARM is a little endian machine,
    although it can be programmed to operate in a big endian mode. In practice, this
    means that you must be careful when debugging programs and looking at memory dumps.
    Equally, you must be careful when performing byte operations on word values to
    ensure that you select the correct byte.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vocabulary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All specializations have their own vocabulary, and programming is no exception.
    Here are a few words that you might find helpful in understanding the text and
    its context.
  prefs: []
  type: TYPE_NORMAL
- en: '`1`s and `0`s. Humans write programs in a high-level language such as Python
    that is close to plain English. Before a high-level language program can be executed,
    a piece of software called a *compiler* translates it into binary code. When you
    run a Python program on your computer, your source code is automatically translated
    into machine code by a compiler working with the operating system. Mercifully,
    you don’t have to worry about all the actions that take place invisibly in the
    background during compilation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y = "4" + 1`. This is a syntax error because I’m adding two different entities
    that can’t be added. The "`4`" is a character (you can print it), whereas the
    `1` is an integer. You can write `y = "4" + "1"` or `z = 4 + 1`. These are both
    syntactically correct, and `y` is `"41"`, whereas `z` is `5`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Semantic error**: Semantics is concerned with meaning. A syntax error means
    that the sentence is grammatically wrong even if it is syntactically correct.
    An example of a sentence in English with a semantic error is, *“Twas brillig,
    and the slithy toves did gyre and gimble in the wabe.”* This is grammatically
    correct but does not have a meaning – that is, it’s semantically incorrect. In
    computing, a semantic error means that your program doesn’t do what you intended.
    A compiler can detect a syntax error but not usually a semantic error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`age = 25`, you’ve created a new variable called `age` with the value `25`.
    If you refer to age, the actual value will be substituted. The expression `y =
    age + 10` would give y the value `35`. A variable has four attributes – its name
    (what you call it), its address (where it’s stored in the computer), its value
    (what it actually is), and its type (e.g., an integer, list, character, or string).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c = 2πr`, where `2` and `π` are constants. Both `c` and `r` are variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c` and its radius `r`. We give the irrational number `3.1415926` the symbolic
    name `π`. When a program is compiled into machine code, symbolic names are replaced
    by actual values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1234`. A programmer normally does not have to worry about where data is actually
    located in memory. Translating addresses from the logical addresses used in programs
    to the physical addresses of memory devices is the domain of the operating system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c = 2πr`, what is `r`? We (humans) see `r` as the symbolic name for the value
    of the radius – say, 5\. But the computer sees `r` as the memory address 1234,
    which has to be read to provide the actual value of `r`. If we write `r = r +
    1`, do we mean `r = 5 + 1 = 6` or do we mean `r = 1234 + 1 = 1235`? It’s important
    to distinguish between an *address* and its *contents*. This factor becomes significant
    when we introduce pointers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i` is really a pointer; we just call it an *index*. If we change the pointer
    (index) we can step through the elements of a table, array, or matrix and step
    through elements x1, x2, x3, and x4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
