- en: Appendices – Summary of Key Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 – 关键概念摘要
- en: In these appendices, we will provide a brief summary of several of the aspects
    we introduced in this book. We will begin with an introduction to IDLE, the Python
    interpreter that lets you rapidly develop programs and test Python’s features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些附录中，我们将简要总结本书中介绍的一些方面。我们将从介绍IDLE开始，这是Python解释器，它允许你快速开发程序并测试Python的功能。
- en: The second appendix provides a very brief summary of some of the Linux commands
    that you might need when developing ARM assembly language programs with Raspberry
    Pi.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个附录简要总结了在Raspberry Pi上开发ARM汇编语言程序时可能需要的某些Linux命令。
- en: The third appendix provides a demonstration of the running and debugging of
    an ARM assembly program. The purpose of this example is to bring together in one
    place all the steps required to debug a program.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个附录提供了一个ARM汇编程序的运行和调试演示。这个示例的目的是将调试程序所需的所有步骤集中在一个地方。
- en: The fourth appendix covers some concepts that can cause students confusion,
    such as the computer use of the terms up and down, which sometimes mean something
    different from the normal meaning of up and down. For example, adding something
    to a computer stack causes the computer stack to grow up toward lower addresses.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个附录涵盖了可能让学生感到困惑的一些概念，例如计算机对“上”和“下”术语的使用，这些术语有时与“上”和“下”的正常含义不同。例如，向计算机堆栈添加内容会导致计算机堆栈向上增长到较低的地址。
- en: The final appendix defines some of the concepts that we use when discussing
    computer languages such as Python.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一章附录定义了我们讨论计算机语言（如Python）时使用的一些概念。
- en: Using IDLE
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IDLE
- en: The Python programs in this book have been written in Python, saved as a `.py`
    file, and then executed in an *integrated development environment*. However, there
    is another approach to executing Python that you will see mentioned in many texts.
    This is the Python IDLE environment (included with the Python package) that lets
    you execute Python code line by line.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的Python程序是用Python编写的，保存为`.py`文件，然后在集成开发环境中执行。然而，还有另一种执行Python的方法，你会在许多文本中看到提到。这是Python
    IDLE环境（包含在Python包中），它允许你逐行执行Python代码。
- en: IDLE is an interpreter that reads a line of Python as it is input and then executes
    it. This is very helpful if you want to test a few lines of code without going
    to the trouble of creating a source program.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE是一个解释器，它读取输入的Python代码行，然后执行它。如果你只想测试几行代码而不想麻烦地创建源程序，这将非常有帮助。
- en: 'Consider the following example, where the text in bold font is my input:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，其中粗体字体的文本是我的输入：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you run a compiled Python program, the output is displayed in the run window.
    Here, as you can see, each input line after the `>>>` prompt is read and interpreted,
    and the result is printed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行编译后的Python程序时，输出将在运行窗口中显示。在这里，正如你所看到的，每个输入行在`>>>`提示符之后都被读取和解释，然后打印结果。
- en: 'This window is, in fact, part of the IDLE environment. This means that if your
    program crashes, you are able to examine variables *after* the crash. Consider
    the following example, where we create and run a program that contains an error:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口实际上是IDLE环境的一部分。这意味着如果你的程序崩溃了，你可以在崩溃后检查变量。考虑以下示例，其中我们创建并运行了一个包含错误的程序：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we run this program, the execution window displays the following message:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，执行窗口将显示以下消息：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Python interpreter has indicated a *type error* because we entered a string
    and tried to add it to an integer. We can continue in the display window and look
    at the `x` and `y` variables and then modify the code as follows. All keyboard
    input is in bold:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释器指示存在*类型错误*，因为我们输入了一个字符串并尝试将其添加到整数中。我们可以在显示窗口中继续操作，查看`x`和`y`变量，然后按如下方式修改代码。所有键盘输入都是粗体的：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have now located and corrected the problem. Of course, it would be necessary
    to edit the original Python program to correct the source code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经定位并修复了问题。当然，编辑原始的Python程序以纠正源代码是必要的。
- en: 'Because IDLE executes a statement at a time, it appears impossible to execute
    a loop because that requires more than one line of code. There is a way. IDLE
    automatically indents instructions in loops, which allows multiple statements.
    In order to finish (close) the loop, you must type TWO enters. Consider the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IDLE一次执行一条语句，因此看起来无法执行循环，因为那需要多行代码。有一种方法。IDLE自动缩进循环中的指令，这允许多个语句。为了完成（关闭）循环，你必须输入两个回车。考虑以下示例：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Instructions and commands
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令和命令
- en: 'This appendix lists some of the popular commands you will use when running
    programs on Raspberry Pi:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此附录列出了您在Raspberry Pi上运行程序时将使用的一些常用命令：
- en: Linux
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Linux
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Assembler directives
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编指令
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: gdb debugger
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: gdb调试器
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Template for an ARM assembly language program
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ARM汇编语言程序的模板
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running an ARM program
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行ARM程序
- en: Here, we’ve put together all the information you need to run and debug a program
    on Raspberry Pi. We’re going to take the string copying example from [*Chapter
    11*](B19624_11.xhtml#_idTextAnchor197) and go through it in more detail to provide
    a template for program development. This program takes an ASCII string and reverses
    it. In this case, the string is `"Hello!!!".` We have made it eight characters
    long so that it fits into two consecutive words (8 * 8 bits = 64 bits = 2 words).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们整理了所有您需要运行和调试Raspberry Pi上程序的信息。我们将从[*第11章*](B19624_11.xhtml#_idTextAnchor197)中的字符串复制示例开始，更详细地讲解，以提供一个程序开发的模板。此程序接受一个ASCII字符串并将其反转。在这种情况下，字符串是`"Hello!!!"`。我们将其设置为8个字符长，以便它适合两个连续的单词（8
    * 8位 = 64位 = 2个单词）。
- en: We have located the source string, `string1`, in the body of the program, in
    the `.text` section, because it is only read from and never written to.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在程序的`.text`部分找到了源字符串`string1`，因为它只被读取，从未被写入。
- en: The destination, `str2`, that will receive the reversed string is in read/write
    memory in the `.data` section. Consequently, we have to use the technique of indirect
    pointers – that is, the .text portion has a pointer at `adr_str2` that contains
    the address of the actual string, `str2`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将接收反转字符串的目标`str2`位于`.data`段的读/写内存中。因此，我们必须使用间接指针技术——也就是说，.text部分在`adr_str2`处有一个指针，它包含实际字符串`str2`的地址。
- en: The program contains several labels that are not accessed by the code (e.g.,
    `preLoop` and `Wait`). The purpose of these labels is to make it easy to use breakpoints
    when debugging by giving them names.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 程序包含一些代码未访问的标签（例如`preLoop`和`Wait`）。这些标签的目的是在调试时通过给它们命名来简化断点的使用。
- en: A final feature is the use of *markers*. We have inserted markers in memory
    that follow both strings – that is, `0xAAFFFFBB` and `0xCCFFFFCC`. These make
    it easier to locate data when you look at memory because they stand out.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个最终特性是使用*标记器*。我们在内存中插入了两个字符串之后的标记器——即`0xAAFFFFBB`和`0xCCFFFFCC`。这些标记使得在查看内存时更容易定位数据，因为它们很突出。
- en: 'This program tests pointer-based addressing, bytes load and store, and auto-incrementing
    and decrementing of pointer registers. We will step through the execution of this
    program using `gdb`’s facilities:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序测试基于指针的寻址、字节加载和存储，以及指针寄存器的自动递增和递减。我们将使用`gdb`的功能逐步执行此程序的执行：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The program is loaded into the `gdb` and debugged by the following. Note that
    my input is in bold font:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 程序被加载到`gdb`中进行调试，以下是调试步骤。注意，我的输入以粗体显示：
- en: '`alan@raspberrypi:~/Desktop $` gdb pLoop'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`alan@raspberrypi:~/Desktop $` gdb pLoop'
- en: 'The first step is to place three breakpoints on the labels so that we can execute
    code up to those points and then examine registers or memory:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在标签上放置三个断点，这样我们就可以执行代码直到这些点，然后检查寄存器或内存：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have set three breakpoints by using `b <label>` three times. We can check
    these breakpoints by using the `info b` command, which displays the state of the
    breakpoints:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`b <label>`三次来设置三个断点。我们可以使用`info b`命令来检查这些断点，该命令显示断点的状态：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next step is to run the program as far as the first instruction:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是运行程序直到第一条指令：
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There’s not a lot to see here. So, we hit `c` to continue to the next breakpoint,
    and then enter `i r` to display the registers. Note we have not displayed registers
    that have not been accessed:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多可看的内容。因此，我们按`c`继续到下一个断点，然后输入`i r`来显示寄存器。注意，我们没有显示未访问过的寄存器：
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s have a look at the data section in the code. Register `r2` points at
    this area, and the command means four words of memory in the hexadecimal form
    are displayed, starting at `0x100A8`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看代码中的数据部分。寄存器`r2`指向这个区域，命令表示从`0x100A8`开始显示以十六进制形式表示的四个内存字：
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The three highlighted values present the string `"Hello!!!"` and the marker
    `0xCCFFFFCC`. Note how these values appear *back to front*. This is a consequence
    of the little-endian byte ordering mode. The least-significant byte is located
    at the least-significant end of a word. In terms of ASCII characters, these are
    `lleH !!!o`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 三个突出显示的值表示字符串`"Hello!!!"`和标记`0xCCFFFFCC`。注意这些值是如何从后往前出现的。这是小端字节序模式的结果。最不重要的字节位于单词的最不重要的末端。从ASCII字符的角度来看，这些是`lleH
    !!!o`。
- en: 'We next perform a single step and display the memory in the data region. At
    this stage, the code had not been executed fully and this region should be as
    originally set up:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来执行一个步骤，并显示数据区域的内存。在这个阶段，代码尚未完全执行，这个区域应该与最初设置的一样：
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, you can see the zeros loaded at bytes and the marker following them.
    We then enter `c` again and continue to the `Wait` breakpoint when the code should
    have been completed. Finally, we look at the registers and then the data memory:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到加载在字节上的零和随后的标记。然后我们再次输入`c`，继续到`Wait`断点，此时代码应该已经完成。最后，我们查看寄存器和数据内存：
- en: '[PRE20]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that the data is changed. As you can see, the order has been reversed.
    Again, note the effect of the little-endianism on the byte order within words.
    The sequence of the data is now `o!!! Hell`. Finally, we enter `c` again and the
    program is completed:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意数据已经改变。正如你所看到的，顺序已经颠倒。再次注意小端字节序对单词内字节顺序的影响。现在数据的顺序是`o!!! Hell`。最后，我们再次输入`c`，程序完成：
- en: '[PRE21]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Common confusions
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见混淆
- en: The growth of computing from the 1960s to today was rapid and chaotic. The chaos
    arose because the technology developed so rapidly that systems became obsolete
    in months, and that meant much of the design was obsolete but had been incorporated
    in systems that were now being held back by it. Similarly, many different notations
    and conventions arose – for example, does `MOVE A,B` move `A` to `B`, or `B` to
    `A`? Both conventions were used at the same time by different computers. Here
    are a few pointers to help with the confusion.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从20世纪60年代到今天，计算机的发展迅速且混乱。这种混乱是由于技术发展得太快，以至于系统几个月内就过时了，这意味着大部分设计已经过时，但已经被纳入了现在正被其拖累的系统。同样，出现了许多不同的符号和约定——例如，`MOVE
    A,B`是将`A`移动到`B`，还是将`B`移动到`A`？不同的计算机同时使用了这两种约定。以下是一些有助于解决混淆的提示。
- en: In this book, we will largely adopt the right-to-left convention for data movement.
    For example, `add` r1`,r2,r2` indicates the addition of `r2` and `r3`, and the
    sum is put in `r1`. As a means of highlighting this, I often put the destination
    operand of an operation in bold font.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将主要采用从右到左的约定进行数据移动。例如，`add r1,r2,r2`表示将`r2`和`r3`相加，并将和放入`r1`。为了突出这一点，我经常将操作的源操作数用粗体字表示。
- en: Symbols are often used with different meanings. This is particularly true of
    `#`, `@`,and `%`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 符号经常被赋予不同的含义。这一点在`#`、`@`和`%`上尤为明显。
- en: '`if x > y: z = 2`. `#` Reset `z` if `x` ever exceeds `y`. The hash is used
    in ARM assembly language to indicate a literal value – for example, `add` r0`,r1,#5`.
    `@` Add the integer `5` to the contents of `r1` and put in `r2`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if x > y: z = 2`。如果`x`超过`y`，则使用`#`重置`z`。在ARM汇编语言中，`#`用于表示文本值——例如，`add r0,r1,#5`。`@`将整数`5`加到`r1`的内容中，并放入`r2`。'
- en: '**@**: The *at* symbol is used to indicate a comment in the ARM assembly language.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@**：在ARM汇编语言中，`at`符号用于表示注释。'
- en: '`add` r1`,r2,#%1010` means add the literal value expressed in the binary form.
    Python uses the prefix `0b` to indicate binary values (e.g., 0b1010).'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add r1,r2,#%1010`表示以二进制形式表示的文本值。Python使用前缀`0b`来表示二进制值（例如，0b1010）。'
- en: '`0x` to indicate hexadecimal values (e.g., 0xA10C).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`0x`来表示十六进制值（例如，0xA10C）。
- en: '**Register indirect addressing**: A key concept in programming at the assembly
    language level is the pointer – that is, a variable that is the address of an
    element in memory. This addressing mode is called register indirect, pointer-based,
    or even indexed addressing.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寄存器间接寻址**：在汇编语言级别的编程中，一个关键概念是指针——即一个变量，它是内存中某个元素的地址。这种寻址模式被称为寄存器间接、基于指针或甚至索引寻址。'
- en: '**Up and down**: In normal everyday use, up and down indicate the direction
    toward the sky (up) or toward the ground (down). In arithmetic, they indicate
    increasing a number (up) or decreasing it (down). In computing, when data items
    are added to a stack, the stack grows up. However, by convention, the address
    grows down as items are added. Consequently, the stack pointer is decremented
    when items are added to the stack and incremented when items are removed.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下**：在正常日常使用中，上下表示向天空（上）或向地面（下）的方向。在算术中，它们表示增加一个数字（上）或减少它（下）。在计算机中，当数据项被添加到栈中时，栈向上增长。然而，按照惯例，地址在添加项时向下增长。因此，当向栈中添加项时，栈指针会递减，当从栈中移除项时，栈指针会递增。'
- en: '`ldr r0,=0x12345678`, a big endian computer would store the bytes in byte memory
    at increasing addresses in the order 12,34,56,78, whereas a little endian computer
    would store the bytes in the order 78,56,34,12\. The ARM is a little endian machine,
    although it can be programmed to operate in a big endian mode. In practice, this
    means that you must be careful when debugging programs and looking at memory dumps.
    Equally, you must be careful when performing byte operations on word values to
    ensure that you select the correct byte.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldr r0,=0x12345678`, 大端序的计算机会在字节内存中以递增的地址顺序存储字节 12,34,56,78，而小端序的计算机则会以 78,56,34,12
    的顺序存储字节。ARM 是一个小端序机器，尽管它可以编程为在大端序模式下运行。在实践中，这意味着在调试程序和查看内存转储时必须小心。同样，在执行字值上的字节操作时，也必须小心，以确保选择正确的字节。'
- en: Vocabulary
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词汇
- en: All specializations have their own vocabulary, and programming is no exception.
    Here are a few words that you might find helpful in understanding the text and
    its context.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有专业领域都有自己的词汇，编程也不例外。以下是一些有助于理解文本及其上下文的有用词汇。
- en: '`1`s and `0`s. Humans write programs in a high-level language such as Python
    that is close to plain English. Before a high-level language program can be executed,
    a piece of software called a *compiler* translates it into binary code. When you
    run a Python program on your computer, your source code is automatically translated
    into machine code by a compiler working with the operating system. Mercifully,
    you don’t have to worry about all the actions that take place invisibly in the
    background during compilation.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`s 和 `0`s。人类用类似于英语的高级语言（如 Python）编写程序。在高级语言程序可以执行之前，一个叫做 *编译器* 的软件将其翻译成二进制代码。当你在电脑上运行
    Python 程序时，你的源代码会由操作系统与编译器一起自动翻译成机器代码。幸运的是，你不必担心编译过程中在后台发生的所有无形操作。'
- en: '`y = "4" + 1`. This is a syntax error because I’m adding two different entities
    that can’t be added. The "`4`" is a character (you can print it), whereas the
    `1` is an integer. You can write `y = "4" + "1"` or `z = 4 + 1`. These are both
    syntactically correct, and `y` is `"41"`, whereas `z` is `5`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y = "4" + 1`。这是一个语法错误，因为我正在添加两个不能相加的不同实体。`"4"` 是一个字符（你可以打印它），而 `1` 是一个整数。你可以写
    `y = "4" + "1"` 或 `z = 4 + 1`。这两个都是语法正确的，`y` 的值是 `"41"`，而 `z` 的值是 `5`。'
- en: '**Semantic error**: Semantics is concerned with meaning. A syntax error means
    that the sentence is grammatically wrong even if it is syntactically correct.
    An example of a sentence in English with a semantic error is, *“Twas brillig,
    and the slithy toves did gyre and gimble in the wabe.”* This is grammatically
    correct but does not have a meaning – that is, it’s semantically incorrect. In
    computing, a semantic error means that your program doesn’t do what you intended.
    A compiler can detect a syntax error but not usually a semantic error.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语义错误**：语义关注于意义。语法错误意味着句子在语法上是正确的，即使它在语法上是正确的。一个带有语义错误的英语句子示例是，“Twas brillig,
    and the slithy toves did gyre and gimble in the wabe。”这是语法正确的，但没有意义——也就是说，它是语义错误的。在计算机中，语义错误意味着你的程序没有按照你的意图执行。编译器可以检测语法错误，但通常不能检测语义错误。'
- en: '`age = 25`, you’ve created a new variable called `age` with the value `25`.
    If you refer to age, the actual value will be substituted. The expression `y =
    age + 10` would give y the value `35`. A variable has four attributes – its name
    (what you call it), its address (where it’s stored in the computer), its value
    (what it actually is), and its type (e.g., an integer, list, character, or string).'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`age = 25`，你创建了一个名为 `age` 的新变量，其值为 `25`。如果你引用 `age`，实际的值将被替换。表达式 `y = age +
    10` 将会给 `y` 赋值为 `35`。一个变量有四个属性——它的名称（你如何称呼它）、它的地址（它在计算机中的存储位置）、它的值（它实际上是什么）和它的类型（例如，整数、列表、字符或字符串）。'
- en: '`c = 2πr`, where `2` and `π` are constants. Both `c` and `r` are variables.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c = 2πr`，其中 `2` 和 `π` 是常数。`c` 和 `r` 都是变量。'
- en: '`c` and its radius `r`. We give the irrational number `3.1415926` the symbolic
    name `π`. When a program is compiled into machine code, symbolic names are replaced
    by actual values.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c` 及其半径 `r`。我们给无理数 `3.1415926` 赋予符号名 `π`。当程序编译成机器代码时，符号名会被实际值替换。'
- en: '`1234`. A programmer normally does not have to worry about where data is actually
    located in memory. Translating addresses from the logical addresses used in programs
    to the physical addresses of memory devices is the domain of the operating system.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1234`。程序员通常不必担心数据在内存中的实际位置。将程序中使用的逻辑地址转换为内存设备的物理地址是操作系统的领域。'
- en: '`c = 2πr`, what is `r`? We (humans) see `r` as the symbolic name for the value
    of the radius – say, 5\. But the computer sees `r` as the memory address 1234,
    which has to be read to provide the actual value of `r`. If we write `r = r +
    1`, do we mean `r = 5 + 1 = 6` or do we mean `r = 1234 + 1 = 1235`? It’s important
    to distinguish between an *address* and its *contents*. This factor becomes significant
    when we introduce pointers.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c = 2πr`，那么 `r` 是什么？我们（人类）将 `r` 视为半径值的符号名——比如说，5。但计算机将 `r` 视为内存地址 1234，必须读取它以提供
    `r` 的实际值。如果我们写 `r = r + 1`，我们是想表示 `r = 5 + 1 = 6` 还是表示 `r = 1234 + 1 = 1235`？区分*地址*和其*内容*非常重要。当我们引入指针时，这个因素变得很重要。'
- en: '`i` is really a pointer; we just call it an *index*. If we change the pointer
    (index) we can step through the elements of a table, array, or matrix and step
    through elements x1, x2, x3, and x4.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i` 实际上是一个指针；我们只是称它为*索引*。如果我们改变指针（索引），我们就可以遍历表、数组或矩阵的元素，并遍历元素 x1、x2、x3 和 x4。'
