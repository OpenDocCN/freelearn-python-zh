- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging – Solving the Bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter showed you how to add logging and tests to your code, but
    no matter how many tests you have, you will always have bugs. The biggest problem
    will always be external variables such as user input and different environments.
    At some point sooner or later, we will need to debug issues with our code, or
    worse, the code that was written by someone else.
  prefs: []
  type: TYPE_NORMAL
- en: There are many debugging techniques and, most certainly, you have already used
    a few of them. Within this chapter, we are going to focus on print/trace debugging
    and interactive debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using print statements, stack traces, and logging is one of the most
    versatile methods to work with, and it is most likely the first type of debugging
    you ever used. Even a `print('Hello world')` can be considered this type, as the
    output will show you that your code is being executed correctly. There is obviously
    no point in explaining how and where to place print statements to debug your code,
    but there are quite a few nice tricks using decorators and other Python modules
    that render this type of debugging a lot more useful, such as `faulthandler`.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive debugging is a more complicated debugging method. It allows you
    to debug a program while it’s still running. Using this method, it’s even possible
    to change variables while the application is running and pause the application
    at any point desired. The downside is that it requires some knowledge about the
    debugger commands to be really useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Non-interactive debugging using `print`, `trace`, `logging`, and `faulthandler`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive debugging using `pdb`, `ipython`, `jupyter`, and other debuggers
    and debugging services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-interactive debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic form of debugging is adding a simple print statement into your
    code to see what is still working and what isn’t. This is useful in a variety
    of cases and likely to help solve most of your issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in this chapter, we will show some interactive debugging methods, but
    those are not always suitable. Interactive debugging tends to become difficult
    or even impossible in cases such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Multithreaded environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bugs that are hard (or take a long time) to reproduce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closed-off remote servers such as Google App Engine or Heroku
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both interactive and non-interactive debugging methods have their merits, but
    I personally opt for non-interactive debugging 90% of the time, since a simple
    print/log statement is usually enough to analyze the cause of a problem. I find
    interactive debugging to be mostly helpful when writing code which uses large
    and complicated external libraries, where it can be hard to analyze which attributes,
    properties, and methods are available for objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic example of this (I’ve been known to do similar) with a generator can
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This shows exactly where the code does, and consequently, does not reach. Without
    this example, you might have expected the first `print` to come immediately after
    the `hiding_generator()` call. Since it’s a generator, however, nothing will be
    executed until we `yield` an item. Assuming you would have some setup code before
    the first `yield`, it won’t run until `next` is actually called. Additionally,
    `print('c')` is never executed and can be considered unreachable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this is one of the simplest ways to debug functions using `print`
    calls, it’s not always the most convenient way. We can start by making an auto-print
    function that prints the line of code that it’s going to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it automatically prints the line number, the name of the function,
    and the line of code it will execute next for you. That way, if you have a slow
    bit of code, you can see which line is stalling because it will be printed before
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: With this specific instance, there’s no real use for a generator, but you could
    easily incorporate some timings so you can see the delay between two `next(print_code)`
    statements. Or perhaps a counter to see how often this particular bit of code
    has been run.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting your script using trace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simple print statements are useful in a lot of cases since you can easily incorporate
    print statements in nearly every application. It does not matter whether it’s
    remote or local, threaded or using multiprocessing. It works almost everywhere,
    making it the most universal solution available – in addition to logging, that
    is. The general solution is often not the best solution for every situation, however.
    A nice alternative to our previous function is the `trace` module. It offers you
    a way to trace every executed line, including the runtime. The downside of tracing
    so much data is that it can quickly become overly verbose, as we will see in the
    next example.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, we will use our previous code but without print statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we execute the code with the `trace` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `trace` module shows you exactly which line is being executed with function
    names and, more importantly, which line was caused by which statement (or statements).
    Additionally, it shows you at what time it was executed relative to the start
    time of the program. This is due to the `--timing` flag.
  prefs: []
  type: TYPE_NORMAL
- en: And it still seems fairly reasonable in terms of output, right? Within this
    example, it does because this is about the most basic code there is. As soon as
    you add an `import`, for example, your screen will be flooded with output. In
    spite of the fact that you can opt to ignore specific modules and directories
    by using command-line parameters, it is still too verbose in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also enable the `trace` module selectively with a little bit of effort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code shows a context manager that temporarily enables and disables the
    `trace` module to selectively trace code. In this example, we used `sys.settrace`
    with `tracer.globaltrace` as an argument, but you could also hook to your own
    tracing functions to customize the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'When executing this, we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to illustrate, if we were to run the same code with the trace module enabled,
    we would get a lot of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `wc` (word count) command shows us that this command gave us `252` lines,
    `2881` words, or `38716` characters of output, so I would generally recommend
    using the context decorator instead. Executing a trace on any reasonably sized
    script will generate a scary amount of output.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few extra options with the `trace` module, such as showing which
    code is (not) executed, which can be useful to detect code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the arguments we already passed to `trace`, we can easily change
    the output or add extra filters by wrapping or replacing `tracer.globaltrace`
    as the `sys.settrace()` argument. As arguments, the function needs to accept `frame`,
    `event`, and `arg`.
  prefs: []
  type: TYPE_NORMAL
- en: The `frame` is a Python stack frame that contains references to the code and
    the filename and can be used to inspect the scope at that point in the stack.
    This is the same frame you can extract when using the `traceback` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `event` argument is a string that can have the following values (from the
    standard Python documentation):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `call` | A function is called (or some other code block entered). The global
    trace function is called; `arg` is `None`. The return value specifies the local
    trace function. |'
  prefs: []
  type: TYPE_TB
- en: '| `line` | The interpreter is about to execute a new line of code or re-execute
    the condition of a loop. The local trace function is called; `arg` is `None`;
    the return value specifies the new local trace function. See `Objects/lnotab_notes.txt`
    (in the Python source repository) for a detailed explanation of how this works.
    Per-line events may be disabled for a frame by setting `f_trace_lines` to `False`
    on that `frame`. |'
  prefs: []
  type: TYPE_TB
- en: '| `return` | A function (or another code block) is about to return. The local
    trace function is called; `arg` is the value that will be returned, or `None`
    if the event is caused by an exception being raised. The trace function’s return
    value is ignored. |'
  prefs: []
  type: TYPE_TB
- en: '| `exception` | This means an exception has occurred. The local trace function
    is called; `arg` is a tuple (`exception`, `value`, `traceback`). The return value
    specifies the new local trace function. |'
  prefs: []
  type: TYPE_TB
- en: '| `opcode` | The interpreter is about to execute a new opcode (see the `dis`
    module for opcode details). The local trace function is called; `arg` is `None`;
    the return value specifies the new local trace function. Per-opcode events are
    not emitted by default: they must be explicitly requested by setting `f_trace_opcodes`
    to `True` on the frame. |'
  prefs: []
  type: TYPE_TB
- en: Lastly, the `arg` argument depends on the `event` argument as illustrated by
    the documentation above. In general, if `arg` is `None`, the return value of this
    function will be used as the local trace function, allowing you to override this
    for a specific scope. With `exception` events, it will be a tuple containing `exception`,
    `value`, and `traceback`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s create a little snippet that can selectively trace our code by filtering
    on filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By using the `frame` argument, we can retrieve the code we are currently executing,
    and from that, the filename the code currently exists in. Naturally, you could
    also filter for different functions or only filter to a specific depth. Since
    we hand the tracing and outputting off to `tracer.globaltrace()`, we only check
    the `filename` for a place up in the stack. You could return `trace()` instead
    and handle the `print()` yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'When executing this code, you should get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this excludes the code from `contextlib`, which we saw in the
    earlier example.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 10*, *Testing and Logging – Preparing for Bugs*, we saw how to create
    custom loggers, set the levels for them, and add handlers to specific levels.
    We are going to use the `logging.DEBUG` level to log now, which is nothing special
    by itself, but with a few decorators, we can add some very useful debug-only code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever I’m debugging, I always find it very useful to know the input and
    output for a function. The basic version with a decorator is simple enough to
    write; just print the `args`, `kwargs`, and `return` value and you are done. The
    following example goes a little further. By using the `inspect` module, we can
    retrieve the default arguments as well, making it possible to show all arguments
    with the argument names and values in all cases, even if the argument was not
    specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s analyze how this code executes:'
  prefs: []
  type: TYPE_NORMAL
- en: The decorator executes `function()` as normal with the given `*args` and `**kwargs`
    passed along unmodified, while storing the result to both display and `return`
    later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `finally` section of the `try`/`finally` generates an `inspect.Signature()`
    object from `function()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we generate an `inspect.BoundArguments()` object by binding `*args` and
    `**kwargs` using the previously generated `signature`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can tell the `inspect.BoundArguments()` object to apply the default arguments
    so we can see the value of arguments not passed in `*args` and `**kwargs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we output the full function name, the formatted arguments, and the `result`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we execute the code, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Very nice of course, as we have a clear sight of when the function is called,
    which parameters were used, and what is returned. However, this is something you
    will probably only execute when you are actively debugging your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also make the regular `logging.debug` statements in your code quite
    a bit more useful by adding a debug-specific logger, which shows more information.
    Simply replace the logging config of the preceding example with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then your result will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It shows the time relative to the start of the application in milliseconds and
    the log level. This is followed by an identification block that shows the filename,
    line number, and function name that originated the logs. Of course, there is a
    `message` at the end, which contains the result of our log call.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the call stack without exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When looking at how and why a piece of code is being run, it’s often useful
    to see the entire stack trace. Simply raising an exception is, of course, an option.
    However, that will kill the current code execution, which is generally not something
    we are looking for. This is where the `traceback` module comes in handy. With
    just a simple call to `traceback.print_stack()`, we get a full stack list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `ShowMyStack.run()` function shows a regular `traceback.print_stack()` call,
    which shows the entire stack trace to that point in the stack. You could place
    `traceback.print_stack()` anywhere in your code to see where it is being called
    from.
  prefs: []
  type: TYPE_NORMAL
- en: Since the full stack trace can be quite large, it is often useful to use the
    `limit` argument to only show a few levels, which is what we do in the second
    run.
  prefs: []
  type: TYPE_NORMAL
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the traceback simply prints without any exceptions. The `traceback`
    module actually has quite a few other methods for printing tracebacks based on
    exceptions and such, but you probably won’t need them often. The most useful one
    is probably the `limit` parameter we’ve demonstrated. A positive limit number
    shows you only a specific number of frames. In most cases, you don’t need a full
    stack trace, so this can be quite useful to limit the output.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can also specify a negative limit, which trims the stack from
    the other side. This is mostly useful when printing the stack from a decorator
    where you want to hide the decorator from the trace. If you want to limit both
    sides, you will have to do it manually using `format_list(stack)` with a stack
    from `extract_stack(f, limit)`, the usage of which is similar to the `print_stack()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The negative limit support was added in Python 3.5\. Before that, only positive
    limits were supported.
  prefs: []
  type: TYPE_NORMAL
- en: Handling crashes using faulthandler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `faulthandler` module helps when debugging really low-level crashes, that
    is, crashes that should only be possible when using low-level access to memory,
    such as C extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s a bit of code that *will* cause your Python interpreter
    to crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It results in something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s quite an ugly response, of course, and gives you no possibility to handle
    the error. Just in case you are wondering, having a `try/except` structure won’t
    help you in these cases either. The following code will crash in exactly the same
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where the `faulthandler` module helps. It will still cause your interpreter
    to crash, but at least you will see a proper error message raised, so it’s a good
    default if you (or any of the sub-libraries) have any interaction with raw memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It results in something along these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, it’s not desirable to have a Python application exit in this manner
    as the code won’t exit with a normal cleanup. Resources won’t be closed cleanly
    and your exit handler won’t be called. If you somehow need to catch this behavior,
    your best bet is to wrap the Python executable in a separate script using something
    like `subprocess.run([sys.argv[0], '` `T_09_faulthandler_enabled.py'])`.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have discussed basic debugging methods that will always work, we
    will look at interactive debugging for some more advanced debugging techniques.
    The previous debugging methods made variables and stacks visible through modifying
    the code and/or foresight. This time around, we will look at a slightly smarter
    method, which constitutes doing the same thing interactively, but once the need
    arises.
  prefs: []
  type: TYPE_NORMAL
- en: Console on demand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When testing some Python code, you may have used the interactive console a
    couple of times, since it’s a simple yet effective tool for testing your Python
    code. What you might not have known is that it is actually simple to start your
    own shell from within your code. So, whenever you want to drop into a regular
    shell from a specific point in your code, that’s easily possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing that, we will drop into an interactive console halfway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To exit this console, we can use *^d* (*Ctrl* + *D*) on Linux/Mac systems and
    *^z* (*Ctrl* + *Z*) on Windows systems.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to note here is that the local scope is not shared between
    the two. Even though we passed along `locals()` to share the local variables for
    convenience, this relation is not bidirectional.
  prefs: []
  type: TYPE_NORMAL
- en: The result is that even though we set `some_variable` to `456` in the interactive
    session, it does not carry over to the outside function. You can modify variables
    in the outside scope through direct manipulation (for example, setting the properties)
    if you wish, but all variables declared locally will remain local.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, modifying mutable variables will affect both scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using Python debugger (pdb)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to actually debugging code, the regular interactive console just
    isn’t suited. With a bit of effort, you can make it work, but it’s just not all
    that convenient for debugging since you can only see the current scope and can’t
    jump around the stack easily. With `pdb` (Python debugger), this is easily possible.
    So, let’s look at a simple example of using `pdb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is pretty much identical to the one in the previous paragraph,
    except that this time we end up in the `pdb` console instead of a regular interactive
    console. So let’s give the interactive debugger a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we’ve actually modified the value of `some_variable` now. In
    this case, we used the full `continue` command, but all the `pdb` commands have
    short versions as well. So, using `c` instead of `continue` gives the same result.
    Just typing `some_variable` (or any other variable) will show the contents and
    setting the variable will simply set it, just as we would expect from an interactive
    session.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with `pdb`, first of all, a list of the most useful (full) stack
    movement and manipulation commands with shorthands is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| `h(elp)` | This shows the list of commands (this list). |'
  prefs: []
  type: TYPE_TB
- en: '| `h(elp) command` | This shows the help for the given command. |'
  prefs: []
  type: TYPE_TB
- en: '| `w(here)` | Current stack trace with an arrow at the current frame. |'
  prefs: []
  type: TYPE_TB
- en: '| `d(own)` | Move down/to a newer frame in the stack. |'
  prefs: []
  type: TYPE_TB
- en: '| `u(p)` | Move up/to an older frame in the stack. |'
  prefs: []
  type: TYPE_TB
- en: '| `s(tep)` | Execute the current line and stop as soon as possible. |'
  prefs: []
  type: TYPE_TB
- en: '| `n(ext)` | Execute the current line and stop at the next line within the
    current function. |'
  prefs: []
  type: TYPE_TB
- en: '| `r(eturn)` | Continue execution until the function returns. |'
  prefs: []
  type: TYPE_TB
- en: '| `c(ont(inue))` | Continue execution up to the next breakpoint. |'
  prefs: []
  type: TYPE_TB
- en: '| `l(ist) [first[, last]]` | List the lines of source code (by default, 11
    lines) around the current line. |'
  prefs: []
  type: TYPE_TB
- en: '| `ll &#124; longlist` | List all of the source code for the current function
    or frame. |'
  prefs: []
  type: TYPE_TB
- en: '| `source expression` | List the source code for the given object. This is
    similar to `longlist`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a(rgs)` | Print the arguments for the current function. |'
  prefs: []
  type: TYPE_TB
- en: '| `pp expression` | Pretty-print the given expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `! statement` | Execute the statement at the current point in the stack.
    Normally, the `!` sign is not needed, but this can be useful if there are collisions
    with debugger commands. For example, try `b = 123`. |'
  prefs: []
  type: TYPE_TB
- en: '| `interact` | Open an interactive Python shell session similar to the previous
    paragraph. |'
  prefs: []
  type: TYPE_TB
- en: Many more commands are available and some of them will be covered by the following
    paragraphs. All commands are covered by the built-in help, however, so be sure
    to use the `h/help [command]` command if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Breakpoints are points where the debugger will halt the code execution and
    allow you to debug from that point. We can create breakpoints using either code
    or commands. First, let’s enter the debugger using `pdb.set_trace()`. This is
    effectively a hardcoded breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, nothing new has happened, but let’s now open the interactive debugging
    session and try a few breakpoint commands. Here’s a list of the most useful breakpoint
    commands before we start:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| `b(reak)` | Show the list of breakpoints. |'
  prefs: []
  type: TYPE_TB
- en: '| `b(reak) [filename:]lineno` | Place a breakpoint at the given line number
    and, optionally, file. |'
  prefs: []
  type: TYPE_TB
- en: '| `b(reak) function[, condition]` | Place a breakpoint at the given function.
    The condition is an expression that must evaluate to `True` for the breakpoint
    to work. |'
  prefs: []
  type: TYPE_TB
- en: '| `cl(ear) [filename:]lineno` | Clear the breakpoint (or breakpoints) at this
    line. |'
  prefs: []
  type: TYPE_TB
- en: '| `cl(ear) breakpoint [breakpoint ...]` | Clear the breakpoint (or breakpoints)
    with these numbers. |'
  prefs: []
  type: TYPE_TB
- en: 'Now let’s execute this code and enter the interactive debugger to try the commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'That was a lot of output, but it’s actually not as complex as it seems:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we used the `source print_value` command to see the source for the `print_value`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we knew the line number of the first `print` statement, which we
    used to place a breakpoint (`b 5`) at line 5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To check whether we were still at the right position, we used the `w` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the breakpoint was set, we used `c` to continue up to the next breakpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having stopped at the breakpoint at line 5, we used `w` again to confirm that
    and show the current stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We listed the code of the current function using `ll`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We listed the breakpoints using `b`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We removed the breakpoint again using `cl 1` with the breakpoint number from
    the previous command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We continued (`c`) until the program exits or reaches the next breakpoint if
    available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It all seems a bit complicated in the beginning, but you’ll see that it’s actually
    a very convenient way of debugging once you’ve tried a few times.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it even better, this time we will execute the breakpoint only when
    `value = 3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To list what we have done:'
  prefs: []
  type: TYPE_NORMAL
- en: First, using `source print_value`, we looked for the line number and variable
    name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we placed a breakpoint with the `value == 3` condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we continued execution using `c`. As you can see, the values `0`, `1`,
    and `2` are printed as normal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The breakpoint was reached at value `3`. To verify, we used `a` to see the function
    arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We changed the variable before `print()` was executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We continued to execute the rest of the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Catching exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All of these have been manual calls to the `pdb.set_trace()` function, but
    in general, you are just running your application and not really expecting issues.
    This is where exception catching can be very handy. In addition to importing `pdb`
    yourself, you can run scripts through `pdb` as a module as well. Let’s examine
    this bit of code, which dies as soon as it reaches zero division:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run it through the `pdb` module, we can end up in the Python debugger
    whenever it crashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: A useful little trick within `pdb` is to use the *Enter* button, which, by default,
    will execute the previously executed command again. This is very useful when stepping
    through the program.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Aliases can be a really useful feature to make your life easier. If you “live”
    in a Linux/Unix shell like I do, you are probably already familiar with them,
    but essentially an alias is just a shorthand to save you from having to type (or
    even remember) a long and complicated command.
  prefs: []
  type: TYPE_NORMAL
- en: Which aliases are useful for you depends on your preferences of course, but
    I personally like an alias for the `pprint` (pretty print) module. Within my projects,
    I often use `pf=pprint.pformat` and `pp=pprint.pprint` as aliases, but the same
    goes for `pdb` where I find `pd` a useful shorthand for pretty printing the `__dict__`
    for a given object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pdb` commands for aliases are relatively straightforward and very easy
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `alias` | List all aliases. |'
  prefs: []
  type: TYPE_TB
- en: '| `alias name command` | Create an alias. The command can be any valid Python
    expression, so you can do the following to print all properties for an object:`alias
    pd pp %1.__dict__` |'
  prefs: []
  type: TYPE_TB
- en: '| `unalias name` | Remove an alias. |'
  prefs: []
  type: TYPE_TB
- en: Make sure to use these to your advantage. Within Linux/Unix systems, you have
    probably noticed that many commands (`ls`, `rm`, `cd`) are very short to save
    you some typing; you can do the same with these aliases.
  prefs: []
  type: TYPE_NORMAL
- en: commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `commands` command is a little complicated but very useful. It allows you
    to execute commands whenever a specific breakpoint is encountered. To illustrate
    this, let’s start from a simple example again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is simple enough, so now we’ll add the breakpoint and the commands,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can easily add commands to the breakpoint. After removing
    the breakpoint, these commands won’t be executed anymore because they are linked
    to the breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: These can be really useful to add some automatic debug `print` statements to
    your breakpoint; for example, to see the value of all of the variables in the
    local scope. You can always manually do a `print(locals())` of course, but these
    can save you a lot of time while debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with IPython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the generic Python console is useful, it can be a little rough around
    the edges. The IPython console offers a whole new world of extra features, which
    make it a much nicer console to work with. One of those features is a more convenient
    debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make sure you have `ipython` installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s try the debugger with a very basic script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we run IPython and tell it to run the script in debug mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, not all that different from `pdb`. But it automatically shows
    the surrounding code in a readable format, which is very useful. Additionally,
    the shown code has syntax highlighting, which helps with readability as well.
  prefs: []
  type: TYPE_NORMAL
- en: If you install the `ipdb` module, you get features similar to the `pdb` module,
    which allow for triggering breakpoints from your code.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with Jupyter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jupyter is amazing for ad hoc development and makes it really easy to see what’s
    going on in your code for small scripts. For larger scripts, it can quickly become
    more difficult because you normally only get the non-interactive stack trace and
    have to resort to a different method for changing external code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since 2020, however, Jupyter has added a (currently experimental) visual debugger
    to make it possible to debug your code as it happens in a very convenient way.
    To get started, make sure you have a recent version of Jupyter and install both
    the `@jupyterlab/debugger` extension and the `xeus-python` (XPython) kernel for
    Jupyter. To make sure everything works without too much effort, I strongly recommend
    using `conda` for this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The current installation instructions for Conda can be found on the JupyterLab
    debugger GitHub page: [https://jupyterlab.readthedocs.io/en/latest/user/debugger.html](Chapter_11.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a regular Python virtual environment, you can try the binary wheel (`.whl`)
    packages so you don’t have to compile anything. Due to the currently experimental
    nature of this feature, it is not supported in all environments yet. At the time
    of writing, binary wheels are available for Python 3.6, 3.7 and 3.8 for OS X,
    Linux, and Windows. A list of available versions can be found here: [https://pypi.org/project/xeus-python/#files](Chapter_11.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start `jupyter lab` as normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is working as expected, you should see the JupyterLab launcher
    now, with both Python 3 and the XPython kernels available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_11_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: JupyterLab Python and XPython kernels'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since only `xeus-python` (XPython) currently supports debugging, we will have
    to open that one. Now we will add our script from before so we can demonstrate
    the debugger. If everything is working correctly, you should see the debug buttons
    at the top-right part of your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_11_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Regular Jupyter console output'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start debugging by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable the debug toggle at the top right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on a line to add a breakpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If everything is set up correctly, it should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_11_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Debugging using Jupyter'
  prefs: []
  type: TYPE_NORMAL
- en: From this point on, you can use the buttons in the debugging pane on the right
    to step over/in/out of the next statement to walk through the code.
  prefs: []
  type: TYPE_NORMAL
- en: Other debuggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `pdb` debugger is simply the Python default, but far from the only option
    to debug Python code. Some of the currently noteworthy debuggers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ipdb`: The `pdb` debugger wrapped in an IPython shell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pudb`: A full-screen command-line debugger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pdbpp` (pdb++): An extension to the regular `pdb` module, which adds tab completion,
    syntax highlighting, and a few other useful features to `pdb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Werkzeug`: A web-based debugger that allows debugging of web applications
    while they are running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many others, of course, and there isn’t a single one that’s the absolute
    best. As is the case with all tools, they all have their advantages and their
    flaws, and the one that is best for your current purpose can be properly decided
    only by you. Chances are that your current Python IDE already has an integrated
    debugger. The PyCharm IDE, for example, even offers built-in remote debugging
    so you can debug applications running on cloud providers from your local graphical
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to debugging when you encounter a problem, there are times when
    you simply need to keep track of errors for later debugging. This can be especially
    difficult if your application is running on remote servers or on computers not
    controlled by you. For this type of error tracking, there are a few very useful
    open-source packages available.
  prefs: []
  type: TYPE_NORMAL
- en: Elastic APM
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Elastic APM is part of the Elastic Stack and can keep track of errors, performance,
    logs, and other data for you. This system can help you track not only Python applications
    but supports a whole range of other languages and applications as well. The Elastic
    Stack (which is built around Elasticsearch) is an extremely versatile and very
    well-maintained stack of software which I highly recommend.
  prefs: []
  type: TYPE_NORMAL
- en: The only downside of the Elastic Stack is that it is a very heavy set of applications,
    which quickly requires a number of dedicated servers to maintain reasonable performance.
    It does scale very well, however; if you ever need more processing power, you
    can simply add a new machine to your cluster and everything will automatically
    rebalance for you.
  prefs: []
  type: TYPE_NORMAL
- en: Sentry
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sentry is an open-source error management system that allows you to collect
    errors from a wide range of languages and frameworks. Some notable features are:'
  prefs: []
  type: TYPE_NORMAL
- en: Grouping of errors so you only get one (or a configurable number of) notification
    of errors per type of error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being able to mark an error as “fixed” so it re-alerts you when it occurs again
    while still showing you the previous occurrences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing a full stack trace including surrounding code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping track of code versions/releases so you know which version (re-)introduced
    an error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign errors to a specific **developer** to fix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the Sentry application is mainly focused on web applications, it can easily
    be used for regular applications and scripts as well.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, Sentry started as a small error-grouping application that could
    be used as an app within an existing Django application, or as a separate installation
    depending on your needs. Since that time, very little of that lightweight structure
    remains; it has grown into a fully fledged error tracking system that has native
    support for many programming languages and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over time, Sentry has gravitated more and more toward the commercial hosted
    platform, however, so hosting the application yourself has become more difficult
    with that. The time that a simple `pip install sentry` was enough to get it running
    is long gone. These days, Sentry is a heavy application that relies on the following
    running services:'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memcached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbolicator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kafka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snuba
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So if you wish to try Sentry, I would recommend trying the free tier of the
    hosted Sentry to see if you like it first. Manually installing is not really a
    valid option anymore, so if you wish to run it self-hosted, your only realistic
    option is to use the `docker-compose` files provided.
  prefs: []
  type: TYPE_NORMAL
- en: When self-hosting, you should keep in mind that it is a heavy application that
    requires a significant amount of resources to run and can easily fill a decently
    sized dedicated server. It is still lighter than Elastic APM, however.
  prefs: []
  type: TYPE_NORMAL
- en: In my experience, you need at least about 2-3 GiB of RAM and about 2 CPU cores
    to run current versions of Sentry. Depending on your load, you might need something
    much heavier, but that is the bare minimum.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For local development, a few small utility functions can make your life much
    easier. We have already seen an example of this with the `print_code` generator
    and the `trace` context wrapper. See if you can extend one of these to:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute code with a timeout so you can see where your application is stalling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measure the duration of the execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show how often that specific bit of code has been executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_11.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained a few different debugging techniques and gotchas. There
    is, of course, much more that can be said about debugging, but I hope you have
    acquired a nice vantage point for debugging your Python code now. Interactive
    debugging techniques are very useful for single-threaded applications and locations
    where interactive sessions are available.
  prefs: []
  type: TYPE_NORMAL
- en: But since that’s not always the case, we also discussed some non-interactive
    options.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, in this chapter, we talked about non-interactive debugging with `print`
    statements, `logging`, `trace`, `traceback`, `asyncio`, and `faulthandler`. We
    also explored interactive debugging with the Python debugger, IPython, and Jupyter,
    as well as learning about alternative debuggers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to monitor and improve both CPU and memory
    performance, as well as finding and fixing memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](Chapter_11.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code156081100001293319171.png)'
  prefs: []
  type: TYPE_IMG
