<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">File I/O and Python Utilities</h1>
            </header>

            <article>
                
<p>In this chapter, we are going to discuss file I/O, that is reading, writing and appending to file in detail. We are also going to discuss Python utilities that enable manipulating files and interacting with the operating system. Each topic has a different level of complexity that we will discuss using an example. Let's get started!</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">File I/O</h1>
            </header>

            <article>
                
<p>We are discussing file I/O for two reasons:</p>
<ul>
<li>In the world of Linux operating systems, everything is a file. Interaction with peripherals on the Raspberry Pi is similar to reading from/writing to a file. For example: In <a href="56d43053-0d4d-47a4-bf28-c36fc00a7da2.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Communication Interfaces</em>, we discussed serial port communication. You should be able to observe that serial port communication is like a file read/write operation.</li>
<li>We use file I/O in some form in every project. For example: Writing sensor data to a CSV file or reading pre-configured options for a web server, and so on.</li>
</ul>
<p>Hence, we thought it would be useful to discuss file I/O in Python as its own chapter (detailed documentation available from here: <a href="https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files"><span class="URLPACKT">https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files</span></a>) and discuss examples where it could play a role while developing applications on the Raspberry Pi Zero.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Reading from a file</h1>
            </header>

            <article>
                
<p>Let's create a simple text file, <kbd>read_file.txt</kbd> with the following text: <kbd>I am learning Python Programming using the Raspberry Pi Zero</kbd> and save it to the code samples directory (or any location of your choice).</p>
<p>To read from a file, we need to make use of the Python's in-built function: <kbd>open</kbd> to open the file. Let's take a quick look at a code snippet that demonstrates opening a text file to read its content and print it to the screen:</p>
<pre>
if __name__ == "__main__":<br/>    # open text file to read<br/>    file = open('read_line.txt', 'r')<br/>    # read from file and store it to data<br/>    data = file.read()<br/>    print(data)<br/>    file.close()
</pre>
<p>Let's discuss this code snippet in detail:</p>
<ol>
<li>The first step in reading the contents of the text file is opening the file using the in-built function <kbd>open</kbd>. The file in question needs to be passed as an argument along with a flag <kbd>r</kbd> that indicates we are opening the file to read the contents (We will discuss other flag options as we discuss each reading/writing files.)</li>
<li>Upon opening the file, the <kbd>open</kbd> function returns a pointer (address to the file object) that is stored in the <kbd>file</kbd> variable.</li>
</ol>
<pre>
       file = open('read_line.txt', 'r')
</pre>
<ol start="3">
<li>This file pointer is used to read the contents of the file and print it to the screen:</li>
</ol>
<pre>
       data = file.read() <br/>       print(data)
</pre>
<ol start="4">
<li>After reading the contents of the file, the file is closed by calling the <kbd>close()</kbd> function.</li>
</ol>
<p>Run the preceding code snippet (available for download along with this chapter—<kbd>read_from_file.py</kbd>) using IDLE3 or the command-line terminal. The contents of the text file would be printed to the screen as follows:</p>
<pre>
    <strong>I am learning Python Programming using the Raspberry Pi Zero</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Reading lines</h1>
            </header>

            <article>
                
<p>Sometimes, it is necessary to read the contents of a file by line-by-file. In Python, there are two options to do this: <kbd>readline()</kbd> and <kbd>readlines()</kbd>:</p>
<ul>
<li><kbd>readline()</kbd>: As the name suggests, this in-built function enables reading one line at a time. Let's review this using an example:</li>
</ul>
<pre>
       if __name__ == "__main__": <br/>          # open text file to read<br/>          file = open('read_line.txt', 'r') <br/><br/>          # read a line from the file<br/>          data = file.readline() <br/>          print(data) <br/><br/>          # read another line from the file <br/>          data = file.readline() <br/>          print(data) <br/><br/>          file.close()
</pre>
<p style="padding-left: 60px">When the preceding code snippet is executed (available for download as <kbd>read_line_from_file.py</kbd> along with this chapter), the <kbd>read_line.txt</kbd> file is opened and a single line is returned by the <kbd>readline()</kbd> function. This line is stored in the variable data. Since the function is called twice in this program, the output is as follows:</p>
<pre>
<strong>       I am learning Python Programming using the Raspberry Pi Zero.</strong> <br/><br/><strong>       This is the second line.</strong>
</pre>
<p style="padding-left: 60px">A new line is returned every time the <kbd>readline</kbd> function is called and it returns an empty string when the end-of-file has reached.</p>
<ul>
<li><kbd>readlines()</kbd>: This function reads the entire content of a file in lines and stores each it to a list:</li>
</ul>
<pre>
       if __name__ == "__main__": <br/>           # open text file to read<br/>           file = open('read_lines.txt', 'r') <br/><br/>           # read a line from the file<br/>           data = file.readlines() <br/>           for line in data: <br/>               print(line) <br/><br/>           file.close()
</pre>
<p style="padding-left: 60px">Since the lines of the files is stored as a list, it could be retrieved by iterating through the list:</p>
<pre>
       data = file.readlines() <br/>           for line in data: <br/>               print(line)
</pre>
<p style="padding-left: 60px">The preceding code snippet is available for download along with this chapter as <kbd>read_lines_from_file.py</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Writing to a file</h1>
            </header>

            <article>
                
<p>Perform the following steps in order to write to a file:</p>
<ol>
<li>The first step in writing to a file is opening a file with the write flag: <kbd>w</kbd>. If the file name that was passed as an argument doesn't exist, a new file is created:</li>
</ol>
<pre>
      file = open('write_file.txt', 'w')
</pre>
<ol start="2">
<li>Once the file is open, the next step is passing the string to be written as argument to the <kbd>write()</kbd> function:</li>
</ol>
<pre>
      file.write('I am excited to learn Python using<br/>      Raspberry Pi Zero')
</pre>
<ol start="3">
<li>Let's put the code together where we write a string to a text file, close it, re-open the file and print the contents of the file to the screen:</li>
</ol>
<pre>
       if __name__ == "__main__": <br/>          # open text file to write<br/>          file = open('write_file.txt', 'w') <br/>          # write a line from the file<br/>          file.write('I am excited to learn Python using<br/>          Raspberry Pi Zero \n') <br/>          file.close() <br/><br/>          file = open('write_file.txt', 'r') <br/>          data = file.read() <br/>          print(data) <br/>          file.close()
</pre>
<ol start="4">
<li>The preceding code snippet is available for download along with this chapter (<kbd>write_to_file.py</kbd>).</li>
<li>When the preceding code snippet is executed, the output is shown as follows:</li>
</ol>
<pre>
       <strong>I am excited to learn Python using Raspberry Pi Zero</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Appending to a file</h1>
            </header>

            <article>
                
<p>Whenever a file is opened using the write flag <kbd>w</kbd>, the contents of the file are deleted and opened afresh to write data. There is an alternative flag <kbd>a</kbd> that enables appending data to the end of the file. This flag also creates a new file if the file (that is passed as an argument to open) doesn't exist. Let's consider the code snippet below where we append a line to the text file <kbd>write_file.txt</kbd> from the previous section:</p>
<pre>
if __name__ == "__main__": <br/>   # open text file to append<br/>   file = open('write_file.txt', 'a') <br/>   # append a line from the file<br/>   file.write('This is a line appended to the file\n') <br/>   file.close() <br/><br/>   file = open('write_file.txt', 'r') <br/>   data = file.read() <br/>   print(data) <br/>   file.close()
</pre>
<p>When the preceding code snippet is executed (available for download along with this chapter—<kbd>append_to_file.py</kbd>), the string <kbd>This is a line appended to the file</kbd> is appended to the end of the text of the file. The contents of the file will include the following:</p>
<pre>
    <strong>I am excited to learn Python using Raspberry Pi Zero</strong><br/><strong>    This is a line appended to the file</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">seek</h1>
            </header>

            <article>
                
<p>Once a file is opened, the file pointer that is used in file I/O moves from the beginning to the end of the file. It is possible to move the pointer to a specific position and read the data from that position. This is especially useful when we are interested in a specific line of a file. Let's consider the text file <kbd>write_file.txt</kbd> from the previous example. The contents of the file include:</p>
<pre>
    <strong>I am excited to learn Python using Raspberry Pi Zero</strong><br/><strong>    This is a line appended to the file</strong>
</pre>
<p>Let's try to skip the first line and read only the second line using <kbd>seek</kbd>:</p>
<pre>
if __name__ == "__main__": <br/>   # open text file to read<br/><br/>   file = open('write_file.txt', 'r') <br/><br/>   # read the second line from the file<br/>   file.seek(53) <br/><br/>   data = file.read() <br/>   print(data) <br/>   file.close()
</pre>
<p>In the preceding example (available for download along with this chapter as <kbd>seek_in_file.py</kbd>), the <kbd>seek</kbd> function is used to move the pointer to byte <kbd>53</kbd> that is the end of first line. Then the file's contents are read and stored into the variable. When this code snippet is executed, the output is as follows:</p>
<pre>
    <strong>This is a line appended to the file</strong>
</pre>
<p>Thus, seek enables moving the file pointer to a specific position.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Read n bytes</h1>
            </header>

            <article>
                
<p>The <kbd>seek</kbd> function enables moving the pointer to a specific position and reading a byte or <kbd>n</kbd> bytes from that position. Let's re-visit reading <kbd>write_file.txt</kbd> and try to read the word <kbd>excited</kbd> in the sentence <kbd>I am excited to learn Python using Raspberry Pi Zero</kbd>.</p>
<pre>
if __name__ == "__main__": <br/>   # open text file to read and write <br/>   file = open('write_file.txt', 'r') <br/><br/>   # set the pointer to the desired position <br/>   file.seek(5) <br/>   data = file.read(1) <br/>   print(data) <br/><br/>   # rewind the pointer<br/>   file.seek(5) <br/>   data = file.read(7) <br/>   print(data) <br/>   file.close()
</pre>
<p>The preceding code can be explained in the following steps:</p>
<ol>
<li>In the first step, the file is opened using the <kbd>read</kbd> flag and the file pointer is set to the fifth byte (using <kbd>seek</kbd>)—the position of the letter <kbd>e</kbd> in the contents of the text file.</li>
<li>Now, we read one byte from the file by passing it as an argument to the <kbd>read</kbd> function. When an integer is passed as an argument, the <kbd>read</kbd> function returns the corresponding number of bytes from the file. When no argument is passed, it reads the entire file. The <kbd>read</kbd> function returns an empty string if the file is empty:</li>
</ol>
<pre>
       file.seek(5) <br/>       data = file.read(1) <br/>       print(data)
</pre>
<ol start="3">
<li>In the second part, we try to read the word <kbd>excited</kbd> from the text file. We rewind the position of the pointer back to the fifth byte. Then we read seven bytes from the file (length of the word <kbd>excited</kbd>).</li>
<li>When the code snippet is executed (available for download along with this chapter as <kbd>seek_to_read.py</kbd>), the program should print the letter <kbd>e</kbd> and the word <kbd>excited</kbd>:</li>
</ol>
<pre>
       file.seek(5) <br/>       data = file.read(7) <br/>       print(data)
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">r+</h1>
            </header>

            <article>
                
<p>We discussed reading and writing to files using the <kbd>r</kbd> and <kbd>w</kbd> flags. There is another called <kbd>r+</kbd>. This flag enables reading and writing to a file. Let's review an example that enables us to understand this flag.</p>
<p>Let's review the contents of <kbd>write_file.txt</kbd> once again:</p>
<pre>
    <strong>I am excited to learn Python using Raspberry Pi Zero</strong><br/><strong>    This is a line appended to the file</strong>
</pre>
<p>Let's modify the second line to read: <kbd>This is a line that was modified</kbd>. The code sample is available for download along with this chapter as <kbd>seek_to_write.py</kbd>.</p>
<pre>
if __name__ == "__main__": <br/>   # open text file to read and write <br/>   file = open('write_file.txt', 'r+') <br/><br/>   # set the pointer to the desired position <br/>   file.seek(68) <br/>   file.write('that was modified \n') <br/><br/>   # rewind the pointer to the beginning of the file<br/>   file.seek(0) <br/>   data = file.read() <br/>   print(data) <br/>   file.close()
</pre>
<p>Let's review how this example works:</p>
<ol>
<li>The first step in this example is opening the file using the <kbd>r+</kbd> flag. This enables reading and writing to the file.</li>
<li>The next step is moving to the 68th byte of the file</li>
<li>The <kbd>that was modified</kbd> string is written to the file at this position. The spaces at the end of the string are used to overwrite the original content of the second sentence.</li>
<li>Now, the file pointer is set to the beginning of the file and its contents are read.</li>
<li>When the preceding code snippet is executed, the modified file contents are printed to the screen as follows:</li>
</ol>
<pre>
       <strong>I am excited to learn Python using Raspberry Pi Zero</strong><br/><strong>       This is a line that was modified</strong>
</pre>
<p>There is another <kbd>a+</kbd> flag that enables appending data to the end of the file and reading at the same time. We will leave this to the reader to figure out using the examples discussed so far.</p>
<div class="packt_infobox">We have discussed different examples on reading and writing to files in Python. It can be overwhelming without sufficient experience in programming. We strongly recommend working through the different code samples provided in this chapter</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Challenge to the reader</h1>
            </header>

            <article>
                
<p>Use the <kbd>a+</kbd> flag to open the <kbd>write_file.txt</kbd> file (discussed in different examples) and append a line to the file. Set the file pointer using <kbd>seek</kbd> and print its contents. You may open the file only once in the program.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">The with keyword</h1>
            </header>

            <article>
                
<p>So far, we discussed different flags that could be used to open files in different modes. The examples we discussed followed a common pattern—open the file, perform read/write operations and close the file. There is an elegant way of interacting with files using the <kbd>with</kbd> keyword.<br/>
If there are any errors during the execution of the code block that interacts with a file, the <kbd>with</kbd> keyword ensures that the file is closed and the associated resources are cleaned up on exiting the code block. As always, let's review the <kbd>with</kbd> keyword with an example:</p>
<pre>
if __name__ == "__main__": <br/>   with open('write_file.txt', 'r+') as file: <br/>         # read the contents of the file and print to the screen <br/>         print(file.read()) <br/>         file.write("This is a line appended to the file") <br/><br/>         #rewind the file and read its contents <br/>         file.seek(0) <br/>         print(file.read()) <br/>   # the file is automatically closed at this point <br/>   print("Exited the with keyword code block")
</pre>
<p>In the preceding example (<kbd>with_keyword_example</kbd>), we skipped closing the file as the <kbd>with</kbd> keyword takes care of closing the file once the execution of the indented code block is complete. The <kbd>with</kbd> keyword also takes care of closing the file while leaving the code block due to an error. This ensures that the resources are cleaned up properly in any scenario. Going forward, we will be using the <kbd>with</kbd> keyword for file I/O.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">configparser</h1>
            </header>

            <article>
                
<p>Let's discuss some aspects of Python programming that is especially helpful while developing applications using the Raspberry Pi. One such tool is the <kbd>configparser</kbd> available in Python. The <kbd>configparser</kbd> module (<a href="https://docs.python.org/3.4/library/configparser.html"><span class="URLPACKT">https://docs.python.org/3.4/library/configparser.html</span></a>) is used to read/write config files for applications.</p>
<p>In software development, config files are generally used to store constants such as access credentials, device ID, and so on In the context of a Raspberry Pi, <kbd>configparser</kbd> could be used to store the list of all GPIO pins in use, addresses of sensors interfaced via the I<sup>2</sup>C interface, and so on. Let's discuss three examples where we learn making use of the <kbd>configparser</kbd> module. In the first example we will create a <kbd>config</kbd> file using the <kbd>configparser</kbd>. In the second example, we will make use of the <kbd>configparser</kbd> to read the config values and in the third example, we will discuss modifying config files in the final example.</p>
<p><strong>Example 1</strong>:</p>
<p>In the first example, let's create a config file that stores information including device ID, GPIO pins in use, sensor interface address, debug switch, and access credentials:</p>
<pre>
import configparser <br/><br/>if __name__ == "__main__": <br/>   # initialize ConfigParser <br/>   config_parser = configparser.ConfigParser() <br/><br/>   # Let's create a config file <br/>   with open('raspi.cfg', 'w') as config_file: <br/>         #Let's add a section called ApplicationInfo <br/>         config_parser.add_section('AppInfo') <br/><br/>         #let's add config information under this section <br/>         config_parser.set('AppInfo', 'id', '123') <br/>         config_parser.set('AppInfo', 'gpio', '2') <br/>         config_parser.set('AppInfo', 'debug_switch', 'True') <br/>         config_parser.set('AppInfo', 'sensor_address', '0x62') <br/><br/>         #Let's add another section for credentials <br/>         config_parser.add_section('Credentials') <br/>         config_parser.set('Credentials', 'token', 'abcxyz123') <br/>         config_parser.write(config_file) <br/>   print("Config File Creation Complete")
</pre>
<p>Let's discuss the preceding code example (available for download along with this chapter as <kbd>config_parser_write.py</kbd>) in detail:</p>
<ol>
<li>The first step is importing the <kbd>configparser</kbd> module and creating an instance of the <kbd>ConfigParser</kbd> class. This instance is going to be called <kbd>config_parser</kbd>:</li>
</ol>
<pre>
       config_parser = configparser.ConfigParser()
</pre>
<ol start="2">
<li>Now, we open a config file called <kbd>raspi.cfg</kbd> using the <kbd>with</kbd> keyword. Since the file doesn't exist, a new config file is created.</li>
<li>The config file is going to consist of two sections namely <kbd>AppInfo</kbd> and <kbd>Credentials</kbd>.</li>
</ol>
<ol start="4">
<li>The two sections could be created using the <kbd>add_section</kbd> method as follows:</li>
</ol>
<pre>
       config_parser.add_section('AppInfo') <br/>       config_parser.add_section('Credentials')
</pre>
<ol start="5">
<li>Each section is going to consist of different set of constants. Each constant could be added to the relevant section using the <kbd>set</kbd> method. The required arguments to the <kbd>set</kbd> method include the section name (under which the parameter/constant is going to be located), the name of the parameter/constant and its corresponding value. For example: The <kbd>id</kbd> parameter can be added to the <kbd>AppInfo</kbd> section and assigned a value of <kbd>123</kbd> as follows:</li>
</ol>
<pre>
       config_parser.set('AppInfo', 'id', '123')
</pre>
<ol start="6">
<li>The final step is saving these config values to the file. This is accomplished using the <kbd>config_parser</kbd> method, <kbd>write</kbd>. The file is closed once the program exits the indented block under the <kbd>with</kbd> keyword:</li>
</ol>
<pre>
       config_parser.write(config_file)
</pre>
<div class="packt_infobox">We strongly recommend trying the code snippets yourself and use these snippets as a reference. You will learn a lot by making mistakes and possibly arrive with a better solution than the one discussed here.</div>
<p>When the preceding code snippet is executed, a config file called <kbd>raspi.cfg</kbd> is created. The contents of the config file would include the contents shown as follows:</p>
<pre>
[AppInfo] <br/>id = 123 <br/>gpio = 2 <br/>debug_switch = True <br/>sensor_address = 0x62 <br/><br/>[Credentials] <br/>token = abcxyz123
</pre>
<p><strong>Example 2</strong>:</p>
<p>Let's discuss an example where we read config parameters from a config file created in the previous example:</p>
<pre>
import configparser <br/><br/>if __name__ == "__main__": <br/>   # initialize ConfigParser <br/>   config_parser = configparser.ConfigParser() <br/><br/>   # Let's read the config file <br/>   config_parser.read('raspi.cfg') <br/><br/>   # Read config variables <br/>   device_id = config_parser.get('AppInfo', 'id') <br/>   debug_switch = config_parser.get('AppInfo', 'debug_switch') <br/>   sensor_address = config_parser.get('AppInfo', 'sensor_address') <br/><br/>   # execute the code if the debug switch is true <br/>   if debug_switch == "True":<br/>         print("The device id is " + device_id) <br/>         print("The sensor_address is " + sensor_address)
</pre>
<div class="packt_infobox">If the config files are created in the format shown, the <kbd>ConfigParser</kbd> class should be able to parse it. It is not really necessary to create config files using a Python program. We just wanted to show programmatic creation of config files as it is easier to programmatically create config files for multiple devices at the same time.</div>
<p>The preceding example is available for download along with this chapter (<kbd>config_parser_read.py</kbd>). Let's discuss how this code sample works:</p>
<ol>
<li>The first step is initializing an instance of the <kbd>ConfigParser</kbd> class called <kbd>config_parser</kbd>.</li>
<li>The second step is loading and reading the config file using the instance method <kbd>read</kbd>.</li>
<li>Since we know the structure of the config file, let's go ahead and read some constants available under the section <kbd>AppInfo</kbd>. The config file parameters can be read using the <kbd>get</kbd> method. The required arguments include the section under which the config parameter is located and the name of the parameter. For example: The config <kbd>id</kbd> parameter is located under the <kbd>AppInfo</kbd> section. Hence, the required arguments to the method include <kbd>AppInfo</kbd> and <kbd>id</kbd>:</li>
</ol>
<pre>
      device_id = config_parser.get('AppInfo', 'id')
</pre>
<ol start="4">
<li>Now that the config parameters are read into variables, let's make use of it in our program. For example: Let's test if the <kbd>debug_switch</kbd> variable (a switch to determine if the program is in debug mode) and print the other config parameters that were retrieved from the file:</li>
</ol>
<pre>
       if debug_switch == "True":<br/>           print("The device id is " + device_id) <br/>           print("The sensor_address is " + sensor_address)
</pre>
<p><strong>Example 3</strong>:</p>
<p>Let's discuss an example where we would like to modify an existing config file. This is especially useful in situations where we need to update the firmware version number in the config file after performing a firmware update.</p>
<p>The following code snippet is available for download as <kbd>config_parser_modify.py</kbd> along with this chapter:</p>
<pre>
import configparser <br/><br/>if __name__ == "__main__": <br/>   # initialize ConfigParser <br/>   config_parser = configparser.ConfigParser() <br/><br/>   # Let's read the config file <br/>   config_parser.read('raspi.cfg') <br/><br/>   # Set firmware version <br/>   config_parser.set('AppInfo', 'fw_version', 'A3') <br/><br/>   # write the updated config to the config file <br/>   with open('raspi.cfg', 'w') as config_file: <br/>       config_parser.write(config_file)
</pre>
<p>Let's discuss how this works:</p>
<ol>
<li>As always, the first step is initializing an instance of the <kbd>ConfigParser</kbd> class. The config file is loaded using the method <kbd>read</kbd>:</li>
</ol>
<pre>
       # initialize ConfigParser <br/>       config_parser = configparser.ConfigParser() <br/><br/>       # Let's read the config file <br/>       config_parser.read('raspi.cfg')
</pre>
<ol start="2">
<li>The required parameter is updated using the <kbd>set</kbd> method (discussed in a previous example):</li>
</ol>
<pre>
       # Set firmware version <br/>       config_parser.set('AppInfo', 'fw_version', 'A3')
</pre>
<ol start="3">
<li>The updated config is saved to the config file using the <kbd>write</kbd> method:</li>
</ol>
<pre>
       with open('raspi.cfg', 'w') as config_file: <br/>          config_parser.write(config_file)
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Challenge to the reader</h1>
            </header>

            <article>
                
<p>Using example 3 as a reference, update the config parameter <kbd>debug_switch</kbd> to the value <kbd>False</kbd>. Repeat example 2 and see what happens.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Reading/writing to CSV files</h1>
            </header>

            <article>
                
<p>In this section, we are <span>going</span> to discuss reading/writing to CSV files. This module (<a href="https://docs.python.org/3.4/library/csv.html"><span class="URLPACKT">https://docs.python.org/3.4/library/csv.html</span></a>) is useful <span>in</span> data logging applications. Since we <span>will</span> be discussing data logging in the <span>next </span>chapter, let's review reading/writing to CSV files.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Writing to CSV files</h1>
            </header>

            <article>
                
<p>Let's consider a scenario where we are reading data from different sensors. This data needs to be recorded to a <span>CSV</span> file where each column corresponds to a reading from a specific sensor. We are going to discuss an example where we record the value <kbd>123</kbd>, <kbd>456</kbd>, and <kbd>789</kbd> in the first row of the <span>CSV</span> file and the second row is going to consist of values including <kbd>Red</kbd>, <kbd>Green</kbd>, and <kbd>Blue</kbd>:</p>
<ol>
<li>The first step in writing to a <span>CSV </span>file is opening a <span>CSV </span>file using the <kbd>with</kbd> keyword:</li>
</ol>
<pre>
       with open("csv_example.csv", 'w') as csv_file:
</pre>
<ol start="2">
<li>The next step is initializing an instance of the <kbd>writer</kbd> class of the <span>CSV </span>module:</li>
</ol>
<pre>
       csv_writer = csv.writer(csv_file)
</pre>
<ol start="3">
<li>Now, each row is added to the file by creating a list that contains all the elements that need to be added to a row. For example: The first row can be added to the list as follows:</li>
</ol>
<pre>
       csv_writer.writerow([123, 456, 789])
</pre>
<ol start="4">
<li>Putting it altogether, we have:</li>
</ol>
<pre>
       import csv <br/>       if __name__ == "__main__": <br/>          # initialize csv writer <br/>          with open("csv_example.csv", 'w') as csv_file: <br/>                csv_writer = csv.writer(csv_file) <br/>                csv_writer.writerow([123, 456, 789]) <br/>                csv_writer.writerow(["Red", "Green", "Blue"])
</pre>
<ol start="5">
<li>When the above code snippet is executed (available for download as <kbd>csv_write.py</kbd> along with this chapter), a CSV file is created in the local directory with the following contents:</li>
</ol>
<pre>
<strong>       123,456,789</strong><br/><strong>       Red,Green,Blue</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Reading from CSV files</h1>
            </header>

            <article>
                
<p>Let's discuss an example where we read the contents of the <span>CSV </span>file created in the previous section:</p>
<ol>
<li>The first step in reading a <span>CSV </span>file is opening it in read mode:</li>
</ol>
<pre>
       with open("csv_example.csv", 'r') as csv_file:
</pre>
<ol start="2">
<li>Next, we initialize an instance of the <kbd>reader</kbd> class from the CSV module. The contents of the <span>CSV </span>file are loaded into the object <kbd>csv_reader</kbd>:</li>
</ol>
<pre>
       csv_reader = csv.reader(csv_file)
</pre>
<ol start="3">
<li>Now that the contents of the <span>CSV </span>file are loaded, each row of the <span>CSV </span>file could be retrieved as follows:</li>
</ol>
<pre>
       for row in csv_reader: <br/>           print(row)
</pre>
<ol start="4">
<li>Put it all together:</li>
</ol>
<pre>
       import csv <br/><br/>       if __name__ == "__main__": <br/>          # initialize csv writer <br/>          with open("csv_example.csv", 'r') as csv_file: <br/>                csv_reader = csv.reader(csv_file) <br/><br/>                for row in csv_reader: <br/>                      print(row)
</pre>
<ol start="5">
<li>When the preceding code snippet is executed (available for download along with this chapter as <kbd>csv_read.py</kbd>), the contents of the file are printed row-by-row where each row is a list that contains the comma separated values:</li>
</ol>
<pre>
       <strong>['123', '456', '789']</strong><br/><strong>       ['Red', 'Green', 'Blue']</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Python utilities</h1>
            </header>

            <article>
                
<p>Python comes with several utilities that enables interacting with other files and the operating system itself. We have identified all those Python utilities that we have used in our past projects. Let's discuss the different modules and their uses as we might use them in the final project of this book.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">The os module</h1>
            </header>

            <article>
                
<p>As the name suggests, this module (<a href="https://docs.python.org/3.1/library/os.html">https://docs.python.org/3.1/library/os.html</a>) enables interacting with the operating system. Let's discuss some of its applications with examples.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Checking a file's existence</h1>
            </header>

            <article>
                
<p>The <kbd>os</kbd> module could be used to check if a file exists in a specific directory. For example: We extensively made use of the <kbd>write_file.txt</kbd> file. Before opening this file to read or write, we could check the file's existence:</p>
<pre>
import os<br/>if __name__ == "__main__":<br/>    # Check if file exists<br/>    if os.path.isfile('/home/pi/Desktop/code_samples/write_file.txt'):<br/>        print('The file exists!')<br/>    else:<br/>        print('The file does not exist!')
</pre>
<p>In the preceding code snippet, we make use of the <kbd>isfile()</kbd> function, available with the <kbd>os.path</kbd> module. When a file's location is passed an argument to the function, it returns <kbd>True</kbd> if the file exists at that location. In this example, since the file <kbd>write_file.txt</kbd> exists in the code examples directory, the function returns <kbd>True</kbd>. Hence the message, <kbd>The file exists</kbd> is printed to the screen:</p>
<pre>
if os.path.isfile('/home/pi/Desktop/code_samples/write_file.txt'): <br/>    print('The file exists!') <br/>else: <br/>    print('The file does not exist!')
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Checking for a folder's existence</h1>
            </header>

            <article>
                
<p>Similar to <kbd>os.path.isfile()</kbd>, there is another function called <kbd>os.path.isdir()</kbd>. It returns <kbd>True</kbd> if a folder exists at a specific location. We have been reviewing all code samples from a folder called <kbd>code_samples</kbd> located on the Raspberry Pi's desktop. It's existence could be confirmed as follows:</p>
<pre>
# Confirm code_samples' existence <br/>if os.path.isdir('/home/pi/Desktop/code_samples'): <br/>    print('The directory exists!') <br/>else: <br/>    print('The directory does not exist!')
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Deleting files</h1>
            </header>

            <article>
                
<p>The <kbd>os</kbd> module also enables deleting files using the <kbd>remove()</kbd> function. Any file that is passed as an argument to the function is deleted. In the <em>File I/O</em> section, we discussed reading from files using the text file, <kbd>read_file.txt</kbd>. Let's delete the file by passing it as an argument to the <kbd>remove()</kbd> function:</p>
<pre>
os.remove('/home/pi/Desktop/code_samples/read_file.txt')
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Killing a process</h1>
            </header>

            <article>
                
<p>It is possible to kill an application running on the Raspberry Pi by passing process <kbd>pid</kbd> to the <kbd>kill()</kbd> function. In the previous chapter, we discussed the <kbd>light_scheduler</kbd> example that runs as a background process on the Raspberry Pi. To demonstrate killing a process, we are going to attempt killing that process. We need to determine the process <kbd>pid</kbd> of the <kbd>light_scheduler</kbd> process (you may pick an application that was started by you as a user and not do not touch root processes). The process <kbd>pid</kbd> could be retrieved from the command-line terminal using the following command:</p>
<pre>
<strong>    ps aux</strong>
</pre>
<p>It spits out the processes currently running on the Raspberry Pi (shown in the following figure). The process <kbd>pid</kbd> for the <kbd>light_scheduler</kbd> application is <span class="packt_screen">1815</span>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="71" src="assets/image_06_001.png" width="555"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">light_scheduler daemon's PID</div>
<p>Assuming we know the process <kbd>pid</kbd> of the application that needs to be killed, let's review killing the function using <kbd>kill()</kbd>. The arguments required to kill the function include the process <kbd>pid</kbd> and signal (<kbd>signal.SIGKILL</kbd>) that needs to be sent to the process to kill the application:</p>
<pre>
import os<br/>import signal<br/>if __name__ == "__main__":<br/>    #kill the application<br/>    try:<br/>        os.kill(1815, signal.SIGKILL)<br/>    except OSError as error:<br/>        print("OS Error " + str(error))
</pre>
<p>The <kbd>signal</kbd> module (<a href="https://docs.python.org/2/library/signal.html)">https://docs.python.org/3/library/signal.html)</a> contains the constants that represents the signals that could be used to stop an application. In this code snippet, we make use of the <kbd>SIGKILL</kbd> signal. Try running the <kbd>ps</kbd> command (<kbd>ps aux</kbd>) and you will notice that the <kbd>light_scheduler</kbd> application has been killed.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Monitoring a process</h1>
            </header>

            <article>
                
<p>In the previous example, we discussed killing an application using the <kbd>kill()</kbd> function. You might have noticed that we made use of something called the <kbd>try</kbd>/<kbd>except</kbd> keywords to attempt killing the application. We will discuss these keywords in detail in the next chapter.</p>
<p>It is also possible to monitor whether an application is running using the <kbd>kill()</kbd> function using the <kbd>try</kbd>/<kbd>except</kbd> keywords. We will discuss monitoring processes using the <kbd>kill()</kbd> function after introducing the concept of trapping exceptions using <kbd>try</kbd>/<kbd>except</kbd> keywords.</p>
<p>All examples discussed in the <kbd>os</kbd> module are available for download along with this chapter as <kbd>os_utils.py</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">The glob module</h1>
            </header>

            <article>
                
<p>The <kbd>glob</kbd> module (<a href="https://docs.python.org/3/library/glob.html">https://docs.python.org/3/library/glob.html</a>) enables identifying files of a specific extension or files that have a specific pattern. For example, it is possible to list all Python files in a folder as follows:</p>
<pre>
# List all files<br/>for file in glob.glob('*.py'):<br/>    print(file)
</pre>
<p>The <kbd>glob()</kbd> function returns a list of files that contains the <kbd>.py</kbd> extension. A <kbd>for</kbd> loop is used to iterate through the list and print each file. When the preceding code snippet is executed, the output contains the list of all code samples belonging to this chapter (output truncated for representation):</p>
<pre>
<strong>read_from_file.py</strong><br/><strong>config_parser_read.py</strong><br/><strong>append_to_file.py</strong><br/><strong>read_line_from_file.py</strong><br/><strong>config_parser_modify.py</strong><br/><strong>python_utils.py</strong><br/><strong>config_parser_write.py</strong><br/><strong>csv_write.py</strong>
</pre>
<p>This module is especially helpful with listing files that have a specific pattern. For example: Let's consider a scenario where you would like to upload files that were created from different trials of an experiment. You are only interested in files that are of the following format: <kbd>file1xx.txt</kbd> where <kbd>x</kbd> stands for any digit between <kbd>0</kbd> and <kbd>9</kbd>. Those files could be sorted and listed as follows:</p>
<pre>
# List all files of the format 1xx.txt<br/>for file in glob.glob('txt_files/file1[0-9][0-9].txt'):<br/>    print(file)
</pre>
<p>In the preceding example, <kbd>[0-9]</kbd> means that the file name could contain any digit between <kbd>0</kbd> and <kbd>9</kbd>. Since we are looking for files of the <kbd>file1xx.txt</kbd> format, the search pattern that is passed an argument to the <kbd>glob()</kbd> function is <kbd>file1[0-9][0-9].txt</kbd>.</p>
<p>When the preceding code snippet is executed, the output contains all text files of the specified format:</p>
<pre>
<strong>txt_files/file126.txt</strong><br/><strong>txt_files/file125.txt</strong><br/><strong>txt_files/file124.txt</strong><br/><strong>txt_files/file123.txt</strong><br/><strong>txt_files/file127.txt</strong>
</pre>
<p>We came across this article that explains the use of expressions for sorting files: <a href="http://www.linuxjournal.com/content/bash-extended-globbing">http://www.linuxjournal.com/content/bash-extended-globbing</a>. The same concept can be extended to searching for files using the <kbd>glob</kbd> module.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Challenge to the reader</h1>
            </header>

            <article>
                
<p>The examples discussed with the <kbd>glob</kbd> module are available for download along with this chapter as <kbd>glob_example.py</kbd>. In one of the examples, we discussed listing files of a specific format. How would you go about listing files that are of the following format: <kbd>filexxxx.*</kbd>? (Here <kbd>x</kbd> represents any number between <kbd>0</kbd> and <kbd>9</kbd>. <kbd>*</kbd> represents any file extension.)</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">The shutil module</h1>
            </header>

            <article>
                
<p>The <kbd>shutil</kbd> module (<a href="https://docs.python.org/3/library/shutil.html">https://docs.python.org/3/library/shutil.html</a>) enables moving and copying files between folders using the <kbd>move()</kbd> and <kbd>copy()</kbd> methods. In the previous section, we listed all text files within the folder, <kbd>txt_files</kbd>. Let's move these files to the current directory (where the code is being executed) using <kbd>move()</kbd>, make a copy of these files once again in <kbd>txt_files</kbd> and finally remove the text files from the current directory:</p>
<pre>
import glob<br/>import shutil<br/>import os<br/>if __name__ == "__main__":<br/>    # move files to the current directory<br/>    for file in glob.glob('txt_files/file1[0-9][0-9].txt'):<br/>        shutil.move(file, '.')<br/>    # make a copy of files in the folder 'txt_files' and delete them<br/>    for file in glob.glob('file1[0-9][0-9].txt'):<br/>        shutil.copy(file, 'txt_files')<br/>        os.remove(file)
</pre>
<p>In the preceding example (available for download along with this chapter as <kbd>shutil_example.py</kbd>), the files are being moved as well as copied from the origin to the destination by specifying the source and the destination as the first and second arguments respectively.</p>
<p>The files to be moved (or copied) are identified using the <kbd>glob</kbd> module. Then, each file is moved or copied using their corresponding methods.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">The subprocess module</h1>
            </header>

            <article>
                
<p>We briefly discussed this module in the previous chapter. The <kbd>subprocess</kbd> module (<a href="https://docs.python.org/3.2/library/subprocess.html">https://docs.python.org/3.2/library/subprocess.html</a>) enables launching another program from within a Python program. One of the commonly used functions from the <kbd>subprocess</kbd> module is <kbd>Popen</kbd>.Any process that needs to be launched from within the program needs to be passed as a list argument to the <kbd>Popen</kbd> function:</p>
<pre>
import subprocess<br/>if __name__ == "__main__":<br/>    subprocess.Popen(['aplay', 'tone.wav'])
</pre>
<p>In the preceding example, <kbd>tone.wav</kbd> (WAVE file that needs to be played) and the command that needs to be run are passed as a list argument to the function. There are several other commands from the <kbd>subprocess</kbd> module that serve a similar purpose. We leave it to your exploration.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">The sys module</h1>
            </header>

            <article>
                
<p>The <kbd>sys</kbd> module (<a href="https://docs.python.org/3/library/sys.html">https://docs.python.org/3/library/sys.html</a>) allows interacting with the Python run-time interpreter. One of the functions of the <kbd>sys</kbd> module is parsing command-line arguments provided as inputs to the program. Let's write a program that reads and prints the contents of the file that is passed as an argument to the program:</p>
<pre>
import sys<br/>if __name__ == "__main__":<br/>    with open(sys.argv[1], 'r') as read_file:<br/>        print(read_file.read())
</pre>
<p>Try running the preceding example as follows:</p>
<pre>
<strong>python3 sys_example.py read_lines.txt</strong>
</pre>
<p>The preceding example is available for download along with this chapter as <kbd>sys_example.py</kbd>. The list of command-line arguments passed while running the program are available as a <kbd>argv</kbd> list in the <kbd>sys</kbd> module. <kbd>argv[0]</kbd> is usually the name of the Python program and <kbd>argv[1]</kbd> is usually the first argument passed to the function.</p>
<p>When <kbd>sys_example.py</kbd> is executed with <kbd>read_lines.txt</kbd> as an argument, the program should print the contents of the text file:</p>
<pre>
<strong>I am learning Python Programming using the Raspberry Pi Zero.</strong><br/><strong>This is the second line.</strong><br/><strong>Line 3.</strong><br/><strong>Line 4.</strong><br/><strong>Line 5.</strong><br/><strong>Line 6.</strong><br/><strong>Line 7.</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, we discussed file I/O – reading and writing to files, different flags used to read, write, and append to files. We talked about moving file pointers to different points in a file to retrieve specific content or overwrite the contents of a file at a specific location. We discussed the <kbd>ConfigParser</kbd> module in Python and its application in storing/retrieving config parameters for applications along with reading and writing to CSV files.</p>
<p>Finally, we discussed different Python utilities that have a potential use in our project. We will be extensively making use of file I/O and the discussed Python utilities in our final project. We strongly recommend familiarizing yourself with the concepts discussed in this chapter before moving onto the final projects discussed in this book.</p>
<p>In the upcoming chapters, we will discuss uploading sensor data stored in CSV files to the cloud and logging errors encountered during the execution of an application. See you in the next chapter!</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>