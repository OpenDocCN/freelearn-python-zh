- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency and Asynchronous Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we covered architectural design patterns: patterns
    that help with solving some unique challenges that come with complex projects.
    Next, we need to discuss concurrency and asynchronous patterns, another important
    category in our solutions catalog.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency allows your program to manage multiple operations simultaneously,
    leveraging the full power of modern processors. It’s akin to a chef preparing
    multiple dishes in parallel, each step orchestrated so that all dishes are ready
    at the same time. Asynchronous programming, on the other hand, lets your application
    move on to other tasks while waiting for operations to complete, such as sending
    a food order to the kitchen and serving other customers until the order is ready.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The Thread Pool pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Worker Model pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Future and Promise pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Observer pattern in reactive programming
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other concurrency and asynchronous patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'See the requirements presented in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017).
    The additional technical requirements for the code discussed in this chapter are
    the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Faker, using `pip` `install faker`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReactiveX, using `pip` `install reactivex`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Thread Pool pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, it’s important to understand what a thread is. In computing, a thread
    is the smallest unit of processing that can be scheduled by an operating system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Threads are like tracks of execution that can run on a computer at the same
    time, which enables many activities to be done simultaneously and thus improve
    performance. They are particularly important in applications that need multitasking,
    such as serving multiple web requests or carrying out multiple computations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Now, onto the Thread Pool pattern itself. Imagine you have many tasks to complete
    but starting each task (which means in this case, creating a thread) can be expensive
    in terms of resources and time. It’s like hiring a new employee every time you
    have a job to do and then letting them go when the job is done. This process can
    be inefficient and costly. By maintaining a collection, or a pool, of worker threads
    that can be created for once and then reused upon several jobs, the Thread Pool
    pattern helps reduce this inefficiency. When one thread finishes a task, it does
    not terminate but goes back to the pool, awaiting another task that it can be
    used again for.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: What are worker threads?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: A worker thread is a thread of execution of a particular task or set of tasks.
    Worker threads are used to offload processing tasks from the main thread, helping
    to keep applications responsive by performing time-consuming or resource-intensive
    tasks asynchronously.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to faster application performance, there are two benefits:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduced overhead**: By reusing threads, the application avoids the overhead
    of creating and destroying threads for each task'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better resource management**: The thread pool limits the number of threads,
    preventing resource exhaustion that could occur if too many threads were created'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的资源管理**：线程池限制了线程的数量，防止了由于创建过多线程而可能发生的资源耗尽'
- en: Real-world examples
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界中的例子
- en: In real life, imagine a small restaurant with a limited number of chefs (threads)
    who cook meals (tasks) for customers. The restaurant can only accommodate a certain
    number of chefs working at once due to kitchen space (system resources). When
    a new order comes in, if all chefs are busy, the order waits in a queue until
    there is an available chef. This way, the restaurant efficiently manages the flow
    of orders with its available chefs, ensuring all are utilized effectively without
    overwhelming the kitchen or needing to hire more staff for each new order.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，想象一家小餐馆，餐馆里有有限数量的厨师（线程）为顾客烹饪餐点（任务）。由于厨房空间（系统资源）的限制，餐馆一次只能容纳一定数量的厨师同时工作。当新的订单到来时，如果所有厨师都在忙碌，订单就会在队列中等待，直到有可用的厨师。这样，餐馆通过其可用的厨师有效地管理订单流，确保所有厨师都得到有效利用，而不会压垮厨房或需要为每个新订单雇佣更多员工。
- en: 'There are also many examples in software:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中也有很多例子：
- en: Web servers often use thread pools to handle incoming client requests. This
    allows them to serve multiple clients simultaneously without the overhead of creating
    a new thread for each request.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络服务器经常使用线程池来处理传入的客户请求。这允许它们同时为多个客户提供服务，而不需要为每个请求创建新的线程。
- en: Databases use thread pools to manage connections, ensuring that a pool of connections
    is always available for incoming queries.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库使用线程池来管理连接，确保总有一池连接可供传入的查询使用。
- en: Task schedulers use thread pools to execute scheduled tasks such as *cron* jobs,
    backups, or updates.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务调度器使用线程池来执行计划的任务，例如*cron*作业、备份或更新。
- en: Use cases for the Thread Pool pattern
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程池模式的用例
- en: 'There are three use cases where the Thread Pool pattern helps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个用例，其中线程池模式有助于：
- en: '**Batch processing**: When you have many tasks that can be performed in parallel,
    a thread pool can distribute them among its worker threads'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批量处理**：当你有许多可以并行执行的任务时，线程池可以将它们分配给其工作线程'
- en: '**Load balancing**: Thread pools can be used to distribute workload evenly
    among worker threads, ensuring that no single thread takes on too much work'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**：线程池可以用来在工作线程之间均匀地分配工作负载，确保没有单个线程承担过多的工作'
- en: '**Resource optimization**: By reusing threads, the thread pool minimizes system
    resource usage, such as memory and CPU time'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源优化**：通过重用线程，线程池最小化了系统资源的使用，例如内存和CPU时间'
- en: Implementing the Thread Pool pattern
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现线程池模式
- en: 'First, let’s stop to break down how a thread pool, for a given application,
    works:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们停下来分析一下对于给定的应用程序，线程池是如何工作的：
- en: When the application starts, the thread pool creates a certain number of worker
    threads. This is the initialization. This number of threads can be fixed or dynamically
    adjusted based on the application’s needs.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序启动时，线程池创建一定数量的工作线程。这是初始化。线程的数量可以是固定的，也可以根据应用程序的需求动态调整。
- en: Then, we have the task submission step. When there’s a task to be done, it’s
    submitted to the pool rather than directly creating a new thread. The task can
    be anything that needs to be executed, such as processing user input, handling
    network requests, or performing calculations.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有任务提交步骤。当有任务要执行时，它被提交到池中，而不是直接创建一个新的线程。任务可以是任何需要执行的内容，例如处理用户输入、处理网络请求或执行计算。
- en: The following step is the task execution. The pool assigns the task to one of
    the available worker threads. If all threads are busy, the task might wait in
    a queue until a thread becomes available.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是任务执行。池将任务分配给一个可用的工作线程。如果所有线程都在忙碌，任务可能会在队列中等待，直到有线程变得可用。
- en: Once a thread completes its task, it doesn’t die. Instead, it returns to the
    pool, ready to be assigned a new task.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦线程完成了其任务，它不会死亡。相反，它返回到池中，准备好被分配新的任务。
- en: For our example, let’s see some code where we create a thread pool with five
    worker threads to handle a set of tasks. We are going to use the `ThreadPoolExecutor`
    class from the `concurrent.futures` module.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，让我们看看一些代码，其中我们创建了一个包含五个工作线程的线程池来处理一组任务。我们将使用`concurrent.futures`模块中的`ThreadPoolExecutor`类。
- en: 'We start by importing what we need for the example, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入示例中需要的模块，如下所示：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we create a function to simulate the tasks, by simply using `time.sleep(1)`
    in this case:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个函数来模拟任务，在这个例子中，我们简单地使用 `time.sleep(1)`：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we use an instance of the `ThreadPoolExecutor` class, created with a
    maximum number of worker threads of 5, and we submit 10 tasks to the thread pool.
    So, the worker threads pick up these tasks and execute them. Once a worker thread
    completes a task, it picks up another from the queue. The code is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用一个 `ThreadPoolExecutor` 类的实例，该实例创建了一个最大工作者线程数为 5 的线程池，并向线程池提交了 10 个任务。因此，工作者线程会取走这些任务并执行它们。一旦工作者线程完成一个任务，它会从队列中取走另一个。代码如下：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When running the example code, using the `ch07/thread_pool.py` Python command,
    you should get the following output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行示例代码时，使用 `ch07/thread_pool.py` Python 命令，你应该得到以下输出：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We see that the tasks were completed in an order different from the order of
    submission. This shows that they were executed concurrently using the threads
    available in the thread pool.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，任务的完成顺序与提交顺序不同。这表明它们是使用线程池中可用的线程并发执行的。
- en: The Worker Model pattern
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Worker Model 模式
- en: The idea behind the Worker Model pattern is to divide a large task or many tasks
    into smaller, manageable units of work, called workers, that can be processed
    in parallel. This approach to concurrency and parallel processing not only accelerates
    processing time but also enhances the application’s performance.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Worker Model 模式的背后思想是将一个大型任务或多个任务划分为更小、更易于管理的单元，称为工作者，这些单元可以并行处理。这种并发和并行处理方法不仅加速了处理时间，还提高了应用程序的性能。
- en: The workers could be threads within a single application (as we have just seen
    in the Thread Pool pattern), separate processes on the same machine, or even different
    machines in a distributed system.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者可以是单个应用程序内的线程（正如我们在线程池模式中刚刚看到的），同一台机器上的独立进程，甚至是分布式系统中的不同机器。
- en: 'The benefits of the Worker Model pattern are the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Worker Model 模式的优点如下：
- en: '**Scalability**: Easily scales with the addition of more workers, which can
    be particularly beneficial in distributed systems where tasks can be processed
    on multiple machines'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：易于通过添加更多工作者进行扩展，这在分布式系统中特别有益，因为可以在多台机器上处理任务'
- en: '**Efficiency**: By distributing tasks across multiple workers, the system can
    make better use of available computing resources, processing tasks in parallel'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：通过将任务分配给多个工作者，系统可以更好地利用可用的计算资源，并行处理任务'
- en: '**Flexibility**: The Worker Model pattern can accommodate a range of processing
    strategies, from simple thread-based workers to complex distributed systems spanning
    multiple servers'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：Worker Model 模式可以适应各种处理策略，从简单的基于线程的工作者到跨越多服务器的复杂分布式系统'
- en: Real-world examples
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: Consider a delivery service where packages (tasks) are delivered by a team of
    couriers (workers). Each courier picks up a package from the distribution center
    (task queue) and delivers it. The number of couriers can vary depending on demand;
    more couriers can be added during busy periods and reduced when it’s quieter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个快递服务，包裹（任务）由一组快递员（工作者）递送。每个快递员从配送中心（任务队列）取走一个包裹并递送。快递员的数量可以根据需求变化；在繁忙时期可以增加更多快递员，而在较安静时可以减少。
- en: In big data processing, the Worker Model pattern is often employed where each
    worker is responsible for mapping or reducing a part of the data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在大数据处理中，Worker Model 模式通常被采用，其中每个工作者负责映射或减少数据的一部分。
- en: In systems such as RabbitMQ or Kafka, the Worker Model pattern is used to process
    messages from a queue concurrently.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RabbitMQ 或 Kafka 等系统中，Worker Model 模式用于并发处理队列中的消息。
- en: We can also cite image processing services. Services that need to process multiple
    images simultaneously often use the Worker Model pattern to distribute the load
    among multiple workers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以引用图像处理服务。需要同时处理多个图像的服务通常使用 Worker Model 模式在多个工作者之间分配负载。
- en: Use cases for the Worker Model pattern
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Worker Model 模式的用例
- en: One use case for the Worker Model pattern is *data transformation*. When you
    have a large dataset that needs to be transformed, you can distribute the work
    among multiple workers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Worker Model 模式的用例之一是*数据转换*。当你有一个需要转换的大型数据集时，你可以将工作分配给多个工作者。
- en: Another one is *task parallelism*. In applications where different tasks are
    independent of each other, the Worker Model pattern can be very effective.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例是*任务并行化*。在任务彼此独立的应用程序中，Worker Model 模式可以非常有效。
- en: A third use case is *distributed computing*, where the Worker Model pattern
    can be extended to multiple machines, making it suitable for distributed computing
    environments.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个用例是 *分布式计算*，工作模型模式可以扩展到多台机器，使其适用于分布式计算环境。
- en: Implementing the Worker Model pattern
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现工作模型模式
- en: 'Before discussing an implementation example, let’s understand how the Worker
    Model pattern works. Three components are involved in the Worker Model pattern:
    workers, a task queue, and, optionally, a dispatcher:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论实现示例之前，让我们了解工作模型模式是如何工作的。工作模型模式涉及三个组件：工作者、任务队列和可选的调度器：
- en: '**The workers**: The primary actors in this model. Each worker can perform
    a piece of the task independently of the others. Depending on the implementation,
    a worker might process one task at a time or handle multiple tasks concurrently.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作者**：在这个模型中的主要角色。每个工作者可以独立于其他工作者执行任务的一部分。根据实现方式，工作者可能一次处理一个任务或同时处理多个任务。'
- en: '**The task queue**: A central component where tasks are stored awaiting processing.
    Workers typically pull tasks from this queue, ensuring that tasks are distributed
    efficiently among them. The queue acts as a buffer, decoupling task submission
    from task processing.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务队列**：一个中央组件，其中存储着等待处理的任务。工作者通常从这个队列中拉取任务，确保任务在他们之间高效分配。队列充当了一个缓冲区，将任务提交与任务处理解耦。'
- en: '**The dispatcher**: In some implementations, a dispatcher component assigns
    tasks to workers based on availability, load, or priority. This can help optimize
    task distribution and resource utilization.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度器**：在某些实现中，调度器组件根据可用性、负载或优先级将任务分配给工作进程。这有助于优化任务分配和资源利用。'
- en: Let’s now see an example where we execute a function in parallel.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个并行执行函数的例子。
- en: 'We start by importing what we need for the example, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入示例中需要的模块，如下所示：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we create a `worker()` function that we are going to run tasks with.
    It takes as a parameter the `task_queue` object that contains the tasks to execute.
    The code is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个 `worker()` 函数，我们将用它来运行任务。该函数接受一个参数 `task_queue` 对象，其中包含要执行的任务。代码如下：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `main()` function, we start by creating a queue of tasks, an instance
    of `multiprocessing.Queue`. Then, we create 10 tasks and add them to the queue:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们首先创建一个任务队列，一个 `multiprocessing.Queue` 实例。然后，我们创建 10 个任务并将它们添加到队列中：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Five worker processes are then created, using the `multiprocessing.Process`
    class, and started. Each worker picks up a task from the queue, to execute it,
    and then picks up another until the queue is empty. Then, we start each worker
    process (using `p.start()`) in a loop, which means that the associated task will
    get executed concurrently. After that, we create another loop where we use the
    process’ `.join()` method so that the program waits for those processes to complete
    their work. That part of the code is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们创建了五个工作进程，使用 `multiprocessing.Process` 类，并启动它们。每个工作进程从队列中取一个任务来执行，然后取另一个任务，直到队列为空。然后，我们通过循环启动每个工作进程（使用
    `p.start()`），这意味着相关的任务将并发执行。之后，我们创建另一个循环，在这个循环中使用进程的 `.join()` 方法，这样程序会等待这些进程完成工作。这部分代码如下：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When running the example code, using the `ch07/worker_model.py` Python command,
    you should get the following output, where you can see that the 5 workers process
    tasks from the task queue in a concurrent way until all 10 tasks are completed:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行示例代码时，使用 `ch07/worker_model.py` Python 命令，你应该得到以下输出，其中可以看到 5 个工作者以并发方式从任务队列中处理任务，直到所有
    10 个任务完成：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This demonstrates our implementation of the Worker Model pattern. This pattern
    is particularly useful for scenarios where tasks are independent and can be processed
    in parallel.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了我们实现的工作模型模式。这种模式特别适用于任务独立且可以并行处理的情况。
- en: The Future and Promise pattern
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来和承诺模式
- en: In the asynchronous programming paradigm, a Future represents a value that is
    not yet known but will be provided eventually. When a function initiates an asynchronous
    operation, instead of blocking until the operation completes and a result is available,
    it immediately returns a Future. This `Future` object acts as a placeholder for
    the actual result available later.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步编程范式下，Future 表示一个尚未知晓但最终会提供的值。当一个函数启动异步操作时，它不会阻塞直到操作完成并得到结果，而是立即返回一个 Future。这个
    `Future` 对象充当了稍后可用的实际结果的占位符。
- en: Futures are commonly used for I/O operations, network requests, and other time-consuming
    tasks that run asynchronously. They allow the program to continue executing other
    tasks rather than waiting for the operation to be completed. That property is
    referred to as *non-blocking*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 未来对象通常用于I/O操作、网络请求和其他耗时的异步任务。它们允许程序在等待操作完成的同时继续执行其他任务。这种特性被称为*非阻塞*。
- en: Once the Future is fulfilled, the result can be accessed through the Future,
    often via callbacks, polling, or blocking until the result is available.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦未来被实现，结果可以通过未来对象访问，通常是通过回调、轮询或阻塞，直到结果可用。
- en: A Promise is the writable, controlling counterpart to a Future. It represents
    the producer side of the asynchronous operation, which will eventually provide
    a result to its associated Future. When the operation completes, the Promise is
    fulfilled with a value or rejected with an error, which then resolves the Future.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺是未来对象的可写、可控对应物。它代表异步操作的生产者端，最终将为相关的未来对象提供结果。当操作完成时，承诺通过一个值或错误被履行或拒绝，然后解决未来对象。
- en: Promises can be chained, allowing a sequence of asynchronous operations to be
    performed clearly and concisely.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺可以被链式调用，允许一系列异步操作以清晰和简洁的方式执行。
- en: 'By allowing a program to continue execution without waiting for asynchronous
    operations, applications become more responsive. Another benefit is *composability*:
    multiple asynchronous operations can be combined, sequenced, or executed in parallel
    in a clean and manageable way.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过允许程序在等待异步操作的同时继续执行，应用程序变得更加响应。另一个好处是*可组合性*：多个异步操作可以以干净和可管理的方式组合、排序或并行执行。
- en: Real-world examples
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际例子
- en: Ordering a custom dining table from a carpenter provides a tangible example
    of the Future and Promise pattern. When you place the order, you receive an estimated
    completion date and design sketch (Future), representing the carpenter’s promise
    to deliver the table. As the carpenter works, this promise moves toward fulfillment.
    The delivery of the completed table resolves the Future, marking the fulfillment
    of the carpenter’s promise to you.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从木匠那里订购定制餐桌提供了未来和承诺模式的实际例子。当你下单时，你会收到一个预计完成日期和设计草图（未来对象），代表木匠交付桌子的承诺。随着木匠的工作进行，这个承诺逐渐得到履行。完成餐桌的交付解决了未来对象，标志着木匠对你承诺的履行。
- en: 'We can also find several examples in the digital realm, such as the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在数字领域找到几个例子，如下所示：
- en: '**Online shopping order tracking**: When you place an order online, the website
    immediately provides you with an order confirmation and a tracking number (Future).
    As your order is processed, shipped, and delivered, status updates (Promise fulfillment)
    are reflected in real time on the tracking page, eventually resolving to a final
    delivery status.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在线购物订单跟踪**：当你在线下单时，网站会立即为你提供订单确认和跟踪号码（未来对象）。随着你的订单被处理、发货和交付，状态更新（承诺的履行）会在跟踪页面上实时反映，最终确定最终的交付状态。'
- en: '**Food delivery apps**: Upon ordering your meal through a food delivery app,
    you’re given an estimated delivery time (Future). The app continuously updates
    the order status—from preparation through pickup and delivery (Promise being fulfilled)—until
    the food arrives at your door, at which point the Future is resolved with the
    completion of your order.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**食品配送应用**：通过食品配送应用下单后，你会收到一个预计的配送时间（未来对象）。应用会持续更新订单状态——从准备到取货和配送（承诺正在履行）——直到食物送到你家门口，此时未来对象因订单完成而得到解决。'
- en: '**Customer support tickets**: When you submit a support ticket on a website,
    you immediately receive a ticket number and a message stating that someone will
    get back to you (Future). Behind the scenes, the support team addresses tickets
    based on priority or in the order they were received. Once your ticket is addressed,
    you receive a response, fulfilling the Promise made when you first submitted the
    ticket.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户支持工单**：当你在一个网站上提交支持工单时，你会立即收到一个工单号码和一条消息，说明有人会回复你（未来对象）。幕后，支持团队根据优先级或接收顺序处理工单。一旦你的工单得到处理，你会收到回复，履行了你最初提交工单时做出的承诺。'
- en: Use cases for the Future and Promise pattern
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来和承诺模式的用例
- en: 'There are at least four use cases where the Future and Promise pattern is recommended:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有四种情况下推荐使用未来和承诺模式：
- en: '**Data pipelines**: In data processing pipelines, data is often transformed
    through multiple stages before reaching its final form. By representing each stage
    with a Future, you can effectively manage the asynchronous flow of data. For example,
    the output of one stage can serve as the input for the next, but because each
    stage returns a Future, subsequent stages don’t have to block while waiting for
    the previous ones to complete.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据处理管道**：在数据处理管道中，数据通常需要经过多个阶段才能达到最终形式。通过用Future表示每个阶段，你可以有效地管理数据的异步流动。例如，一个阶段的输出可以作为下一个阶段的输入，但由于每个阶段都返回一个Future，后续阶段不需要阻塞等待前一个阶段完成。'
- en: '**Task scheduling**: Task scheduling systems, such as those in an operating
    system or a high-level application, can use Futures to represent tasks that are
    scheduled to run at a future time. When a task is scheduled, a Future is returned
    to represent the eventual completion of that task. This allows the system or the
    application to keep track of the task’s state without blocking execution.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**任务调度**：任务调度系统，如操作系统或高级应用程序中的系统，可以使用Future来表示计划在未来运行的任务。当任务被调度时，会返回一个Future来表示该任务的最终完成。这允许系统或应用程序跟踪任务的状态，而不会阻塞执行。'
- en: '**Complex database queries or transactions**: Executing database queries asynchronously
    is crucial for maintaining application responsiveness, particularly in web applications
    where user experience is paramount. By using Futures to represent the outcome
    of database operations, applications can initiate a query and immediately return
    control to the user interface or the calling function. The Future will eventually
    resolve with the query result, allowing the application to update the UI or process
    the data without having frozen or become unresponsive while waiting for the database
    response.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**复杂数据库查询或事务**：异步执行数据库查询对于保持应用程序的响应性至关重要，尤其是在用户体验至关重要的Web应用程序中。通过使用Future来表示数据库操作的结果，应用程序可以发起一个查询并立即将控制权返回给用户界面或调用函数。Future最终会解析为查询结果，允许应用程序更新UI或处理数据，而无需在等待数据库响应时冻结或变得无响应。'
- en: '**File I/O operations**: File I/O operations can significantly impact application
    performance, particularly if executed synchronously on the main thread. By applying
    the Future and Promise pattern, file I/O operations are offloaded to a background
    process, with a Future returned to represent the completion of the operation.
    This approach allows the application to continue running other tasks or responding
    to user interactions while the file is being read from or written to. Once the
    I/O operation completes, the Future resolves, and the application can process
    or display the file data.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**文件输入输出操作**：文件输入输出操作可能会显著影响应用程序的性能，尤其是在主线程上同步执行时。通过应用Future和Promise模式，文件输入输出操作被卸载到后台进程，并返回一个Future来表示操作的完成。这种方法允许应用程序在读取或写入文件的同时继续运行其他任务或响应用户交互。一旦I/O操作完成，Future就会解析，应用程序可以处理或显示文件数据。'
- en: In each of these use cases, the Future and Promise pattern facilitates asynchronous
    operation, allowing applications to remain responsive and efficient by not blocking
    the main thread with long-running tasks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些用例中，Future和Promise模式促进了异步操作，允许应用程序通过不阻塞主线程执行长时间运行的任务，保持响应性和高效性。
- en: Implementing the Future and Promise pattern – using concurrent.futures
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`concurrent.futures`实现Future和Promise模式
- en: 'To understand how to implement the Future and Promise pattern, you must first
    understand the three steps of its mechanism. Let’s break those down next:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何实现Future和Promise模式，你必须首先理解其机制的三个步骤。接下来，让我们逐一分析：
- en: '**Initiation**: The initiation step involves starting an asynchronous operation
    using a function where, instead of waiting for the operation to complete, the
    function immediately returns a “Future” object. This object acts as a placeholder
    for the result that will be available later. Internally, the asynchronous function
    creates a “Promise” object. This object is responsible for handling the outcome
    of the asynchronous operation. The Promise is linked to the Future, meaning the
    state of the Promise (whether it’s fulfilled or rejected) will directly affect
    the Future.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化**：初始化步骤涉及使用一个函数启动异步操作，在该函数中，不是等待操作完成，而是函数立即返回一个“Future”对象。此对象充当稍后可用的结果的占位符。内部，异步函数创建一个“Promise”对象。此对象负责处理异步操作的结果。Promise与Future相关联，这意味着Promise的状态（无论是已履行还是被拒绝）将直接影响Future。'
- en: '**Execution**: During the execution step, the operation proceeds independently
    of the main program flow. This allows the program to remain responsive and continue
    with other tasks. Once the asynchronous task completes, its result needs to be
    communicated back to the part of the program that initiated the operation. The
    outcome of the operation (be it a successful result or an error) is passed to
    the previously created Promise.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行**：在执行步骤中，操作独立于主程序流程进行。这允许程序保持响应性并继续执行其他任务。一旦异步任务完成，其结果需要传达给启动操作的部分程序。操作的结果（无论是成功的结果还是错误）传递给先前创建的Promise。'
- en: '**Resolution**: If the operation is successful, the Promise is “fulfilled”
    with the result. If the operation fails, the Promise is “rejected” with an error.
    The fulfillment or rejection of the Promise resolves the Future. Using the result
    is often done through a callback or continuation function, which is a piece of
    code that specifies what to do with the result. The Future provides mechanisms
    (for example, methods or operators) to specify these callbacks, which will execute
    once the Future is resolved.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解析**：如果操作成功，Promise将“履行”结果。如果操作失败，Promise将“拒绝”错误。Promise的履行或拒绝解决Future。通常通过回调或后续函数使用结果，这是一段指定如何处理结果的代码。Future提供机制（例如，方法或运算符）来指定这些回调，这些回调将在Future解决后执行。'
- en: 'In our example, we use an instance of the `ThreadPoolExecutor` class to execute
    tasks asynchronously. The submit method returns a `Future` object that will eventually
    contain the result of the computation. We start by importing what we need, as
    follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用`ThreadPoolExecutor`类的实例异步执行任务。submit方法返回一个将最终包含计算结果的`Future`对象。我们首先导入所需的模块，如下所示：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we define a function for the task to be executed:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个用于执行的任务的函数：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We submit tasks and get `Future` objects, then we collect the completed Futures.
    The `as_completed` function allows us to iterate over completed `Future` objects
    and retrieve their results:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提交任务并获取`Future`对象，然后我们收集完成的Future对象。`as_completed`函数允许我们遍历完成的`Future`对象并检索它们的结果：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When running the example, using the `ch07/future_and_promise/future.py` Python
    command, you should get the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例时，使用`ch07/future_and_promise/future.py` Python命令，你应该得到以下输出：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This demonstrates our implementation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了我们的实现。
- en: Implementing the Future and Promise pattern – using asyncio
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Future和Promise模式 - 使用asyncio
- en: Python’s `asyncio` library provides another way to execute tasks using asynchronous
    programming. It is particularly useful for I/O-bound tasks. Let’s see a second
    example using this technique.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`asyncio`库提供了另一种使用异步编程执行任务的方法。它特别适用于I/O密集型任务。让我们看看使用这种技术的第二个示例。
- en: What is asyncio?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是asyncio？
- en: The `asyncio` library provides support for asynchronous I/O, event loops, coroutines,
    and other concurrency-related tasks. So, using `asyncio`, developers can write
    code that efficiently handles I/O-bound operations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`库提供了对异步I/O、事件循环、协程和其他并发相关任务的支撑。因此，使用`asyncio`，开发者可以编写高效处理I/O密集型操作的代码。'
- en: Coroutines and async/await
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 协程和async/await
- en: A coroutine is a special kind of function that can pause and resume its execution
    at certain points, allowing other coroutines to run in the meantime. Coroutines
    are declared with the `async` keyword. Also, a coroutine can be awaited from other
    coroutines, using the `await` keyword.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是一种特殊的函数，可以在某些点暂停和恢复其执行，同时允许其他协程在此期间运行。协程使用`async`关键字声明。此外，协程可以使用`await`关键字从其他协程中等待。
- en: 'We import the `asyncio` module, which contains everything we need:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we create a function for the task of computing and returning the square
    of a number. We also want an I/O-bound operation, so we use `asyncio.sleep()`.
    Notice that in the `asyncio` style of programming, such a function is defined
    using the combined keywords `async def` – it is a coroutine. The `asyncio.sleep()`
    function itself is a coroutine, so we make sure to use the `await` keyword when
    calling it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we move to creating our `main()` function. We use the `asyncio.ensure_future()`
    function to create the `Future` objects we want, passing it `square(x)`, with
    `x` being the number to square. We create three `Future` objects, `future1`, `future2`,
    and `future3`. Then, we use the `asyncio.gather()` coroutine to wait for our Futures
    to complete and gather the results. The code for the `main()` function is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'At the end of our code file, we have the usual `if __name__ == "__main__":`
    block. What is new here, since we are writing `asyncio`-based code, is that we
    need to run `asyncio`’s event loop, by calling `asyncio.run(main())`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To test the example, run the `ch07/future_and_promise/async.py` Python command.
    You should get an output like the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The order of the results may vary, depending on who is running the program and
    when. In fact, it is not predictable. You may have noticed similar behavior in
    our previous examples. This is generally the case with concurrency or asynchronous
    code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: This simple example shows that `asyncio` is a suitable choice for the Future
    and Promise pattern when we need to efficiently handle I/O-bound tasks (in scenarios
    such as web scraping or API calls).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The Observer pattern in reactive programming
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Observer pattern (covered in [*Chapter 5*](B21896_05.xhtml#_idTextAnchor121),
    *Behavioral Design Patterns*) is useful for notifying an object or a group of
    objects when the state of a given object changes. This type of traditional Observer
    allows us to react to some object change events. It provides a nice solution for
    many cases, but in a situation where we must deal with many events, some depending
    on each other, the traditional way could lead to complicated, difficult-to-maintain
    code. That is where another paradigm called reactive programming gives us an interesting
    option. In simple terms, the concept of reactive programming is to react to many
    events (streams of events) while keeping our code clean.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Let’s focus on ReactiveX ([http://reactivex.io](http://reactivex.io)), which
    is a part of reactive programming. At the heart of ReactiveX is a concept known
    as an Observable. According to its official website, ReactiveX is about providing
    an API for asynchronous programming with what are called observable streams. This
    concept is added to the idea of the Observer, which we already discussed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Imagine an Observable like a river that flows data or events down to an Observer.
    This Observable sends out items one after another. These items travel through
    a path made up of different steps or operations until they reach an Observer,
    who takes them in or consumes them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An airport’s flight information display system is analogous to an Observable
    in reactive programming. Such a system continuously streams updates about flight
    statuses, including arrivals, departures, delays, and cancellations. This analogy
    illustrates how observers (travelers, airline staff, and airport services subscribed
    to receive updates) subscribe to an Observable (the flight display system) and
    react to a continuous stream of updates, allowing for dynamic responses to real-time
    information.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: A spreadsheet application can also be seen as an example of reactive programming,
    based on its internal behavior. In virtually all spreadsheet applications, interactively
    changing any one cell in the sheet will result in immediately reevaluating all
    formulas that directly or indirectly depend on that cell and updating the display
    to reflect these reevaluations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The ReactiveX idea is implemented in a variety of languages, including Java
    (RxJava), Python (RxPY), and JavaScript (RxJS). The Angular framework uses RxJS
    to implement the Observable pattern.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for the Observer pattern in reactive programming
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One use case is the idea of a collection pipeline, discussed by Martin Fowler
    on his blog ([https://martinfowler.com/articles/collection-pipeline](https://martinfowler.com/articles/collection-pipeline)).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Collection pipeline, described by Martin Fowler
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Collection pipelines are a programming pattern where you organize some computation
    as a sequence of operations that compose by taking a collection as the output
    of one operation and feeding it into the next.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: We can also use an Observable to do operations such as “map and reduce” or “groupby”
    on sequences of objects when processing data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Observables can be created for diverse functions such as button events,
    requests, and Twitter feeds.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Observer pattern in reactive programming
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this example, we decided to build a stream of a list of (fake) people’s
    names (in the `ch07/observer_rx/people.txt`) text file, and an observable based
    on it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: A first example text file containing fake names of people is provided (`ch07/observer_rx/people.txt`)
    as part of the book’s example files. But a new one can be generated whenever needed
    using a helper script (`ch07/observer_rx/peoplelist.py`), which will be presented
    in a minute.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of such a list of names will look like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Back to our implementation. We start by importing what we need:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We define a function, `firstnames_from_db()`, which returns an Observable from
    the text file (reading the content of the file) containing the names, with transformations
    (as we have already seen) using `flat_map()`, `filter()`, and `map()` methods,
    and a new operation, `group_by()`, to emit items from another sequence—the first
    name found in the file, with its number of occurrence:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, in the `main()` function, we define an Observable that emits data every
    5 seconds, merging its emission with what is returned from `firstnames_from_db(db_file)`,
    after setting `db_file` to the people names text file, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is a recap of the example (complete code in the `ch07/observer_rx/rx_peoplelist.py`
    file):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: We import the modules and classes we need.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define a `firstnames_from_db()` function, which returns an Observable from
    the text file that is the source of the data. We collect and push the stored people’s
    first names from that file.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in the `main()` function, we define an Observable that emits data every
    5 seconds, merging its emission with what is returned from calling the `firstnames_from_db()`
    function.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test the example, run the `ch07/observer_rx/rx_peoplelist.py` Python command.
    You should get an output like the following (only an extract is shown here):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once you press a key and press *Enter* on the keyboard, the emission is interrupted,
    and the program stops.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Handling new streams of data
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our test worked, but in a sense, it was static; the stream of data was limited
    to what is currently in the text file. What we need now is to generate several
    streams of data. The technique we can use to generate the type of fake data in
    the text file is based on a third-party module called Faker ([https://pypi.org/project/Faker](https://pypi.org/project/Faker)).
    The code that produces the data is provided to you, for free (in the `ch07/observer_rx/peoplelist.py`
    file), as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let’s see what happens when we execute both programs (`ch07/observer_rx/peoplelist.py`
    and `ch07/observer_rx/rx_peoplelis.py`):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'From one command-line window or terminal, you can generate people’s names,
    passing the right file path to the script; you would execute the following command:
    `python` `ch07/observer_rx/peoplelist.py ch07/observer_rx/people.txt`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a second shell window, you can run the program that implements the Observable
    via the `python` `ch07/observer_rx/rx_peoplelist.py` command.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, what is the output from both commands?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: A new version of the `people.txt` file is created (with the random names in
    it, separated by a comma), to replace the existing file. And, each time you rerun
    that command (`python ch07/observer_rx/peoplelist.py`), a new set of names is
    added to the file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The second command gives an output like the one you got with the first execution;
    the difference is that now it is not the same set of data that is emitted repeatedly.
    Now, new data can be generated in the source and emitted.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Other concurrency and asynchronous patterns
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some other concurrency and asynchronous patterns developers may use.
    We can cite the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**The Actor model**: A conceptual model to deal with concurrent computation.
    It defines some rules for how actor instances should behave: an actor can make
    local decisions, create more actors, send more messages, and determine how to
    respond to the next message received.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asyncio` library).'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message passing**: Used in parallel computing, **object-oriented programming**
    (**OOP**), and **inter-process communication** (**IPC**), where software entities
    communicate and coordinate their actions by passing messages to each other.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backpressure**: A mechanism to manage the flow of data through software systems
    and prevent overwhelming components. It allows systems to gracefully handle overload
    by signaling the producer to slow down until the consumer can catch up.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these patterns has its use cases and trade-offs. It is interesting to
    know they exist, but we cannot discuss all the available patterns and techniques.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed concurrency and asynchronous patterns, patterns
    useful for writing efficient, responsive software that can handle multiple tasks
    at once.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The Thread Pool pattern is a powerful tool in concurrent programming, offering
    a way to manage resources efficiently and improve application performance. It
    helps us improve application performance but also reduces overhead and better
    manages resources because the thread pool limits the number of threads.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: While the Thread Pool pattern focuses on reusing a fixed number of threads to
    execute tasks, the Worker Model pattern is more about the dynamic distribution
    of tasks across potentially scalable and flexible worker entities. This pattern
    is particularly useful for scenarios where tasks are independent and can be processed
    in parallel.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The Future and Promise pattern facilitates asynchronous operation, allowing
    applications to remain responsive and efficient by not blocking the main thread
    with long-running tasks.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the Observer pattern in reactive programming. The core idea
    of this pattern is to react to a stream of data and events, as with the streams
    of water we see in nature. We have lots of examples of this idea in the computing
    world. We have discussed an example of ReactiveX, which serves as an introduction
    for the reader to approach this programming paradigm and continue their own research
    via the ReactiveX official documentation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we touched upon the fact that there are other concurrency and asynchronous
    patterns. Each of these patterns has its use cases and trade-offs, but we cannot
    cover them all in a single book.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss performance design patterns.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
