<html><head></head><body>
  <div id="_idContainer116">
    <h1 class="chapterNumber">8</h1>
    <h1 id="_idParaDest-154" class="chapterTitle">The Intersection of Object-Oriented and Functional Programming</h1>
    <p class="normal">There are many aspects of Python that appear more reminiscent of structural or functional programming than object-oriented programming. Although object-oriented programming has been the most visible paradigm of the past two decades, the old models have seen a recent resurgence. As with Python's data structures, most of these tools are syntactic sugar over an underlying object-oriented implementation; we can think of them as a further abstraction layer built on top of the (already abstracted) object-oriented paradigm. In this chapter, we'll be covering a grab bag of Python features that are not strictly object-oriented:</p>
    <ul>
      <li class="bullet">Built-in functions that take care of common tasks in one call</li>
      <li class="bullet">An alternative to method overloading</li>
      <li class="bullet">Functions as objects</li>
      <li class="bullet">File I/O and context managers</li>
    </ul>
    <p class="normal">The case study in this chapter will revisit some of the essential algorithms of <em class="italic">k</em>-nearest neighbor classification. We'll look at how we can use functions instead of classes with methods. For parts of the application, separating algorithms from a class definition can provide some flexibility.</p>
    <p class="normal">We'll start this chapter by looking at some of Python's built-in functions. Some of these are closely related to class definitions, allowing us to use a functional style of programming with the underlying complex objects.</p>
    <h1 id="_idParaDest-155" class="title">Python built-in functions</h1>
    <p class="normal">There are <a id="_idIndexMarker511"/>numerous functions in Python that perform a task or calculate a result on certain types of objects without being methods on the underlying class. They <a id="_idIndexMarker512"/>usually abstract common calculations that apply to multiple types of classes. This is duck typing at its best; these functions accept objects that have certain attributes or methods, and are able to perform generic operations using those methods. We've used many of the built-in functions already, but let's quickly go through the important ones and pick up a few neat tricks along the way.</p>
    <h2 id="_idParaDest-156" class="title">The len() function</h2>
    <p class="normal">One simple example <a id="_idIndexMarker513"/>of functions that are related to <a id="_idIndexMarker514"/>object methods is the <code class="Code-In-Text--PACKT-">len()</code> function, which returns the number of items in some kind of container object, such as a dictionary or list. You've seen it before, demonstrated as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">len</span><span class="python">([</span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">, </span><span class="hljs-con-number">3</span><span class="python">, </span><span class="hljs-con-number">4</span><span class="python">])</span>
4
</code></pre>
    <p class="normal">You may wonder why these objects don't have a length property instead of having to call a function on them. Technically, they do. Most objects that <code class="Code-In-Text--PACKT-">len()</code> will apply to have a method called <code class="Code-In-Text--PACKT-">__len__()</code> that returns the same value. So <code class="Code-In-Text--PACKT-">len(myobj)</code> seems to call <code class="Code-In-Text--PACKT-">myobj.__len__()</code>.</p>
    <p class="normal">Why should we use the <code class="Code-In-Text--PACKT-">len()</code> function instead of the <code class="Code-In-Text--PACKT-">__len__()</code> method? Obviously, <code class="Code-In-Text--PACKT-">__len__()</code> is a special double-underscore method, suggesting that we shouldn't call it directly. There must be an explanation for this. The Python developers don't make such design decisions lightly.</p>
    <p class="normal">The main reason is efficiency. When we call the <code class="Code-In-Text--PACKT-">__len__()</code> method of an object, the object has to look the method up in its namespace, and, if the special <code class="Code-In-Text--PACKT-">__getattribute__()</code> method (which is called every time an attribute or method on an object is accessed) is defined on that object, it has to be called as well. Furthermore, the <code class="Code-In-Text--PACKT-">__getattribute__()</code> method may have been written to do something clever, for example, refusing to give us access to special methods such as <code class="Code-In-Text--PACKT-">__len__()</code>! The <code class="Code-In-Text--PACKT-">len()</code> function doesn't encounter any of this. It actually calls the <code class="Code-In-Text--PACKT-">__len__()</code> method on the underlying class, so <code class="Code-In-Text--PACKT-">len(myobj)</code> maps to <code class="Code-In-Text--PACKT-">MyObj.</code><code class="Code-In-Text--PACKT-">__len__(myobj)</code>.</p>
    <p class="normal">Another reason is maintainability. In the future, Python developers may want to change <code class="Code-In-Text--PACKT-">len()</code> so that it can calculate the length of objects that don't have <code class="Code-In-Text--PACKT-">__len__()</code>, for example, by counting the number of items returned in an iterator. They'll only have to change one function instead of countless <code class="Code-In-Text--PACKT-">__len__()</code> methods in many objects across the board.</p>
    <p class="normal">The functional style, <code class="Code-In-Text--PACKT-">len(myobj)</code>, is described by some as more readable than the alternative method style, <code class="Code-In-Text--PACKT-">myobj.len()</code>. Some debate the inconsistency of this syntax, but others prefer it for those few common operations that are applied to a wide number of collection types.</p>
    <p class="normal">Another, sometimes <a id="_idIndexMarker515"/>overlooked, reason for <code class="Code-In-Text--PACKT-">len()</code> being an <a id="_idIndexMarker516"/>external function is backward compatibility. This is often cited in articles as <em class="italic">for historical reasons</em>, which can be a mildly dismissive way of saying a mistake was made long ago and we're stuck with it. Strictly speaking, <code class="Code-In-Text--PACKT-">len()</code> isn't a mistake; it's a design decision that has stood the test of time and has some benefits.</p>
    <h2 id="_idParaDest-157" class="title">The reversed() function</h2>
    <p class="normal">The <code class="Code-In-Text--PACKT-">reversed()</code> function takes <a id="_idIndexMarker517"/>any sequence as input and returns a copy of that sequence in reverse order. It is normally used in <code class="Code-In-Text--PACKT-">for</code> statements <a id="_idIndexMarker518"/>when we want to iterate over items from back to front.</p>
    <p class="normal">Similar to the <code class="Code-In-Text--PACKT-">len()</code> function, <code class="Code-In-Text--PACKT-">reversed()</code> calls the <code class="Code-In-Text--PACKT-">__reversed__()</code> method on the class for the parameter. If that method does not exist, <code class="Code-In-Text--PACKT-">reversed</code> builds the reversed sequence itself using calls to <code class="Code-In-Text--PACKT-">__len__()</code> and <code class="Code-In-Text--PACKT-">__getitem__()</code>, which are used to define a sequence. We only need to override <code class="Code-In-Text--PACKT-">__reversed__()</code> if we want to somehow customize or optimize the process, as demonstrated in the following code:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">CustomSequence</span><span class="hljs-con-class">:</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, args</span><span class="hljs-con-function">):</span>
<span class="hljs-con-meta">...</span> <span class="python">        self._list = args</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__len__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> </span><span class="hljs-con-number">5</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__getitem__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, index</span><span class="hljs-con-function">):</span>
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> </span><span class="hljs-con-string">f"x</span><span class="hljs-con-subst">{index}</span><span class="hljs-con-string">"</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">FunkyBackwards</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">list</span><span class="hljs-con-class">):</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__reversed__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> </span><span class="hljs-con-string">"BACKWARDS!"</span>
</code></pre>
    <p class="normal">Let's exercise this function on three different kinds of lists:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">generic = [</span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">, </span><span class="hljs-con-number">3</span><span class="python">, </span><span class="hljs-con-number">4</span><span class="python">, </span><span class="hljs-con-number">5</span><span class="python">]</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">custom = CustomSequence([</span><span class="hljs-con-number">6</span><span class="python">, </span><span class="hljs-con-number">7</span><span class="python">, </span><span class="hljs-con-number">8</span><span class="python">, </span><span class="hljs-con-number">9</span><span class="python">, </span><span class="hljs-con-number">10</span><span class="python">])</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">funkadelic = FunkyBackwards([</span><span class="hljs-con-number">11</span><span class="python">, </span><span class="hljs-con-number">12</span><span class="python">, </span><span class="hljs-con-number">13</span><span class="python">, </span><span class="hljs-con-number">14</span><span class="python">, </span><span class="hljs-con-number">15</span><span class="python">])</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span><span class="python"> sequence </span><span class="hljs-con-keyword">in</span><span class="python"> generic, custom, funkadelic:</span>
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">f"</span><span class="hljs-con-subst">{sequence.__class__.__name__}</span><span class="hljs-con-string">: "</span><span class="python">, end=</span><span class="hljs-con-string">""</span><span class="python">)</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">for</span><span class="python"> item </span><span class="hljs-con-keyword">in</span><span class="python"> </span><span class="hljs-con-built_in">reversed</span><span class="python">(sequence):</span>
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">f"</span><span class="hljs-con-subst">{item}</span><span class="hljs-con-string">, "</span><span class="python">, end=</span><span class="hljs-con-string">""</span><span class="python">)</span>
<span class="hljs-con-meta">...</span> <span class="python">    print()</span>
list: 5, 4, 3, 2, 1, 
CustomSequence: x4, x3, x2, x1, x0, 
FunkyBackwards: B, A, C, K, W, A, R, D, S, !, 
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">for</code> statements at <a id="_idIndexMarker519"/>the end print reversed versions of a <a id="_idIndexMarker520"/>generic list object, and instances of the <code class="Code-In-Text--PACKT-">CustomSequence</code> class and the <code class="Code-In-Text--PACKT-">FunkyBackwards</code> class. The output shows that <code class="Code-In-Text--PACKT-">reversed</code> works on all three of them, but has very different results. </p>
    <p class="normal">When we reverse <code class="Code-In-Text--PACKT-">CustomSequence</code>, the <code class="Code-In-Text--PACKT-">__getitem__()</code> method is called for each item, which just inserts an <code class="Code-In-Text--PACKT-">x</code> before the index. For <code class="Code-In-Text--PACKT-">FunkyBackwards</code>, the <code class="Code-In-Text--PACKT-">__reversed__()</code> method returns a string, each character of which is output individually in the <code class="Code-In-Text--PACKT-">for</code> loop.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">The <code class="Code-In-Text--PACKT-">CustomSequence</code> class is incomplete. It doesn't define a proper version of <code class="Code-In-Text--PACKT-">__iter__()</code>, so a forward <code class="Code-In-Text--PACKT-">for</code> loop over them will never end. This is the subject of <em class="chapterRef">Chapter 10</em>, <em class="italic">The Iterator Pattern</em>.</p>
    </div>
    <h2 id="_idParaDest-158" class="title">The enumerate() function</h2>
    <p class="normal">Sometimes, when we're examining items in a <a id="_idIndexMarker521"/>container <a id="_idIndexMarker522"/>with a <code class="Code-In-Text--PACKT-">for</code> statement, we want access to the index (the current position in the container) of the current item being processed. The <code class="Code-In-Text--PACKT-">for</code> statement doesn't provide us with indexes, but the <code class="Code-In-Text--PACKT-">enumerate()</code> function gives us something better: it creates a sequence of tuples, where the first object in each tuple is the index and the second is the original item. </p>
    <p class="normal">This is useful because it assigns an index number. It works well for sets or dictionaries where there isn't an inherent index order to the values. It also works for text files, which have an implied line number. Consider some simple code that outputs each of the lines in a file with the associated line numbers:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span><span class="python"> pathlib </span><span class="hljs-con-keyword">import</span><span class="python"> Path</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">with</span><span class="python"> Path(</span><span class="hljs-con-string">"docs/sample_data.md"</span><span class="python">).</span><span class="hljs-con-built_in">open</span><span class="python">() </span><span class="hljs-con-keyword">as</span><span class="python"> source:</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">for</span><span class="python"> index, line </span><span class="hljs-con-keyword">in</span><span class="python"> </span><span class="hljs-con-built_in">enumerate</span><span class="python">(source, start=</span><span class="hljs-con-number">1</span><span class="python">):</span>
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">f"</span><span class="hljs-con-subst">{index:3d}</span><span class="hljs-con-string">: </span><span class="hljs-con-subst">{line.rstrip()}</span><span class="hljs-con-string">"</span><span class="python">)</span>
</code></pre>
    <p class="normal">Running this shows the following:</p>
    <pre class="programlisting con"><code class="hljs-con">1: # Python 3 Object-Oriented Programming
2: 
3: Chapter 8. The Intersection of Object-Oriented and Functional Programming
4: 
5: Some sample data to show how the `enumerate()` function works.
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">enumerate</code> function is an iterable: it <a id="_idIndexMarker523"/>returns a sequence of tuples. Our <code class="Code-In-Text--PACKT-">for</code> statement splits each tuple into two values, and the <code class="Code-In-Text--PACKT-">print()</code> function <a id="_idIndexMarker524"/>formats them together. We used the optional <code class="Code-In-Text--PACKT-">start=1</code> on the enumerate function to provide a convention 1-based sequence of line numbers.</p>
    <p class="normal">We've only touched on a few of the more important Python built-in functions. As you can see, many of them call into object-oriented concepts, while others subscribe to purely functional or procedural paradigms. There are numerous others in the standard library; some of the more interesting ones include the following:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">abs()</code>, <code class="Code-In-Text--PACKT-">str()</code>, <code class="Code-In-Text--PACKT-">repr()</code>, <code class="Code-In-Text--PACKT-">pow()</code>, and <code class="Code-In-Text--PACKT-">divmod()</code> map directly to the special methods <code class="Code-In-Text--PACKT-">__abs__()</code>, <code class="Code-In-Text--PACKT-">__str__()</code>, <code class="Code-In-Text--PACKT-">__repr__()</code>, <code class="Code-In-Text--PACKT-">__pow__()</code>, and <code class="Code-In-Text--PACKT-">__divmod__()</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">bytes()</code>, <code class="Code-In-Text--PACKT-">format()</code>, <code class="Code-In-Text--PACKT-">hash()</code>, and <code class="Code-In-Text--PACKT-">bool()</code> also map directly to the special methods <code class="Code-In-Text--PACKT-">__bytes__()</code>, <code class="Code-In-Text--PACKT-">__format__()</code>, <code class="Code-In-Text--PACKT-">__hash__()</code>, and <code class="Code-In-Text--PACKT-">__bool__()</code></li>
    </ul>
    <p class="normal">And several more. <em class="italic">Section 3.3, Special Methods Names</em> of <em class="italic">The Python Language Reference</em>, provides the details of these mappings. Other interesting built-in functions include the following:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">all()</code> and <code class="Code-In-Text--PACKT-">any()</code>, which accept an iterable object and return <code class="Code-In-Text--PACKT-">True</code> if all, or any, of the items evaluate to true (such as a non-empty string or list, a non-zero number, an object that is not <code class="Code-In-Text--PACKT-">None</code>, or the literal <code class="Code-In-Text--PACKT-">True</code>).</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">eval()</code>, <code class="Code-In-Text--PACKT-">exec()</code>, and <code class="Code-In-Text--PACKT-">compile()</code>, which execute string as code inside the interpreter. Be careful with these ones; they are not safe, so don't execute code an unknown user has supplied to you (in general, assume all unknown users are malicious, foolish, or both).</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">hasattr()</code>, <code class="Code-In-Text--PACKT-">getattr()</code>, <code class="Code-In-Text--PACKT-">setattr()</code>, and <code class="Code-In-Text--PACKT-">delattr()</code>, which allow attributes on an object to be manipulated by their string names.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">zip()</code>, which takes two or more sequences and returns a new sequence of tuples, where each tuple contains a single value from each sequence.</li>
      <li class="bullet">And many more! See the interpreter help documentation for each of the functions listed in <code class="Code-In-Text--PACKT-">help("builtins")</code>.</li>
    </ul>
    <p class="normal">What's central is <a id="_idIndexMarker525"/>avoiding a narrow viewpoint that an <a id="_idIndexMarker526"/>object-oriented programming language must always use <code class="Code-In-Text--PACKT-">object.method()</code> syntax for everything. Python strives for readability, and a simple <code class="Code-In-Text--PACKT-">len(collection)</code> seems more clear than the slightly more consistent <em class="italic">potential</em> alternative, <code class="Code-In-Text--PACKT-">collection.len()</code>. </p>
    <h1 id="_idParaDest-159" class="title">An alternative to method overloading</h1>
    <p class="normal">One prominent feature of many object-oriented programming languages is a tool called <strong class="keyword">method overloading</strong>. Method overloading <a id="_idIndexMarker527"/>refers to having multiple methods with the same name that accept different sets of parameters. In statically typed languages, this is useful if we want to have a method that accepts either an integer or a string, for example. In non-object-oriented languages, we might need two functions, called <code class="Code-In-Text--PACKT-">add_s</code> and <code class="Code-In-Text--PACKT-">add_i</code>, to accommodate such situations. In statically typed object-oriented languages, we'd need two methods, both called <code class="Code-In-Text--PACKT-">add</code>, one that accepts strings, and one that accepts integers.</p>
    <p class="normal">In Python, we've already seen that we only need one method, which accepts any type of object. It may have to do some testing on the object type (for example, if it is a string, convert it to an integer), but only one method is required.</p>
    <p class="normal">The type hints for a parameter that can take on multiple types can become rather complex. We'll often have to use a <code class="Code-In-Text--PACKT-">typing.Union</code> hint to show that a parameter can have values from <code class="Code-In-Text--PACKT-">Union[int, str]</code>. This definition clarifies the alternatives so <strong class="" style="font-style: italic;">mypy</strong> can confirm that we're using the overloaded function properly.</p>
    <p class="normal">We have to distinguish between two varieties of overloading here:</p>
    <ul>
      <li class="bullet">Overloading parameters to allow alternative types using <code class="Code-In-Text--PACKT-">Union[...]</code> hints</li>
      <li class="bullet">Overloading the method by using more complex patterns of parameters</li>
    </ul>
    <p class="normal">For example, an email message method might come in two versions, one of which accepts a parameter for the <em class="italic">from</em> email address. The other method might look up a default <em class="italic">from</em> email address instead. Some languages force us to write multiple methods with the same name and different parameter patterns. Python doesn't permit multiple definitions of methods with the same name, but it does provide a different, equally flexible way to specify variant parameters.</p>
    <p class="normal">We've seen some of the possible ways to send argument values to methods and functions in previous examples, but now we'll cover all the details. The simplest function accepts no parameters. We probably don't need an example, but here's one for completeness:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">no_params</span><span class="hljs-con-function">():</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> </span><span class="hljs-con-string">"Hello, world!"</span>
</code></pre>
    <p class="normal">And here's how it's called:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">no_params()</span>
'Hello, world!'
</code></pre>
    <p class="normal">In this case, since we're <a id="_idIndexMarker528"/>working interactively, we omitted the type hint. A function that does accept parameters will provide the names of those parameter names in a comma-separated list. Only the name of each parameter needs to be supplied. A type hint, however, is always helpful. The hints follow the names, separated by a colon, <code class="Code-In-Text--PACKT-">:</code>.</p>
    <p class="normal">When calling the function, the values for the positional parameters must be specified in order, and none can be missed or skipped. This is the most common way in which we've specified parameters in our previous examples:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">mandatory_params</span><span class="hljs-con-function">(</span><span class="hljs-con-params">x, y, z</span><span class="hljs-con-function">):</span><span class="python"> </span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> </span><span class="hljs-con-string">f"</span><span class="hljs-con-subst">{x=}</span><span class="hljs-con-string">, </span><span class="hljs-con-subst">{y=}</span><span class="hljs-con-string">, </span><span class="hljs-con-subst">{z=}</span><span class="hljs-con-string">"</span>
</code></pre>
    <p class="normal">To call it, type the following:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">a_variable = </span><span class="hljs-con-number">42</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">mandatory_params(</span><span class="hljs-con-string">"a string"</span><span class="python">, a_variable, </span><span class="hljs-con-literal">True</span><span class="python">)</span>
</code></pre>
    <p class="normal">Python code is generic with respect to type. This means that any type of object can be passed as an argument value: an object, a container, a primitive, even functions and classes. The preceding call shows a hardcoded string, the value of a variable, and a Boolean passed into the function.</p>
    <p class="normal">Generally, our applications are not completely generic. That's why we often provide type hints to narrow the domain of possible values. In the rare case when we're writing something truly generic, we can use the <code class="Code-In-Text--PACKT-">typing.Any</code> hint to tell <strong class="" style="font-style: italic;">mypy</strong> that we really mean that any object is usable: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span><span class="python"> typing </span><span class="hljs-con-keyword">import</span><span class="python"> Any</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">mandatory_params</span><span class="hljs-con-function">(</span><span class="hljs-con-params">x: Any, y: Any, z: Any</span><span class="hljs-con-function">) -&gt; str:</span><span class="python"> </span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> </span><span class="hljs-con-string">f"</span><span class="hljs-con-subst">{x=}</span><span class="hljs-con-string">, </span><span class="hljs-con-subst">{y=}</span><span class="hljs-con-string">, </span><span class="hljs-con-subst">{z=}</span><span class="hljs-con-string">"</span>
</code></pre>
    <p class="normal">We can use <strong class="" style="font-style: italic;">mypy</strong> to locate code <a id="_idIndexMarker529"/>like this using the <code class="Code-In-Text--PACKT-">--disallow-any-expr</code> option. This can flag lines that may be in need of some clarity on what types are really important.</p>
    <h2 id="_idParaDest-160" class="title">Default values for parameters</h2>
    <p class="normal">If we want to make a <a id="_idIndexMarker530"/>parameter's value optional, we can specify a default value. Some other languages (Java, for example) require a second method with a <a id="_idIndexMarker531"/>different set of parameters. In Python, we define a single method; we can provide a default value for a parameter using an equals sign. If the calling code does not supply an argument value for the parameter, it will be assigned the given default value. This means calling code can still choose to override the default by passing in a different value. If a value of <code class="Code-In-Text--PACKT-">None</code> is used as the default for optional parameter values, the <code class="Code-In-Text--PACKT-">typing</code> module lets us describe this using the <code class="Code-In-Text--PACKT-">Optional</code> type hint.</p>
    <p class="normal">Here's a function definition with default parameter definitions:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">latitude_dms</span><span class="hljs-function">(</span>
<span class="hljs-params">    deg: </span><span class="hljs-built_in">float</span><span class="hljs-params">, </span><span class="hljs-built_in">min</span><span class="hljs-params">: </span><span class="hljs-built_in">float</span><span class="hljs-params">, sec: </span><span class="hljs-built_in">float</span><span class="hljs-params"> = </span><span class="hljs-number">0.0</span><span class="hljs-params">, </span><span class="hljs-built_in">dir</span><span class="hljs-params">: Optional[</span><span class="hljs-built_in">str</span><span class="hljs-params">] = </span><span class="hljs-literal">None</span>
<span class="hljs-function">) -&gt; str:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">dir</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        <span class="hljs-built_in">dir</span> = <span class="hljs-string">"N"</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">f"</span><span class="hljs-subst">{deg:</span><span class="hljs-number">02.0</span><span class="hljs-subst">f}</span><span class="hljs-string">° </span><span class="hljs-subst">{</span><span class="hljs-built_in">min</span><span class="hljs-subst">+sec/</span><span class="hljs-number">60</span><span class="hljs-subst">:</span><span class="hljs-number">05.3</span><span class="hljs-subst">f}{</span><span class="hljs-built_in">dir</span><span class="hljs-subst">}</span><span class="hljs-string">"</span>
</code></pre>
    <p class="normal">The first two parameters are mandatory and must be provided. The last two parameters have default argument values and can be omitted.</p>
    <p class="normal">There are several ways we can call this function. We can supply all argument values in order, as though all the parameters were positional, as can be seen in the following:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">latitude_dms(</span><span class="hljs-con-number">36</span><span class="python">, </span><span class="hljs-con-number">51</span><span class="python">, </span><span class="hljs-con-number">2.9</span><span class="python">, </span><span class="hljs-con-string">"N"</span><span class="python">)</span>
'36° 51.048N'
</code></pre>
    <p class="normal">Alternatively, we can supply just the mandatory argument values in order, allowing one of the keyword parameters (<code class="Code-In-Text--PACKT-">sec</code>) to use a default value, and providing a keyword argument for the <code class="Code-In-Text--PACKT-">dir</code> parameter:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">latitude_dms(</span><span class="hljs-con-number">38</span><span class="python">, </span><span class="hljs-con-number">58</span><span class="python">, </span><span class="hljs-con-built_in">dir</span><span class="python">=</span><span class="hljs-con-string">"N"</span><span class="python">)</span>
'38° 58.000N'
</code></pre>
    <p class="normal">We've used equals sign syntax when calling a function to skip default values that we aren't interested in. </p>
    <p class="normal">Surprisingly, we can even <a id="_idIndexMarker532"/>use the equals sign syntax to mix up the <a id="_idIndexMarker533"/>order of arguments for the positional parameters, so long as all the parameters are given an argument value:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">latitude_dms(</span><span class="hljs-con-number">38</span><span class="python">, </span><span class="hljs-con-number">19</span><span class="python">, </span><span class="hljs-con-built_in">dir</span><span class="python">=</span><span class="hljs-con-string">"N"</span><span class="python">, sec=</span><span class="hljs-con-number">7</span><span class="python">)</span>
'38° 19.117N'
</code></pre>
    <p class="normal">You may occasionally find it useful to make a <em class="italic">keyword-only</em> parameter. To use this, the argument value must be supplied as a keyword argument. You can do that by placing a <code class="Code-In-Text--PACKT-">*</code> before all of the keyword-only parameters:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">kw_only</span><span class="hljs-function">(</span>
<span class="hljs-function">    </span><span class="hljs-params">x: Any, y: </span><span class="hljs-built_in">str</span><span class="hljs-params"> = </span><span class="hljs-string">"defaultkw"</span><span class="hljs-params">, *, a: </span><span class="hljs-built_in">bool</span><span class="hljs-params">, b: </span><span class="hljs-built_in">str</span><span class="hljs-params"> = </span><span class="hljs-string">"only"</span>
<span class="hljs-function">) -&gt; str:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">f"</span><span class="hljs-subst">{x=}</span><span class="hljs-string">, </span><span class="hljs-subst">{y=}</span><span class="hljs-string">, </span><span class="hljs-subst">{a=}</span><span class="hljs-string">, </span><span class="hljs-subst">{b=}</span><span class="hljs-string">"</span>
</code></pre>
    <p class="normal">This function has one positional parameter, <code class="Code-In-Text--PACKT-">x</code>, and three keyword parameters, <code class="Code-In-Text--PACKT-">y</code>, <code class="Code-In-Text--PACKT-">a</code>, and <code class="Code-In-Text--PACKT-">b</code>. The <code class="Code-In-Text--PACKT-">x</code> and <code class="Code-In-Text--PACKT-">y</code> parameters are both mandatory, but <code class="Code-In-Text--PACKT-">a</code> can only be passed as a keyword argument. <code class="Code-In-Text--PACKT-">y</code> and <code class="Code-In-Text--PACKT-">b</code> are both optional with default values, but if <code class="Code-In-Text--PACKT-">b</code> is supplied, it can only be a keyword argument.</p>
    <p class="normal">This function fails if you don't pass <code class="Code-In-Text--PACKT-">a</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">kw_only(</span><span class="hljs-con-string">'x'</span><span class="python">)</span>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: kw_only() missing 1 required keyword-only argument: 'a'
</code></pre>
    <p class="normal">It also fails if you pass <code class="Code-In-Text--PACKT-">a</code> as a positional argument:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">kw_only(</span><span class="hljs-con-string">'x'</span><span class="python">, </span><span class="hljs-con-string">'y'</span><span class="python">, </span><span class="hljs-con-string">'a'</span><span class="python">)</span>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: kw_only() takes from 1 to 2 positional arguments but 3 were given
</code></pre>
    <p class="normal">But you can pass <code class="Code-In-Text--PACKT-">a</code> and <code class="Code-In-Text--PACKT-">b</code> as keyword arguments:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">kw_only(</span><span class="hljs-con-string">'x'</span><span class="python">, a=</span><span class="hljs-con-string">'a'</span><span class="python">, b=</span><span class="hljs-con-string">'b'</span><span class="python">)</span>
"x='x', y='defaultkw', a='a', b='b'"
</code></pre>
    <p class="normal">We can also mark parameters as being supplied only by position. We do this by providing these names before a single <code class="Code-In-Text--PACKT-">/</code> that separates the positional-only parameters from the more flexible parameters that follow.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">pos_only</span><span class="hljs-function">(</span><span class="hljs-params">x: Any, y: </span><span class="hljs-built_in">str</span><span class="hljs-params">, /, z: Optional[Any] = </span><span class="hljs-literal">None</span><span class="hljs-function">) -&gt; str:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">f"</span><span class="hljs-subst">{x=}</span><span class="hljs-string">, </span><span class="hljs-subst">{y=}</span><span class="hljs-string">, </span><span class="hljs-subst">{z=}</span><span class="hljs-string">"</span>
</code></pre>
    <p class="normal">This function <a id="_idIndexMarker534"/>requires argument values for the <code class="Code-In-Text--PACKT-">x</code> and <code class="Code-In-Text--PACKT-">y</code> parameters <a id="_idIndexMarker535"/>be the first two, and named arguments for <code class="Code-In-Text--PACKT-">x</code> and <code class="Code-In-Text--PACKT-">y</code> are specifically not permitted. Here's what happens if we try:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">pos_only(x=</span><span class="hljs-con-number">2</span><span class="python">, y=</span><span class="hljs-con-string">"three"</span><span class="python">)</span>
Traceback (most recent call last):
  ...
  File "&lt;doctest hint_examples.__test__.test_pos_only[0]&gt;", line 1, in &lt;module&gt;
    pos_only(x=2, y="three")
TypeError: pos_only() got some positional-only arguments passed as keyword arguments: 'x, y'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">pos_only(</span><span class="hljs-con-number">2</span><span class="python">, </span><span class="hljs-con-string">"three"</span><span class="python">)</span>
"x=2, y='three', z=None"
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">pos_only(</span><span class="hljs-con-number">2</span><span class="python">, </span><span class="hljs-con-string">"three"</span><span class="python">, </span><span class="hljs-con-number">3.14159</span><span class="python">) </span>
"x=2, y='three', z=3.14159"
</code></pre>
    <p class="normal">We must provide argument values for the first two parameters, <code class="Code-In-Text--PACKT-">x</code> and <code class="Code-In-Text--PACKT-">y</code>, positionally. The third parameter, <code class="Code-In-Text--PACKT-">z</code>, can be provided positionally, or with a keyword.</p>
    <p class="normal">We have three separate <a id="_idIndexMarker536"/>kinds of parameter possibilities:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Positional only</strong>: These are handy in a few cases; see PEP 570 for examples: <a href="https://www.python.org/dev/peps/pep-0570"><span class="url">https://www.python.org/dev/peps/pep-0570</span></a>.</li>
      <li class="bullet"><strong class="keyword">Either positional or keyword</strong>: This is the case for most parameters. The order is designed to be helpful, and keywords can be used for clarification. More than three positional parameters invites confusion, so a long list of positional parameters isn't a great idea.</li>
      <li class="bullet"><strong class="keyword">Keyword only</strong>: After the <code class="Code-In-Text--PACKT-">*</code>, the argument values <strong class="" style="font-style: italic;">must</strong> have a keyword supplied. This can be helpful to make rarely used options more visible. It can help to think of keywords as keys to a dictionary.</li>
    </ul>
    <p class="normal">Choosing how to call the method <a id="_idIndexMarker537"/>normally takes care of itself, depending on which values need to be supplied, and which can be left at their defaults. For simple <a id="_idIndexMarker538"/>methods with a few argument values, positional parameters are more or less expected. For complex methods with a lot of argument values, using keywords can help to clarify how things work.</p>
    <h3 id="_idParaDest-161" class="title">Additional details on defaults</h3>
    <p class="normal">One thing to take note of <a id="_idIndexMarker539"/>with keyword arguments is that anything we provide as a default argument is evaluated exactly once when the function is first created, not when it is evaluated. This means we can't have dynamically generated default values. For example, the following code won't behave quite as expected:</p>
    <pre class="programlisting code"><code class="hljs-code">number = <span class="hljs-number">5</span>
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">funky_function</span><span class="hljs-function">(</span><span class="hljs-params">x: </span><span class="hljs-built_in">int</span><span class="hljs-params"> = number</span><span class="hljs-function">) -&gt; str:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">f"</span><span class="hljs-subst">{x=}</span><span class="hljs-string">, </span><span class="hljs-subst">{number=}</span><span class="hljs-string">"</span>
</code></pre>
    <p class="normal">The default value for the <code class="Code-In-Text--PACKT-">x</code> parameter is the current value <em class="italic">when the function is defined</em>. We can see that behavior when we try to evaluate this with different values for the <code class="Code-In-Text--PACKT-">number</code> variable:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">funky_function(</span><span class="hljs-con-number">42</span><span class="python">)</span>
'x=42, number=5'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">number = </span><span class="hljs-con-number">7</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">funky_function()</span>
'x=5, number=5'
</code></pre>
    <p class="normal">The first evaluation looks like our expectation; the default value is the original value. This is a coincidence. The second evaluation, after changing the global variable, <code class="Code-In-Text--PACKT-">number</code>, shows that the function definition has a fixed value for the default – the variable is not re-evaluated.</p>
    <p class="normal">To make this work, we'll often use <code class="Code-In-Text--PACKT-">None</code> as a default value and assign the current value of a global variable within the body of the function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">better_function</span><span class="hljs-function">(</span><span class="hljs-params">x: Optional[</span><span class="hljs-built_in">int</span><span class="hljs-params">] = </span><span class="hljs-literal">None</span><span class="hljs-function">) -&gt; str:</span>
    <span class="hljs-keyword">if</span> x <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        x = number
    <span class="hljs-keyword">return</span> <span class="hljs-string">f"better: </span><span class="hljs-subst">{x=}</span><span class="hljs-string">, </span><span class="hljs-subst">{number=}</span><span class="hljs-string">"</span>
</code></pre>
    <p class="normal">This <code class="Code-In-Text--PACKT-">better_function()</code> does not have a value for the <code class="Code-In-Text--PACKT-">number</code> variable bound into the function definition. It uses the current value of a global <code class="Code-In-Text--PACKT-">number</code> variable. Yes, this function is implicitly dependent on a global variable, and the docstring should explain that, ideally surrounded by flame emojis to make it clear to anyone reading it how the function's results may not be obviously idempotent.</p>
    <p class="normal">A slightly more compact <a id="_idIndexMarker540"/>way to set a parameter value to an argument or a default looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">better_function_2</span><span class="hljs-function">(</span><span class="hljs-params">x: Optional[</span><span class="hljs-built_in">int</span><span class="hljs-params">] = </span><span class="hljs-literal">None</span><span class="hljs-function">) -&gt; str:</span>
    x = number <span class="hljs-keyword">if</span> x <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> x
    <span class="hljs-keyword">return</span> <span class="hljs-string">f"better: </span><span class="hljs-subst">{x=}</span><span class="hljs-string">, </span><span class="hljs-subst">{number=}</span><span class="hljs-string">"</span>
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">number if x is None else x</code> expression seems to make it clear that <code class="Code-In-Text--PACKT-">x</code> will have the value of the global, <code class="Code-In-Text--PACKT-">number</code>, or the argument value provided for <code class="Code-In-Text--PACKT-">x</code>. </p>
    <p class="normal">The "evaluation at definition time" can trip us up when working with mutable containers such as lists, sets, and dictionaries. It seems like a good design decision to make an empty list (or set or dictionary) as a default value for a parameter. We shouldn't do this because it will create only one instance of the mutable object, when the code is first constructed. This one object will be reused, demonstrated as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">bad_default</span><span class="hljs-function">(</span><span class="hljs-params">tag: </span><span class="hljs-built_in">str</span><span class="hljs-params">, history: </span><span class="hljs-built_in">list</span><span class="hljs-params">[</span><span class="hljs-built_in">str</span><span class="hljs-params">] = []</span><span class="hljs-function">) -&gt; list[str]:</span>
    <span class="hljs-string">""" A Very Bad Design (VBD™)."""</span>
    history.append(tag)
    <span class="hljs-keyword">return</span> history
</code></pre>
    <p class="normal">This is very bad design. We can try to create a history list, <code class="Code-In-Text--PACKT-">h</code>, and append things to it. This seems to work. Spoiler alert: the default object is one specific mutable, <code class="Code-In-Text--PACKT-">list</code>, that's shared:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">h = bad_default(</span><span class="hljs-con-string">"tag1"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">h = bad_default(</span><span class="hljs-con-string">"tag2"</span><span class="python">, h)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">h</span>
['tag1', 'tag2']
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">h2 = bad_default(</span><span class="hljs-con-string">"tag21"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">h2 = bad_default(</span><span class="hljs-con-string">"tag22"</span><span class="python">, h2)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">h2</span>
['tag1', 'tag2', 'tag21', 'tag22']
</code></pre>
    <p class="normal">Whoops, that's not quite what we expected! When we tried to create a second history list, <code class="Code-In-Text--PACKT-">h2</code>, it was based on the one and only default value: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">h</span>
['tag1', 'tag2', 'tag21', 'tag22']
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">h </span><span class="hljs-con-keyword">is</span><span class="python"> h2</span>
True
</code></pre>
    <p class="normal">The usual way to get <a id="_idIndexMarker541"/>around this is to make the default value <code class="Code-In-Text--PACKT-">None</code>. We've seen this in previous examples, and this is a common approach:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">good_default</span><span class="hljs-function">(</span>
<span class="hljs-function">        </span><span class="hljs-params">tag: </span><span class="hljs-built_in">str</span><span class="hljs-params">, history: Optional[</span><span class="hljs-built_in">list</span><span class="hljs-params">[</span><span class="hljs-built_in">str</span><span class="hljs-params">]] = </span><span class="hljs-literal">None</span>
<span class="hljs-function">) -&gt; list[str]:</span>
    history = [] <span class="hljs-keyword">if</span> history <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> history
    history.append(tag)
    <span class="hljs-keyword">return</span> history
</code></pre>
    <p class="normal">This will build a fresh, empty <code class="Code-In-Text--PACKT-">list[str]</code> object if no parameter was supplied. This is the best way to work with default values that are also mutable objects.</p>
    <h2 id="_idParaDest-162" class="title">Variable argument lists</h2>
    <p class="normal">Default values <a id="_idIndexMarker542"/>alone do not allow us all the flexibility we might want. One thing that makes Python really slick is the ability to write methods that accept an arbitrary number of positional or keyword arguments without explicitly naming them. We can also pass arbitrary lists and dictionaries into such functions. In other languages, these are sometimes <a id="_idIndexMarker543"/>called variadic arguments, <strong class="keyword">varargs</strong>.</p>
    <p class="normal">For example, we could write a function to accept a link or list of URLs and download the web pages. The idea is to avoid the confusing-looking overhead of a singleton list when we only want one page downloaded. Instead of accepting a single value with a list of URLs, we can accept an arbitrary number of arguments, where each argument is a URL. We do this by defining one positional parameter to receive all the argument values. This parameter has to be last (among the positional parameters), and we'll decorate it with a <code class="Code-In-Text--PACKT-">*</code> in the function definition, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> urlparse
<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get_pages</span><span class="hljs-function">(</span><span class="hljs-params">*links: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
    <span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> links:
        url = urlparse(link)
        name = <span class="hljs-string">"index.html"</span> <span class="hljs-keyword">if</span> url.path <span class="hljs-keyword">in</span> (<span class="hljs-string">""</span>, <span class="hljs-string">"/"</span>) <span class="hljs-keyword">else</span> url.path
        target = Path(url.netloc.replace(<span class="hljs-string">"."</span>, <span class="hljs-string">"_"</span>)) / name
        print(<span class="hljs-string">f"Create </span><span class="hljs-subst">{target}</span><span class="hljs-string"> from </span><span class="hljs-subst">{link!r}</span><span class="hljs-string">"</span>)
        <span class="hljs-comment"># etc.</span>
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">*</code> in the <code class="Code-In-Text--PACKT-">*links</code> parameter says, <em class="italic">I'll accept any number of arguments and put them all in a tuple named</em> <code class="Code-In-Text--PACKT-">links</code>. If we supply only one argument, it will be a list with one element; if we supply no arguments, it will be an empty list. Thus, all these function calls are valid:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">get_pages()</span>
 
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">get_pages(</span><span class="hljs-con-string">'https://www.archlinux.org'</span><span class="python">) </span>
Create www_archlinux_org/index.html from 'https://www.archlinux.org'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">get_pages(</span><span class="hljs-con-string">'https://www.archlinux.org'</span><span class="python">, </span>
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-string">'https://dusty.phillips.codes'</span><span class="python">,</span>
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-string">'https://itmaybeahack.com'</span>
<span class="hljs-con-meta">...</span> <span class="python">) </span>
Create www_archlinux_org/index.html from 'https://www.archlinux.org'
Create dusty_phillips_codes/index.html from 'https://dusty.phillips.codes'
Create itmaybeahack_com/index.html from 'https://itmaybeahack.com'
</code></pre>
    <p class="normal">Note that our type hint <a id="_idIndexMarker544"/>suggested that all of the positional argument values are of the same type, <code class="Code-In-Text--PACKT-">str</code>, in this example. This is a widespread expectation: the variable parameters feature is little more than syntactic sugar, saving us from writing a dumb-looking list. The alternative to one type for the variable parameter tuple is potentially confusing: why write a function expecting a complex collection of distinct types, but – somehow – not state this in the parameter definitions? Don't write that function.</p>
    <p class="normal">We can also accept arbitrary keyword arguments. These arrive in the function as a dictionary. They are specified with two asterisks (as in <code class="Code-In-Text--PACKT-">**kwargs</code>) in the function declaration. This tool is commonly used in configuration setups. The following class allows us to specify a set of options with default values:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> annotations
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Dict, Any
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Options</span><span class="hljs-class">(</span><span class="hljs-params">Dict[</span><span class="hljs-built_in">str</span><span class="hljs-params">, Any]</span><span class="hljs-class">):</span>
    default_options: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, Any] = {
        <span class="hljs-string">"port"</span>: <span class="hljs-number">21</span>,
        <span class="hljs-string">"host"</span>: <span class="hljs-string">"localhost"</span>,
        <span class="hljs-string">"username"</span>: <span class="hljs-literal">None</span>,
        <span class="hljs-string">"password"</span>: <span class="hljs-literal">None</span>,
        <span class="hljs-string">"debug"</span>: <span class="hljs-literal">False</span>,
    }
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, **kwargs: Any</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-built_in">super</span>().__init__(self.default_options)
        self.update(kwargs)
</code></pre>
    <p class="normal">This class leverages a <a id="_idIndexMarker545"/>feature of the <code class="Code-In-Text--PACKT-">__init__()</code> method. We have a dictionary of default options, with the boring name of <code class="Code-In-Text--PACKT-">default_options</code>, defined as part of the class. The <code class="Code-In-Text--PACKT-">__init__()</code> method starts initializing this instance with the values from the class-level dictionary of defaults. We do that instead of modifying the dictionary directly, in case we instantiate two separate sets of options. (Remember, class-level variables are shared among all instances of the class.) </p>
    <p class="normal">After having seeded the instance from the class-level source data, <code class="Code-In-Text--PACKT-">__init__()</code> uses the <code class="Code-In-Text--PACKT-">update()</code> method inherited from the superclass to change any non-default values to those supplied as keyword arguments. Because the value of <code class="Code-In-Text--PACKT-">kwargs</code> is also a dictionary, the <code class="Code-In-Text--PACKT-">update()</code> method handles the merge of default values with override values.</p>
    <p class="normal">Here's a session demonstrating the class in action:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">options = Options(username=</span><span class="hljs-con-string">"dusty"</span><span class="python">, password=</span><span class="hljs-con-string">"Hunter2"</span><span class="python">,</span>
<span class="hljs-con-meta">...</span> <span class="python">    debug=</span><span class="hljs-con-literal">True</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">options[</span><span class="hljs-con-string">'debug'</span><span class="python">]</span>
True
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">options[</span><span class="hljs-con-string">'port'</span><span class="python">]</span>
21
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">options[</span><span class="hljs-con-string">'username'</span><span class="python">]</span>
'dusty'
</code></pre>
    <p class="normal">We're able to access our <code class="Code-In-Text--PACKT-">options</code> instance using dictionary indexing syntax. The <code class="Code-In-Text--PACKT-">Options</code> dictionary includes both default values and the ones we set using keyword arguments. </p>
    <p class="normal">Note that the parent class is <code class="Code-In-Text--PACKT-">typing.Dict[str, Any]</code>, the class for a generic dictionary limited to strings for keys. When we initialize the <code class="Code-In-Text--PACKT-">default_options</code> object, we can rely on the <code class="Code-In-Text--PACKT-">from __future__ import annotations</code> statement and use <code class="Code-In-Text--PACKT-">dict[str, Any]</code> to tell the <strong class="" style="font-style: italic;">mypy</strong> tool <a id="_idIndexMarker546"/>what to expect for this variable. The distinction is important: the class relies on <code class="Code-In-Text--PACKT-">typing.Dict</code> as a superclass. </p>
    <p class="normal">The variable needs a type hint, and we can use either the <code class="Code-In-Text--PACKT-">typing.Dict</code> class or we can use the built-in <code class="Code-In-Text--PACKT-">dict</code> class. We suggest using the <code class="Code-In-Text--PACKT-">typing</code> module only when absolutely required, and using the built-in classes as much as possible.</p>
    <p class="normal">In the preceding example, it's <a id="_idIndexMarker547"/>possible to pass arbitrary keyword arguments to the <code class="Code-In-Text--PACKT-">Options</code> initializer to represent options that don't exist in the default dictionary. This can be handy when adding new features to an application. This can be bad when debugging a spelling mistake. Providing the "Port" option instead of the "port" option will lead to two similar-looking options where only one should have existed. </p>
    <p class="normal">One way to limit the risk of spelling mistakes is to write an <code class="Code-In-Text--PACKT-">update()</code> method that only replaces existing keys. This can prevent misspellings from creating problems. The solution is interesting and we'll leave it as an exercise for the reader.</p>
    <p class="normal">Keyword arguments are also very useful when we need to accept arbitrary arguments to pass to a second function, but we don't know what those arguments will be. We saw this in action in <em class="chapterRef">Chapter 3</em>, <em class="italic">When Objects Are Alike</em>, when we were building support for multiple inheritance. </p>
    <p class="normal">We can, of course, combine the variable argument and variable keyword argument syntax in one function call, and we can use normal positional and default arguments as well. The following example is somewhat contrived, but demonstrates the four types of parameters in action:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> annotations
<span class="hljs-keyword">import</span> contextlib
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> subprocess
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TextIO
<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">doctest_everything</span><span class="hljs-function">(</span>
<span class="hljs-params">        output: TextIO,</span>
<span class="hljs-params">        *directories: Path,</span>
<span class="hljs-params">        verbose: </span><span class="hljs-built_in">bool</span><span class="hljs-params"> = </span><span class="hljs-literal">False</span><span class="hljs-params">,</span>
<span class="hljs-params">        **stems: </span><span class="hljs-built_in">str</span>
<span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">log</span><span class="hljs-function">(</span><span class="hljs-params">*args: Any, **kwargs: Any</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-keyword">if</span> verbose:
            print(*args, **kwargs)
    <span class="hljs-keyword">with</span> contextlib.redirect_stdout(output):
        <span class="hljs-keyword">for</span> directory <span class="hljs-keyword">in</span> directories:
            log(<span class="hljs-string">f"Searching </span><span class="hljs-subst">{directory}</span><span class="hljs-string">"</span>)
            <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> directory.glob(<span class="hljs-string">"**/*.md"</span>):
                <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(
                        parent.stem == <span class="hljs-string">".tox"</span>
                        <span class="hljs-keyword">for</span> parent <span class="hljs-keyword">in</span> path.parents
                ):
                    <span class="hljs-keyword">continue</span>
                log(
                    <span class="hljs-string">f"File </span><span class="hljs-subst">{path.relative_to(directory)}</span><span class="hljs-string">, "</span>
                    <span class="hljs-string">f"</span><span class="hljs-subst">{path.stem=}</span><span class="hljs-string">"</span>
                )
                <span class="hljs-keyword">if</span> stems.get(path.stem, <span class="hljs-string">""</span>).upper() == <span class="hljs-string">"SKIP"</span>:
                    log(<span class="hljs-string">"Skipped"</span>)
                    <span class="hljs-keyword">continue</span>
                options = []
                <span class="hljs-keyword">if</span> stems.get(path.stem, <span class="hljs-string">""</span>).upper() == <span class="hljs-string">"ELLIPSIS"</span>:
                    options += [<span class="hljs-string">"ELLIPSIS"</span>]
                search_path = directory / <span class="hljs-string">"src"</span>
                print(
                    <span class="hljs-string">f"cd '</span><span class="hljs-subst">{Path.cwd()}</span><span class="hljs-string">'; "</span>
                    <span class="hljs-string">f"PYTHONPATH='</span><span class="hljs-subst">{search_path}</span><span class="hljs-string">' doctest '</span><span class="hljs-subst">{path}</span><span class="hljs-string">' -v"</span>
                )
                option_args = (
                    [<span class="hljs-string">"-o"</span>, <span class="hljs-string">","</span>.join(options)] <span class="hljs-keyword">if</span> options <span class="hljs-keyword">else</span> []
                )
                subprocess.run(
                    [<span class="hljs-string">"python3"</span>, <span class="hljs-string">"-m"</span>, <span class="hljs-string">"doctest"</span>, <span class="hljs-string">"-v"</span>] 
                        + option_args + [<span class="hljs-built_in">str</span>(path)],
                    cwd=directory,
                    env={<span class="hljs-string">"PYTHONPATH"</span>: <span class="hljs-built_in">str</span>(search_path)},
                )
</code></pre>
    <p class="normal">This example <a id="_idIndexMarker548"/>processes an arbitrary list of directory paths to run the <strong class="keyword">doctest</strong> tool on <a id="_idIndexMarker549"/>markdown files in those directories. Let's look at each parameter definition in detail:</p>
    <ul>
      <li class="bullet">The first parameter, <code class="Code-In-Text--PACKT-">output</code>, is an open file to which output will be written.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">directories</code> parameter will be given all non-keyword arguments. These should all be <code class="Code-In-Text--PACKT-">Path()</code> objects.</li>
      <li class="bullet">The keyword-only parameter, <code class="Code-In-Text--PACKT-">verbose</code>, tells us whether to print information on each file processed. </li>
      <li class="bullet">Finally, we can supply any other keyword as the name of a file to process specially. Four names – output, directories, verbose, and stems – are effectively special filenames that can't be given special processing. Any other keyword argument will be collected into the <code class="Code-In-Text--PACKT-">stems</code> dictionary, and these names will be singled out for special processing. Specifically, if a file stem is listed with a value of <code class="Code-In-Text--PACKT-">"SKIP"</code>, the file won't be tested. If there's a value of <code class="Code-In-Text--PACKT-">"ellipsis"</code>, then a special option flag will be provided to doctest.</li>
    </ul>
    <p class="normal">We create an inner helper function, <code class="Code-In-Text--PACKT-">log()</code>, which will print messages only if the <code class="Code-In-Text--PACKT-">verbose</code> parameter has been set. This function keeps code readable by encapsulating this functionality in a single location.</p>
    <p class="normal">The outermost <code class="Code-In-Text--PACKT-">with</code> statement redirects all output normally sent to <code class="Code-In-Text--PACKT-">sys.stdout</code> to the desired file. This <a id="_idIndexMarker550"/>lets us collect a single log from <code class="Code-In-Text--PACKT-">print()</code> functions. The <code class="Code-In-Text--PACKT-">for</code> statement examines all the positional argument values collected into the <code class="Code-In-Text--PACKT-">directories</code> parameter. Each directory is examined with the <code class="Code-In-Text--PACKT-">glob()</code> method to locate all <code class="Code-In-Text--PACKT-">*.md</code> files in any subdirectory. </p>
    <p class="normal">A file's <em class="italic">stem</em> is the name without its path or suffix. So <code class="Code-In-Text--PACKT-">ch_03/docs/examples.md</code> has a stem of <code class="Code-In-Text--PACKT-">examples</code>. If the stem was used as a keyword argument, the value of that argument provides additional details of what to do for files with that specific stem. For example, if we provide the keyword argument <code class="Code-In-Text--PACKT-">examples='SKIP'</code>, this will populate the <code class="Code-In-Text--PACKT-">**stems</code> dictionary, and any file with a stem of <code class="Code-In-Text--PACKT-">examples</code> will be skipped.</p>
    <p class="normal">We use <code class="Code-In-Text--PACKT-">subprocess.run()</code> because of the way doctest works out the local directory. When we want to run doctest in a number of different directories, it seems easiest to be sure that the current working directory (<code class="Code-In-Text--PACKT-">cwd</code>) is set first, before we run doctest.</p>
    <p class="normal">In common cases, this function could be called as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">doctest_everything(
    sys.stdout,
    Path.cwd() / <span class="hljs-string">"ch_02"</span>,
    Path.cwd() / <span class="hljs-string">"ch_03"</span>,
)
</code></pre>
    <p class="normal">This command would locate all the <code class="Code-In-Text--PACKT-">*.md</code> files in these two directories and run doctest. The output would appear on the console because we redirected <code class="Code-In-Text--PACKT-">sys.stdout</code> back to <code class="Code-In-Text--PACKT-">sys.stdout</code>. Very little output would be produced because the <code class="Code-In-Text--PACKT-">verbose</code> parameter would have a default value of <code class="Code-In-Text--PACKT-">False</code>.</p>
    <p class="normal">If we want to collect detailed output, we can call it with the help of the following command:</p>
    <pre class="programlisting code"><code class="hljs-code">doctest_log = Path(<span class="hljs-string">"doctest.log"</span>)
<span class="hljs-keyword">with</span> doctest_log.<span class="hljs-built_in">open</span>(<span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> log:
    doctest_everything(
        log,
        Path.cwd() / <span class="hljs-string">"ch_04"</span>,
        Path.cwd() / <span class="hljs-string">"ch_05"</span>,
        verbose=<span class="hljs-literal">True</span>
    )
</code></pre>
    <p class="normal">This tests files in <a id="_idIndexMarker551"/>two directories and tells us what it's doing. Notice that it is impossible to specify <code class="Code-In-Text--PACKT-">verbose</code> as a positional argument in this example; we must pass this as a keyword argument. Otherwise, Python would think it was another <code class="Code-In-Text--PACKT-">Path</code> in the <code class="Code-In-Text--PACKT-">*directories</code> list.</p>
    <p class="normal">If we want to change the processing for a selected set of files in the list, we can pass additional keyword arguments, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">doctest_everything(
    sys.stdout,
    Path.cwd() / <span class="hljs-string">"ch_02"</span>,
    Path.cwd() / <span class="hljs-string">"ch_03"</span>,
    examples=<span class="hljs-string">"ELLIPSIS"</span>,
    examples_38=<span class="hljs-string">"SKIP"</span>,
    case_study_2=<span class="hljs-string">"SKIP"</span>,
    case_study_3=<span class="hljs-string">"SKIP"</span>,
)
</code></pre>
    <p class="normal">This will test two directories, but won't display any output, since we didn't specify <code class="Code-In-Text--PACKT-">verbose</code>. This will apply the <code class="Code-In-Text--PACKT-">doctest --ellipsis</code> option to any file with a step of <code class="Code-In-Text--PACKT-">examples</code>. Similarly, any file with a stem of <code class="Code-In-Text--PACKT-">examples_38</code>, <code class="Code-In-Text--PACKT-">case_study_2</code>, or <code class="Code-In-Text--PACKT-">case_study_3</code>, are skipped.</p>
    <p class="normal">Because we can provide any name we choose, and they will all be collected into the value of the <code class="Code-In-Text--PACKT-">stems</code> parameter, we can make use of this flexibility to match names of files in the directory structures. There are, of course, a number of limitations on Python identifiers that don't match operating system filenames, making this less than perfect. It does, however, show the amazing flexibility of Python function arguments.</p>
    <h2 id="_idParaDest-163" class="title">Unpacking arguments</h2>
    <p class="normal">There's one more nifty <a id="_idIndexMarker552"/>trick involving positional and keyword parameters. We've used it in some of our previous examples, but it's never too late for an explanation. Given a list or dictionary of values, we can pass a sequence of values into a function as if they were normal positional or keyword arguments. Have a look at this code:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">show_args</span><span class="hljs-con-function">(</span><span class="hljs-con-params">arg1, arg2, arg3=</span><span class="hljs-con-string">"THREE"</span><span class="hljs-con-function">):</span><span class="python"> </span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> </span><span class="hljs-con-string">f"</span><span class="hljs-con-subst">{arg1=}</span><span class="hljs-con-string">, </span><span class="hljs-con-subst">{arg2=}</span><span class="hljs-con-string">, </span><span class="hljs-con-subst">{arg3=}</span><span class="hljs-con-string">"</span><span class="python"> </span>
</code></pre>
    <p class="normal">The function accepts three parameters, one of which has a default value. But when we have a list of three argument values, we can use the <code class="Code-In-Text--PACKT-">*</code> operator inside a function call to unpack it into the three arguments.</p>
    <p class="normal">Here's what it looks like when we run it with <code class="Code-In-Text--PACKT-">*some_args</code> to provide a three-element iterable:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">some_args = </span><span class="hljs-con-built_in">range</span><span class="python">(</span><span class="hljs-con-number">3</span><span class="python">) </span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">show_args(*some_args)</span>
'arg1=0, arg2=1, arg3=2'
</code></pre>
    <p class="normal">The value of <code class="Code-In-Text--PACKT-">*some_args</code> has to match the positional parameter definition. Because there's a default value for <code class="Code-In-Text--PACKT-">arg3</code>, making it optional, we can provide two or three values.</p>
    <p class="normal">If we have a dictionary of arguments, we can use the <code class="Code-In-Text--PACKT-">**</code> syntax to unpack a dictionary to supply argument values for keyword parameters. It looks like this:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">more_args = { </span>
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-string">"arg1"</span><span class="python">: </span><span class="hljs-con-string">"ONE"</span><span class="python">, </span>
<span class="hljs-con-meta">...</span> <span class="python">       </span><span class="hljs-con-string">"arg2"</span><span class="python">: </span><span class="hljs-con-string">"TWO"</span><span class="python">}</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">show_args(**more_args)</span>
"arg1='ONE', arg2='TWO', arg3='THREE'"
</code></pre>
    <p class="normal">This is often useful when mapping information that has been collected from user input or from an outside source (for example, an internet page or a text file) and needs to be provided to a function or method call. Rather than decompose an external source of data into individual keyword parameters, we simply provide the keyword parameters from the dictionary keys. An expression like <code class="Code-In-Text--PACKT-">show_args(arg1=more_args['arg1'], arg2=more_args['arg2'])</code> seems an error-prone way to match a parameter name with the dictionary key.</p>
    <p class="normal">This unpacking syntax can be used in some areas outside of function calls, too. The <code class="Code-In-Text--PACKT-">Options</code> class shown in the <em class="italic">Variable argument lists</em> section, earlier in this chapter, had an <code class="Code-In-Text--PACKT-">__init__()</code> method that looked like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, **kwargs: Any</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
    <span class="hljs-built_in">super</span>().__init__(self.default_options)
    self.update(kwargs)
</code></pre>
    <p class="normal">An even more succinct way to do this would be to unpack the two dictionaries like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, **kwargs: Any</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
    <span class="hljs-built_in">super</span>().__init__({**self.default_options, **kwargs})
</code></pre>
    <p class="normal">The expression <code class="Code-In-Text--PACKT-">{**self.default_options, **kwargs}</code> merges dictionaries by unpacking each <a id="_idIndexMarker553"/>dictionary into keyword arguments and then assembling a final dictionary from them. Because the dictionaries are unpacked in order from left to right, the resulting dictionary will contain all the default options, with any of the <code class="Code-In-Text--PACKT-">kwarg</code> options replacing some of the keys. Here's an example:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">x = {</span><span class="hljs-con-string">'a'</span><span class="python">: </span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-string">'b'</span><span class="python">: </span><span class="hljs-con-number">2</span><span class="python">}</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">y = {</span><span class="hljs-con-string">'b'</span><span class="python">: </span><span class="hljs-con-number">11</span><span class="python">, </span><span class="hljs-con-string">'c'</span><span class="python">: </span><span class="hljs-con-number">3</span><span class="python">}</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">z = {**x, **y}</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">z</span>
{'a': 1, 'b': 11, 'c': 3}
</code></pre>
    <p class="normal">This dictionary unpacking is a handy consequence of the way the <code class="Code-In-Text--PACKT-">**</code> operator transforms a dictionary into named parameters for a function call.</p>
    <p class="normal">After looking at sophisticated ways we can provide argument values to functions, we need to look at functions a little more broadly. Python considers functions as one kind of "callable" object. This means functions are objects, and higher-order functions can accept functions as argument values and return functions as results.</p>
    <h1 id="_idParaDest-164" class="title">Functions are objects, too</h1>
    <p class="normal">There are <a id="_idIndexMarker554"/>numerous situations where we'd like to pass around a small object that is simply called to perform an action. In essence, we'd like an object that is a callable function. This is most frequently done in event-driven programming, such as graphical toolkits or asynchronous servers; we'll see some design patterns that use it in <em class="chapterRef">Chapter 11</em>, <em class="italic">Common Design Patterns</em>, and <em class="chapterRef">Chapter 12</em>, <em class="italic">Advanced Design Patterns</em>.</p>
    <p class="normal">In Python, we don't need to wrap such methods in a class definition because functions are already objects! We can set attributes on functions (though this isn't a common activity), and we can pass them around to be called at a later date. They even have a few special properties that can be accessed directly. </p>
    <p class="normal">Here's yet another contrived example, sometimes used as an interview question:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">fizz</span><span class="hljs-con-function">(</span><span class="hljs-con-params">x: </span><span class="hljs-con-built_in">int</span><span class="hljs-con-function">) -&gt; bool:</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> x % </span><span class="hljs-con-number">3</span><span class="python"> == </span><span class="hljs-con-number">0</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">buzz</span><span class="hljs-con-function">(</span><span class="hljs-con-params">x: </span><span class="hljs-con-built_in">int</span><span class="hljs-con-function">) -&gt; bool:</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> x % </span><span class="hljs-con-number">5</span><span class="python"> == </span><span class="hljs-con-number">0</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">name_or_number</span><span class="hljs-con-function">(</span>
<span class="hljs-con-meta">...</span> <span class="hljs-con-params">        number: </span><span class="hljs-con-built_in">int</span><span class="hljs-con-params">, *tests: Callable[[</span><span class="hljs-con-built_in">int</span><span class="hljs-con-params">], </span><span class="hljs-con-built_in">bool</span><span class="hljs-con-params">]</span><span class="hljs-con-function">) -&gt; </span><span class="hljs-con-keyword">None</span><span class="hljs-con-function">:</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">for</span><span class="python"> t </span><span class="hljs-con-keyword">in</span><span class="python"> tests:</span>
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">if</span><span class="python"> t(number):</span>
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">return</span><span class="python"> t.__name__</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> </span><span class="hljs-con-built_in">str</span><span class="python">(number)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span><span class="python"> i </span><span class="hljs-con-keyword">in</span><span class="python"> </span><span class="hljs-con-built_in">range</span><span class="python">(</span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">11</span><span class="python">):</span>
<span class="hljs-con-meta">...</span> <span class="python">    print(name_or_number(i, fizz, buzz))</span>
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">fizz()</code> and <code class="Code-In-Text--PACKT-">buzz()</code> functions <a id="_idIndexMarker555"/>check to see whether their parameter, <code class="Code-In-Text--PACKT-">x</code>, is an exact multiple of another number. This relies on the definition of the modulo operator: if <em class="italic">x</em> is a multiple of 3, then 3 divides <em class="italic">x</em> with no remainder. Sometimes they say <img src="../Images/B17070_08_001.png" alt="" style="height: 1em;"/> in the math books. In Python, we say <code class="Code-In-Text--PACKT-">x % 3 == 0</code>.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">name_or_number()</code> function uses any number of test functions, provided as the <code class="Code-In-Text--PACKT-">tests</code> parameter value. The <code class="Code-In-Text--PACKT-">for</code> statement assigns each function in the <code class="Code-In-Text--PACKT-">tests</code> collection to a variable, <code class="Code-In-Text--PACKT-">t</code>, then evaluates the variable with the number parameter's value. If the function's value is true, then the result is the function's name.</p>
    <p class="normal">Here's how this function looks when we apply it to a number and another function:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">name_or_number(</span><span class="hljs-con-number">1</span><span class="python">, fizz)</span>
'1'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">name_or_number(</span><span class="hljs-con-number">3</span><span class="python">, fizz)</span>
'fizz'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">name_or_number(</span><span class="hljs-con-number">5</span><span class="python">, fizz)</span>
'5'
</code></pre>
    <p class="normal">In each case, the value of the <code class="Code-In-Text--PACKT-">tests</code> parameter is <code class="Code-In-Text--PACKT-">(fizz,)</code> a tuple that contains only the <code class="Code-In-Text--PACKT-">fizz</code> function. The <code class="Code-In-Text--PACKT-">name_or_number()</code> function evaluates <code class="Code-In-Text--PACKT-">t(number)</code>, where <code class="Code-In-Text--PACKT-">t</code> is the <code class="Code-In-Text--PACKT-">fizz()</code> function. When <code class="Code-In-Text--PACKT-">fizz(number)</code> is true, the value returned is the value of the function's <code class="Code-In-Text--PACKT-">__name__</code> attribute – the <code class="Code-In-Text--PACKT-">'fizz'</code> string. Function names are available at runtime as an attribute of the function. </p>
    <p class="normal">What if we provide multiple functions? Each is applied to the number until one is true: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">name_or_number(</span><span class="hljs-con-number">5</span><span class="python">, fizz, buzz)</span>
'buzz'
</code></pre>
    <p class="normal">This is, by the way, not <a id="_idIndexMarker556"/>completely correct. What should happen for a number like 15? Is it <code class="Code-In-Text--PACKT-">fizz</code> or <code class="Code-In-Text--PACKT-">buzz</code> or both? Because it's both, some work needs to be done in the <code class="Code-In-Text--PACKT-">name_or_number()</code> function to collect <strong class="keyword">all</strong> the names of all the true functions. That sounds like it would make a good exercise. </p>
    <p class="normal">We can add to our list of special functions. We might define <code class="Code-In-Text--PACKT-">bazz()</code> to be true for multiples of seven. This, too, sounds like a good exercise.</p>
    <p class="normal">If we run this code, we can see that we were able to pass two different functions into our <code class="Code-In-Text--PACKT-">name_or_number()</code> function, and get different output for each one:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span><span class="python"> i </span><span class="hljs-con-keyword">in</span><span class="python"> </span><span class="hljs-con-built_in">range</span><span class="python">(</span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">11</span><span class="python">):</span>
<span class="hljs-con-meta">...</span> <span class="python">    print(name_or_number(i, fizz, buzz))</span>
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
</code></pre>
    <p class="normal">We could apply our functions to an argument value using <code class="Code-In-Text--PACKT-">t(number)</code>. We were able to get the value of the function's <code class="Code-In-Text--PACKT-">__name__</code> attribute using <code class="Code-In-Text--PACKT-">t.__name__</code>.</p>
    <h2 id="_idParaDest-165" class="title">Function objects and callbacks</h2>
    <p class="normal">The fact that <a id="_idIndexMarker557"/>functions are top-level objects is most often used to pass them around to be executed at a later date, for example, when a certain condition has been satisfied. Callbacks are <a id="_idIndexMarker558"/>common as part of building a user interface: when the user clicks on something, the framework can call a function so the application code can create a visual response. For very long-running tasks, like file transfers, it is often helpful for the transfer library to call back to the application with status on the number of bytes transferred so far – this makes it possible to display status thermometers to show status.</p>
    <p class="normal">Let's build an event-driven timer <a id="_idIndexMarker559"/>using callbacks so that things will happen at scheduled intervals. This <a id="_idIndexMarker560"/>can be handy for an <strong class="keyword">IoT</strong> (<strong class="keyword">Internet of Things</strong>) application built on a <a id="_idIndexMarker561"/>small CircuitPython or MicroPython device. We'll break this down into two parts: a task, and a scheduler that executes the function object stored in the task: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> annotations
<span class="hljs-keyword">import</span> heapq
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Callable, Any, List, Optional
<span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass, field
Callback = Callable[[<span class="hljs-built_in">int</span>], <span class="hljs-literal">None</span>]
<span class="hljs-meta">@dataclass(</span><span class="hljs-params">frozen=</span><span class="hljs-literal">True</span><span class="hljs-params">, order=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Task</span><span class="hljs-class">:</span>
    scheduled: <span class="hljs-built_in">int</span>
    callback: Callback = field(compare=<span class="hljs-literal">False</span>)
    delay: <span class="hljs-built_in">int</span> = field(default=<span class="hljs-number">0</span>, compare=<span class="hljs-literal">False</span>)
    limit: <span class="hljs-built_in">int</span> = field(default=<span class="hljs-number">1</span>, compare=<span class="hljs-literal">False</span>)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">repeat</span><span class="hljs-function">(</span><span class="hljs-params">self, current_time: </span><span class="hljs-built_in">int</span><span class="hljs-function">) -&gt; Optional["Task"]:</span>
        <span class="hljs-keyword">if</span> self.delay &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> self.limit &gt; <span class="hljs-number">2</span>:
            <span class="hljs-keyword">return</span> Task(
                current_time + self.delay,
                cast(Callback, self.callback),  <span class="hljs-comment"># type: ignore [misc]</span>
                self.delay,
                self.limit - <span class="hljs-number">1</span>,
            )
        <span class="hljs-keyword">elif</span> self.delay &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> self.limit == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">return</span> Task(
                current_time + self.delay,
                cast(Callback, self.callback),  <span class="hljs-comment"># type: ignore [misc]</span>
            )
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Task</code> class definition has two mandatory fields and two optional fields. The mandatory fields, <code class="Code-In-Text--PACKT-">scheduled</code> and <code class="Code-In-Text--PACKT-">callback</code>, provide a scheduled time to do something and a callback function, the thing to be done at the scheduled time. The scheduled time has an <code class="Code-In-Text--PACKT-">int</code> type hint; the time module can use floating-point time, for super-accurate operations. We're going to ignore these details. Also, the <strong class="" style="font-style: italic;">mypy</strong> tool is <a id="_idIndexMarker562"/>well aware that integers can be coerced to floating-point numbers, so we don't have to be super-fussy-precise about numeric types.</p>
    <p class="normal">The callback has a hint of <code class="Code-In-Text--PACKT-">Callable[[int], None]</code>. This summarizes what the function definition should look like. A callback function definition should look like <code class="Code-In-Text--PACKT-">def some_name(an_arg: int) -&gt; None:</code>. If it doesn't match, <strong class="" style="font-style: italic;">mypy</strong> will alert us to the potential mismatch between our callback function definition and the contract specified by the type hint.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">repeat()</code> method can <a id="_idIndexMarker563"/>return a task for those tasks that might repeat. It computes a new time for the task, provides the reference to the original function object, and may <a id="_idIndexMarker564"/>provide a subsequent delay and a changed limit. The changed limit will count the number of repetitions toward zero, giving us a defined upper limit on processing; it's always nice to be sure that iteration will terminate.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-"># type: ignore [misc]</code> comments are there because there's a feature here that's confusing to <strong class="" style="font-style: italic;">mypy</strong>. When we use code like <code class="Code-In-Text--PACKT-">self.callback</code> or <code class="Code-In-Text--PACKT-">someTask.callback()</code>, it looks like an ordinary method. The code in the <code class="Code-In-Text--PACKT-">Scheduler</code> class is not going to use it as an ordinary method; it will be used as a reference to a separate function defined entirely outside of the class. The assumption wired into Python is this: a <code class="Code-In-Text--PACKT-">Callable</code> attribute must be a method, and that means the method must have a "<code class="Code-In-Text--PACKT-">self</code>" variable. In this case, the callable object is a separate function. The easiest way to refute the assumption is by silencing <strong class="" style="font-style: italic;">mypy</strong>'s checking of this line of code. An alternative is to assign <code class="Code-In-Text--PACKT-">self.callback</code> to another non-<code class="Code-In-Text--PACKT-">self</code> variable to make it look like it's an external function.</p>
    <p class="normal">Here's the overall <code class="Code-In-Text--PACKT-">Scheduler</code> class that uses these <code class="Code-In-Text--PACKT-">Task</code> objects and their associated callback functions:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Scheduler</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.tasks: List[Task] = []
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">enter</span><span class="hljs-function">(</span>
<span class="hljs-params">        self,</span>
<span class="hljs-params">        after: </span><span class="hljs-built_in">int</span><span class="hljs-params">,</span>
<span class="hljs-params">        task: Callback,</span>
<span class="hljs-params">        delay: </span><span class="hljs-built_in">int</span><span class="hljs-params"> = </span><span class="hljs-number">0</span><span class="hljs-params">,</span>
<span class="hljs-params">        limit: </span><span class="hljs-built_in">int</span><span class="hljs-params"> = </span><span class="hljs-number">1</span><span class="hljs-params">,</span>
<span class="hljs-params">    </span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        new_task = Task(after, task, delay, limit)
        heapq.heappush(self.tasks, new_task)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">run</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        current_time = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> self.tasks:
            next_task = heapq.heappop(self.tasks)
            <span class="hljs-keyword">if</span> (delay := next_task.scheduled - current_time) &gt; <span class="hljs-number">0</span>:
               time.sleep(next_task.scheduled - current_time)
            current_time = next_task.scheduled
            next_task.callback(current_time)  <span class="hljs-comment"># type: ignore [misc]</span>
            <span class="hljs-keyword">if</span> again := next_task.repeat(current_time):
                heapq.heappush(self.tasks, again)
</code></pre>
    <p class="normal">The central feature of the <code class="Code-In-Text--PACKT-">Scheduler</code> class is a heap queue, a <code class="Code-In-Text--PACKT-">List</code> of <code class="Code-In-Text--PACKT-">Task</code> objects kept in a specific order. We mentioned the heap queue in the <em class="italic">Three types of queues</em> section of <em class="chapterRef">Chapter 7</em>, <em class="italic">Python Data Structures</em>, noting that the priority ordering made it inappropriate for that use case. Here, however, the heap data structure makes use of the flexibility of a list to <a id="_idIndexMarker565"/>keep items in order without the overhead of a complete sort of the entire list. In this case, we want to keep items in order by the time they're <a id="_idIndexMarker566"/>required to be executed: "first things first" order. When we push something to a heap queue, it's inserted so the time order will be maintained. When we pop the next thing from the queue, the heap may be adjusted to keep the first things at the front of the queue.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Scheduler</code> class provides an <code class="Code-In-Text--PACKT-">enter()</code> method to add a new task to the queue. This method accepts a <code class="Code-In-Text--PACKT-">delay</code> parameter representing the interval to wait before executing the callback task, and the <code class="Code-In-Text--PACKT-">task</code> function itself, a function to be executed at the correct time. This <code class="Code-In-Text--PACKT-">task</code> function should fit the type hint of <code class="Code-In-Text--PACKT-">Callback</code>, defined above.</p>
    <p class="normal">There are no runtime checks to ensure the callback function really does meet the type hint. It's only checked by <strong class="" style="font-style: italic;">mypy</strong>. More importantly, the <code class="Code-In-Text--PACKT-">after</code>, <code class="Code-In-Text--PACKT-">delay</code>, and <code class="Code-In-Text--PACKT-">limit</code> parameters should have some validation checks. For example, a negative value of <code class="Code-In-Text--PACKT-">after</code> or <code class="Code-In-Text--PACKT-">delay</code> should raise a <code class="Code-In-Text--PACKT-">ValueError</code> exception. There's a special method name, <code class="Code-In-Text--PACKT-">__post_init__()</code>, that a dataclass can use for validation. This is invoked after <code class="Code-In-Text--PACKT-">__init__()</code> and can be used for other initialization, pre-computing derived values, or validating that the combination of values is sensible.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">run()</code> method removes items from the queue in order by the time they're supposed to be performed. If we're at (or past) the required time, then the value computed for <code class="Code-In-Text--PACKT-">delay</code> will be zero or negative, and we don't need to wait; we can perform the callback immediately. If we're before the required time, then we need to sleep until the time arrives.</p>
    <p class="normal">At the appointed time, we'll update our current time in the <code class="Code-In-Text--PACKT-">current_time</code> variable. We'll call the callback function provided in the <code class="Code-In-Text--PACKT-">Task</code> object. And then we'll see if the <code class="Code-In-Text--PACKT-">Task</code> object's <code class="Code-In-Text--PACKT-">repeat()</code> method will provide another repeat task into the queue.</p>
    <p class="normal">The important things to <a id="_idIndexMarker567"/>note here are the lines that touch callback functions. The function is passed around like any other object and the <code class="Code-In-Text--PACKT-">Scheduler</code> and <code class="Code-In-Text--PACKT-">Task</code> classes <a id="_idIndexMarker568"/>never know or care what the original name of the function is or where it was defined. When it's time to call the function, the <code class="Code-In-Text--PACKT-">Scheduler</code> simply evaluates the function with <code class="Code-In-Text--PACKT-">new_task.callback(current_time)</code>.</p>
    <p class="normal">Here's a set of callback functions that test the <code class="Code-In-Text--PACKT-">Scheduler</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> datetime
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">format_time</span><span class="hljs-function">(</span><span class="hljs-params">message: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
    now = datetime.datetime.now()
    print(<span class="hljs-string">f"</span><span class="hljs-subst">{now:%I:%M:%S}</span><span class="hljs-string">: </span><span class="hljs-subst">{message}</span><span class="hljs-string">"</span>)
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">one</span><span class="hljs-function">(</span><span class="hljs-params">timer: </span><span class="hljs-built_in">float</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
    format_time(<span class="hljs-string">"Called One"</span>)
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">two</span><span class="hljs-function">(</span><span class="hljs-params">timer: </span><span class="hljs-built_in">float</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
    format_time(<span class="hljs-string">"Called Two"</span>)
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">three</span><span class="hljs-function">(</span><span class="hljs-params">timer: </span><span class="hljs-built_in">float</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
    format_time(<span class="hljs-string">"Called Three"</span>)
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Repeater</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.count = <span class="hljs-number">0</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">four</span><span class="hljs-function">(</span><span class="hljs-params">self, timer: </span><span class="hljs-built_in">float</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.count += <span class="hljs-number">1</span>
        format_time(<span class="hljs-string">f"Called Four: </span><span class="hljs-subst">{self.count}</span><span class="hljs-string">"</span>)
</code></pre>
    <p class="normal">These functions all meet the definition of the <code class="Code-In-Text--PACKT-">Callback</code> type hint, so they'll work nicely. The <code class="Code-In-Text--PACKT-">Repeater</code> class definition has a method, <code class="Code-In-Text--PACKT-">four()</code>, that meets the definition. That means an instance of <code class="Code-In-Text--PACKT-">Repeater</code> can also be used.</p>
    <p class="normal">We've defined a handy utility function, <code class="Code-In-Text--PACKT-">format_time()</code>, to write common messages. It uses the format string <a id="_idIndexMarker569"/>syntax to add the current time to the message. The three small callback functions output the current time and a short message telling us which of the callbacks has been fired.</p>
    <p class="normal">Here's an example of creating a scheduler and loading it up with callback functions:</p>
    <pre class="programlisting code"><code class="hljs-code">s = Scheduler()
s.enter(<span class="hljs-number">1</span>, one)
s.enter(<span class="hljs-number">2</span>, one)
s.enter(<span class="hljs-number">2</span>, two)
s.enter(<span class="hljs-number">4</span>, two)
s.enter(<span class="hljs-number">3</span>, three)
s.enter(<span class="hljs-number">6</span>, three)
repeater = Repeater()
s.enter(<span class="hljs-number">5</span>, repeater.four, delay=<span class="hljs-number">1</span>, limit=<span class="hljs-number">5</span>)
s.run()
</code></pre>
    <p class="normal">This example allows us to see how multiple callbacks interact with the timer.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Repeater</code> class <a id="_idIndexMarker570"/>demonstrates that methods can be used as callbacks too, since they are really functions that happen to be bound to an object. Using a method of an instance of the <code class="Code-In-Text--PACKT-">Repeater</code> class is a function like any other.</p>
    <p class="normal">The output shows that events are run in the expected order:</p>
    <pre class="programlisting con"><code class="hljs-con">01:44:35: Called One
01:44:36: Called Two
01:44:36: Called One
01:44:37: Called Three
01:44:38: Called Two
01:44:39: Called Four: 1
01:44:40: Called Three
01:44:40: Called Four: 2
01:44:41: Called Four: 3
01:44:42: Called Four: 4
01:44:43: Called Four: 5 
</code></pre>
    <p class="normal">Note that some events have the same scheduled run time. Scheduled after 2 seconds, for example, both callback functions <code class="Code-In-Text--PACKT-">one()</code> and <code class="Code-In-Text--PACKT-">two()</code> are defined. They both ran at 01:44:36. There's no rule to decide how to resolve the tie between these two functions. The scheduler's algorithm is to pop an item from the heap queue, execute the callback function, then pop another item from the heap queue; if it has the same execution time, then evaluate the next <a id="_idIndexMarker571"/>callback function. Which of the two callbacks is performed first and which is done second is an implementation detail of the heap queue. If order <a id="_idIndexMarker572"/>matters to your application, you'll need an additional attribute to distinguish among items scheduled at the same time; a priority number is often used for this.</p>
    <p class="normal">Because Python is a dynamic language, the contents of a class are not fixed. There are some more advanced programming techniques available to us. In the next section, we'll look at changing the methods of a class.</p>
    <h2 id="_idParaDest-166" class="title">Using functions to patch a class</h2>
    <p class="normal">One of the things we <a id="_idIndexMarker573"/>noted in the previous example was that <strong class="" style="font-style: italic;">mypy</strong> assumed that the <code class="Code-In-Text--PACKT-">Callable</code> attribute, <code class="Code-In-Text--PACKT-">callback</code>, was a method of the <code class="Code-In-Text--PACKT-">Task</code> class. This leads to a potentially confusing <strong class="" style="font-style: italic;">mypy</strong> error message, <code class="Code-In-Text--PACKT-">Invalid self argument "Task" to attribute function "callback" with type "Callable[[int], None]"</code>. In the previous example, the callable attribute was emphatically not a method.</p>
    <p class="normal">The presence of the confusion means that a callable attribute can be treated as a method of a class. Since we can generally supply extra methods to a class, it means we can patch in additional methods at runtime.</p>
    <p class="normal">Does it mean we <strong class="" style="font-style: italic;">should</strong> do this? It's perhaps a bad idea, except in a very special situation.</p>
    <p class="normal">It is possible to add or change a function to an instantiated object, demonstrated as follows. First we'll define a class, <code class="Code-In-Text--PACKT-">A</code>, with a method, <code class="Code-In-Text--PACKT-">show_something()</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">A</span><span class="hljs-con-class">:</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">show_something</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">"My class is A"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">a_object = A()</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">a_object.show_something()</span>
My class is A
</code></pre>
    <p class="normal">This looks like what we'd expect. We invoke the method on an instance of the class and see the results of the <code class="Code-In-Text--PACKT-">print()</code> function. Now, let's patch this object, replacing the <code class="Code-In-Text--PACKT-">show_something()</code> method:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">patched_show_something</span><span class="hljs-con-function">():</span>
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">"My class is NOT A"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">a_object.show_something = patched_show_something</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">a_object.show_something()</span>
My class is NOT A
</code></pre>
    <p class="normal">We've patched the <a id="_idIndexMarker574"/>object introducing an attribute that's a callable function. When we use <code class="Code-In-Text--PACKT-">a_object.show_something()</code>, the rule is to look in local attributes first, then look in class attributes. Because of this, we've used a callable attribute to create a localized patch to this instance of the <code class="Code-In-Text--PACKT-">A</code> class.</p>
    <p class="normal">We can create another instance of the class, unpatched, and see that it's still using the class-level method:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">b_object = A()</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">b_object.show_something()</span>
My class is A
</code></pre>
    <p class="normal">If we can patch an object, you'd think we can also patch the class. We can. It is possible to replace methods on classes instead of objects. If we change the class, we have to account for the <code class="Code-In-Text--PACKT-">self</code> argument that will be implicitly provided to methods defined in the class. </p>
    <p class="normal">It's very important to note that patching a class will change the method for all instances of that object, even ones that have already been instantiated. Obviously, replacing methods like this can be both dangerous and confusing to maintain. Somebody reading the code will see that a method has been called and look up that method on the original class. But the method on the original class is not the one that was called. Figuring out what really happened can become a tricky, frustrating debugging session.</p>
    <p class="normal">There's a cardinal assumption that needs to underpin everything we write. It's a kind of contract that is essential to understanding how software works:</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">The code people see in a module file must be the code that is running.</p>
    </div>
    <p class="normal">Breaking this assumption will really confuse people. Our previous example showed an instance of class <code class="Code-In-Text--PACKT-">A</code> that had a method named <code class="Code-In-Text--PACKT-">show_something()</code> with behavior clearly different to the definition for class <code class="Code-In-Text--PACKT-">A</code>. That's going to be lead people to distrust your application software.</p>
    <p class="normal">This technique does have its uses though. Often, replacing or adding methods at runtime (called <strong class="keyword">monkey patching</strong>) is used in <a id="_idIndexMarker575"/>automated testing. If testing a client-server application, we may not want to actually connect to the server while testing the client; this may result in <a id="_idIndexMarker576"/>accidental transfers of funds or embarrassing test emails being sent to real people. </p>
    <p class="normal">Instead, we can set up our test code to replace some of the key methods on the object that sends requests to the server so that it only records that the methods have been called. We'll cover this in detail in <em class="chapterRef">Chapter 13</em>, <em class="italic">Testing Object-Oriented Programs</em>. Outside the narrow realm of testing, monkey patching is generally a sign of bad design.</p>
    <p class="normal">This is sometimes justified as part of a bug fix for imported components. If this is done, the patch needs to be clearly flagged so anyone looking at the code knows what bug is being worked around and when the fix can be removed. We call this kind of code <em class="italic">tech debt</em>, because the complication of using a monkey patch is a liability. </p>
    <p class="normal">In the case of our class in this example, a subclass of <code class="Code-In-Text--PACKT-">A</code> with a distinct implementation of <code class="Code-In-Text--PACKT-">show_something()</code> would make things much more clear than a patched method.</p>
    <p class="normal">We can use class definitions to create objects that are usable as if they were functions. This gives us another path toward using small, separate functions to build applications.</p>
    <h2 id="_idParaDest-167" class="title">Callable objects</h2>
    <p class="normal">Just as functions are <a id="_idIndexMarker577"/>objects that can have attributes set on them, it is possible to create an object that can be called as though it were a function. Any object can be made callable by giving it a <code class="Code-In-Text--PACKT-">__call__()</code> method that accepts the required arguments. Let's make our <code class="Code-In-Text--PACKT-">Repeater</code> class, from the timer example, a little easier to use by making it a callable, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Repeater_2</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.count = <span class="hljs-number">0</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__call__</span><span class="hljs-function">(</span><span class="hljs-params">self, timer: </span><span class="hljs-built_in">float</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.count += <span class="hljs-number">1</span>
        format_time(<span class="hljs-string">f"Called Four: </span><span class="hljs-subst">{self.count}</span><span class="hljs-string">"</span>)
</code></pre>
    <p class="normal">This example isn't much different from the earlier class; all we did was change the name of the <code class="Code-In-Text--PACKT-">repeater</code> function to <code class="Code-In-Text--PACKT-">__call__</code> and pass the object itself as a callable. How does this work? We can do the following interactively to see an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Repeater_2</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.count = <span class="hljs-number">0</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__call__</span><span class="hljs-function">(</span><span class="hljs-params">self, timer: </span><span class="hljs-built_in">float</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.count += <span class="hljs-number">1</span>
        format_time(<span class="hljs-string">f"Called Four: </span><span class="hljs-subst">{self.count}</span><span class="hljs-string">"</span>)
rpt = Repeater_2()
</code></pre>
    <p class="normal">At this point, we've created a callable object, <code class="Code-In-Text--PACKT-">rpt()</code>. When we evaluate something like <code class="Code-In-Text--PACKT-">rpt(1)</code>, Python will evaluate <code class="Code-In-Text--PACKT-">rpt.__call__(1)</code> for us because there's a <code class="Code-In-Text--PACKT-">__call__()</code> method defined. It looks like this:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">rpt(</span><span class="hljs-con-number">1</span><span class="python">)</span>
04:50:32: Called Four: 1
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">rpt(</span><span class="hljs-con-number">2</span><span class="python">)</span>
04:50:35: Called Four: 2
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">rpt(</span><span class="hljs-con-number">3</span><span class="python">)</span>
04:50:39: Called Four: 3
</code></pre>
    <p class="normal">Here's an example of <a id="_idIndexMarker578"/>using this variation on the <code class="Code-In-Text--PACKT-">Repeater_2</code> class definition with a <code class="Code-In-Text--PACKT-">Scheduler</code> object:</p>
    <pre class="programlisting code"><code class="hljs-code">s2 = Scheduler()
s2.enter(<span class="hljs-number">5</span>, Repeater_2(), delay=<span class="hljs-number">1</span>, limit=<span class="hljs-number">5</span>)
s2.run()
</code></pre>
    <p class="normal">Note that, when we make the <code class="Code-In-Text--PACKT-">enter()</code> call, we pass as an argument the value <code class="Code-In-Text--PACKT-">Repeater_2()</code>. Those two parentheses are creating a new instance of the class. The instance that is created has the <code class="Code-In-Text--PACKT-">__call__()</code> method, which can be used by the <code class="Code-In-Text--PACKT-">Scheduler</code>. When working with callable objects, it's essential to create an instance of a class; it's the object that's callable, not the class.</p>
    <p class="normal">At this point, we've seen two different kinds of callable objects:</p>
    <ol>
      <li class="numbered">Python's functions, built with the <code class="Code-In-Text--PACKT-">def</code> statement.</li>
      <li class="numbered">Callable objects. These are instances of a class with the <code class="Code-In-Text--PACKT-">__call__()</code> method defined.</li>
    </ol>
    <p class="normal">Generally, the simple <code class="Code-In-Text--PACKT-">def</code> statement is all we need. Callable objects, however, can do something an ordinary function can't do. Our <code class="Code-In-Text--PACKT-">Repeater_2</code> class counts the number of times it was used. An ordinary function is stateless. A callable object can be stateful. This needs to be used with <a id="_idIndexMarker579"/>some care, but some algorithms can have a dramatic performance improvement from saving results in a cache, and a callable object is a great way to save results from a function so they don't need to be recomputed.</p>
    <h1 id="_idParaDest-168" class="title">File I/O</h1>
    <p class="normal">Our examples so far <a id="_idIndexMarker580"/>that have touched the filesystem have operated entirely on text files without much thought as to what is going on under the hood. Operating systems represent files as a sequence of bytes, not text. We'll take a deep dive into the relationship between bytes and text in <em class="chapterRef">Chapter 9</em>, <em class="italic">Strings, Serialization, and File Paths</em>. For now, be aware that reading textual data from a file is a fairly involved process, but Python takes care of most of the work for us behind the scenes.</p>
    <p class="normal">The concept of files has been around since long before anyone coined the term <em class="italic">object-oriented programming</em>. However, Python has wrapped the interface that operating systems provide in a sweet abstraction that allows us to work with file (or file-like, vis-à-vis duck typing) objects.</p>
    <p class="normal">The confusion arises because the operating system file and the Python file object are both, commonly, called "files." It's difficult to be ultra-cautious and wrap each reference to the term <em class="italic">file</em> with appropriate context to distinguish bytes on a disk from the OS libraries for accessing those bytes from the Python file object that wraps the OS libraries.</p>
    <p class="normal">Python's <code class="Code-In-Text--PACKT-">open()</code> built-in function is used to open the OS file and return a Python file object. For reading text from a file, we only need to pass the name of the file into the function. The OS file will be opened for reading, and the bytes will be converted to text using the platform's default encoding.</p>
    <p class="normal">A file "name" can be a name relative to the current working directory. It can also be an absolute name, beginning from the root of the directory tree. A file's name is the tail end of a path to the file from the root of the filesystem. The root in a Linux-based filesystem is "<code class="Code-In-Text--PACKT-">/</code>". In Windows, there's a filesystem on each device, so we use a more complex name like "<code class="Code-In-Text--PACKT-">C:\</code>". While Windows uses <code class="Code-In-Text--PACKT-">\</code> for separating elements of the file path, Python's <code class="Code-In-Text--PACKT-">pathlib</code> uses "<code class="Code-In-Text--PACKT-">/</code>" consistently, converting the string to the OS-specific names when needed.</p>
    <p class="normal">Of course, we don't always want to <em class="italic">read</em> files; often we want to <em class="italic">write</em> data to them! To open a file for writing, we need to pass a <code class="Code-In-Text--PACKT-">mode</code> argument as the second positional argument to <code class="Code-In-Text--PACKT-">open()</code>, with a value of <code class="Code-In-Text--PACKT-">"w"</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">contents = </span><span class="hljs-con-string">"Some file contents\n"</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">file = </span><span class="hljs-con-built_in">open</span><span class="python">(</span><span class="hljs-con-string">"filename.txt"</span><span class="python">, </span><span class="hljs-con-string">"w"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">file.write(contents)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">file.close()</span>
</code></pre>
    <p class="normal">We could also supply the value <code class="Code-In-Text--PACKT-">"a"</code> as a mode argument, to <em class="italic">append</em> to the end of the file, rather than completely overwriting existing file content.</p>
    <p class="normal">These files with built-in wrappers for converting bytes to text are great, but it'd be awfully inconvenient if the file we wanted to open was an image, executable, or other binary file, wouldn't it?</p>
    <p class="normal">To open a binary file, we <a id="_idIndexMarker581"/>modify the mode string to append <code class="Code-In-Text--PACKT-">"b"</code>. So, <code class="Code-In-Text--PACKT-">"wb"</code> would open a file for writing bytes, while <code class="Code-In-Text--PACKT-">"rb"</code> allows us to read them. They will behave like text files, but without the automatic encoding of text to bytes. When we read such a file, it will return <code class="Code-In-Text--PACKT-">bytes</code> objects instead of <code class="Code-In-Text--PACKT-">str</code>, and when we write to it, it will fail if we try to pass a text object.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">These mode strings for controlling how files are opened are rather cryptic and are neither Pythonic nor object-oriented. However, they are consistent with virtually every other programming language out there because they are based on the venerable standard I/O library. File I/O is one of the fundamental jobs an operating system has to handle, and all programming languages have to talk to the operating system using the same system calls.</p>
    </div>
    <p class="normal">Since all files are actually bytes, it's important to be aware that reading text means that the bytes are converted to text characters. Most operating systems use an encoding called UTF-8 to represent the Unicode characters Python uses as bytes. In some cases, other encodings might be used, and we may have to provide an <code class="Code-In-Text--PACKT-">encoding='cp1252'</code> argument value when opening a text file that uses an uncommon encoding.</p>
    <p class="normal">Once a file is opened for reading, we can call any of the <code class="Code-In-Text--PACKT-">read()</code>, <code class="Code-In-Text--PACKT-">readline()</code>, or <code class="Code-In-Text--PACKT-">readlines()</code> methods to get the contents of the file. The <code class="Code-In-Text--PACKT-">read()</code> method returns the entire contents of the file as a <code class="Code-In-Text--PACKT-">str</code> or <code class="Code-In-Text--PACKT-">bytes</code> object, depending on whether there is <code class="Code-In-Text--PACKT-">"b"</code> in the mode. Be careful not to use this method without arguments on huge files. You don't want to find out what happens if you try to load that much data into memory!</p>
    <p class="normal">It is also possible to read a fixed number of bytes from a file; we pass an integer argument to the <code class="Code-In-Text--PACKT-">read()</code> method, describing how many bytes we want to read. The next call to <code class="Code-In-Text--PACKT-">read()</code> will load the next sequence of bytes, and so on. We can do this inside a <code class="Code-In-Text--PACKT-">while</code> statement to read the entire file in manageable chunks.</p>
    <p class="normal">Some file formats define neatly bounded chunks for us. The logging module can transmit log objects as bytes. A process reading those bytes must first read four bytes to determine the size of the log message. The size value defines how many more bytes must be read to gather a single, complete message. </p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">readline()</code> method returns a single line from the file (where each line ends in a newline, a carriage return, or both, depending on the operating system on which the file was created). We can call it repeatedly to get additional lines. The plural <code class="Code-In-Text--PACKT-">readlines()</code> method returns a list of all the lines in the file. Like the <code class="Code-In-Text--PACKT-">read()</code> method, it's not safe to use on very large files. These two methods even work when the file is open in <code class="Code-In-Text--PACKT-">bytes</code> mode, but it only makes sense if we are parsing text-like data that has newlines at reasonable positions. An image or audio file, for example, will not have newline characters in it (unless the newline byte happened to represent a certain pixel or sound), so applying <code class="Code-In-Text--PACKT-">readline()</code> wouldn't make sense.</p>
    <p class="normal">For readability, and to <a id="_idIndexMarker582"/>avoid reading a large file into memory at once, it is often better to use a <code class="Code-In-Text--PACKT-">for</code> statement to consume lines from a file object. For text files, it will read each line, one at a time, and we can process it inside the <code class="Code-In-Text--PACKT-">for</code> statement. For binary files, this will also work, but it's often unlikely that the binary file adheres to text file rules. For binary files, it's better to read fixed-sized chunks of data using the <code class="Code-In-Text--PACKT-">read()</code> method, passing a parameter for the maximum number of bytes to read.</p>
    <p class="normal">Reading a file might look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"big_number.txt"</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">input</span>:
    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>:
        print(line)
</code></pre>
    <p class="normal">Writing to a file is just as easy; the <code class="Code-In-Text--PACKT-">write()</code> method on file objects writes a string (or bytes, for binary data) object to the file. It can be called repeatedly to write multiple strings, one after the other. The <code class="Code-In-Text--PACKT-">writelines()</code> method accepts a sequence of strings and writes each of the iterated values to the file. The <code class="Code-In-Text--PACKT-">writelines()</code> method does <em class="italic">not</em> append a new line after each item in the sequence. It is basically a poorly named convenience function to write the contents of a sequence of strings without having to explicitly iterate over it using a <code class="Code-In-Text--PACKT-">for</code> statement.</p>
    <p class="normal">Writing to a file might look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">results = <span class="hljs-built_in">str</span>(<span class="hljs-number">2</span>**<span class="hljs-number">2048</span>)
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"big_number.txt"</span>, <span class="hljs-string">"w"</span>) <span class="hljs-keyword">as</span> output:
    output.write(<span class="hljs-string">"# A big number\n"</span>)
    output.writelines(
        [
            <span class="hljs-string">f"</span><span class="hljs-subst">{</span><span class="hljs-built_in">len</span><span class="hljs-subst">(results)}</span><span class="hljs-string">\n"</span>,
            <span class="hljs-string">f"</span><span class="hljs-subst">{results}</span><span class="hljs-string">\n"</span>
        ]
    )
</code></pre>
    <p class="normal">The explicit newline characters, <code class="Code-In-Text--PACKT-">\n</code>, are required to create line breaks in the file. Only the <code class="Code-In-Text--PACKT-">print()</code> function adds newlines automatically. Because the <code class="Code-In-Text--PACKT-">open()</code> function is built-in, there are no imports required for simple file input and output operations.</p>
    <p class="normal">Lastly, and we do <a id="_idIndexMarker583"/>mean lastly, we come to the <code class="Code-In-Text--PACKT-">close()</code> method. This method should be called when we are finished reading or writing the file, to ensure any buffered writes are written to the disk, that the file has been properly cleaned up, and that all resources associated with the file are released back to the operating system. It's very important to be explicit and clean up after ourselves, especially in long-running processes like web servers. </p>
    <p class="normal">Each open file is a context manager, usable by the <code class="Code-In-Text--PACKT-">with</code> statement. If we use files like this, the <code class="Code-In-Text--PACKT-">close()</code> happens automatically at the end of the context. We'll look closely at using context managers to control the OS resources in the next section.</p>
    <h2 id="_idParaDest-169" class="title">Placing it in context</h2>
    <p class="normal">The need to close files <a id="_idIndexMarker584"/>when we are finished with them can make our code quite ugly. Because an exception may occur at any time during file I/O, we ought to wrap all calls to a file in a <code class="Code-In-Text--PACKT-">try...finally</code> clause. The file should be closed in the <code class="Code-In-Text--PACKT-">finally</code> clause, regardless of whether I/O was successful. This isn't very Pythonic. Of course, there is a more elegant way to do it.</p>
    <p class="normal">Python's file <a id="_idIndexMarker585"/>objects are also <strong class="keyword">context managers</strong>. By using the <code class="Code-In-Text--PACKT-">with</code> statement, the context management methods ensure that the file is closed, even if an exception is raised. By using the <code class="Code-In-Text--PACKT-">with</code> statement, we no longer have to explicitly manage the closing of the file.</p>
    <p class="normal">Here is what a file-oriented <code class="Code-In-Text--PACKT-">with</code> statement looks like in practice:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">source_path = Path(</span><span class="hljs-con-string">"requirements.txt"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">with</span><span class="python"> source_path.</span><span class="hljs-con-built_in">open</span><span class="python">() </span><span class="hljs-con-keyword">as</span><span class="python"> source_file:</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">for</span><span class="python"> line </span><span class="hljs-con-keyword">in</span><span class="python"> source_file:</span>
<span class="hljs-con-meta">...</span> <span class="python">        print(line, end=</span><span class="hljs-con-string">''</span><span class="python">)</span>
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">open</code> method of a <code class="Code-In-Text--PACKT-">Path</code> object returns a file object, which has <code class="Code-In-Text--PACKT-">__enter__()</code> and <code class="Code-In-Text--PACKT-">__exit__()</code> methods. The returned object is assigned to the variable named <code class="Code-In-Text--PACKT-">source_file</code> by the <code class="Code-In-Text--PACKT-">as</code> clause. We know the file will be closed when the code returns to the outer indentation level, and that this will happen even if an exception is raised. (We'll look at <code class="Code-In-Text--PACKT-">Path</code> objects in more detail in <em class="chapterRef">Chapter 9</em>, <em class="italic">Strings</em>, <em class="italic">Serialization</em>, <em class="italic">and File Paths</em>. For now, we'll use them to open our files.)</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">with</code> statement is used widely, often where startup and cleanup code need to be connected in spite of anything that might go wrong. For example, the <code class="Code-In-Text--PACKT-">urlopen</code> call returns a context object that can be used in a <code class="Code-In-Text--PACKT-">with</code> statement to clean up the socket when we're done. Locks in the <code class="Code-In-Text--PACKT-">threading</code> module can automatically release the lock after the body of the <code class="Code-In-Text--PACKT-">with</code> statement has been executed.</p>
    <p class="normal">Most interestingly, because <a id="_idIndexMarker586"/>any object that has the appropriate special methods can be a context manager, used by the <code class="Code-In-Text--PACKT-">with</code> statement, we can use it in our own frameworks. For example, remember that strings are immutable, but sometimes you need to build a string from multiple parts. For efficiency, this is usually done by storing the component strings in a list and joining them at the end. Let's extend the list class to create a simple context manager that allows us to construct a sequence of characters and automatically convert it to a string upon exit:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">StringJoiner</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">list</span><span class="hljs-con-class">):</span><span class="python"> </span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__enter__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span><span class="python"> </span>
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self </span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__exit__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, exc_type, exc_val, exc_tb</span><span class="hljs-con-function">):</span><span class="python"> </span>
<span class="hljs-con-meta">...</span> <span class="python">        self.result = </span><span class="hljs-con-string">""</span><span class="python">.join(self) </span>
</code></pre>
    <p class="normal">This code adds the two special methods required of a context manager to the <code class="Code-In-Text--PACKT-">list</code> class it inherits from. The <code class="Code-In-Text--PACKT-">__enter__()</code> method performs any required setup code (in this case, there isn't any) and then returns the object that will be assigned to the variable after <code class="Code-In-Text--PACKT-">as</code> in the <code class="Code-In-Text--PACKT-">with</code> statement. Often, as we've done here, this is the context manager object itself. The <code class="Code-In-Text--PACKT-">__exit__()</code> method accepts three arguments. In a normal situation, these are all given a value of <code class="Code-In-Text--PACKT-">None</code>. However, if an exception occurs inside the <code class="Code-In-Text--PACKT-">with</code> block, they will be set to values related to the type, value, and traceback for the exception. This allows the <code class="Code-In-Text--PACKT-">__exit__()</code> method to perform any cleanup code that may be required, even if an exception occurred. In our example, we create a result string by joining the characters in the string, regardless of whether an exception was thrown. In some cases, it may be necessary to do more sophisticated cleanup to respond to the exceptional condition.</p>
    <p class="normal">Formally, the type hints look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List, Optional, Type, Literal
<span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> TracebackType
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">StringJoiner</span><span class="hljs-class">(</span><span class="hljs-params">List[</span><span class="hljs-built_in">str</span><span class="hljs-params">]</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__enter__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; "StringJoiner":</span>
        <span class="hljs-keyword">return</span> self
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__exit__</span><span class="hljs-function">(</span>
<span class="hljs-params">        self,</span>
<span class="hljs-params">        exc_type: Optional[Type[BaseException]],</span>
<span class="hljs-params">        exc_val: Optional[BaseException],</span>
<span class="hljs-params">        exc_tb: Optional[TracebackType],</span>
<span class="hljs-params">    </span><span class="hljs-function">) -&gt; Literal[False]:</span>
        self.result = <span class="hljs-string">""</span>.join(self)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
</code></pre>
    <p class="normal">Note that we've <a id="_idIndexMarker587"/>defined <code class="Code-In-Text--PACKT-">__exit__()</code> to always return <code class="Code-In-Text--PACKT-">False</code>. A return value of <code class="Code-In-Text--PACKT-">False</code> makes sure any exception that is raised in the context will be seen. This is the typical behavior. We can, however, silence the exceptions raised by returning <code class="Code-In-Text--PACKT-">True</code>. This means changing the type hint from <code class="Code-In-Text--PACKT-">Literal[False]</code> to <code class="Code-In-Text--PACKT-">bool</code> and – of course – examining the exception details to see if it should be silenced. We might, for example, check <code class="Code-In-Text--PACKT-">exc_type</code> to see if it is <code class="Code-In-Text--PACKT-">StopIteration</code>, like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> exc_type == StopIteration
</code></pre>
    <p class="normal">This will silence only <code class="Code-In-Text--PACKT-">StopIteration</code> exceptions, and allow all others to propagate outside the context. For a refresher on exceptions, refer back to <em class="chapterRef">Chapter 4</em>, <em class="italic">Expecting the Unexpected</em>.</p>
    <p class="normal">While this is one of the simplest context managers we could write, and its usefulness is dubious, it does work with a <code class="Code-In-Text--PACKT-">with</code> statement. Have a look at it in action:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">with</span><span class="python"> StringJoiner(</span><span class="hljs-con-string">"Hello"</span><span class="python">) </span><span class="hljs-con-keyword">as</span><span class="python"> sj:</span>
<span class="hljs-con-meta">...</span> <span class="python">    sj.append(</span><span class="hljs-con-string">", "</span><span class="python">)</span>
<span class="hljs-con-meta">...</span> <span class="python">    sj.extend(</span><span class="hljs-con-string">"world"</span><span class="python">)</span>
<span class="hljs-con-meta">...</span> <span class="python">    sj.append(</span><span class="hljs-con-string">"!"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sj.result</span>
'Hello, world!'
</code></pre>
    <p class="normal">This code constructs a string by appending and extending an initial list of characters. When the <code class="Code-In-Text--PACKT-">with</code> statement finishes the indented statements of the context, the <code class="Code-In-Text--PACKT-">__exit__()</code> method is called, and the <code class="Code-In-Text--PACKT-">result</code> attribute becomes available on the <code class="Code-In-Text--PACKT-">StringJoiner</code> object, <code class="Code-In-Text--PACKT-">sj</code>. We then print this value to see the resulting string. Note that the <code class="Code-In-Text--PACKT-">__exit__()</code> is always executed, even if there's an exception. The following example raises an exception inside the context, and the final result is still built:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">with</span><span class="python"> StringJoiner(</span><span class="hljs-con-string">"Partial"</span><span class="python">) </span><span class="hljs-con-keyword">as</span><span class="python"> sj:</span>
<span class="hljs-con-meta">...</span> <span class="python">    sj.append(</span><span class="hljs-con-string">" "</span><span class="python">)</span>
<span class="hljs-con-meta">...</span> <span class="python">    sj.extend(</span><span class="hljs-con-string">"Results"</span><span class="python">)</span>
<span class="hljs-con-meta">...</span> <span class="python">    sj.append(</span><span class="hljs-con-built_in">str</span><span class="python">(</span><span class="hljs-con-number">2</span><span class="python"> / </span><span class="hljs-con-number">0</span><span class="python">))</span>
<span class="hljs-con-meta">...</span> <span class="python">    sj.extend(</span><span class="hljs-con-string">"Even If There's an Exception"</span><span class="python">)</span>
Traceback (most recent call last):
  ...
  File "&lt;doctest examples.md[60]&gt;", line 3, in &lt;module&gt;
    sj.append(str(2 / 0))
ZeroDivisionError: division by zero
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sj.result</span>
'Partial Results'
</code></pre>
    <p class="normal">The division by zero <a id="_idIndexMarker588"/>raised an exception. The statement appending this to the <code class="Code-In-Text--PACKT-">sj</code> variable failed, and the remaining statements within the context aren't executed. The context's <code class="Code-In-Text--PACKT-">__exit__()</code> method is executed, with details of the exception. The <code class="Code-In-Text--PACKT-">__exit__()</code> method computed the <code class="Code-In-Text--PACKT-">result</code> attribute, and allowed the exception to propagate. The <code class="Code-In-Text--PACKT-">sj</code> variable has the partial result.</p>
    <p class="normal">We can also build a context manager from a simple function. This relies on a feature of an iterator, something we'll look at deeply in <em class="chapterRef">Chapter 10</em>, <em class="italic">The Iterator Pattern</em>. For now, it's enough to know that the <code class="Code-In-Text--PACKT-">yield</code> statement produces the first result of a sequence of results. Because of the way iterators work in Python, we can write a function that has the <code class="Code-In-Text--PACKT-">__enter__()</code> processing and the <code class="Code-In-Text--PACKT-">__exit__()</code> processing separated by a single <code class="Code-In-Text--PACKT-">yield</code> statement.</p>
    <p class="normal">The example of a string joiner is a stateful context manager, and using a function can cleanly separate the state-changing object from the context manager that makes the state change.</p>
    <p class="normal">Here's a revised "<code class="Code-In-Text--PACKT-">string joiner</code>" object that implements part of the work. It contains the strings and also the final result attribute:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">StringJoiner2</span><span class="hljs-class">(</span><span class="hljs-params">List[</span><span class="hljs-built_in">str</span><span class="hljs-params">]</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, *args: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-built_in">super</span>().__init__(*args)
        self.result = <span class="hljs-string">""</span>.join(self)
</code></pre>
    <p class="normal">Separate from this is a context manager that has some steps for entering the context and exiting it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List, Any, Iterator
<span class="hljs-meta">@contextmanager</span>
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">joiner</span><span class="hljs-function">(</span><span class="hljs-params">*args: Any</span><span class="hljs-function">) -&gt; Iterator[StringJoiner2]:</span>
    string_list = StringJoiner2(*args)
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">yield</span> string_list
    <span class="hljs-keyword">finally</span>:
        string_list.result = <span class="hljs-string">""</span>.join(string_list)
</code></pre>
    <p class="normal">The steps <a id="_idIndexMarker589"/>prior to the <code class="Code-In-Text--PACKT-">yield</code> are performed on entry into the context. The expression in the <code class="Code-In-Text--PACKT-">yield</code> statement is assigned to the <code class="Code-In-Text--PACKT-">as</code> variable in the <code class="Code-In-Text--PACKT-">with</code> statement. When the context finishes normally, the code after the <code class="Code-In-Text--PACKT-">yield</code> is processed. The <code class="Code-In-Text--PACKT-">try:</code> statement's <code class="Code-In-Text--PACKT-">finally:</code> clause will make sure that the final result attribute is always set, irrespective of the presence of an exception. Since the <code class="Code-In-Text--PACKT-">try:</code> statement doesn't explicitly match any exceptions, it doesn't silence anything, and the exception will be visible outside the enclosing <code class="Code-In-Text--PACKT-">with</code> statement. This behaves identically to the <code class="Code-In-Text--PACKT-">StringJoiner</code> examples above; the only change is to replace <code class="Code-In-Text--PACKT-">StringJoiner</code> – a class that is a context manager – with <code class="Code-In-Text--PACKT-">joiner</code>.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">@contextmanager</code> decorator is used to <a id="_idIndexMarker590"/>add some features around this function to make it work like a context manager class definition. This saves us from the overhead of a class that defines both <code class="Code-In-Text--PACKT-">__enter__()</code> and <code class="Code-In-Text--PACKT-">__exit__()</code> methods. In this case, the context management involves so few lines of code that a decorated function seems more appropriate than a longer and more complex-looking class.</p>
    <p class="normal">Context managers can do many things. The reason why we cover them adjacent to simple file operations is because one of the important places we can use context managers is when opening files, databases, or network connections. Any place where external, operating system-managed resources are involved, we need a context manager to be sure that the external resources are properly released no matter what goes wrong in our application programming.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Any time we're working with a file, always wrap the processing in a <code class="Code-In-Text--PACKT-">with</code> statement.</p>
    </div>
    <h1 id="_idParaDest-170" class="title">Case study</h1>
    <p class="normal">While object-oriented programming is helpful for encapsulating features, it's not the only way to create flexible, expressive, and succinct application programs. Functional programming emphasizes functional design and function composition over object-oriented design.</p>
    <p class="normal">In Python, functional design often involves using a few object-oriented techniques. This is one of the beauties of Python: being able to choose an appropriate set of design tools to address the problem effectively.</p>
    <p class="normal">We often depict object-oriented designs with the classes and their various associations. For functional design, we're interested in functions to transform objects. A functional design can follow mathematical practices closely.</p>
    <p class="normal">In this part of the case study, we'll revisit a number of features of the classifier as functions mixed with class definitions. We'll step away from a pure object-oriented view and adopt a hybrid view. In particular, we'll look closely at segregating data into a training set and a testing set.</p>
    <h2 id="_idParaDest-171" class="title">Processing overview</h2>
    <p class="normal">The initial analysis from <em class="chapterRef">Chapter 1</em>, <em class="italic">Object-Oriented Design</em>, identified three distinct processes for <a id="_idIndexMarker591"/>gathering training data, testing the classifier, and actually doing classification. The context diagram looked like this:</p>
    <figure class="mediaobject"><img src="../Images/B17070_08_01.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.1: Context diagram</p>
    <p class="normal">We can think of these as separate functions to build some collections of sample data:</p>
    <ol>
      <li class="numbered" value="1">A function based on the "Provide Training Data" use case would transform source data into two collections of samples, a training set and a testing set. We'd like to avoid placing items in the testing set that are exact matches for items in the training set, creating some constraints on this process. We can think of this as a mapping from a <code class="Code-In-Text--PACKT-">KnownSample</code> to a <code class="Code-In-Text--PACKT-">TestingKnownSample</code> or a <code class="Code-In-Text--PACKT-">TrainingKnownSample</code>.</li>
      <li class="numbered">A function based on the "Set Parameters and Test Classifier" use case would transform a <code class="Code-In-Text--PACKT-">Hyperparameter</code> (the <em class="italic">k</em> value and the distance algorithm) and the testing set of samples into a quality score. We can think of this as a mapping from <code class="Code-In-Text--PACKT-">TestingKnownSample</code> to a correct or incorrect classification, and a reduction to a single value showing the number correct out of the number of tests.</li>
      <li class="numbered">A function based on the "Make Classification Request" use case would transform a <code class="Code-In-Text--PACKT-">Hyperparameter</code> (the <em class="italic">k</em> value and the distance algorithm) and a single sample into a classification result.</li>
    </ol>
    <p class="normal">We'll look at each of these <a id="_idIndexMarker592"/>functions separately. We can build an alternative model for our application using these processing steps to define a functional approach.</p>
    <h2 id="_idParaDest-172" class="title">Splitting the data</h2>
    <p class="normal">In effect, splitting the data into <a id="_idIndexMarker593"/>two subsets can be defined around some filter functions. We'll avoid Python for a moment and focus on the conceptual math to make sure we have the logic completely correct before diving into code. Conceptually, we have a pair of functions, <img src="../Images/B17070_08_002.png" alt="" style="height: 1em;"/> and <img src="../Images/B17070_08_003.png" alt="" style="height: 1em;"/>, that decide if a sample, <img src="../Images/B17070_08_004.png" alt="" style="height: 1em;"/>, is for testing, <em class="italic">e</em>, or training, <em class="italic">r</em>. These functions are used to partition the samples into two subsets. (If testing and training didn't both begin with t, we'd have an easier time finding names. It might help to think about <img src="../Images/B17070_08_005.png" alt="" style="height: 1em;"/> for evaluation and testing, and <img src="../Images/B17070_08_006.png" alt="" style="height: 1em;"/> for running a real classification.)</p>
    <p class="normal">It's simpler if these two functions are exclusive, <img src="../Images/B17070_08_007.png" alt="" style="height: 1em;"/>. (We'll use ¬ instead of the longer <code class="Code-In-Text--PACKT-">not</code>.) If they are proper inverses of each other, this means we only need to define one of the two functions: </p>
    <figure class="mediaobject"><img src="../Images/B17070_08_008.png" alt="" style="height: 2em;"/></figure>
    <figure class="mediaobject"><img src="../Images/B17070_08_009.png" alt="" style="height: 2em;"/></figure>
    <p class="normal">If the above syntax is unfamiliar, it just <a id="_idIndexMarker594"/>means that the training set is all items, <img src="../Images/B17070_08_010.png" alt="" style="height: 0.9em;"/>, from the source data, <em class="italic">S</em>, where <img src="../Images/B17070_08_011.png" alt="" style="height: 1em;"/> is true. The testing set is all the items from the source where <img src="../Images/B17070_08_012.png" alt="" style="height: 1em;"/> is false. This mathematical formalism can help make sure all the cases are properly covered.</p>
    <p class="normal">This concept is a kind of "comprehension" or "builder" for a set of samples. We can translate the mathematical comprehension into a Python list comprehension in a fairly direct way. We'll implement our conceptual function <img src="../Images/B17070_08_013.png" alt="" style="height: 1em;"/> as a Python function, <code class="Code-In-Text--PACKT-">training()</code>. We'll also expose the index value, <em class="italic">i</em>, as a separate parameter to this function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">training</span><span class="hljs-function">(</span><span class="hljs-params">s: Sample, i: </span><span class="hljs-built_in">int</span><span class="hljs-function">) -&gt; bool:</span>
    <span class="hljs-keyword">pass</span>
training_samples = [
    TrainingKnownSample(s) 
    <span class="hljs-keyword">for</span> i, s <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(samples) 
    <span class="hljs-keyword">if</span> training(s, i)]
test_samples = [
    TestingKnownSample(s) 
    <span class="hljs-keyword">for</span> i, s <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(samples) 
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> training(s, i)]
</code></pre>
    <p class="normal">In <em class="chapterRef">Chapter 10</em>, <em class="italic">The Iterator Pattern</em>, we'll dive into this deeply. For now, it's enough to see that the comprehensions have three parts: an expression, a <code class="Code-In-Text--PACKT-">for</code> clause, and an <code class="Code-In-Text--PACKT-">if</code> condition. The <code class="Code-In-Text--PACKT-">for</code> clause provides the values, in effect the <img src="../Images/B17070_08_014.png" alt="" style="height: 1em;"/> portion of the formal statement. The <code class="Code-In-Text--PACKT-">if</code> condition filters the values, in effect the <img src="../Images/B17070_08_015.png" alt="" style="height: 1em;"/> clause. The final expression, <code class="Code-In-Text--PACKT-">s</code>, determines what is accumulated into the resulting list object.</p>
    <p class="normal">We've composed a <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> object as a wrapper around the source <code class="Code-In-Text--PACKT-">KnownSample</code> instances. This leverages the composition-based design from <em class="chapterRef">Chapter 7</em>, <em class="italic">Python Data Structures</em>.</p>
    <p class="normal">We can use the index <a id="_idIndexMarker595"/>value to partition the data. The remainder after division, the modulo, can be used to break data into subsets. The value of <code class="Code-In-Text--PACKT-">i % 5</code>, for example, is a value from 0 to 4. If we use <code class="Code-In-Text--PACKT-">i % 5 == 0</code> as test data, 20% of the values will be selected. When <code class="Code-In-Text--PACKT-">i % 5 != 0</code>, this is the remaining 80% of the data that will be used for training.</p>
    <p class="normal">The following is a list comprehension without the <code class="Code-In-Text--PACKT-">[]</code> wrapper. We've used the <code class="Code-In-Text--PACKT-">list()</code> function to consume items from the generator and build a list: </p>
    <pre class="programlisting code"><code class="hljs-code">test_samples = <span class="hljs-built_in">list</span>(
    TestingKnownSample(s) 
    <span class="hljs-keyword">for</span> i, s <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(samples) 
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> training(s, i))
</code></pre>
    <p class="normal">The processing with <code class="Code-In-Text--PACKT-">[]</code> or <code class="Code-In-Text--PACKT-">list()</code> is the same. Some folks like the clarity of <code class="Code-In-Text--PACKT-">list()</code>, even though it's wordier than <code class="Code-In-Text--PACKT-">[]</code>. If we create our own extension to the list class, it's slightly simpler to find <code class="Code-In-Text--PACKT-">list(...)</code> than to find all the places where <code class="Code-In-Text--PACKT-">[...]</code> is used and separate out the list builders from other uses of <code class="Code-In-Text--PACKT-">[]</code>.</p>
    <h2 id="_idParaDest-173" class="title">Rethinking classification</h2>
    <p class="normal">In <em class="chapterRef">Chapter 2</em>, <em class="italic">Objects in Python</em>, we wrestled with a number of ways of handling the state change that goes with <a id="_idIndexMarker596"/>classification. There are two similar processes, one for <code class="Code-In-Text--PACKT-">KnownSample</code> objects that will be used for testing, and one for <code class="Code-In-Text--PACKT-">UnknownSample</code> objects being classified by users. The process diagrams are simple-looking but conceal an important question.</p>
    <p class="normal">Here's the user's classification of an unknown sample:</p>
    <figure class="mediaobject"><img src="../Images/B17070_08_02.png" alt="Diagram, schematic  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.2: UnknownSample classification process diagram</p>
    <p class="normal">We can borrow this (with a few tiny class changes) and use it for testing. Here's an approach to handling classification for test purposes that parallels the unknown sample process:</p>
    <figure class="mediaobject"><img src="../Images/B17070_08_03.png" alt="Diagram, schematic  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.3: TestingKnownSample classification process diagram</p>
    <p class="normal">Ideally, the same code <a id="_idIndexMarker597"/>can be used in both cases, reducing the overall complexity of the application.</p>
    <p class="normal">As we consider the different alternatives to the process view, this leads to changes in the logical view. Here's a revised view, thinking of these classes as immutable compositions. We've included notes to suggest when these objects are created during application processing. We've highlighted two classes requiring careful consideration:</p>
    <figure class="mediaobject"><img src="../Images/B17070_08_04.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 8.4: Revised logical view</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">TestingKnownSample</code> and the <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> classes have very minor differences. They don't introduce <a id="_idIndexMarker598"/>new attributes or methods. Here are the differences:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">TrainingKnownSample</code> instances are never used for classification.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">TestingKnownSample</code> and <code class="Code-In-Text--PACKT-">UnknownSample</code> instances are used for classification and testing. We'll create a <code class="Code-In-Text--PACKT-">ClassifiedKnownSample</code> object from a <code class="Code-In-Text--PACKT-">TestingKnownSample</code> object by repackaging the <code class="Code-In-Text--PACKT-">KnownSample</code> instance into a new container. This creates a more consistent set of definitions.</li>
    </ul>
    <p class="normal">The idea is that the <code class="Code-In-Text--PACKT-">classifier()</code> method of the <code class="Code-In-Text--PACKT-">Hyperparameter</code> class should work with objects of two classes, summarized by the type hint <code class="Code-In-Text--PACKT-">Union[TestingKnownSample, UnknownSample]</code>. This kind of hint can help us spot application code that uses the classes incorrectly.</p>
    <p class="normal">This diagram seems to <a id="_idIndexMarker599"/>capture the ways in which these objects are used. Having these details available can lead to more detailed type hints that can be used to clarify our intent. </p>
    <h2 id="_idParaDest-174" class="title">The partition() function</h2>
    <p class="normal">We can define multiple versions of the <code class="Code-In-Text--PACKT-">training()</code> function to <a id="_idIndexMarker600"/>divide our data into an 80/20, 75/25, or 67/33 split:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">training_80</span><span class="hljs-function">(</span><span class="hljs-params">s: KnownSample, i: </span><span class="hljs-built_in">int</span><span class="hljs-function">) -&gt; bool:</span>
    <span class="hljs-keyword">return</span> i % <span class="hljs-number">5</span> != <span class="hljs-number">0</span>
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">training_75</span><span class="hljs-function">(</span><span class="hljs-params">s: KnownSample, i: </span><span class="hljs-built_in">int</span><span class="hljs-function">) -&gt; bool:</span>
    <span class="hljs-keyword">return</span> i % <span class="hljs-number">4</span> != <span class="hljs-number">0</span>
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">training_67</span><span class="hljs-function">(</span><span class="hljs-params">s: KnownSample, i: </span><span class="hljs-built_in">int</span><span class="hljs-function">) -&gt; bool:</span>
    <span class="hljs-keyword">return</span> i % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>
</code></pre>
    <p class="normal">Here's a function, <code class="Code-In-Text--PACKT-">partition()</code>, that takes one of the <code class="Code-In-Text--PACKT-">training_xx()</code> functions as an argument. The <code class="Code-In-Text--PACKT-">training_xx()</code> function is applied to a sample to decide if it's training data or not:</p>
    <pre class="programlisting code"><code class="hljs-code">TrainingList = List[TrainingKnownSample]
TestingList = List[TestingKnownSample]
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">partition</span><span class="hljs-function">(</span>
<span class="hljs-params">    samples: Iterable[KnownSample], </span>
<span class="hljs-params">    rule: Callable[[KnownSample, </span><span class="hljs-built_in">int</span><span class="hljs-params">], </span><span class="hljs-built_in">bool</span><span class="hljs-params">]</span>
<span class="hljs-function">) -&gt; Tuple[TrainingList, TestingList]:</span>
    training_samples = [
        TrainingKnownSample(s) 
<span class="hljs-keyword">        for</span> i, s <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(samples) <span class="hljs-keyword">if</span> rule(s, i)
    ]
    test_samples = [
        TestingKnownSample(s) 
        <span class="hljs-keyword">for</span> i, s <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(samples) <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> rule(s, i)
    ]
    <span class="hljs-keyword">return</span> training_samples, test_samples
</code></pre>
    <p class="normal">We've built a "higher-order" function that takes another function as an argument value. This is a very cool feature of functional programming that is an integral part of Python.</p>
    <p class="normal">This <code class="Code-In-Text--PACKT-">partition()</code> function <a id="_idIndexMarker601"/>builds two lists from a source of data and a function. This covers the simple case, where we don't care about introducing values into the <code class="Code-In-Text--PACKT-">testing</code> list that are duplicates of values in the <code class="Code-In-Text--PACKT-">training</code> list.</p>
    <p class="normal">While this is pleasantly succinct and expressive, it has a hidden cost. We'd like to avoid examining the data twice. For the small set of known samples in this particular problem, the processing is not particularly costly. But we may have a generator expression creating the raw data in the first place. Since we can only consume a generator once, we'd like to avoid creating multiple copies of a large set of data.</p>
    <p class="normal">Also, we'd like to avoid assigning test values that happen to be exact matches for training values. This turns into a more complex problem. We'll defer this until <em class="chapterRef">Chapter 10</em>, <em class="italic">The Iterator Pattern</em>.</p>
    <h2 id="_idParaDest-175" class="title">One-pass partitioning</h2>
    <p class="normal">We can create multiple pools of <a id="_idIndexMarker602"/>samples in one pass through the data. There are several approaches; we'll show one that has simpler type hints. Again, this is a function, not a full class definition. The individual sample instances have distinct classes, but this process yields objects of distinct classes, and is a better fit for a functional style.</p>
    <p class="normal">The idea is to create two empty list objects, one for training, the other for testing. We can then assign specific type hints to each list, and leverage <strong class="" style="font-style: italic;">mypy</strong> to be sure we are using the lists appropriately:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">partition_1</span><span class="hljs-function">(</span>
<span class="hljs-params">        samples: Iterable[KnownSample], </span>
<span class="hljs-params">        rule: Callable[[KnownSample, </span><span class="hljs-built_in">int</span><span class="hljs-params">], </span><span class="hljs-built_in">bool</span><span class="hljs-params">]</span>
<span class="hljs-function">) -&gt; Tuple[TrainingList, TestingList]:</span>
    
    training: TrainingList = []
    testing: TestingList = []
    <span class="hljs-keyword">for</span> i, s <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(samples):
        training_use = rule(s, i)
        <span class="hljs-keyword">if</span> training_use:
            training.append(TrainingKnownSample(s))
        <span class="hljs-keyword">else</span>:
            testing.append(TestingKnownSample(s))
    <span class="hljs-keyword">return</span> training, testing
</code></pre>
    <p class="normal">In this <code class="Code-In-Text--PACKT-">partition_1()</code> function, we've used the <code class="Code-In-Text--PACKT-">rule</code> function to determine if the data will be used for training. We expect one of the <code class="Code-In-Text--PACKT-">training_xx()</code> functions defined earlier in this case study to be provided as the argument for the <code class="Code-In-Text--PACKT-">rule</code> parameter.</p>
    <p class="normal">Based on this output, we can create an appropriate class for each sample instance, and then assign the sample to an appropriate list.</p>
    <p class="normal">This example doesn't check for <a id="_idIndexMarker603"/>duplicates between testing samples and training samples. Some data scientists suggest we don't want any test samples that are exact matches for training samples; it biases the testing. We can see where that needed decision can be inserted between when the <code class="Code-In-Text--PACKT-">training_use</code> variable is assigned and when the final appends are done to either list. If <code class="Code-In-Text--PACKT-">training_use</code> is <code class="Code-In-Text--PACKT-">False</code> and the item already exists in the training set, this item, too, must be used for training.</p>
    <p class="normal">We can refactor this algorithm slightly by performing the type conversions later in the process. This lets us create a dictionary of various "pools" of <code class="Code-In-Text--PACKT-">KnownSample</code> objects based on the intended usage. So far, we only have two pools – training, where a <code class="Code-In-Text--PACKT-">training_xx()</code> rule is <code class="Code-In-Text--PACKT-">True</code>, and testing:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict, Counter
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">partition_1p</span><span class="hljs-function">(</span>
<span class="hljs-params">    samples: Iterable[KnownSample], </span>
<span class="hljs-params">    rule: Callable[[KnownSample, </span><span class="hljs-built_in">int</span><span class="hljs-params">], </span><span class="hljs-built_in">bool</span><span class="hljs-params">]</span>
<span class="hljs-function">) -&gt; tuple[TrainingList, TestingList]:</span>
    pools: defaultdict[<span class="hljs-built_in">bool</span>, <span class="hljs-built_in">list</span>[KnownSample]] = defaultdict(<span class="hljs-built_in">list</span>)
    partition = ((rule(s, i), s) <span class="hljs-keyword">for</span> i, s <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(samples))
    <span class="hljs-keyword">for</span> usage_pool, sample <span class="hljs-keyword">in</span> partition:
        pools[usage_pool].append(sample)
    training = [TrainingKnownSample(s) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> pools[<span class="hljs-literal">True</span>]]
    testing = [TestingKnownSample(s) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> pools[<span class="hljs-literal">False</span>]]
    <span class="hljs-keyword">return</span> training, testing
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">defaultdict</code> object, <code class="Code-In-Text--PACKT-">pools</code>, will map Boolean values to <code class="Code-In-Text--PACKT-">List[KnownSample]</code> objects. We provided the <code class="Code-In-Text--PACKT-">list</code> function to set a default value when a key is accessed that did not previously exist. We only anticipate two keys, and this could also have been written as <code class="Code-In-Text--PACKT-">pools: dict[bool, list[KnownSample]] = {True: [], False: []}</code>. </p>
    <p class="normal">The partitioning starts by <a id="_idIndexMarker604"/>creating a generator function to apply the given <code class="Code-In-Text--PACKT-">rule</code> function to each sample. The result is a two-tuple; we could write an explicit type hint of <code class="Code-In-Text--PACKT-">tuple[bool, KnownSample]</code>. This generator expression assigned to the partition <code class="Code-In-Text--PACKT-">variable</code> is lazy, and doesn't compute anything until the values are consumed by the <code class="Code-In-Text--PACKT-">for</code> statement.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">for</code> statement consumes values from the generator, appending each sample to the appropriate pool. When values are consumed, the generator function is evaluated, producing a stream of two-tuples with the pool, a Boolean value, and the <code class="Code-In-Text--PACKT-">KnownSample</code> instance.</p>
    <p class="normal">Once the <code class="Code-In-Text--PACKT-">KnownSample</code> objects have been partitioned, we can wrap them up as instances of the <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> class or the <code class="Code-In-Text--PACKT-">TestingKnownSample</code> class. The type hints seem simpler in this example than in the previous version.</p>
    <p class="normal">This doesn't actually create two copies of the data. References to the <code class="Code-In-Text--PACKT-">KnownSample</code> objects are collected into a dictionary. From these, the two lists of <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> and <code class="Code-In-Text--PACKT-">TestingKnownSample</code> objects are created. Each of the derived objects contains a reference to the original <code class="Code-In-Text--PACKT-">KnownSample</code> object. The structure of the temporary dictionary represents some memory overhead, but overall, we've avoided duplicating data, reducing the memory required by this application.</p>
    <p class="normal">This example suffers from a complication. It's not perfectly clear how to prevent creating test samples that are exact matches for training samples. An additional <code class="Code-In-Text--PACKT-">if</code> statement inside the <code class="Code-In-Text--PACKT-">for</code> statement could check for an item with <code class="Code-In-Text--PACKT-">usage_pool</code> of <code class="Code-In-Text--PACKT-">False</code> (in other words, a testing item) that also existed in <code class="Code-In-Text--PACKT-">pools[True]</code> (in other words, the training items). This is quite a bit of extra complexity.</p>
    <p class="normal">Rather than add the additional steps here, we'll wait for <em class="chapterRef">Chapter 10</em>, <em class="italic">The Iterator Pattern</em>, and revise the algorithm to handle duplicate removal that avoids too many special cases or extra <code class="Code-In-Text--PACKT-">if</code> statements.</p>
    <p class="normal">In the case study for<em class="chapterRef"> Chapter 5</em>, <em class="italic">When to Use Object-Oriented Programming</em>, we used <code class="Code-In-Text--PACKT-">with</code> statements and the <code class="Code-In-Text--PACKT-">csv</code> module to load the raw sample data. In that chapter, we defined a <code class="Code-In-Text--PACKT-">SampleReader</code> class. It's <a id="_idIndexMarker605"/>important to review the older definition with these newer partitioning functions to create an integrated whole that can properly read and partition the source of sample data.</p>
    <h1 id="_idParaDest-176" class="title">Recall</h1>
    <p class="normal">We've touched on a number of ways that object-oriented and functional programming techniques are part of Python:</p>
    <ul>
      <li class="bullet">Python built-in functions provide access to special methods that can be implemented by a wide variety of classes. Almost all classes, most of them utterly unrelated, provide an implementation for <code class="Code-In-Text--PACKT-">__str__( )</code> and <code class="Code-In-Text--PACKT-">__repr__()</code> methods, which can be used by the built-in <code class="Code-In-Text--PACKT-">str()</code> and <code class="Code-In-Text--PACKT-">repr()</code> functions. There are many functions like this where a function is provided to access implementations that cut across class boundaries. </li>
      <li class="bullet">Some object-oriented languages rely on "method overloading" – a single name can have multiple implementations with different combinations of parameters. Python provides an alternative, where one method name can have optional, mandatory, position-only, and keyword-only parameters. This provides tremendous flexibility.</li>
      <li class="bullet">Functions are objects and can be used in ways that other objects are used. We can provide them as argument values; we can return them from functions. A function has attributes, also.</li>
      <li class="bullet">File I/O leads us to look closely at how we interact with external objects. Files are always composed of bytes. Python will convert the bytes to text for us. The most common encoding, UTF-8, is the default, but we can specify other encodings.</li>
      <li class="bullet">Context managers are a way to be sure that the operating system entanglements are correctly cleaned up even when there's an exception raised. The use goes beyond simply handling files and network connections, however. Anywhere we have a clear context where we want consistent processing on entry or exit, we have a place where a context manager can be useful.</li>
    </ul>
    <h1 id="_idParaDest-177" class="title">Exercises</h1>
    <p class="normal">If you haven't encountered <code class="Code-In-Text--PACKT-">with</code> statements and context managers before, I encourage you, as usual, to go through your old code, find all the places where you were opening files, and make sure they are safely closed using the <code class="Code-In-Text--PACKT-">with</code> statement. Look for places to write your own context managers as well. Ugly or repetitive <code class="Code-In-Text--PACKT-">try...finally</code> clauses are a good place to start, but you may find them useful any time you need to do before and/or after tasks in context.</p>
    <p class="normal">You've probably used many of the basic built-in functions before now. We covered several of them, but didn't go into a great deal of detail. Play with <code class="Code-In-Text--PACKT-">enumerate</code>, <code class="Code-In-Text--PACKT-">zip</code>, <code class="Code-In-Text--PACKT-">reversed</code>, <code class="Code-In-Text--PACKT-">any</code>, and <code class="Code-In-Text--PACKT-">all</code> until you know you'll remember to use them when they are the right tool for the job. The <code class="Code-In-Text--PACKT-">enumerate</code> function is especially important because not using it results in some pretty ugly <code class="Code-In-Text--PACKT-">while</code> loops.</p>
    <p class="normal">Also explore some applications that pass functions around as callable objects, as well as using the <code class="Code-In-Text--PACKT-">__call__()</code> method to make your own objects callable. You can get the same effect by attaching attributes to functions or by creating a <code class="Code-In-Text--PACKT-">__call__()</code> method on an object. In which case would you use one syntax, and when would it be more suitable to use the other?</p>
    <p class="normal">The relationship between arguments, keyword arguments, variable arguments, and variable keyword arguments can be a bit confusing. We saw how painfully they can interact when we covered multiple inheritance. Devise some other examples to see how they can work well together, as well as to understand when they don't.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Options</code> example for using <code class="Code-In-Text--PACKT-">**kwargs</code> has a potential problem. The <code class="Code-In-Text--PACKT-">update()</code> method inherited from the <code class="Code-In-Text--PACKT-">dict</code> class will add or replace keys. What if we only want to replace key values? We'd have to write our own version of <code class="Code-In-Text--PACKT-">update()</code> that will update existing keys and raise a <code class="Code-In-Text--PACKT-">ValueError</code> exception when a new key is provided</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">name_or_number()</code> function example has a blatant bug. It is not completely correct. For a number 15, it will not report both "fizz" and "buzz". Fix the <code class="Code-In-Text--PACKT-">name_or_number()</code> function to collect all the names of all the true functions. A good exercise. </p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">name_or_number()</code> function example has two test functions, <code class="Code-In-Text--PACKT-">fizz()</code>, and <code class="Code-In-Text--PACKT-">buzz()</code>. We need an additional function, <code class="Code-In-Text--PACKT-">bazz()</code>, to be true for multiples of seven. Write the function and be sure it works with the <code class="Code-In-Text--PACKT-">name_or_number()</code> function. Be sure that the number 105 is handled correctly.</p>
    <p class="normal">It's helpful to review the previous case studies and combine them into a more complete application. The chapter case studies tend to focus on details, avoiding the overall integration of a more complete application. We've left the integration as work for the reader to allow them to dig more deeply into the design.</p>
    <h1 id="_idParaDest-178" class="title">Summary</h1>
    <p class="normal">We covered a grab bag of topics in this chapter. Each represented an important non-object-oriented feature that is popular in Python. Just because we can use object-oriented principles does not always mean we should!</p>
    <p class="normal">However, we also saw that Python typically implements such features by providing a syntax shortcut to traditional object-oriented syntax. Knowing the object-oriented principles underlying these tools allows us to use them more effectively in our own classes.</p>
    <p class="normal">We discussed a series of built-in functions and file I/O operations. There are a whole bunch of different syntaxes available to us when calling functions with arguments, keyword arguments, and variable argument lists. Context managers are useful for the common pattern of sandwiching a piece of code between two method calls. Even functions are objects, and, conversely, any normal object can be made callable.</p>
    <p class="normal">In the next chapter, we'll learn more about string and file manipulation, and even spend some time with one of the least object-oriented topics in the standard library: regular expressions.</p>
  </div>
</body></html>