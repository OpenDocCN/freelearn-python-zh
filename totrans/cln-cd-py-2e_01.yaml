- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introduction, Code Formatting, and Tools
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言、代码格式化和工具
- en: In this chapter, we will explore the first concepts related to clean code, starting
    with what it is and what it means. The main goal of the chapter is to understand
    that clean code is not just a nice thing to have or a luxury in software projects.
    It's a necessity. Without quality code, the project will face the perils of failing
    due to an accumulation of technical debt (*technical debt* is something we'll
    discuss at length later in the chapter, so don't worry if you haven't heard the
    term before).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨与清洁代码相关的第一个概念，从它是什么以及它的意义开始。本章的主要目标是理解清洁代码不仅仅是一件好事或软件项目中的奢侈品。它是一种必需品。没有高质量的代码，项目将面临因技术债务积累而失败的风险（技术债务是我们将在本章后面详细讨论的内容，所以如果你之前没有听说过这个术语，请不要担心）。
- en: Along the same lines, but going into a bit more detail, are the concepts of
    formatting and documenting the code. These also might sound like superfluous requirements
    or tasks, but again, we will discover that they play a fundamental role in keeping
    the code base maintainable and workable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，但更详细地，是格式化和文档化的概念。这些也可能听起来像是多余的或任务，但再次强调，我们将发现它们在保持代码库可维护和可操作方面起着基本作用。
- en: We will analyze the importance of adopting a good coding guideline for this
    project. Realizing that maintaining the code aligned to a reference is a continuous
    task, we will see how we can get help from automated tools that will ease our
    work. For this reason, we'll discuss how to configure tools that will automatically
    run on the project as part of the build.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分析采用良好的编码指南对这个项目的重要性。意识到维护与参考代码对齐是一个持续的任务，我们将看到如何从自动化工具中获得帮助，这些工具将简化我们的工作。因此，我们将讨论如何配置将在项目构建过程中自动运行的工具。
- en: The goal of this chapter is to have an idea of what clean code is, why it is
    important, why formatting and documenting the code are crucial tasks, and how
    to automate this process. From this, you should acquire a mindset for quickly
    organizing the structure of a new project, aiming for good code quality.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是了解清洁代码是什么，为什么它很重要，为什么格式化和文档化代码是关键任务，以及如何自动化这个过程。从这一点出发，你应该获得一种快速组织新项目结构的心态，目标是良好的代码质量。
- en: 'After reading this chapter, you will have learned the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，你将学习以下内容：
- en: That clean code really means something far more important than formatting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洁代码真正意味着比格式化更重要的东西
- en: That having standard formatting is a key component in a software project for
    the sake of its maintainability
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有标准格式是软件项目维护性的关键组成部分
- en: How to make the code self-documenting by using the features that Python provides
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过使用Python提供的功能使代码自我文档化
- en: How to configure tools to automate static verifications on the code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何配置工具来自动化代码的静态验证
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: We'll start first by understanding what clean code is, and why this is important
    for a software engineering project for it to be successful. In the first two sections,
    we will learn how important it is to maintain good code quality in order to work
    efficiently.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将理解什么是清洁代码，以及为什么这对于软件工程项目的成功至关重要。在前两节中，我们将学习保持良好的代码质量对于高效工作的重要性。
- en: 'Then we''ll discuss some exceptions to these rules: that is, situations in
    which it might even be cost-effective to not refactor our code to pay off all
    its technical debt. After all, we cannot simply expect general rules to apply
    everywhere, as we know there are exceptions. The important bit here is to properly
    understand why we would be willing to make an exception and identify these kinds
    of situations properly. We wouldn''t want to mislead ourselves into thinking something
    shouldn''t be improved when in fact it should.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将讨论这些规则的例外情况：即在某些情况下，甚至可能是有成本效益的，不重构我们的代码以偿还所有技术债务。毕竟，我们不能简单地期望一般规则适用于所有地方，因为我们知道总有例外。这里的关键是要正确理解我们为什么愿意做出例外，并正确识别这些情况。我们不想误导自己认为某些东西不应该改进，而实际上它应该改进。
- en: The meaning of clean code
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清洁代码的意义
- en: There is no sole or strict definition of clean code. Moreover, there is probably
    no way of formally measuring clean code, so you cannot run a tool on a repository
    that will tell you how good, bad, or maintainable that code is. Sure, you can
    run tools such as `checkers`, `linters`, `static analyzers`, and so on, and those
    tools are of much help. They are necessary, but not sufficient. Clean code is
    not something a machine or script can recognize (so far) but rather something
    that we, as professionals, can decide.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁代码并没有一个唯一或严格的定义。此外，可能没有一种正式的方法来衡量清洁代码，因此你无法在存储库上运行一个工具来告诉你代码是好是坏，或者是否易于维护。当然，你可以运行像`checkers`、`linters`、`static
    analyzers`等工具，这些工具非常有帮助。它们是必要的，但并不充分。清洁代码不是机器或脚本可以识别的（到目前为止）的东西，而是一种我们作为专业人士可以决定的东西。
- en: For decades of using the term programming languages, we thought that they were
    meant to communicate our ideas to machines so they can run our programs. We were
    wrong. That's not the truth, but part of the truth. The real meaning of the "language"
    part of "programming languages" is to communicate our ideas to other developers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，我们使用编程语言这个术语，认为它们是用来将我们的想法传达给机器，以便它们可以运行我们的程序的。我们错了。这不是真相，但这是真相的一部分。编程语言中“语言”部分的真正含义是将我们的想法传达给其他开发者。
- en: Here is where the true nature of clean code lies. It depends on other engineers
    to be able to read and maintain the code. Therefore, we, as professionals, are
    the only ones who can judge this. Think about it; as developers, we spend much
    more time reading code than actually writing it. Every time we want to make a
    change or add a new feature, we first have to read all the surroundings of the
    code we have to modify or extend. The language (Python) is what we use to communicate
    among ourselves.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这里揭示了清洁代码的真正本质。它取决于其他工程师能否阅读和维护代码。因此，我们作为专业人士，是唯一能够判断这一点的人。想想看；作为开发者，我们花在阅读代码上的时间比实际编写代码的时间要多得多。每次我们想要进行更改或添加新功能时，我们首先必须阅读我们必须修改或扩展的代码的所有周围环境。语言（Python）是我们用来相互沟通的工具。
- en: So, instead of giving you a definition (or my definition) of clean code, I invite
    you to go through the book, read all about idiomatic Python, see the difference
    between good and bad code, identify traits of good code and good architecture,
    and then come up with your own definition. After reading this book, you will be
    able to judge and analyze code for yourself, and you will have a clearer understanding
    of clean code. You will know what it is and what it means, regardless of any definition
    given to you.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，而不是给你一个清洁代码的定义（或我的定义），我邀请你阅读这本书，了解所有关于惯用Python的知识，看到好代码和坏代码之间的区别，识别好代码和好架构的特征，然后提出你自己的定义。阅读这本书后，你将能够自己判断和分析代码，并且对清洁代码将有更清晰的理解。你将知道它是什么，它意味着什么，无论别人给你什么样的定义。
- en: The importance of having clean code
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清洁代码的重要性
- en: There are a huge number of reasons why clean code is important. Most of them
    revolve around the ideas of maintainability, reducing technical debt, working
    effectively with agile development, and managing a successful project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁代码之所以重要，有很多原因。其中大多数都与可维护性、减少技术债务、有效地与敏捷开发合作以及管理成功项目有关。
- en: The first idea I would like to explore is with regard to agile development and
    continuous delivery. If we want our project to successfully deliver features constantly
    at a steady and predictable pace, then having a good and maintainable code base
    is a must.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要探讨的第一个想法是关于敏捷开发和持续交付。如果我们希望我们的项目能够以稳定和可预测的速度持续不断地交付功能，那么拥有一个良好且易于维护的代码库是必不可少的。
- en: Imagine you are driving a car on a road towards a destination you want to reach
    at a certain point in time. You have to estimate your arrival time so that you
    can tell the person who is waiting for you. If the car works fine, and the road
    is flat and perfect, then I do not see why you would miss your estimation by a
    large margin. However, if the road is in poor condition and you have to step out
    to move rocks out of the way, or avoid cracks, stop to check the engine every
    few kilometers, then it is very unlikely that you will know for sure when you
    are going to arrive (or if you will arrive). I think the analogy is clear; the
    road is the code. If you want to move at a steady, constant, and predictable pace,
    the code needs to be maintainable and readable. If it is not, every time product
    management asks for a new feature, you will have to stop to refactor and fix the
    technical debt.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在驾驶一辆汽车，沿着一条通往你希望在某个时间点到达的目的地的道路行驶。你必须估算你的到达时间，以便你可以告诉等待你的人。如果汽车运行良好，道路平坦完美，那么我看不到你为什么会大大超出你的估计。然而，如果道路状况糟糕，你必须下车移走石头，或者避开裂缝，每隔几公里就停下来检查引擎，那么你很可能无法确切知道你何时会到达（或者你是否能到达）。我认为这个类比很清楚；道路就是代码。如果你想以稳定、恒定和可预测的速度前进，代码就需要是可维护和可读的。如果不是这样，每当产品管理要求添加新功能时，你将不得不停下来重构和修复技术债务。
- en: 'Technical debt refers to the concept of problems in the software as a result
    of a compromise or a bad decision being made. It''s possible to think about technical
    debt in two ways. From the present to the past: what if the problems we are currently
    facing are the result of previously written bad code? And, from the present to
    the future: if we decide to take a shortcut now, instead of investing time in
    a proper solution, what problems are we creating for ourselves further down the
    line?'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务指的是软件中由于妥协或不良决策而产生的问题的概念。我们可以从现在到过去和从现在到未来两种方式来思考技术债务。从现在到过去：如果我们目前面临的问题是由于之前编写的糟糕代码造成的呢？从现在到未来：如果我们现在决定走捷径，而不是投入时间在合适的解决方案上，我们将会为自己在未来的某个时刻创造什么问题？
- en: The word *debt* is a good choice. It's debt because the code will be harder
    to change in the future than it would be to change it now. That incurred cost
    is the interest of the debt. Incurring technical debt means that tomorrow, the
    code will be harder and more expensive to change (it would even be possible to
    measure this) than it is today, and even more expensive the day after, and so
    on.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: “债务”这个词是一个很好的选择。它之所以被称为债务，是因为代码在未来将比现在更难更改。这种产生的成本就是债务的利息。积累技术债务意味着，明天，代码将比今天更难更改，而且成本更高（甚至可以测量这一点），后天成本更高，以此类推。
- en: Every time the team cannot deliver something on time and has to stop to fix
    and refactor the code, it is paying the price of technical debt.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每当团队无法按时交付某个项目，不得不停下来修复和重构代码时，它就是在支付技术债务的代价。
- en: One could even argue that a team that owns a code base with technical debt is
    not doing agile software development. Because, what's the opposite of agile? Rigid.
    If the code is riddled with code smells, then it can't be easily changed, so there's
    no way the team would be able to quickly react to changes in requirements and
    deliver continuously.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以争论说，拥有带有技术债务的代码库的团队并没有在进行敏捷软件开发。因为，敏捷的对立面是什么？僵化。如果代码充满了代码异味，那么它就不容易更改，因此团队无法快速响应需求的变化并持续交付。
- en: The worst thing about technical debt is that it represents a long-term and underlying
    problem. It is not something that raises an alarm. Instead, it is a silent problem,
    scattered across all parts of the project, that one day, at one particular time,
    will wake up and become a show-stopper.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务最糟糕的地方在于，它代表了一个长期和根本的问题。它不是那种会拉响警报的问题。相反，它是一个静默的问题，散布在项目的各个部分，有一天，在某个特定的时间点，会突然爆发，成为拦路虎。
- en: 'In some more alarming cases, "technical debt" is even an understatement, because
    the problem is much worse. In the previous paragraphs, I referred to scenarios
    in which technical debt makes things harder for the team in the future, but what
    if the reality is much more dangerous? Imagine taking a shortcut that leaves the
    code in a fragile position (one simple example could be a mutable default argument
    in a function that causes a memory leak, as we''ll see in later chapters). You
    could deploy your code and it would work fine for quite some time (for as long
    as that defect doesn''t manifest itself). But it''s actually a crash waiting to
    happen: one day, when least expected, a certain condition in the code will be
    met that will cause a runtime problem with the application, like a time-bomb inside
    the code that at a random time goes off.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些更令人担忧的情况下，“技术债务”甚至是一种轻描淡写，因为问题实际上要严重得多。在前面的段落中，我提到了一些场景，在这些场景中，技术债务使得团队在未来面临的问题更加困难，但现实情况是否更加危险呢？想象一下采取捷径，使得代码处于脆弱状态（一个简单的例子可能是在函数中有一个可变的默认参数，这会导致内存泄漏，我们将在后面的章节中看到）。你可以部署你的代码，并且它会在相当长的一段时间内运行良好（只要那个缺陷没有显现出来）。但实际上，这是一个等待发生的崩溃：有一天，在人们最不期待的时候，代码中某个条件将会满足，这将导致应用程序在运行时出现问题，就像代码中的一个定时炸弹，在随机的时间爆炸。
- en: We clearly would like to avoid scenarios like the aforementioned one. Not everything
    can be caught by automated tools, but whenever it's possible, it's a good investment.
    The rest relies on good, thorough code reviews, and good automated testing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然希望避免上述情况。并非所有问题都能被自动化工具捕获，但只要可能，这都是一项良好的投资。其余的则依赖于良好的、彻底的代码审查和良好的自动化测试。
- en: Software is only useful to the degree to which it can be easily changed. Think
    about it. We create software to respond to some needs (whether it is purchasing
    a plane ticket, shopping online, or listening to music, just to name a few examples).
    These requirements are rarely frozen, meaning the software will have to be updated
    as soon as something in the context that led to that software being written in
    the first place changes. If the code can't be changed (and we know reality does
    change), then it's useless. Having a clean code base is an absolute requirement
    for it to be modified, hence the importance of clean code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 软件只有在能够轻松更改的程度上是有效的。想想看。我们创建软件是为了满足某些需求（无论是购买机票、在线购物还是听音乐，仅举几个例子）。这些需求很少冻结，这意味着软件将不得不在导致该软件最初被编写的环境中的任何变化发生时立即更新。如果代码不能更改（我们知道现实是会变化的），那么它就是无用的。拥有一个干净的代码库是修改它的绝对要求，因此干净代码的重要性。
- en: Some exceptions
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些例外情况
- en: 'In the previous section, we explored the critical role a clean code base plays
    in the success of a software project. That said, remember that this is a book
    for practitioners, so a pragmatic reader might rightfully point out that this
    begs the question: "Are there legitimate exceptions to this?"'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了干净的代码库在软件项目成功中的关键作用。话虽如此，请记住，这是一本面向实践者的书，因此一个务实的读者可能会合理地指出，这提出了一个问题：“是否存在合法的例外情况？”
- en: And of course, this wouldn't be a truly pragmatic book if it didn't allow the
    reader to challenge some of its assumptions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果这本书不允许读者对其假设提出挑战，那么它就不是一个真正实用的书籍。
- en: 'Indeed, there are some cases in which you might want to think of relaxing some
    of the constraints of having a pristine code base. What follows is a list (by
    no means exhaustive) of situations that might justify skipping some of the quality
    checks:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，有些情况下，你可能想要考虑放宽一些保持代码库纯净的约束。以下是一个列表（绝非详尽无遗），列出了可能证明跳过一些质量检查的情况：
- en: Hackathons
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑客马拉松
- en: If you're writing a simple script for a one-off task
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在编写一个用于一次性任务的简单脚本
- en: Code competitions
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程竞赛
- en: When developing a proof of concept
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发概念验证时
- en: When developing a prototype (as long as you make sure it's indeed a prototype
    that will be thrown away)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发原型时（只要确保它确实是一个将被丢弃的原型）
- en: When you're working with a legacy project that will be deprecated, and it's
    only in maintenance mode for a fixed, short-lived period of time (and again, provided
    this is assured)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你与一个将被弃用且仅处于固定、短暂维护模式的遗留项目一起工作时（再次强调，只要这是确定的）
- en: In these cases, common sense applies. For example, if you just arrived at a
    project that will be live only for the next few months until it gets decommissioned,
    then it's probably not worth going through all the trouble of fixing all of its
    inherited technical debt, and waiting for it to be archived might be a better
    option.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，常识适用。例如，如果你刚刚加入一个项目，该项目将在未来几个月内上线，然后被退役，那么修复其继承的技术债务并等待其存档可能不是值得所有麻烦的选择。
- en: 'Notice how these examples all have in common that they assume the code can
    afford not being written under good quality standards is also code that we will
    never have to look at again. This is coherent with what was previously exposed
    and can be thought of as the counter-proposal of our original premise: that we
    write clean code because we want to achieve high maintainability. If there''s
    no need to maintain that code, then we can skip the effort of maintaining high-quality
    standards on it.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这些例子都有一个共同点，即它们都假设代码可以不按照良好的质量标准编写，而且我们永远不会再次查看这些代码。这与之前所讨论的内容是一致的，可以被视为我们原始前提的逆命题：我们编写干净的代码是因为我们想要实现高可维护性。如果不需要维护那段代码，那么我们可以跳过在它上面保持高质量标准的努力。
- en: Remember that we write clean code so we can maintain a project. That means to
    be able to modify that code ourselves in the future, or, if we're transitioning
    the ownership of that code to another team in the company, to make this transition
    (and the lives of the future maintainers) easier. That means, that if a project
    is in maintenance mode only, but it's not going to be deprecated, then it might
    still be a good investment to pay off its technical debt. This is because at some
    point (and usually when least expected), there will be a bug that will have to
    be fixed, and it would be beneficial for the code to be as readable as possible.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们编写干净的代码是为了能够维护项目。这意味着能够将来自己修改代码，或者，如果我们正在将代码的所有权转移到公司中的另一个团队，这将使这种过渡（以及未来维护者的生活）变得更加容易。这意味着，如果一个项目只处于维护模式，但不会过时，那么支付其技术债务可能仍然是一个好的投资。这是因为某个时候（通常是在最意想不到的时候），将会有一个需要修复的错误，并且使代码尽可能易于阅读将是有益的。
- en: Code formatting
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码格式化
- en: Is clean code only about formatting and structuring the code? The short answer
    is no.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 干净的代码仅仅是关于格式化和结构化代码吗？简短的回答是否定的。
- en: There are some coding standards like PEP-8 ([https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/))
    that state how the code should be written and formatted. In Python, PEP-8 is the
    most well-known standard, and that document provides guidelines on how we should
    write our programs, in terms of spacing, naming convention, line length, and more.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有些编码标准，如PEP-8([https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/))，规定了代码应该如何编写和格式化。在Python中，PEP-8是最为人所知的标准，该文档提供了关于我们应该如何编写程序的指导，包括间距、命名约定、行长度等方面。
- en: However, clean code is something else that goes far beyond coding standards,
    formatting, linting tools, and other checks regarding the layout of the code.
    Clean code is about achieving quality software and building a system that is robust
    and maintainable. A piece of code or an entire software component can be 100%
    compliant with PEP-8 (or any other guideline) and still not satisfy these requirements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，干净的代码是另外一回事，它远远超出了编码标准、格式化、linting工具和其他关于代码布局的检查。干净的代码是关于实现高质量的软件和构建一个既健壮又易于维护的系统。一段代码或整个软件组件可以100%符合PEP-8（或任何其他指南），但仍不满足这些要求。
- en: Even though formatting is not our main goal, not paying attention to the code
    structure has some perils. For this reason, we will first analyze the problems
    with a bad code structure and how to address them. After that, we will see how
    to configure and use tools for Python projects to automatically check the most
    common problems.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管格式化不是我们的主要目标，但忽视代码结构有一些风险。因此，我们将首先分析糟糕的代码结构的问题以及如何解决这些问题。之后，我们将看到如何配置和使用工具来自动检查Python项目的最常见问题。
- en: To sum this up, we can say that clean code has nothing to do with things like
    PEP-8 or coding styles. It goes way beyond that, and it's something more meaningful
    to the maintainability of the code and the quality of the software. However, as
    we will see, formatting code correctly is important to work efficiently.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们可以这样说，干净的代码与PEP-8或编码风格等事物无关。它远远超出了这些，对代码的可维护性和软件的质量有更深远的意义。然而，正如我们将看到的，正确格式化代码对于高效工作是非常重要的。
- en: Adhering to a coding style guide on your project
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在你的项目中遵循编码风格指南
- en: A coding guideline is a bare minimum a project should have to be considered
    being developed under quality standards. In this section, we will explore the
    reasons behind this. In the following sections, we can start looking at ways to
    enforce this automatically by using tools.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 编码规范是一个项目在被视为符合质量标准开发时应该拥有的最低要求。在本节中，我们将探讨其背后的原因。在接下来的章节中，我们可以开始探讨如何通过使用工具自动执行这些规范。
- en: The first thing that comes to my mind when I try to find good traits in a code
    layout is consistency. I would expect the code to be consistently structured so
    that it is easy to read and follow. If the code is not correct nor consistently
    structured, and everyone on the team is doing things in their own way, then we
    will end up with code that will require extra effort and concentration to be understood.
    It will be error-prone, misleading, and bugs or subtleties might slip through
    easily.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我试图在代码布局中寻找好的特质时，首先想到的是一致性。我期望代码的结构是一致的，这样便于阅读和跟踪。如果代码既不正确也不结构一致，而且团队中的每个人都以自己的方式做事，那么我们最终会得到需要额外努力和集中精力才能理解的代码。这将导致错误，误导，并且错误或细微之处可能会轻易地被忽略。
- en: We want to avoid that. What we want is exactly the opposite of that—code that
    we can read and understand as quickly as possible at a single glance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望避免这种情况。我们想要的正好相反——代码能够让我们一眼就能快速阅读和理解。
- en: If all members of the development team agree on a standardized way of structuring
    the code, the resulting code will look much more familiar. As a result of that,
    you will quickly identify patterns (more about this in a second), and with these
    patterns in mind, it will be much easier to understand things and detect errors.
    For example, when something is amiss, you will notice that, somehow, there is
    something odd in the patterns you are used to seeing, which will catch your attention.
    You will take a closer look, and you will more than likely spot the mistake!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发团队的所有成员都同意一种标准化的代码结构方式，那么生成的代码看起来会更为熟悉。因此，你将很快识别出模式（关于这一点将在下一节中详细介绍），并且有了这些模式在心中，理解事物和检测错误将会容易得多。例如，当某处出现问题时，你会注意到，某种方式下，你习惯看到的模式中有些奇怪，这会吸引你的注意。你会仔细查看，并且很可能发现错误！
- en: As stated in the classical book, *Code Complete*, an interesting analysis of
    this was done in the paper titled *Perceptions in Chess* (1973), where an experiment
    was conducted to identify how different people can understand or memorize different
    chess positions. The experiment was conducted on players of all levels (novices,
    intermediate, and chess masters), and with different chess positions on the board.
    They found out that when the position was random, the novices did as well as the
    chess masters; it was just a memorization exercise that anyone could do at reasonably
    the same level. When the positions followed a logical sequence that might occur
    in a real game (again, consistency, adhering to a pattern), then the chess masters
    performed exceedingly better than the rest.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如经典书籍《代码大全》中所述，在1973年发表的论文《棋局感知》中，对这一点进行了有趣的分析。该实验旨在确定不同的人如何理解或记忆不同的棋局位置。实验针对所有级别的玩家（新手、中级和棋艺大师）以及棋盘上的不同棋局位置进行。他们发现，当位置是随机的，新手的表现和棋艺大师一样好；这仅仅是一个任何人都能在相当相同的水平上完成的记忆练习。当位置遵循可能在真实游戏中出现的逻辑顺序（再次强调，一致性，遵循模式）时，棋艺大师的表现远远优于其他人。
- en: Now imagine this same situation applied to software. We, as the software engineer
    experts in Python, are like the chess masters in the previous example. When the
    code is structured randomly, without following any logic, or adhering to any standard,
    then it would be as difficult for us to spot mistakes as a novice developer. On
    the other hand, if we are used to reading code in a structured fashion, and we
    have learned to get ideas quickly from the code by following patterns, then we
    are at a considerable advantage.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，将同样的情况应用到软件上。我们作为Python软件工程师专家，就像之前例子中的棋艺大师。当代码结构随机，没有遵循任何逻辑，或者不遵循任何标准时，对于我们来说，找出错误就像新手开发者一样困难。另一方面，如果我们习惯于以结构化的方式阅读代码，并且我们已经学会了通过遵循模式快速从代码中获取想法，那么我们就处于相当的优势地位。
- en: In particular, for Python, the sort of coding style you should follow is PEP-8\.
    You can extend it or adopt some of its parts to the particularities of the project
    you are working on (for example, the length of the line, the notes about strings,
    and so on).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是对于Python，你应该遵循的编码风格是PEP-8。你可以根据你正在工作的项目的特定需求扩展它或采用其部分内容（例如，行的长度，关于字符串的注释等）。
- en: If you realize the project you're working on doesn't adhere to any coding standard,
    push for the adoption of PEP-8 in that code base. Ideally, there should be a written
    document for the company or team you're working in that explains the coding standard
    that's expected to be followed. These coding guidelines can be an adaptation of
    PEP-8.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你意识到你正在工作的项目没有遵循任何编码标准，那么推动在该代码库中采用PEP-8。理想情况下，你应该有一个书面文件，解释你所在的公司或团队期望遵循的编码标准。这些编码规范可以是PEP-8的改编。
- en: If you notice there's not an alignment in your team with the code style, and
    there are several discussions about this during code reviews, it's probably a
    good idea to revisit the coding guidelines and invest in automatic verification
    tools.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到你的团队在代码风格上没有一致性，并且在代码审查期间对此进行了多次讨论，那么重新审视编码规范并投资于自动验证工具可能是个不错的想法。
- en: 'In particular, PEP-8 touches on some important points for quality traits that
    you don''t want to miss in your project; some of them are:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是PEP-8涉及了一些对于项目质量特性非常重要的要点，你不想在你的项目中错过；其中一些包括：
- en: '**Searchability**: This refers to the ability to identify tokens in the code
    at a glance; that is, to search in certain files (and in which part of those files)
    for the particular string we are looking for. One key point of PEP-8 is that it
    differentiates the way of writing the assignment of values to variables, from
    the keyword arguments being passed to functions. To see this better, let''s use
    an example. Let''s say we are debugging, and we need to find where the value to
    a parameter named `location` is being passed. We can run the following `grep`
    command, and the result will tell us the file and the line we are looking for:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可搜索性**：这指的是一眼就能识别代码中标记的能力；也就是说，在特定的文件（以及这些文件的哪个部分）中搜索我们正在寻找的特定字符串。PEP-8的一个关键点是它区分了变量赋值和传递给函数的关键字参数的写法。为了更好地说明这一点，让我们用一个例子来说明。假设我们正在调试，需要找到名为`location`的参数值被传递的地方。我们可以运行以下`grep`命令，结果会告诉我们我们正在寻找的文件和行：'
- en: '[PRE0]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we want to know where this variable is being assigned this value, and
    the following command will also give us the information we are looking for:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们想知道这个变量在哪里被赋予这个值，以下命令也会给我们提供我们想要的信息：
- en: '[PRE1]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: PEP-8 establishes the convention that, when passing arguments by keyword to
    a function, we don't use spaces, but we do when we set values to variables. For
    that reason, we can adapt our search criteria (no spaces around the `=` in the
    first example, and one space in the second) and be more efficient in our search.
    That is one of the advantages of following a convention.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: PEP-8确立了这样的惯例，即在向函数传递关键字参数时，我们不使用空格，但在给变量赋值时使用空格。因此，我们可以调整我们的搜索标准（第一个例子中`=`周围没有空格，第二个例子中有一个空格），并在搜索中更加高效。这是遵循惯例的一个优点。
- en: '**Consistency**: If the code has a uniform format, the reading of it will be
    much easier. This is particularly important for onboarding, if you want to welcome
    new developers to your project, or even hire new (and probably less experienced)
    programmers on your team, and they need to become familiar with the code (which
    might even consist of several repositories). It will make their lives much easier
    if the code layout, documentation, naming convention, and such is identical across
    all files they open, in all repositories.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：如果代码格式统一，阅读起来会容易得多。这对于入职尤其重要，如果你希望欢迎新开发者加入你的项目，或者甚至雇佣新的（可能经验较少的）程序员到你的团队，并且他们需要熟悉代码（可能包括多个仓库）。如果所有文件中的代码布局、文档、命名约定等都是相同的，这将使他们的生活变得更加容易。'
- en: '**Better error handling**: One of the suggestions made in PEP-8 is to limit
    the amount of code inside a `try/except` block to the minimum possible. This reduces
    the error surface, in the sense that it reduces the likelihood of accidentally
    swallowing an exception and masking a bug. This is, arguably, perhaps hard to
    enforce by automatic checks, but nonetheless something worth keeping an eye on
    while performing code reviews.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的错误处理**：PEP-8中提出的建议之一是限制`try/except`块内的代码量到尽可能少。这减少了错误面，从某种意义上说，它减少了意外吞下异常并掩盖错误的可能性。这可能是难以通过自动检查执行的，但无论如何，在代码审查时值得注意。'
- en: '**Code quality**: By looking at the code in a structured fashion, you will
    become more proficient at understanding it at a glance (again, like in *Perception
    in Chess*), and you will spot bugs and mistakes more easily. In addition to that,
    tools that check the quality of the code will also hint at potential bugs. Static
    analysis of the code might help to reduce the ratio of bugs per line of code.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码质量**：通过以结构化的方式查看代码，你将更擅长一眼看懂它（再次，就像在《棋艺感知》中一样），并且更容易发现错误和错误。此外，检查代码质量的工具也会提示潜在的错误。代码的静态分析可能有助于降低每行代码的错误率。'
- en: As I mentioned in the introduction, formatting is a necessary part of clean
    code, but it doesn't end there. There are more considerations to take into account,
    such as documenting design decisions in the code and using tools to leverage automatic
    quality checks as much as possible. In the next section, we start with the first
    one.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在引言中提到的，格式化是干净代码的一个必要部分，但这并不结束。还有更多需要考虑的因素，例如在代码中记录设计决策，并尽可能使用工具来利用自动质量检查。在下一节中，我们将从第一个因素开始。
- en: Documentation
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档
- en: This section is about documenting code in Python, from within the code. Good
    code is self-explanatory but is also well-documented. It is a good idea to explain
    what it is supposed to do (not how).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是关于在Python代码内部记录代码。好的代码是自我解释的，但也是良好记录的。解释它应该做什么（而不是如何做）是一个好主意。
- en: 'One important distinction: documenting code is not the same as adding comments
    to it. This section intends to explore docstrings and annotations because they''re
    the tools in Python used to document code. That said, parenthetically, I will
    briefly touch on the subject of code comments, just to establish some points that
    will make a clearer distinction.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的区别：记录代码与向其添加注释不同。本节旨在探讨docstrings和注释，因为它们是Python中用于记录代码的工具。顺便说一句，我将简要地触及代码注释的主题，只是为了确立一些将使区分更清晰的要点。
- en: Code documentation is important in Python, because being dynamically typed,
    it might be easy to get lost in the values of variables or objects across functions
    and methods. For this reason, stating this information will make it easier for
    future readers of the code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，代码文档化很重要，因为它是动态类型的，可能会在函数和方法之间的变量或对象值中迷失方向。因此，声明这些信息将使未来的代码读者更容易理解。
- en: There is another reason that specifically relates to annotations. They can also
    help in running some automatic checks, such as type hinting, through tools such
    as `mypy` ([http://mypy-lang.org/](http://mypy-lang.org/)) or `pytype` ([https://google.github.io/pytype/](https://google.github.io/pytype/)).
    We will find that, in the end, adding annotations pays off.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与注释特别相关的理由是，它们还可以通过像`mypy`([http://mypy-lang.org/](http://mypy-lang.org/))或`pytype`([https://google.github.io/pytype/](https://google.github.io/pytype/))这样的工具运行一些自动检查，例如类型提示。我们会发现，最终，添加注释是值得的。
- en: Code comments
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码注释
- en: As a general rule, we should *aim to have as few code comments as possible*.
    That is because our code should be self-documenting. This means that if we make
    an effort to use the right abstractions (like dividing the responsibilities in
    the code throughout meaningful functions or objects), and we name things clearly,
    then comments shouldn't be needed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条一般规则，我们应该**尽量减少代码注释的数量**。这是因为我们的代码应该是自我文档化的。这意味着如果我们努力使用正确的抽象（比如通过有意义的函数或对象来划分代码中的责任），并且清晰地命名事物，那么注释就不需要了。
- en: Before writing a comment, try to see if you can express the same meaning using
    only code (that is, by adding a new function, or using better variable names).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在写注释之前，试着看看你是否可以用只有代码（即添加一个新函数或使用更好的变量名）来表达相同的意思。
- en: 'The opinion stated in this book about comments agrees pretty much with the
    rest of the literature on software engineering: comments in code are a symptom
    of our inability to express our code correctly.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中关于注释的观点与软件工程文献中的其他观点基本一致：代码中的注释是我们无法正确表达代码的迹象。
- en: However, in some cases, it's impossible to avoid adding a comment in code, and
    not doing so would be dangerous. This is typically the case when something in
    the code must be done for a particular technical nuance that's not trivial at
    first glance (for example, if there's a bug in an underlying external function
    and we need to pass a special parameter to circumvent the issue). In that case,
    our mission is to be as concise as possible and explain in the best possible way
    what the problem is, and why we're taking this specific path in the code so that
    the reader can understand the situation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，避免在代码中添加注释是不可能的，而且不这样做是危险的。这种情况通常发生在代码中必须完成某些特定技术细节，而这些细节乍一看并不简单（例如，如果底层外部函数中有一个错误，我们需要传递一个特殊参数来规避问题）。在这种情况下，我们的任务是尽可能简洁，以最佳方式解释问题是什么，以及为什么我们要采取这种特定的代码路径，以便读者能够理解情况。
- en: 'Lastly, there''s another kind of comment in code that is definitely bad, and
    there''s just no way to justify it: commented out code. This code must be deleted
    mercilessly. Remember that code is a communication language among developers and
    is the ultimate expression of the design. Code is knowledge. Commented out code
    brings chaos (and most likely contradictions) that will pollute that knowledge.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码中还有一种评论是绝对不好的，而且根本无法为其辩护：被注释掉的代码。这种代码必须无情地删除。记住，代码是开发者之间的交流语言，是设计的最终表达。代码是知识。被注释掉的代码会带来混乱（以及很可能是矛盾），这将污染这种知识。
- en: There's just no good reason, especially now, with modern version control systems,
    to leave commented out code that can be simply deleted (or stashed elsewhere).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在根本没有任何合理的理由，尤其是在现代版本控制系统的背景下，留下可以简单地删除（或存放在其他地方的）被注释掉的代码。
- en: 'To sum up: code comments are evil. Sometimes a necessary evil, but nonetheless
    something we should try to avoid as much as possible. Documentation on code, on the
    other hand, is something different. That refers to documenting the design or architecture
    within the code itself, to make it clear, and that''s a positive force (and also
    the topic of the next section, in which we discuss docstrings).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：代码注释是邪恶的。有时是必要的邪恶，但无论如何，我们都应该尽可能地避免。另一方面，代码的文档是另一回事。这指的是在代码本身中记录设计或架构，使其清晰，这是一种积极的动力（也是下一节的主题，我们将讨论文档字符串）。
- en: Docstrings
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档字符串
- en: In simple terms, we can say that docstrings are **documentation** embedded in
    the source code. A **docstring** is basically a literal string, placed somewhere
    in the code to document that part of the logic.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们可以这样说，文档字符串是嵌入在源代码中的**文档**。**文档字符串**基本上是一个字面字符串，放置在代码的某个位置，以记录该部分逻辑。
- en: Notice the emphasis on the word **documentation**. This is important because
    it's meant to represent explanation, not justification. Docstrings are not comments;
    they are documentation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到对单词**文档**的强调。这很重要，因为它旨在代表解释，而不是辩解。文档字符串不是注释；它们是文档。
- en: Docstrings are intended to provide documentation for a particular component
    (a `module`, `class`, `method`, or `function`) in the code that will be useful
    for other developers. The idea is that when other engineers want to use the component
    you're writing, they'll most likely take a look at the docstring to understand
    how it's supposed to work, what the expected inputs and outputs are, and so on.
    For this reason, it is a good practice to add docstrings whenever possible.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串旨在为代码中的特定组件（一个`模块`、`类`、`方法`或`函数`）提供文档，这对其他开发者将是有用的。想法是，当其他工程师想要使用你正在编写的组件时，他们很可能会查看文档字符串，以了解它应该如何工作，预期的输入和输出是什么，等等。因此，在可能的情况下添加文档字符串是一个好习惯。
- en: Docstrings are also useful to document design and architecture decisions. It's
    probably a good idea to add a docstring to the most important Python modules,
    functions, and classes in order to hint to the reader how that component fits
    in the overall architecture.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串也有助于记录设计和架构决策。给最重要的Python模块、函数和类添加文档字符串可能是个好主意，以便向读者暗示该组件如何在整体架构中发挥作用。
- en: The reason they are a good thing to have in code (or maybe even required, depending
    on the standards of your project) is that Python is dynamically typed. This means
    that, for example, a function can take anything as the value for any of its parameters.
    Python will not enforce, nor check, anything like this. So, imagine that you find
    a function in the code that you know you will have to modify. You are even lucky
    enough that the function has a descriptive name, and that its parameters do as
    well. It might still not be quite clear what types you should pass to it. Even
    if this is the case, how are they expected to be used?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在代码中（或者甚至可能根据你项目的标准是必需的）是一个好东西，是因为Python是动态类型的。这意味着，例如，一个函数可以接受任何值作为其任何参数的值。Python不会强制执行，也不会检查这类事情。所以，想象一下，你发现了一个你将不得不修改的函数。你甚至很幸运，这个函数有一个描述性的名称，它的参数也是如此。但它仍然可能不太清楚你应该传递什么类型给它。即使在这种情况下，它们应该如何使用？
- en: Here is where a good docstring might be of help. Documenting the expected input
    and output of a function is a good practice that will help the readers of that
    function understand how it is supposed to work.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是一个好的文档字符串可能有所帮助的地方。记录一个函数的预期输入和输出是一个良好的实践，这将帮助阅读该函数的人理解它应该如何工作。
- en: To run the following code you'll need an `IPython` ([https://ipython.org/](https://ipython.org/))
    interactive shell with the version of Python set according to the requirements
    of this book. If you don't have an `IPython` shell, you can still run the same
    commands in a normal `Python shell`, by replacing the `<function>??` with `help(<function>)`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行以下代码，你需要一个`IPython`([https://ipython.org/](https://ipython.org/))交互式外壳，其Python版本应满足本书的要求。如果你没有`IPython`外壳，你仍然可以在正常的`Python`外壳中运行相同的命令，只需将`<function>??`替换为`help(<function>)`。
- en: 'Consider this good example from the standard library:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个来自标准库的好例子：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, the docstring for the `update` method on dictionaries gives us useful
    information, and it is telling us that we can use it in different ways:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，字典上的`update`方法的文档字符串为我们提供了有用的信息，并且它告诉我们我们可以以不同的方式使用它：
- en: 'We can pass something with a `.keys()` method (for example, another dictionary),
    and it will update the original dictionary with the keys from the object passed
    per parameter:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以传递一个具有`.keys()`方法的对象（例如，另一个字典），并且它将使用通过参数传递的对象的键来更新原始字典：
- en: '[PRE3]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can pass an iterable of pairs of keys and values, and we will unpack them
    to `update`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以传递一个键值对的序列，并将它们解包以更新：
- en: '[PRE4]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It''s also telling us that we can update the dictionary with values taken from
    keyword arguments:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它还告诉我们我们可以使用关键字参数从字典中更新值：
- en: '[PRE5]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: (Note that in this form, the keyword arguments are strings, so we cannot set
    something in the form `5="five"` as it'd be incorrect.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: （注意，在这种情况下，关键字参数是字符串，所以我们不能设置形如`5="five"`的东西，因为这将是错误的。）
- en: This information is crucial for someone who wants to learn and understand how
    a new function works, and how they can take advantage of it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于想要学习和理解新函数的工作方式以及如何利用它的人来说，这些信息至关重要。
- en: Notice that in the first example, we obtained the docstring of the function
    by using the double question mark on it (`dict.update??`). This is a feature of
    the `IPython` interactive interpreter ([https://ipython.org/](https://ipython.org/)).
    When this is called, it will print the docstring of the object you are expecting.
    Now, imagine that in the same way, we obtained help from this function of the
    standard library; how much easier could you make the lives of your readers (the
    users of your code), if you place docstrings on the functions you write so that
    others can understand their workings in the same way?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第一个例子中，我们通过在函数上使用双问号(`dict.update??`)来获取函数的文档字符串。这是`IPython`交互式解释器的一个特性。当调用它时，它将打印出你期望的对象的文档字符串。现在，想象一下，以同样的方式，我们从标准库的这个函数中获取帮助；如果你在你的函数上放置文档字符串，以便其他人可以以相同的方式理解它们的工作方式，你将使你的读者（你的代码的用户）的生活变得多么容易？
- en: 'The docstring is not something separated or isolated from the code. It becomes
    part of the code, and you can access it. When an object has a docstring defined,
    this becomes part of it via its `__doc__` attribute:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串不是与代码分离或孤立的东西。它成为代码的一部分，你可以访问它。当一个对象定义了文档字符串时，它通过其`__doc__`属性成为它的一部分：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This means that it is even possible to access it at runtime and even generate
    or compile documentation from the source code. In fact, there are tools for that.
    If you run `Sphinx`, it will create the basic scaffold for the documentation of
    your project. With the `autodoc` extension (`sphinx.ext.autodoc`) in particular,
    the tool will take the docstrings from the code and place them in the pages that
    document the function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着甚至可以在运行时访问它，甚至可以从源代码生成或编译文档。实际上，有专门的工具来做这件事。如果你运行`Sphinx`，它将为你的项目文档创建基本框架。特别是使用`autodoc`扩展（`sphinx.ext.autodoc`），该工具将从代码中提取文档字符串并将它们放置在记录函数的页面上。
- en: Once you have the tools in place to build the documentation, make it public
    so that it becomes part of the project itself. For open source projects, you can
    use `read the docs` ([https://readthedocs.org/](https://readthedocs.org/)), which
    will generate the documentation automatically per branch or version (configurable).
    For companies or projects, you can have the same tools or configure these services
    on-premise, but regardless of this decision, the important part is that the documentation
    should be ready and available to all members of the team.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了构建文档的工具，就让它公开，这样它就成为项目本身的一部分。对于开源项目，你可以使用`read the docs` ([https://readthedocs.org/](https://readthedocs.org/))，它将根据分支或版本（可配置）自动生成文档。对于公司或项目，你可以使用相同的工具或在本地配置这些服务，但无论这个决定如何，重要的是文档应该准备好并可供团队所有成员使用。
- en: There is, unfortunately, one downside to docstrings, and it is that, as happens
    with all documentation, it requires manual and constant maintenance. As the code
    changes, it will have to be updated. Another problem is that for docstrings to
    be really useful, they have to be detailed, which requires multiple lines. Taking
    into account these two considerations, if the function you're writing is really
    simple, and self-explanatory, it's probably better to avoid adding a redundant
    docstring that will require maintenance later on.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，文档字符串有一个缺点，那就是和所有文档一样，它需要手动和持续的维护。随着代码的变化，它将不得不进行更新。另一个问题是，为了使文档字符串真正有用，它们必须详细，这通常需要多行。考虑到这两个因素，如果你正在编写的函数非常简单，并且是自我解释的，那么最好避免添加冗余的文档字符串，因为这将需要在以后进行维护。
- en: Maintaining proper documentation is a software engineering challenge that we
    cannot escape from. It also makes sense for it to be like this. If you think about
    it, the reason for documentation to be manually written is because it is intended
    to be read by other humans. If it were automated, it would probably not be of
    much use. For the documentation to be of any value, everyone on the team must
    agree that it is something that requires manual intervention, hence the effort
    required. The key is to understand that software is not just about code. The documentation
    that comes with it is also part of the deliverable. Therefore, when someone is
    making a change on a function, it is equally important to also update the corresponding
    part of the documentation to the code that was just changed, regardless of whether
    it's a wiki, a user manual, a `README` file, or several docstrings.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 维护适当的文档是软件工程的一个挑战，我们无法逃避。这也很有道理。如果你这么想，文档需要手动编写的原因是因为它是为了被其他人类阅读。如果它是自动化的，可能就不会有多大用处。为了使文档具有任何价值，团队中的每个人都必须同意这是一项需要手动干预的工作，因此需要付出努力。关键是理解软件不仅仅是代码。与之相关的文档也是交付成果的一部分。因此，当有人对函数进行更改时，同样重要的是也要更新与刚刚更改的代码相对应的文档部分，无论它是维基、用户手册、`README`文件还是几个文档字符串。
- en: Annotations
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: PEP-3107 introduced the concept of annotations. The basic idea of them is to
    hint to the readers of the code about what to expect as values of arguments in
    functions. The use of the word **hint** is not casual; annotations enable type
    hinting, which we will discuss later on in this chapter, after the first introduction
    to annotations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: PEP-3107引入了注释的概念。它们的基本思想是向代码的读者暗示函数中参数的预期值。使用“暗示”这个词并非偶然；注释使类型提示成为可能，我们将在本章稍后讨论这一点，在介绍注释之后。
- en: Annotations let you specify the expected type of some variables that have been
    defined. It is actually not only about the types, but any kind of metadata that
    can help you get a better idea of what that variable actually represents.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注释允许你指定已定义的一些变量的预期类型。实际上，它不仅关于类型，还包括任何可以帮助你更好地理解该变量实际代表的元数据。
- en: 'Consider the following example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we use `float` to indicate the expected types of `latitude` and `longitude`.
    This is merely informative for the reader of the function so that they can get
    an idea of these expected types. Python will not check these types nor enforce
    them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`float`来表示`latitude`和`longitude`的预期类型。这仅仅是对函数读者的信息，使他们能够了解这些预期类型。Python不会检查这些类型也不会强制执行它们。
- en: We can also specify the expected type of the returned value of the function.
    In this case, `Point` is a user-defined class, so it will mean that whatever is
    returned will be an instance of `Point`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定函数返回值的预期类型。在这种情况下，`Point`是一个用户定义的类，这意味着返回的任何内容都将是一个`Point`的实例。
- en: However, types or built-ins are not the only kind of thing we can use as annotations.
    Basically, everything that is valid in the scope of the current Python interpreter
    could be placed there. For example, a string explaining the intention of the variable,
    a callable to be used as a callback or validation function, and so on.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类型或内置类型并不是我们可以用作注释的唯一类型。基本上，在当前Python解释器的范围内有效的一切都可以放在那里。例如，一个解释变量意图的字符串，一个用作回调或验证函数的可调用对象，等等。
- en: 'We can leverage annotations to make our code more expressive. Consider the
    following example for a function that is supposed to launch a task, but that also
    accepts a parameter to defer the execution:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用注释使我们的代码更具表达性。考虑以下示例，这是一个应该启动任务但同时也接受一个参数以延迟执行的函数：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the name of the argument `delay_in_seconds` seems quite verbose, but despite
    that fact, it still doesn't provide much information. What constitutes acceptable
    good values for seconds? Does it consider fractions?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，参数`delay_in_seconds`的名称似乎相当冗长，但尽管如此，它仍然没有提供太多信息。对于秒来说，哪些值是可接受的优良值？它是否考虑了分数？
- en: How about we answer those questions in the code?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否应该在代码中回答这些问题？
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now the code speaks for itself. Moreover, we can argue that with the introduction
    of the `Seconds` annotation, we have created a small abstraction around how we
    interpret time in our code, and we can reuse this abstraction in more parts of
    our code base. If we later decide to change the underlying abstraction for seconds
    (let's say that from now on, only integers are allowed), we can make that change
    in a single place.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码自己说话了。此外，我们可以争论，随着`Seconds`注释的引入，我们已经在如何解释代码中的时间方面创建了一个小的抽象，我们可以在代码库的更多部分重用这个抽象。如果我们后来决定改变秒的底层抽象（比如说，从现在开始，只允许整数），我们可以在一个地方进行这个更改。
- en: 'With the introduction of annotations, a new special attribute is also included,
    and it is `__annotations__`. This will give us access to a dictionary that maps
    the name of the annotations (as keys in the dictionary) with their corresponding
    values, which are those we have defined for them. In our example, this will look
    like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 随着注释的引入，还包含了一个新的特殊属性，即`__annotations__`。这将使我们能够访问一个字典，该字典将注释的名称（作为字典中的键）映射到它们对应的值，即我们为它们定义的值。在我们的例子中，它看起来如下所示：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We could use this to generate documentation, run validations, or enforce checks
    in our code if we think we have to.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们认为有必要，我们可以使用这个来生成文档、运行验证或在我们的代码中执行检查。
- en: 'Speaking of checking the code through annotations, this is when PEP-484 comes
    into play. This PEP specifies the basics of type hinting; the idea of checking
    the types of our functions via annotations. Just to be clear again, and quoting
    PEP-484 itself:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 说到通过注释检查代码，这就是PEP-484发挥作用的时候。这个PEP指定了类型提示的基础；通过注释检查我们函数类型的思想。再次明确一下，并引用PEP-484本身：
- en: '"Python will remain a dynamically typed language, and the authors have no desire
    to ever make type hints mandatory, even by convention."'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “Python将保持动态类型语言，作者们没有意愿将类型提示强制为必须的，即使是按照惯例。”
- en: The idea of type hinting is to have extra tools (independent from the interpreter)
    to check the correct use of types throughout the code and to hint to the user
    if any incompatibilities are detected. There are useful tools that run checks
    around the data types and how they're used in our code, in order to find potential
    problems. Some example tools, such as `mypy` and `pytype`, are explained in more
    detail in the *Tooling section*, where we will talk about using and configuring
    the tools for the project. For now, you can think of it as a sort of linter that
    will check the semantics of the types used in code. For this reason, it is a good
    idea to configure `mypy` or `pytype` on the project and use it at the same level
    as the rest of the tools for static analysis.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示的想法是拥有额外的工具（独立于解释器）来检查代码中类型的正确使用，并在检测到任何不兼容性时向用户提示。有一些有用的工具会在数据类型及其在我们代码中的使用方面进行检查，以找到潜在的问题。例如，`mypy`和`pytype`等工具在*工具部分*中有更详细的解释，我们将讨论如何使用和配置项目中的工具。现在，你可以将其视为一种检查代码中使用的类型语义的linter。因此，在项目中配置`mypy`或`pytype`并将其用于与静态分析工具相同的级别是一个好主意。
- en: 'However, type hinting means more than just a tool for checking the types in
    our code. Following up from our previous example, we can create meaningful names
    and abstractions for types in our code. Consider the following case for a function
    that processes a list of clients. In its simplest form, it can be annotated just
    using a generic list:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类型提示不仅仅是一个检查我们代码中类型的工具。从我们之前的例子中继续，我们可以为我们的代码中的类型创建有意义的名称和抽象。考虑以下一个处理客户列表的函数的例子。在其最简单的形式中，它可以使用一个通用的列表进行注解：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can add a bit more detail if we know that in our current modeling of the
    data, clients are represented as tuples of integers and text:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道在我们的当前数据建模中，客户被表示为整数和文本的元组，我们可以添加更多细节：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But that still doesn''t give us enough information, so it''s better to be explicit
    and have a name for that alias, so we don''t have to infer what that type means:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 但这仍然没有给我们提供足够的信息，所以最好明确地给这个别名起一个名字，这样我们就不必推断这个类型意味着什么：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, the meaning is clearer, and it supports evolving datatypes. Perhaps
    a tuple is the minimal data structure that fits the problem to represent a client
    correctly, but later on, we will want to change it for another object or create
    a specific class. And in this case, the annotation will remain correct, and so
    will all other type verifications.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，含义更清晰，并且它支持数据类型的演变。也许元组是适合正确表示客户的最低数据结构，但后来我们可能希望将其更改为另一个对象或创建一个特定的类。在这种情况下，注释将保持正确，所有其他类型验证也将保持正确。
- en: The basic idea behind this is that now the semantics extend to more meaningful
    concepts, making it even easier for us (humans) to understand what the code means,
    or what is expected at a given point.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这背后的基本思想是，现在语义扩展到更有意义的概念，这使得我们（人类）更容易理解代码的含义，或者在一个特定点期望什么。
- en: 'There is an added benefit that annotations bring. With the introduction of
    PEP-526 and PEP-557, there is a convenient way of writing classes in a compact
    way and defining small container objects. The idea is to just declare attributes
    in a class, and use annotations to set their type, and with the help of the `@dataclass`
    decorator, they will be handled as instance attributes without having to explicitly
    declare it in the `__init__` method and set values to them:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注释还带来了一些额外的优势。随着PEP-526和PEP-557的引入，有一种方便的方式来紧凑地编写类并定义小的容器对象。想法就是只在一个类中声明属性，并使用注释来设置它们的类型，借助`@dataclass`装饰器，它们将被处理为实例属性，而无需在`__init__`方法中显式声明并设置它们的值：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Later in the book, we'll explore other important uses of annotations, more related
    to the design of the code. When we explore good practices for object-oriented
    design, we might want to use concepts like dependency injection, in which we design
    our code to depend on interfaces that declare a contract. And probably the best
    way to declare that code relies on a particular interface is to make use of annotations.
    More to the point, there are tools that specifically make use of Python annotations
    to automatically provide support for dependency injection.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将探讨注释的其他重要用途，这些用途更多地与代码的设计相关。当我们探讨面向对象设计的良好实践时，我们可能希望使用诸如依赖注入等概念，其中我们设计代码以依赖于声明契约的接口。而声明代码依赖于特定接口的最好方法可能是使用注释。更具体地说，有一些工具专门使用Python注释来自动提供对依赖注入的支持。
- en: In design patterns, we usually also want to decouple parts of our code from
    specific implementations and rely on abstract interfaces or contracts, to make
    our code more flexible and extensible. In addition, design patterns usually solve
    problems by creating the proper abstractions needed (which usually means having
    new classes that encapsulate part of the logic). In both these scenarios, annotating
    our code will be of extra help.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计模式中，我们通常还希望将代码的某些部分与特定的实现解耦，并依赖于抽象接口或契约，以使我们的代码更加灵活和可扩展。此外，设计模式通常通过创建所需的适当抽象来解决这些问题（这通常意味着有新的类来封装部分逻辑）。在这两种情况下，注解我们的代码将提供额外的帮助。
- en: Do annotations replace docstrings?
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注解是否取代了文档字符串？
- en: This is a valid question, since in older versions of Python, long before annotations
    were introduced, the way to document the types of the parameters of functions
    or attributes was to put docstrings on them. There are even some conventions for
    formats on how to structure docstrings to include the basic information for a function,
    including types and the meaning of each parameter, the return value, and possible
    exceptions that the function might raise.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个合理的问题，因为在Python的早期版本中，在引入注解之前，记录函数或属性的参数类型的方式是在它们上面放置文档字符串。甚至还有一些关于如何结构化文档字符串的约定，以包括函数的基本信息，包括类型、每个参数的含义、返回值以及函数可能引发的异常。
- en: Most of this has been addressed already in a more compact way by means of annotations,
    so one might wonder if it is really worth having docstrings as well. The answer
    is yes, and this is because they complement each other.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分内容已经通过注解以更紧凑的方式得到了解决，所以有人可能会想知道是否真的有必要同时拥有文档字符串。答案是肯定的，这是因为它们是互补的。
- en: It is true that a part of the information previously contained in the docstring
    can now be moved to the annotations (there's no longer the need to indicate the
    types of the parameters in the docstrings as we can use annotations). But this
    should only leave more room for better documentation on the docstring. In particular,
    for dynamic and nested data types, it is always a good idea to provide examples
    of the expected data so that we can get a better idea of what we are dealing with.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，文档字符串中先前包含的部分信息现在可以移动到注解中（因为我们不再需要在文档字符串中指示参数的类型，因为我们可以使用注解）。但这应该为更好的文档字符串留下更多空间。特别是，对于动态和嵌套数据类型，提供预期数据的示例总是一个好主意，这样我们可以更好地了解我们正在处理的内容。
- en: 'Consider the following example. Let''s say we have a function that expects
    a dictionary to validate some data:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。假设我们有一个期望接收字典以验证某些数据的函数：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we can see a function that takes a dictionary and returns another dictionary.
    Potentially, it could raise an exception if the value under the key `"status"`
    is not the expected one. However, we do not have much more information about it.
    For example, what does a correct instance of a `response` object look like? What
    would an instance of `result` look like? To answer both of these questions, it
    would be a good idea to document examples of the data that is expected to be passed
    in by a parameter and returned by this function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个接收字典并返回另一个字典的函数。如果键“status”下的值不是预期的值，则可能引发异常。然而，我们对此了解不多。例如，一个正确的`response`对象实例看起来是什么样子？`result`对象实例会是什么样子？为了回答这两个问题，记录预期通过参数传递并由该函数返回的数据的示例将是一个好主意。
- en: 'Let''s see if we can explain this better with the help of a docstring:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看是否可以通过文档字符串更好地解释这一点：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we have a better idea of what is expected to be received and returned by
    this function. The documentation serves as valuable input, not only for understanding
    and getting an idea of what is being passed around but also as a valuable source
    for unit tests. We can derive data like this to use as input, and we know what
    would be the correct and incorrect values to use on the tests. Actually, the tests
    also work as actionable documentation for our code, but this will be explained
    in more detail later on in the book.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对这个函数预期接收和返回的内容有了更好的了解。文档不仅有助于理解和获取正在传递的内容的概要，而且也是单元测试的有价值来源。我们可以从这样的数据中推导出输入，并知道在测试中应该使用正确的和错误的值。实际上，测试也充当了我们代码的可操作文档，但这将在本书的后面部分进行更详细的解释。
- en: The benefit is that now we know what the possible values of the keys are, as
    well as their types, and we have a more concrete interpretation of what the data
    looks like. The cost is that, as we mentioned earlier, it takes up a lot of lines,
    and it needs to be verbose and detailed to be effective.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 优点在于，现在我们知道了键的可能值以及它们的类型，并且我们对数据的外观有了更具体的解释。缺点是，正如我们之前提到的，它需要占用很多行，并且需要详细且冗长才能有效。
- en: Tooling
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具
- en: In this section, we will explore how to configure some basic tools and automatically
    run checks on code, with the goal of leveraging part of the repetitive verification
    checks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何配置一些基本工具，并自动对代码进行检查，目标是利用部分重复的验证检查。
- en: 'This is an important point: remember that code is for us, people, to understand,
    so only we can determine what is good or bad code. We should invest time in code
    reviews, thinking about what is good code, and how readable and understandable
    it is. When looking at the code written by a peer, you should ask such questions
    as:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的观点：记住，代码是为了我们，即人类，去理解的，所以只有我们才能判断什么是好代码或坏代码。我们应该在代码审查上投入时间，思考什么是好代码，以及它的可读性和可理解性如何。当查看同事编写的代码时，你应该提出如下问题：
- en: Is this code easy to understand and follow to a fellow programmer?
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码是否容易让其他程序员理解并遵循？
- en: Does it speak in terms of the domain of the problem?
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否使用问题域的术语？
- en: Would a new person joining the team be able to understand it, and work with
    it effectively?
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新加入团队的人能否理解它，并有效地与之合作？
- en: As we saw previously, code formatting, consistent layout, and proper indentation
    are required but not sufficient traits to have in a code base. Moreover, these
    are things that we, as engineers with a high sense of quality, would take for
    granted, so we would read and write code far beyond the basic concepts of its
    layout. Therefore, we are not willing to waste time reviewing these kinds of items,
    so we can invest our time more effectively by looking at actual patterns in the
    code in order to understand its true meaning and provide valuable results.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，代码格式、一致的布局和适当的缩进是必要的，但不足以在代码库中拥有这些特性。此外，这些是我们作为有高度质量意识的工程师会认为理所当然的事情，因此我们会远远超出其布局的基本概念来阅读和编写代码。因此，我们不愿意浪费时间审查这类项目，我们可以通过查看代码中的实际模式来更有效地投入时间，以理解其真正的含义并提供有价值的成果。
- en: All of these checks should be automated. They should be part of the tests or
    checklist, and this, in turn, should be part of the continuous integration build.
    If these checks do not pass, make the build fail. This is the only way to actually
    ensure the continuity of the structure of the code at all times. It also serves
    as an objective parameter for the team to have as a reference. Instead of having
    some engineers or the leader of the team always having to point out the same comments
    about PEP-8 on code reviews, the build will automatically fail, making it something
    objective.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些检查都应该自动化。它们应该是测试或清单的一部分，反过来，这也应该是持续集成构建的一部分。如果这些检查未通过，则构建失败。这是确保代码结构始终连续的唯一方法。它还作为团队参考的客观参数。而不是让一些工程师或团队领导在代码审查中总是指出关于PEP-8的相同评论，构建将自动失败，使其变得客观。
- en: The tools presented in this section will give you an idea of checks you could
    automatically perform on the code. These tools should enforce some standards.
    Generally, they're configurable, and it would be perfectly fine for each repository
    to have its own configuration.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中介绍的工具将给你一个关于可以对代码自动执行检查的想法。这些工具应该强制执行某些标准。通常，它们是可配置的，并且每个仓库都有自己的配置是完全可以接受的。
- en: The idea of using tools is to have a *repeatable* and automatic way of running
    certain checks. That means that every engineer should be able to run the tools
    on their local development environment and reach the same results as any other
    member of the team. And also, that these tools should be configured as part of
    the **Continuous Integration** (**CI**) build.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工具的想法是有一个可重复和自动运行某些检查的方式。这意味着每个工程师都应该能够在他们的本地开发环境中运行这些工具，并得到与团队其他成员相同的结果。此外，这些工具应该作为**持续集成**（**CI**）构建的一部分进行配置。
- en: Checking type consistency
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查类型一致性
- en: Type consistency is one of the main things we would like to check automatically.
    Python is dynamically typed, but we can still add type annotations to hint to
    the readers (and tools) about what to expect in different parts of the code. Even
    though annotations are optional, as we have seen, adding them is a good idea not
    only because it makes the code more readable, but also because we can then use
    annotations along with some tooling to automatically check for some common errors
    that are most likely bugs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 类型一致性是我们希望自动检查的主要事项之一。Python是动态类型的，但我们仍然可以添加类型注解来向读者（和工具）暗示代码不同部分期望的内容。尽管注解是可选的，如我们所见，添加注解是一个好主意，这不仅因为它使代码更易读，而且因为我们可以使用注解和一些工具自动检查一些常见的错误，这些错误很可能是bug。
- en: 'Since type hinting was introduced in Python, many tools for checking type consistency
    have been developed. In this section, we''ll take a look at two of them: `mypy`
    ([https://github.com/python/mypy](https://github.com/python/mypy)), and `pytype`
    ([https://github.com/google/pytype](https://github.com/google/pytype)). There
    are multiple tools, and you might even choose to use a different one, but in general,
    the same principles apply regardless of the specific tool: the important part
    is to have an automatic way of validating changes, and adding these validations
    as part of the CI build. `mypy` is the main tool for optional static type checking
    in Python. The idea is that, once you install it, it will analyze all of the files
    in your project, checking for inconsistencies in the use of types. This is useful
    since, most of the time, it will detect actual bugs early, but sometimes it can
    give false positives.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Python引入类型提示以来，已经开发了众多用于检查类型一致性的工具。在本节中，我们将探讨其中的两个：`mypy` ([https://github.com/python/mypy](https://github.com/python/mypy))
    和 `pytype` ([https://github.com/google/pytype](https://github.com/google/pytype))。虽然有多种工具可供选择，甚至你可能选择使用不同的工具，但通常，无论具体使用哪种工具，原则都是相同的：重要的是要有一个自动验证更改的方法，并将这些验证作为CI构建的一部分。`mypy`是Python中进行可选静态类型检查的主要工具。其理念是，一旦安装，它将分析项目中的所有文件，检查类型使用中的不一致性。这很有用，因为大多数时候，它会在早期发现实际的错误，但有时它可能会给出误报。
- en: 'You can install it with `pip`, and it is recommended to include it as a dependency
    for the project on the setup file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`pip`来安装它，并建议在设置文件中将它包括为项目的依赖项：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once it is installed in the virtual environment, you just have to run the preceding
    command and it will report all of the findings on the type checks. Try to adhere
    to its report as much as possible, because most of the time, the insights provided
    by it help to avoid errors that might otherwise slip into production. However,
    the tool is not perfect, so if you think it is reporting a false positive, you
    can ignore that line with the following marker as a comment:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在虚拟环境中安装，你只需运行前面的命令，它就会报告类型检查的所有发现。尽可能遵循其报告，因为大多数时候，它提供的见解有助于避免可能否则会进入生产的错误。然而，这个工具并不完美，所以如果你认为它报告了误报，你可以用以下标记作为注释来忽略该行：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It's important to note that for this or any tool to be useful, we have to be
    careful with the type annotations we declare in the code. If we're too generic
    with the types set, we might miss some cases in which the tool could report legitimate
    problems.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，为了使这个或任何工具变得有用，我们必须在代码中声明的类型注解上小心谨慎。如果我们对类型设置过于泛化，我们可能会错过工具可能报告的合法问题。
- en: 'In the following example, there''s a function that is intended to receive a
    parameter to be iterated over. Originally, any iterable would work, so we want
    to take advantage of Python''s dynamic typing capabilities and allow a function
    that can use passing lists, tuples, keys of dictionaries, sets, or pretty much
    anything that supports a `for` loop:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，有一个旨在接收要迭代的参数的函数。最初，任何可迭代的对象都可以工作，因此我们想利用Python的动态类型能力，允许函数使用传递列表、元组、字典键、集合或几乎任何支持`for`循环的对象：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The problem is that if some part of the code passes these parameters by mistake,
    `mypy` won''t report an error:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，如果代码的某些部分错误地传递了这些参数，`mypy`不会报告错误：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And of course, this is not a valid instance because it will iterate every character
    in the string, and try to use it as an email.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是一个有效的实例，因为它会迭代字符串中的每个字符，并尝试将其用作电子邮件。
- en: 'If instead, we''re more restrictive with the types set for that parameter (let''s
    say to accept only lists or tuples of strings), then running `mypy` does identify
    this erroneous scenario:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对该参数设置的类型更加严格（比如说只接受字符串的列表或元组），那么运行 `mypy` 就会识别出这种错误场景：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similarly, `pytype` is also configurable and works in a similar fashion, so
    you can adapt both tools to the specific context of your project. We can see how
    the error reported by this tool is very similar to the previous case:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`pytype` 也是可配置的，并且以类似的方式工作，因此你可以根据项目的具体上下文调整这两个工具。我们可以看到这个工具报告的错误与之前的情况非常相似：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: One key difference that `pytype` has though, is that it won't just check the
    definitions against the arguments, but try to interpret if the code at runtime
    will be correct, and report on what would be runtime errors. For example, if one
    of the type definitions is temporarily violated, this won't be considered an issue
    as long as the end result complies with the type that was declared. While this
    is a nice trait, in general, I would recommend that you try not to break the invariants
    you set in the code, and avoid intermediate invalid states as much as possible
    because that will make your code easier to reason about and rely on fewer side-effects.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`pytype` 有一个关键的区别，那就是它不仅会检查定义与参数之间的匹配，还会尝试解释代码在运行时是否正确，并报告可能出现的运行时错误。例如，如果一个类型定义暂时被违反，只要最终结果符合声明的类型，这就不会被视为问题。虽然这是一个很好的特性，但一般来说，我建议你尽量不要破坏代码中设置的不可变特性，并尽可能避免中间无效状态，因为这会使你的代码更容易推理和依赖，并且副作用更少。
- en: Generic validations in code
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码中的通用验证
- en: Besides using tools like the ones introduced in the previous section, to check
    for errors on the type management of our program, we can use other tools that
    will provide validations against a wider range of parameters.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用上一节中介绍的工具来检查程序中类型管理上的错误外，我们还可以使用其他工具，这些工具将对更广泛的参数提供验证。
- en: There are many tools for checking the structure of code (basically, this is
    compliance with PEP-8) in Python, such as `pycodestyle` (formerly known as `pep8`
    in `PyPi`), `flake8`, and many more. They are all configurable and are as easy
    to use as running the command they provide.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中有许多用于检查代码结构的工具（基本上，这是符合 PEP-8 规范），例如 `pycodestyle`（在 `PyPi` 中曾被称为
    `pep8`），`flake8` 以及更多。它们都是可配置的，并且使用起来与运行它们提供的命令一样简单。
- en: These tools are programs that run over a set of Python files, and check the
    compliance of the code against the PEP-8 standard, reporting every line that is in violation
    and the indicative error of the rule that got broken.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具是运行在一系列 Python 文件上的程序，检查代码是否符合 PEP-8 标准，并报告每行违反规则的情况以及相应的错误提示。
- en: There are other tools that provide more complete checks so that instead of just
    validating the compliance with PEP-8, they also include extra checks for more
    complicated situations that exceed PEP-8 (remember, code can still be utterly
    compliant with PEP-8 and still not be of good quality).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他工具提供更全面的检查，这样它们不仅验证代码是否符合 PEP-8，还包括对超出 PEP-8 的更复杂情况的额外检查（记住，代码仍然可以完全符合 PEP-8，但质量并不好）。
- en: For example, PEP-8 is mostly about styling and structuring our code, but it
    doesn't enforce us to put a docstring on every `public method`, `class`, or `module`.
    It also doesn't say anything about a function that takes too many parameters (something
    we'll identify as a bad trait later on in the book).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，PEP-8 主要关于代码的样式和结构，但它并不强制我们为每个 `public method`、`class` 或 `module` 添加文档字符串。它也没有提到函数参数过多的问题（我们将在本书后面的章节中将这个问题识别为不良特性）。
- en: 'One example of such a tool is `pylint`. This is one of the most complete and
    strict tools there is to validate Python projects, and it''s also configurable.
    As before, to use it, you just have to install it in the virtual environment with
    `pip`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具的一个例子是 `pylint`。这是目前最完整和最严格的用于验证 Python 项目的工具之一，它也是可配置的。和之前一样，要使用它，你只需在虚拟环境中使用
    `pip` 安装即可：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then, just running the `pylint` command would be enough to check it in the code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需运行 `pylint` 命令就足以在代码中检查它。
- en: 'It is possible to configure `pylint` via a configuration file named `pylintrc`.
    In this file, you can decide the rules you would like to enable or disable, and
    parametrize others (for example, to change the maximum length of the column).
    For example, as we have just discussed, we might not want every single function
    to have a docstring, as forcing this might be counterproductive. However, by default,
    `pylint` will impose this restriction, but we can overrule it in the configuration
    file by declaring it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过名为`pylintrc`的配置文件来配置`pylint`。在这个文件中，你可以决定你想启用或禁用的规则，并参数化其他规则（例如，更改列的最大长度）。例如，正如我们刚才讨论的，我们可能不希望每个函数都有文档字符串，因为强制这样做可能适得其反。然而，默认情况下，`pylint`将强制执行此限制，但我们可以通过在配置文件中声明来覆盖它：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once this configuration file has reached a stable state (meaning that it is
    aligned with the coding guidelines and doesn't require much further tuning), then
    it can be copied to the rest of the repositories, where it should also be under
    version control.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个配置文件达到了稳定状态（意味着它与编码指南保持一致，不需要进行太多进一步的调整），然后它可以复制到其他存储库，那里也应该受到版本控制。
- en: Document the coding standards agreed by the development team, and then enforce
    them in configuration files for the tools that will run automatically in the repository.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 记录开发团队同意的编码标准，并在配置文件中强制执行，这些配置文件将用于在存储库中自动运行的工具。
- en: 'Finally, there''s another tool I would like to mention, and that is `Coala`
    ([https://github.com/coala/coala](https://github.com/coala/coala)). `Coala` is
    a bit more generic (meaning it supports multiple languages, not just Python),
    but the idea is similar to the one before: it takes a configuration file, and
    then it presents a command-line tool that will run some checks on the code. When
    running, if the tool detects some errors while scanning the files, it might prompt
    the user about them, and it will suggest automatically applying a fixing patch,
    when applicable.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想提到另一个工具，那就是`Coala` ([https://github.com/coala/coala](https://github.com/coala/coala))。`Coala`更通用一些（这意味着它支持多种语言，而不仅仅是Python），但想法与之前类似：它接受一个配置文件，然后提供一个命令行工具，该工具将对代码执行一些检查。在运行时，如果工具在扫描文件时检测到一些错误，它可能会提示用户，如果适用，它还会建议自动应用修复补丁。
- en: But what if I have a use case that's not covered by the default rules of the
    tools? Both `pylint` and `Coala` come with lots of predefined rules that cover
    the most common scenarios, but you might still detect in your organization some
    pattern that it was found to led to errors.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我的用例没有被工具的默认规则覆盖怎么办？`pylint`和`Coala`都附带了许多预定义的规则，涵盖了最常见的场景，但你可能还在你的组织中检测到一些导致错误的模式。
- en: 'If you detect a recurrent pattern in the code that is error-prone, I suggest
    investing some time in defining your own rules. Both these tools are extensible:
    in the case of `pylint`, there are multiple plugins available, and you can write
    your own. In the case of `Coala`, you can write your own validation modules to
    run right alongside the regular checks.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检测到代码中反复出现的、容易出错的模式，我建议花些时间来定义你自己的规则。这两个工具都是可扩展的：在`pylint`的情况下，有多个插件可用，你可以编写自己的。在`Coala`的情况下，你可以编写自己的验证模块，以便与常规检查并行运行。
- en: Automatic formatting
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动格式化
- en: As mentioned at the beginning of the chapter, it would be wise for the team
    to agree on a writing convention for the code, to avoid discussing personal preferences
    on pull requests, and focus on the essence of the code. But the agreement would
    only get you so far, and if these rules aren't enforced, they'll get lost over
    time.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，团队就代码的编写约定达成一致是明智的，以避免在拉取请求中讨论个人偏好，并专注于代码的本质。但协议只能带你走这么远，如果这些规则不得到执行，它们会随着时间的推移而丢失。
- en: Besides just checking for adherence to standards by means of tooling, it would
    be useful to automatically format the code directly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过工具检查代码是否符合标准之外，自动直接格式化代码也会很有用。
- en: 'There are multiple tools that automatically format Python code (for example,
    most of the tools that validate PEP-8, like `flake8`, also have a mode to rewrite
    the code and make it PEP-8 compliant), and they''re also configurable and adaptable
    to each specific project. Among those, and perhaps because of just the opposite
    of full flexibility and configuration, is one that I would like to highlight:
    `black`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个工具可以自动格式化 Python 代码（例如，大多数验证 PEP-8 的工具，如 `flake8`，也具有重写代码使其符合 PEP-8 标准的模式），并且它们也是可配置和适应每个特定项目的。在这些工具中，也许正因为与完全灵活和配置相反，我想强调的是：`black`。
- en: '`black` ([https://github.com/psf/black](https://github.com/psf/black)) has
    a peculiarity that formats code in a unique and deterministic way, without allowing
    any parameters (except perhaps, the length of the lines).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`black` ([https://github.com/psf/black](https://github.com/psf/black)) 有一个特性，以独特和确定的方式格式化代码，不允许任何参数（除了可能行长的设置）。'
- en: One example of this is that `black` will always format strings using double-quotes,
    and the order of the parameters will always follow the same structure. This might
    sound rigid, but it's the only way to ensure the differences in the code are kept
    to a minimum. If the code always respects the same structure, changes in the code
    will only show up in pull requests with the actual changes that were made, and
    no extra cosmetic modifications. It's more restrictive than PEP-8, but it's also
    convenient because, by formatting the code directly through a tool, we don't have
    to actually worry about that, and we can focus on the crux of the problem at hand.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这其中的一个例子是 `black` 总是使用双引号来格式化字符串，参数的顺序也总是遵循相同的结构。这听起来可能有些死板，但这是确保代码差异最小化的唯一方法。如果代码始终遵循相同的结构，代码的更改只会出现在包含实际更改的
    pull request 中，而不会有额外的外观修改。它比 PEP-8 更为严格，但同时也方便，因为通过工具直接格式化代码，我们实际上不必担心这一点，可以专注于手头问题的核心。
- en: It's also the reason `black` exists. PEP-8 defines some guidelines to structure
    our code, but there are multiple ways of having code that is compliant with PEP-8,
    so there's still the problem of finding style differences. The way `black` formats
    code is by moving it to a stricter subset of PEP-8 that is always deterministic.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是 `black` 存在的原因。PEP-8 定义了一些代码结构的指南，但有多种方式可以使代码符合 PEP-8 标准，因此仍然存在寻找风格差异的问题。`black`
    格式化代码的方式是将它移动到一个始终确定的 PEP-8 严格子集。
- en: 'As an example, see that the following code is PEP-8 compliant, but it doesn''t
    follow the conventions of `black`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码符合 PEP-8 标准，但它并不遵循 `black` 的约定：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we can run the following command to format the file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行以下命令来格式化文件：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And we can see what the tool has written:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看工具生成的结果：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: On more complex code, a lot more would have changed (trailing commas, and more),
    but the idea can be seen clearly. Again, it's opinionated, but it's also a good
    idea to have a tool that takes care of details for us.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的代码中，会有更多的变化（尾随逗号等），但基本思想可以清楚地看到。再次强调，它具有主观性，但也是一个好主意，有一个工具可以为我们处理细节。
- en: It's also something that the Golang community learned a long time ago, to the
    point that there is a standard tool library, `go fmt`, that automatically formats
    the code according to the conventions of the language. It's good that Python has
    something like this now.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是 Go 社区很久以前就学到的东西，以至于有一个标准的工具库，`go fmt`，它可以自动根据语言的约定格式化代码。现在 Python 也有类似的东西是件好事。
- en: When installed, the `'black'` command, by default, will attempt to format the
    code, but it also has a `'--check'` option that will validate the file against
    the standard, and fail the process if it doesn't pass the validation. This command
    is a good candidate to have as part of the automatic checks and CI process.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，默认情况下，`'black'` 命令会尝试格式化代码，但它还有一个 `'--check'` 选项，该选项将验证文件是否符合标准，如果验证未通过，则终止进程。这个命令是作为自动检查和
    CI 流程的一部分的好候选。
- en: 'It''s worth mentioning that `black` will format a file thoroughly, and it doesn''t
    support partial formatting (as opposed to other tools). This might be an issue
    for legacy projects that already have code with a different style because if you
    want to adopt `black` as the formatting standard in your project, you''ll most
    likely have to accept one of these two scenarios:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`black` 会彻底格式化文件，并且不支持部分格式化（与其他工具相反）。这可能是一个问题，因为遗留项目可能已经存在不同风格的代码，如果你想在项目中采用
    `black` 作为格式化标准，你很可能会接受以下两种情况之一：
- en: Creating a milestone `pull` request that will apply the `black` format to all
    Python files in the repository. This has the disadvantages of adding a lot of noise
    and polluting the version control history of the repo. In some cases, your team
    might decide to accept the risk (depending on how much you rely on the `git` history).
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个里程碑`pull`请求，将`black`格式应用于仓库中的所有Python文件。这有一个缺点，就是会添加很多噪声并污染仓库的版本控制历史。在某些情况下，你的团队可能会决定接受这个风险（取决于你对`git`历史的依赖程度）。
- en: Alternatively, you can rewrite the history with the changes in the code with
    the `black` format applied. In `git`, it's possible to rewrite the commits (from
    the very beginning), by applying some commands on each commit. In this case, we
    can rewrite each commit after the `'black'` formatting has been applied. In the
    end, it would look like the project has been in the new form from the very beginning,
    but there are some caveats. For starters, the history of the project was rewritten,
    so everyone will have to refresh their local copies of the repository. And secondly,
    depending on the history of your repository, if there are a lot of commits, this
    process can take a while.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，你可以使用`black`格式重写代码中的历史变更。在`git`中，通过在每个提交上应用一些命令，可以重写提交（从最一开始）。在这种情况下，我们可以在`'black'`格式化应用后重写每个提交。最终，项目看起来就像从一开始就是新的形式，但也有一些注意事项。首先，项目的历史被重写了，所以每个人都需要刷新他们的本地仓库副本。其次，根据你的仓库历史，如果有大量的提交，这个过程可能需要一段时间。
- en: 'In cases where formatting in the "all-or-nothing" fashion is not acceptable,
    we can use `yapf` ([https://github.com/google/yapf](https://github.com/google/yapf)),
    which is another tool that has many differences with respect to `black`: it''s
    highly customizable, and it also accepts partial formatting (applying the formatting
    to only certain regions of the file).'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式化采用“全有或全无”方式不可接受的情况下，我们可以使用`yapf` ([https://github.com/google/yapf](https://github.com/google/yapf))，这是另一个与`black`有许多不同之处的工具：它高度可定制，并且也接受部分格式化（仅对文件的特定区域应用格式化）。
- en: '`yapf` accepts an argument to specify the range of the lines to apply the formatting
    to. With this, you can configure your editor or IDE (or better yet, set up a `git`
    pre-commit hook), to automatically format the code only on the regions of the
    code that were just changed. This way, the project can get aligned to the coding
    standards, at staged intervals, as changes are being made.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`yapf`接受一个参数来指定要应用格式的行范围。利用这个参数，你可以配置你的编辑器或IDE（或者更好的是，设置一个`git` pre-commit钩子），以自动仅对刚刚更改的代码区域进行格式化。这样，项目可以在变更过程中以分阶段的时间间隔对齐到编码标准。'
- en: To conclude this section on tools that format the code automatically, we can
    say that `black` is a great tool that will push the code toward a canonical standard,
    and for this reason, you should try to use it in your repositories. There's absolutely
    no friction with using `black` on new repositories that are created, but it's
    also understandable that for legacy repositories this might become an obstacle.
    If the team decides that it is just too cumbersome to adopt `black` in a legacy
    repository, then tools such as `yapf` could be more suitable.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要总结本节关于自动格式化代码的工具，我们可以说`black`是一个很好的工具，它将推动代码向一个规范标准靠拢，因此，你应该尝试在你的仓库中使用它。在创建新仓库时使用`black`没有任何摩擦，但对于遗留仓库，这可能会成为一个障碍。如果团队决定在遗留仓库中采用`black`过于繁琐，那么像`yapf`这样的工具可能更适合。
- en: Setup for automatic checks
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动检查的设置
- en: In Unix development environments, the most common way of working is through
    Makefiles. Makefiles are powerful tools that let us configure commands to be run
    in the project, mostly for compiling, running, and so on. Besides this, we can
    use aMakefile in the root of our project, with some commands configured to run
    checks on the formatting and conventions of the code, automatically.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix开发环境中，最常见的工作方式是通过Makefiles。Makefiles是强大的工具，它让我们能够配置在项目中运行的命令，主要用于编译、运行等。除此之外，我们可以在项目的根目录中使用Makefile，配置一些命令来自动运行对代码格式和约定的检查。
- en: 'A good approach for this would be to have targets for the tests, and each particular
    test, and then have another one that runs altogether; for example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此，一个好的方法是为测试设置目标，并为每个特定的测试设置一个目标，然后还有一个运行所有测试的目标；例如：
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, the command we run (both on our development machines and on the CI environment
    builds) is the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们运行的命令（在我们的开发机器上以及CI环境构建中）如下：
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will run everything in the following steps:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在以下步骤中运行所有内容：
- en: It will first check the compliance with the coding guideline (PEP-8, or `black`
    with the `'--check'` parameter, for instance).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将首先检查是否符合编码指南（PEP-8，或者例如使用`'--check'`参数的`black`）。
- en: Then it will check for the use of types on the code.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它将检查代码中对类型的用法。
- en: Finally, it will run the tests.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它将运行测试。
- en: If any of these steps fail, consider the entire process a failure.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些步骤中的任何一个失败，请考虑整个过程为失败。
- en: These tools (`black`, `pylint`, `mypy`, and many more) can be integrated with
    the editor or IDE of your choice to make things even easier. It's a good investment
    to configure your editor to make these kinds of modifications either when saving
    the file or through a shortcut.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具（`black`、`pylint`、`mypy`等）可以与您选择的编辑器或IDE集成，使事情更加简单。配置您的编辑器，在保存文件或通过快捷键进行此类修改，这是一个很好的投资。
- en: 'It''s worth mentioning that the use of a `Makefile` comes in handy for a couple
    of reasons: first, there is a single and easy way to perform the most repetitive
    tasks automatically. New members of the team can quickly get onboarded by learning
    that something like `''make format''` automatically formats the code regardless
    of the underlying tool (and its parameters) being used. In addition, if it''s
    later decided to change the tool (let''s say you''re switching over from `yapf`
    to `black`), then the same command `(''make format''`) would still be valid.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，使用`Makefile`有几个原因很方便：首先，有一个简单且统一的方法来自动执行最重复的任务。新加入团队的成员可以通过学习像`'make
    format'`这样的命令来自动格式化代码，而不管使用的是哪种底层工具（及其参数）。此外，如果后来决定更改工具（比如说从`yapf`切换到`black`），那么相同的命令`('make
    format'`)仍然有效。
- en: Second, it's good to leverage the `Makefile` as much as possible, and that means
    configuring your CI tool to also call the commands in the `Makefile`. This way
    there is a standardized way of running the main tasks in your project, and we
    place as little configuration as possible in the CI tool (which again, might change
    in the future, and that doesn't have to be a major burden).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，尽可能利用`Makefile`，这意味着配置你的CI工具以调用`Makefile`中的命令。这样，就有了一个标准化的方式来运行项目中的主要任务，我们将尽可能少地在CI工具中放置配置（这同样可能在将来发生变化，而且不必成为一项重大负担）。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We now have a first idea of what clean code is, and a workable interpretation
    of it, which will serve us as a reference point for the rest of this book.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对什么是干净的代码有一个初步的了解，以及对其的一个可行的解释，这将作为本书其余部分的一个参考点。
- en: More importantly, we now understand that clean code is something much more important
    than the structure and layout of the code. We have to focus on how ideas are represented
    in the code to see if they are correct. Clean code is about readability, maintainability
    of the code, keeping technical debt to a minimum, and effectively communicating
    our ideas in the code so that others can understand what we intended to write
    in the first place.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们现在明白，干净的代码比代码的结构和布局更重要。我们必须关注代码中想法的表达方式，以判断它们是否正确。干净的代码关乎代码的可读性、可维护性，将技术债务降至最低，以及有效地在代码中传达我们的想法，以便他人能够理解我们最初想要写的内容。
- en: However, we discussed that adherence to coding styles or guidelines is important
    for multiple reasons. We agreed that this is a condition that is necessary, but
    not sufficient, and since it is a minimal requirement every solid project should
    comply with, it is clear that it is something we better leave to the tools. Therefore,
    automating all of these checks becomes critical, and in this regard, we have to
    keep in mind how to configure tools such as `mypy`, `pylint`, `black`, and others.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们讨论了遵守编码风格或指南的重要性，原因有很多。我们一致认为，这是一个必要条件，但不是充分条件，并且由于它是每个稳健项目都必须遵守的最小要求，因此很明显，这是我们应该留给工具的事情。因此，自动化所有这些检查变得至关重要，在这方面，我们必须记住如何配置`mypy`、`pylint`、`black`和其他工具。
- en: The next chapter is going to be more focused on Python-specific code, and how
    to express our ideas in idiomatic Python. We will explore the idioms in Python
    that make for more compact and efficient code. In this analysis, we will see that,
    in general, Python has different ideas or different ways to accomplish things
    compared to other languages.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将更加专注于Python特定的代码，以及如何用惯用的Python方式表达我们的想法。我们将探讨Python中那些使代码更加紧凑和高效的惯用用法。在这个分析中，我们将看到，总的来说，Python与其他语言相比，有不同的想法或不同的方式来完成事情。
- en: References
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: '*PEP-8*: [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-8*: [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)'
- en: '`mypy`: [http://mypy-lang.org/](http://mypy-lang.org/)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mypy`: [http://mypy-lang.org/](http://mypy-lang.org/)'
- en: '`pytype`: [https://google.github.io/pytype/](https://google.github.io/pytype/)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytype`: [https://google.github.io/pytype/](https://google.github.io/pytype/)'
- en: '*PEP-3107*: [https://www.python.org/dev/peps/pep-3107/](https://www.python.org/dev/peps/pep-3107/)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-3107*: [https://www.python.org/dev/peps/pep-3107/](https://www.python.org/dev/peps/pep-3107/)'
- en: '*PEP-484*: [https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-484*: [https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/)'
- en: '*PEP-526*: [https://www.python.org/dev/peps/pep-0526/](https://www.python.org/dev/peps/pep-0526/)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-526*: [https://www.python.org/dev/peps/pep-0526/](https://www.python.org/dev/peps/pep-0526/)'
- en: '*PEP-557*: [https://www.python.org/dev/peps/pep-0557/](https://www.python.org/dev/peps/pep-0557/)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-557*: [https://www.python.org/dev/peps/pep-0557/](https://www.python.org/dev/peps/pep-0557/)'
- en: '*PEP-585*: [https://www.python.org/dev/peps/pep-0585/](https://www.python.org/dev/peps/pep-0585/)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-585*: [https://www.python.org/dev/peps/pep-0585/](https://www.python.org/dev/peps/pep-0585/)'
