- en: Extension Modules and Compiled Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展模块和编译代码
- en: In this chapter, we'll discuss how to integrate compiled code into Python programs.
    We'll take a look at the benefits and drawbacks of our compiled code and see two
    ways of making a connection between Python's managed environment and code that
    runs directly on the hardware.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何将编译代码集成到 Python 程序中。我们将探讨编译代码的优缺点，并查看两种将 Python 的管理环境与直接在硬件上运行的代码连接起来的方法。
- en: We'll see how to use the `ctypes` package and tie it to the interface of a C
    dynamic library, calling its functions and receiving their output from within
    our Python code. We'll also look at an easy way to write compiled code modules
    so that they could be imported and called directly from Python.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解如何使用 `ctypes` 包并将其与 C 动态库的接口绑定，从我们的 Python 代码中调用其函数并接收它们的输出。我们还将探讨一种简单的方法来编写编译代码模块，以便它们可以直接从
    Python 中导入和调用。
- en: 'We''ll cover the following topics in detail:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细介绍以下主题：
- en: Advantages and disadvantages of compiled code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译代码的优点和缺点
- en: Accessing a dynamic library using `ctypes`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ctypes` 访问动态库
- en: Interfacing with C code using Cython
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cython 与 C 代码接口
- en: Advantages and disadvantages of compiled code
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译代码的优点和缺点
- en: There are many real advantages of using compiled code. Python is a very productive
    language, but it may not fulfil the requirements of a lot of people. Sometimes,
    we need to interface with code written in a different language. One reason for
    doing this would be in case we need to access some functionality that is written
    in a different language that doesn't exist in Python.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编译代码有许多实际优点。Python 是一种非常高效的编程语言，但它可能无法满足很多人的需求。有时，我们需要与用不同语言编写的代码进行接口。这样做的一个原因可能是在我们需要访问一些用不同语言编写的功能，而这些功能在
    Python 中不存在。
- en: As long as the code in question is in a dynamic library that has a C-compatible
    interface, it's relatively easy to call the code from within Python, using the
    **Foreign Function Interface** (**FFI**) provided by Python's standard ctypes
    package, which we'll discuss in the next section.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 只要相关代码是在具有 C 兼容接口的动态库中，使用 Python 的标准 ctypes 包提供的**外部函数接口（FFI**）从 Python 内部调用代码就相对简单，我们将在下一节中讨论这个包。
- en: Alternatively, we may need to write some code that runs **Close to Metal** (**CTM**),
    either to maximize the performance of an algorithm that's proven to be a bottleneck
    in our project, or interface directly with some piece of hardware. In this case,
    we'll need to compile custom code and link it to the Python environment. You can
    easily do this using a tool called **Cython** (for more details, refer to cython.org),
    which we'll discuss in the third section of this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可能需要编写一些**接近金属（CTM**）运行的代码，要么是为了最大化我们项目中已证明是瓶颈的算法的性能，要么是直接与某些硬件接口。在这种情况下，我们需要编译自定义代码并将其链接到
    Python 环境。你可以使用一个名为 **Cython** 的工具轻松完成此操作（更多详情请参阅 cython.org），我们将在本章的第三部分中讨论它。
- en: The downsides of compiled code
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译代码的缺点
- en: 'While working with compiled code is usually absolutely fine, there can be some
    significant downsides. Let''s take a look at them:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用编译代码通常是非常好的，但可能会有一些显著的缺点。让我们来看看它们：
- en: First and foremost is the fact that it's easy to create ridiculously weird bugs
    when we work at this level of compiled code. Both `ctypes` and Cython allow us
    to make a horrible mess in the program's memory, potentially producing any conceivable
    kind of bug or error. The following diagram illustrates an example of a potential
    low-level bug. You can imagine how difficult it would be to troubleshoot such
    bugs.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先要考虑的是，我们在编译代码的这个级别上工作时很容易创建极其奇怪的bug。`ctypes` 和 Cython 都允许我们在程序的内存中制造混乱，可能产生任何可想象到的bug或错误。以下图表展示了一个潜在的底层bug示例。你可以想象调试这样的bug会有多困难。
- en: '![](img/2b4fc3be-18a6-41bb-a1c7-02de4a733dd1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b4fc3be-18a6-41bb-a1c7-02de4a733dd1.jpg)'
- en: If we're lucky, that bug or error would result in a flat-out termination of
    our program, that is, if it violates the constraints of the operating system's
    protected memory manager.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们很幸运，那个错误或bug会导致程序直接终止，也就是说，如果它违反了操作系统受保护内存管理器的限制。
- en: I say we'll be lucky because if that doesn't happen, it would mean we've made
    an effective random change to some part of our program state and who knows what
    that'll do.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们会很幸运，因为如果这种情况没有发生，那就意味着我们对程序状态的一部分进行了有效的随机更改，谁知道那会带来什么后果。
- en: The second downside is that it makes distributing our program more difficult.
    For a normal Python program, we can distribute a single `.pyz` file to our users
    or upload a set of tools, a compatible source package, or a neutral operating
    system wheel file to the **Python Package Index** (**PyPI**). Using compiled code
    means we have to worry about which operating system and hardware architecture
    our users employ and provide separate packages for each combination we want to
    support.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个缺点是它使得分发我们的程序变得更加困难。对于一个普通的 Python 程序，我们可以向用户分发单个 `.pyz` 文件，或者上传一系列工具、兼容的源代码包或中立的操作系统
    wheel 文件到 **Python 包索引**（**PyPI**）。使用编译代码意味着我们必须担心我们的用户使用的是哪种操作系统和硬件架构，并为我们想要支持的每种组合提供单独的包。
- en: The third downside only applies if we're writing our own compiled code primarily
    for those use cases where Cython is most useful. The problem is that it could
    be complex to actually get a compiler installed and working, particularly for
    people who aren't used to working with compilers. Not only that, if we distribute
    our project as source code, our users would need to go through the same hassle.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个缺点仅适用于我们编写自己的编译代码，主要用于那些 Cython 最有用的用例。问题是实际上安装并使编译器工作可能很复杂，尤其是对于不习惯与编译器打交道的人来说。不仅如此，如果我们以源代码的形式分发我们的项目，我们的用户也需要经历同样的麻烦。
- en: Between the danger of bizarre errors and the annoyance involved in creating
    and distributing projects that use compiled code, we should generally wait until
    we have a compelling reason for taking the step of creating or interfacing with
    compiled code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在奇怪错误的危险和创建和使用编译代码的项目所带来的烦恼之间，我们应该通常等到我们有充分的理由去采取创建或与编译代码接口的步骤。
- en: 'Now we have a pretty good grasp of the benefits of interfacing with compiled
    code: it gives us access to C-compatible libraries written in other languages.
    This code lets us optimize the performance of critical algorithms, and it lets
    us interface directly with hardware or low-level drivers.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地掌握了与编译代码接口的好处：它使我们能够访问用其他语言编写的与 C 兼容的库。这段代码让我们能够优化关键算法的性能，并使我们能够直接与硬件或低级驱动程序接口。
- en: Similarly, we know what the drawbacks are, namely the potential and seemingly
    inexplicable errors and a generally higher level of annoyance and difficulty throughout
    the development and distribution process. Now, let's take a look at putting some
    of the knowledge we've gained into action.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们知道其缺点是什么，即潜在的看似无法解释的错误以及在整个开发和分发过程中普遍较高的烦恼和难度。现在，让我们看看如何将我们获得的一些知识付诸实践。
- en: Accessing a dynamic library using ctypes
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ctypes 访问动态库
- en: In this section, we're going to narrow down our focus to the Python standard
    library's `ctypes` package, which allows us to interact with dynamic libraries
    from within Python.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将将我们的重点缩小到 Python 标准库的 `ctypes` 包，它允许我们在 Python 中与动态库交互。
- en: Locating and linking a dynamic library
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位和链接动态库
- en: Probably, the most common need to interact with compiled code is when there's
    a library out there that does exactly what we need but it's not a Python library.
    Perhaps it was instead written for C, or it has a C interface.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，与编译代码交互的最常见需求是当有一个库正好符合我们的需求，但它不是 Python 库。也许它原本是为 C 编写的，或者它有一个 C 接口。
- en: 'We''re not going to let a little thing like this stop us. Instead, we''ll use
    `ctypes` to create an interface module for the library. For basic usage, `ctypes`
    is very simple. We just need to import it, load the dynamic library by the filename,
    and call a function in that library as shown in the following code example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会让这样一个小问题阻止我们。相反，我们将使用 `ctypes` 为库创建一个接口模块。对于基本使用，`ctypes` 非常简单。我们只需要导入它，通过文件名加载动态库，并调用该库中的函数，如下面的代码示例所示：
- en: '![](img/29920012-1239-4850-a3cf-9be51f1630ea.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/29920012-1239-4850-a3cf-9be51f1630ea.png)'
- en: The `CDLL` constructor we called in this example creates a Python object that
    represents a dynamic library containing C functions. We do need to take care when
    we define the filename of the library here, because of course different operating
    systems have different naming conventions for their libraries. The `libc.so.6`
    attribute, in our example here, is the filename of the C standard library on current
    versions of Linux.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们调用的 `CDLL` 构造函数创建了一个代表包含 C 函数的动态库的 Python 对象。当然，由于不同的操作系统有不同的库命名约定，我们在定义库的文件名时需要格外小心。在我们的例子中，`libc.so.6`
    属性是当前 Linux 版本上 C 标准库的文件名。
- en: 'The `ctypes` package includes a utility function, called `ctypes.util.find_library`,
    to help address this difficulty. If we pass a base name to `find_library`, it
    will try to find the full name of the version installed on the system, as shown
    in the following code example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctypes` 包含一个名为 `ctypes.util.find_library` 的实用函数，用于帮助解决这个难题。如果我们向 `find_library`
    传递一个基本名称，它将尝试找到系统上安装的完整版本名称，如下面的代码示例所示：'
- en: '![](img/bc077a2d-e201-45ab-98c2-6bc681198989.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc077a2d-e201-45ab-98c2-6bc681198989.png)'
- en: The `ctypes.util.find_library` is pretty useful on Linux and Mac OS X but less
    so on Windows because Windows dynamic libraries handle multiple versions in a
    very different way.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctypes.util.find_library` 在 Linux 和 Mac OS X 上非常有用，但在 Windows 上则不那么有用，因为 Windows
    动态库以非常不同的方式处理多个版本。'
- en: It's also worth noting that when we pass the C string to `find_library`, we'll
    find the C standard library on Linux and Mac OS X. On Windows, the same library
    is rather arbitrarily called `msvcrt`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当我们向 `find_library` 传递 C 字符串时，我们将在 Linux 和 Mac OS X 上找到 C 标准库。在 Windows
    上，相同的库被任意地称为 `msvcrt`。
- en: For cross-platform library loading, we need to be able to specify several alternate
    names for the library; try `find_library` on these names (refer to the following
    code example) and fall back to trying the raw name if `find_library` fails.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于跨平台库加载，我们需要能够指定几个库的备用名称；尝试在这些名称上使用 `find_library`（参考以下代码示例），如果 `find_library`
    失败，则回退到尝试原始名称。
- en: '![](img/f76438bd-e701-4259-bf81-964332dc115a.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f76438bd-e701-4259-bf81-964332dc115a.jpg)'
- en: There's a `load_library` function in the `demo_ctype/libc.py` file, available
    with this book, which also demonstrates this.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书一起提供的 `demo_ctype/libc.py` 文件中有一个 `load_library` 函数，它也演示了这一点。
- en: Accessing functions defined in the library
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问库中定义的函数
- en: Once we have the library loaded, we have access to the functions exported from
    that library, which are exposed as attributes of the library object in Python.
    We saw this in the previous section when we called C's `printf` function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们加载了库，我们就能够访问从该库导出的函数，这些函数在 Python 中作为库对象的属性公开。我们在上一节中调用 C 的 `printf` 函数时看到了这一点。
- en: 'Now, it''s important to know that there''s nothing in the C shared library
    that tells the users of the library what the parameter types of a function are,
    or the return type, or even how many parameters the function has. This information
    is used when compiling the library, but it isn''t part of the end result. This
    means it''s up to us to know how the function is supposed to be used. For example,
    the C library contains a quick sort function called `qsort`, which is intended
    to accept several parameters. Let''s see what happens if these parameters aren''t
    provided:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重要的是要知道，C 共享库中没有内容告诉库的用户函数的参数类型是什么，或者返回类型，甚至函数有多少个参数。这些信息在编译库时使用，但不是最终结果的一部分。这意味着我们必须知道函数应该如何使用。例如，C
    库中包含一个名为 `qsort` 的快速排序函数，它旨在接受多个参数。让我们看看如果这些参数没有提供会发生什么：
- en: '![](img/c9fa4089-cc8e-43c6-b8dd-80fb3acaeb0d.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c9fa4089-cc8e-43c6-b8dd-80fb3acaeb0d.png)'
- en: As you can see in the preceding code example, if we omit the parameters, `ctypes`
    has no way of knowing whether we're making a mistake, and bad things happen with
    no warning.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码示例所示，如果我们省略了参数，`ctypes` 就无法知道我们是否犯了错误，并且没有任何警告的情况下发生不良事件。
- en: Assigning attributes to a function
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将属性分配给函数
- en: If we're planning on making systematic use of a foreign function, or especially,
    if we're going to expose it as part of the interface of a module we're writing,
    it is advisable to tell `ctypes` about the function's signature. We can do this
    by assigning to the function's `argtypes` and `restype` attributes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们计划系统地使用外部函数，或者特别是如果我们打算将其作为我们编写的模块接口的一部分公开，建议告诉 `ctypes` 关于函数签名的信息。我们可以通过将
    `argtypes` 和 `restype` 属性分配给函数来实现这一点。
- en: 'The `argtypes` attribute should be a list of C data types defined in the `ctypes`
    package, while `restype` should be one of these packages, as shown in the following
    code example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`argtypes` 属性应该是 `ctypes` 包中定义的 C 数据类型列表，而 `restype` 应该是这些包之一，如下面的代码示例所示：'
- en: '![](img/c0d0b711-7cb8-46cc-8d96-2b9811eb23d2.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0d0b711-7cb8-46cc-8d96-2b9811eb23d2.png)'
- en: As you can see in the code, providing this information to `ctypes` significantly
    improves the error handling of a foreign function. The `atof` function returns
    a double-precision floating point number, but `ctypes` wouldn't know about this
    if we don't tell it so. When `ctypes` doesn't have the information, it just assumes
    the return value is an integer; this works in many cases, but it would have been
    useless in this particular example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，向 `ctypes` 提供这些信息可以显著提高外部函数的错误处理能力。`atof` 函数返回一个双精度浮点数，但如果我们不告诉它，`ctypes`
    就不知道这一点。当 `ctypes` 没有信息时，它就假设返回值是整数；这在许多情况下是可行的，但在这个特定的例子中就毫无用处了。
- en: Using a pointer as a parameter of a function
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指针作为函数的参数
- en: 'It''s pretty common for C functions to accept a pointer as one of the parameters
    and fill in a value at the address that the pointer refers to. Naturally, `ctypes`
    allows us to work with this sort of interface by letting us create objects that
    represent memory locations and passing that object using the pointer to the functions
    we call. The C `scanf` function works in a way that can be illustrated by the
    following code example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: C 函数接受指针作为参数并在指针指向的地址填充值是很常见的。自然地，`ctypes` 允许我们通过创建代表内存位置的对象并使用指针将此对象传递给调用函数的接口来处理这种类型的接口。C
    的 `scanf` 函数的工作方式可以通过以下代码示例来说明：
- en: '![](img/93dd9490-e720-4ed1-8004-241ce57244b1.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93dd9490-e720-4ed1-8004-241ce57244b1.png)'
- en: In this example, we created two C-style variables called `integer` and `decimal`;
    then, we used the `scanf` function to fill them with values, based on user input.
    The `byref` function tells `ctypes` that we're not passing the value of the variable
    to the function, but that we're passing its memory address, so the function can
    store something there.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了两个 C 风格的变量，分别称为 `integer` 和 `decimal`；然后，我们使用 `scanf` 函数根据用户输入填充它们。`byref`
    函数告诉 `ctypes` 我们不是传递变量的值给函数，而是传递其内存地址，这样函数就可以在那里存储某些内容。
- en: Providing a function signature
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供函数签名
- en: 'Another common behavior of C functions is filling bytes into a character buffer.
    We can use the `create_string_buffer` function of `ctypes` to allocate such a
    buffer and then use the result as a parameter for functions that want a string
    buffer, as shown in the following code example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: C 函数的另一种常见行为是将字节填充到字符缓冲区中。我们可以使用 `ctypes` 的 `create_string_buffer` 函数来分配这样的缓冲区，然后将其结果用作需要字符串缓冲区的函数的参数，如下面的代码示例所示：
- en: '![](img/83920145-3f04-4102-b75f-8d56f95971d2.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83920145-3f04-4102-b75f-8d56f95971d2.jpg)'
- en: Let's look at this code now. We do not need to use the `byref` function here,
    because the character bumper is inherently by reference. There's just no other
    way to do this in C.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这段代码。这里我们不需要使用 `byref` 函数，因为字符缓冲区本身是按引用提供的。在 C 中没有其他方法可以做到这一点。
- en: 'There''s a pitfall here: one that''s been tripping up C programmers for decades.
    Our string buffer has a specific length, but the function we''re passing to it
    doesn''t know what that length is. If it starts writing to the buffer and continues
    beyond the end of the buffer, the program will either crash or begin behaving
    strangely. Always make sure your buffer is at least large enough for whatever
    will be written into it.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个陷阱：这是几十年来困扰 C 程序员的陷阱之一。我们的字符串缓冲区有特定的长度，但我们传递给它的函数并不知道这个长度。如果它开始向缓冲区写入并超出缓冲区末尾，程序要么崩溃，要么开始表现出异常行为。始终确保您的缓冲区至少足够大，以便写入其中的任何内容。
- en: Providing data structure layouts
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供数据结构布局
- en: 'Another thing that is not available in a C shared library is the layout of
    data structures that the functions use, as shown in the following code example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 共享库中不可用的一件事是函数使用的数据结构的布局，如下面的代码示例所示：
- en: '![](img/b281248c-613f-428e-8c85-f05892d01c77.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b281248c-613f-428e-8c85-f05892d01c77.png)'
- en: 'Again, `ctypes` gives us a way of filling in the missing information. C''s
    `tm` structure, which is used for representing date and time information, looks
    like the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`ctypes` 给我们一种填充缺失信息的方法。用于表示日期和时间信息的 C 的 `tm` 结构看起来如下所示：
- en: '![](img/0b1b9abc-58d4-47a5-b372-a16f6ee0c392.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b1b9abc-58d4-47a5-b372-a16f6ee0c392.jpg)'
- en: As shown in this example, the translation into `ctypes` is straightforward.
    We need to create a class that would inherit from `ctypes.Structure`, and in that
    class, we need to create a list called **fields** containing tuples of field name
    and field type.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，将其翻译成 `ctypes` 是直接的。我们需要创建一个从 `ctypes.Structure` 继承的类，并在该类中创建一个名为 **fields**
    的列表，其中包含字段名称和字段类型的元组。
- en: Once we get this, we could create instances of the class and assign the attributes
    as we'd expect in Python. But, we can also pass it to C functions as a parameter,
    either directly or by reference, and we can use it as part of the signature of
    a foreign function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们掌握了这些，我们就可以创建类的实例，并像在 Python 中预期的那样分配属性。但是，我们也可以将其作为参数直接或通过引用传递给 C 函数，我们还可以将其用作外部函数签名的一部分。
- en: The `ctypes` package provides support for pretty much every feature of the C
    language, but we've now seen the ones that are most useful for calling into a
    library function and using its results.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctypes` 包提供了对 C 语言几乎所有特性的支持，但我们已经看到了调用库函数和使用其结果最有用的那些。'
- en: Interfacing with C code using Cython
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cython 与 C 代码接口
- en: In this section, we're going to look at a third-party tool called Cython, which
    is another tool for bridging the gap between Python and the software that has
    been compiled into machine code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一个名为 Cython 的第三方工具，它是另一个用于弥合 Python 与编译成机器码的软件之间差距的工具。
- en: 'If we have a situation where we want to implement part of our project in compiled
    code, we could do this by creating a dynamic library containing the code and calling
    to it with `ctypes`; however, that''s a roundabout way to get where we want to
    go. We''d end up writing a lot of code twice: once for the sake of our compiler
    and then again to tell `ctypes` about details such as function signatures and
    data structures.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在编译代码中实现项目的一部分，我们可以通过创建包含代码的动态库并使用 `ctypes` 调用它来实现。然而，这是一个绕弯路的方法，我们最终会写很多代码两次：一次是为了我们的编译器，然后再次告诉
    `ctypes` 关于函数签名和数据结构等细节。
- en: Now this is inefficient and violates one of the most important principles of
    programming—*don't repeat yourself*. There's a tool that's better suited to this
    situation, as you may have surely guessed, and that tool is Cython.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这样做是不高效的，违反了编程最重要的原则之一——*不要重复自己*。有一个工具更适合这种情况，你可能已经猜到了，那就是 Cython。
- en: Working with Cython
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cython 进行工作
- en: What Cython does is it translates a Python source code file into a C source
    code file containing equivalent calls to the Python C API; then it wraps it in
    the boilerplate necessary to turn it into a Python binary module.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 所做的是将 Python 源代码文件转换为包含对 Python C API 等效调用的 C 源代码文件；然后它将其包装在必要的模板中，以将其转换为
    Python 二进制模块。
- en: This would be useful enough by itself, but Cython also allows us to inject calls
    in C functions and low-level data access operations into the module. The end result
    is that we could pretty much just write our compiled code as if it were Python
    and still gain the speed or low-level access that prompted our need to compile
    it in the first place.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭这一点就足够有用，但 Cython 还允许我们将调用注入 C 函数和低级数据访问操作到模块中。最终结果是，我们几乎可以像编写 Python 代码一样编写我们的编译代码，同时仍然获得最初促使我们编译它的速度或低级访问。
- en: The amount of work this saves us over using the Python API directly is considerable.
    The 100-line Python example included with this course translates into more than
    5,000 lines of C when compiled. Let's go through this example piece by piece and
    talk about the differences while comparing it with plain Python.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接使用 Python API 相比，这为我们节省了大量工作量。本课程附带的一个 100 行 Python 示例在编译后转换为超过 5,000 行 C
    代码。让我们逐个分析这个示例，并在与纯 Python 进行比较时讨论差异。
- en: Additional import methods in Cython
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cython 的附加导入方法
- en: Cython allows two import mechanisms in addition to the normal ones provided
    by Python packages. Let's check out these mechanisms in detail.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 允许除了 Python 包提供的常规导入机制之外，还有两种导入机制。让我们详细了解一下这些机制。
- en: 'The first mechanism is called `cimport`, and it imports the signatures of compiled
    functions and data structures from pre-prepared libraries, as shown in the following
    command line:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种机制称为 `cimport`，它从预先准备好的库中导入编译函数和数据结构的签名，如下面的命令行所示：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case, since Cython comes with a pre-prepared library of all Python C
    API functions, we were able to use this mechanism to report the needed information
    about Python's low-level memory allocation and de-allocation functions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于 Cython 随带了一个所有 Python C API 函数的预准备库，我们能够使用这个机制来报告关于 Python 的低级内存分配和释放函数所需的信息。
- en: The second additional importing mechanism is `cdef extern from`. When we don't
    already have the signature of a compiled function available, we use the syntax
    to make it available in the Cython code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种额外的导入机制是 `cdef extern from`。当我们还没有编译函数的签名可用时，我们使用这种语法使其在 Cython 代码中可用。
- en: 'The indented block can contain any number of function declarations, type definitions,
    structure definitions, and so on, as shown in the following code example. Note
    that these don''t need to be precisely correct, though, just close enough that
    Cython is able to generate proper C code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进的块可以包含任意数量的函数声明、类型定义、结构定义等，如下面的代码示例所示。请注意，这些不需要完全正确，只要足够接近，使得 Cython 能够生成正确的
    C 代码：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A `cdef extern from` block references a C header file, which is automatically
    included in the generated C code. While we could simply use the normal Python
    syntax for the `class` statement, prepending it with `cdef` gives the ability
    to store raw data values in predefined variable members of the class instances,
    as shown in the following code example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `cdef extern from` 块引用一个 C 头文件，这个头文件会被自动包含在生成的 C 代码中。虽然我们可以简单地使用正常的 Python
    语法来编写 `class` 语句，但在前面加上 `cdef` 可以使我们能够在类的实例预定义变量成员中存储原始数据值，如下面的代码示例所示：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Writing extension modules in Cython
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Cython 中编写扩展模块
- en: The `num_values` variable in the previous code example is just a chunk of memory
    that stores bits that represent an integer value. It doesn't have any of the extra
    data needed to turn it into a Python object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，`num_values` 变量只是一个存储表示整数值的位的内存块。它没有将它们转换成 Python 对象所需的任何额外数据。
- en: This is a bad thing in a way because it means that Python can't do any of the
    smart things it does to help us write good code quickly.We wouldn't be working
    with these tools if we didn't have a reason to let them do some of this work for
    us.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这在某种程度上是一个坏事情，因为它意味着 Python 不能做任何帮助我们快速编写好代码的智能事情。如果没有让我们这些工具为我们做这些工作的原因，我们不会使用这些工具。
- en: So, to resolve this, let's define an extension type called `StatisticalArray`
    (refer to the following code example), which contains a pointer to a memory location
    and two integers. The memory location is supposed to contain double-precision
    floating point numbers. These are raw machine-level values, and while primitive
    in comparison to Python values, they're very fast because they can be fed directly
    into CPU operations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了解决这个问题，让我们定义一个名为 `StatisticalArray` 的扩展类型（参考以下代码示例），它包含一个指向内存位置的指针和两个整数。这个内存位置应该包含双精度浮点数。这些是原始的机器级值，与
    Python 值相比虽然比较原始，但它们非常快，因为它们可以直接输入 CPU 操作。
- en: '![](img/a448ad99-a805-4d80-87fa-afe00b53595c.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a448ad99-a805-4d80-87fa-afe00b53595c.png)'
- en: In this code example, we have the functions that set up and dispose of the instances
    of the `StatisticalArray` class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们有设置和销毁 `StatisticalArray` 类实例的函数。
- en: Notice that the setup function is called `__cinit__`, not `__init__`. Actually,
    a Cython `cdef` class can have both. The `__cinit__` function's job is to set
    up the raw variables for the class instance, and the normal `__init__` function
    is supposed to set up any normal Python variable it contains.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，设置函数被命名为 `__cinit__`，而不是 `__init__`。实际上，Cython 的 `cdef` 类可以同时拥有这两个。`__cinit__`
    函数的职责是为类实例设置原始变量，而正常的 `__init__` 函数应该设置它包含的任何正常 Python 变量。
- en: The `__cinit__` function is called first, and it's not guaranteed that `self`
    will actually be a valid Python object itself yet, so it should confine itself
    only to initializing raw variables. The reason `__cinit__` accepts the extra positional
    and keyword arguments is because if a Python class inherits from our class and
    adds more parameters to the signature of `__init__`, the `__cinit__` function
    will still work.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`__cinit__` 函数首先被调用，并且不能保证 `self` 本身就是一个有效的 Python 对象，因此它应该仅限于初始化原始变量。`__cinit__`
    接受额外的位置参数和关键字参数的原因是，如果 Python 类从我们的类继承并添加了更多参数到 `__init__` 的签名中，`__cinit__` 函数仍然可以工作。'
- en: At the other end of the process, we have the `__dealloc__` function, which needs
    to release any specially allocated resources associated with the class instance.
    In the preceding case, we allocated a chunk of memory to `__cinit__`, so we need
    to release that memory in the `__dealloc__` function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程的另一端，我们有`__dealloc__`函数，它需要释放与类实例关联的任何特殊分配的资源。在前面的例子中，我们在`__cinit__`中分配了一块内存，因此我们需要在`__dealloc__`函数中释放这块内存。
- en: Methods to increase the execution speed of Python code
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高Python代码执行速度的方法
- en: 'Now we are going to define a few of Python''s normal magic methods, which will
    allow us to iterate over the values stored in our object and access them by indexing.
    For this, refer to the following code example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将定义一些Python的常规魔法方法，这将使我们能够遍历存储在我们对象中的值并通过索引访问它们。为此，请参考以下代码示例：
- en: '![](img/0a066dd8-c2f1-4181-a922-329200742b2c.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a066dd8-c2f1-4181-a922-329200742b2c.jpg)'
- en: The thing to notice in this code example is how little has changed from what
    we've be doing in a pure Python implementation. The only real differences are
    the type definitions we provided for every parameter and the local variable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中需要注意的一点是，与我们在纯Python实现中所做的工作相比，变化有多小。唯一的真正区别是我们为每个参数和局部变量提供的类型定义。
- en: We didn't actually have to provide the type definition for every parameter and
    local variable. The type definition lets Cython generate plain C code for a lot
    of the operations we're performing, which means we're using the CPU directly instead
    of the Python virtual machine. We're trading flexibility for speed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上不必为每个参数和局部变量提供类型定义。类型定义让Cython为我们执行的大多数操作生成纯C代码，这意味着我们直接使用CPU而不是Python虚拟机。我们是在用速度换取灵活性。
- en: The previous functions were all defined with the `def` keyword as normal for
    Python, and these functions operate as if they were defined in a normal Python
    module.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的所有函数都是使用`def`关键字定义的，就像Python中的常规模块一样，这些函数的操作就像它们是在常规Python模块中定义的一样。
- en: 'Cython gives us two other options, though. Instead of `def`, we can use `cdef`;
    in this case, the function is much faster to call, but it''s only for use by other
    Cython code. This is great for internal help functions and such. Alternatively,
    we can use `cpdef` (as shown in the following code example); here, the function
    is accessible from normal Python, but it''s almost as fast as a `cdef` function
    when called from Cython code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Cython还给我们提供了两种其他选项。我们不是使用`def`，而是可以使用`cdef`；在这种情况下，函数调用速度更快，但它仅适用于其他Cython代码。这对于内部帮助函数等来说非常棒。或者，我们可以使用`cpdef`（如以下代码示例所示）；在这种情况下，函数可以从正常的Python代码中访问，但它在从Cython代码调用时几乎与`cdef`函数一样快：
- en: '![](img/0811f2f0-ea0e-4629-8e8c-f689c17f9307.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0811f2f0-ea0e-4629-8e8c-f689c17f9307.jpg)'
- en: We've chosen `cpdef` in our case because we want to expose the full feature
    set to any Python code that uses our compiled module, but we also expect to use
    the same functionality from within our Cython code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们选择了`cpdef`，因为我们希望向使用我们编译模块的任何Python代码公开完整的特性集，但我们还期望在Cython代码中使用相同的功能。
- en: Using cpdef in a Cython class
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Cython类中使用cpdef
- en: In the following code example, you'll see that we're getting to the reason why
    we called our class `StatisticalArray`. We implemented several discrete statistical
    calculations using the values stored in the class instance. You don't need to
    worry about what `mean`, `variance`, and `covariance` actually do, but let's take
    a look at how they're actually working.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，您将看到我们为什么将我们的类命名为`StatisticalArray`。我们使用类实例中存储的值实现了几个离散的统计计算。您不必担心`mean`、`variance`和`covariance`实际上做什么，但让我们看看它们是如何实际工作的。
- en: '![](img/61fb2050-6029-4d72-b036-d84f3701b98d.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/61fb2050-6029-4d72-b036-d84f3701b98d.jpg)'
- en: In the `mean` function, here, we see a loop that calculates the sum of the values
    stored in the array. If we were running that code in Python, each cycle through
    the loop would involve several dictionary lookups and function calls. Cython generates
    four lines of C code for this that translates into only a few machine code operations.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mean`函数中，这里我们看到一个循环，它计算数组中存储的值的总和。如果我们在这个Python中运行这段代码，每次循环都会涉及几个字典查找和函数调用。Cython为这个操作生成了四行C代码，这转化为只有几个机器代码操作。
- en: This is possible because we told Cython that the `index` variable should be
    a C integer, and because Cython is smart about handling loops with C integer variables,
    we gain a similar benefit in both `variance` and `covariance` functions. Again,
    we just use the Python syntax and give Cython additional information that it can
    use to optimize the generated code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们告诉 Cython，`index` 变量应该是一个 C 整数，而且 Cython 在处理使用 C 整数变量的循环方面非常聪明，因此我们在 `variance`
    和 `covariance` 函数中都能获得类似的收益。再次强调，我们只是使用 Python 语法，并给 Cython 提供额外的信息，以便它可以用来优化生成的代码。
- en: 'There is one unusual thing to note with `covariance`, though. At the end of
    the first line shown in the following screenshot, we see `except? -200.0`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于 `covariance` 有一个不同寻常的注意事项。在以下截图的第一行末尾，我们看到 `except? -200.0`：
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What is that? Well, as with most of these functions, we gave the `covariance`
    function an explicit C return type of `double`. That's a big gain in terms of
    speed. But when the code calling the function is also Cython, and stores the return
    value in a `cdef` double variable, there's a downside. Normally, Cython would
    use the return value to signal that an exception has been raised, but how is it
    supposed to do that when we have changed the return type, since it cannot know
    which values are valid at that point?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 那是什么？好吧，就像这些函数中的大多数一样，我们给 `covariance` 函数指定了一个显式的 C 返回类型 `double`。这在速度方面是一个很大的提升。但是当调用函数的代码也是
    Cython，并且将返回值存储在一个 `cdef` double 变量中时，存在一个缺点。通常，Cython 会使用返回值来指示已引发异常，但当我们改变了返回类型时，它应该如何做呢？因为它无法知道在那个点哪些值是有效的？
- en: Well, we'll tell it. Adding `except? -200.0` means that if the return value
    is `-200`, Cython would check to see whether an exception has been raised. If
    we had left off `?`, it would have meant that `-200` always means there's an exception,
    which is a bit faster; however, we can't go that far because `-200` is still a
    potentially valid return variable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们会告诉您。添加 `except? -200.0` 表示如果返回值是 `-200`，Cython 会检查是否已引发异常。如果我们省略了 `?`，那么
    `-200` 总是意味着存在异常，这会稍微快一点；然而，我们不能走得太远，因为 `-200` 仍然是一个可能的有效返回变量。
- en: 'Notice that we don''t actually return `-200`; we just raise an exception as
    normal. Cython takes care of the rest. Here are a couple of more examples of functions
    that are built using the earlier functions as building blocks:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们实际上并没有返回 `-200`；我们只是像平常一样引发一个异常。Cython 会处理其余的部分。以下是一些使用早期函数作为构建块构建的函数的更多示例：
- en: '![](img/542ca636-39ff-4cf1-833d-4b5786a3bc6f.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/542ca636-39ff-4cf1-833d-4b5786a3bc6f.jpg)'
- en: Thanks to our use of `cpdef`, when we define the `variance` and `covariance`
    functions, there's very little overhead involved in calling those functions from
    here.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了 `cpdef`，当我们定义 `variance` 和 `covariance` 函数时，从这里调用这些函数所涉及的开销非常小。
- en: Compiling an extension module in Python
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Python 中编译扩展模块
- en: So let's say we've written a somewhat useful Cython class; now, how do we make
    it available to Python code? Well, we have to compile it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，假设我们已经编写了一个有点有用的 Cython 类；现在，我们如何使其对 Python 代码可用？好吧，我们必须编译它。
- en: 'First of all, this means we need to have a compiler. The documentation on cython.org
    has a tutorial entry and appendix on this process, and I suggest you refer to
    them if there''s not already a compiler on your system. If you have a compiler,
    installing Cython is just a matter of asking `pip` to grab it for us:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这意味着我们需要有一个编译器。在 cython.org 的文档中有一个关于此过程的教程条目和附录，如果您系统上还没有编译器，我建议您参考它们。如果您已经有了编译器，安装
    Cython 只是一个请求 `pip` 为我们获取它的问题：
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The installation can be a little slow because it needs to do some compiling
    during the installation; just be patient until it finishes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 安装可能有点慢，因为它需要在安装过程中进行一些编译；只需耐心等待它完成。
- en: Once Cython is installed, we need to create a `setup.py` file describing how
    to build our extension, as shown in the following code example. For the base case,
    the process is very straightforward.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Cython，我们需要创建一个 `setup.py` 文件来描述如何构建我们的扩展，如下面的代码示例所示。对于基本案例，这个过程非常直接。
- en: The source code we were working on is saved in `statistics.pyx`, as shown in
    the following code example. The `.pyx` extension is the standard filename extension
    for Cython source code files.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在工作的源代码保存在 `statistics.pyx` 中，如下面的代码示例所示。`.pyx` 扩展名是 Cython 源代码文件的标准文件扩展名。
- en: '![](img/0e532917-be58-443e-af3c-a21f42070c91.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e532917-be58-443e-af3c-a21f42070c91.jpg)'
- en: Once we do this, the last step is a snap. Once the `build_ext` command is finished,
    we should have a compiled extension sitting next to our `.pyx` file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，最后一步就变得简单了。一旦`build_ext`命令完成，我们应该在我们的`.pyx`文件旁边有一个编译好的扩展。
- en: 'Now, all we have to do is import it and use it as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要导入它，并按照以下方式使用：
- en: '![](img/aba5b3b4-9805-4737-a700-154fca73000e.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aba5b3b4-9805-4737-a700-154fca73000e.jpg)'
- en: Notice that when we cause an exception in the compiled code, the traceback is
    fully filled in and points us to the cause and location of the problem. That's
    a Cython feature and a nice advantage.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们导致编译代码中的异常时，跟踪信息会完全填充，并指向问题的原因和位置。这是Cython的一个特性，也是一个很好的优势。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the benefits and drawbacks of using compiled code.
    We took a look at using Python's standard `ctypes` package to access functions
    stored in compiled C-compatible dynamic libraries, which is a quick way to gain
    access to the functionality that was written in other languages.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了使用编译代码的优缺点。我们探讨了使用Python的标准`ctypes`包来访问存储在编译的C兼容动态库中的函数，这是一种快速获取其他语言编写的功能的方法。
- en: We also saw how to use Cython to operate with one foot at Python's higher level
    and C's much lower level of abstraction, with surprisingly little pain involved
    in bridging the gap. We can use this knowledge to optimize bottlenecks in our
    programs or access functionality that's only available when we operate close to
    the hardware.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何使用Cython在Python的高层和C的低层抽象之间操作，而在这个过程中，桥接差距的痛苦出奇地少。我们可以利用这些知识来优化程序中的瓶颈或访问仅在接近硬件操作时才可用的功能。
- en: With this, we've come to the end of this course. I hope you've learned a lot
    and have gained immense knowledge about Python. Keep learning!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们结束了这门课程。我希望你已经学到了很多，并且对Python有了巨大的知识收获。继续学习！
