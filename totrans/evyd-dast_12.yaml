- en: 'Chapter 12. Sorting: Bringing Order Out Of Chaos'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章. 排序：从混乱中带来秩序
- en: Being able to build the right data structure or collection class for a particular
    application is only half the battle. Unless the data sets in your problem domain
    are very small, any collection of your data will benefit from a little organization.
    Organizing the elements in your list or collection by a particular value or set
    of values is known as **sorting**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 能够为特定应用构建正确的数据结构或集合类只是战斗的一半。除非你的问题域中的数据集非常小，否则你的数据集合将受益于一点组织。通过特定的值或值集对列表或集合中的元素进行组织被称为**排序**。
- en: Sorting your data is not strictly necessary, but doing so makes searching or
    lookup operations much more efficient. Likewise, when you need to merge multiple
    collections of data together, having the various collections sorted in advance
    of the merge can greatly improve the efficiency of the merge operation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据进行排序并非绝对必要，但这样做可以使搜索或查找操作更加高效。同样，当你需要合并多个数据集时，在合并之前对各种数据集进行排序可以大大提高合并操作的效率。
- en: If your data is a collection of numeric values, then sorting can be something
    as simple as arranging it in ascending or descending order. However, if your data
    consists of complex objects, you can sort the collection by a particular value.
    In this case, the field or property by which the data is sorted is referred to
    as a **key**. For example, if you have a collection of car objects and you want
    to sort them by their make, such as Ford, Chevrolet or Dodge, then the make is
    the key. However, if you wanted to sort by multiple keys, say the make and model,
    then the make becomes the *primary key*, while the model becomes the *secondary
    key*. Further extensions of this pattern would result in *tertiary keys*, *Quaternary keys*,
    and so on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据是一组数值，那么排序可能只是按升序或降序排列它。然而，如果你的数据由复杂对象组成，你可以通过特定的值对集合进行排序。在这种情况下，数据排序所依据的字段或属性被称为**键**。例如，如果你有一个汽车对象的集合，并且你想按制造商（如福特、雪佛兰或道奇）对其进行排序，那么制造商就是键。然而，如果你想要按多个键排序，比如制造商和型号，那么制造商成为**主键**，而型号成为**次键**。这种模式的进一步扩展将导致**三级键**、**四级键**等等。
- en: 'Sorting algorithms come in many shapes and sizes, and many of them are specifically
    suited to particular types of data structures. Although an exhaustive examination
    of known or even just popular sorting algorithms is beyond the scope of this book,
    in this chapter, we will focus on those algorithms that are either fairly common
    or are well suited to some of the data structures we have already examined. In
    each case, we will review examples in each of the four languages we have been
    looking at and discuss the complexity cost. In this chapter, we will cover the
    following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 排序算法形态各异，大小不一，其中许多特别适合特定的数据结构。尽管对已知或甚至只是流行的排序算法进行全面考察超出了本书的范围，但在本章中，我们将重点关注那些相对常见或非常适合我们已考察的一些数据结构的算法。在每种情况下，我们将回顾我们一直在查看的四种语言中的示例，并讨论复杂度成本。在本章中，我们将涵盖以下内容：
- en: Selection sort
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择排序
- en: Insertion sort
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入排序
- en: Bubble sort
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: Quick sort
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速排序
- en: Merge sort
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归并排序
- en: Bucket sort
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桶排序
- en: Counting sort
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数排序
- en: Selection sort
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择排序
- en: A selection sort can be described as an in-place comparison. This algorithm
    divides a collection or list of objects into two parts. The first is a subset
    of objects that have already been sorted, ranging from *0* to *i,* where *i* is
    the next object to be sorted. The second is a subset of objects that have not
    been sorted, ranging from *i* to *n,* where *n* is the length of the collection.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 选择排序可以被描述为原地比较。这个算法将一个集合或对象列表分为两部分。第一部分是已经排序的对象子集，范围从*0*到*i*，其中*i*是下一个要排序的对象。第二部分是尚未排序的对象子集，范围从*i*到*n*，其中*n*是集合的长度。
- en: The selection sort algorithm works by taking the smallest or largest value in
    a collection and placing it at the beginning of the unsorted subarray by swapping
    it with the object at the current index. For example, consider ordering a collection
    in ascending order. At the outset, the sorted subarray will consist of 0 members,
    while the unsorted subarray will consist of all the members in the set. The selection
    sort algorithm will find the smallest member in the unsorted subarray and place
    it at the beginning of the unsorted subarray.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 选择排序算法通过在集合中找到最小或最大值，并通过与当前索引的对象交换来将其放置在未排序子数组的开头。例如，考虑按升序对集合进行排序。一开始，已排序的子数组将包含0个成员，而未排序的子数组将包含集合中的所有成员。选择排序算法将在未排序的子数组中找到最小的成员，并将其放置在未排序子数组的开头。
- en: At this point, the sorted subarray consists of one member, while the unsorted
    subarray consists of all the remaining members in the original set. This process
    will repeat until all members of the unsorted subarray have been placed in the
    sorted subarray.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，已排序的子数组包含一个成员，而未排序的子数组包含原始集合中所有剩余的成员。这个过程将重复进行，直到未排序子数组中的所有成员都被放置在已排序子数组中。
- en: 'Given the following set of values:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下值集合：
- en: '*S = {50, 25, 73, 21, 3}*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*S = {50, 25, 73, 21, 3}*'
- en: Our algorithm will find the smallest value in *S[0...4]*, which in this case
    is *3*, and place it at the beginning of *S[0...4]:*
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的算法将在*S[0...4]*中找到最小的值，在这个例子中是*3*，并将其放置在*S[0...4]:*的开头。
- en: '*S = {3, 25, 73, 21, 50}*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*S = {3, 25, 73, 21, 50}*'
- en: 'The process is repeated for *S[1...4]*, which returns the value 21:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程会重复进行*S[1...4]*，返回值为21：
- en: '*S = {3, 21, 73, 25, 50}*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*S = {3, 21, 73, 25, 50}*'
- en: 'The next evaluation at *S[2...4]* returns a value of 25:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在*S[2...4]*的下一个评估返回值为25：
- en: '*S = {3, 21, 25, 73, 50}*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*S = {3, 21, 25, 73, 50}*'
- en: 'Finally, the function repeats again for *S[3...4]* which returns the smallest
    value of 50:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函数再次对*S[3...4]*进行重复，返回最小值50：
- en: '*S = {3, 21, 25, 50, 73}*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*S = {3, 21, 25, 50, 73}*'
- en: There is no need to examine the last object in the collection because it, by
    necessity, is already the largest remaining value. This is a small consolation,
    however, because the selection sort algorithm still has an **O**(*n²*) complexity
    cost. Moreover, this worst-case complexity score doesn't tell the whole tale in
    this particular case. The selection sort is always an **O**(*n²*) complexity,
    even under the best of circumstances. Therefore, the selection sort is quite possibly
    the slowest and most inefficient sorting algorithm you may encounter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要检查集合中的最后一个对象，因为它，按照必然性，已经是剩余的最大值。然而，这只能算是一点点安慰，因为选择排序算法仍然有**O**(*n²*)的复杂度成本。此外，这个最坏情况的复杂度分数并不能完全说明这个特定情况。选择排序始终是**O**(*n²*)的复杂度，即使在最佳情况下也是如此。因此，选择排序可能是你可能会遇到的慢速且效率最低的排序算法。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Each of the code examples in this chapter will examine algorithms in the form
    of those methods most essential to the operation, with these being detached from
    their parent classes. Additionally, in each case the collection of objects being
    sorted will be defined at the class level, outside of the example code shown here.
    Likewise, the subsequent object instantiation and population of those collections
    will be defined outside the example code. To see the full class examples, please
    use the code examples accompanying this text.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的每个代码示例都将检查算法，以这些方法最基本的形式，这些方法与其父类分离。此外，在每个情况下，要排序的对象集合将在类级别定义，在示例代码之外。同样，后续的对象实例化和这些集合的填充也将定义在示例代码之外。要查看完整的类示例，请使用伴随此文本的代码示例。
- en: '**C#**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each of our implementations of the `SelectionSort` method begins by confirming
    that the `values` array has at least two members. If not, the method returns as
    there are not enough members to sort. Otherwise, we create two nested loops. The
    outer `for` loop moves the boundary of the unsorted array one index at a time,
    while the inner `for` loop is used to find the minimum value within the unsorted
    boundary. Once we have a minimum value, the method swaps the member at `i` with
    the member identified as the current minimum. Since C# does not support passing
    primitives by reference by default we must explicitly invoke the `ref` keyword
    on both the `swap(ref int x, ref int y)` method signature as well as the called
    parameter. Although it may seem like more work to create a separate `swap` method
    for this purpose, the swap functionality is common to several popular sorting
    algorithms and having this code in a separate method saves us some keystrokes
    later on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`SelectionSort`方法的每个实现都是从确认`values`数组至少有两个成员开始的。如果没有，该方法将返回，因为没有足够的成员进行排序。否则，我们创建两个嵌套循环。外层`for`循环每次移动未排序数组的边界一个索引，而内层`for`循环用于在未排序边界内找到最小值。一旦我们得到最小值，方法就会将`i`处的成员与当前最小值的成员进行交换。由于C#默认不支持通过引用传递原始数据类型，我们必须在`swap(ref
    int x, ref int y)`方法签名以及调用的参数上显式调用`ref`关键字。尽管创建一个单独的`swap`方法来执行此操作可能看起来更麻烦，但交换功能是几种流行排序算法的共同点，将此代码放在单独的方法中可以在以后节省一些按键操作。
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Nested for loops**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌套循环**'
- en: Remember that nested loops will automatically increase the complexity of an
    algorithm exponentially. Any algorithm with a `for` loop has a complexity cost
    of **O**(n), but once you nest another `for` loop within the first the complexity
    cost increases to **O**(n²). Nesting another `for` loop within the second makes
    the cost **O**(n³), and so on.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，嵌套循环会自动使算法的复杂度呈指数级增加。任何包含`for`循环的算法都有复杂度成本**O**(n)，但一旦在第一个`for`循环内嵌套另一个`for`循环，复杂度成本就增加到**O**(n²)。在第二个循环内嵌套另一个`for`循环会使成本增加到**O**(n³)，依此类推。
- en: Also note that nesting `for` loops in any implementation will be a red flag
    to an observant reviewer and you should always be ready to justify such a design.
    Only nest for loops when you absolutely must.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在任何实现中嵌套`for`循环都会成为观察者注意的红旗，你应该总是准备好为这种设计进行辩护。只有在你绝对必须的时候才嵌套`for`循环。
- en: '**Java**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Java implementation is nearly identical in design to the C# implementation,
    except for the name of the array `length` function. However, Java does not support
    passing primitives by reference at all. Although it is possible to emulate this
    behavior by passing the primitive to an instance of a mutable wrapper class, most
    developers agree that this is a bad idea. Instead, our Java implementation performs
    the swap directly inside the `for` loop.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Java实现的设计几乎与C#实现相同，除了数组`length`函数的名称。然而，Java根本不支持通过引用传递原始数据类型。尽管可以通过将原始数据类型传递给可变包装类的实例来模拟这种行为，但大多数开发者都认为这是一个坏主意。相反，我们的Java实现直接在`for`循环内执行交换。
- en: '**Objective-C**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since `NSArray` can only store objects, we need to cast our values to `NSNumber`,
    and when we evaluate the members we need to explicitly examine the `intValue`
    object. Like Java, we opt to not create a separate swap method and pass the values
    by reference. Otherwise, implementations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`NSArray`只能存储对象，我们需要将我们的值转换为`NSNumber`，当我们评估成员时，需要显式检查`intValue`对象。像Java一样，我们选择不创建一个单独的交换方法，而是通过引用传递值。否则，实现方式。
- en: '**Swift**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Swift does not permit C-style `for` loops so our method must use the Swift
    3.0 equivalent. Also, since Swift considers arrays to be `struct` implementations
    instead of class implementations, the `values` parameter cannot be simply passed
    by reference. Therefore, our Swift implementation includes the `inout` decorator
    on the `values` parameter. Otherwise, the functionality is fundamentally the same
    as its predecessors. This rule also applies in our `swap( x: inout Int, y: inout
    Int)` method, which is used to swap the values during the sort.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 'Swift不允许使用C样式的`for`循环，因此我们的方法必须使用Swift 3.0的等效方法。此外，由于Swift将数组视为`struct`实现而不是类实现，因此`values`参数不能简单地通过引用传递。因此，我们的Swift实现包括在`values`参数上使用`inout`修饰符。否则，功能与其前辈基本相同。此规则也适用于我们的`swap(x:
    inout Int, y: inout Int)`方法，该方法用于在排序过程中交换值。'
- en: Insertion sort
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入排序
- en: An **insertion sort** is a very simple algorithm that looks at an object in
    a collection and compares its key to the keys prior to itself. You can visualize
    this process as how many of us order a hand of playing cards, individually removing
    and inserting cards from left to right in ascending order.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入排序**是一个非常简单的算法，它查看集合中的一个对象，并将其键与它之前的键进行比较。您可以将这个过程想象成我们中多少人按顺序排列一副扑克牌，逐个从左到右按升序移除和插入卡片。'
- en: For example, consider the case of ordering a collection in ascending order.
    An insertion sort algorithm will examine an object at index *i* and determine
    if it's key is lower in value or priority than the object at index *i - 1*. If
    so, the object at *i* is removed and inserted at *i - 1*. At this point, the function
    will repeat and continue to loop in this manner until the object key at *i - 1*
    is not lower than the object key at *i*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑按升序对集合进行排序的情况。插入排序算法将检查索引*i*处的对象，并确定其键值是否低于或优先于索引*i - 1*处的对象。如果是这样，索引*i*处的对象将被移除并插入到*i
    - 1*处。此时，函数将重复并继续以这种方式循环，直到*i - 1*处的对象键值不低于*i*处的对象键值。
- en: 'Given the following set of values:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下值集：
- en: '*S = {50, 25, 73, 21, 3}*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*S = {50, 25, 73, 21, 3}*'
- en: Our algorithm will begin examining the list at *i = 1*. We do this because at
    *i = 0*, *i - 1* is a non-existent value and would require special handling.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始检查列表的*i = 1*。我们这样做是因为在*i = 0*处，*i - 1*是一个不存在的值，需要特殊处理。
- en: 'Since 25 is less than 50, it is removed and reinserted at *i = 0*. Since we''re
    at index 0, there is nothing left to examine to the left of 25, so this iteration
    is complete:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于25小于50，因此它被移除并重新插入到*i = 0*的位置。由于我们处于索引0，因此没有东西可以检查25左侧的，所以这次迭代完成：
- en: '*S = {25, 50, 73, 21, 3}*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*S = {25, 50, 73, 21, 3}*'
- en: 'Next we examine *i = 2*. Because 73 is not less than 50, this value doesn''t
    need to move. Since we have already sorted everything to the left of *i = 2*,
    this iteration is immediately completed. At *i = 3*, the value 21 is less than
    73 and so it is removed and reinserted at *i = 2*. Checking again, 21 is less
    than 50, so the value 21 is removed and reinserted at index 1\. Finally, 21 is
    less than 25, so the value 21 is removed and reinserted at *i = 0*. Since we''re
    now at index 0, there is nothing left to examine to the left of 21, so this iteration
    are complete:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们检查*i = 2*。由于73不小于50，因此这个值不需要移动。由于我们已经将*i = 2*左侧的所有东西都排序好了，所以这次迭代立即完成。在*i
    = 3*处，值21小于73，因此它被移除并重新插入到*i = 2*。再次检查，21小于50，所以值21被移除并重新插入到索引1。最后，21小于25，所以值21被移除并重新插入到*i
    = 0*。由于我们现在处于索引0，因此没有东西可以检查21左侧的，所以这次迭代完成：
- en: '*S = {21, 25, 50, 73, 3}*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*S = {21, 25, 50, 73, 3}*'
- en: 'Finally, we come to *i = 4*, the end of the list. Since 3 is less than 21,
    the value 3 is removed and reinserted at *i = 3*. Next, 3 is less than 73, so
    the value 3 is removed and reinserted at *i = 2*. At *i = 2*, 3 is less than 50
    so the value 3 is removed and reinserted at *i = 1*. At *i = 1*, 3 is less than
    25 so the value 3 is removed and reinserted at *i = 0*. Since we''re now at index
    0, there is nothing left to examine to the left of 3 so this iteration, and our
    sorting function, are complete:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达列表的*i = 4*，即列表的末尾。由于3小于21，因此值3被移除并重新插入到*i = 3*。接下来，3小于73，所以值3被移除并重新插入到*i
    = 2*。在*i = 2*处，3小于50，所以值3被移除并重新插入到*i = 1*。在*i = 1*处，3小于25，所以值3被移除并重新插入到*i = 0*。由于我们现在处于索引0，因此没有东西可以检查3左侧的，所以这次迭代和我们的排序函数都完成了：
- en: '*S = {3, 21, 25, 50, 73}*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*S = {3, 21, 25, 50, 73}*'
- en: As you can see this algorithm is simple but also potentially expensive for larger
    lists of objects or values. The insertion sort has a worst-case and even an *average-*case
    complexity of **O**(*n²*). However, unlike selection sort, insertion sort has
    improved efficiency when sorting lists that were previously sorted. As a result,
    it enjoys a best-case complexity of **O**(*n*), making this algorithm a slightly
    better choice than selection sort.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个算法简单，但对于较大的对象或值列表来说可能成本较高。插入排序在最坏情况和平均情况下的复杂度都是**O(n²**)。然而，与选择排序不同，当对先前已排序的列表进行排序时，插入排序的效率有所提高。因此，它具有最佳复杂度**O(n**)，这使得该算法比选择排序略好一些。
- en: '**C#**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each of our implementations of the `InsertionSort` method begins by confirming
    that the `values` array has at least two members. If not, the method returns as
    there are not enough members to sort. Otherwise, two integer variables are declared
    named `j` and `value`. Next a `for` loop is created that iterates through the
    members of the collection. The index `i` is used to track the position of the
    last sorted member. Within this for loop, `value` is assigned to the last sorted
    member while `j` is used to track the position in the current iteration through
    the unsorted members. Our `while` loop continues until `j` is equal to `0` and
    the value at index `j` is greater than the value at index `i`. In every iteration
    of the `while` loop, we swap the member at position `j` with the member at position
    `j + 1`, then the loop decrements the value of `j` by 1 to move back through the
    collection. Finally, the last step is to set the member stored in `value` at position
    `j + 1`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`InsertionSort`方法的每个实现都首先确认`values`数组至少有两个成员。如果没有，则方法返回，因为没有足够的成员进行排序。否则，声明两个名为`j`和`value`的整数变量。接下来创建一个`for`循环，遍历集合的成员。索引`i`用于跟踪最后排序成员的位置。在这个`for`循环中，`value`被分配给最后排序的成员，而`j`用于跟踪当前迭代中未排序成员的位置。在我们的`while`循环中，`value`被分配给索引`j`处的成员，而`j`用于跟踪当前迭代中未排序成员的位置。我们的`while`循环将继续，直到`j`等于`0`且索引`j`处的值大于索引`i`处的值。在`while`循环的每次迭代中，我们将位置`j`处的成员与位置`j
    + 1`处的成员交换，然后循环将`j`的值减1，以便在集合中回溯。最后一步是将存储在`value`中的成员设置在位置`j + 1`。
- en: '**Java**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Java implementation is nearly identical in design to the C# implementation,
    except for the name of the array `length` function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Java实现的设计几乎与C#实现相同，只是数组`length`函数的名称不同。
- en: '**Objective-C**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since `NSArray` can only store objects, we need to cast our values to the `NSNumber`
    variable, and when we evaluate the members we need to explicitly examine the `intValue`
    variable. Otherwise, this implementation is fundamentally the same as the C# or
    Java implementations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`NSArray`只能存储对象，我们需要将我们的值转换为`NSNumber`变量，并且在评估成员时需要显式检查`intValue`变量。否则，此实现与C#或Java实现基本相同。
- en: '**Swift**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Swift does not permit C-style `for` loops, so our method must use the Swift
    3.0 equivalent. Also, since Swift considers arrays to be struct implementations
    instead of class implementations, the `values` parameter cannot be simply passed
    by reference. Therefore, our Swift implementation includes the `inout` decorator
    on the `values` parameter. Otherwise, the functionality is fundamentally the same
    as its predecessors.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Swift不允许使用C风格的`for`循环，因此我们的方法必须使用Swift 3.0的等效方法。此外，由于Swift将数组视为结构体实现而不是类实现，因此`values`参数不能简单地通过引用传递。因此，我们的Swift实现包括在`values`参数上使用`inout`修饰符。否则，其功能与前辈基本相同。
- en: Bubble sort
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: '**Bubble sort** is another simple algorithm that steps through the list of
    values or objects to be sorted and compares adjacent items or their keys to determine
    if they are in the wrong order. The name comes from the way that unordered items
    seem to bubble to the top of the list. However, some developers sometimes refer
    to this as a **sinking sort**, as objects could just as easily appear to be dropping
    down through the list.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**冒泡排序**是另一种简单的算法，它通过遍历要排序的值或对象的列表，并比较相邻项或它们的键来确定它们是否处于错误的顺序。这个名字来源于无序项似乎会冒到列表顶部的样子。然而，一些开发者有时将其称为**下沉排序**，因为对象也可能看起来像是从列表中掉下来的。'
- en: 'Overall, the bubble sort is just another inefficient comparison sort. However,
    it does have one distinct advantage over other comparison sorts, in that: inherently
    determine whether or not the list has been sorted. Bubble sort accomplishes this
    by not performing comparisons on objects that were sorted in previous iterations
    and by stopping once the collection proves ordered.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，冒泡排序只是另一种低效的比较排序算法。然而，它确实具有其他比较排序算法所没有的一个显著优点，那就是：**内在地确定列表是否已排序**。冒泡排序通过不在之前迭代中已排序的对象上执行比较，并在集合被证明有序后停止，来实现这一点。
- en: For example, consider the case of ordering a collection in ascending order.
    A bubble sort algorithm will examine an object at index *i* and determine if its
    key is lower in value or priority than the object at index *i + 1,* in which case
    the two objects are swapped.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑按升序对集合进行排序的情况。冒泡排序算法将检查索引 *i* 处的对象，并确定其键值是否低于或优先级低于索引 *i + 1* 处的对象，如果是这样，则交换这两个对象。
- en: 'Given the following set of values:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下值集：
- en: '*S = {50, 25, 73, 21, 3}*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*S = {50, 25, 73, 21, 3}*'
- en: 'The bubble sort algorithm will compare *{i = 0, i = 1}*. Since 50 is greater
    than 25, the two are swapped. Next the method compares *{i = 1, i = 2}*. In this
    case 50 is less than 73, so nothing changes. At *{i = 2, i = 3},* 73 is greater
    than 21 so they are swapped. Finally, at *{i = 3, i = 4}*, 73 is greater than
    3, so they are swapped as well. After our first iteration, our set now looks like
    this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序算法将比较*{i = 0, i = 1}*。由于50大于25，所以这两个数被交换。接下来，方法比较*{i = 1, i = 2}*。在这种情况下，50小于73，所以没有变化。在*{i
    = 2, i = 3}*时，73大于21，所以它们被交换。最后，在*{i = 3, i = 4}*时，73大于3，所以它们也被交换。在我们的第一次迭代之后，我们的集合现在看起来是这样的：
- en: '*S = {25, 50, 21, 3, 73}*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*S = {25, 50, 21, 3, 73}*'
- en: 'Let''s examine another iteration. In this iteration, our algorithm will begin
    by comparing *{i = 0, i = 1}*, and since 25 is less than 50 nothing changes. Next
    we examine *{i = 1, i = 2}*. Since 50 is greater than 21 the two are swapped.
    At *{i = 2, i = 3}*, 50 is greater than 3 so the two are swapped. Since *i = 4*
    was sorted in the previous iteration, the loop halts and resets to position *i
    = 0* for the next iteration. After the second iteration our set looks like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查另一个迭代。在这个迭代中，我们的算法将首先比较*{i = 0, i = 1}*)，由于25小于50，所以没有变化。接下来，我们检查*{i =
    1, i = 2}*)。由于50大于21，所以这两个数被交换。在*{i = 2, i = 3}*时，50大于3，所以这两个数被交换。由于在之前的迭代中*i
    = 4*已被排序，循环停止并重置到*i = 0*以进行下一次迭代。在第二次迭代之后，我们的集合看起来是这样的：
- en: '*S = {25, 21, 3, 50, 73}*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*S = {25, 21, 3, 50, 73}*'
- en: This shows us that iterations through the set consist of *n - j* comparisons,
    where *n* is the number of items in the set and *j* is the current iteration count.
    Therefore, after each iteration the bubble sort becomes *slightly* more efficient.
    Plus, once the set proves to be sorted the iterations stop altogether. Although
    bubble sort has a worst case and an average case complexity of **O**(*n²*), the
    ability to limit the sorting to objects that have not been sorted provides the
    algorithm with a best case complexity of **O**(*n*), making this approach slightly
    better than selection sort but about equal to insertion sort. In certain circumstances
    where the list is already sorted, the bubble sort is also slightly more efficient
    than **quick sort**, which we will discuss later. However, bubble sort is still
    a terribly inefficient algorithm that is unsuitable for all but small collections
    of objects.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明通过集合的迭代包括*n - j*次比较，其中*n*是集合中项目数，*j*是当前迭代计数。因此，每次迭代后，冒泡排序都会变得*稍微*更有效率。此外，一旦集合被证明已排序，迭代就会完全停止。尽管冒泡排序的最坏情况和平均情况复杂度为**O**(*n²*)，但将排序限制为未排序的对象的能力为算法提供了**O**(*n*)的最佳情况复杂度，这使得这种方法略优于选择排序，但与插入排序大致相等。在列表已经排序的某些情况下，冒泡排序也比**快速排序**（我们稍后讨论）稍微有效率。然而，冒泡排序仍然是一个非常低效的算法，不适合除了小型对象集合之外的所有情况。
- en: '**C#**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each of our implementations of the `BubbleSort` method begins by declaring a
    Boolean value named `swapped`. This value is critical to the optimized bubble
    sort method as it is used to track whether any objects were swapped during the
    current iteration. If `true`, there is no guarantee that the list is guaranteed
    so at least one more iteration is required. If `false`, no objects were swapped
    meaning that the list is ordered and the algorithm can stop now.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`BubbleSort`方法的每个实现都是从声明一个名为`swapped`的布尔值开始的。这个值对于优化的冒泡排序方法至关重要，因为它用于跟踪当前迭代过程中是否有任何对象被交换。如果为`true`，则不能保证列表已排序，因此至少还需要进行一次迭代。如果为`false`，则没有对象被交换，这意味着列表已排序，算法可以立即停止。
- en: Next we create a `for` loop that iterates through the members of the collection.
    This loop effectively tracks our current iteration. Inside this loop, we immediately
    set `swapped` variable to `false` and then create another inner loop, which moves
    backward through the collection performing comparisons on the pair of objects.
    If the pair of objects is determined to be out of order, the `BubbleSort()` method calls
    the same `swap()` method examined in the selection sort discussion and then changes
    swapped to true. Otherwise, the execution continues to the next iteration of `j`.
    Once the inner loop is completed, the method checks the `swapped` variable to
    determine if any objects were ordered. If false, the execution continues to the
    next iteration of `i`. Otherwise, the method breaks out of the outer loop and
    the execution is finished.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`for`循环，遍历集合的成员。这个循环有效地跟踪我们的当前迭代。在这个循环内部，我们立即将`swapped`变量设置为`false`，然后创建另一个内部循环，它通过集合向后移动，对成对的对象进行比较。如果成对的两个对象被判定为顺序错误，`BubbleSort()`方法调用在选择排序讨论中检查的相同`swap()`方法，并将`swapped`改为`true`。否则，执行继续到`j`的下一个迭代。一旦内部循环完成，方法检查`swapped`变量以确定是否有对象被排序。如果为`false`，则执行继续到`i`的下一个迭代。否则，方法跳出外部循环，执行结束。
- en: '**Java**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Java implementation is nearly identical in design to the C# implementation,
    except for the name of the array `length` function. However, Java does not support
    passing primitives by reference at all. Although it is possible to emulate this
    behavior by passing the primitive to an instance of a mutable wrapper class, most
    developers agree that this is a bad idea. Instead, our Java implementation performs
    the swap directly inside the `for` loop.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Java实现的设计几乎与C#实现相同，只是数组`length`函数的名称不同。然而，Java根本不支持通过引用传递原始数据类型。尽管可以通过将原始数据类型传递给可变包装类的实例来模拟这种行为，但大多数开发者都认为这是一个糟糕的想法。相反，我们的Java实现直接在`for`循环内部执行交换。
- en: '**Objective-C**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since the `NSArray` variable can only store objects, we need to cast our values
    to `NSNumber`, and when we evaluate the members we need to explicitly examine
    the `intValue`. Like Java, we opt to not create a separate swap method, and pass
    the values by reference. Otherwise, this implementation is fundamentally the same
    as the C# or Java implementations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`NSArray`变量只能存储对象，我们需要将我们的值转换为`NSNumber`，在评估成员时需要显式检查`intValue`。与Java类似，我们选择不创建单独的交换方法，并通过引用传递值。否则，此实现与C#或Java实现基本相同。
- en: '**Swift**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Swift does not permit C-style `for` loops so our method must use the Swift
    3.0 equivalent. Also, since Swift considers arrays to be struct implementations
    instead of class implementations, the `values` parameter cannot be simply passed
    by reference. Therefore, our Swift implementation includes the `inout` decorator
    on the `values` parameter. Otherwise, the functionality is fundamentally the same
    as its predecessors. This rule also applies in our `swap( x: inout Int, y: inout
    Int)` method, which is used to swap the values during the sort.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 'Swift不允许使用C风格的`for`循环，因此我们的方法必须使用Swift 3.0的等效方法。此外，由于Swift将数组视为结构体实现而不是类实现，`values`参数不能简单地通过引用传递。因此，我们的Swift实现包括在`values`参数上的`inout`修饰符。否则，其功能与前辈基本相同。这个规则也适用于我们的`swap(x:
    inout Int, y: inout Int)`方法，该方法在排序过程中用于交换值。'
- en: Quick sort
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速排序
- en: The quick sort is one of a set of algorithms known as **divide-and-conquer**.
    Divide and conquer algorithms work by recursively breaking down a set of objects
    into two or more sub sets until each sub set becomes simple enough to solve directly.
    In the case of quick sort, the algorithm picks an element called a **pivot**,
    and then sorts by moving all smaller items prior to it and greater items after
    it. Moving elements before and after the pivot is the primary component of a quick
    sort algorithm and is referred to as a **partition**. The partition is recursively
    repeated on smaller and smaller sub sets until each sub set contains the 0 or
    1 element, at which point the set is ordered.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序是被称为**分而治之**算法集合中的一员。分而治之算法通过递归地将一组对象分解成两个或更多的子集，直到每个子集足够简单，可以直接解决。在快速排序的情况下，算法选择一个称为**基准点**的元素，然后通过将其前的所有较小元素和其后的所有较大元素进行排序。在基准点前后移动元素是快速排序算法的主要组成部分，被称为**分区**。分区在越来越小的子集上递归重复，直到每个子集包含0或1个元素，此时集合是有序的。
- en: 'Choosing the correct pivot point is critical in maintaining quick sort''s improved
    performance. For example, choosing the smallest or largest element in the list
    will result in **O**(*n²*) complexity. Although there is no bulletproof approach
    for choosing the best pivot, there are fundamentally four approaches your design
    can take:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持快速排序改进性能方面，选择正确的枢轴点至关重要。例如，选择列表中的最小或最大元素将导致**O**(*n²*)复杂度。尽管没有万无一失的方法来选择最佳枢轴，但你的设计可以采取以下四种基本方法：
- en: Always pick the *first* object in the collection.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是选择集合中的**第一个**对象。
- en: Always pick the *median* object in the collection.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是选择集合中的**中值**对象。
- en: Always pick the *last* object in the collection.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是选择集合中的**最后一个**对象。
- en: Choose an object at *random* from the collection.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从集合中随机选择一个对象。
- en: In the following examples, we will take the third approach and choose the last
    object in the collection as the pivot.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将采取第三种方法，选择集合中的最后一个对象作为枢轴。
- en: Although the quick sort algorithm has a worst case complexity of **O**(*n²*)
    like other sorts we have examined thus far, it has a much improved average- and
    best-case complexity of **O**(*n* log(*n*)), cost making it, on average, better
    than the selection, insertion and bubble sort approaches.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管快速排序算法的最坏情况复杂度与其他我们迄今为止检查的排序一样，为**O**(*n²*)，但它具有改进的平均和最佳情况复杂度**O**(*n* log(*n*))，这使得它平均而言比选择排序、插入排序和冒泡排序方法更好。
- en: '**C#**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each of our implementations of the `QuickSort` method begins by checking if
    the low index is less than the high index. If `false`, the sub set is empty or
    has one item so it is ordered by definition and the method returns. If `true`,
    the method first determines the `index` of the next division of sub sets by calling
    the `Partition(int[] values, int low, int high)` method. Next, the `QuickSort(int[]
    values, int low, int high)` method is called recursively on the lower and upper
    sub sets, which are defined based on `index`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`QuickSort`方法的每个实现都是从检查低索引是否小于高索引开始的。如果为`false`，子集为空或有单个项目，因此根据定义它是有序的，方法返回。如果为`true`，方法首先通过调用`Partition(int[]
    values, int low, int high)`方法确定子集下一次划分的`index`。接下来，基于`index`定义的上下子集上递归调用`QuickSort(int[]
    values, int low, int high)`方法。
- en: The real magic in this algorithm occurs in the `Partition(int[] values, int
    low, int high)` method. Here, an `index` variable is defined for the pivot, which
    in our case is the last object in the collection. Next, `i` is defined as the
    `low` index `-1`. Our algorithm then loops through the list from `low` to `high
    -1`. Within the loop, if the value at `i` is less than or equal to the pivot,
    we increment `i`, so we have the index of the first unsorted object in the collection,
    then we swap that unsorted object with the object at `j` which is less than the
    pivot.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法真正的魔力发生在`Partition(int[] values, int low, int high)`方法中。在这里，定义了一个用于枢轴的`index`变量，在我们的例子中是集合中的最后一个对象。接下来，`i`被定义为`low`索引`-1`。然后，我们的算法从`low`到`high
    -1`遍历列表。在循环中，如果`i`处的值小于或等于枢轴，我们就增加`i`，这样我们就有了集合中第一个未排序对象的索引，然后我们将其与`j`处的对象交换，`j`处的对象小于枢轴。
- en: Once the loop is completed we increment `i` one more time because *i + 1* is
    the first object in the collection that is greater than the pivot while every
    object prior to *i + 1* is less than the pivot. Our method swaps the value at
    *i* and the pivot object at index `high` so the pivot is also properly ordered.
    Finally, the method returns `i`, which is the index of the next break point for
    the `QuickSort(int[] values, int low, int high)` method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦循环完成，我们就将`i`增加一次，因为`i + 1`是集合中第一个大于枢轴的对象，而`i + 1`之前的所有对象都小于枢轴。我们的方法交换`i`处的值和索引`high`处的枢轴对象，这样枢轴也被正确排序。最后，方法返回`i`，这是`QuickSort(int[]
    values, int low, int high)`方法的下一个断点索引。
- en: '**Java**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Java implementation is nearly identical in design to the C# implementation,
    except for the name of the array `length` function. However, Java does not support
    passing primitives by reference at all. Although it is possible to emulate this
    behavior by passing the primitive to an instance of a mutable wrapper class, most
    developers agree that this is a bad idea. Instead, our Java implementation performs
    the swap directly inside the `for` loop and the method itself.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Java实现的设计几乎与C#实现相同，只是数组`length`函数的名称不同。然而，Java根本不支持通过引用传递原始数据。尽管可以通过将原始数据传递给可变包装类的实例来模拟这种行为，但大多数开发者都认为这是一个坏主意。相反，我们的Java实现直接在`for`循环内和该方法本身执行交换操作。
- en: '**Objective-C**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since the `NSArray` variable can only store objects, we need to cast our values
    to `NSNumber`, and when we evaluate the members we need to explicitly examine
    the `intValue`. Like Java, we opt to not create a separate swap method and pass
    the values by reference. Otherwise, this implementation is fundamentally the same
    as the C# or Java implementations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `NSArray` 变量只能存储对象，我们需要将我们的值转换为 `NSNumber`，在评估成员时需要显式检查 `intValue`。像 Java
    一样，我们选择不创建单独的交换方法并通过引用传递值。否则，这个实现与 C# 或 Java 实现基本相同。
- en: '**Swift**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Swift does not permit C-style `for` loops so our Swift 3.0 version of the `mergeSort:`
    method is somewhat limited in this case. Therefore, our `for` loop will be replaced
    by a `while` loop. As such, we are define `j` as the `low` index value and increment
    `j` explicitly within each iteration of the `while` loop. Also, since Swift considers
    arrays to be struct implementations instead of class implementations, the `values`
    parameter cannot be simply passed by reference. Therefore, our Swift implementation
    includes the `inout` decorator on the `values` parameter. Otherwise, the functionality
    is fundamentally the same as its predecessors. This rule also applies in our `swap(x:
    inout Int, y: inout Int)` method, which is used to swap the values during the
    sort.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'Swift 不允许使用 C 风格的 `for` 循环，因此我们的 Swift 3.0 版本的 `mergeSort:` 方法在这方面有些受限。因此，我们将使用
    `while` 循环来替换 `for` 循环。这样，我们定义 `j` 为 `low` 索引值，并在 `while` 循环的每次迭代中显式地增加 `j`。另外，由于
    Swift 将数组视为结构体实现而不是类实现，`values` 参数不能简单地通过引用传递。因此，我们的 Swift 实现包括在 `values` 参数上使用
    `inout` 装饰器。否则，其功能与前辈们基本相同。这个规则也适用于我们的 `swap(x: inout Int, y: inout Int)` 方法，该方法用于在排序过程中交换值。'
- en: Merge sort
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 归并排序
- en: '**Merge sort** is another popular version of the divide and conquer algorithm.
    It is a very efficient, general-purpose sort algorithm. The algorithm gets is
    named from the fact that it divides the collection in half, recursively sorts
    each half, and then merges the two sorted halves back together. Each half of the
    collection is repeatedly halved until there is only one object in the half, at
    which point it is sorted by definition. As each sorted half is merged, the algorithm
    compares the objects to determine where to place each sub set.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**归并排序**是分治算法的另一种流行版本。它是一个非常高效、通用的排序算法。算法的命名来源于它将集合分成两半，递归地对每个半集合进行排序，然后将两个排序后的半集合合并在一起。集合的每个半部分都会反复分成一半，直到只剩下一个对象，此时根据定义进行排序。在合并每个排序后的半部分时，算法会比较对象以确定每个子集的放置位置。'
- en: As far as divide and conquer algorithms are concerned, merge sort is one of
    the most efficient algorithms. The algorithm has a worst-, average- and best-
    case complexity of **O**(*n* log(*n*)), making it an improvement over quick sort
    even in the worst circumstances.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 就分治算法而言，归并排序是最有效的算法之一。该算法的最坏、平均和最佳情况复杂度为 **O**(*n* log(*n*))，即使在最坏情况下也优于快速排序。
- en: '**C#**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In each of our implementations of the `MergeSort` method, the `left` and `right`
    parameters define the beginning and end of a collection within the overall `values`
    array. When the method is initially called, the `left` parameter should be 0 and
    the `right` parameter should be the index of the final object in the `values`
    collection.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 `MergeSort` 方法的每个实现中，`left` 和 `right` 参数定义了整体 `values` 数组中集合的开始和结束位置。当方法最初被调用时，`left`
    参数应该是 0，而 `right` 参数应该是 `values` 集合中最后一个对象的索引。
- en: The method begins by checking whether the `left` index is equal to the `right`
    index. If `true`, the sub set is empty or has one item so it is ordered by definition
    and the method returns. Otherwise, the method checks whether the `left` index
    is less than the `right` index. If `false`, the method returns as this sub set
    is already ordered.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先检查 `left` 索引是否等于 `right` 索引。如果是 `true`，子集为空或只有一个项目，因此根据定义是有序的，方法返回。否则，方法检查
    `left` 索引是否小于 `right` 索引。如果是 `false`，方法返回，因为该子集已经是有序的。
- en: If `true`, the method execution begins in earnest. First, the method determines
    the mid point of the current sub set as this will be needed to divide the sub
    set into two new halves. The `middle` variable is declared and defined by adding
    `left` and `right` and dividing the sum by 2\. Next, the `MergeSort(int[] values,
    int left, int right)` method is called recursively on each of the two halves by
    passing the values array and using `left`, `right`, and `middle` as guidelines.
    Following this, the method creates a new array called `temp` of the same size
    as `values`, and populates only the indices that correlate to the current sub
    set. Once the `temp` array is populated, the method creates two `int` variables
    called `index1` and `index2`, which represent the starting points of the two halves
    in the current sub set.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为`true`，方法执行将真正开始。首先，方法确定当前子集的中点，因为这将被用来将子集分成两个新的 halves。声明并定义`middle`变量，通过将`left`和`right`相加然后除以2。接下来，通过传递值数组和使用`left`、`right`和`middle`作为指南，递归地调用每个
    halves 的`MergeSort(int[] values, int left, int right)`方法。随后，方法创建一个名为`temp`的新数组，其大小与`values`相同，并仅填充与当前子集相关的索引。一旦`temp`数组被填充，方法创建两个名为`index1`和`index2`的`int`变量，它们代表当前子集内两个
    halves 的起始点。
- en: 'Finally, we get to the `for` loop, which iterates through the sub set from
    start to finish (`left` to `right`) and orders the values found there. The logic
    in each of these `if` statement is self-explanatory, but it helps to understand
    the reasoning behind these particular comparisons:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达`for`循环，它从开始到结束（`left`到`right`）遍历子集并对找到的值进行排序。每个`if`语句中的逻辑是显而易见的，但了解这些特定比较背后的推理是有帮助的：
- en: The first comparison is only `true` when the left sub set has been exhausted
    of values, at which time the `values[n]` array is set to the value at `temp[index2]`.
    Following this, using the post-increment operator, the `index2` variable is incremented
    by 1 to move the pointer within the right sub set one index to the right.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一次比较仅在左子集耗尽值时为`true`，此时将`values[n]`数组设置为`temp[index2]`的值。随后，使用后增量运算符，`index2`变量增加1，将指针在右子集内向右移动一个索引。
- en: The second comparison is only `true` when the right sub set has been exhausted
    of values, at which time the `values[n]` array is set to the value at `temp[index1]`.
    Following this, using the post-increment operator, `index1` variable is incremented
    by 1 to move the pointer within the left sub set one index to the right.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次比较仅在右子集耗尽值时为`true`，此时将`values[n]`数组设置为`temp[index1]`的值。随后，使用后增量运算符，`index1`变量增加1，将指针在左子集内向右移动一个索引。
- en: The third and final comparison is only evaluated when there are values in both
    the left and right subsets that have not yet been ordered. This comparison is
    `true` when the value at the `temp[index1]` array is less than the value at `temp[index2]`,
    at which time the `values[n]` array is set to `temp[index1]`. Again, following
    this, using the post-increment operator, the `index1` variable is incremented
    by 1 to move the pointer within the left sub set one index to the right.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三次也是最后一次比较仅在左右子集都有尚未排序的值时才会评估。当`temp[index1]`数组中的值小于`temp[index2]`数组中的值时，此比较为`true`，此时将`values[n]`数组设置为`temp[index1]`。同样，随后，使用后增量运算符，`index1`变量增加1，将指针在左子集内向右移动一个索引。
- en: Finally, when all other logical options are false, the default behavior assumes
    that the value at `temp[index1]` array is greater than the value at `temp[index2]`,
    so the else block sets the value at the `values[n]` array to `temp[index2]`. Following
    this, using the post-increment operator, the `index2` variable is incremented
    by 1 to move the pointer within the right sub set one index to the right.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当所有其他逻辑选项都无效时，默认行为假定`temp[index1]`数组中的值大于`temp[index2]`数组中的值，因此else块将`values[n]`数组中的值设置为`temp[index2]`。随后，使用后增量运算符，`index2`变量增加1，将指针在右子集内向右移动一个索引。
- en: '**Java**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Java implementation is nearly identical in design to the C# implementation,
    except for the name of the array `length` function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Java实现的设计几乎与C#实现相同，只是数组`length`函数的名称不同。
- en: '**Objective-C**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Objective-C implementation of `mergeSort:withLeftIndex:andRightIndex:` is
    fundamentally identical to the C# and Java implementations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`mergeSort:withLeftIndex:andRightIndex:`的Objective-C实现与C#和Java实现基本相同。'
- en: '**Swift**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Swift does not permit C-style `for` loops so our method but the Swift 3.0 equivalent
    is somewhat limited for this case. Since Swift considers arrays to be struct implementations
    instead of class implementations, the `values` parameter cannot be simply passed
    by reference. This is not necessarily a problem for this merge sort implementation
    because whenever the method is called recursively the entire `values` array is
    passed as a parameter. However, to make the method more consistent with other
    algorithms being discussed here, and to avoid the need to declare a return type,
    this implementation still includes the `inout` decorator on the `values` parameter.
    Otherwise, the functionality is fundamentally the same as its predecessors.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Swift不允许使用C风格的`for`循环，因此我们的方法与Swift 3.0的等效方法在此情况下有些受限。由于Swift将数组视为结构体实现而不是类实现，`values`参数不能简单地通过引用传递。这对于这个归并排序实现来说并不一定是问题，因为每当方法递归调用时，整个`values`数组都会作为参数传递。然而，为了使该方法与其他在此讨论的算法更一致，并避免需要声明返回类型，此实现仍然在`values`参数上包含了`inout`修饰符。否则，其功能与前辈们基本相同。
- en: Bucket sort
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桶排序
- en: '**Bucket sort**, also known as **bin sort**, is a type of distribution sorting
    algorithm. Distribution sorts are algorithms that scatter the original values
    into any sort of intermediate structures that are then ordered, gathered, and
    merged into the final output structure. It is important to note that, although
    bucket sort is considered a distribution sort, most implementations typically
    leverage a comparison sort to order the contents of the buckets. This algorithm
    sorts values by distributing them throughout an array of arrays that are called
    **buckets**. Elements are distributed based on their value and the range of values
    assigned to each bucket. For example, if one bucket inclusively accepts a range
    of values from 5 to 10, and the original set consists of 3, 5, 7, 9, and 11, the
    values 5, 7, and 9 would be placed in this hypothetical bucket.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**桶排序**，也称为**箱排序**，是一种分布排序算法。分布排序是那些将原始值散布到任何中间结构中的算法，然后对这些中间结构进行排序、收集和合并到最终输出结构中的算法。需要注意的是，尽管桶排序被认为是分布排序，但大多数实现通常利用比较排序来对桶的内容进行排序。该算法通过在整个数组数组（称为**桶**）中分配值来排序值。元素根据其值和分配给每个桶的值范围进行分配。例如，如果一个桶接受从5到10的值范围，原始集合包括3、5、7、9和11，那么值5、7和9将放入这个假设的桶中。'
- en: Once all of the values have been distributed to their respective buckets, the
    buckets themselves are then ordered by recursively calling the bucket sort algorithm
    again. Eventually, each of the buckets is sorted and then the sorted results are
    concatenated into a complete sorted collection.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有值都分配到各自的桶中，然后通过递归调用桶排序算法再次对桶本身进行排序。最终，每个桶都被排序，然后排序结果被连接成一个完整的排序集合。
- en: Bucket sort can be much faster than other sorting algorithms because of how
    elements are assigned to the buckets, typically using an array for each bucket
    where the value represents the index. Although the algorithm still suffers from
    a worst case complexity of **O**(*n²*), the average an best case complexity is
    a mere *O(n + k)*, where *n* is the number of elements in the original array,
    and *k* is the total number of buckets used to sort the collection.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元素分配到桶的方式，桶排序可以比其他排序算法快得多，通常每个桶使用一个数组，其中值表示索引。尽管该算法仍然具有**O**(*n²*)的最坏情况复杂度，但平均和最佳情况复杂度仅为*O(n
    + k)*，其中*n*是原始数组中的元素数量，*k*是用于排序集合的总桶数。
- en: '**C#**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Each of our implementations of the `BucketSort` method begins by creating the
    empty buckets based on the total number of elements in the `values` array. Next,
    a `for` loop is used to populate the buckets with a base value of `0`. This is
    immediately followed by a second `for` loop that distributes the elements from
    values into the various buckets. Finally, a nested `for` loop is used to actually
    sort the elements in the buckets and in turn the `values` array.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`BucketSort`方法的每个实现都是从根据`values`数组中的元素总数创建空桶开始的。接下来，使用`for`循环将基础值`0`填充到桶中。这立即被第二个`for`循环所跟随，该循环将元素从`values`分配到各个桶中。最后，使用嵌套`for`循环对桶中的元素以及`values`数组本身进行排序。
- en: '**Java**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The Java implementation is nearly identical in design to the C# implementation,
    except for the name of the array `length` function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Java实现的设计几乎与C#实现相同，只是数组的`length`函数名称不同。
- en: '**Objective-C**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since the `NSArray` array can only store objects, we need to cast our values
    to the `NSNumber` array, and when we evaluate the members we need to explicitly
    examine the `intValue` variable. Otherwise, this implementation is fundamentally
    the same as the C# or Java implementations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`NSArray`数组只能存储对象，我们需要将我们的值转换为`NSNumber`数组，并且在评估成员时需要显式检查`intValue`变量。否则，这种实现与C#或Java实现的基本上是相同的。
- en: '**Swift**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Swift does not permit C-style `for` loops so our method must use the Swift 3.0
    equivalent. Otherwise, the functionality is fundamentally the same as its predecessors.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Swift不允许使用C风格的`for`循环，因此我们的方法必须使用Swift 3.0的等效方法。否则，其功能与其前辈基本相同。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we discussed several of the more common sorting algorithms you
    might encounter in your day-to-day experience. We started with several comparison
    sorts including selection, insertion, and bubble. We noted that a selection sort
    is perhaps the most inefficient sorting algorithm you are likely to encounter
    in the real world, but that's not to say that it is completely academic. Insertion
    sort somewhat improves on selection, as does the bubble sorting algorithm. Next,
    we examined two divide and conquer sorting algorithms including quick sort and
    merge sort. Both of these approaches are much more efficient than comparison sorts.
    Finally, we explored a common and highly efficient distribution sort called the
    counting sort. The counting sort is the most efficient algorithm we examined,
    but it is not necessarily the best fit for every situation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了你在日常经验中可能会遇到的几种常见排序算法。我们首先介绍了几种比较排序，包括选择排序、插入排序和冒泡排序。我们指出，选择排序可能是你在现实生活中可能遇到的最不高效的排序算法，但这并不意味着它是完全学术性的。插入排序在某种程度上改进了选择排序，冒泡排序算法也是如此。接下来，我们考察了两种分而治之的排序算法，包括快速排序和归并排序。这两种方法都比比较排序更高效。最后，我们探索了一种常见且高效的分布排序，称为计数排序。计数排序是我们考察过的最有效率的算法，但它并不一定适合所有情况。
