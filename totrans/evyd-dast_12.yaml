- en: 'Chapter 12. Sorting: Bringing Order Out Of Chaos'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to build the right data structure or collection class for a particular
    application is only half the battle. Unless the data sets in your problem domain
    are very small, any collection of your data will benefit from a little organization.
    Organizing the elements in your list or collection by a particular value or set
    of values is known as **sorting**.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting your data is not strictly necessary, but doing so makes searching or
    lookup operations much more efficient. Likewise, when you need to merge multiple
    collections of data together, having the various collections sorted in advance
    of the merge can greatly improve the efficiency of the merge operation.
  prefs: []
  type: TYPE_NORMAL
- en: If your data is a collection of numeric values, then sorting can be something
    as simple as arranging it in ascending or descending order. However, if your data
    consists of complex objects, you can sort the collection by a particular value.
    In this case, the field or property by which the data is sorted is referred to
    as a **key**. For example, if you have a collection of car objects and you want
    to sort them by their make, such as Ford, Chevrolet or Dodge, then the make is
    the key. However, if you wanted to sort by multiple keys, say the make and model,
    then the make becomes the *primary key*, while the model becomes the *secondary
    key*. Further extensions of this pattern would result in *tertiary keys*, *Quaternary keys*,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting algorithms come in many shapes and sizes, and many of them are specifically
    suited to particular types of data structures. Although an exhaustive examination
    of known or even just popular sorting algorithms is beyond the scope of this book,
    in this chapter, we will focus on those algorithms that are either fairly common
    or are well suited to some of the data structures we have already examined. In
    each case, we will review examples in each of the four languages we have been
    looking at and discuss the complexity cost. In this chapter, we will cover the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Selection sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insertion sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bubble sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merge sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bucket sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A selection sort can be described as an in-place comparison. This algorithm
    divides a collection or list of objects into two parts. The first is a subset
    of objects that have already been sorted, ranging from *0* to *i,* where *i* is
    the next object to be sorted. The second is a subset of objects that have not
    been sorted, ranging from *i* to *n,* where *n* is the length of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: The selection sort algorithm works by taking the smallest or largest value in
    a collection and placing it at the beginning of the unsorted subarray by swapping
    it with the object at the current index. For example, consider ordering a collection
    in ascending order. At the outset, the sorted subarray will consist of 0 members,
    while the unsorted subarray will consist of all the members in the set. The selection
    sort algorithm will find the smallest member in the unsorted subarray and place
    it at the beginning of the unsorted subarray.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the sorted subarray consists of one member, while the unsorted
    subarray consists of all the remaining members in the original set. This process
    will repeat until all members of the unsorted subarray have been placed in the
    sorted subarray.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following set of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S = {50, 25, 73, 21, 3}*'
  prefs: []
  type: TYPE_NORMAL
- en: Our algorithm will find the smallest value in *S[0...4]*, which in this case
    is *3*, and place it at the beginning of *S[0...4]:*
  prefs: []
  type: TYPE_NORMAL
- en: '*S = {3, 25, 73, 21, 50}*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is repeated for *S[1...4]*, which returns the value 21:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S = {3, 21, 73, 25, 50}*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next evaluation at *S[2...4]* returns a value of 25:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S = {3, 21, 25, 73, 50}*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the function repeats again for *S[3...4]* which returns the smallest
    value of 50:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S = {3, 21, 25, 50, 73}*'
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to examine the last object in the collection because it, by
    necessity, is already the largest remaining value. This is a small consolation,
    however, because the selection sort algorithm still has an **O**(*n²*) complexity
    cost. Moreover, this worst-case complexity score doesn't tell the whole tale in
    this particular case. The selection sort is always an **O**(*n²*) complexity,
    even under the best of circumstances. Therefore, the selection sort is quite possibly
    the slowest and most inefficient sorting algorithm you may encounter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each of the code examples in this chapter will examine algorithms in the form
    of those methods most essential to the operation, with these being detached from
    their parent classes. Additionally, in each case the collection of objects being
    sorted will be defined at the class level, outside of the example code shown here.
    Likewise, the subsequent object instantiation and population of those collections
    will be defined outside the example code. To see the full class examples, please
    use the code examples accompanying this text.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each of our implementations of the `SelectionSort` method begins by confirming
    that the `values` array has at least two members. If not, the method returns as
    there are not enough members to sort. Otherwise, we create two nested loops. The
    outer `for` loop moves the boundary of the unsorted array one index at a time,
    while the inner `for` loop is used to find the minimum value within the unsorted
    boundary. Once we have a minimum value, the method swaps the member at `i` with
    the member identified as the current minimum. Since C# does not support passing
    primitives by reference by default we must explicitly invoke the `ref` keyword
    on both the `swap(ref int x, ref int y)` method signature as well as the called
    parameter. Although it may seem like more work to create a separate `swap` method
    for this purpose, the swap functionality is common to several popular sorting
    algorithms and having this code in a separate method saves us some keystrokes
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Nested for loops**'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that nested loops will automatically increase the complexity of an
    algorithm exponentially. Any algorithm with a `for` loop has a complexity cost
    of **O**(n), but once you nest another `for` loop within the first the complexity
    cost increases to **O**(n²). Nesting another `for` loop within the second makes
    the cost **O**(n³), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that nesting `for` loops in any implementation will be a red flag
    to an observant reviewer and you should always be ready to justify such a design.
    Only nest for loops when you absolutely must.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Java implementation is nearly identical in design to the C# implementation,
    except for the name of the array `length` function. However, Java does not support
    passing primitives by reference at all. Although it is possible to emulate this
    behavior by passing the primitive to an instance of a mutable wrapper class, most
    developers agree that this is a bad idea. Instead, our Java implementation performs
    the swap directly inside the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since `NSArray` can only store objects, we need to cast our values to `NSNumber`,
    and when we evaluate the members we need to explicitly examine the `intValue`
    object. Like Java, we opt to not create a separate swap method and pass the values
    by reference. Otherwise, implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift does not permit C-style `for` loops so our method must use the Swift
    3.0 equivalent. Also, since Swift considers arrays to be `struct` implementations
    instead of class implementations, the `values` parameter cannot be simply passed
    by reference. Therefore, our Swift implementation includes the `inout` decorator
    on the `values` parameter. Otherwise, the functionality is fundamentally the same
    as its predecessors. This rule also applies in our `swap( x: inout Int, y: inout
    Int)` method, which is used to swap the values during the sort.'
  prefs: []
  type: TYPE_NORMAL
- en: Insertion sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **insertion sort** is a very simple algorithm that looks at an object in
    a collection and compares its key to the keys prior to itself. You can visualize
    this process as how many of us order a hand of playing cards, individually removing
    and inserting cards from left to right in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the case of ordering a collection in ascending order.
    An insertion sort algorithm will examine an object at index *i* and determine
    if it's key is lower in value or priority than the object at index *i - 1*. If
    so, the object at *i* is removed and inserted at *i - 1*. At this point, the function
    will repeat and continue to loop in this manner until the object key at *i - 1*
    is not lower than the object key at *i*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following set of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S = {50, 25, 73, 21, 3}*'
  prefs: []
  type: TYPE_NORMAL
- en: Our algorithm will begin examining the list at *i = 1*. We do this because at
    *i = 0*, *i - 1* is a non-existent value and would require special handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since 25 is less than 50, it is removed and reinserted at *i = 0*. Since we''re
    at index 0, there is nothing left to examine to the left of 25, so this iteration
    is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S = {25, 50, 73, 21, 3}*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we examine *i = 2*. Because 73 is not less than 50, this value doesn''t
    need to move. Since we have already sorted everything to the left of *i = 2*,
    this iteration is immediately completed. At *i = 3*, the value 21 is less than
    73 and so it is removed and reinserted at *i = 2*. Checking again, 21 is less
    than 50, so the value 21 is removed and reinserted at index 1\. Finally, 21 is
    less than 25, so the value 21 is removed and reinserted at *i = 0*. Since we''re
    now at index 0, there is nothing left to examine to the left of 21, so this iteration
    are complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S = {21, 25, 50, 73, 3}*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we come to *i = 4*, the end of the list. Since 3 is less than 21,
    the value 3 is removed and reinserted at *i = 3*. Next, 3 is less than 73, so
    the value 3 is removed and reinserted at *i = 2*. At *i = 2*, 3 is less than 50
    so the value 3 is removed and reinserted at *i = 1*. At *i = 1*, 3 is less than
    25 so the value 3 is removed and reinserted at *i = 0*. Since we''re now at index
    0, there is nothing left to examine to the left of 3 so this iteration, and our
    sorting function, are complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S = {3, 21, 25, 50, 73}*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see this algorithm is simple but also potentially expensive for larger
    lists of objects or values. The insertion sort has a worst-case and even an *average-*case
    complexity of **O**(*n²*). However, unlike selection sort, insertion sort has
    improved efficiency when sorting lists that were previously sorted. As a result,
    it enjoys a best-case complexity of **O**(*n*), making this algorithm a slightly
    better choice than selection sort.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each of our implementations of the `InsertionSort` method begins by confirming
    that the `values` array has at least two members. If not, the method returns as
    there are not enough members to sort. Otherwise, two integer variables are declared
    named `j` and `value`. Next a `for` loop is created that iterates through the
    members of the collection. The index `i` is used to track the position of the
    last sorted member. Within this for loop, `value` is assigned to the last sorted
    member while `j` is used to track the position in the current iteration through
    the unsorted members. Our `while` loop continues until `j` is equal to `0` and
    the value at index `j` is greater than the value at index `i`. In every iteration
    of the `while` loop, we swap the member at position `j` with the member at position
    `j + 1`, then the loop decrements the value of `j` by 1 to move back through the
    collection. Finally, the last step is to set the member stored in `value` at position
    `j + 1`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Java implementation is nearly identical in design to the C# implementation,
    except for the name of the array `length` function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Since `NSArray` can only store objects, we need to cast our values to the `NSNumber`
    variable, and when we evaluate the members we need to explicitly examine the `intValue`
    variable. Otherwise, this implementation is fundamentally the same as the C# or
    Java implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Swift does not permit C-style `for` loops, so our method must use the Swift
    3.0 equivalent. Also, since Swift considers arrays to be struct implementations
    instead of class implementations, the `values` parameter cannot be simply passed
    by reference. Therefore, our Swift implementation includes the `inout` decorator
    on the `values` parameter. Otherwise, the functionality is fundamentally the same
    as its predecessors.
  prefs: []
  type: TYPE_NORMAL
- en: Bubble sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Bubble sort** is another simple algorithm that steps through the list of
    values or objects to be sorted and compares adjacent items or their keys to determine
    if they are in the wrong order. The name comes from the way that unordered items
    seem to bubble to the top of the list. However, some developers sometimes refer
    to this as a **sinking sort**, as objects could just as easily appear to be dropping
    down through the list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, the bubble sort is just another inefficient comparison sort. However,
    it does have one distinct advantage over other comparison sorts, in that: inherently
    determine whether or not the list has been sorted. Bubble sort accomplishes this
    by not performing comparisons on objects that were sorted in previous iterations
    and by stopping once the collection proves ordered.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the case of ordering a collection in ascending order.
    A bubble sort algorithm will examine an object at index *i* and determine if its
    key is lower in value or priority than the object at index *i + 1,* in which case
    the two objects are swapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following set of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S = {50, 25, 73, 21, 3}*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bubble sort algorithm will compare *{i = 0, i = 1}*. Since 50 is greater
    than 25, the two are swapped. Next the method compares *{i = 1, i = 2}*. In this
    case 50 is less than 73, so nothing changes. At *{i = 2, i = 3},* 73 is greater
    than 21 so they are swapped. Finally, at *{i = 3, i = 4}*, 73 is greater than
    3, so they are swapped as well. After our first iteration, our set now looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S = {25, 50, 21, 3, 73}*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine another iteration. In this iteration, our algorithm will begin
    by comparing *{i = 0, i = 1}*, and since 25 is less than 50 nothing changes. Next
    we examine *{i = 1, i = 2}*. Since 50 is greater than 21 the two are swapped.
    At *{i = 2, i = 3}*, 50 is greater than 3 so the two are swapped. Since *i = 4*
    was sorted in the previous iteration, the loop halts and resets to position *i
    = 0* for the next iteration. After the second iteration our set looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S = {25, 21, 3, 50, 73}*'
  prefs: []
  type: TYPE_NORMAL
- en: This shows us that iterations through the set consist of *n - j* comparisons,
    where *n* is the number of items in the set and *j* is the current iteration count.
    Therefore, after each iteration the bubble sort becomes *slightly* more efficient.
    Plus, once the set proves to be sorted the iterations stop altogether. Although
    bubble sort has a worst case and an average case complexity of **O**(*n²*), the
    ability to limit the sorting to objects that have not been sorted provides the
    algorithm with a best case complexity of **O**(*n*), making this approach slightly
    better than selection sort but about equal to insertion sort. In certain circumstances
    where the list is already sorted, the bubble sort is also slightly more efficient
    than **quick sort**, which we will discuss later. However, bubble sort is still
    a terribly inefficient algorithm that is unsuitable for all but small collections
    of objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Each of our implementations of the `BubbleSort` method begins by declaring a
    Boolean value named `swapped`. This value is critical to the optimized bubble
    sort method as it is used to track whether any objects were swapped during the
    current iteration. If `true`, there is no guarantee that the list is guaranteed
    so at least one more iteration is required. If `false`, no objects were swapped
    meaning that the list is ordered and the algorithm can stop now.
  prefs: []
  type: TYPE_NORMAL
- en: Next we create a `for` loop that iterates through the members of the collection.
    This loop effectively tracks our current iteration. Inside this loop, we immediately
    set `swapped` variable to `false` and then create another inner loop, which moves
    backward through the collection performing comparisons on the pair of objects.
    If the pair of objects is determined to be out of order, the `BubbleSort()` method calls
    the same `swap()` method examined in the selection sort discussion and then changes
    swapped to true. Otherwise, the execution continues to the next iteration of `j`.
    Once the inner loop is completed, the method checks the `swapped` variable to
    determine if any objects were ordered. If false, the execution continues to the
    next iteration of `i`. Otherwise, the method breaks out of the outer loop and
    the execution is finished.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The Java implementation is nearly identical in design to the C# implementation,
    except for the name of the array `length` function. However, Java does not support
    passing primitives by reference at all. Although it is possible to emulate this
    behavior by passing the primitive to an instance of a mutable wrapper class, most
    developers agree that this is a bad idea. Instead, our Java implementation performs
    the swap directly inside the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since the `NSArray` variable can only store objects, we need to cast our values
    to `NSNumber`, and when we evaluate the members we need to explicitly examine
    the `intValue`. Like Java, we opt to not create a separate swap method, and pass
    the values by reference. Otherwise, this implementation is fundamentally the same
    as the C# or Java implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift does not permit C-style `for` loops so our method must use the Swift
    3.0 equivalent. Also, since Swift considers arrays to be struct implementations
    instead of class implementations, the `values` parameter cannot be simply passed
    by reference. Therefore, our Swift implementation includes the `inout` decorator
    on the `values` parameter. Otherwise, the functionality is fundamentally the same
    as its predecessors. This rule also applies in our `swap( x: inout Int, y: inout
    Int)` method, which is used to swap the values during the sort.'
  prefs: []
  type: TYPE_NORMAL
- en: Quick sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The quick sort is one of a set of algorithms known as **divide-and-conquer**.
    Divide and conquer algorithms work by recursively breaking down a set of objects
    into two or more sub sets until each sub set becomes simple enough to solve directly.
    In the case of quick sort, the algorithm picks an element called a **pivot**,
    and then sorts by moving all smaller items prior to it and greater items after
    it. Moving elements before and after the pivot is the primary component of a quick
    sort algorithm and is referred to as a **partition**. The partition is recursively
    repeated on smaller and smaller sub sets until each sub set contains the 0 or
    1 element, at which point the set is ordered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Choosing the correct pivot point is critical in maintaining quick sort''s improved
    performance. For example, choosing the smallest or largest element in the list
    will result in **O**(*n²*) complexity. Although there is no bulletproof approach
    for choosing the best pivot, there are fundamentally four approaches your design
    can take:'
  prefs: []
  type: TYPE_NORMAL
- en: Always pick the *first* object in the collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always pick the *median* object in the collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always pick the *last* object in the collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose an object at *random* from the collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following examples, we will take the third approach and choose the last
    object in the collection as the pivot.
  prefs: []
  type: TYPE_NORMAL
- en: Although the quick sort algorithm has a worst case complexity of **O**(*n²*)
    like other sorts we have examined thus far, it has a much improved average- and
    best-case complexity of **O**(*n* log(*n*)), cost making it, on average, better
    than the selection, insertion and bubble sort approaches.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Each of our implementations of the `QuickSort` method begins by checking if
    the low index is less than the high index. If `false`, the sub set is empty or
    has one item so it is ordered by definition and the method returns. If `true`,
    the method first determines the `index` of the next division of sub sets by calling
    the `Partition(int[] values, int low, int high)` method. Next, the `QuickSort(int[]
    values, int low, int high)` method is called recursively on the lower and upper
    sub sets, which are defined based on `index`.
  prefs: []
  type: TYPE_NORMAL
- en: The real magic in this algorithm occurs in the `Partition(int[] values, int
    low, int high)` method. Here, an `index` variable is defined for the pivot, which
    in our case is the last object in the collection. Next, `i` is defined as the
    `low` index `-1`. Our algorithm then loops through the list from `low` to `high
    -1`. Within the loop, if the value at `i` is less than or equal to the pivot,
    we increment `i`, so we have the index of the first unsorted object in the collection,
    then we swap that unsorted object with the object at `j` which is less than the
    pivot.
  prefs: []
  type: TYPE_NORMAL
- en: Once the loop is completed we increment `i` one more time because *i + 1* is
    the first object in the collection that is greater than the pivot while every
    object prior to *i + 1* is less than the pivot. Our method swaps the value at
    *i* and the pivot object at index `high` so the pivot is also properly ordered.
    Finally, the method returns `i`, which is the index of the next break point for
    the `QuickSort(int[] values, int low, int high)` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The Java implementation is nearly identical in design to the C# implementation,
    except for the name of the array `length` function. However, Java does not support
    passing primitives by reference at all. Although it is possible to emulate this
    behavior by passing the primitive to an instance of a mutable wrapper class, most
    developers agree that this is a bad idea. Instead, our Java implementation performs
    the swap directly inside the `for` loop and the method itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since the `NSArray` variable can only store objects, we need to cast our values
    to `NSNumber`, and when we evaluate the members we need to explicitly examine
    the `intValue`. Like Java, we opt to not create a separate swap method and pass
    the values by reference. Otherwise, this implementation is fundamentally the same
    as the C# or Java implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift does not permit C-style `for` loops so our Swift 3.0 version of the `mergeSort:`
    method is somewhat limited in this case. Therefore, our `for` loop will be replaced
    by a `while` loop. As such, we are define `j` as the `low` index value and increment
    `j` explicitly within each iteration of the `while` loop. Also, since Swift considers
    arrays to be struct implementations instead of class implementations, the `values`
    parameter cannot be simply passed by reference. Therefore, our Swift implementation
    includes the `inout` decorator on the `values` parameter. Otherwise, the functionality
    is fundamentally the same as its predecessors. This rule also applies in our `swap(x:
    inout Int, y: inout Int)` method, which is used to swap the values during the
    sort.'
  prefs: []
  type: TYPE_NORMAL
- en: Merge sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Merge sort** is another popular version of the divide and conquer algorithm.
    It is a very efficient, general-purpose sort algorithm. The algorithm gets is
    named from the fact that it divides the collection in half, recursively sorts
    each half, and then merges the two sorted halves back together. Each half of the
    collection is repeatedly halved until there is only one object in the half, at
    which point it is sorted by definition. As each sorted half is merged, the algorithm
    compares the objects to determine where to place each sub set.'
  prefs: []
  type: TYPE_NORMAL
- en: As far as divide and conquer algorithms are concerned, merge sort is one of
    the most efficient algorithms. The algorithm has a worst-, average- and best-
    case complexity of **O**(*n* log(*n*)), making it an improvement over quick sort
    even in the worst circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In each of our implementations of the `MergeSort` method, the `left` and `right`
    parameters define the beginning and end of a collection within the overall `values`
    array. When the method is initially called, the `left` parameter should be 0 and
    the `right` parameter should be the index of the final object in the `values`
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: The method begins by checking whether the `left` index is equal to the `right`
    index. If `true`, the sub set is empty or has one item so it is ordered by definition
    and the method returns. Otherwise, the method checks whether the `left` index
    is less than the `right` index. If `false`, the method returns as this sub set
    is already ordered.
  prefs: []
  type: TYPE_NORMAL
- en: If `true`, the method execution begins in earnest. First, the method determines
    the mid point of the current sub set as this will be needed to divide the sub
    set into two new halves. The `middle` variable is declared and defined by adding
    `left` and `right` and dividing the sum by 2\. Next, the `MergeSort(int[] values,
    int left, int right)` method is called recursively on each of the two halves by
    passing the values array and using `left`, `right`, and `middle` as guidelines.
    Following this, the method creates a new array called `temp` of the same size
    as `values`, and populates only the indices that correlate to the current sub
    set. Once the `temp` array is populated, the method creates two `int` variables
    called `index1` and `index2`, which represent the starting points of the two halves
    in the current sub set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we get to the `for` loop, which iterates through the sub set from
    start to finish (`left` to `right`) and orders the values found there. The logic
    in each of these `if` statement is self-explanatory, but it helps to understand
    the reasoning behind these particular comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: The first comparison is only `true` when the left sub set has been exhausted
    of values, at which time the `values[n]` array is set to the value at `temp[index2]`.
    Following this, using the post-increment operator, the `index2` variable is incremented
    by 1 to move the pointer within the right sub set one index to the right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second comparison is only `true` when the right sub set has been exhausted
    of values, at which time the `values[n]` array is set to the value at `temp[index1]`.
    Following this, using the post-increment operator, `index1` variable is incremented
    by 1 to move the pointer within the left sub set one index to the right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third and final comparison is only evaluated when there are values in both
    the left and right subsets that have not yet been ordered. This comparison is
    `true` when the value at the `temp[index1]` array is less than the value at `temp[index2]`,
    at which time the `values[n]` array is set to `temp[index1]`. Again, following
    this, using the post-increment operator, the `index1` variable is incremented
    by 1 to move the pointer within the left sub set one index to the right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, when all other logical options are false, the default behavior assumes
    that the value at `temp[index1]` array is greater than the value at `temp[index2]`,
    so the else block sets the value at the `values[n]` array to `temp[index2]`. Following
    this, using the post-increment operator, the `index2` variable is incremented
    by 1 to move the pointer within the right sub set one index to the right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The Java implementation is nearly identical in design to the C# implementation,
    except for the name of the array `length` function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The Objective-C implementation of `mergeSort:withLeftIndex:andRightIndex:` is
    fundamentally identical to the C# and Java implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Swift does not permit C-style `for` loops so our method but the Swift 3.0 equivalent
    is somewhat limited for this case. Since Swift considers arrays to be struct implementations
    instead of class implementations, the `values` parameter cannot be simply passed
    by reference. This is not necessarily a problem for this merge sort implementation
    because whenever the method is called recursively the entire `values` array is
    passed as a parameter. However, to make the method more consistent with other
    algorithms being discussed here, and to avoid the need to declare a return type,
    this implementation still includes the `inout` decorator on the `values` parameter.
    Otherwise, the functionality is fundamentally the same as its predecessors.
  prefs: []
  type: TYPE_NORMAL
- en: Bucket sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Bucket sort**, also known as **bin sort**, is a type of distribution sorting
    algorithm. Distribution sorts are algorithms that scatter the original values
    into any sort of intermediate structures that are then ordered, gathered, and
    merged into the final output structure. It is important to note that, although
    bucket sort is considered a distribution sort, most implementations typically
    leverage a comparison sort to order the contents of the buckets. This algorithm
    sorts values by distributing them throughout an array of arrays that are called
    **buckets**. Elements are distributed based on their value and the range of values
    assigned to each bucket. For example, if one bucket inclusively accepts a range
    of values from 5 to 10, and the original set consists of 3, 5, 7, 9, and 11, the
    values 5, 7, and 9 would be placed in this hypothetical bucket.'
  prefs: []
  type: TYPE_NORMAL
- en: Once all of the values have been distributed to their respective buckets, the
    buckets themselves are then ordered by recursively calling the bucket sort algorithm
    again. Eventually, each of the buckets is sorted and then the sorted results are
    concatenated into a complete sorted collection.
  prefs: []
  type: TYPE_NORMAL
- en: Bucket sort can be much faster than other sorting algorithms because of how
    elements are assigned to the buckets, typically using an array for each bucket
    where the value represents the index. Although the algorithm still suffers from
    a worst case complexity of **O**(*n²*), the average an best case complexity is
    a mere *O(n + k)*, where *n* is the number of elements in the original array,
    and *k* is the total number of buckets used to sort the collection.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Each of our implementations of the `BucketSort` method begins by creating the
    empty buckets based on the total number of elements in the `values` array. Next,
    a `for` loop is used to populate the buckets with a base value of `0`. This is
    immediately followed by a second `for` loop that distributes the elements from
    values into the various buckets. Finally, a nested `for` loop is used to actually
    sort the elements in the buckets and in turn the `values` array.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The Java implementation is nearly identical in design to the C# implementation,
    except for the name of the array `length` function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since the `NSArray` array can only store objects, we need to cast our values
    to the `NSNumber` array, and when we evaluate the members we need to explicitly
    examine the `intValue` variable. Otherwise, this implementation is fundamentally
    the same as the C# or Java implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Swift does not permit C-style `for` loops so our method must use the Swift 3.0
    equivalent. Otherwise, the functionality is fundamentally the same as its predecessors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we discussed several of the more common sorting algorithms you
    might encounter in your day-to-day experience. We started with several comparison
    sorts including selection, insertion, and bubble. We noted that a selection sort
    is perhaps the most inefficient sorting algorithm you are likely to encounter
    in the real world, but that's not to say that it is completely academic. Insertion
    sort somewhat improves on selection, as does the bubble sorting algorithm. Next,
    we examined two divide and conquer sorting algorithms including quick sort and
    merge sort. Both of these approaches are much more efficient than comparison sorts.
    Finally, we explored a common and highly efficient distribution sort called the
    counting sort. The counting sort is the most efficient algorithm we examined,
    but it is not necessarily the best fit for every situation.
  prefs: []
  type: TYPE_NORMAL
