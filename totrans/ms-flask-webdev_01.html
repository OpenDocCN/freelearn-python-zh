<html><head></head><body>
        

                            
                    <h1 class="header-title">Getting Started</h1>
                
            
            
                
<p>Over the course of this book, you will be introduced to multiple concepts that will enable you to build a complete modern web application. You will progress from a "Hello world" web page to a complete web application that uses databases, caches, asynchronous task processing, authentication, role-based access, a REST API, and internationalization. You will learn a comprehensive way of structuring your application so that it can grow effortlessly. To choose between SQL and NoSQL technologies, you will learn how to use the most common Flask extensions to help you leverage multiple technologies, from sending emails to authentication using social media accounts. Toward the end, you will learn how to write tests, build a modern continuous integration/delivery pipeline with Docker and Jenkins, deploy your application to multiple cloud services, and know how to deal with high availability and scaling. We will tackle all of these topics with a simple and practical approach. </p>
<p><strong>Flask</strong> is the Python web framework that we are going to use. It has a very well-designed API, is very easy to learn, and makes no assumptions whatsoever as to what technology stack you are going to use, so it won't get in your way. Flask has a micro footprint, but leverages an extension system that contains hundreds of packages from a very active and vibrant community.</p>
<p>In this first chapter, you will learn how to set up your development environment and build your first Flask application. We will be covering the following topics:</p>
<ul>
<li>Setting up and learning how to use Git, a powerful version control system</li>
<li>Learning pip, the Python management system, and how to create virtual environments with different setups</li>
<li>Setting up and learning the basic facts about Docker</li>
<li>Building a first simple Flask application</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Version control with Git</h1>
                
            
            
                
<p>Using Python or any other language requires you to use a version control system. A version control system is a tool that records changes in files over time. This allows a programmer to revert to an earlier version of the file and identify bugs more easily. You can test new ideas without fear of breaking your current code, and your team can work using a predefined workflow without stepping on each others' toes. Git was developed by Linus Torvalds, the father of Linux. It's decentralized, light, and has great features that get the job done the right way.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Git</h1>
                
            
            
                
<p>Installing Git is very simple. Simply go to <a href="http://www.git-scm.com/downloads">http://www.git-scm.com/downloads</a> and click on the <strong>operating system</strong> (<strong>OS</strong>) that is being run. A program will begin to download will walk you through the basic installation process.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Git on Windows</h1>
                
            
            
                
<p>Git was originally solely developed for Unix OSes (for example, Linux and macOS X). Consequently, using Git on Windows is not seamless. During the installation, the installer will ask whether you want to install Git alongside the normal Windows Command Prompt. Do not pick this option. Choose the default option that will install a new type of command processor on your system named <strong>Bash</strong> (<strong>Bourne-again shell</strong>), which is the same command processor that the Unix systems use. Bash is much more powerful than the default Windows command line, and this is what we will be using for all the examples in this book.</p>
<p>A good introduction to Bash for beginners can be found at <a href="http://linuxcommand.org">http://linuxcommand.org</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Git basics</h1>
                
            
            
                
<p>Git is a very complex tool; only the basics that are needed for this book will be covered in this section.</p>
<p class="mce-root"/>
<p>To learn more, refer to the Git documentation at <a href="http://www.git-scm.com/doc" target="_blank">http://www.git-scm.com/doc</a>.</p>
<p>Git does not track your changes automatically. In order for Git to run properly, we have to give it the following information:</p>
<ul>
<li>Which folders to track</li>
<li>When to save the state of the code</li>
<li>What to track and what not to track</li>
</ul>
<p>Before we can do anything, we have to tell Git to initialize a new <kbd>git</kbd> repository in our directory. Run the following code on your Terminal:</p>
<pre><strong>$ git init</strong></pre>
<p>Git will now start to track changes in our project. As <kbd>git</kbd> tracks our files, we can see the status of our tracked files and any files that are not tracked by typing the following command:</p>
<pre><strong>$ git status</strong></pre>
<p>Now we can save our first <kbd>commit</kbd>, which is a snapshot of our code at the time that we run the <kbd>commit</kbd> command:</p>
<pre># In Bash, comments are marked with a #, just like Python
# Add any files that have changes and you wish to save in this      <br/># commit
<strong>$ git add main.py</strong>
# Commit the changes, add in your commit message with -m
<strong>$ git commit -m "Our first commit"</strong></pre>
<p>Now, at any point in the future, we can return to this point in our project. Adding files that are to be committed is called <strong>staging</strong> files in Git. Remember that you should only add stage files if you are ready to commit them. Once the files are staged, any further changes will not be staged. For an example of more advanced Git usage, add any text to your <kbd>main.py</kbd> file with your text editor and then run the following:</p>
<pre>    <strong># To see the changes from the last commit</strong>
    <strong>$ git diff</strong>
    <strong># To see the history of your changes</strong>
    <strong>$ git log</strong>
    <strong># As an example, we will stage main.py</strong>
    <strong># and then remove any added files from the stage</strong>
    <strong>$ git add main.py</strong>
    <strong>$ git status</strong>
    <strong>$ git reset HEAD main.py</strong>
    <strong># After any complicated changes, be sure to run status</strong>
    <strong># to make sure everything went well</strong>
    <strong>$ git status</strong>
    <strong># lets delete the changes to main.py, reverting to its state at the   <br/>   </strong> # last commit # This can only be run on files that aren't staged
    <strong>$ git checkout -- main.py</strong></pre>
<p>Your terminal should look something like the following:</p>
<div><img class="aligncenter size-full wp-image-529 image-border" src="img/439bbf17-d71e-43d9-829a-33dac6a93832.png" style="width:33.00em;height:40.75em;"/></div>
<p>Note that in the preceding example I have modified the <kbd>main.py</kbd> file by adding the comment <kbd># Changed to show the git diff command</kbd>.</p>
<p>One important step to include in every Git repository is a <kbd>.gitignore</kbd> file. This file tells Git what files to ignore. This way you can safely commit and add all your files. The following are some common files that you can ignore:</p>
<ul>
<li>Python's byte code files (<kbd>*.pyc</kbd>)</li>
<li>Databases (specially for our examples using SQLLite database files) (<kbd>*.db</kbd>)</li>
<li>Secrets (never push secrets (password, keys, and so on) to your repositories)</li>
<li>IDE metadata files (<kbd>.idea</kbd>)</li>
<li>The <kbd>Virtualenv</kbd> directory (<kbd>env</kbd> or <kbd>venv</kbd>)</li>
</ul>
<p>Here's a simple example of a <kbd>gitignore</kbd> file:</p>
<pre>*.pyc<br/>*.pem<br/>*.pub<br/>*.tar.gz<br/>*.zip<br/>*.sql<br/>*.db<br/>secrets.txt<br/>./tmp<br/>./build/*<br/>.idea/*<br/>.idea<br/>env<br/>venv</pre>
<p>Now we can safely add all the files to <kbd>git</kbd> and commit them:</p>
<pre><strong>  $ git add --all</strong><br/><strong>  $ git status</strong><br/><strong>  $ git commit -a -m "Added gitignore and all the projects missing <br/>    files"</strong></pre>
<p>The Git system's <kbd>checkout</kbd> command is rather advanced for this simple introduction, but it is used to change the current status of the Git system's <kbd>HEAD</kbd> pointer, which refers to the current location of our code in the history of our project. This will be shown in the next example.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Now, if we wish to see the code in a previous commit, we should first run the following command:</p>
<pre><strong>$ git log<br/></strong><strong>commit cd88be37f12fb596be743ccba7e8283dd567ac05 (HEAD -&gt; master)</strong><br/><strong>Author: Daniel Gaspar</strong><br/><strong>Date: Sun May 6 16:59:46 2018 +0100</strong><br/><br/><strong>Added gitignore and all the projects missing files</strong><br/><strong>commit beb471198369e64a8ee8f6e602acc97250dce3cd</strong><br/><strong>Author: Daniel Gaspar</strong><br/><strong>Date: Fri May 4 19:06:57 2018 +0100</strong><br/><br/><strong>Our first commit</strong></pre>
<p>The string of characters next to our <kbd>commit</kbd> message, <kbd>beb4711</kbd>, is called the <strong>hash</strong> of our commit. It is the unique identifier of the commit that we can use to return to the saved state. Now, to take the project back to the previous state, run the following command:</p>
<pre><strong>$ git checkout beb4711</strong></pre>
<p>Your Git project is now in a special state where any changes or commits will neither be saved nor affect any commits that were made after the one you checked out. This state is just for viewing old code. To return to the normal mode of Git, run the following command:</p>
<pre><strong>$ git checkout master</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Git branches and flow</h1>
                
            
            
                
<p>Source control branches are an important feature that works great in team projects. A developer can create a new line of code from a specific point in time, revision, or tag. In this way, developing new features, creating releases, and making bugfixes or hotfixes can be done safely and subjected to team revision, and/or automatic integration tools (such as tests, code coverage, lint tools). A branch can be merged with other branches until it finally reaches the main line of code, called the <em>master branch</em>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>But let's get our hands on a practical exercise. Let's say that we want to develop a new feature. Our first chapter example displays the traditional "Hello World" message, but we want it to say "good morning" to the users. First, we create a branch from a special branch called the <kbd>feature/good-morning</kbd> that for now is a copy of the master branch, as shown in the following code:</p>
<pre><strong># Display our branches<br/>$ git branch<br/></strong>* master<strong><br/># Create a branch called feature/good-morning from master<br/>$ git branch feature/good-morning<br/># Display our branches again<br/>$ git branch<br/></strong>  feature/good-morning<br/>* master<strong><br/># Check out the new feature/good-morning branch<br/>$ git checkout feature/good-morning<br/></strong></pre>
<p>This could be resumed to the following:</p>
<pre><strong>$ git checkout -b </strong><strong>feature/good-morning master</strong></pre>
<p>Now let's change our code to display good morning to the visitors of a certain URL, along with their names. To do this, we change <kbd>main.py</kbd>, which looks like the following code:</p>
<pre>@app.route('/')<br/>def home():<br/>    return '&lt;h1&gt;Hello world&lt;/h1&gt;'</pre>
<p>We change <kbd>main.py</kbd> to the following:</p>
<pre>@app.route('/username')<br/>def home():<br/>    return '&lt;h1&gt;Good Morning %s&lt;/h1&gt;' % username</pre>
<p>Let's look at what we have done:</p>
<pre><strong>$</strong> <strong>git diff</strong><br/><strong>diff --git a/main.py b/main.py</strong><br/><strong>index 3e0aacc..1a930d9 100755</strong><br/><strong>--- a/main.py</strong><br/><strong>+++ b/main.py</strong><br/><strong>@@ -5,9 +5,9 @@ app = Flask(__name__)</strong><br/><strong> app.config.from_object(DevConfig)</strong><br/><br/><strong> # Changed to show the git diff command</strong><br/><strong>-@app.route('/')</strong><br/><strong>-def home():</strong><br/><strong>- return '&lt;h1&gt;Hello World!&lt;/h1&gt;'</strong><br/><strong>+@app.route('/&lt;username&gt;')</strong><br/><strong>+def home(username):</strong><br/><strong>+ return '&lt;h1&gt;Good Morning %s&lt;/h1&gt;' % username</strong><br/><br/><strong> if __name__ == '__main__':</strong><br/><strong>     app.run()</strong></pre>
<p>Looks good. Let's commit, as shown in the following code:</p>
<pre><strong>$ git commit -m "Display good morning because its nice"</strong><br/><strong>[feature/good-morning d4f7fb8] Display good morning because its nice</strong><br/><strong> 1 file changed, 3 insertions(+), 3 deletions(-)</strong></pre>
<p>Now, if we were working as part of a team, or if our work was open source (or if we just wanted to back up our work), we should upload (push) our code to a centralized remote origin. One way of doing this is to push our code to a version control system, such as <strong>Bitbucket</strong> or <strong>GitHub</strong>, and then open a <strong>pull request</strong> to the master branch. This pull request will show our changes. As such, it may need approval from other team members, and many other features that these systems can provide.</p>
<p>One example of a pull request on the Flask project can be found at <a href="https://github.com/pallets/flask/pull/1767">https://github.com/pallets/flask/pull/1767</a>.<a href="https://github.com/pallets/flask/pull/1767"/></p>
<p>For our example, let's just merge to the master, as shown in the following code:</p>
<pre><strong># Get back to the master branch<br/>$ git checkout master</strong><br/><strong>Switched to branch 'master'</strong><br/><strong>bash-3.2$ git log</strong><br/><strong>commit 139d121d6ecc7508e1017f364e6eb2e4c5f57d83 (HEAD -&gt; master)</strong><br/><strong>Author: Daniel Gaspar</strong><br/><strong>Date: Fri May 4 23:32:42 2018 +0100</strong><br/><br/><strong>    Our first commit</strong><br/><strong># Merge our feature into the master branch</strong><br/><strong>$ git merge feature/good-morning</strong><br/><strong>Updating 139d121..5d44a43</strong><br/><strong>Fast-forward</strong><br/><strong> main.py | 6 +++---</strong><br/><strong> 1 file changed, 3 insertions(+), 3 deletions(-)</strong><br/><strong>bash-3.2$ git log</strong><br/><strong>commit 5d44a4380200f374c879ec1f7bda055f31243263 (HEAD -&gt; master, feature/good-morning)</strong><br/><strong>Author: Daniel Gaspar</strong><br/><strong>Date: Fri May 4 23:34:06 2018 +0100</strong><br/><br/><strong>Display good morning because its nice<br/><br/></strong><strong>commit 139d121d6ecc7508e1017f364e6eb2e4c5f57d83</strong><br/><strong>Author: Daniel Gaspar &lt;daniel.gaspar@miniclip.com&gt;</strong><br/><strong>Date: Fri May 4 23:32:42 2018 +0100</strong><br/><br/><strong>Our first commit</strong></pre>
<p>As you can see from the output, Git uses the fast-forward strategy by default. If we wanted to keep an extra commit log message that mentions the merge itself, then we could have used the <kbd>--no-ff </kbd>flag on the <kbd>git merge</kbd> command. This flag will disable the fast-forward merging strategy.</p>
<p>For more details, go to <a href="https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging">https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging</a>.</p>
<p>Now imagine that we regret our change and want to revert the feature that we have just created back to an earlier version. To do this, we can use the following code:</p>
<pre><strong>$ git revert</strong></pre>
<p>With Git, you can actually delete your commits, but this is considered a really bad practice. Note that the <kbd>revert</kbd> command did not delete our merge, but created a new commit with the reverted changes. It's considered a good practice not to rewrite the past. </p>
<p>What was shown is a feature branch simple workflow. With big teams or projects, the use of more complex workflows is normally adopted to better isolate features, fixes, and releases, and to keep a stable line of code. This is what is proposed when using the git-flow process.</p>
<p>Now that we have a version control system, we are ready to cover Python's package management system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Python package management with pip</h1>
                
            
            
                
<p>In Python, programmers can download libraries from other programmers that extend the functionality of the standard Python library. As you already know from using Flask, a lot of Python's power comes from its large number of community-created libraries.</p>
<p>However, installing third-party libraries can be a huge pain to do correctly. Say that you want to install package X. Simple enough: download the ZIP file and run <kbd>setup.py</kbd>, right? Not quite. Package X relies on package Y, which in turn relies on Z and Q. None of this information was listed on package X's website, but these packages need to be installed for X to work at all. You then have to find all of the packages one by one and install them, and then hope that the packages you are installing don't require any extra packages themselves.</p>
<p>In order to automate this process, we use <strong>pip</strong>, the Python package manager.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing the Python package manager on Windows</h1>
                
            
            
                
<p>If you are using Windows, and your previously installed version of Python is the current version, then you already have pip! If your Python installation is not the most recent version, then the easiest thing to do is to simply reinstall it. Download the Python Windows installer at <a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>.</p>
<p>In Windows, the variable that controls which programs are accessible from the command line is the <kbd>path</kbd>. To modify our <kbd>path</kbd> to include Python and pip, we have to add <kbd>C:\Python27</kbd> and <kbd>C:\Python27\Tools</kbd>. Edit the Windows <kbd>path</kbd> by opening the Windows menu, right-clicking on Computer, and clicking on Properties. Under Advanced system settings, click Environment Variables.... Scroll down until you find Path, double-click on it, and add <kbd>;C:\Python27;C:\Python27\Tools</kbd> to the end.</p>
<p>To make sure that you have modified your path correctly, close and reopen your Terminal and type the following into the command line:</p>
<pre><strong>pip --help</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Pip should have printed its usage message, as shown in the following screenshot:</p>
<div><img class="aligncenter size-full wp-image-530 image-border" src="img/c1e2cfd7-5e05-42b0-ad5d-4e3d2d7f1af1.png" style="width:47.92em;height:26.92em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing pip Python package manager on macOS X and Linux</h1>
                
            
            
                
<p>Some Python installations of Linux do not come with pip, and Mac OS X's installations doesn't come with pip by default. If you are using Python 2.7, then you may need to install pip, but pip is already included in Python 3.4, and in later versions. You can check this using the following:</p>
<pre><strong>$ python3 -m pip list</strong></pre>
<p>If you need to install it, download the <kbd>get-pip.py</kbd> file from <a href="https://bootstrap.pypa.io/get-pip.py">https://bootstrap.pypa.io/get-pip.py</a>.</p>
<p>Once you have downloaded it, run it with elevated privileges using the following code:</p>
<pre><strong># Download and install pip<br/>$ wget https://bootstrap.pypa.io/get-pip.py</strong>    <br/><strong>$ sudo python get-pip.py</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Once this has been entered, pip will be installed automatically.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pip basics</h1>
                
            
            
                
<p>We are now going to learn the basic commands for using Python package manager. To install a package with <kbd>pip</kbd>, enter the following code:</p>
<pre><strong>$ pip install [package-name]</strong></pre>
<p>On Mac and Linux, because you are installing programs outside of the user-owned folders, you might have to prepend <kbd>sudo</kbd> to the <kbd>install</kbd> commands. To install Flask, simply run the following:</p>
<pre><strong>$ pip install flask</strong></pre>
<p>Once you have done this, all of the requirements that you need for using Flask will be installed for you.</p>
<p>If you want to remove a package that you are no longer using, run the following:</p>
<pre><strong>$ pip uninstall [package-name]</strong></pre>
<p>If you wish to explore or find a package, but don't know its exact name, you can use the <kbd>search</kbd> command:</p>
<pre><strong>$ pip search [search-term]</strong></pre>
<p>Now that we have a couple of packages installed, it is common courtesy in the Python community to create a list of packages that are required to run the project so that others can quickly install every necessary package. This also has the added benefit that any new member of your project will be able to run your code quickly.</p>
<p>This list can be created with pip by running the following command:</p>
<pre><strong>$ pip freeze &gt; requirements.txt</strong></pre>
<p>What exactly did this command do? The <kbd>pip freeze</kbd> command automatically prints out a list of the installed packages and their versions. For our example, it prints the following:</p>
<pre><strong>click==6.7</strong><br/><strong>Flask==0.12.4</strong><br/><strong>itsdangerous==0.24</strong><br/><strong>Jinja2==2.10</strong><br/><strong>MarkupSafe==1.0</strong><br/><strong>Werkzeug==0.14.1</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The <kbd>&gt;</kbd> operator tells Bash to take everything printed by the last command and write it to this file. If you look in your project directory, you can see a new file named <kbd>requirements.txt</kbd> that contains the output of <kbd>pip freeze</kbd>.</p>
<p>To install all the packages from this file, a new project maintainer would have to run this, as shown in the following code. Normally, this will also be used to deploy the production environment of your project:</p>
<pre><strong>$ pip install -r requirements.txt</strong></pre>
<p>The preceding code tells <kbd>pip</kbd> to read all the packages listed in <kbd>requirements.txt</kbd> and install them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dependency sandboxing with virtualenv</h1>
                
            
            
                
<p>So you have installed all the packages that you want for your new project. Great! But what happens when we develop a second project some time later that will use newer versions of the same packages? And what happens when a library that you wish to use depends on a library that you installed for the first project, but which uses an older version of these packages? When newer versions of packages contain breaking changes, upgrading them would require extra development work on an older project that you may not be able to afford. So in our system, we could have clashing Python packages between projects.</p>
<p>We should also consider automated build environments, such as <strong>Jenkins</strong>, where we want to run tests. These builds may run on the same system on which other projects are being built, so it's essential that during the build jobs we create a contained Python package environment that is not shared between jobs. This environment is created from the information in the <kbd>requirements.txt</kbd> file that we created earlier. This way, multiple Python applications can be built and tested on the same system without clashing with each other.</p>
<p>Thankfully, there is <strong>virtualenv</strong>, a tool that sandboxes your Python projects. The secret to virtualenv is in tricking your computer to look for and install packages in the project directory rather than in the main Python directory, which allows you to keep them completely separate.</p>
<p>If you're using Python 3—and I recommend that you do, because Python 2 support will end in 2020—then you don't have to install virtualenv; you can use it just by running it like a package, as shown in the following code:</p>
<pre><strong># Create a python 3 virtualenv<br/>$ python3 -m venv env</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Now that we have pip, if we need to install <kbd>virtualenv</kbd>, then we can just run the following command:</p>
<pre><strong>$ pip install virtualenv</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Virtualenv basics</h1>
                
            
            
                
<p>Let's initialize <kbd>virtualenv</kbd> for our project, as follows:</p>
<pre><strong>$ virtualenv env</strong></pre>
<p>The extra <kbd>env</kbd> tells virtualenv to store all the packages in a folder named <kbd>env</kbd>. Virtualenv requires you to start it before it will sandbox your project. You can do this using the following code:</p>
<pre><strong>$ source env/bin/activate</strong>
<strong># Your prompt should now look like</strong>
<strong>(env) $</strong></pre>
<p>The <kbd>source</kbd> command tells Bash to run the <kbd>env/bin/activate</kbd> script in the context of the current directory. Let's reinstall Flask in our new sandbox, as follows:</p>
<pre><strong># you won't need sudo anymore</strong>
<strong>(env) $ pip install flask</strong>
<strong># To return to the global Python</strong>
<strong>(env) $ deactivate</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up Docker</h1>
                
            
            
                
<p>Your development projects normally need more then a web server application layer; you will most definitely need some kind of database system. You might be using a cache, <strong>redis</strong>, workers with <strong>Celery</strong>, a messaging queuing system, or something else. Normally, all of the systems that are needed for your application to work are collectively referred to as <strong>stack</strong>. One simple way to easily define and quickly spawn all these components is to use <strong>Docker</strong> containers. With Docker, you define all of your application components and how to install and configure them, and you can then share your stack with your team, and send it to production with the exact same specification.</p>
<p class="mce-root"/>
<p>You can download and install Docker from <a href="https://docs.docker.com/install/">https://docs.docker.com/install/</a>.</p>
<p>First, let's create a very simple <strong>Dockerfile</strong>. This file defines how to set up your application. Each line will serve as a container layer for very fast rebuilds. A very simple Dockerfile will look like the following:</p>
<pre>FROM python:3.6.5<br/># Set the working directory to /app<br/>WORKDIR /app<br/># Copy local contents into the container<br/>ADD . /app<br/># Install all required dependencies<br/>RUN pip install -r requirements.txt<br/>EXPOSE 5000<br/>CMD ["python", "main.py"]</pre>
<p>Next, let's build out first container image. We will tag it as <kbd>chapter_1</kbd> for further ease of use, as shown in the following code:</p>
<pre><strong>$ docker build -t chapter_1 .<br/></strong></pre>
<p>Then we will run it, as shown in the following code:</p>
<pre><strong>$ docker run -p 5000:5000 chapter_1<br/># List all the running containers<br/>$ docker container list</strong></pre>
<p>Docker is easy, but it's a complex tool with lots of options for configuring and deploying containers. We will look at Docker in more detail in <a href="380101ac-fb85-4e2e-b664-8d6de77928f4.xhtml">Chapter 13</a>, <em>Deploying Flask Apps</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The beginning of our project</h1>
                
            
            
                
<p>Finally, we can get to our first Flask project. In order to build a complex project at the end of this book, we will need a simple Flask project to start us off.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Simple application</h1>
                
            
            
                
<p>Flask is very powerful, but will most definitely not get in your way. You can use it to create a simple web application using a single file. Our aim is to create a project that is structured in a way that it can scale and be easy to understand. For now, we will create a <kbd>config</kbd> file first. In the file named <kbd>config.py</kbd>, add the following:</p>
<pre>class Config(object): 
    pass 
 
class ProdConfig(Config): 
    pass 
 
class DevConfig(Config): 
    DEBUG = True </pre>
<p>Now, in another file named <kbd>main.py</kbd>, add the following:</p>
<pre>from flask import Flask 
from config import DevConfig 
 
app = Flask(__name__) 
app.config.from_object(DevConfig) 
 
@app.route('/') 
def home(): 
    return '&lt;h1&gt;Hello World!&lt;/h1&gt;' 
 
if __name__ == '__main__': 
    app.run() </pre>
<p>For anyone who is familiar with the base Flask API, this program is very basic. It will simply show <kbd>Hello World!</kbd> on the browser if we navigate to <kbd>http://127.0.0.1:5000</kbd>. One point that may be unfamiliar to Flask users is the use of the phrase <kbd>config.from_object</kbd> rather than <kbd>app.config['DEBUG']</kbd>. We use <kbd>from_object</kbd> because in future, multiple configurations will be used, and manually changing every variable when we need to switch between configurations is time consuming.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Project structure</h1>
                
            
            
                
<p>We have created a very simple project structure, but can it serve as the base skeleton for any Python project. In <a href="dee931d4-a3b0-4355-acbd-37e05e158356.xhtml" target="_blank">Chapter 5</a>, <em>Advanced Application Structure</em>, we will get our hands on a more scalable structure, but for now, let's go back to our environment, as shown in the following code:</p>
<pre><strong>Dockerfile</strong> # Instructions to configure and run our application on a container<br/><strong>requirements.txt</strong> # All the dependencies needed to run our application<br/><strong>/venv</strong> # We will not add this folder to our Git repo, our virtualenv<br/><strong>.gitignore</strong> # Instruction for Git to ignore files<br/><strong>main.py</strong> # Our main Flask application<br/><strong>config.py</strong> # Our configuration file</pre>
<p>Remember to commit these changes in Git, as shown in the following code:</p>
<pre><strong># The --all flag will tell git to stage all changes you have made</strong>
<strong># including deletions and new files</strong>
<strong>$ git add --all</strong>
<strong>$ git commit -m" ""created the base application"</strong></pre>
<p>You will no longer be reminded of when to commit your changes to Git. It is up to you to develop the habit of committing whenever you reach a stopping point. It is also assumed that you will be operating inside the virtual environment, so all command-line prompts will not be prefixed with <kbd>(env)</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Flask's command-line interface</h1>
                
            
            
                
<p>In order to make the next chapters easier for the reader, we will look at how to use the Flask CLI (using version 0.11 onward). The CLI allows programmers to create commands that act within the <strong>application context</strong> of Flask—that is, the state in Flask that allows the modification of the <kbd>Flask</kbd> object. The Flask CLI comes with some default commands to run the server and a Python shell in the application context.</p>
<p>Let's take a look at the Flask CLI and how to initialize it. First, we must tell it how to discover our application using the following code:</p>
<pre><strong>$</strong> <strong>export FLASK_APP=main.py</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Then, we will use the Flask CLI to run our application using the following code:</p>
<pre><strong>$ flask run</strong></pre>
<p>Now, let's enter the shell on the application context and see how to get all the defined URL routes, using the following code:</p>
<pre><strong>$ flask shell<br/></strong>Python 3.6.5 (v3.6.5:f59c0932b4, Mar 28 2018, 03:03:55)<br/>[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin<br/>App: main [debug]<br/>Instance: /chapter_1/instance<strong><br/>&gt;&gt;&gt; app.url_map<br/>Map([&lt;Rule '/' (OPTIONS, GET, HEAD) -&gt; home&gt;,<br/> &lt;Rule '/static/&lt;filename&gt;' (OPTIONS, GET, HEAD) -&gt; static&gt;])</strong></pre>
<p>As you can see, we already have two routes defined: the <kbd>/</kbd> where we display the "<kbd>Hello World</kbd>" sentence and the static default route created by Flask. Some other useful information shows where Flask thinks our templates and static folders are, as shown in the following code:</p>
<pre><strong>&gt;&gt;&gt; app.static_folder</strong><br/><strong>/chapter_1/static'</strong><br/><strong>&gt;&gt;&gt; app.template_folder</strong><br/><strong>'templates'</strong></pre>
<p>Flask CLI, uses the <kbd>click</kbd> library from the creator of Flask itself. It was designed to be easily extensible so that the Flask extensions can extend it and implement new commands that are available when you use them. We should indeed extend it—it makes it more useful to extend it ourselves. This is the right way to create management commands for our applications. Think about commands that you can use to migrate database schemas, create users, prune data, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Now that we have set up our development environment, we can move on to implementing advanced application features in Flask. Before we can do anything visual, we need content to display. This content will be kept on a database. In the next chapter, you will be introduced to working with databases in Flask, and you will learn how master them.</p>


            

            
        
    </body></html>