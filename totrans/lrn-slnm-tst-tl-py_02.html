<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Writing Tests Using unittest</h1></div></div></div><p>Selenium WebDriver <a id="id61" class="indexterm"/>is a browser automation API. It provides features to automate browser interaction, and this API is mainly used to test web applications. We cannot set up test preconditions and post conditions, check the expected and actual output, check the state of the application, report test results, create data-driven tests, and so on with Selenium WebDriver. We can use a unit testing framework or test runners used for unit testing along with Selenium to create a testing framework. In this chapter, we will learn how to use the <code class="literal">unittest</code> library to create Selenium WebDriver tests in Python.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What <code class="literal">unittest</code> is?</li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">unittest</code> library to write Selenium WebDriver tests</li><li class="listitem" style="list-style-type: disc">Implementing a test using the <code class="literal">TestCase</code> class</li><li class="listitem" style="list-style-type: disc">Understanding various types of <code class="literal">assert</code> methods provided by the <code class="literal">unittest</code> library</li><li class="listitem" style="list-style-type: disc">Creating a <code class="literal">TestSuite</code> for a group of tests</li><li class="listitem" style="list-style-type: disc">Generating test reports in HTML format using the <code class="literal">unittest</code> extension</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec12"/>The unittest library</h1></div></div></div><p>The <code class="literal">unittest</code> <a id="id62" class="indexterm"/>library (originally named as PyUnit) is inspired by the JUnit library widely used in Java application development. We can use <code class="literal">unittest</code> to create a comprehensive suite of tests for any project. The <code class="literal">unittest</code> module is used within the Python project to test various standard library modules including <code class="literal">unittest</code> itself. You <a id="id63" class="indexterm"/>can find the <code class="literal">unittest</code> documentation at <a class="ulink" href="http://docs.python.org/2/library/unittest.html">http://docs.python.org/2/library/unittest.html</a>.</p><p>The <code class="literal">unittest</code> library provides us with the ability to create test cases, test suites, and test fixtures. Let's understand each of these components as shown in following diagram:</p><div><img src="img/3506_02_01.jpg" alt="The unittest library"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Test Fixture</strong>: By <a id="id64" class="indexterm"/>using a test fixture, we can define the <a id="id65" class="indexterm"/>preparation needed to perform one or more tests and any associated clean-up actions.</li><li class="listitem" style="list-style-type: disc"><strong>Test Case</strong>: A test <a id="id66" class="indexterm"/>case is the smallest unit of testing in <code class="literal">unittest</code>. It checks for a specific response to a particular set of actions and inputs <a id="id67" class="indexterm"/>using various <code class="literal">assert</code> methods provided by the <code class="literal">unittest</code> library. The <code class="literal">unittest</code> library provides a base class called <code class="literal">TestCase</code> that may be used to create new test cases.</li><li class="listitem" style="list-style-type: disc"><strong>Test Suite</strong>: A test <a id="id68" class="indexterm"/>suite is a collection of multiple tests or <a id="id69" class="indexterm"/>test cases to create groups of tests representing specific functionality or modules of the application under test, which will be executed together.</li><li class="listitem" style="list-style-type: disc"><strong>Test Runner</strong>: The test <a id="id70" class="indexterm"/>runner orchestrates execution of tests and provides results to the user. The runner may use a graphical <a id="id71" class="indexterm"/>interface, a textual interface, or return a special value to indicate the results of executing the tests.</li><li class="listitem" style="list-style-type: disc"><strong>Test Report</strong>: A test <a id="id72" class="indexterm"/>report displays a summary of test <a id="id73" class="indexterm"/>results showing the pass or fail status of executed test cases, expected versus actual results for failed steps, and summary of overall run and timing information.</li></ul></div><p>A test created with the <a id="id74" class="indexterm"/>
<code class="literal">xUnit</code> framework such as <code class="literal">unittest</code> is divided into three parts also <a id="id75" class="indexterm"/>known as the 3 A's, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Arrange</strong>: This part <a id="id76" class="indexterm"/>sets up the preconditions for tests including the object(s) that need to be tested, related configuration, and dependencies</li><li class="listitem" style="list-style-type: disc"><strong>Act</strong>: This part <a id="id77" class="indexterm"/>exercises the functionality</li><li class="listitem" style="list-style-type: disc"><strong>Assert</strong>: This part checks <a id="id78" class="indexterm"/>the outcome with the expected results</li></ul></div><p>We will use this approach to create tests with the <code class="literal">unittest</code> library in rest of the chapter.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>We will use the <code class="literal">unittest</code> library in rest of the book to create and run Selenium WebDriver tests. However, there are other testing frameworks available in Python with additional features, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Nose</strong>: The <code class="literal">nose</code> <a id="id79" class="indexterm"/>framework extends the <code class="literal">unittest</code> library and provides ability to search and run tests automatically. It also provides various plugins to create more advanced tests. You can find more about <code class="literal">nose</code> at <a class="ulink" href="https://nose.readthedocs.org/en/latest/">https://nose.readthedocs.org/en/latest/</a>.</li><li class="listitem" style="list-style-type: disc"><strong>Pytest</strong>: The <code class="literal">pytest</code> <a id="id80" class="indexterm"/>framework is another testing framework that offers a number of advanced features to write and run unit tests in Python. You can find out more about <code class="literal">pytest</code> at <a class="ulink" href="http://pytest.org/latest/">http://pytest.org/latest/</a>.</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>The TestCase class</h2></div></div></div><p>We can create a <a id="id81" class="indexterm"/>test, or group of tests, by inheriting the <code class="literal">TestCase</code> class and adding each test as a method to this class. To make a test, we need to either use <code class="literal">assert</code> or one of the many variations on <code class="literal">assert</code> that are part of the <code class="literal">TestCase</code> class. The <a id="id82" class="indexterm"/>most important task of each test is a call to <code class="literal">assertEqual()</code> to check for an expected result, <code class="literal">assertTrue()</code> to verify a condition, or <code class="literal">assertRaises()</code> to verify that an expected exception gets raised.</p><p>In addition to adding tests, we can add test fixtures: that is the <code class="literal">setUp()</code> and <code class="literal">tearDown()</code> methods to handle creation and disposition of any objects or conditions that are needed for a test.</p><p>Let's start using the <code class="literal">unittest</code> library, first writing a simple test by inheriting the <code class="literal">TestCase</code> class and then adding a test method for the sample script that we created in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Selenium WebDriver and Python">Chapter 1</a>, <em>Getting Started with Selenium WebDriver and Python</em>.</p><p>We need to import the <a id="id83" class="indexterm"/>
<code class="literal">unittest</code> module and define a class that inherits the <a id="id84" class="indexterm"/>
<code class="literal">TestCase</code> class, as shown here:</p><div><pre class="programlisting">import unittest
from selenium import webdriver

class SearchTest(unittest.TestCase):</pre></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec04"/>The setUp() method</h3></div></div></div><p>The starting point for <a id="id85" class="indexterm"/>test cases is the <code class="literal">setUp()</code> method, which we can use to perform some tasks at the start of each test or all the tests that will be defined in the <a id="id86" class="indexterm"/>class. These can be test preparation tasks such as creating an instance of a browser driver, navigating to the base URL, loading test data, opening logfiles, and so on.</p><p>This method takes no arguments and doesn't return anything. When a <code class="literal">setUp()</code> method is defined, the test runner will run that method prior to each test method. In our example, we will use the <code class="literal">setUp()</code> method to create an instance of Firefox, set up the properties, and navigate to the main page of the application before a test is executed as shown in the following example:</p><div><pre class="programlisting">import unittest
from selenium import webdriver

class SearchTests(unittest.TestCase):
    def setUp(self):
        # create a new Firefox session
        self.driver = webdriver.Firefox()
        self.driver.implicitly_wait(30)
        self.driver.maximize_window()

        # navigate to the application home page
        self.driver.get("http://demo.magentocommerce.com/")</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Writing tests</h3></div></div></div><p>With a setup method in <a id="id87" class="indexterm"/>place, we can now write some tests to verify the application's functionality that we want to test. In this example, we will search for a product and <a id="id88" class="indexterm"/>check if the result returns a number of items. Similar to the <code class="literal">setUp()</code> method, test methods are implemented in the <code class="literal">TestCase</code> class. It is important that we name these methods beginning with the word <code class="literal">test</code>. This naming convention informs the test runner about which methods represent a test.</p><p>For each test method that the test runner finds, it executes the <code class="literal">setUp()</code> method before executing the <code class="literal">test</code> method. This helps ensure that each <code class="literal">test</code> method can depend on a consistent environment, regardless of how many tests are defined in the class. We will use a simple <code class="literal">assertEqual()</code> method to check that the expected results for the given search term match with the results returned by the application. We will discuss more about assertions later in the chapter.</p><p>Add a new test method, <code class="literal">test_search_by_category()</code>, which searches for products by category and checks for the <a id="id89" class="indexterm"/>number of products returned by the search, as <a id="id90" class="indexterm"/>shown in following example:</p><div><pre class="programlisting">import unittest
from selenium import webdriver

class SearchTests(unittest.TestCase):
    def setUp(self):
        # create a new Firefox session
        self.driver = webdriver.Firefox()
        self.driver.implicitly_wait(30)
        self.driver.maximize_window()

        # navigate to the application home page
        self.driver.get("http://demo.magentocommerce.com/")

    <strong>def test_search_by_category(self):</strong>
        <strong># get the search textbox</strong>
        <strong>self.search_field = self.driver.find_element_by_name("q")</strong>
        <strong>self.search_field.clear()</strong>

        <strong># enter search keyword and submit</strong>
        <strong>self.search_field.send_keys("phones")</strong>
        <strong>self.search_field.submit()</strong>

        <strong># get all the anchor elements which have product names </strong>        <strong># displayed currently on result page using </strong>        <strong># find_elements_by_xpath method</strong>
        <strong>products = self.driver.find_elements_by_xpath</strong>          <strong>("//h2[@class='product-name']/a")</strong>
        <strong>self.assertEqual(2, len(products))</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Cleaning up the code</h3></div></div></div><p>Similar to the <a id="id91" class="indexterm"/>
<code class="literal">setUp()</code> method that is called before each test method, the <code class="literal">TestCase</code> class also calls a <code class="literal">tearDown()</code> method to clean up any initialized values after the test is executed. Once a test is executed, the values defined in the <code class="literal">setUp()</code> method are <a id="id92" class="indexterm"/>no longer required; so, it is good practice to clean up the values initialized by the <code class="literal">setUp()</code> method after a test is completed. In our example, after a test is executed, we no longer need the instance of Firefox. We will close the Firefox instance that was created for the test in the <code class="literal">tearDown()</code> method, as shown in the following code:</p><div><pre class="programlisting">import unittest
from selenium import webdriver

class SearchTests(unittest.TestCase):
    def setUp(self):
        # create a new Firefox session
        self.driver = webdriver.Firefox()
        self.driver.implicitly_wait(30)
        self.driver.maximize_window()

        # navigate to the application home page
        self.driver.get("http://demo.magentocommerce.com/")

    def test_search_by_category(self):
        # get the search textbox
        self.search_field = self.driver.find_element_by_name("q")
        self.search_field.clear()

        # enter search keyword and submit
        self.search_field.send_keys("phones")
        self.search_field.submit()

        # get all the anchor elements which have product names # displayed currently on result page using # find_elements_by_xpath method
        products = self.driver.find_elements_by_xpath ("//h2[@class='product-name']/a")
        self.assertEqual(2, len(products))

    <strong>def tearDown(self):</strong>
        <strong># close the browser window</strong>
        <strong>self.driver.quit()</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Running the test</h3></div></div></div><p>To run the test <a id="id93" class="indexterm"/>from command line, we can add a call to the <code class="literal">main</code> <a id="id94" class="indexterm"/>method of the test case. We will pass the <code class="literal">verbosity</code> argument that is used to display the amount of test result details on the console:</p><div><pre class="programlisting">if __name__ == '__main__':
    unittest.main(verbosity=2)</pre></div><p>We can store the tests as a normal Python script. For this example, save the sample test as <code class="literal">searchtests.py</code>. After saving the file, we can execute it through command line by using the following command:</p><div><pre class="programlisting">
<strong>python searchtests.py</strong>
</pre></div><p>After running the tests, <code class="literal">unittest</code> shows the results on the console along with the summary of tests as shown in the following screenshot:</p><div><img src="img/3506_02_02.jpg" alt="Running the test"/></div><p>In addition to the results summary, when a test case fails, for each failure, summary will produce a block of text to describe what went wrong. Look at the following screenshot to see what happens when we change the expected value to something else:</p><div><img src="img/3506_02_03.jpg" alt="Running the test"/></div><p>As you can see, it shows exactly which test method generated the failure, with trace-back information to <a id="id95" class="indexterm"/>track down the code flow that led to the failure. In <a id="id96" class="indexterm"/>addition, the failure itself is shown as <code class="literal">AssertionError</code>, with a mismatch of the expected output with the actual output.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec08"/>Adding another test</h3></div></div></div><p>We can group a <a id="id97" class="indexterm"/>number of tests as part of one test class. This helps in creating logical groups of tests that belong to a specific functionality. Let's <a id="id98" class="indexterm"/>add another test to the test class. The rule is simple; name the new method starting with the word <code class="literal">test</code>, as shown in the following code:</p><div><pre class="programlisting">def test_search_by_name(self):
    # get the search textbox
    self.search_field = self.driver.find_element_by_name("q")
    self.search_field.clear()

    # enter search keyword and submit
    self.search_field.send_keys("salt shaker")
    self.search_field.submit()

    # get all the anchor elements which have
	# product names displayed
    # currently on result page using
	# find_elements_by_xpath method
    products = self.driver.find_elements_by_xpath ("//h2[@class='product-name']/a")
    self.assertEqual(1, len(products))</pre></div><p>Run the test and <a id="id99" class="indexterm"/>you will see two instances of Firefox opening and closing. This is how the <code class="literal">setUp()</code> and <code class="literal">tearDown()</code> methods work for each test method. You <a id="id100" class="indexterm"/>will see the result as shown in the following screenshot:</p><div><img src="img/3506_02_04.jpg" alt="Adding another test"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Class-level setUp() and tearDown() methods</h2></div></div></div><p>In the previous example, we created a new instance of Firefox using the <code class="literal">setUp()</code> method before the execution of each test method and closed that instance after the execution of the test method. How about <a id="id101" class="indexterm"/>sharing a single Firefox <a id="id102" class="indexterm"/>instance between the methods instead of creating a new instance every time? This can be done by using the <code class="literal">setUpClass()</code> and <code class="literal">tearDownClass()</code> methods and using the <code class="literal">@classmethod</code> decorator. These methods allow us to initialize <a id="id103" class="indexterm"/>values at the class level instead of the method level and then share these values between the test methods. In the following example, the <a id="id104" class="indexterm"/>code is modified to call the <code class="literal">setUpClass()</code> and <code class="literal">tearDownClass()</code> methods with the <code class="literal">@classmethod</code> decorator:</p><div><pre class="programlisting">import unittest
from selenium import webdriver

class SearchTests(unittest.TestCase):
    <strong>@classmethod</strong>
    <strong>def setUpClass(cls):</strong>
        <strong># create a new Firefox session</strong>
        <strong>cls.driver = webdriver.Firefox()</strong>
        <strong>cls.driver.implicitly_wait(30)</strong>
        <strong>cls.driver.maximize_window()</strong>

        <strong># navigate to the application home page</strong>
        <strong>cls.driver.get("http://demo.magentocommerce.com/")</strong>
        <strong>cls.driver.title</strong>
        
    def test_search_by_category(self):
        # get the search textbox
        self.search_field = self.driver.find_element_by_name("q")
        self.search_field.clear()

        # enter search keyword and submit
        self.search_field.send_keys("phones")
        self.search_field.submit()

        # get all the anchor elements which have product names
		# displayed currently on result page using
		# find_elements_by_xpath method
        products = self.driver.find_elements_by_xpath("//h2[@class='product-name']/a")
        self.assertEqual(2, len(products))

    def test_search_by_name(self):
        # get the search textbox
        self.search_field = self.driver.find_element_by_name("q")
        self.search_field.clear()

        # enter search keyword and submit
        self.search_field.send_keys("salt shaker")
        self.search_field.submit()

        # get all the anchor elements which have product names
		# displayed currently on result page using
		# find_elements_by_xpath method
        products = self.driver.find_elements_by_xpath("//h2[@class='product-name']/a")
        self.assertEqual(1, len(products))

    <strong>@classmethod</strong>
    <strong>def tearDownClass(cls):</strong>
        <strong># close the browser window</strong>
        <strong>cls.driver.quit()</strong>

    <strong>if __name__ == '__main__':</strong>
        <strong>unittest.main()</strong>
</pre></div><p>Run <a id="id105" class="indexterm"/>the test and you will see a single Firefox instance <a id="id106" class="indexterm"/>created; both the tests will use <a id="id107" class="indexterm"/>this <a id="id108" class="indexterm"/>instance.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>For more <a id="id109" class="indexterm"/>information on the <code class="literal">@classmethod</code> decorator, refer <a id="id110" class="indexterm"/>to <a class="ulink" href="https://docs.python.org/2/library/functions.html#classmethod">https://docs.python.org/2/library/functions.html#classmethod</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Assertions</h2></div></div></div><p>The <code class="literal">TestCase</code> class of <a id="id111" class="indexterm"/>the <code class="literal">unittest</code> library offers a number of utility methods to check the expected values against actual values returned by the application. These methods are implemented in such a way that they represent a condition that must be true in order <a id="id112" class="indexterm"/>to continue the execution of the test. There are broadly three types of such methods, each covering a specific type of condition such as checking equivalence, logical comparison, and exceptions. If the given assertion passes, the test will continue to the next line of code; otherwise, the test halts immediately and a failure message will be generated.</p><p>The <code class="literal">unittest</code> library <a id="id113" class="indexterm"/>provides all the standard xUnit <code class="literal">asserts</code> methods. The following table lists some of the important methods that we will be using in the rest of the book:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Condition that is checked</p>
</th><th style="text-align: left" valign="bottom">
<p>Example uses</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assertEqual(a, b [,msg])</code>
</p>
</td><td style="text-align: left" valign="top">
<p>a == b</p>
</td><td rowspan="2" style="text-align: left" valign="top">
<p>These methods check whether or not <code class="literal">a</code> and <code class="literal">b</code> are equal to each other. The <code class="literal">msg</code> object is a message explaining the failure (if any).</p>
<p>This is useful to check values of elements, attributes, and so on. For example:</p>
<p>
<code class="literal">assertEqual(element.text,"10")</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assertNotEqual(a, b[,msg])</code>
</p>
</td><td style="text-align: left" valign="top">
<p>a != b</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assertTrue(x[,msg]))</code>
</p>
</td><td style="text-align: left" valign="top">
<p>bool(x) is True</p>
</td><td rowspan="3" style="text-align: left" valign="top">
<p>These methods check whether the given expression evaluates to <code class="literal">True</code> or <code class="literal">False</code>.</p>
<p>For example, to check whether the element is displayed on a page, we can use the following method:</p>
<p>
<code class="literal">assertTrue(element.is_dispalyed())</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assertFalse(x[,msg]))</code>
</p>
</td><td style="text-align: left" valign="top">
<p>bool(x) is False</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assertIsNot(a, b[,msg]))</code>
</p>
</td><td style="text-align: left" valign="top">
<p>a is not b</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assertRaises(exc, fun, *args, **kwds)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>fun(*args, **kwds) raises exc</p>
</td><td rowspan="2" style="text-align: left" valign="top">
<p>These <a id="id114" class="indexterm"/>methods check whether the specific exceptions are raised by the test steps. A possible use of this method is to check <code class="literal">NoSuchElementFoundexception</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assertRaisesRegexp(exc, r, fun, *args, **kwds)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>fun(*args, **kwds) raises exc and the message matches regex r</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assertAlmostEqual(a, b)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>round(a-b, 7) == 0</p>
</td><td rowspan="2" style="text-align: left" valign="top">
<p>These methods specifically check for numeric values, and round the value to the given number of decimal places before checking for equality. This helps account for rounding errors and other problems due to floating-point arithmetic.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assertNotAlmostEqual(a, b)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>round(a-b, 7) != 0</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assertGreater(a, b)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>a &gt; b</p>
</td><td rowspan="4" style="text-align: left" valign="top">
<p>These methods are similar to the <code class="literal">assertEqual()</code> method, designed with logical conditions.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assertGreaterEqual(a, b)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>a &gt;= b</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assertLess(a, b)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>a &lt; b</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assertLessEqual(a, b)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>a &lt;= b</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assertRegexpMatches(s, r)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>r.search(s)</p>
</td><td rowspan="2" style="text-align: left" valign="top">
<p>These methods check whether a <code class="literal">regexp</code> search matches the text.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assertNotRegexpMatches(s, r)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>not r.search(s)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assertMultiLineEqual(a, b)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>strings</p>
</td><td style="text-align: left" valign="top">
<p>This method is a specialized form of <code class="literal">assertEqual()</code>, designed for multiline strings. Equality works like any other string, but the default failure message is optimized to show the differences between the values.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assertListEqual(a, b)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>lists</p>
</td><td style="text-align: left" valign="top">
<p>This method checks whether the lists <code class="literal">a</code> and <code class="literal">b</code> match. This is useful to match options from drop-down fields.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fail()</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>This method fails the test unconditionally. This can also <a id="id115" class="indexterm"/>be used to create custom conditional blocks where other <code class="literal">assert</code> methods do not work easily.</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Test suites</h2></div></div></div><p>Using the <code class="literal">TestSuites</code> feature of <code class="literal">unittest</code>, we can collect various tests into logical groups and then <a id="id116" class="indexterm"/>into a unified test suite that can be run with a single command. This is done by using the <code class="literal">TestSuite</code>, <code class="literal">TestLoader</code>, and <code class="literal">TestRunner</code> classes.</p><p>Before we get into details of <code class="literal">TestSuite</code>, let's add a new test to check the home page of the sample application. We will aggregate this test along with the previous search tests into a single test suite, as shown in the following code:</p><div><pre class="programlisting">import unittest
from selenium import webdriver
from selenium.common.exceptions import NoSuchElementException
from selenium.webdriver.common.by import By
from __builtin__ import classmethod

class HomePageTest(unittest.TestCase):
    @classmethod
    def setUp(cls):
        # create a new Firefox session """
        cls.driver = webdriver.Firefox()
        cls.driver.implicitly_wait(30)
        cls.driver.maximize_window()

        # navigate to the application home page """
        cls.driver.get("http://demo.magentocommerce.com/")

    def test_search_field(self):
        # check search field exists on Home page
        self.assertTrue(self.is_element_present(By.NAME,"q"))

    def test_language_option(self):
        # check language options dropdown on Home page
        self.assertTrue(self.is_element_present(By.ID,"select-language"))

    def test_shopping_cart_empty_message(self):
        # check content of My Shopping Cart block on Home page
        shopping_cart_icon = \
            self.driver.find_element_by_css_selector("div.header-minicart span.icon")
        shopping_cart_icon.click()

        shopping_cart_status = \
            self.driver.find_element_by_css_selector("p.empty").text
        self.assertEqual("You have no items in your shopping cart.", shopping_cart_status)

        close_button =  self.driver.find_element_by_css_selector("div.minicart-wrapper a.close")
        close_button.click()

    @classmethod
    def tearDown(cls):
        # close the browser window
        cls.driver.quit()


    def is_element_present(self, how, what):
        """
        Utility method to check presence of an element on page
        :params how: By locator type
        :params what: locator value
        """
        try: self.driver.find_element(by=how, value=what)
        except NoSuchElementException, e: return False
        return True

    if __name__ == '__main__':
        unittest.main(verbosity=2)</pre></div><p>We will use the <code class="literal">TestSuite</code> class for defining and running the test suite. We can add multiple test cases to the test suite. In addition to the <code class="literal">TestSuite</code> class we need to use <code class="literal">TestLoader</code> and <code class="literal">TextTestRunner</code> to create and run a test suite as shown in the following code:</p><div><pre class="programlisting">import unittest
from searchtests import SearchTests
from homepagetests import HomePageTest

# get all tests from SearchProductTest and HomePageTest class
search_tests = unittest.TestLoader().loadTestsFromTestCase(SearchTests)
home_page_tests = unittest.TestLoader().loadTestsFromTestCase(HomePageTest)

# create a test suite combining search_test and home_page_test
smoke_tests = unittest.TestSuite([home_page_tests, search_tests])

# run the suite
unittest.TextTestRunner(verbosity=2).run(smoke_tests)</pre></div><p>Using the <code class="literal">TestLoader</code> class, we will get all the test methods from the specified test files that will be used to create the test suite. The <code class="literal">TestRunner</code> class will take the test suite and run all the tests from these files.</p><p>We can run the new test suite file using the following command:</p><div><pre class="programlisting">
<strong>python smoketests.py</strong>
</pre></div><p>This will run all the tests <a id="id117" class="indexterm"/>from the <code class="literal">SearchProductTest</code> and <code class="literal">HomePageTest</code> class and generate the following output in the console:</p><div><img src="img/3506_02_05.jpg" alt="Test suites"/></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Generating the HTML test report</h1></div></div></div><p>The <code class="literal">unittest</code> library <a id="id118" class="indexterm"/>generates the test output on a console window. You might want to generate a report of all the tests executed as evidence or to distribute test results to various stakeholders. Sending console logs to the stakeholder may not be a good idea. Stakeholders will need nicely formatted, summary reports with a drill-down access to the details. The <code class="literal">unittest</code> library does not have an in-built way to generate nicely formatted reports. We can use the <code class="literal">HTMLTestRunner</code> extension of <code class="literal">unittest</code> written by Wai Yip Tung. You can find more about <code class="literal">HTMLTestRunner</code> at <a class="ulink" href="https://pypi.python.org/pypi/HTMLTestRunner">https://pypi.python.org/pypi/HTMLTestRunner</a> along with the download instructions.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>The <code class="literal">HTMLTestRunner</code> extension is bundled with the book's source code.</p></div></div><p>We will use <code class="literal">HTMLTestRunner</code> in our test to generate a nice-looking report. Let's modify the test suite file that we created earlier in the chapter and add <code class="literal">HTMLTestRunner</code> support. We need to create an output file that will contain the actual report, configure the <code class="literal">HTMLTestRunner</code> options, and run the tests in the following way:</p><div><pre class="programlisting">import unittest
import HTMLTestRunner
import os
from searchtests import SearchTests
from homepagetests import HomePageTest

# get the directory path to output report file
dir = os.getcwd()

# get all tests from SearchProductTest and HomePageTest class
search_tests = unittest.TestLoader().loadTestsFromTestCase(SearchTests)
home_page_tests = unittest.TestLoader().loadTestsFromTestCase(HomePageTest)

# create a test suite combining search_test and home_page_test
smoke_tests = unittest.TestSuite([home_page_tests, search_tests])

# open the report file
outfile = open(dir + "\SmokeTestReport.html", "w")

# configure HTMLTestRunner options
runner = HTMLTestRunner.HTMLTestRunner(
                 stream=outfile,
                 title='Test Report',
                 description='Smoke Tests'
                 )

# run the suite using HTMLTestRunner
runner.run(smoke_tests)</pre></div><p>Run the test suite; <code class="literal">HTMLTestRunner</code> executes all the tests similar to the <code class="literal">unittest</code> library's default test <a id="id119" class="indexterm"/>runner. At the end of the execution, it will generate a report file as shown in the following screenshot:</p><div><img src="img/3506_02_06.jpg" alt="Generating the HTML test report"/></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Summary</h1></div></div></div><p>In this chapter, we learned how to use the <code class="literal">unittest</code> testing library for writing and running tests with Selenium WebDriver. We created a test using the <code class="literal">TestClass</code> class with the <code class="literal">setUp()</code> and <code class="literal">tearDown()</code> methods. We added an assertion to check the expected output with the actual output.</p><p>We also learned how to use different types of assertions that are supported by the <code class="literal">unittest</code> library. We implemented the test suite that provides the ability to aggregate tests in logical groups. Finally, we used <code class="literal">HTMLTestRunner</code> to generate test reports in HTML format that show nicely formatted test results.</p><p>In the next chapter, we will learn how to use and define locators to interact with various HTML elements displayed on a page.</p></div></div>
</body></html>