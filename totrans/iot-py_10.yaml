- en: Chapter 10. Analyzing Huge Amounts of Data with Cloud-based IoT Analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will work with Intel IoT Analytics to analyze huge amounts
    of data with this powerful cloud-based service. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the relationship between Internet of Things and Big Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the Intel IoT Analytics structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up devices in Intel IoT Analytics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure components in Intel IoT Analytics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collect sensor data with Intel IoT Analytics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze sensor data with Intel IoT Analytics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trigger alerts with rules in Intel IoT Analytics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the relationship between Internet of Things and Big Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Big Data is watching us. We are generating valuable data each time we perform
    an action without even knowing that. Every time we tap, click, tweet, stop on
    a red light signal, hop on a bus, or perform an action caught by the millions
    of real-time sensors in any city around the world, we are generating valuable
    data. We interact with IoT devices that have sensors, collect data, and publish
    it to the Cloud. In order to analyze and process Big Data, managers, architects,
    developers, and system administrators require many skills that were not necessary
    for applications that worked with smaller data sets.
  prefs: []
  type: TYPE_NORMAL
- en: We have been working with examples that collected data from the real world through
    sensors and published it to the Cloud. We also published messages that include
    data from sensors and commands that have to be processed by code running on an
    IoT device. Sometimes, we are retrieving data from the sensors every second. Thus,
    it is very easy to realize that we generate huge amounts of data, and therefore,
    it is very important to learn many things related to Big Data. Internet of Things
    comprises Big Data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we write Python code that runs on an Intel Galileo Gen 2 board and
    performs the following actions every second:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the measured ambient temperature from a temperature and humidity sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the measured ambient humidity level from a temperature and humidity sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the measured volumetric water content in soil from ten soil moisture sensor
    that measure the values in different locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish a message with the ambient temperature, ambient humidity, and the ten
    volumetric water contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first things that might come to our mind are the number of sensors we have
    to connect to our board. Let's consider that all the sensors are digital sensors
    and we have to connect them to the I²C bus. We can connect the digital temperature
    and humidity sensor plus then ten soil-moisture sensors to the I²C bus as long
    as all the sensors have different I²C bus addresses. We just need to make sure
    that we can configure the I²C bus address for the soil moisture sensors and we
    can assign a different I²C address to each of these sensors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Catnip Electronics designed a digital soil moisture sensor that provides an
    I²C interface and one of its features is that it allows an I²C address change.
    The default I²C address for this sensor is 0x20 (hexadecimal 20) but we can easily
    change it. We just need to connect each sensor to the I²C bus, write the new address
    to register one and the new address will take effect after we reset the sensor.
    We just need to write a 6 to the sensor''s I²C address to reset the sensor. We
    can follow the same procedure for all the sensors and assign different I²C addresses
    to them. You can read more about the digital soil moisture sensor in the following
    webpage: [http://www.tindie.com/products/miceuz/i2c-soil-moisture-sensor](http://www.tindie.com/products/miceuz/i2c-soil-moisture-sensor).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to analyze hourly, daily, monthly, quarterly, and yearly data. However,
    we do need to measure every second and not every single day because it is very
    important to analyze how data changes per second. We are going to collect the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: 60 measurements for all the variables per minute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3,600 (60 * 60) measurements per hour
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 86,400 (3,600 x 24) measurements per day
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 31,536,000 (86,400 * 365) measurements per year (considering that we aren't
    talking about a leap year)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We won''t have just one IoT device collecting data and publishing it. We will
    have 3,000 IoT devices running the same code and they will generate 94,608,000,000
    (31,356,300 * 3,000), that is, ninety-four billion six hundred eight million,
    measurements per year. In addition, we have other data sources that we have to
    analyze: all the tweets about weather related issues in the locations in which
    the sensors are capturing data. Thus, we have huge volumes of both structured
    and unstructured data that we want to analyze computationally, to reveal patterns
    and associations. We are definitely talking about Big Data practices.'
  prefs: []
  type: TYPE_NORMAL
- en: The sample numbers are useful to understand the relationship between Big Data
    and IoT. We won't deploy 3,000 boards for our next example and we won't cover
    all the topics related to IoT analytics and Big Data because it would be out of
    the scope of this book. However, we will work with the cloud-based analytics system
    that works with a component included in the Intel IoT Development Kit image that
    we have been using to boot the board with the Yocto Linux meta distribution in
    [Chapter 2](ch02.html "Chapter 2. Working with Python on Intel Galileo Gen 2"),
    *Working with Python on Intel Galileo Gen 2*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Intel IoT Analytics structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we have to collect and analyze sensor data for 3,000 IoT devices,
    that is, 3,000 Intel Galileo Gen 2 boards running the Python code that interacts
    with sensors. We would need to invest in the storage and processing capacity to
    perform IoT analytics with such a huge amount of data. Whenever we have a similar
    requirement, we can take advantage of a cloud-based solution. Intel IoT Analytics
    is one of them and it works very well with the Intel Galileo Gen 2 board and Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Intel IoT Analytics requires us to sign up, create an account with a valid
    e-mail and a password, and click on the activation link of a confirmation e-mail
    before we can publish the sensor data using their free services. We aren''t required
    to enter any credit card or payment information. If you already have an account
    at Intel IoT Analytics, you can skip this step. You can also use your existing
    Facebook, Google+, or GitHub account to log in. The following is the main web
    page for the Intel IoT Analytics site: [https://dashboard.us.enableiot.com](https://dashboard.us.enableiot.com).
    Make sure to review the terms and conditions before you use this cloud-based service
    with sensitive data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you create your account and log in for the first time to Intel IoT Analytics,
    the site will display the **Create new Account** page. Enter the desired name
    to identity the account, that is, your analytics project in **Account Name**.
    Enter `Temperature and humidity` for our example and leave the default option
    for **Sensor health report**. Then, click **Create** and the site will display
    the **My Dashboard** page for the recently created account. Each account represents
    a separate workspace with its own set of sensors and related data. The site allows
    us to create more than one account and easily switch between them. The following
    screenshot shows the initial view for the **My Dashboard** page after we created
    a new account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Intel IoT Analytics structure](img/B05042_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **My Dashboard** page indicates that we still don't have registered devices,
    and therefore, we don't have either transmitting devices or observations. Each
    time we publish data from a registered device to Intel IoT Analytics, we create
    an observation for the device. Thus, the **My Dashboard** page provides the number
    of last observations in a specific period. By default, the page displays the sum
    of the last hour observations for all the registered devices. Keep the web site
    opened in your web browser because we will continue working with it later.
  prefs: []
  type: TYPE_NORMAL
- en: As a user, we can work with many accounts. Each account can contain many devices,
    has a name and an identifier known as `accountId`. Each device has a globally
    unique identifier known as `deviceId`. So, each Intel Galileo Gen 2 board that
    includes sensors will become one device for the account we have created. In our
    case, we will just work with a single Intel Galileo Gen 2 board. However, remember
    that our goal is to demonstrate how we can work with 3,000 IoT devices handled
    by a single account.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of each device as an endpoint that contains one or more components
    that can provide one of the following in Intel IoT Analytics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Actuator**: A setting that can be modified on a device. For example, rotate
    the angle of a servo''s shaft or turn on an LED.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time series**: A series of values captured from a sensor, that is, a collection
    of observations. For example, a collection of observations with ambient temperature
    values retrieved with a temperature and humidity sensor, expressed in degrees
    Fahrenheit and including timestamps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, we need a device to use the following components that will retrieve
    the values from the digital temperature and humidity sensor connected to our board:'
  prefs: []
  type: TYPE_NORMAL
- en: A time series with ambient temperature observations expressed in degrees Fahrenheit
    (ºF)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A time series with ambient temperature observations expressed in degrees Celsius
    (ºC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A time series with ambient humidity level observations expressed in percentage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we will work with the UI provided by the Intel IoT Analytics web site
    in combination with the `iotkit-admin` utility to set up the device, activate
    it and register the three components included in the previous list. This way,
    we will learn to work with the structure required by Intel IoT Analytics. Then,
    we will write Python code that uses the REST API to create observations for the
    defined components that belong to an activated device included in our recently
    created account.
  prefs: []
  type: TYPE_NORMAL
- en: We can also the REST API to perform the previously explained setup tasks by
    writing a Python code. In case we have to work with more than a dozen devices,
    we won't want to perform the setup tasks by working with the UI provided by the
    Intel IoT Analytics web site, we would definitely want to write code that automates
    the setup tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up devices in Intel IoT Analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The image that we have been using to boot our Intel Galileo Gen 2 board includes
    a local agent for Intel IoT Analytics preinstalled. Unless we have made specific
    changes to the Yocto Linux meta distribution to disable specific components, we
    will have the agent running as a daemon on the device. The agent includes the
    `iotkit-admin` command-line utility that allows us to perform specific interactions
    with Intel IoT Analytics. We will use this command-line utility to perform the
    following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Test the proper communication with Intel IoT Analytics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtain the device id
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activate a device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register three time series components for the device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send test observations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we will check whether the `iotkit-admin` command-line utility can establish
    proper communication with Intel IoT Analytics. We just need to run the following
    command in the SSH terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If the connection is successful, we will see lines similar to the following
    ones. The last line provides information about the build, that is, the version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following command in the SSH terminal to obtain the device ID,
    also known as `deviceId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The previous command will generate an output line such as the following one
    with the device ID. By default, the device ID is equal to the MAC address of the
    network interface card.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the following command to change the device ID to a different one:
    `iotkit-admin set-device-id new-device-id`. You just need to replace `new-device-id`
    with the new device id you want to set up for your device. However, bear in mind
    the new device ID must be a globally unique identifier.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will use `kansas-temperature-humidity-01` as our device ID
    for all our samples. You must replace it in all the commands, then include this
    name with the device name you retrieved or the new device ID you assign to the
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command in the SSH terminal will rename the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output for the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Go to the web browser in which you are working with the Intel IoT Analytics
    dashboard, click on the menu icon (a button with three horizontal lines located
    at the upper-left corner). Select **Account** and the site will display the **My
    Account** page with detailed information about the account we previously created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial view will display the **Details** tab. In case the **Activation
    Code** includes the **(Code Expired)** text, it means that the activation code
    is not valid anymore and it is necessary to click on the refresh icon located
    on the right-hand side of the **Activation Code** textbox (the second icon with
    the two arrows). We have to make sure that the activation code hasn''t expired
    in order to activate the device successfully. The following screenshot gives the
    initial view for the **My Account** page for the **Temperature and humidity**
    account with the activation code expired:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up devices in Intel IoT Analytics](img/B05042_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you refresh the activation code by clicking on the refresh button, a countdown
    stopwatch will indicate the time left for the activation code until it expires.
    You will have one hour after you click on the refresh button. Click on the eye
    icon to view the hidden activation code and copy it. We will use `01aCti0e` as
    our sample activation code and you will have to replace it with your activation
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the following command in the SSH terminal to activate the device with
    the previously generated activation code. Replace `01aCti0e` with your activation
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will generate an output similar to the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our Intel Galileo Gen 2 board, that is, the device, is now associated with the
    **Temperature and humidity** account that provided us with the activation code
    and the command generated the necessary security credentials, that is, the device
    token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the web browser in which you are working with the Intel IoT Analytics
    dashboard, click on the menu icon (a button with three horizontal lines located
    at the upper-left corner). Select **Devices** and the site will display the **My
    Devices** page with the list of all the devices that we have activated for the
    current account. The previously activated `kansas-temperature-humidity-01` device
    will appear in the list with **Kansas-temperature-humidity-01-NAME** in its **Name**
    column and **active** in the **Status** column. The following screenshot shows
    the device listed in the **My Devices** page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up devices in Intel IoT Analytics](img/B05042_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the device **Id** in the previous list (**kansas-temperature-humidity-01**)
    to see and edit the device details. You can add tags and attributes to make it
    easier to filter the devices in the previous list. These possibilities are extremely
    useful when we have to work with more than a dozen devices as they make it easy
    for us to filter the devices in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up components in Intel IoT Analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go to the web browser in which you are working with the Intel IoT Analytics
    dashboard, click on the menu icon, select **Account** and the site will display
    the **My Account** page. Then, click on the **Catalog** tab and the site will
    display the components registered in the catalog grouped in the following three
    categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Humidity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Powerswitch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temperature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make sure that the **Humidity** components panel is expanded and click on **humidity.v1.0**.
    The site will display the **Component definition** dialog box for the **humidity.v1.0**
    component, that is, the component named **humidity** whose version is `1.0`. The
    following screenshot shows the values for the different fields in the component
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up components in Intel IoT Analytics](img/B05042_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `humidity` component version `1.0` represents a time series with ambient
    humidity level expressed in percentage. The **Data type** is **Number**, the **Unit
    of measure** is **Percent (%)**, the **Format** is **Float** and the **Display**
    is **Time Series**. We can use this component for our ambient humidity level observations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Close**, make sure that the **Temperature** components panel is
    expanded and click on **temperature.v1.0**. The site will display the **Component
    definition** dialog box for the **temperature.v1.0** component, that is, the component
    named **temperature** whose version is `1.0`. The following screenshot shows the
    values for the different fields in the component definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up components in Intel IoT Analytics](img/B05042_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `temperature` component version **1.0** represents a time series with temperature
    expressed in degrees Celsius. The **Data type** is **Number**, the **Unit of measure**
    is **Degrees Celsius**, the **Format** is **Float** and the **Display** is **Time
    Series**. We can use this component for our ambient temperature observations expressed
    in degrees Celsius.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Close** and make sure that the **Temperature** components panel is
    expanded. There is no other temperature component, and therefore, we will have
    to create a new component for our ambient temperature observations expressed in
    degrees Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Add new Catalog Item** at the bottom of the page and the site will
    display the **Component definition** dialog box with all the fields empty except
    from the version that will have a fixed `1.0` value. We are creating the first
    version of a new catalog item. Enter and select the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter **temperaturef** in **Component Name**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select **Sensor** in **Type**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select **Number** in **Data type**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter **Degrees Fahrenheit** in **Unit of measure**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select **Float** in **Format**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select **Time Series** in **Display**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, click on **Save** and the site will add the new component definition
    at the bottom of the list with the `temperaturef.v.1.0` name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are sure that we have all the required component definitions in
    the catalog, we have to register the components that our device will use to create
    observations. We must give a name or alias of each component we register, and
    we must specify the component type and version from the previous catalog. The
    following table summarizes the components that we will register for our device:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Component name or alias | Component type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `temperaturec` | temperature.v1.0 | A time series with ambient temperature
    observations expressed in degrees Celsius (ºC) |'
  prefs: []
  type: TYPE_TB
- en: '| `temperaturef` | temperaturef.v1.0 | A time series with ambient temperature
    observations expressed in degrees Fahrenheit (ºF) |'
  prefs: []
  type: TYPE_TB
- en: '| `humidity` | humidity.v1.0 | A time series with ambient humidity level observations
    expressed in percentage |'
  prefs: []
  type: TYPE_TB
- en: 'We can use the following command to register each component: `iotkit-admin
    register component-name component-type`. We just need to replace `component-name`
    with the name that will identify the component and component-type with the name
    that identifies the component type in the catalog, including the version number.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command in the SSH terminal will register the `temperaturec`
    component from the previous table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the output for the previous command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The last line provides us with the component id, that is, the value after `cid=`
    and before the next comma (`,`). In the previous output, the component id is `c37cb57d-002c-4a66-866e-ce66bc3b2340`.
    We have to save each component id because we will need it later to write code
    that creates observations using the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command in the SSH terminal will register the `temperaturef`
    component from the previous table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output for the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As happened with the other command, the last line provides us with the component
    id, that is, the value after `cid=` and before the next comma (`,`). In the previous
    output, the component id is `0f3b3aae-ce40-4fb4-a939-e7c705915f0c`. We have to
    save this one for its later usage in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command in the SSH terminal will register the `humidity` component
    from the previous table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the output for the previous command and the last line
    includes the component id.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The component ids will be different from the values indicated in the previous
    outputs and you will have to take note of each of the component ids that have
    been generated with the previous commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the web browser in which you are working with the Intel IoT Analytics
    dashboard, click on the menu icon. Select **Devices** and the site will display
    the **My Devices** page. Click on the device **Id** in the previous list (**kansas-temperature-humidity-01**)
    to see and edit the device details. Click on **+Components** to expand the components
    registered for the device and you will see a list with the following three components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**temperaturec**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**temperaturef**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**humidity**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the three components registered for the selected
    device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up components in Intel IoT Analytics](img/B05042_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can click on any of the three components and check the details for the registered
    component. In case we lose the component id, we can retrieve it by clicking on
    the component and the **Component Definition** dialog box will display the component
    id just below the component type description. The following screenshot shows the
    component definition for the `temperaturef` component. The component id **0f3b3aae-ce40-4fb4-a939-e7c705915f0c**
    appears below the **Custom Component** label on the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up components in Intel IoT Analytics](img/B05042_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Unluckily, there is no way to retrieve the device token that was generated
    when we activated the device with the features included in the site. We need the
    device token to create observations for the registered components. The agent for
    Intel IoT Analytics saves the device token with other configuration values for
    the device in the `device.json` file and its default path is `/usr/lib/node_modules/iotkit-agent/data/device.json`.
    As the file name suggests, the file contains JSON code. We just need to run the
    following command in the SSH terminal to display the text content from the previous
    file and allow us to retrieve the device token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the output for the previous command that includes all
    the configurations we have made so far for our device. The line that defines the
    value for the device token is highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The previous lines also show the component id for each of the components that
    we have registered. Thus, we have all the necessary configuration values that
    we will have to use in our code in just one place. In this case, the device token
    is the following, that is, the string value for the `"device_token"` key. However,
    the value that you will retrieve will be different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Collecting sensor data with Intel IoT Analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will take the code we wrote in [Chapter 8](ch08.html "Chapter 8. Displaying
    Information and Performing Actions"), *Displaying Information and Performing Actions*,
    when we read temperature and humidity values from the sensor, we printed the values
    in an OLED matrix and rotated a servo's shaft to display the measured temperature
    expressed in degrees Fahrenheit with the shaft. The code file for the sample was
    `iot_python_chapter_08_03.py`. We will use this code as a baseline to add new
    features that will allow us to create observations for the three components we
    registered for our activated device.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Working with Python on Intel Galileo Gen
    2"), *Working with Python on Intel Galileo Gen 2*, we made sure that the `pip`
    installer was available to install additional Python 2.7.3 packages in the Yocto
    Linux that we are running on the board. Now, we will use `pip` installer to make
    sure that the `requests` package is installed. This package is a very popular
    HTTP library for Python that allows us to easily build and send HTTP requests
    with an extremely easy to understand syntax.
  prefs: []
  type: TYPE_NORMAL
- en: If you have worked with examples from the previous chapter, you will have this
    package already installed. However, in case you just jumped into this chapter,
    it might be necessary to install it. We just need to run the following command
    in the SSH terminal to install the package. Notice that it can take a few minutes
    to complete the installation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In case you see the following output, it means that the requests package was
    already installed and you can move on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create an `IntelIotAnalytics` class to represent the interface to Intel
    IoT Analytics and make it easy for us to publish observations for the three components.
    However, before we code the class, we have to make sure that we can replace the
    content for many class attributes that define important values related to our
    account, the components, and the device. You will have to replace the strings
    specified for the following class attributes with the appropriate values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`account_name`: The value of the **Account name** field in the **My Account**
    page. In our example, we used `"Temperature and humidity"` for our account name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`account_id`: The value of the **Account ID** field in the **My Account** page.
    In our example, we use `"22612154-0f71-4f64-a68e-e116771115d5"` for our account
    id. We can also retrieve the account id value by reading the string value specified
    for the `"account_id"` key in the `device.json` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`device_id`: The value of the **ID** field in the **Add / Edit a Device** page
    that the site shows when we click on a device name in the list displayed in the
    **My Devices** page. In our example, we use `"kansas-temperature-humidity-01"`
    for our device id. We can also retrieve the device_id by running the following
    command in an SSH terminal: `iotkit-admin device-id` or by reading the string
    value specified for the `"device_id"` key in the `device.json` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`device_token`: The value of the device token that was generated when we activated
    the device. As previously explained, we can retrieve the device token by reading
    the string value specified for the `"device_token"` key in the `device.json` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`component_id_temperature_fahrenheit`: The value of the component id that was
    generated when we registered the `temperaturef` component. The component id is
    displayed below the component type in the **Component Definition** dialog box.
    In our example, we use `"0f3b3aae-ce40-4fb4-a939-e7c705915f0c"` for this value.
    We can also retrieve the component id value by reading the string value specified
    for the `"cid"` key in the same block that declares the `"name": "temperaturef"`
    key-value pair, in the `device.json` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`component_id_temperature_celsius`: The value of the component id that was
    generated when we registered the `temperaturec` component. In our example, we
    use `"c37cb57d-002c-4a66-866e-ce66bc3b2340"` for this value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`component_id_humidity_level_percentage`: The value of the component id that
    was generated when we registered the `humidity` component. In our example, we
    use `"71aba984-c485-4ced-bf19-c0f32649bcee"` for this value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code file for the sample is `iot_python_chapter_10_01.py`. Remember that
    we use the code file `iot_python_chapter_08_03.py` as a baseline, and therefore,
    we will add the `IntelIotAnalytics` class to the existing code in this file and
    we will create a new Python file. The following lines show the code for the `IntelIotAnalytics`
    class that allows us to publish observations for the `temperaturef`, `temperaturec`
    and `humidity` components through the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IntelIotAnalytics` class declares many class attributes that we explained
    before and that you need to replace with your own string values: `account_name`,
    `account_id`, `device_token`, `device_id`, `component_id_temperature_fahrenheit`,
    `component_id_temperature_celsius` and `component_id_humidity_level_percentage`.
    The `base_url` class attribute defines the base URL to access the REST API: `https://dashboard.us.enableiot.com/v1/api`.
    We will use this value in combination with a `data` path and the `device_id` class
    attribute to build the URL to which we will send the HTTP request to publish an
    observation.'
  prefs: []
  type: TYPE_NORMAL
- en: The class declares the `publish_observation` method that receives the temperature
    expressed in degrees Fahrenheit, the temperature expressed in degrees Celsius
    and the humidity level percentage in the `temperature_fahrenheit`, `temperature_celsius`
    and `humidity_level` arguments. The method builds the URL to which we will send
    the HTTP request to create an observation for the device and the three components.
    The URL is composed of the `base_url` class attribute, `/data/` and the `device_id`
    class attribute. As happens with many REST APIs, the `base_url` class attribute
    specifies the version number for the API. This way, we make sure that we are always
    working with a specific version and that our requests are compatible with this
    version. The code saves the value for the build URL in the `url` local variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the code saves the board''s current time in seconds multiplied by 1000
    in the `now` local variable. The code creates a `body` dictionary that represents
    the request''s body with the following key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"on"`: The value stored in the `now` local variable, that is, the board''s
    current time. It is the time for the observations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"accountId"`: The value stored in the `accountId` class attribute, that is,
    the Intel IoT Analytics account to which we will publish the observation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"data"`: An empty array that we will fill later with one observation for each
    component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, the code creates three dictionaries with the following key-value pairs
    that represent an observation for a specific component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"componentId"`: The value stored in the class attribute that specifies the
    component id to which we will publish the observation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"on"`: The value stored in the `now` local variable, that is, the board''s
    current time. It is the time for the observation. We use the same variable for
    all the observations, and therefore, they are registered with the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"value"`: The string representation of the value received as an argument in
    the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the code calls the `append` method to add the three dictionaries to the
    `data` key in the `body` dictionary. This way, the `data` key will have an array
    with three dictionaries as its value. The code calls the `json.dumps` function
    to serialize the `body` dictionary to a JSON formatted string and saves it in
    the `data` local variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line creates a `headers` dictionary with the following key-value pairs
    that represent the headers for the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"Authorization"`: The authorization string composed of the concatenation of
    `"Bearer"` and the device token saved in the `device_token` class attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"content-type"`: Declares the content type as JSON: `"application/json"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, the code has built the headers and the body for the HTTP request
    that will publish the observations to Intel IoT Analytics. The next line calls
    the `requests.post` function to send an HTTP POST request to the URL specified
    by the `url` local variable, with the `data` dictionary as the JSON body data
    and the `headers` dictionary as the headers.
  prefs: []
  type: TYPE_NORMAL
- en: The `requests.post` method returns a response saved in the `response` local
    variable and the code evaluates whether the code attribute for response is not
    equal to 201\. In case the code is different than `201`, it means that the observations
    weren't successfully published, that is, something went wrong. In this case, the
    code prints the values for the `status_code` and `text` attributes for the response
    to the console output to allow us to understand what went wrong. In case we use
    a wrong device token or a wrong id for the account, the device or the components,
    we will receive errors.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will use the previously coded `IntelIoTAnalytics` class to create a
    new version of the `__main__` method that publishes observations to Intel IoT
    Analytics every 5 seconds. The following lines show the new version of the `__main__`
    method. The code file for the sample is `iot_python_chapter_10_01.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines show the code that creates an instance of the previously
    created `IntelIoTAnalytics` class and saves its reference in the `intel_iot_analytics`
    local variable. Then, the code within the loop that runs every 5 seconds calls
    the `publish_observation` method with the temperature and humidity values retrieved
    from the temperature and humidity sensor as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line will start the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After you run the example, turn on an air conditioner or a heating system, to
    generate a change in the ambient temperature and humidity. This way, we will notice
    changes in the data that is being published every 5 seconds. Keep the code running
    while we explore different features included in Intel IoT Analytics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the web browser in which you are working with the Intel IoT Analytics
    dashboard, click on the menu icon and select **Dashboard**. The site will display
    the **My Dashboard** page that will indicate you have one active device and it
    will update the number of observations published in the last hour as it receives
    observations from the board. The following pictures show the dashboard with the
    active device and the counter that includes `945` observations published in the
    last hour:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collecting sensor data with Intel IoT Analytics](img/B05042_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Keep the browser open with the dashboard view and you will notice that observations
    value increases in the last hour, as the code continues running on the board.
    You can click on the configuration icon located at the upper-right corner of the
    panel that displays the number of observations and a context-menu will allow you
    to configure the observations period you want to see in this panel. For example,
    you can change from **Last hour** to **Last week** to display the number of observations
    the device has registered during the last week.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing sensor data with Intel IoT Analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intel IoT Analytics allows us to generate charts with the data generated for
    each component that has observations for a specific device. First, we have to
    select the device and then we have to choose one or more component to generate
    the chart with historic time series or the time series that are being generated
    with the code running on the board, that is, live data for the component.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the web browser in which you are working with the Intel IoT Analytics
    dashboard, click on the menu icon and select **Charts**. The site will display
    the **My Charts** page that will allow you to search for devices using many search
    criteria, such as the device name, the associated tags, and its properties.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we just have one activated device, and therefore, we can select
    the device from the list of devices that the site shows us below the **Select
    Device** section. This section displays the first characters for the device name
    at the right-hand side of a checkbox and the number of components that have been
    registered for this device at the right-hand side of the text. The following picture
    shows the **Select Device** section with **kansas-temp…** representing the `kansas-temperature-humidity-01`
    device. If you hover the mouse over the checkbox or tap on the text, the site
    will display a popup with the complete name for the device and the types of the
    registered components. The following screenshot show the popup with this information
    displayed for the **kansas-temp…** checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing sensor data with Intel IoT Analytics](img/B05042_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Check the **kansas-temp…** checkbox and the site will display the three registered
    components for the selected device. In this case, the site displays the component
    names (`temperaturec`, `temperaturef`, and `humidity`) while in the previously
    explained popup the site showed the component types (`temperature.v1.0`, `temperaturef.v1.0`,
    and `humidity.v1.0`).
  prefs: []
  type: TYPE_NORMAL
- en: Check the `temperaturef` checkbox and the site will display a chart with the
    ambient temperature measured in degrees Fahrenheit for the past hour. By default,
    the chart uses a line and generates a graph with the time series values registered
    in the past hour. By default, the refresh rate for the graph is set to 30 seconds,
    and therefore, the chart will be updated every 30 seconds and will display all
    the new observations that were published by the board through the REST API in
    this period.
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing sensor data with Intel IoT Analytics](img/B05042_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can use the different buttons at the top of the chart to change the chart
    type and to select the time range we want to view displayed in the graph. We can
    also change the refresh rate to as low as five seconds or as high as 60 seconds.
    If we save the graph as favorite, the site will display it as part of the dashboard
    in **My Dashboard**.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Raw data** button (A bullets icon) located at the right-hand
    side of the **Chart** button (A picture icon with mountains). The site will display
    a list with the raw data that has been sent to build the time series, that is,
    all the observations received for the selected component. The following screenshot
    shows an example of the first page of the raw data view for the `temperaturef`
    component in the past hour.
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing sensor data with Intel IoT Analytics](img/B05042_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, it is extremely useful to generate a chart with the temperature
    and the humidity level. Go back to the Chart view by clicking on the **Chart**
    button (A picture icon with mountains) and check the checkbox for humidity. This
    way, the site will generate a graph that combines the temperature expressed in
    degrees Fahrenheit and the humidity level expressed in percentage. The following
    screenshot shows the generated chart when **temperaturef** and **humidity** are
    both checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing sensor data with Intel IoT Analytics](img/B05042_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Triggering alerts with rules in Intel IoT Analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Intel IoT Analytics allows us to define the rules that can trigger any of the
    following notification types:'
  prefs: []
  type: TYPE_NORMAL
- en: Email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP Endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actuation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to the web browser in which you are working with the Intel IoT Analytics
    dashboard, click on the menu icon and select **Rules**. The site will display
    the **My Rules** page that will allow you to define rules for the activated devices.
    In this case, we will define a rule that will send us an e-mail when the humidity
    level is lower than 10%.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Add a rule** and the site will display us a form that will allow
    us to enter the details for the new rule. Enter `Very low humidity level` in **Rule
    Name**, select `Low` in **Priority** and `Email` in **Notifications type**. Select
    the e-mail address to which you want to receive the notifications in the dropdown
    in the **Notifications To** panel.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** and the site will ask us to select the devices to which the new
    rule has to be applied. In this case, we just have one activated device, and therefore,
    we can select the device from the list of devices that the site shows us below
    the **Select Device** section. As seen in previous device selection pages, this
    section displays the first characters for the device name at the right-hand side
    of a checkbox and the number of components that have been registered for this
    device at the right-hand side of the text. Check the **kansas-temp…** checkbox
    and the name will appear in the **Selected Devices** list.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** and the site will ask us to specify the conditions for the new
    rule. Leave the **Enable Automatic Reset** checkbox unchecked because we want
    the rule to become inactive after every alert until it is acknowledged. This way,
    after we receive an alert, we will only receive additional alerts when we acknowledge
    the first alert that was generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select `humidity (Number)` in **Monitored Measure** and `Basic Condition` in
    **Trigger When**. Then, select `<` in the additional dropdown that appears and
    enter `10` in the **Enter a value** textbox. This way, we are creating a rule
    that will trigger when the value in a humidity observation is lower than 10 (`humidity
    < 10`). The following screenshot shows the defined condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Triggering alerts with rules in Intel IoT Analytics](img/B05042_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click **Done** and the rule will be added to the list shown in **My Rules**.
    The following screenshot shows the rule definition included in this list after
    we define it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Triggering alerts with rules in Intel IoT Analytics](img/B05042_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After the humidity level is lower than 10%, an alert will be triggered and
    we will see a number 1 in the alerts icon (the bell). After we click on the icon,
    the site will display all the unread alerts we have. The following screenshot
    shows the My Dashboard page with one unread alert:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Triggering alerts with rules in Intel IoT Analytics](img/B05042_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we click on the alert, the site will display the details of the situation
    that triggered the alert. We can also go **Alerts** in the menu and see the list
    of the received alerts. The following screenshot show the alert included in the
    list of received alerts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Triggering alerts with rules in Intel IoT Analytics](img/B05042_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we click on the **Alert** number, the site will display the details for
    the alert including the condition defined in the rule that triggered the alert
    and the measured value. In this case, the measured value was `7.99`. It is possible
    to add comments to an alert. The following screenshot shows the details for the
    alert:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Triggering alerts with rules in Intel IoT Analytics](img/B05042_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition, we receive an e-mail that includes the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we defined a very simple condition in our rule. However, we can
    define a more complex condition that can include any of the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Time-based condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statistics based condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single-sensor change detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multisensory change detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can play with the different options to trigger alerts for a large number
    of devices with multiple sensors and huge amounts of data. One of the most interesting
    features of Intel IoT Analytics is that we can easily work with huge amounts of
    data with the charts, the rules and the alerts.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The components for each device in Intel IoT Analytics can be either:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Actuator or time series.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Account, actuator or time series.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Proxy, account, actuator or time series.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Each time we publish data from a registered device to Intel IoT Analytics,
    we create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An actuator.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An account.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An observation.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A time series is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A series of actions performed by an actuator, that is, a collection of actions.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A series of values captured from a sensor, that is, a collection of observations.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A series of triggered alarms, that is, a collection of alarms.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use the following command-line utility to activate our board as a device
    in an Intel IoT Analytics account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: iotkit-admin
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: iotkit-configure
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: iotkit-setup
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to send observations from a device with the REST API provided by Intel
    IoT Analytics, we need the following token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sensor token.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The observation token.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The device token.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood the close relationship between Internet of Things
    and Big Data. We worked with a cloud-based service that allowed us to organize
    huge amounts of data collected by multiple devices and their sensors. We took
    advantage of the `requests` package to write a few lines of Python code that could
    interact with the Intel IoT Analytics REST API.
  prefs: []
  type: TYPE_NORMAL
- en: We used the Intel IoT Analytics web site to set up a device and its components.
    Then, we made changes to one of our examples to collect data from the sensors
    and publish observations to Intel IoT Analytics. Then, we learned about the different
    options that Intel IoT Analytics offers us to analyze huge amounts of data. Finally,
    we defined rules that triggered alerts. Now that we are able to take advantage
    of Intel IoT Analytics to analyze huge amounts of data, we are ready to deploy
    thousands of IoT devices that collect data from multiple sensors.
  prefs: []
  type: TYPE_NORMAL
- en: We learned to use Python and the Intel Galileo Gen 2 board to create low cost
    devices that collect huge amounts of data, interact with each other and take advantage
    of cloud-services and cloud-based storage. We can develop IoT prototypes from
    the hardware selection to all the necessary stacks with Python 2.7.3, its libraries
    and tools. In case we need a smaller board or a different alternative, we can
    switch to any of the compatible Intel Edison boards, and therefore, we can switch
    to this board in case we need to.
  prefs: []
  type: TYPE_NORMAL
- en: We are able to leverage our existing Python knowledge to capture data from the
    real world, interact with physical objects, develop APIs and use different IoT
    protocols. We learned to use specific libraries to work with low-level hardware,
    sensors, actuators, buses, and displays. We are ready to become makers and to
    be part of the exciting IoT world.
  prefs: []
  type: TYPE_NORMAL
- en: We can start working on fascinating projects that can transform everyday objects
    into smart devices with sensors and actuators. We are ready to start building
    ecosystems composed of thousands of IoT devices, with Python as our main programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A. Exercise Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1, Understanding and Setting up the Base IoT Hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| Q1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Q2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Q3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Q4 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Q5 | 1 |'
  prefs: []
  type: TYPE_TB
- en: Chapter 2, Working with Python on Intel Galileo Gen 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| Q1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Q2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Q3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Q4 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Q5 | 1 |'
  prefs: []
  type: TYPE_TB
- en: Chapter 3, Interacting with Digital Outputs with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| Q1 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Q2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Q3 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Q4 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Q5 | 2 |'
  prefs: []
  type: TYPE_TB
- en: Chapter 4, Working with a RESTful API and Pulse Width Modulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| Q1 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Q2 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Q3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Q4 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Q5 | 2 |'
  prefs: []
  type: TYPE_TB
- en: Chapter 5, Working with Digital Inputs, Polling and Interrupts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| Q1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Q2 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Q3 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Q4 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Q5 | 3 |'
  prefs: []
  type: TYPE_TB
- en: Chapter 6, Working with Analog Inputs and Local Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| Q1 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Q2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Q3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Q4 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Q5 | 3 |'
  prefs: []
  type: TYPE_TB
- en: Chapter 7, Retrieving Data from the Real World with Sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| Q1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Q2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Q3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Q4 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Q5 | 1 |'
  prefs: []
  type: TYPE_TB
- en: Chapter 8, Displaying Information and Performing Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| Q1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Q2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Q3 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Q4 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Q5 | 2 |'
  prefs: []
  type: TYPE_TB
- en: Chapter 9, Working with the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| Q1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Q2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Q3 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Q4 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Q5 | 1 |'
  prefs: []
  type: TYPE_TB
- en: Chapter 10, Analyzing Huge Amounts of Data with Cloud-based IoT Analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| Q1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Q2 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Q3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Q4 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Q5 | 3 |'
  prefs: []
  type: TYPE_TB
