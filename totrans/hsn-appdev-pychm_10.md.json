["```py\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = 'django-insecure-39u&w+cgs2t4*jwe3nuz4y4j^s!s65^xb7eqtb_a3bl!a_s%tn'\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = True\n```", "```py\n# Database\n# https://docs.djangoproject.com/en/4.2/ref/settings/#databases\nDATABASES = {\n  'default': {\n    'ENGINE': 'django.db.backends.sqlite3',\n    'NAME': BASE_DIR / 'db.sqlite3',\n  }\n}\n```", "```py\nfrom django.db import models\n# Create your models here.\n```", "```py\nfrom django.db import models\nimport datetime\nfrom django.utils import timezone\n```", "```py\n# Create your models here.\nclass Author(models.Model):\n  first_name = models.CharField(max_length=100)\n  last_name = models.CharField(max_length=100)\n  def __str__(self):\n    return f'{self.last_name}, {self.first_name}'\n```", "```py\nclass Book(models.Model):\n  title = models.CharField(max_length=200)\n  author = models.ForeignKey(Author, on_delete=models.CASCADE,)\n  pub_date = models.DateTimeField('date published')\n```", "```py\npub_date = models.DateTimeField('date published')\n```", "```py\n  def was_published_recently(self):\n    now = timezone.now()\n    return now - datetime.timedelta(days=1) <= self.pub_date <= now\n```", "```py\nmakemigrations TheGreatBookery\n```", "```py\nsqlmigrate TheGreatBookery 0001\n```", "```py\nmigrate\n```", "```py\ncreatesuperuser\n```", "```py\nrunserver\n```", "```py\n# Register your models here.\nfrom .models import Author\nadmin.site.register(Author)\n```", "```py\nfrom django.contrib import admin\n# Register your models here.\nfrom .models import Author, Book\nclass BookInLine(admin.TabularInline):\n  model = Book\n  extra = 1\n  fieldsets = [\n    (None, {'fields': ['title']}),\n('Date information', {'fields': ['pub_date']})\n  ]\nclass AuthorAdmin(admin.ModelAdmin):\n  inlines = [BookInLine]\nadmin.site.register(Author, AuthorAdmin)\n```", "```py\nfrom django.shortcuts import render\nfrom .models import Book\n# Create your views here.\ndef index(request):\n  latest_books = Book.objects.order_by('-pub_date')[:5]\n  context = {'latest_books': latest_books}\nBook model, then defined a method designed to accept a request, retrieve all the books in the database, and order them by the pub_date field in descending order indicated by the minus sign next to pub_date. We’re only going to display the first five books we find as indicated by the slice [:5].\nNext, we create a variable called context ,which becomes a dictionary that will be used to pass data to the template during rendering. In this case, it creates a key-value pair where the key is `latest_books` and the value is the `QuerySet` of the latest books retrieved in the previous step.\nThe `return` line calls the `render` method imported at the top of the file. It passes the `request` object, a path to the template (which we have yet to create), and the `context` dictionary variable we just created.\nThis view function won’t do all the work by itself. Before it can be used, it must be registered in the `urls.py` file so we have a route to employ this function.\nOpen `urls.py` and change the code to this:\n\n```", "```py\n\n We added an import to the `index` function we just created in the `views.py` file. Next, we added by way of the `path` function an empty string, which will map the root route for the app, a reference to the `index` function that will execute in response to requests at the root route, and a friendly name.\nWe’re almost done. There’s just one more thing. Go back to the `view.py` file and you’ll see some problematic yellow highlighting. See *Figure 10**.18*.\n![Figure 10.18: We have a view and a URL mapped, but we haven’t made the template yet](img/B19644_10_18.jpg)\n\nFigure 10.18: We have a view and a URL mapped, but we haven’t made the template yet\nHover your mouse over `index.html` and note that the tooltip has an action available to create the template for us. Either click the blue link text in the tool-tip window or use *Alt* + *Shift* + *Enter* as indicated. *Figure 10**.19* shows the ensuing dialog.\n![Figure 10.19: The dialog you get when you use the in-line action to create the missing template is automatically filled in based on some obvious assumptions](img/B19644_10_19.jpg)\n\nFigure 10.19: The dialog you get when you use the in-line action to create the missing template is automatically filled in based on some obvious assumptions\nWhen you click `Templates` called `TheGreatBookery`. It is possible to have multiple apps in your Django project. Since that is the case, you might want to segregate your templates. Go ahead and let PyCharm create the folder for you. After it does, you get an empty file called `index.html`.\nThis isn’t a book on web page design, so we aren’t even going to try to make this pretty. Enter this code into your `index.html` page:\n\n```", "```py\n\n This looks a lot like Jinja2 code we saw in [*Chapter 8*](B19644_08.xhtml#_idTextAnchor203) with Flask. It is very similar. All this code does is check whether or not a dictionary key called `latest_books` exists on the data context that was passed in. If you go back and look at the `render` function we called in the view, it’s passing this in.\nIf the key is there, we render the contents using the templates for loop syntax. This isn’t exactly an amazing UI. It is just going to render an unordered list with each book as a list item. If the key were not there, then we’ll be rendering a paragraph that says **No** **books available**.\nWhat’s with the weird Python icon in the template gutter?\nYou might have noticed a big, juicy Python icon in the gutter of the `index.html` file. Check out *Figure 18**.20*.\n![Figure 10.20: Look at that icon up there just begging to be clicked!](img/B19644_10_20.jpg)\n\nFigure 10.20: Look at that icon up there just begging to be clicked!\nThat Python icon is actually called a *Pythicon*.\nOK, no it isn’t, I just made that up. Still, you really want to click it, don’t you? Go ahead, click it! It takes you to the Python code in `views.py` where we invoke it. Travel works both ways. In `views.py`, you’ll notice a more subtle icon in the gutter where the template is invoked. See *Figure 18**.21*.\n![Figure 10.21: Click the HTML icon to navigate to the template](img/B19644_10_21.jpg)\n\nFigure 10.21: Click the HTML icon to navigate to the template\nAgain, just click the html icon, er, I mean HTML icon, to go to the template. I wouldn’t blame you for clicking back and forth between the two while saying, *“Take that, vi* *and emacs!”*\nRun it!\nStart or restart your server and check the results as seen in *Figure 18**.22*. \n![Figure 10.22: This might be the best website ever!](img/B19644_10_22.jpg)\n\nFigure 10.22: This might be the best website ever!\nIf you direct your browser to [http://localhost:8000/](http://localhost:8000/) you should see either some books or a message stating there are no books. I added some obvious reading choices and so my run looks absolutely glorious!\nClearly, you could leverage the HTML tooling we learned in [*Chapter 7*](B19644_07.xhtml#_idTextAnchor172) to make this nicer, but we still have more ground to cover, so I’ll leave that up to you.\nBuilding Pyramid applications with PyCharm\nWe’ve seen three popular web frameworks so far. There is one left that is listed in PyCharm’s **New Project** menu: **Pyramid**. You can find details on Pyramid at [https://trypyramid.com/](https://trypyramid.com/).\nThe organization behind Pyramid bills it as a framework that allows you to start small, finish big, and stay finished. To my mind, this might be a little bit of a dig at its main competitors. Django is criticized as being overly opinionated, and for being overkill for small projects. This fits with the “start small” idea in Pyramid. You have more leeway in choosing the components for your application, and you can leave out what you don’t need. For example, you can choose from a couple of ORM libraries, or simply choose not to use one. Django really wants you to use theirs.\nFlask, in contrast, doesn’t come with an ORM or anything really, besides Jinja2 for templating. Flask is criticized for not being performant in large applications. The “finish big” concept seems to speak to this criticism. I’m not sure what, if anything, the “stay finished” directive is criticizing. I think that’s something we all want.\nHaving seen the first-rate tooling for Django, switching to Pyramid now is going to seem underwhelming. Django is a good candidate for custom tooling because it is complex, and it makes a lot of technical decisions for you. We can consider the `manage.py` task panel as an example. There are tons of commands in `manage.py`, so having its own panel makes sense. It also helps that Django is wildly popular. Pyramid isn’t. So from a PyCharm perspective, this is a much simpler proposition in terms of tooling.\nCreating a Pyramid project\nCreating a Pyramid project is no different from any other. Just use **File | New Project**, and pick the **Pyramid** template, as shown in *Figure 10**.23*.\n![Figure 10.23: PyCharm has a project template for Pyramid](img/B19644_10_23.jpg)\n\nFigure 10.23: PyCharm has a project template for Pyramid\nAs with Django, you should twirl down the advanced settings, as shown in *Figure 10**.23*. You are able to set a project name, as you were in Django. Be careful with this setting!\nPyramid project name\nMake sure the project name is different than the PyCharm project name entered in the **Location** box.\nWhen working with Pyramid, it’s a best practice to have a PyCharm project name that is different from the project name you define within Pyramid. This separation of names is recommended to avoid potential conflicts and confusion between the two namespaced systems: PyCharm, an IDE, and Pyramid, a Python web framework.\nHere’s why it’s advisable to keep them different:\n\n*   **Namespace clashes**: If your PyCharm project name matches your Pyramid project name exactly, you may encounter namespace clashes or naming conflicts. These conflicts can make it challenging for PyCharm to distinguish between project-specific settings, configurations, and files, and the Pyramid framework-specific files and configurations. This can lead to confusion and potential errors in your development process.\n*   **PyCharm project settings**: PyCharm uses the project name for its internal settings and configurations, including virtual environments, code analysis, and project-specific settings. If your PyCharm project name is the same as your Pyramid project name, PyCharm might overwrite or interfere with Pyramid-specific configurations and settings.\n*   **Clarity and maintainability**: Keeping distinct names for your PyCharm project and Pyramid project helps maintain clarity and organization in your development environment. It makes it easier to understand which aspects of your development are controlled by PyCharm and which are specific to your Pyramid web application.\n*   **Flexibility**: Having different names provides flexibility, especially if you work on multiple projects with Pyramid or use PyCharm for various other Python projects. It prevents potential conflicts when switching between projects.\n\nI’m going to name my imaginary project `giza_application`, a nod to the location of the Great Pyramids of Egypt.\nHaving set the project name, you can select from two template engines: **Jinja2** and **Chameleon**. Finally, you have settings for the ORM, which here is specified as **Backend**. The two choices are **SQLAlchemy**, which is very popular, and **ZODB**, which is somewhat exotic.\nSQL Alchemy is a straightforward ORM used for working with relational databases. You create models as we did with Django’s ORM, and through a migration process, you can apply your database schema changes to a new or existing database.\nZODB refers to the Zope database. Generally speaking, Zope is an open source web application server written in Python. Less generally speaking, it is used as a content management system similar to WordPress. The database component, ZODB, has some interesting features that distinguish it from typical relational databases. It’s a powerful tool that can be used in conjunction with the Pyramid web framework to manage data in a more Pythonic way. Here’s how ZODB integrates into a Pyramid project and some of its features:\n\n*   **Python native**: ZODB lets you store Python objects without needing to serialize them into a different format. You can work with complex data structures directly, without having to map them to a relational database schema.\n*   **ACID transactions**: ZODB supports **Atomicity, Consistency, Isolation, Durability** (**ACID**) transactions. This ensures that your data remains consistent, even if something goes wrong during a transaction.\n*   `pyramid_zodbconn` package. This provides a smooth way to get a ZODB connection within Pyramid’s request handling.\n*   **Hierarchical storage**: ZODB allows you to organize your data in a tree-like structure. This can be particularly useful in a Pyramid application using traversal, where the URL structure often mirrors a hierarchical data structure.\n*   **Scalability**: ZODB can be scaled across multiple machines, allowing for more extensive and complex applications.\n*   **Versioning**: ZODB supports object versioning, allowing you to keep track of changes to objects over time. This can be useful for implementing features such as undo/redo.\n*   `repoze.catalog`.\n*   **No schema required**: Unlike relational databases, ZODB doesn’t require a fixed schema, offering flexibility in data modeling. You can modify the Python classes used for storage without needing to migrate data.\n*   **Blob support**: ZODB supports the storage of large binary objects (BLOBs), such as images or videos, alongside regular objects.\n*   **Persistence**: ZODB provides a straightforward persistence model. Any changes to persistent objects within a transaction are automatically saved to the database when the transaction is committed.\n*   **Compatibility**: ZODB works well with various WSGI servers and can be integrated into a Pyramid application running on different platforms.\n\nZODB can be a compelling choice for Pyramid developers looking for a database that aligns closely with Python’s object-oriented paradigm. Its integration into a Pyramid project allows for intuitive data management without the need for complex SQL queries or ORM mapping, making it an attractive option for certain types of applications. If the hierarchical, object-oriented nature of ZODB fits the data model of your Pyramid application, it may be an excellent choice. From a PyCharm perspective though, there is no special tooling for this database.\nClicking the **OK** button will generate the project structure and the run configuration.\nI really wish there was more to say here, but in truth, besides Djano, any other framework that could have been covered last would have the same problem. We’ve already covered PyCharm’s tools for developing web applications in an unopinionated framework. We have seen the support for Jinja2 templates, working with an ORM, and obviously general Python project work.\nSummary\nIn this chapter, we examined various PyCharm features regarding supporting and automating tasks in the process of web development with Django. While this list of features is in no way exhaustive, I hope it can offer you a solid starting point to continue discovering other powerful features for your web development process.\nFirst, we see that, by specifying the PyCharm project type as Django, an extensive project skeleton will be generated with convenient boilerplate code already filled out. With the implementation of the `manage.py` panel inside the project window as well as its run/debug configuration, PyCharm additionally allows for a higher level of development, with various tasks traditionally achieved via the command line, such as running the server or making migrations. Finally, by acknowledging integrated views and templates in Django, PyCharm makes it as easy as possible for developers to work with them in the editor—be it generating a missing template, code completion even in HTML and Jinja, or even dynamically switching between views and templates.\nWe concluded with a short coverage of Pyramid. Pyramid is a framework that aims to be more flexible than Django but packs more features than Flask. It’s a happy medium between the two. Unfortunately for Pyramid, we covered it last. PyCharm doesn’t have any special tooling for Pyramid beyond the project template that creates the project structure. To be fair, if Flask had gone last, it would have suffered the same fate because most of PyCharm’s web development tools are useful regardless of which framework you choose. Pyramid has some great features and is worthy of consideration for any project.\nIn the next chapter, we will tackle the last major component of any web application: the database. Buckle up, because the tooling for databases in PyCharm is extensive!\nQuestions\n\n1.  What are the major characteristics of Django, and how do they set Django apart from another popular Python web framework, Flask?\n2.  What is the purpose of the PyCharm `manage.py` panel in a Django project, and how does one open and utilize it?\n3.  What is the purpose of the Django admin interface? How does one create an instance of a model (that is, a new entry in a database table) in this interface? How does the process change if the model references another model?\n4.  What is the purpose of the run/debug configuration in PyCharm in the context of running a Django server?\n5.  Does PyCharm’s code completion logic only apply to Python code in Django projects?\n6.  What is the significance of being able to switch between Django views and corresponding templates in PyCharm?\n7.  Describe the PyCharm tooling available for the Pyramid framework.\n\nFurther reading\nBe sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).\nCheck the following resources to expand on what was covered in this chapter:\n\n*   *Web Development with Django,* *Second Edition*\n*   *Hands-On RESTful Python Web Services,* *Second Edition*\n\n```"]