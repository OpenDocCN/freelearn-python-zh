- en: 'Chapter 10. Heaps: Ordered Trees'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Heaps** are a special category of the tree data structure, that are ordered
    with respect to the value of the tree''s nodes or the keys associated with each
    node. This ordering is either ascending in a min heap, meaning that the root node
    is smaller in value or priority than it''s child nodes, or descending in a max
    heap, meaning that the root node is larger in value or priority than it''s child
    nodes. Note that heap data structures should not be confused with the heap memory
    of a computer system, which is the name typically used for system''s dynamically
    allocated memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the heap data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating heaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like trees, heaps are typically implemented using either linked lists or linked
    nodes, or an array. Since we examined the linked node approach in [Chapter 9](part0050_split_000.html#1FLS41-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 9. Trees: Non-Linear Structures"), *Trees: Nonlinear Structures*, in
    this chapter, we''ll examine an array implementation of a heap called a **binary
    heap**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Heap implementations](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A binary heap is a tree structure where all levels of the tree are filled completely,
    with the possible exception of the last or deepest level. In the case of the deepest
    level the nodes are filled from left to right until the level is full. As you
    can see from the preceding figure, in an array-based implementation each parent
    node has two child nodes that are located at *2i + 1* and *2i + 2, *where i is
    the index of the parent node and the first node of the collection is found at
    index 0.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alternate implementations skip the 0 index of the array to simplify the arithmetic
    of finding child and parent nodes for a given index. In this design, the child
    nodes for any given index i are located at *2i* and 2i + 1.
  prefs: []
  type: TYPE_NORMAL
- en: Heap operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all implementations of the heap data structures expose the same operational
    methods. However, the more common operations should be available or made available
    as needed by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Insert**:The Insert operation adds a new node to the heap. This operation
    must also re-order the heap to ensure that the newly added node maintains the
    heap property. This operation has an **O**(*log n*) operational cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FindMax**: The FindMax operation is synonymous with a max heap, and returns
    the largest value or highest-priority object in the collection. In an array-based
    implementation, this is typically the object at either index 0 or index 1, depending
    on the design. This is equivalent to the *peek* operation in a stack or queue,
    which is important when using a heap to implement a priority queue. This operation
    has an **O**(*1*) operational cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FindMin**: The FindMin operation is related to a min heap, and returns the
    smallest value or lowest-priority object in the collection. In an array-based
    implementation this is typically the object at either index 0 or index 1, depending
    on the design. This operation has an **O**(*1*) operational cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ExtractMax**: The ExtractMax operation is related to a max heap, and both
    returns the largest value or highest-priority object in the collection and removes
    it from the collection. This is equivalent to the *pop* operation in a stack or
    queue structure. As with FindMax, this is typically the object at either index
    0 or index 1 depending on the design. This operation will also re-order the heap
    to maintain the heap property. This operation has an **O**(*log n*) operational
    cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ExtractMin**: The ExtractMin operation is related to a min heap, and both
    returns the smallest value or lowest-priority object in the collection and removes
    it from the collection. As with FindMin, this is typically the object at either
    index 0 or index 1 depending on the design. This operation will also re-order
    the heap to maintain the heap property. This operation has an **O**(*log n*) operational
    cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DeleteMax**: The DeleteMax operation is related to a max heap, and simply
    removes the largest value or highest priority object in the collection. As with
    FindMax, this is typically the object at either index 0 or index 1 depending on
    the design. This operation will also re-order the heap to maintain the heap property.
    This operation has an **O**(*log n*) operational cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DeleteMin**: The DeleteMin operation is related to a min heap, and simply
    removes the smallest value or lowest priority object in the collection. As with
    FindMin, this is typically the object at either index 0 or index 1 depending on
    the design. This operation will also re-order the heap to maintain the heap property.
    This operation has an **O**(*log n*) operational cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Count**: The Count operation returns the total number of nodes in the heap.
    This operation has an O(*1*) operational cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Children**:The Children operation will return the two child nodes for the
    provided node or node index. This operation has an **O**(*2*) operational cost
    since two calculations must be performed to gather the child nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parent**: The Parent operation will return the parent node for any given
    node or node index. This operation has an **O**(*1*) operational cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This list of operations may remind you somewhat of the tree data structure
    discussed in [Chapter 9](part0050_split_000.html#1FLS41-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 9. Trees: Non-Linear Structures"), *Trees: Non-linear Structures*. It
    is important to note that, although a binary heap is quite similar to a binary
    search tree, the two should not be confused. Like a binary search tree, a heap
    data structure organizes each node of the collection. The heap orders nodes priority
    based on some arbitrary property of the node or the environment, while the values
    of each node are not necessarily ordered at all. In a binary search tree, on the
    other hand, the values of the nodes themselves are ordered.'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating heaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since heaps are a form of tree data structure, it is unsurprising that we will
    not find a native concrete implementation in the languages we are discussing.
    However, the heap data structure is actually quite simple to implement. Therefore,
    we are going to build our own heap structure, specifically a min heap.
  prefs: []
  type: TYPE_NORMAL
- en: Min heap structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin, we need to detail a few characteristics our heap structure
    will possess. For starters, we are going to implement the heap using an array,
    and the first node will occupy the `0` index in this array. This decision is important
    because it affects the formula we use to calculate each node's parent and Children.
    Next, we will need an object to represent the nodes in our heap. Since this is
    going to be a very simple object for our demonstration, we'll define its class
    in-line with our heap implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a min heap, we will only need to implement the `min` operations.
    Therefore, our implementation must expose methods for `FindMin` (peek), `ExtractMin`
    (pop), and `DeleteMin`. The heap's *Insert*, *Count*, *Children*, and *Parent*
    operations will each be implemented as single methods.
  prefs: []
  type: TYPE_NORMAL
- en: Our min heap implementation will also need two supporting methods to re-order
    the collection whenever a node is added or removed. We'll call these methods `OrderHeap`
    and `SwapNodes`, and their functions should be self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that an implementation of a max heap is almost identical to a `min` heap
    except that you switch around the variables in a few operations. We'll examine
    those differences in-line with our implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: 'C# provides enough functionality for us to create a versatile heap data structure
    with very little code. First we need to build the simple class that represents
    the nodes of the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This class is very simple, containing only a `public` property to store our
    integer data. Since this class' contents are consistent in each of the following
    language examples, we will only examine it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we can implement our heap functions. Here''s what a concrete implementation
    of the `MinHeap` class might look like in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our `MinHeap` class includes two public fields. The first is a `List<HeapNode>`
    named `elements` that represents our heap collection. The second is a `Count`
    field that will return the total number of elements in the collection. Finally,
    our constructor simply initializes the `elements` collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Insert(HeapNode item)` method accepts a new `HeapNode` object and adds
    it to the collection. Once the object has been added, the method calls `OrderHeap()`to
    make sure the new object is placed in the correct position to maintain the heap
    property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Delete(HeapNode item)` method accepts a `HeapNode` item to be removed from
    the collection. The method first finds the index of the item to be removed, then
    gets the index of the last object in the collection. Next, the method deletes
    the matching node by overwriting its position with a reference to the last node
    in the heap and then the last node is removed. Finally, the `OrderHeap()` method
    is called to ensure the final collection satisfies the heap property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `ExtractMin()` method first confirms that the `elements` collection has
    at least one element. If not, the method returns `null`. Otherwise, the method
    creates a new instance of `HeapNode` called `item` and sets it to the root object
    in the collection, which is the smallest object or the object with the lowest
    priority. Next, the method calls `Delete(item)` to remove the node from the collection.
    Finally, since the `ExtractMin` function must return an object, the method returns
    `item` to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `FindMin()` method is very similar to the `ExtractMin()` method, except
    that it does not remove the returned minimum value from the collection. The method
    first confirms that the element's collection has at least one element. If not,
    the method returns `null`. Otherwise the method returns the root object in the
    collection, which is the smallest object or the object with the lowest priority.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The private `OrderHeap()` method is the heart of the `MinHeap` class. This is
    the method responsible for maintaining the heap property of the collection. The
    method first establishes a `for` loop based on the length of the elements collection,
    and begins iterating through the collection from the end to the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we know that the two children of any object at index i are located at
    indices *2i + 1* and *2i + 2*, we likewise know that the parent of any object
    at index i is found at *(i - 1) / 2*. This formula only works because the resulting
    value is defined as an integer, meaning that any floating-point values are truncated
    and only the whole number value is retained. This algorithm, implemented in the
    `OrderHeap()` method via the `int parentPosition = (i - 1) / 2;` code, is what
    ensures the heap data structure retains its binary nature.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `min` heap property formula, the `for` loop first identifies the parent
    index for the current node. Next, the value of the current node's `Data` field
    is compared to that of the parent; if the parent is larger, the method calls `SwapElements(parentPosition,
    i)`. Once each of the nodes has been evaluated, the method is complete and the
    heap property is consistent throughout the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that, by switching the two operands of the `if` statement, or by simply
    changing the comparator from `>` to `<`, or, our collection would effectively
    change from a min heap to a max heap. Using this knowledge, it would be very simple
    indeed to create a heap collection that could be defined as either a `min` heap
    or a `max` heap at *runtime*.
  prefs: []
  type: TYPE_NORMAL
- en: The `SwapElements(int firstIndex, int secondIndex)` method's function is self-explanatory.
    Each of the nodes at the given indices is swapped to enforce the heap property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using the same rule, which states that the two children of any object at index
    i are located at indices *2i + 1* and *2i + 2*, the `GetChildren(int parentIndex)`
    method gathers and returns the two child nodes for a given parent index. The method
    first confirms that `parentIndex` is not less than `0`, otherwise it returns `null`.
    If the `parentIndex` is valid, the method creates a new `List<Heapnode>` and populates
    it using the calculated child indices before returning the `children` collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finally, `GetParent(int childIndex)` works on the same principle as `GetChildren`.
    If the given `childIndex` is greater than `0` the node has a parent. The method
    confirms that we are not searching for the root node and also confirms that the
    index is not out of bounds for the collection. If either check fails, the method
    returns `null`. Otherwise, the method determines the node's parent index and then
    returns the node found at that index.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java also provides the basic tools necessary to build a robust implementation
    of our `MinHeap` class with little code. Here''s how that class might look in
    Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `MinHeap` class includes one public field of abstract type `List<HeapNode>`
    named `elements` that represents our heap collection. The class also include a
    method named `size()`, which will return the total number of elements in the collection.
    Finally, our constructor simply initializes the `elements` collection as an `ArrayList<HeapNode>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `insert(HeapNode item)` method accepts a new `HeapNode` object and adds
    it to the collection. Once the object has been added, the method calls `orderHeap()` to
    make sure the new object is placed in the correct position to maintain the heap
    property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `delete(HeapNode item)` method accepts a `HeapNode` item to be removed from
    the collection. The method first finds the index of the item to be removed, then
    gets the index of the last object in the collection. Next, the method deletes
    the matching node by overwriting its position with a reference to the last node
    in the heap and then the last node is removed. Finally, `orderHeap()` is called
    to ensure the final collection satisfies the heap property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `extractMin()` method first confirms that the `elements` collection has
    at least one element. If not, the method returns `null`. Otherwise the method
    creates a new instance of `HeapNode` called `item` and sets it to the root object
    in the collection, which is the smallest object or the object with the lowest
    priority. Next, the method calls `delete(item)` to remove the node from the collection.
    Finally, since the `ExtractMin` function must return an object, the method returns
    `item` to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `findMin()` method is very similar to the `extractMin()` method, except
    that it does not remove the returned minimum value from the collection. The method
    first confirms that the elements collection has at least one element. If not,
    the method returns `null`. Otherwise the method returns the root object in the
    collection by calling `elements.get(0)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The private `orderHeap()` method is responsible for maintaining the heap property
    of the collection. The method first establishes a `for` loop based on the length
    of the elements collection, and begins iterating through the collection from the
    end to the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Using the min heap property formula, the `for` loop first identifies the parent
    index for the current node. Next, the value of the current node's `Data` field
    is compared to that of the parent, and if the parent is larger, the method calls
    `swapElements(parentPosition, i)`. Once each of the nodes has been evaluated,
    the method is complete and the heap property is consistent throughout the collection.
  prefs: []
  type: TYPE_NORMAL
- en: The `swapElements(int firstIndex, int secondIndex)` method's function is self-explanatory.
    Each of the nodes at the given indices is swapped to enforce the heap property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using the same rule, which states that the two children of any object at index
    i are located at indices *2i + 1* and *2i + 2*, the `getChildren(int parentIndex)`
    method gathers and returns the two child nodes for a given parent index. The method
    first confirms that `parentIndex` is not less than 0, otherwise it returns `null`.
    If the `parentIndex` is valid, the method creates a new `ArrayList<Heapnode>`
    and populates it using the calculated child indices before returning the `children`
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Finally, `getParent(int childIndex)` works on the same principle as `getChildren`.
    If the given `childIndex` is greater than 0 the node has a parent. The method
    confirms that we are not searching for the root node and also confirms that the
    index is not out of bounds for the collection. If either check fails, the method
    returns `null`. Otherwise, the method determines the node's parent index and then
    returns the node found at that index.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using an `NSMutableArray` as the core structure, Objective-C can also easily
    implement the min heap data structure. Here''s how the `EDSMinHeap` class might
    look in Objective-C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using the class cluster `NSMutableArray`, we create an ivar for our class called
    `_elements`. Our initializer instantiates this array, giving us the underlying
    data structure to build our `EDSMinHeap` class on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Our `EDSMinHeap` class includes one public property named `Count`, and the `getCount()`
    accessor returns the `count` property of the `_elements` array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `insert:` method accepts a new `EDSHeapNode` object and adds it to the
    array. Once the object has been added, the method calls `orderHeap` to make sure
    the new object is placed in the correct position to maintain the heap property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `delete:` method accepts an `EDSHeapNode` item to be removed from the collection.
    The method first finds the index of the item to be removed using `indexOfObject:`,
    then deletes the matching node by overwriting its position with a reference to
    the `lastObject` in the heap. Next, the last node is removed using `removeLastObject`.
    Finally, `orderHeap:` is called to ensure the final collection satisfies the heap
    property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `extractMin` method first confirms that the `_elements` collection has at
    least one element. If not, the method returns `nil`. Otherwise, the method creates
    a new instance of `EDSHeapNode` called `item` and sets it to the root object in
    the collection, which is the smallest object or the object with the lowest priority.
    Next, the method calls `delete:` to remove the node from the collection. Finally,
    since the *ExtractMin* function must return an object, the method returns `item`
    to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `findMin` method is very similar to the `extractMin` method, except that
    it does not remove the returned minimum value from the collection. The method
    first confirms that the elements collection has at least one element. If not,
    the method returns `nil`. Otherwise the method returns the first object in the
    collection, which is the root node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The private `orderHeap` method is responsible for maintaining the heap property
    of the collection. The method first establishes a `for` loop based on the length
    of the elements collection, and begins iterating through the collection from the
    end to the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Using the min heap property formula, the `for` loop first identifies the parent
    index for the current node. Next, the value of the current node's `data` property
    is compared to that of the parent, and if the parent is larger, the method calls
    `swapElement:withElement:`. Once each of the nodes has been evaluated, the method
    is complete and the heap property is consistent throughout the collection.
  prefs: []
  type: TYPE_NORMAL
- en: The `swapElement:withElement:` method's function is self-explanatory. Each of
    the nodes at the given indices is swapped to enforce the heap property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Using the rule that states the two children of any object at index i are located
    at indices *2i + 1* and *2i + 2*, the `childrenOfParentIndex:` method gathers
    and returns the two child nodes for a given parent index. The method first confirms
    that `parentIndex` is not less than 0, otherwise it returns `nil`. If the `parentIndex`
    is valid, the method creates a new `NSMutableArray` and populates it using nodes
    from the calculated child indices before returning the `children` collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Finally, `parentOfChildIndex:` works on the same principle as `childrenOfParentIndex:`.
    If the given `childIndex` is greater than 0, the node has a parent. The method
    confirms that we are not searching for the root node and also confirms that the
    index is not out of bounds for the collection. If either check fails, the method
    returns `nil`. Otherwise, the method determines the node's parent index and then
    returns the node found at that index.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Swift `MinHeap` class is similar in structure and functionality to the
    C# and Java implementations. Here''s what an example of the `MinHeap` class might
    look like in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Using the `Array` class we create a private property for our class called `_elements`.
    Since our property is declared and instantiated simultaneously, and there is no
    other custom code requiring instantiation, we can exclude the explicit public
    initializer and rely on the default initializer. Our class also provides a public
    method called `getCount()`, which returns the size of the `_elements` array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `insert(HeapNode item)` method accepts a new `HeapNode` object and adds
    it to the collection. Once the object has been added the method calls `orderHeap()`to
    make sure the new object is placed in the correct position to maintain the heap
    property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `delete(HeapNode item)` method accepts a `HeapNode` item to be removed from
    the collection. The method first finds the `index` of the item to be removed,
    then deletes the matching node by overwriting its position with a reference to
    the `last` object in the heap. Finally, the `orderHeap()` method is called to
    ensure the final collection satisfies the heap property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `extractMin()` method first confirms that the `elements` collection has
    at least one element. If not, the method returns `nil`. Otherwise the method creates
    a new variable called `item` and sets it to the root object in the collection,
    which is the smallest `HeapNode` or the `HeapNode` with the lowest priority. Next,
    the method calls `delete(item: Heapnode)` to remove the node from the collection.
    Finally, the method returns `item` to the caller.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `findMin()` method is very similar to the `extractMin()` method, except
    that it does not remove the returned minimum value from the collection. The method
    first confirms that the elements collection has at least one element. If not,
    the method returns `nil`. Otherwise the method returns `_elements[0]`, which is
    the root object in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The private `orderHeap()` method is responsible for maintaining the heap property
    of the collection. The method first establishes a `for` loop based on the length
    of the elements collection, and begins iterating through the collection from the
    end to the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the min heap property formula, the `for` loop first identifies the parent
    index for the current node. Next, the value of the current node''s `data` field
    is compared to that of the parent, and if the parent is larger, the method calls
    `swapElements(first: Int, second: Int)`. Once each of the nodes has been evaluated,
    the method is complete and the heap property is consistent throughout the collection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `swapElements(int firstIndex, int secondIndex)` method''s function is self-explanatory.
    Each of the nodes at the given indices is swapped to enforce the heap property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same rule that states the two children of any object at index `i`
    are located at indices *2i + 1* and *2i + 2*, the `getChildren(parentIndex: Int)`
    method gathers and returns the two child nodes for a given parent index. The method
    first confirms that `parentIndex` is not less than 0, otherwise it returns `nil`.
    If the `parentIndex` is valid, the method creates a new `Array` of `HeapNode`
    objects and populates it using the calculated child indices before returning the
    `children` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `getParent(childIndex: Int)` works on the same principle as `getChildren`.
    If the given `childIndex` is greater than `0` the node has a parent. The method
    confirms that we are not searching for the root node and also confirms that the
    index is not out of bounds for the collection. If either check fails, the method
    returns `nil`. Otherwise, the method determines the node''s parent index and then
    returns the node found at that index.'
  prefs: []
  type: TYPE_NORMAL
- en: Common applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Heap data structures are actually quite common, although you may not always
    realize you are working with one. Here are some of the most common applications
    for the heap data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Selection algorithms**: A selection algorithm is used to determine the k^(th)
    smallest or largest element in a collection, or the median valued object of a
    collection. In a typically collection, this operation costs O(n). However, in
    an ordered heap implemented with an array finding the k^(th) element is an **O**(1)
    operation because we can find the element by simply examining the k index in the
    array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Priority queue**: Priority queues are an abstract data structure similar
    to standard queues except that the nodes contain an additional value representing
    the priority of that object in relation to others in the collection. Due to the
    natural sorting of the heap data structure, priority queues are often implemented
    using the heap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about heap data structures. We examined the most
    common operations when working with heaps and their complexity cost. Following
    this we created our own simple min heap data structure class from scratch, and
    discussed how the min heap property formula is used to calculate parents or children
    for any given node index. Finally, we examined the most common applications for
    heap data structures.
  prefs: []
  type: TYPE_NORMAL
