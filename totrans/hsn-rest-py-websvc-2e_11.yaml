- en: Working with Asynchronous Code, Testing, and Deploying an API with Tornado
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take advantage of the non-blocking features combined
    with asynchronous operations in Tornado 5.1.1 in a new version of the API we built
    in the previous chapter. We will configure, write, and execute unit tests, and
    learn a few things related to deployment. We will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand synchronous and asynchronous execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactor code to take advantage of asynchronous decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map URL patterns to asynchronous and non-blocking request handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make HTTP requests to the Tornado non-blocking API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up unit tests with `pytest`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the first round of unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run unit tests with `pytest` and check testing ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding synchronous and asynchronous execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our current version of the RESTful API built with Tornado 5.1.1, each HTTP
    request is blocking. Hence, whenever the Tornado HTTP server receives an HTTP
    request, it doesn't start working on any other HTTP requests in the incoming queue
    until the server sends the response for the first HTTP request is received. The
    methods we coded in the request handlers are working with a synchronous execution
    and don't take advantage of the non-blocking features included in Tornado when
    combined with asynchronous executions.
  prefs: []
  type: TYPE_NORMAL
- en: In order to set the brightness level for the red, green, and blue LEDs, we have
    to make three HTTP `PATCH` requests. We will make these requests to understand
    how our current version of the API processes three incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the Tornado 5.1.1 development server is running. Open three additional
    Terminals in macOS or Linux, or Command Prompt or Windows PowerShell windows in
    Windows. Activate the virtual environment in which we have been working for our
    RESTful API with Tornado in each of the windows. We will run commands in the three
    windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following command in the first window. The command will compose and
    send an HTTP `PATCH` request to set the brightness level for the red LED to `255`.
    Write the line in the first window but don''t press *Enter* yet, as we will try
    to launch three commands at almost the same time in three windows. The code file
    for the sample is included in the `restful_python_2_11_01` folder, in the `Tornado01/cmd/cmd1201.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_11_01` folder, in the `Tornado01/cmd/cmd1202.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to the second window and write the following command. The command will
    compose and send an HTTP `PATCH` request to set the brightness level for the green
    LED to `128`. Write the line in the second window but don''t press *Enter* yet,
    as we will try to launch two commands at almost the same time in three windows.
    The code file for the sample is included in the `restful_python_2_11_01` folder,
    in the `Tornado01/cmd/cmd1203.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_11_01` folder, in the `Tornado01/cmd/cmd1204.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to the third window and write the following command. The command will
    compose and send an HTTP `PATCH` request to set the brightness level for the blue
    LED to `64`. Write the line in the third window but don''t press *Enter* yet,
    as we will try to launch two commands at almost the same time in three windows.
    The code file for the sample is included in the `restful_python_2_11_01` folder,
    in the `Tornado01/cmd/cmd1205.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_11_01` folder, in the `Tornado01/cmd/cmd1206.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to each window, from the first to the third, and press *Enter* quickly
    in each of them. You will see the following line in the window that is running
    the Tornado HTTP server for a few seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few seconds, you will see the following lines, which show the results
    of executing the print statements that describe when the code finished and then
    start setting the brightness levels for the LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It was necessary to wait for the request that changed the brightness level for
    the red LED to finish before the server could process the HTTP request that changes
    the brightness level for the green LED. The HTTP request that changes the brightness
    level for the blue LED had to wait for the other two requests to finish their
    execution first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows four Terminal windows on macOS. The window on
    the left-hand side is running the Tornado 5.1.1 HTTP server and displays the messages
    printed in the methods that process the HTTP requests. The three windows on the
    right run the `http` command to generate the HTTP `PATCH` request that changes
    the brightness levels for the red, green, and blue LEDs. It is a good idea to
    use a similar configuration to check the output while we compose and send the
    HTTP requests, and thus understand how the synchronous execution is working in
    the current version of the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db46ba34-9666-49c1-83b4-f5c72f8af9fb.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember that the different methods we coded in the request handler classes
    end up calling `time.sleep` to simulate it taking some time for the operations
    to complete their execution.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring code to take advantage of asynchronous decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As each operation takes some time and blocks the possibility to process other
    incoming HTTP requests, we will create a new version of this API that will use
    asynchronous execution, and we will understand the advantages of Tornado's non-blocking
    features. This way, it will be possible to change the brightness level for the
    red LED while another request is changing the brightness level for the green LED.
    Tornado will be able to start processing requests while the I/O operations with
    the drone take some time to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you quit the Tornado HTTP server. You just need to press *Ctrl* +
    *C* in the Terminal or Command Prompt window in which it is running.
  prefs: []
  type: TYPE_NORMAL
- en: Tornado 5.1.1 provides ...
  prefs: []
  type: TYPE_NORMAL
- en: Mapping URL patterns to asynchronous request handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stay in the `async_drone_service.py` file in the root folder for the virtual
    environment (`Tornado01`). Add the following lines to map URL patterns to our
    previously coded subclasses of the `RequestHandler` superclass, which provide
    us with asynchronous methods for our request handlers. The following lines create
    the main entry point for the application, initialize it with the URL patterns
    for the API, and start listening for requests. The lines that are new or edited,
    compared to the synchronous version, are highlighted. The code file for the sample
    is included in the `restful_python_2_11_01` folder, in the `Django01/async_drone_service.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code creates an instance of `tornado.web.Application`, named `application`,
    with the collection of request handlers that make up the web application. We just
    changed the name of the handlers for the new names that have the `Async` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP requests to the Tornado non-blocking API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can run the `drone_service.py` script, which launches the development
    server for Tornado 5.1.1 to our new version of the web API that uses the non-blocking
    features of Tornado, combined with an asynchronous execution. Make sure that the
    `drone_service.py` script is not running anymore. Execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line shows the output after we execute the previous command.
    The Tornado HTTP development server is listening at port `8888`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In our new version of the API, each HTTP request is non-blocking. Thus, whenever
    the Tornado HTTP server receives an HTTP request and makes an asynchronous call,
    it is able to start ...
  prefs: []
  type: TYPE_NORMAL
- en: Setting up unit tests with pytest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you quit the Django development server. You just need to press *Ctrl*
    + *C* in the Terminal or Command Prompt window in which it is running.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will install many additional packages to be able to easily run tests
    and measure their code coverage. Make sure you have activated the virtual environment
    that we created in the previous chapter, named `Tornado01`. After you activate
    the virtual environment, it is time to run many commands that will be the same
    for macOS, Linux, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will edit the existing `requirements.txt` file to specify the additional
    packages that our application requires to be installed on any supported platform.
    This way, it will be extremely easy to repeat the installation of the specified
    packages with their versions in any new virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your favorite editor to edit the existing text file, named `requirements.txt`,
    within the root folder for the virtual environment. Add the following lines after
    the last line to declare the additional packages that we require. The code file
    for the sample is included in the `restful_python_2_11_01` folder, in the `Tornado01/requirements.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Each additional line added to the `requirements.txt` file indicates the package
    and the version that need to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the packages and the version numbers that we
    specified as additional requirements to the previously included packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Package name | Version to be installed |'
  prefs: []
  type: TYPE_TB
- en: '| `pytest` | 4.0.2 |'
  prefs: []
  type: TYPE_TB
- en: '| `coverage` | 4.5.2 |'
  prefs: []
  type: TYPE_TB
- en: '| `pytest-cov` | 2.6.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `pytest-tornasync` | 0.5.0 |'
  prefs: []
  type: TYPE_TB
- en: 'We will install the following Python packages in our virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pytest`: This is a very popular Python unit test framework that makes testing
    easy and reduces boilerplate code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coverage`: This tool measures code coverage of Python programs and we will
    use it to determine which parts of the code are being executed by unit tests and
    which parts aren''t.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-cov`: This plugin for `pytest` makes it easy to produce coverage reports
    that use the `coverage` tool under the hood and provides some additional features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-tornasync`: This plugin for `pytest` provides fixtures to make it easier
    to test Tornado asynchronous code with `pytest`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we must run the following command on macOS, Linux, or Windows to install
    the additional packages and the versions outlined in the previous table with `pip`,
    using the recently edited `requirements.txt` file. Make sure you are located in
    the folder that has the `requirements.txt` file before running the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate whether all the new packages and
    their dependencies have been successfully installed. If you downloaded the source
    code for the example and you didn''t work with the previous version of the API,
    `pip` will also install the other packages included in the `requirements.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `setup.cfg` file in the root folder for the virtual environment
    (`Tornado01`). The following lines show the code that specifies the desired configuration
    for `pytest` and the `coverage` tools. The code file for the sample is included
    in the `restful_python_2_11_01` folder, in the `Tornado01/setup.cfg` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `tool:pytest` section specifies the configuration for `pytest`. The `testpaths`
    setting assigns the `tests.py` value to indicate that the tests are located in
    the `tests.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: The `coverage:run` section specifies the configuration for the `coverage` tool.
    The `branch` setting is set to `True` to enable branch coverage measurement in
    addition to the default statement coverage. The `source` setting specifies the
    modules that we want to be considered for coverage measurement. We just want to
    include the `drone` and `async_drone_service` modules.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we won't be using configuration files for each environment. However,
    in more complex applications, you will definitely want to use configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the first round of unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will write the first round of unit tests. Specifically, we will write
    unit tests related to the LED resources. Test fixtures provide a fixed baseline
    to enable us to reliably and repeatedly execute tests. Pytest makes it easy to
    declare a test fixture function by marking a function with the `@pytest.fixture`
    decorator. Then, whenever we use the fixture function name as an argument in a
    test function declaration, `pytest` will make the fixture function provide the
    fixture object.
  prefs: []
  type: TYPE_NORMAL
- en: The `pytest-tornasync` plugin provides us with many fixtures that we will use
    to easily write tests for our Tornado API. In order to work with this plugin,
    we must declare a fixture function, named `app`, that returns a `tornado.web.Application
    ...`
  prefs: []
  type: TYPE_NORMAL
- en: Improving testing coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will write additional unit tests to improve the testing coverage. Specifically,
    we will write unit tests related to the hexacopter motor and the altimeter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `tests.py` file in the root folder for the virtual environment (`Tornado01`).
    Insert the following lines after the last line. The code file for the sample is
    included in the `restful_python_2_11_02` folder, in the `Django01/tests.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code added the following three test functions, whose names start
    with the `test_` prefix and who receive the `http_server_client` argument to use
    this test fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test_set_and_get_hexacopter_motor_speed`: This test function tests whether
    we can set and get the hexacopter''s motor speed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_get_altimeter_altitude_in_feet`: This test function tests whether we
    can retrieve the altitude value from the altimeter, expressed in feet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_get_altimeter_altitude_in_meters`: This test function tests whether we
    can retrieve the altitude value from the altimeter, expressed in meters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We just coded a few tests related to the hexacopter and the altimeter in order
    to improve test coverage and note the impact on the test coverage report.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will use the `pytest` command to run tests and measure their code coverage.
    Make sure you run the command in the Terminal or Command Prompt window in which
    you have activated the virtual environment, and that you are located within its
    root folder (`Tornado01`). Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The output provided details indicating that the test runner executed four tests
    and all of them passed. The test code coverage measurement report provided by
    the `coverage` package increased the `Cover` percentage of the `async_drone_service.py`
    module from 40% to 69%. In addition, the `Cover` percentage of the `drone.py`
    module increased from 59% in the previous run to 79%. The new tests we wrote executed
    additional code in different modules, and therefore there is an important impact
    in the coverage report. The total coverage increased from 46% to 72%.
  prefs: []
  type: TYPE_NORMAL
- en: If we take a look at the missing statements, we will notice that we aren't testing
    scenarios where validations fail. Now, we will write additional unit tests to
    improve the testing coverage further. Specifically, we will write unit tests to
    make sure that we cannot set invalid brightness levels for the LEDs, we cannot
    set invalid motor speeds for the hexacopter, and that we receive an HTTP `404
    Not Found` status code when we try to access a resource that doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `tests.py` file in the root folder for the virtual environment (`Tornado01`).
    Insert the following lines after the last line. The code file for the sample is
    included in the `restful_python_2_11_03` folder, in the `Django01/tests.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code added the following three test functions, whose names start
    with the `test_` prefix and receive the `http_server_client` argument to use this
    test fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test_set_invalid_brightness_level`: This test function makes sure that we
    cannot set an invalid brightness level for an LED through an HTTP `PATCH` request.
    In this method, many `try...except` blocks capture an `HTTPClientError` exception
    as `err` and use `assert` to make sure the `err.code` attribute matches `HTTPStatus.BAD_REQUEST`.
    This way, the test makes sure that each HTTP `PATCH` request generates an HTTP
    `400 Bad Request` status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_set_brightness_level_invalid_led_id`: This test function makes sure that
    we cannot set the brightness level for an invalid LED `id` through an HTTP `PATCH`
    request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_get_brightness_level_invalid_led_id`: This test function makes sure that
    we cannot get the brightness level for an invalid LED `id` through an HTTP `GET`
    request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the last two methods, a `try...except` block captures an `HTTPClientError`
    exception as `err`. The `except` block uses `assert` to make sure the `err.code`
    attribute matches `HTTPStatus.NOT_FOUND`. This way, the test makes sure that the
    HTTP `PATCH` and HTTP `GET` requests to generate an HTTP `404 Not Found` status
    code.
  prefs: []
  type: TYPE_NORMAL
- en: When an HTTP request is unsuccessful, the `http_server_client.fetch` method
    raises a `tornado.httpclient.HTTPClientError` exception and the status code is
    available in the `code` attribute for the instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stay in the `tests.py` file in the root folder for the virtual environment
    (`Tornado01`). Insert the following lines after the last line. The code file for
    the sample is included in the `restful_python_2_11_03` folder, in the `Django01/tests.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code added the following four test functions, whose names start
    with the `test_` prefix and receive the `http_server_client` argument to use this
    test fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test_set_invalid_brightness_level`: This test function makes sure that we
    cannot set an invalid brightness level for the LED through an HTTP `PATCH` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_set_motor_speed_invalid_hexacopter_id`: This test function makes sure
    that we cannot set the motor speed for an invalid hexacopter `id` through an HTTP
    `PATCH` request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_get_motor_speed_invalid_hexacopter_id`: This test function makes sure
    that we cannot get the motor speed for an invalid hexacopter `id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_get_altimeter_altitude_invalid_altimeter_id`: This test function makes
    sure that we cannot get the altitude value for an invalid altimeter `id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We coded many additional tests that will make sure that all the validations
    work as expected. Now, we will use the `pytest` command again to run the tests
    and measure their code coverage. Make sure you run the command in the Terminal
    or Command Prompt window in which you have activated the virtual environment,
    and that you are located within its root folder (`Tornado01`). Run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The output provided details indicating that the test runner executed `11` tests
    and all of them passed. The test code coverage measurement report provided by
    the `coverage` package increased the `Cover` percentage of the `async_drone_service.py`
    module from 69% to 87%. In addition, the `Cover` percentage of the `drone.py`
    module increased from 79% in the previous run to 85%. The new tests we wrote executed
    additional code in different modules, and therefore there is an important impact
    in the coverage report. The total coverage increased from 72% to 86%.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding strategies for deploying Tornado APIs to the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tornado supplies its own HTTP server, and therefore it can run without a WSGI
    container. However, some cloud providers, such as Google App Engine, only enable
    the running of Tornado in a WSGI-only environment. When Tornado runs in a WSGI-only
    environment, it doesn't support asynchronous operations. Hence, we must take into
    account this important limitation when selecting our cloud platform for Tornado.
  prefs: []
  type: TYPE_NORMAL
- en: We must make sure that the API runs under HTTPS in production environments.
    In addition, we have to make sure we add some authentication and throttling policies.
    Our Tornado sample is a simple RESTful API that provides some features we can
    use as a baseline to generate a more ...
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Future` does which of the following?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encapsulates the asynchronous execution of a callable
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Encapsulates the synchronous execution of a callable
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Runs an asynchronous method synchronously on the executor specified as an argument
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `concurrent.futures.ThreadPoolExecutor` class provides us with which of
    the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A high-level interface for synchronously executing callables
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A high-level interface for asynchronously executing callables
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A high-level interface for composing HTTP requests
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `@tornado.concurrent.run_on_executor` decorator allows us to do which of
    the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run an asynchronous method synchronously on an executor
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run an asynchronous method on an executor without generating `Future`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run a synchronous method asynchronously on an executor
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The recommended way to write asynchronous code in Tornado is to use which of
    the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Coroutines
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Chained callbacks
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Subroutines
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following fixtures, defined by the `pytest-tornasync pytest` plugin,
    provide an asynchronous HTTP client for tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tornado_client`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http_client`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http_server_client`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If we want to convert the bytes in a JSON response body into a Python dictionary,
    we can use which of the following functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tornado.escape.json_decode`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tornado.escape.byte_decode`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tornado.escape.response_body_decode`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood the difference between synchronous and asynchronous
    execution. We created a new version of the RESTful API that takes advantage of
    the non-blocking features in Tornado, combined with an asynchronous execution.
    We improved the scalability of our existing API and made it possible to start
    executing other requests while waiting for slow I/O operations with sensors and
    actuators. We avoided splitting our methods into multiple methods with callbacks
    by using the `tornado.gen` generator-based interface that Tornado provides, to
    make it easier to work in an asynchronous environment.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we set up a testing environment. We installed `pytest`, along with many
    plugins, to make it easy to discover and execute unit ...
  prefs: []
  type: TYPE_NORMAL
