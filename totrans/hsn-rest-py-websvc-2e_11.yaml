- en: Working with Asynchronous Code, Testing, and Deploying an API with Tornado
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tornado处理异步代码、测试和部署API
- en: 'In this chapter, we will take advantage of the non-blocking features combined
    with asynchronous operations in Tornado 5.1.1 in a new version of the API we built
    in the previous chapter. We will configure, write, and execute unit tests, and
    learn a few things related to deployment. We will do the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用Tornado 5.1.1的非阻塞特性以及异步操作，在上一章中构建的新版本的API中。我们将配置、编写和执行单元测试，并学习一些与部署相关的内容。我们将执行以下操作：
- en: Understand synchronous and asynchronous execution
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解同步和异步执行
- en: Work with asynchronous code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步代码
- en: Refactor code to take advantage of asynchronous decorators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新编写代码以利用异步装饰器
- en: Map URL patterns to asynchronous and non-blocking request handlers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将URL模式映射到异步和非阻塞请求处理器
- en: Make HTTP requests to the Tornado non-blocking API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Tornado非阻塞API发送HTTP请求
- en: Set up unit tests with `pytest`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pytest`设置单元测试
- en: Write the first round of unit tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写第一轮单元测试
- en: Run unit tests with `pytest` and check testing ...
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pytest`运行单元测试并检查测试...
- en: Understanding synchronous and asynchronous execution
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解同步和异步执行
- en: In our current version of the RESTful API built with Tornado 5.1.1, each HTTP
    request is blocking. Hence, whenever the Tornado HTTP server receives an HTTP
    request, it doesn't start working on any other HTTP requests in the incoming queue
    until the server sends the response for the first HTTP request is received. The
    methods we coded in the request handlers are working with a synchronous execution
    and don't take advantage of the non-blocking features included in Tornado when
    combined with asynchronous executions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用Tornado 5.1.1构建的当前版本的RESTful API中，每个HTTP请求都是阻塞的。因此，每当Tornado HTTP服务器收到一个HTTP请求时，它不会开始处理队列中的任何其他HTTP请求，直到收到第一个HTTP请求的响应。我们在请求处理器中编写的代码是以同步执行方式工作的，并且没有利用Tornado在异步执行中包含的非阻塞特性。
- en: In order to set the brightness level for the red, green, and blue LEDs, we have
    to make three HTTP `PATCH` requests. We will make these requests to understand
    how our current version of the API processes three incoming requests.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置红色、绿色和蓝色LED的亮度级别，我们必须发出三个HTTP `PATCH`请求。我们将发出这些请求以了解我们当前版本的API如何处理三个传入的请求。
- en: Make sure the Tornado 5.1.1 development server is running. Open three additional
    Terminals in macOS or Linux, or Command Prompt or Windows PowerShell windows in
    Windows. Activate the virtual environment in which we have been working for our
    RESTful API with Tornado in each of the windows. We will run commands in the three
    windows.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Tornado 5.1.1开发服务器正在运行。在macOS或Linux中打开三个额外的终端，或在Windows中打开命令提示符或Windows PowerShell窗口。在每个窗口中激活我们为使用Tornado构建的RESTful
    API所工作的虚拟环境。我们将在三个窗口中运行命令。
- en: 'Write the following command in the first window. The command will compose and
    send an HTTP `PATCH` request to set the brightness level for the red LED to `255`.
    Write the line in the first window but don''t press *Enter* yet, as we will try
    to launch three commands at almost the same time in three windows. The code file
    for the sample is included in the `restful_python_2_11_01` folder, in the `Tornado01/cmd/cmd1201.txt`
    file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个窗口中写下以下命令。该命令将组合并发送一个HTTP `PATCH`请求，将红色LED的亮度级别设置为`255`。在第一个窗口中写下这一行，但不要按*Enter*键，因为我们将在三个窗口中几乎同时尝试启动三个命令。示例的代码文件包含在`restful_python_2_11_01`文件夹中，在`Tornado01/cmd/cmd1201.txt`文件中：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_11_01` folder, in the `Tornado01/cmd/cmd1202.txt`
    file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令。示例的代码文件包含在`restful_python_2_11_01`文件夹中，在`Tornado01/cmd/cmd1202.txt`文件中：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, go to the second window and write the following command. The command will
    compose and send an HTTP `PATCH` request to set the brightness level for the green
    LED to `128`. Write the line in the second window but don''t press *Enter* yet,
    as we will try to launch two commands at almost the same time in three windows.
    The code file for the sample is included in the `restful_python_2_11_01` folder,
    in the `Tornado01/cmd/cmd1203.txt` file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到第二个窗口，写下以下命令。该命令将组合并发送一个HTTP `PATCH`请求，将绿色LED的亮度级别设置为`128`。在第二个窗口中写下这一行，但不要按*Enter*键，因为我们将在三个窗口中几乎同时尝试启动两个命令。示例的代码文件包含在`restful_python_2_11_01`文件夹中，在`Tornado01/cmd/cmd1203.txt`文件中：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_11_01` folder, in the `Tornado01/cmd/cmd1204.txt`
    file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令。示例的代码文件包含在 `restful_python_2_11_01` 文件夹中，位于 `Tornado01/cmd/cmd1204.txt`
    文件中：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, go to the third window and write the following command. The command will
    compose and send an HTTP `PATCH` request to set the brightness level for the blue
    LED to `64`. Write the line in the third window but don''t press *Enter* yet,
    as we will try to launch two commands at almost the same time in three windows.
    The code file for the sample is included in the `restful_python_2_11_01` folder,
    in the `Tornado01/cmd/cmd1205.txt` file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到第三个窗口并输入以下命令。该命令将组合并发送一个 HTTP `PATCH` 请求来设置蓝色 LED 的亮度级别为 `64`。在第三个窗口中写下这一行，但不要按
    *Enter* 键，因为我们将在三个窗口中几乎同时尝试启动两个命令。示例的代码文件包含在 `restful_python_2_11_01` 文件夹中，位于
    `Tornado01/cmd/cmd1205.txt` 文件中：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_11_01` folder, in the `Tornado01/cmd/cmd1206.txt`
    file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令。示例的代码文件包含在 `restful_python_2_11_01` 文件夹中，位于 `Tornado01/cmd/cmd1206.txt`
    文件中：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, go to each window, from the first to the third, and press *Enter* quickly
    in each of them. You will see the following line in the window that is running
    the Tornado HTTP server for a few seconds:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到每个窗口，从第一个到第三个，并在每个窗口中快速按下 *Enter* 键。你将在运行 Tornado HTTP 服务器的窗口中看到以下几秒钟的行：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After a few seconds, you will see the following lines, which show the results
    of executing the print statements that describe when the code finished and then
    start setting the brightness levels for the LEDs:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，你将看到以下几行，它们显示了执行描述代码完成时以及开始设置 LED 亮度级别的打印语句的结果：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It was necessary to wait for the request that changed the brightness level for
    the red LED to finish before the server could process the HTTP request that changes
    the brightness level for the green LED. The HTTP request that changes the brightness
    level for the blue LED had to wait for the other two requests to finish their
    execution first.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器能够处理更改绿色 LED 亮度级别的 HTTP 请求之前，必须等待更改红色 LED 亮度级别的请求完成。更改蓝色 LED 亮度级别的 HTTP
    请求必须等待其他两个请求首先完成它们的执行。
- en: 'The following screenshot shows four Terminal windows on macOS. The window on
    the left-hand side is running the Tornado 5.1.1 HTTP server and displays the messages
    printed in the methods that process the HTTP requests. The three windows on the
    right run the `http` command to generate the HTTP `PATCH` request that changes
    the brightness levels for the red, green, and blue LEDs. It is a good idea to
    use a similar configuration to check the output while we compose and send the
    HTTP requests, and thus understand how the synchronous execution is working in
    the current version of the API:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 macOS 上的四个终端窗口。左侧的窗口正在运行 Tornado 5.1.1 HTTP 服务器，并显示处理 HTTP 请求的方法中打印的消息。右侧的三个窗口运行
    `http` 命令以生成更改红色、绿色和蓝色 LED 亮度级别的 HTTP `PATCH` 请求。在编写和发送 HTTP 请求时使用类似的配置来检查输出是一个好主意，这样我们就可以理解当前
    API 版本中同步执行的工作方式：
- en: '![](img/db46ba34-9666-49c1-83b4-f5c72f8af9fb.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db46ba34-9666-49c1-83b4-f5c72f8af9fb.png)'
- en: Remember that the different methods we coded in the request handler classes
    end up calling `time.sleep` to simulate it taking some time for the operations
    to complete their execution.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们在请求处理类中编写的不同方法最终都会调用 `time.sleep` 来模拟操作执行所需的时间。
- en: Refactoring code to take advantage of asynchronous decorators
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构代码以利用异步装饰器
- en: As each operation takes some time and blocks the possibility to process other
    incoming HTTP requests, we will create a new version of this API that will use
    asynchronous execution, and we will understand the advantages of Tornado's non-blocking
    features. This way, it will be possible to change the brightness level for the
    red LED while another request is changing the brightness level for the green LED.
    Tornado will be able to start processing requests while the I/O operations with
    the drone take some time to complete.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个操作都需要一些时间并且会阻止处理其他传入的 HTTP 请求，我们将创建这个 API 的新版本，它将使用异步执行，我们将了解 Tornado 非阻塞特性的优势。这样，在另一个请求更改绿色
    LED 亮度级别的同时，就可以更改红色 LED 的亮度级别。Tornado 将能够在 I/O 操作与无人机完成一些时间后开始处理请求。
- en: Make sure you quit the Tornado HTTP server. You just need to press *Ctrl* +
    *C* in the Terminal or Command Prompt window in which it is running.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已退出 Tornado HTTP 服务器。您只需在运行它的终端或命令提示符窗口中按 *Ctrl* + *C* 即可。
- en: Tornado 5.1.1 provides ...
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Tornado 5.1.1 提供 ...
- en: Mapping URL patterns to asynchronous request handlers
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 URL 模式映射到异步请求处理器
- en: 'Stay in the `async_drone_service.py` file in the root folder for the virtual
    environment (`Tornado01`). Add the following lines to map URL patterns to our
    previously coded subclasses of the `RequestHandler` superclass, which provide
    us with asynchronous methods for our request handlers. The following lines create
    the main entry point for the application, initialize it with the URL patterns
    for the API, and start listening for requests. The lines that are new or edited,
    compared to the synchronous version, are highlighted. The code file for the sample
    is included in the `restful_python_2_11_01` folder, in the `Django01/async_drone_service.py`
    file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 保持处于虚拟环境根目录下的 `async_drone_service.py` 文件中（`Tornado01`）。添加以下行以将 URL 模式映射到我们之前编写的
    `RequestHandler` 超类子类，这些子类为我们提供了异步方法。以下行创建应用程序的主入口点，用 API 的 URL 模式初始化它，并开始监听请求。与同步版本相比，以下行是新的或已编辑的，已突出显示。示例代码文件位于
    `restful_python_2_11_01` 文件夹中的 `Django01/async_drone_service.py` 文件：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code creates an instance of `tornado.web.Application`, named `application`,
    with the collection of request handlers that make up the web application. We just
    changed the name of the handlers for the new names that have the `Async` prefix.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个名为 `application` 的 `tornado.web.Application` 实例，其中包含构成 Web 应用程序的请求处理器集合。我们只是将处理器的名称更改为具有
    `Async` 前缀的新名称。
- en: Making HTTP requests to the Tornado non-blocking API
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 Tornado 非阻塞 API 发送 HTTP 请求
- en: 'Now, we can run the `drone_service.py` script, which launches the development
    server for Tornado 5.1.1 to our new version of the web API that uses the non-blocking
    features of Tornado, combined with an asynchronous execution. Make sure that the
    `drone_service.py` script is not running anymore. Execute the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行 `drone_service.py` 脚本，该脚本启动 Tornado 5.1.1 开发服务器，为我们的新版本 Web API 启动，该
    API 使用 Tornado 的非阻塞特性，并结合异步执行。确保 `drone_service.py` 脚本不再运行。执行以下命令：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following line shows the output after we execute the previous command.
    The Tornado HTTP development server is listening at port `8888`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了执行上一条命令后的输出。Tornado HTTP 开发服务器正在端口 `8888` 监听：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In our new version of the API, each HTTP request is non-blocking. Thus, whenever
    the Tornado HTTP server receives an HTTP request and makes an asynchronous call,
    it is able to start ...
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 API 的新版本中，每个 HTTP 请求都是非阻塞的。因此，每当 Tornado HTTP 服务器收到 HTTP 请求并执行异步调用时，它就能够开始
    ...
- en: Setting up unit tests with pytest
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pytest 设置单元测试
- en: Make sure you quit the Django development server. You just need to press *Ctrl*
    + *C* in the Terminal or Command Prompt window in which it is running.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已退出 Django 开发服务器。您只需在运行它的终端或命令提示符窗口中按 *Ctrl* + *C* 即可。
- en: Now, we will install many additional packages to be able to easily run tests
    and measure their code coverage. Make sure you have activated the virtual environment
    that we created in the previous chapter, named `Tornado01`. After you activate
    the virtual environment, it is time to run many commands that will be the same
    for macOS, Linux, and Windows.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将安装许多附加包，以便能够轻松运行测试并测量它们的代码覆盖率。确保您已激活我们在上一章中创建的虚拟环境，名为 `Tornado01`。激活虚拟环境后，是时候运行许多命令了，这些命令对
    macOS、Linux 和 Windows 都相同。
- en: Now, we will edit the existing `requirements.txt` file to specify the additional
    packages that our application requires to be installed on any supported platform.
    This way, it will be extremely easy to repeat the installation of the specified
    packages with their versions in any new virtual environment.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编辑现有的 `requirements.txt` 文件，以指定我们的应用程序在任意支持平台上需要安装的附加包。这样，在任意新的虚拟环境中重复安装指定包及其版本将变得极其容易。
- en: 'Use your favorite editor to edit the existing text file, named `requirements.txt`,
    within the root folder for the virtual environment. Add the following lines after
    the last line to declare the additional packages that we require. The code file
    for the sample is included in the `restful_python_2_11_01` folder, in the `Tornado01/requirements.txt`
    file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的编辑器编辑虚拟环境根目录内现有的名为 `requirements.txt` 的文本文件。在最后一行之后添加以下行以声明我们所需的额外包。示例的代码文件包含在
    `restful_python_2_11_01` 文件夹中，在 `Tornado01/requirements.txt` 文件中：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Each additional line added to the `requirements.txt` file indicates the package
    and the version that need to be installed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到 `requirements.txt` 文件中的每一行额外内容都指示需要安装的包和版本。
- en: 'The following table summarizes the packages and the version numbers that we
    specified as additional requirements to the previously included packages:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了我们作为额外要求指定的之前包含的包及其版本号：
- en: '| Package name | Version to be installed |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 包名 | 要安装的版本 |'
- en: '| `pytest` | 4.0.2 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `pytest` | 4.0.2 |'
- en: '| `coverage` | 4.5.2 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `coverage` | 4.5.2 |'
- en: '| `pytest-cov` | 2.6.0 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `pytest-cov` | 2.6.0 |'
- en: '| `pytest-tornasync` | 0.5.0 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `pytest-tornasync` | 0.5.0 |'
- en: 'We will install the following Python packages in our virtual environment:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的虚拟环境中安装以下 Python 包：
- en: '`pytest`: This is a very popular Python unit test framework that makes testing
    easy and reduces boilerplate code.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest`：这是一个非常流行的 Python 单元测试框架，它使测试变得简单，并减少了样板代码。'
- en: '`coverage`: This tool measures code coverage of Python programs and we will
    use it to determine which parts of the code are being executed by unit tests and
    which parts aren''t.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coverage`：这个工具测量 Python 程序的代码覆盖率，我们将使用它来确定哪些代码部分被单元测试执行，哪些部分没有。'
- en: '`pytest-cov`: This plugin for `pytest` makes it easy to produce coverage reports
    that use the `coverage` tool under the hood and provides some additional features.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest-cov`：这个针对 `pytest` 的插件使得使用底层的 `coverage` 工具生成覆盖率报告变得容易，并提供了一些额外的功能。'
- en: '`pytest-tornasync`: This plugin for `pytest` provides fixtures to make it easier
    to test Tornado asynchronous code with `pytest`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest-tornasync`：这个针对 `pytest` 的插件提供了固定装置，使得使用 `pytest` 测试 Tornado 异步代码变得更加容易。'
- en: 'Now, we must run the following command on macOS, Linux, or Windows to install
    the additional packages and the versions outlined in the previous table with `pip`,
    using the recently edited `requirements.txt` file. Make sure you are located in
    the folder that has the `requirements.txt` file before running the command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在 macOS、Linux 或 Windows 上运行以下命令，使用 `pip` 安装之前表格中概述的额外包及其版本，使用最近编辑的 `requirements.txt`
    文件。在运行命令之前，请确保您位于包含 `requirements.txt` 文件的文件夹中：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The last lines for the output will indicate whether all the new packages and
    their dependencies have been successfully installed. If you downloaded the source
    code for the example and you didn''t work with the previous version of the API,
    `pip` will also install the other packages included in the `requirements.txt`
    file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示所有新包及其依赖项是否已成功安装。如果您下载了示例的源代码，并且没有使用之前的 API 版本，`pip` 还将安装 `requirements.txt`
    文件中包含的其他包：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a new `setup.cfg` file in the root folder for the virtual environment
    (`Tornado01`). The following lines show the code that specifies the desired configuration
    for `pytest` and the `coverage` tools. The code file for the sample is included
    in the `restful_python_2_11_01` folder, in the `Tornado01/setup.cfg` file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟环境（`Tornado01`）的根目录下创建一个新的 `setup.cfg` 文件。以下行显示了指定 `pytest` 和 `coverage`
    工具所需配置的代码。示例的代码文件包含在 `restful_python_2_11_01` 文件夹中，在 `Tornado01/setup.cfg` 文件中：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `tool:pytest` section specifies the configuration for `pytest`. The `testpaths`
    setting assigns the `tests.py` value to indicate that the tests are located in
    the `tests.py` file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`tool:pytest` 部分指定了 `pytest` 的配置。`testpaths` 设置将 `tests.py` 的值分配给指示测试位于 `tests.py`
    文件中。'
- en: The `coverage:run` section specifies the configuration for the `coverage` tool.
    The `branch` setting is set to `True` to enable branch coverage measurement in
    addition to the default statement coverage. The `source` setting specifies the
    modules that we want to be considered for coverage measurement. We just want to
    include the `drone` and `async_drone_service` modules.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`coverage:run` 部分指定了 `coverage` 工具的配置。`branch` 设置设置为 `True` 以启用除了默认语句覆盖率之外的分支覆盖率测量。`source`
    设置指定了我们希望考虑进行覆盖率测量的模块。我们只想包括 `drone` 和 `async_drone_service` 模块。'
- en: In this case, we won't be using configuration files for each environment. However,
    in more complex applications, you will definitely want to use configuration files.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不会为每个环境使用配置文件。然而，在更复杂的应用程序中，你肯定会想使用配置文件。
- en: Writing the first round of unit tests
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写第一轮单元测试
- en: Now, we will write the first round of unit tests. Specifically, we will write
    unit tests related to the LED resources. Test fixtures provide a fixed baseline
    to enable us to reliably and repeatedly execute tests. Pytest makes it easy to
    declare a test fixture function by marking a function with the `@pytest.fixture`
    decorator. Then, whenever we use the fixture function name as an argument in a
    test function declaration, `pytest` will make the fixture function provide the
    fixture object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写第一轮单元测试。具体来说，我们将编写与LED资源相关的单元测试。测试固定装置提供了一个固定的基线，使我们能够可靠地重复执行测试。Pytest通过使用`@pytest.fixture`装饰器标记函数，使我们能够轻松地声明测试固定装置函数。然后，每当我们在测试函数声明中使用固定装置函数名称作为参数时，`pytest`将使固定装置函数提供固定装置对象。
- en: The `pytest-tornasync` plugin provides us with many fixtures that we will use
    to easily write tests for our Tornado API. In order to work with this plugin,
    we must declare a fixture function, named `app`, that returns a `tornado.web.Application
    ...`
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest-tornasync`插件为我们提供了许多固定装置，我们将使用这些固定装置轻松编写我们的Tornado API测试。为了与该插件一起工作，我们必须声明一个名为`app`的固定装置函数，该函数返回一个`tornado.web.Application
    ...`'
- en: Improving testing coverage
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高测试覆盖率
- en: Now, we will write additional unit tests to improve the testing coverage. Specifically,
    we will write unit tests related to the hexacopter motor and the altimeter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写额外的单元测试以提高测试覆盖率。具体来说，我们将编写与六旋翼飞行器电机和高度计相关的单元测试。
- en: 'Open the `tests.py` file in the root folder for the virtual environment (`Tornado01`).
    Insert the following lines after the last line. The code file for the sample is
    included in the `restful_python_2_11_02` folder, in the `Django01/tests.py` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 打开虚拟环境根文件夹（`Tornado01`）中的`tests.py`文件。在最后一行之后插入以下行。示例代码文件包含在`restful_python_2_11_02`文件夹中的`Django01/tests.py`文件：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The previous code added the following three test functions, whose names start
    with the `test_` prefix and who receive the `http_server_client` argument to use
    this test fixture:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 之前添加了以下三个测试函数，它们的名称以`test_`前缀开头，并接收`http_server_client`参数以使用此测试固定装置：
- en: '`test_set_and_get_hexacopter_motor_speed`: This test function tests whether
    we can set and get the hexacopter''s motor speed'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_set_and_get_hexacopter_motor_speed`：此测试函数测试我们是否可以设置和获取六旋翼飞行器的电机速度'
- en: '`test_get_altimeter_altitude_in_feet`: This test function tests whether we
    can retrieve the altitude value from the altimeter, expressed in feet'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_get_altimeter_altitude_in_feet`：此测试函数测试我们是否可以从高度计检索以英尺为单位的高度值'
- en: '`test_get_altimeter_altitude_in_meters`: This test function tests whether we
    can retrieve the altitude value from the altimeter, expressed in meters'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_get_altimeter_altitude_in_meters`：此测试函数测试我们是否可以从高度计检索以米为单位的高度值'
- en: We just coded a few tests related to the hexacopter and the altimeter in order
    to improve test coverage and note the impact on the test coverage report.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅编写了一些与六旋翼飞行器和高度计相关的测试，以提高测试覆盖率并记录对测试覆盖率报告的影响。
- en: 'Now, we will use the `pytest` command to run tests and measure their code coverage.
    Make sure you run the command in the Terminal or Command Prompt window in which
    you have activated the virtual environment, and that you are located within its
    root folder (`Tornado01`). Run the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`pytest`命令运行测试并测量它们的代码覆盖率。确保你在激活了虚拟环境的终端或命令提示符窗口中运行此命令，并且你位于其根文件夹（`Tornado01`）内。运行以下命令：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following lines show the sample output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了示例输出：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output provided details indicating that the test runner executed four tests
    and all of them passed. The test code coverage measurement report provided by
    the `coverage` package increased the `Cover` percentage of the `async_drone_service.py`
    module from 40% to 69%. In addition, the `Cover` percentage of the `drone.py`
    module increased from 59% in the previous run to 79%. The new tests we wrote executed
    additional code in different modules, and therefore there is an important impact
    in the coverage report. The total coverage increased from 46% to 72%.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输出提供了详细信息，表明测试运行器执行了四个测试，并且所有测试都通过了。由 `coverage` 包提供的测试代码覆盖率测量报告将 `async_drone_service.py`
    模块的 `Cover` 百分比从 40% 提高到 69%。此外，`drone.py` 模块的 `Cover` 百分比从上一次运行的 59% 提高到 79%。我们编写的新测试在多个模块中执行了额外的代码，因此在覆盖率报告中产生了重要影响。总覆盖率从
    46% 提高到 72%。
- en: If we take a look at the missing statements, we will notice that we aren't testing
    scenarios where validations fail. Now, we will write additional unit tests to
    improve the testing coverage further. Specifically, we will write unit tests to
    make sure that we cannot set invalid brightness levels for the LEDs, we cannot
    set invalid motor speeds for the hexacopter, and that we receive an HTTP `404
    Not Found` status code when we try to access a resource that doesn't exist.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看缺失的语句，我们会注意到我们没有测试验证失败的场景。现在，我们将编写额外的单元测试来进一步提高测试覆盖率。具体来说，我们将编写单元测试以确保我们无法为
    LED 设置无效的亮度级别，无法为六旋翼机设置无效的电机速度，并且在尝试访问不存在的资源时，我们会收到 HTTP `404 Not Found` 状态码。
- en: 'Open the `tests.py` file in the root folder for the virtual environment (`Tornado01`).
    Insert the following lines after the last line. The code file for the sample is
    included in the `restful_python_2_11_03` folder, in the `Django01/tests.py` file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 打开虚拟环境（`Tornado01`）根目录下的 `tests.py` 文件。在最后一行之后插入以下行。示例代码文件包含在 `restful_python_2_11_03`
    文件夹中，在 `Django01/tests.py` 文件中：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The previous code added the following three test functions, whose names start
    with the `test_` prefix and receive the `http_server_client` argument to use this
    test fixture:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码添加了以下三个测试函数，它们的名称以 `test_` 前缀开头，并接收 `http_server_client` 参数以使用此测试固定装置：
- en: '`test_set_invalid_brightness_level`: This test function makes sure that we
    cannot set an invalid brightness level for an LED through an HTTP `PATCH` request.
    In this method, many `try...except` blocks capture an `HTTPClientError` exception
    as `err` and use `assert` to make sure the `err.code` attribute matches `HTTPStatus.BAD_REQUEST`.
    This way, the test makes sure that each HTTP `PATCH` request generates an HTTP
    `400 Bad Request` status code.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_set_invalid_brightness_level`：这个测试函数确保我们无法通过 HTTP `PATCH` 请求为 LED 设置无效的亮度级别。在这个方法中，许多
    `try...except` 块捕获 `HTTPClientError` 异常作为 `err` 并使用 `assert` 确保异常的 `err.code`
    属性与 `HTTPStatus.BAD_REQUEST` 匹配。这样，测试确保每个 HTTP `PATCH` 请求都生成了 HTTP `400 Bad Request`
    状态码。'
- en: '`test_set_brightness_level_invalid_led_id`: This test function makes sure that
    we cannot set the brightness level for an invalid LED `id` through an HTTP `PATCH`
    request.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_set_brightness_level_invalid_led_id`：这个测试函数确保我们无法通过 HTTP `PATCH` 请求设置无效
    LED `id` 的亮度级别。'
- en: '`test_get_brightness_level_invalid_led_id`: This test function makes sure that
    we cannot get the brightness level for an invalid LED `id` through an HTTP `GET`
    request.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_get_brightness_level_invalid_led_id`：这个测试函数确保我们无法通过 HTTP `GET` 请求获取无效
    LED `id` 的亮度级别。'
- en: In the last two methods, a `try...except` block captures an `HTTPClientError`
    exception as `err`. The `except` block uses `assert` to make sure the `err.code`
    attribute matches `HTTPStatus.NOT_FOUND`. This way, the test makes sure that the
    HTTP `PATCH` and HTTP `GET` requests to generate an HTTP `404 Not Found` status
    code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两种方法中，一个 `try...except` 块捕获了 `HTTPClientError` 异常作为 `err`。`except` 块使用 `assert`
    确保异常的 `err.code` 属性与 `HTTPStatus.NOT_FOUND` 匹配。这样，测试确保了 HTTP `PATCH` 和 HTTP `GET`
    请求生成了 HTTP `404 Not Found` 状态码。
- en: When an HTTP request is unsuccessful, the `http_server_client.fetch` method
    raises a `tornado.httpclient.HTTPClientError` exception and the status code is
    available in the `code` attribute for the instance.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当 HTTP 请求失败时，`http_server_client.fetch` 方法会抛出 `tornado.httpclient.HTTPClientError`
    异常，状态码在实例的 `code` 属性中可用。
- en: 'Stay in the `tests.py` file in the root folder for the virtual environment
    (`Tornado01`). Insert the following lines after the last line. The code file for
    the sample is included in the `restful_python_2_11_03` folder, in the `Django01/tests.py`
    file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟环境（`Tornado01`）根目录下的 `tests.py` 文件中保持。在最后一行之后插入以下行。示例的代码文件包含在 `restful_python_2_11_03`
    文件夹中的 `Django01/tests.py` 文件：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The previous code added the following four test functions, whose names start
    with the `test_` prefix and receive the `http_server_client` argument to use this
    test fixture:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码添加了以下四个测试函数，它们的名称以 `test_` 前缀开头，并接收 `http_server_client` 参数以使用此测试固定装置：
- en: '`test_set_invalid_brightness_level`: This test function makes sure that we
    cannot set an invalid brightness level for the LED through an HTTP `PATCH` request'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_set_invalid_brightness_level`: 这个测试函数确保我们无法通过 HTTP `PATCH` 请求设置 LED 的无效亮度级别'
- en: '`test_set_motor_speed_invalid_hexacopter_id`: This test function makes sure
    that we cannot set the motor speed for an invalid hexacopter `id` through an HTTP
    `PATCH` request'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_set_motor_speed_invalid_hexacopter_id`: 这个测试函数确保我们无法通过 HTTP `PATCH` 请求设置无效六旋翼飞行器的
    `id` 的电机速度'
- en: '`test_get_motor_speed_invalid_hexacopter_id`: This test function makes sure
    that we cannot get the motor speed for an invalid hexacopter `id`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_get_motor_speed_invalid_hexacopter_id`: 这个测试函数确保我们无法获取无效六旋翼飞行器的 `id`
    的电机速度'
- en: '`test_get_altimeter_altitude_invalid_altimeter_id`: This test function makes
    sure that we cannot get the altitude value for an invalid altimeter `id`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_get_altimeter_altitude_invalid_altimeter_id`: 这个测试函数确保我们无法获取无效高度计 `id`
    的高度值'
- en: 'We coded many additional tests that will make sure that all the validations
    work as expected. Now, we will use the `pytest` command again to run the tests
    and measure their code coverage. Make sure you run the command in the Terminal
    or Command Prompt window in which you have activated the virtual environment,
    and that you are located within its root folder (`Tornado01`). Run the following
    command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了许多额外的测试，以确保所有验证都能按预期工作。现在，我们将再次使用 `pytest` 命令来运行测试并测量它们的代码覆盖率。确保你在激活了虚拟环境的终端或命令提示符窗口中运行此命令，并且你位于其根目录（`Tornado01`）内。运行以下命令：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following lines show the sample output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了示例输出：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The output provided details indicating that the test runner executed `11` tests
    and all of them passed. The test code coverage measurement report provided by
    the `coverage` package increased the `Cover` percentage of the `async_drone_service.py`
    module from 69% to 87%. In addition, the `Cover` percentage of the `drone.py`
    module increased from 79% in the previous run to 85%. The new tests we wrote executed
    additional code in different modules, and therefore there is an important impact
    in the coverage report. The total coverage increased from 72% to 86%.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的输出详细说明了测试运行器执行了 `11` 个测试，并且所有测试都通过了。由 `coverage` 包提供的测试代码覆盖率测量报告将 `async_drone_service.py`
    模块的 `Cover` 百分比从 69% 提高到 87%。此外，`drone.py` 模块的 `Cover` 百分比从上一次运行的 79% 提高到 85%。我们编写的新测试在多个模块中执行了额外的代码，因此在覆盖率报告中产生了重要影响。总覆盖率从
    72% 提高到 86%。
- en: Understanding strategies for deploying Tornado APIs to the cloud
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解将 Tornado API 部署到云的策略
- en: Tornado supplies its own HTTP server, and therefore it can run without a WSGI
    container. However, some cloud providers, such as Google App Engine, only enable
    the running of Tornado in a WSGI-only environment. When Tornado runs in a WSGI-only
    environment, it doesn't support asynchronous operations. Hence, we must take into
    account this important limitation when selecting our cloud platform for Tornado.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Tornado 提供了自己的 HTTP 服务器，因此它可以不使用 WSGI 容器运行。然而，一些云提供商，如 Google App Engine，仅允许在
    WSGI 环境中运行 Tornado。当 Tornado 在 WSGI 环境中运行时，它不支持异步操作。因此，在选择我们的云平台时，我们必须考虑到这个重要的限制。
- en: We must make sure that the API runs under HTTPS in production environments.
    In addition, we have to make sure we add some authentication and throttling policies.
    Our Tornado sample is a simple RESTful API that provides some features we can
    use as a baseline to generate a more ...
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保在生产环境中 API 在 HTTPS 下运行。此外，我们还需要确保添加一些身份验证和限流策略。我们的 Tornado 示例是一个简单的 RESTful
    API，它提供了一些我们可以用作基准来生成更 ...
- en: Test your knowledge
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'Let''s see whether you can answer the following questions correctly:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否能正确回答以下问题：
- en: '`Future` does which of the following?'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Future` 做了以下哪一项？'
- en: Encapsulates the asynchronous execution of a callable
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封装可调用的异步执行
- en: Encapsulates the synchronous execution of a callable
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封装可调用的同步执行
- en: Runs an asynchronous method synchronously on the executor specified as an argument
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在作为参数指定的执行器上同步运行异步方法
- en: The `concurrent.futures.ThreadPoolExecutor` class provides us with which of
    the following?
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`concurrent.futures.ThreadPoolExecutor`类为我们提供了以下哪个功能？'
- en: A high-level interface for synchronously executing callables
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同步执行调用的高级接口
- en: A high-level interface for asynchronously executing callables
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步执行调用的高级接口
- en: A high-level interface for composing HTTP requests
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合HTTP请求的高级接口
- en: The `@tornado.concurrent.run_on_executor` decorator allows us to do which of
    the following?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@tornado.concurrent.run_on_executor`装饰器允许我们做以下哪一项？'
- en: Run an asynchronous method synchronously on an executor
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行器上同步运行异步方法
- en: Run an asynchronous method on an executor without generating `Future`
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行器上运行异步方法而不生成`Future`
- en: Run a synchronous method asynchronously on an executor
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行器上异步运行同步方法
- en: The recommended way to write asynchronous code in Tornado is to use which of
    the following?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Tornado中编写异步代码的推荐方法是使用以下哪个？
- en: Coroutines
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 协程
- en: Chained callbacks
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链式回调
- en: Subroutines
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子程序
- en: Which of the following fixtures, defined by the `pytest-tornasync pytest` plugin,
    provide an asynchronous HTTP client for tests?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个由`pytest-tornasync pytest`插件定义的固定值提供了异步HTTP客户端用于测试？
- en: '`tornado_client`'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tornado_client`'
- en: '`http_client`'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http_client`'
- en: '`http_server_client`'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http_server_client`'
- en: If we want to convert the bytes in a JSON response body into a Python dictionary,
    we can use which of the following functions?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想将JSON响应体中的字节转换为Python字典，我们可以使用以下哪个函数？
- en: '`tornado.escape.json_decode`'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tornado.escape.json_decode`'
- en: '`tornado.escape.byte_decode`'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tornado.escape.byte_decode`'
- en: '`tornado.escape.response_body_decode`'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tornado.escape.response_body_decode`'
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we understood the difference between synchronous and asynchronous
    execution. We created a new version of the RESTful API that takes advantage of
    the non-blocking features in Tornado, combined with an asynchronous execution.
    We improved the scalability of our existing API and made it possible to start
    executing other requests while waiting for slow I/O operations with sensors and
    actuators. We avoided splitting our methods into multiple methods with callbacks
    by using the `tornado.gen` generator-based interface that Tornado provides, to
    make it easier to work in an asynchronous environment.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了同步执行和异步执行之间的区别。我们创建了一个新的RESTful API版本，它利用了Tornado中的非阻塞特性，并结合了异步执行。我们提高了现有API的可扩展性，并使其在等待传感器和执行器的慢速I/O操作时能够开始执行其他请求。通过使用Tornado提供的基于`tornado.gen`生成器的接口来避免将我们的方法分割成多个带有回调的方法，这使得在异步环境中工作变得更加容易。
- en: Then, we set up a testing environment. We installed `pytest`, along with many
    plugins, to make it easy to discover and execute unit ...
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置了测试环境。我们安装了`pytest`以及许多插件，以便更容易地发现和执行单元测试 ...
