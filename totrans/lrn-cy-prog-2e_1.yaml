- en: Chapter 1. Cython Won't Bite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cython is much more than a programming language. Its origin can be traced to
    SAGE, the mathematics software package, where it is used to increase the performance
    of mathematical computations such as those involving matrices. More generally,
    I tend to consider Cython as an alternative to SWIG to generate really good Python
    bindings to native code.
  prefs: []
  type: TYPE_NORMAL
- en: Language bindings have been around for years, and SWIG was one of the first
    and best tools to generate bindings for multitudes of languages. Cython generates
    bindings for Python code only, and this single purpose approach means it generates
    the best Python bindings you can get outside of doing it all manually, which should
    be attempted only if you're a Python core developer.
  prefs: []
  type: TYPE_NORMAL
- en: For me, taking control of legacy software by generating language bindings is
    a great way to reuse any software package. Consider a legacy application written
    in C/C++. Adding advanced modern features such as a web server for a dashboard
    or message bus is not a trivial thing to do. More importantly, Python comes with
    thousands of packages that have been developed, tested, and used by people for
    a long time that can do exactly that. Wouldn't it be great to take advantage of
    all of this code? With Cython, we can do exactly this, and I will demonstrate
    approaches with plenty of example codes along the way.
  prefs: []
  type: TYPE_NORMAL
- en: This first chapter will be dedicated to the core concepts on using Cython, including
    compilation, and should provide a solid reference and introduction for all the
    Cython core concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this first chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Cython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started - Hello World
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using distutils with Cython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling C functions from Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Cython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Cython is a programming language, we must install its respective compiler,
    which just so happens to be the aptly named *Cython*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many different ways to install Cython. The preferred one would be
    to use `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This should work on both Linux and Mac. Alternatively, you can use your Linux
    distribution''s package manager to install Cython:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows, although there are a plethora of options available, following
    this wiki is the safest option to stay up-to-date: [http://wiki.cython.org/InstallingOnWindows](http://wiki.cython.org/InstallingOnWindows).'
  prefs: []
  type: TYPE_NORMAL
- en: Emacs mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is an **emacs** mode available for Cython. Although the syntax is nearly
    the same as Python, there are differences that conflict in simply using Python-mode.
    You can grab `cython-mode.el` from the Cython source code (inside the `Tools`
    directory.) The preferred way of installing packages to emacs would be to use
    a package repository like `MELPA`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the package repository to emacs, open your `~/.emacs` configuration
    file and add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you add this and reload your configuration to install the Cython mode,
    you can simply run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is installed, you can activate the mode by adding this into your
    emacs config file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can activate the mode manually at any time with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Getting the code examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout this book, I intend to show real examples that are easy to digest
    in order to help you get a feel of the different things you can achieve with Cython.
    To access and download the code used, please clone this repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Getting started – Hello World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you will see when running the **Hello World** program, Cython generates
    native Python modules. Therefore, running any Cython code, you will reference
    it via a module import in Python. Let''s build the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now have created `helloworld.so`! This is a Cython module of the
    same name as the Cython source code file. While in the same directory of the shared
    object module, you can invoke this code by running a respective Python import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see by opening `helloworld.pyx`, it looks just like a normal Python
    Hello World application, but as previously stated, Cython generates modules. These
    modules need a name so that they can be correctly imported by the Python runtime.
    The Cython compiler simply uses the name of the source code file. It then requires
    us to compile this to the same shared object name.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, Cython source code files have the `.pyx`,`.pxd`, and `.pxi` extensions.
    For now, all we care about are the `.pyx` files; the others are for **cimports**
    and **includes** respectively within a `.pyx` module file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot depicts the compilation flow required to have a callable
    native Python module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started – Hello World](img/B04685_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'I wrote a basic `makefile` so that you can simply run `make` to compile these
    examples. Here''s the code to do this manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using distutils with Cython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also compile this HelloWorld example module using Python `distutils`
    and `cythonize`. Open the `setup.py` along side the Makefile and you can see the
    alternate way to compile Cython modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using the `cythonize` function as part of the `ext_modules` section will build
    any specified Cython source into an installable Python module. This will compile
    `helloworld.pyx` into the same shared library. This provides the Python practice
    to distribute native modules as part of `distutils`.
  prefs: []
  type: TYPE_NORMAL
- en: Calling C functions from Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We should be careful for clarity when talking about Python and Cython since
    the syntax is so similar. Let's wrap a simple `AddFunction` in C and make it callable
    from Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open a file called `AddFunction.c`, and write a simple function in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the C code that we will call—just a simple function to add two integers.
    Now, let''s get Python to call it. Open a file called `AddFunction.h`, wherein
    we will declare our prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We need this so that Cython can see the prototype for the function we want to
    call. In practice, you will already have your headers in your own project with
    your prototypes and declarations already available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a file called `AddFunction.pyx`, and insert the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have to declare which code we want to call. The `cdef` is a keyword
    signifying that this is from the C code that will be linked in. Now, we need a
    Python entry point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This `Add` function is a Python callable inside a `PyAddFunction` module this
    acts as a wrapper for Python code to be able to call directly into the C code.
    Again, I have provided a handy `makefile` to produce the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `AddFunction.c` is compiled into the same `PyAddFunction.so` shared
    object. Now, let''s call this `AddFunction` and check to see if C can add numbers
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the print statement inside the `AddFunction` and the final result
    are printed correctly. Therefore, we know that the control hit the C code and
    did the calculation in C, and not inside the Python runtime. This is a revelation
    of what is possible. Python can be cited to be slow in some circumstances. Using
    this technique makes it possible for Python code to bypass its own runtime and
    to run in an unsafe context, which is unrestricted by the Python runtime which
    is much faster.
  prefs: []
  type: TYPE_NORMAL
- en: Type conversion in Cython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Notice that we had to declare a prototype inside the Cython source code `PyAddFunction.pyx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It lets the compiler know that there is a function called `AddFunction` and
    it takes two ints and returns an int. This is all the information the compiler
    needs to know beside the host and target operating system''s calling convention
    to call this function safely. Then, we created the Python entry point, which is
    a Python callable that takes two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Inside this entry point, it simply returned the native `AddFunction` and passed
    the two Python objects as parameters. This is what makes Cython so powerful. Here,
    the Cython compiler must inspect the function call and generate code to safely
    try and convert these Python objects to native C integers. This becomes difficult
    when precision is taken into account as well as potential overflow, which just
    so happens to be a major use case since it handles everything so well. Also, remember
    that this function returns an integer, and Cython also generates code to convert
    the integer return into a valid Python object.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overall, we installed the Cython compiler, ran the Hello World example, and
    took into consideration that we need to compile all code into native shared objects.
    We also saw how to wrap native C code to make it callable from Python. We have
    also seen the implicit type conversion which Cython does for us to make calling
    C work. In the next chapter, we will delve deeper into Cython programming with
    discussion on how to make Python code callable from C and manipulate native C
    data structures from Cython.
  prefs: []
  type: TYPE_NORMAL
