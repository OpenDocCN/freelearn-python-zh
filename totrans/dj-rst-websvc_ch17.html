<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Using Constraints, Filtering, Searching, Ordering, and Pagination</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using Constraints, Filtering, Searching, Ordering, and Pagination</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will take advantage of many features included in the Django REST framework to add constraints, pagination, filtering, searching, and ordering features to our RESTful Web Service. We will add a huge amount of features with a few lines of code. We will gain an understanding of:</p>
<ul>
<li>Browsing the API with resources and relationships</li>
<li>Defining unique constraints</li>
<li>Working with unique constraints</li>
<li>Understanding pagination</li>
<li>Configuring pagination classes</li>
<li>Making requests that paginate results</li>
<li>Working with customized pagination classes</li>
<li>Making requests that use customized paginated results</li>
<li>Configuring filter backend classes</li>
<li>Adding filtering, searching, and ordering</li>
<li>Working with different types of Django filters</li>
<li>Making requests that filter results</li>
<li>Composing requests that filter and order results</li>
<li>Making requests that perform starts with searches</li>
<li>Using the browsable API to test pagination, filtering, searching, and ordering</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Browsing the API with resources and relationships</h1>
                </header>
            
            <article>
                
<p>We will take advantage of the browsable API feature that we introduced in <a href="dj-rst-websvc_ch15.html" target="_blank">Chapter 5</a>,<em>&#160;Understanding and Customizing the Browsable API Feature</em>, with our new web service. Let's start browsing our new RESTful Web Service. Open a web browser and enter <kbd>http://localhost:8000</kbd>. The browser will compose and send a <kbd>GET</kbd> request to <kbd>/</kbd> with <kbd>text/html</kbd> as the desired content type, and the returned HTML web page will be rendered.</p>
<p>The request will end up executing the <kbd><span><span>GET</span></span></kbd>&#160;method defined in the <kbd>ApiRoot</kbd> class within the <kbd>views.py</kbd> file. The following screenshot shows the rendered web page with the resource description&#160;<span class="packt_screen">Api Root</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="307" width="388" src="images/4e6c4e6e-fc28-42b8-a414-84671a6e6c58.png"/></div>
<p>The <span class="packt_screen">Api Root</span> renders the following hyperlinks:</p>
<ul>
<li><kbd>http://localhost:8000/drone-categories/</kbd>: The collection of drone categories</li>
<li><kbd>http://localhost:8000/drones/</kbd>: The collection of drones</li>
<li><kbd>http://localhost:8000/pilots/</kbd>: The collection of pilots</li>
<li><kbd>http://localhost:8000/competitions/</kbd>: The collection of competitions</li>
</ul>
<p>We can easily access each resource collection by clicking or tapping on the appropriate hyperlink. Once we access each resource collection, we can perform operations on the different resources throughout the browsable API. Whenever we visit any of the resource collections, we can use the breadcrumb to go back to the <span class="packt_screen">Api&#160;Root</span> that lists all the hyperlinks.</p>
<div class="packt_tip">Our new RESTful Web Service takes advantage of many generic views. These views provide many features for the browsable API that weren't included when we worked with function-based views, and we will be able to use forms to easily compose and send HTTP <kbd>POST</kbd> requests.</div>
<p>Click or tap on the URL at the right-hand side of <span class="packt_screen">drone-categories</span> and the web browser will go to <kbd>http://localhost:8000/drone-categories/</kbd>. As a result, Django will render the web page for the <span class="packt_screen">Drone Category List</span>. At the bottom of the web page, there are two tabs to make an HTTP POST request: <span class="packt_screen">Raw data</span> and <span class="packt_screen">HTML form</span>. By default, the <span class="packt_screen">HTML form</span> tab is activated and displays an automatically generated form with a textbox to enter the value for the <span class="packt_screen">Name</span> field to create a new drone category. We can use this form to easily compose and send an HTTP POST request without having to deal with the raw JSON data as we did when working with the browsable API and our previous web service. The following screenshot shows the HTML form to create a new drone category:</p>
<div class="CDPAlignCenter CDPAlign"><img height="343" width="385" src="images/99ba53ff-72e1-4c21-94a1-6a40cfe4d7a2.png"/></div>
<div class="packt_tip">HTML forms make it really easy to generate requests to test our RESTful web service with the browsable API.</div>
<p>Enter the following value in the <span class="packt_screen">Name</span> textbox: <kbd>Octocopter</kbd>. Then, click or tap <span class="packt_screen">POST</span> to create a new drone category. The browsable API will compose and send an HTTP <kbd>POST</kbd> request to <kbd>/drone-categories/</kbd> with the specified data. Then, we will see the results of this request in the web browser. The following screenshot shows the rendered web page with the results of the previous operation, with an HTTP status code of <kbd>201 Created</kbd> in the response and the previously explained HTML form with the <span class="packt_screen">POST</span> button that allows us to continue composing and sending HTTP <kbd>POST</kbd> requests to <kbd>/drone-categories/</kbd>:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><br/>
<img height="360" width="421" src="images/562ff41e-6c31-45d9-83e6-947634b56c10.png"/></div>
<p>Now, you can go back to the <span class="packt_screen">Api Root</span> by clicking on the link on the breadcrumb and use the HTML forms to create drones, pilots, and finally, competitions. For example, go to the <span class="packt_screen">Api Root</span> and click or tap on the URL at the right-hand side of <span class="packt_screen">drones</span> and the web browser will go to <kbd>http://localhost:8000/drones/</kbd>. As a result, Django will render the web page for the <span class="packt_screen">Drone List</span>. At the bottom of the web page, there are two tabs to make an HTTP POST request: <span class="packt_screen">Raw data</span> and <span class="packt_screen">HTML</span> <span class="packt_screen">form</span>. By default, the <span class="packt_screen">HTML form</span> tab is activated and displays an automatically generated form with the appropriate controls for the following fields:</p>
<ul>
<li><span class="packt_screen">Name</span></li>
<li><span class="packt_screen">Drone category</span></li>
<li><span class="packt_screen">Manufacturing date</span></li>
<li><span class="packt_screen">Has it competed</span></li>
</ul>
<p>The <span class="packt_screen">Drone category</span> field provides a drop-down with all the existing drone categories so that we can select one of them for our new drone. The <span class="packt_screen">Has it competed</span> field provides a checkbox because the underlying field is Boolean.</p>
<p>We can use this form to easily compose and send an HTTP <kbd>POST</kbd> request without having to deal with the raw JSON data as we did when working with the browsable API and our previous web service. The following screenshot shows the <span class="packt_screen">HTML form</span> to create a new drone:</p>
<div class="CDPAlignCenter CDPAlign"><img height="201" width="408" src="images/b11fe842-b418-4f1b-b823-f3bad85094d4.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining unique constraints</h1>
                </header>
            
            <article>
                
<p>The RESTful Web Service doesn't use any constraints, and therefore, it is possible to create many drone categories with the same name. We don't want to have many drone categories with the same name. Each drone category name must be unique in the database table that persists drone categories (the <kbd>drones_dronecategory</kbd> table). We also want drones and pilots to have unique names. Hence, we will make the necessary changes to add unique constraints to each of the following fields:</p>
<ul>
<li>The name field of the <kbd>DroneCategory</kbd> model</li>
<li>The name field of the <kbd>Drone</kbd> model</li>
<li>The name field of the <kbd>Pilot</kbd> model</li>
</ul>
<p>We will learn the necessary steps to edit existing models and add constraints to fields that are already persisted in tables and to propagate the changes in the underlying database by running the already analyzed migrations process.</p>
<p>Make sure you quit Django's development server. Remember that you just need to press <em><span class="KeyPACKT">Ctrl</span></em> + <em><span class="KeyPACKT">C</span></em> in the terminal or Command Prompt window in which it is running. We have to edit the models and then execute migrations before starting Django's development server again.</p>
<p>Now, we will edit the existing code that declares the models to add unique constraints to the <kbd>name</kbd> field for the models that we use to represent and persist the drone categories, drones, and pilots. Open the <kbd>drones/models.py</kbd> file and replace the code that declares the <kbd>DroneCategory</kbd>, <kbd>Drone</kbd>, and <kbd>Pilot</kbd> classes with the following code. The lines that were edited are highlighted in the code listing. The code for the <kbd>Competition</kbd> class remains without changes. The code file for the sample is included in the <kbd>hillar_django_restful_07_01</kbd> folder, in the <kbd>restful01/drones/models.py</kbd> file:</p>
<pre>  class DroneCategory(models.Model): 
<strong>     name = models.CharField(max_length=250, unique=True) 
</strong> 
     class Meta: 
        ordering = ('name',) 
 
     def __str__(self): 
         return self.name 
 
 
  class Drone(models.Model): 
<strong>     name = models.CharField(max_length=250, unique=True) 
</strong>     drone_category = models.ForeignKey( 
         DroneCategory,  
         related_name='drones',  
         on_delete=models.CASCADE) 
      manufacturing_date = models.DateTimeField() 
      has_it_competed = models.BooleanField(default=False) 
      inserted_timestamp = models.DateTimeField(auto_now_add=True) 
 
    class Meta: 
        ordering = ('name',) 
 
    def __str__(self): 
        return self.name 
 
 
  class Pilot(models.Model): 
    MALE = 'M' 
    FEMALE = 'F' 
    GENDER_CHOICES = ( 
        (MALE, 'Male'), 
        (FEMALE, 'Female'), 
    ) 
<strong>    name = models.CharField(max_length=150, blank=False, unique=True) 
</strong>    gender = models.CharField( 
        max_length=2, 
        choices=GENDER_CHOICES, 
        default=MALE, 
    ) 
    races_count = models.IntegerField() 
    inserted_timestamp = models.DateTimeField(auto_now_add=True) 
 
    class Meta: 
        ordering = ('name',) 
 
    def __str__(self): 
        return self.name </pre>
<p>We added <kbd>unique=True</kbd> as one of the named arguments for each call to the <kbd>models.CharField</kbd> initializer. This way, we specify that the fields must be unique, and Django's ORM will translate this into a requirement for the creation of the necessary unique constraints for the fields in the underlying database tables.</p>
<p>Now, it is necessary to execute the migrations that will generate the unique constraints we added for the fields in the models in the database. This time, the migrations process will synchronize the database with the changes we made in the models, and therefore, the process will apply a delta. Run the following Python script:</p>
<pre>    <strong>python manage.py makemigrations drones</strong></pre>
<p>The following lines show the output generated after running the previous command:</p>
<pre><strong>Migrations for 'drones':</strong><br/><strong>drones/migrations/0002_auto_20171104_0246.py</strong><br/><strong>- Alter field name on drone</strong><br/><strong>- Alter field name on dronecategory</strong><br/><strong>- Alter field name on pilot  </strong></pre>
<p>The lines in the output indicate that the <kbd>drones/migrations/0002_auto_20171104_0246.py</kbd> file includes the code to alter the fields called <kbd>name</kbd> on <kbd>drone</kbd>, <kbd>dronecategory</kbd>, and <kbd>pilot</kbd>. It is important to take into account that the Python filename generated by the migrations process encodes the date and time, and therefore, the name will be different when you run the code in your development computer.</p>
<p>The following lines show the code for the file that was automatically generated by Django. The code file for the sample is included in the <kbd>hillar_django_restful_07_01</kbd> folder, in the <kbd>restful01/drones/migrations/0002_auto_20171104_0246.py</kbd> file:</p>
<pre># -*- coding: utf-8 -*- 
# Generated by Django 1.11.5 on 2017-11-04 02:46 
from __future__ import unicode_literals 
 
from django.db import migrations, models 
 
 
class Migration(migrations.Migration): 
 
    dependencies = [ 
        ('drones', '0001_initial'), 
    ] 
 
    operations = [ 
        migrations.AlterField( 
            model_name='drone', 
            name='name', 
            field=models.CharField(max_length=250, unique=True), 
        ), 
        migrations.AlterField( 
            model_name='dronecategory', 
            name='name', 
            field=models.CharField(max_length=250, unique=True), 
        ), 
        migrations.AlterField( 
            model_name='pilot', 
            name='name', 
            field=models.CharField(max_length=50, unique=True), 
        ), 
    ] </pre>
<p>The code defines a subclass of the <kbd>django.db.migrations.Migration</kbd> class called <kbd>Migration</kbd>, which defines an <kbd>operations</kbd> list with many <kbd>migrations.AlterField</kbd> instances. Each <kbd>migrations.AlterField</kbd> instance will alter the field in the table for each of the related models: <kbd>drone</kbd>, <kbd>dronecategory</kbd>, and <kbd>pilot</kbd>.</p>
<p>Now, run the following Python script to execute all the generated migrations and apply the changes in the underlying database tables:</p>
<pre>    <strong>python manage.py migrate</strong></pre>
<p>The following lines show the output generated after running the previous command. Notice that the order in which the migrations are executed can differ in your development computer:</p>
<pre>    <strong>Operations to perform:</strong>
    <strong>  Apply all migrations: admin, auth, contenttypes, drones, sessions</strong>
    <strong>Running migrations:</strong>
    <strong>  Applying drones.0002_auto_20171104_0246... OK</strong>
  </pre>
<p>After we run the previous command, we will have unique indexes on the <kbd>name</kbd> fields for the following tables in the PostgreSQL database:</p>
<ul>
<li><kbd>drones_drone</kbd></li>
<li><kbd>drones_dronecategory</kbd></li>
<li><kbd>drones_pilot</kbd></li>
</ul>
<p>We can use the PostgreSQL command-line tools or any other application that allows us to easily check the contents of the PostgreSQL database to check the tables that Django updated. If you are working with an SQLite or any other database with this example, make sure you use the commands or tools related to the database you are using.</p>
<p>The following screenshot shows a list of the indexes for each of the previously enumerated tables in the SQLPro for Postgres GUI tool. Each table has a new unique index for the name field:</p>
<div class="CDPAlignCenter CDPAlign"><img height="591" width="300" src="images/1fbca5f4-4c17-428c-a170-febbbc9162b3.png"/></div>
<p>The following are the names generated for the new unique indexes in the sample database:</p>
<ul>
<li>The <kbd>drones_drone_name_85faecee_uniq</kbd> index for the <kbd>drones_drone</kbd> table</li>
<li>The <kbd>drones_drone_dronecategory_name_dedead86_uniq</kbd> index for the <kbd>drones_dronecategory</kbd> table</li>
<li>The <kbd>drones_pilot_name_3b56f2a1_uniq</kbd> index for the <kbd>drones_pilot</kbd> table</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with unique constraints</h1>
                </header>
            
            <article>
                
<p>Now, we can launch Django's development server to compose and send HTTP requests to understand how unique constraints work when applied to our models. Execute any of the following two commands, based on your needs, to access the API in other devices or computers connected to your LAN. Remember that we analyzed the difference between them in <a href="dj-rst-websvc_ch13.html" target="_blank">Chapter 3</a>,&#160;<em>Creating API Views</em>, in the <em>Launching Django's development server</em> section:</p>
<pre>    <strong>python manage.py runserver</strong>
    <strong>python manage.py runserver 0.0.0.0:8000</strong> </pre>
<p>After we run any of the previous commands, the development server will start listening at port <kbd>8000</kbd>.</p>
<p>Now, we will compose and send an HTTP request to create a drone category with a name that already exists: <kbd>'Quadcopter'</kbd>, as shown below:</p>
<pre>    <strong>http POST :8000/drone-categories/ name="Quadcopter"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre> <strong>curl -iX POST -H "Content-Type: application/json" -d  '{"name":"Quadcopter"}' localhost:8000/drone-categories/</strong> </pre>
<p>Django won't be able to persist a <kbd>DroneCategory</kbd> instance whose <kbd>name</kbd> is equal to the specified value because it violates the unique constraint we just added to the <kbd>name</kbd> field for the <kbd>DroneCategory</kbd> model. As a result of the request, we will receive a <kbd>400 Bad Request</kbd> status code in the response header and a message related to the value specified for the <kbd>name</kbd> field in the JSON body: <kbd>"drone category with this name already exists."</kbd> The following lines show the detailed response:</p>
<pre>    <strong>HTTP/1.0 400 Bad Request</strong>
    <strong>Allow: GET, POST, HEAD, OPTIONS</strong>
    <strong>Content-Length: 58</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Sun, 05 Nov 2017 04:00:42 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>Vary: Accept, Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "name": [</strong>
    <strong>        "drone category with this name already exists."</strong>
    <strong>    ]</strong>
    <strong>}</strong></pre>
<div class="packt_tip">We made the necessary changes to avoid duplicate values for the <kbd>name</kbd> field in drone categories, drones, or pilots. Whenever we specify the name for any of these resources, we will be referencing the same unique resource, because duplicates aren't possible.</div>
<p>Now, we will compose and send an HTTP request to create a pilot with a name that already exists: <kbd>'Penelope Pitstop'</kbd>, as shown below:</p>
<pre>    <strong>http POST :8000/pilots/ name="Penelope Pitstop" gender="F" <br/>    races_count=0</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl -iX POST -H "Content-Type: application/json" -d    <br/>    '{"name":"Penelope Pitstop", "gender":"F", "races_count": 0}'   <br/>    localhost:8000/pilots/</strong></pre>
<p>The previous command will compose and send an HTTP <kbd>POST</kbd> request with the specified JSON key-value pairs. The request specifies <kbd>/pilots/</kbd>, and therefore, it will match the <kbd>'^pilots/$'</kbd> regular expression and will run the <kbd>post</kbd> method for the <kbd>views.PilotList</kbd> class-based view. Django won't be able to persist a <kbd>Pilot</kbd> instance whose <kbd>name</kbd> is equal to the specified value because it violates the unique constraint we just added to the <kbd>name</kbd> field for the <kbd>Pilot</kbd> model. As a result of the request, we will receive a <kbd>400 Bad Request</kbd> status code in the response header and a message related to the value specified for the <kbd>name</kbd> field in the JSON body: <kbd>"pilot with this name already exists."</kbd> The following lines show the detailed response:</p>
<pre>    <strong>HTTP/1.0 400 Bad Request</strong>
    <strong>Allow: GET, POST, HEAD, OPTIONS</strong>
    <strong>Content-Length: 49</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Sun, 05 Nov 2017 04:13:37 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>Vary: Accept, Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "name": [</strong>
    <strong>        "pilot with this name already exists."</strong>
    <strong>    ]</strong>
    <strong>}</strong></pre>
<p>If we generate the HTTP <kbd>POST</kbd> request with the help of the HTML form in the browsable API, we will see the error message displayed below the <span class="packt_screen">Name</span> field in the form, as shown in the next screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="374" width="424" src="images/e3a58bab-9384-4f36-8196-7e2dfeb4daf9.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding pagination</h1>
                </header>
            
            <article>
                
<p>So far, we have been working with a database that has just a few rows, and therefore, the HTTP <kbd>GET</kbd> requests to the different resource collections for our RESTful Web Service don't have problems with the amount of data in the JSON body of the responses. However, this situation changes as the number of rows in the database tables increases.</p>
<p>Let's imagine we have 300 rows in the <kbd>drones_pilots</kbd> table that persists pilots. We don't want to retrieve the data for 300 pilots whenever we make an HTTP <kbd>GET</kbd> request to <kbd>localhost:8000/pilots/</kbd>. Instead, we just take advantage of the pagination features available in the Django REST framework to make it easy to specify how we want the large result sets to be split into individual pages of data. This way, each request will retrieve only one page of data, instead of the entire result set. For example, we can make the necessary configurations to retrieve only the data for a page of a maximum of four pilots.</p>
<p>Whenever we enable a pagination scheme, the HTTP <kbd>GET</kbd> requests must specify the pieces of data that they want to retrieve, that is, the details for the specific pages, based on predefined pagination schemes. In addition, it is extremely useful to have data about the total number of resources, the next page, and the previous one, in the response body. This way, the user or the application that is consuming the RESTful Web Service knows the additional requests that need to be made to retrieve the required pages.</p>
<p>We can work with page numbers and the client can request a specific page number in the HTTP <kbd>GET</kbd> request. Each page will include a maximum amount of resources. For example, if we request the first page for the 300 pilots, the web service will return the first four pilots in the response body. The second page will return the pilots from the fifth&#160;to the eighth&#160;position in the response body.</p>
<p>Another option is to specify an offset combined with a limit. For example, if we request a page with an offset equal to 0 and a limit of 4, the web service will return the first four pilots in the response body. A second request with an offset equal to 4 and a limit of 4 will return the pilots from the fifth&#160;to the eighth&#160;position in the response body.</p>
<p>Right now, each of the database tables that persist the models we have defined has a few rows. However, after we start working with our web service in a real-life production environment, we will have hundreds of competitions, pilots, drones, and drone categories. Hence, we will definitely have to deal with large result sets. We will usually have the same situation in most RESTful Web Services, and therefore, it is very important to work with pagination mechanisms.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring pagination classes</h1>
                </header>
            
            <article>
                
<p>The Django REST framework provides many options to enable pagination. First, we will set up one of the customizable pagination styles included in the Django REST framework to include a maximum of four resources in each individual page of data.</p>
<p>Our RESTful Web Service uses the generic views that work with <strong>mixin</strong> classes. These classes are prepared to build paginated responses based on specific settings in the Django REST framework configuration. Hence, our RESTful Web Service will automatically take into account the pagination settings we configured, without requiring additional changes in the code.</p>
<p>Open the <kbd>restful01/restful01/settings.py</kbd> file that declares module-level variables that define the configuration of Django for the <kbd>restful01</kbd> project. We will make some changes to this Django settings file. The code file for the sample is included in the <kbd>hillar_django_restful_07_01</kbd> folder, in the <kbd>restful01/restful01/settings.py</kbd> file.&#160;Add the following lines that declare a dictionary named<span>&#160;</span><kbd>REST_FRAMEWORK</kbd><span>&#160;with key-value pairs that configure the global pagination settings:</span></p>
<pre> REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS':
    'rest_framework.pagination.LimitOffsetPagination',
    'PAGE_SIZE': 4
 }</pre>
<p><span>Save the changes and Django's development server will recognize the edits and start again with the new pagination settings enabled.&#160;</span>The new dictionary has two string keys: <kbd>'DEFAULT_PAGINATION_CLASS'</kbd> and <kbd>'PAGE_SIZE'</kbd>. The value for the <kbd>'DEFAULT_PAGINATION_CLASS'</kbd> key specifies a global setting with the default pagination class that the generic views will use to provide paginated responses. In this case, we will use the <kbd>rest_framework.pagination.LimitOffsetPagination</kbd> class that provides a limit/offset-based style.</p>
<p>This pagination style works with a <kbd>limit</kbd> parameter that indicates the maximum number of items to return and an <kbd>offset</kbd> that specifies the starting position of the query. The value for the <kbd>PAGE_SIZE</kbd> settings key specifies a global setting with the default value for the <kbd>limit</kbd>, also known as the page size. In this case, the value is set to <kbd>4</kbd>, and therefore, the maximum number of resources returned in a single request will be four. We can specify a different limit when we perform the HTTP request by specifying the desired value in the <kbd>limit</kbd> query parameter. We can configure the class to have a maximum <kbd>limit</kbd> value in order to avoid undesired huge result sets. This way, we can make sure that the user won't be able to specify a large number for the <kbd>limit</kbd> value. However, we will make this specific configuration later.</p>
<p>Now, we will compose and send many HTTP <kbd>POST</kbd> requests to create nine additional drones related to the two drone categories we created: <kbd>Quadcopter</kbd> and <kbd>Octocopter</kbd>. This way, we will have a total of 11 drones (two existing drones, plus nine additional drones) to test the limit/offset pagination mechanism we have enabled:</p>
<pre>    <strong>http POST :8000/drones/ name="Need for Speed" drone_category="Quadcopter" manufacturing_date="2017-01-20T02:02:00.716312Z" has_it_competed=false </strong>
    <strong>http POST :8000/drones/ name="Eclipse" drone_category="Octocopter" manufacturing_date="2017-02-18T02:02:00.716312Z" has_it_competed=false</strong>
    <strong>http POST :8000/drones/ name="Gossamer Albatross" drone_category="Quadcopter" manufacturing_date="2017-03-20T02:02:00.716312Z" has_it_competed=false </strong>
    <strong>http POST :8000/drones/ name="Dassault Falcon 7X" drone_category="Octocopter" manufacturing_date="2017-04-18T02:02:00.716312Z" has_it_competed=false</strong>
    <strong>http POST :8000/drones/ name="Gulfstream I" drone_category="Quadcopter" manufacturing_date="2017-05-20T02:02:00.716312Z" has_it_competed=false </strong>
    <strong>http POST :8000/drones/ name="RV-3" drone_category="Octocopter" manufacturing_date="2017-06-18T02:02:00.716312Z" has_it_competed=false</strong>
    <strong>http POST :8000/drones/ name="Dusty" drone_category="Quadcopter" manufacturing_date="2017-07-20T02:02:00.716312Z" has_it_competed=false </strong>
    <strong>http POST :8000/drones/ name="Ripslinger" drone_category="Octocopter" manufacturing_date="2017-08-18T02:02:00.716312Z" has_it_competed=false</strong>
    <strong>http POST :8000/drones/ name="Skipper" drone_category="Quadcopter" manufacturing_date="2017-09-20T02:02:00.716312Z" has_it_competed=false</strong>  </pre>
<p>The following are the equivalent <kbd>curl</kbd> commands:</p>
<pre> <strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Need for Speed", "drone_category":"Quadcopter", "manufacturing_date": "2017-01-20T02:02:00.716312Z", "has_it_competed": "false"}' localhost:8000/drones/</strong>
    <strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Eclipse", "drone_category":"Octocopter", "manufacturing_date": "2017-02-20T02:02:00.716312Z", "has_it_competed": "false"}' localhost:8000/drones/</strong>
    <strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Gossamer Albatross", "drone_category":"Quadcopter", "manufacturing_date": "2017-03-20T02:02:00.716312Z", "has_it_competed": "false"}' localhost:8000/drones/</strong>
    <strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Dassault Falcon 7X", "drone_category":"Octocopter", "manufacturing_date": "2017-04-20T02:02:00.716312Z", "has_it_competed": "false"}' localhost:8000/drones/</strong>
    <strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Gulfstream I", "drone_category":"Quadcopter", "manufacturing_date": "2017-05-20T02:02:00.716312Z", "has_it_competed": "false"}' localhost:8000/drones/</strong>
    <strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"RV-3", "drone_category":"Octocopter", "manufacturing_date": "2017-06-20T02:02:00.716312Z", "has_it_competed": "false"}' localhost:8000/drones/</strong>
    <strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Dusty", "drone_category":"Quadcopter", "manufacturing_date": "2017-07-20T02:02:00.716312Z", "has_it_competed": "false"}' localhost:8000/drones/</strong>
    <strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Ripslinger", "drone_category":"Octocopter", "manufacturing_date": "2017-08-20T02:02:00.716312Z", "has_it_competed": "false"}' localhost:8000/drones/</strong>
    <strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Skipper", "drone_category":"Quadcopter", "manufacturing_date": "2017-09-20T02:02:00.716312Z", "has_it_competed": "false"}' localhost:8000/drones/</strong>  </pre>
<p>The previous commands will compose and send nine HTTP <kbd>POST</kbd> requests with the specified JSON key-value pairs. The requests specify <kbd>/drones/</kbd>, and therefore, they will match the <kbd>'^drones/$'</kbd> regular expression and run the <kbd>post</kbd> method for the <kbd>views.DroneList</kbd> class-based view.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making requests that paginate results</h1>
                </header>
            
            <article>
                
<p>Now, we will compose and send an HTTP <kbd>GET</kbd> request to retrieve all the drones. The new pagination settings will take effect and we will only retrieve the first page for the drones resource collection:</p>
<pre>    <strong>http GET :8000/drones/</strong>  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl -iX GET localhost:8000/drones/</strong></pre>
<p>The previous commands will compose and send an HTTP <kbd>GET</kbd> request. The request specifies <kbd>/drones/</kbd>, and therefore, it will match the <kbd>'^drones/$'</kbd> regular expression and run the <kbd>get</kbd> method for the <kbd>views.DroneList</kbd> class-based view. The method executed in the generic view will use the new settings we added to enable the offset/limit pagination, and the result will provide us with the first four drone resources. However, the response body looks different than in the previous HTTP <kbd>GET</kbd> requests we made to any resource collection. The following lines show the sample response that we will analyze in detail. Don't forget that the drones are being sorted by the name field, in ascending order:</p>
<pre>    <strong>HTTP/1.0 200 OK</strong>
    <strong>Allow: GET, POST, HEAD, OPTIONS</strong>
    <strong>Content-Length: 958</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Mon, 06 Nov 2017 23:08:36 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>Vary: Accept, Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "count": 11, </strong>
    <strong>    "next": "http://localhost:8000/drones/?limit=4&amp;offset=4", </strong>
    <strong>    "previous": null, </strong>
    <strong>    "results": [</strong>
    <strong>        {</strong>
    <strong>            "drone_category": "Quadcopter", </strong>
    <strong>            "has_it_competed": false, </strong>
    <strong>            "inserted_timestamp": "2017-11-03T01:59:31.108031Z", </strong>
    <strong>            "manufacturing_date": "2017-08-18T02:02:00.716312Z", </strong>
    <strong>            "name": "Atom", </strong>
    <strong>            "url": "http://localhost:8000/drones/2"</strong>
    <strong>        }, </strong>
    <strong>        {</strong>
    <strong>            "drone_category": "Octocopter", </strong>
    <strong>            "has_it_competed": false, </strong>
    <strong>            "inserted_timestamp": "2017-11-06T20:25:30.357127Z", </strong>
    <strong>            "manufacturing_date": "2017-04-18T02:02:00.716312Z", </strong>
    <strong>            "name": "Dassault Falcon 7X", </strong>
    <strong>            "url": "http://localhost:8000/drones/6"</strong>
    <strong>        }, </strong>
    <strong>        {</strong>
    <strong>            "drone_category": "Quadcopter", </strong>
    <strong>            "has_it_competed": false, </strong>
    <strong>            "inserted_timestamp": "2017-11-06T20:25:31.049833Z", </strong>
    <strong>            "manufacturing_date": "2017-07-20T02:02:00.716312Z", </strong>
    <strong>            "name": "Dusty", </strong>
    <strong>            "url": "http://localhost:8000/drones/9"</strong>
    <strong>        }, </strong>
    <strong>        {</strong>
    <strong>            "drone_category": "Octocopter", </strong>
    <strong>            "has_it_competed": false, </strong>
    <strong>            "inserted_timestamp": "2017-11-06T20:25:29.909965Z", </strong>
    <strong>            "manufacturing_date": "2017-02-18T02:02:00.716312Z", </strong>
    <strong>            "name": "Eclipse", </strong>
    <strong>            "url": "http://localhost:8000/drones/4"</strong>
    <strong>        }</strong>
    <strong>    ]</strong>
    <strong>}</strong></pre>
<p>The response has a <kbd>200 OK</kbd> status code in the header and the following keys in the response body:</p>
<ul>
<li><kbd>count</kbd>: The value indicates the total number of drones for the query.</li>
<li><kbd>next</kbd>: The value provides a link to the next page.</li>
<li><kbd>previous</kbd>: The value provides a link to the previous page. In this case, the response includes the first page of the result set, and therefore, the link to the previous page is <kbd>null</kbd>.</li>
<li><kbd>results</kbd>: The value provides an array of JSON representations of <kbd>Drone</kbd> instances that compose the requested page. In this case, the four drones belong to the first page of the result set.</li>
</ul>
<p>In the previous HTTP <kbd>GET</kbd> request, we didn't specify any values for either the <kbd>limit</kbd> or <kbd>offset</kbd> parameters. We specified <kbd>4</kbd> as the default value for the <kbd>limit</kbd> parameter in the global settings and the generic views use this configuration value and provide us with the first page. Whenever we don't specify any <kbd>offset</kbd> value, the default <kbd>offset</kbd> is equal to <kbd>0</kbd> and the <kbd>get</kbd> method will return the first page.</p>
<p>The previous request is equivalent to the following HTTP <kbd>GET</kbd> request that specifies <kbd>0</kbd> for the <kbd>offset</kbd> value. The result of the next command will be the same as the previous one:</p>
<pre>    <strong>http GET ":8000/drones/?offset=0"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl -iX GET "localhost:8000/drones/?offset=0"</strong></pre>
<p>The previous requests are equivalent to the following HTTP <kbd>GET</kbd> request that specifies <kbd>0</kbd> for the offset value and <kbd>4</kbd> for the limit value. The result of the next command will be the same as the previous two commands:</p>
<pre>    <strong>http GET ":8000/drones/?limit=4&amp;offset=0"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl -iX GET "localhost:8000/drones/?limit=4&amp;offset=0"</strong>
  </pre>
<p>Now, we will compose and send an HTTP request to retrieve the next page, that is, the second page for the drones. We will use the value for the <kbd>next</kbd> key provided in the JSON body of the response from the previous requests. This value gives us the URL for the next page: <kbd>http://localhost:8000/drones/?limit=4&amp;offset=4</kbd>. Thus, we will compose and send an HTTP <kbd>GET</kbd> method to <kbd>/drones/</kbd> with the limit value set to <kbd>4</kbd> and the <kbd>offset</kbd> value set to <kbd>4</kbd> :</p>
<pre>    <strong>http GET ":8000/drones/?limit=4&amp;offset=4"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl -iX GET "localhost:8000/drones/?limit=4&amp;offset=4"</strong></pre>
<p>The result will provide us the second page of four drone resources as the value for the <kbd>results</kbd> key in the response body. In addition, we will see the values for the <kbd>count</kbd>, <kbd>previous</kbd>, and <kbd>next</kbd> keys that we analyzed in the previous requests. The following lines show the sample response:</p>
<pre><strong>HTTP/1.0 200 OK</strong><br/><strong>Allow: GET, POST, HEAD, OPTIONS</strong><br/><strong>Content-Length: 1007</strong><br/><strong>Content-Type: application/json</strong><br/><strong>Date: Mon, 06 Nov 2017 23:31:34 GMT</strong><br/><strong>Server: WSGIServer/0.2 CPython/3.6.2</strong><br/><strong>Vary: Accept, Cookie</strong><br/><strong>X-Frame-Options: SAMEORIGIN</strong><br/><br/><strong>{</strong><br/><strong>    "count": 11,</strong><br/><strong>    "next": "http://localhost:8000/drones/?limit=4&amp;offset=8",</strong><br/><strong>    "previous": "http://localhost:8000/drones/?limit=4",</strong><br/><strong>    "results": [</strong><br/><strong>        {</strong><br/><strong>            "drone_category": "Quadcopter",</strong><br/><strong>            "has_it_competed": false,</strong><br/><strong>            "inserted_timestamp": "2017-11-06T20:25:30.127661Z",</strong><br/><strong>            "manufacturing_date": "2017-03-20T02:02:00.716312Z",</strong><br/><strong>            "name": "Gossamer Albatross",</strong><br/><strong>            "url": "http://localhost:8000/drones/5"</strong><br/><strong>        },</strong><br/><strong>        {</strong><br/><strong>            "drone_category": "Quadcopter",</strong><br/><strong>            "has_it_competed": false,</strong><br/><strong>            "inserted_timestamp": "2017-11-06T20:25:30.584031Z",</strong><br/><strong>            "manufacturing_date": "2017-05-20T02:02:00.716312Z",</strong><br/><strong>            "name": "Gulfstream I",</strong><br/><strong>            "url": "http://localhost:8000/drones/7"</strong><br/><strong>        },</strong><br/><strong>        {</strong><br/><strong>            "drone_category": "Quadcopter",</strong><br/><strong>            "has_it_competed": false,</strong><br/><strong>            "inserted_timestamp": "2017-11-06T20:25:29.636153Z",</strong><br/><strong>            "manufacturing_date": "2017-01-20T02:02:00.716312Z",</strong><br/><strong>            "name": "Need for Speed",</strong><br/><strong>            "url": "http://localhost:8000/drones/3"</strong><br/><strong>        },</strong><br/><strong>        {</strong><br/><strong>            "drone_category": "Octocopter",</strong><br/><strong>            "has_it_competed": false,</strong><br/><strong>            "inserted_timestamp": "2017-11-06T20:25:30.819695Z",</strong><br/><strong>            "manufacturing_date": "2017-06-18T02:02:00.716312Z",</strong><br/><strong>            "name": "RV-3",</strong><br/><strong>            "url": "http://localhost:8000/drones/8"</strong><br/><strong>        }</strong><br/><strong>    ]</strong><br/><strong>}</strong></pre>
<p>In this case, the result set is the second page, and therefore, we have a value for the <kbd>previous</kbd> key: <kbd>http://localhost:8000/drones/?limit=4</kbd>.</p>
<p>In the previous HTTP request, we specified values for both the <kbd>limit</kbd> and <kbd>offset</kbd> parameters. However, as we set the default value of <kbd>limit</kbd> to <kbd>4</kbd> in the global settings, the following request will produce the same results as the previous request:</p>
<pre>    <strong>http GET ":8000/drones/?offset=4"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl -iX GET "localhost:8000/drones/?offset=4"</strong></pre>
<p>Now, we will compose and send an HTTP request to retrieve the next page, that is, the third and last page for the drones. We will use the value for the <kbd>next</kbd> key provided in the JSON body of the response from the previous requests. This value gives us the URL for the next page as&#160;<kbd>http://localhost:8000/drones/?limit=4&amp;offset=8</kbd>. Thus, we will compose and send an HTTP <kbd>GET</kbd> method to <kbd>/drones/</kbd> with the limit value set to <kbd>4</kbd> and the <kbd>offset</kbd> value set to <kbd>8</kbd> :</p>
<pre>    <strong>http GET ":8000/drones/?limit=4&amp;offset=8"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl -iX GET "localhost:8000/drones/?limit=4&amp;offset=8"</strong></pre>
<p>The result will provide us with the third and last page of three drone resources as the value for the <kbd>results</kbd> key in the response body. In addition, we will see the values for the <kbd>count</kbd>, <kbd>previous</kbd>, and <kbd>next</kbd> keys that we analyzed in the previous requests. The following lines show the sample response:</p>
<pre>    <strong>HTTP/1.0 200 OK</strong>
    <strong>Allow: GET, POST, HEAD, OPTIONS</strong>
    <strong>Content-Length: 747</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Tue, 07 Nov 2017 02:59:42 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>Vary: Accept, Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "count": 11, </strong>
    <strong>    "next": null, </strong>
    <strong>    "previous": "http://localhost:8000/drones/?limit=4&amp;offset=4", </strong>
    <strong>    "results": [</strong>
    <strong>        {</strong>
    <strong>            "drone_category": "Octocopter", </strong>
    <strong>            "has_it_competed": false, </strong>
    <strong>            "inserted_timestamp": "2017-11-06T20:25:31.279172Z", </strong>
    <strong>            "manufacturing_date": "2017-08-18T02:02:00.716312Z", </strong>
    <strong>            "name": "Ripslinger", </strong>
    <strong>            "url": "http://localhost:8000/drones/10"</strong>
    <strong>        }, </strong>
    <strong>        {</strong>
    <strong>            "drone_category": "Quadcopter", </strong>
    <strong>            "has_it_competed": false, </strong>
    <strong>            "inserted_timestamp": "2017-11-06T20:25:31.511881Z", </strong>
    <strong>            "manufacturing_date": "2017-09-20T02:02:00.716312Z", </strong>
    <strong>            "name": "Skipper", </strong>
    <strong>            "url": "http://localhost:8000/drones/11"</strong>
    <strong>        }, </strong>
    <strong>        {</strong>
    <strong>            "drone_category": "Quadcopter", </strong>
    <strong>            "has_it_competed": false, </strong>
    <strong>            "inserted_timestamp": "2017-11-03T01:58:49.135737Z", </strong>
    <strong>            "manufacturing_date": "2017-07-20T02:02:00.716312Z", </strong>
    <strong>            "name": "WonderDrone", </strong>
    <strong>            "url": "http://localhost:8000/drones/1"</strong>
    <strong>        }</strong>
    <strong>    ]</strong>
    <strong>}</strong>  </pre>
<p>In this case, the result set is the last page, and therefore, we have <kbd>null</kbd> as the value for the <kbd>next</kbd> key.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with customized pagination classes</h1>
                </header>
            
            <article>
                
<p>We enabled pagination to limit the size for the result sets. However, any client or user is able to specify a large number for the <kbd>limit</kbd> value, such as <kbd>10000</kbd>, and generate a huge result set. In order to specify the maximum number that is accepted for the limit query parameter, it is necessary to create a customized version of the limit/offset pagination scheme that the Django REST framework provides us.</p>
<p>We made changes to the global configuration to use the <kbd>rest_framework.pagination.LimitOffsetPagination</kbd> class to handle paginated responses. This class declares a <kbd>max_limit</kbd> class attribute whose default value is equal to <kbd>None</kbd>, which means there is no upper bound for the <kbd>limit</kbd> value. We will indicate the upper bound value for the limit query parameter in the <kbd>max_limit</kbd> class attribute.</p>
<p>Make sure you quit Django's development server. Remember that you just need to press <em><span class="KeyPACKT">Ctrl</span></em> + <em><span class="KeyPACKT">C</span></em> in the terminal or Command Prompt in which it is running.</p>
<p>Go to the <kbd>restful01/drones</kbd> folder and create a new file named <kbd>custompagination.py</kbd>. Write the following code in this new file. The following lines show the code for this file that declares the new <kbd>LimitOffsetPaginationWithUpperBound</kbd> class. The code file for the sample is included in the <kbd>hillar_django_restful_07_02</kbd> folder in the <kbd>restful01/drones/custompagination.py</kbd> file:</p>
<pre>from rest_framework.pagination import LimitOffsetPagination 
<span>class LimitOffsetPaginationWithUpperBound(LimitOffsetPagination):</span>
    # Set the maximum limit value to 8 
       max_limit = 8</pre>
<p>The previous lines declare the <kbd>LimitOffsetPaginationWithUpperBound</kbd> class as a subclass of&#160;&#160;<kbd>rest_framework.pagination.LimitOffsetPagination</kbd>. This new class overrides the value assigned to the <kbd>max_limit</kbd> class attribute with <kbd>8</kbd>.</p>
<p>Open the <kbd>restful01/restful01/settings.py</kbd> file and replace the line that specifies the value for the <kbd>DEFAULT_PAGINATION_CLASS</kbd> key in the <kbd>REST_FRAMEWORK</kbd> dictionary with the highlighted line. The following lines show the new declaration of the <kbd>REST_FRAMEWORK</kbd> dictionary. The code file for the sample is included in the <kbd>hillar_django_restful_07_02</kbd> folder in the <kbd>restful01/restful01/settings.py</kbd> file:</p>
<pre> REST_FRAMEWORK = { 
    'DEFAULT_PAGINATION_CLASS': 
<strong>    'drones.custompagination.LimitOffsetPaginationWithUpperBound',</strong> 
    'PAGE_SIZE': 4 
 } </pre>
<p>This way, all the generic views will use the recently declared <kbd>drones.custompagination.LimitOffsetPaginationWithUpperBound</kbd> class that provides the limit/offset pagination scheme we have analyzed with an upper bound for the <kbd>limit</kbd> value equal to <kbd>8</kbd>.</p>
<p>If any request specifies a value higher than 8 for the limit, the class will use the maximum limit value, that is, <kbd>8</kbd>, and the RESTful Web Service will never return more than eight resources in a paginated response.</p>
<div class="packt_tip">It is a good practice to configure a maximum limit to avoid generating responses with huge amounts of data that might generate important loads to the server running the RESTful Web Service. Note that we will learn to limit the usage of the resources of our RESTful Web Service in the forthcoming chapters. Pagination is just the beginning of a long story.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making requests that use customized paginated results</h1>
                </header>
            
            <article>
                
<p>Launch Django's development server. If you don't remember how to start Django's development server, check the instructions in <a href="dj-rst-websvc_ch13.html" target="_blank">Chapter 3</a>,<em>&#160;Creating API Views</em>, in the <em>Launching Django's development server</em> section.</p>
<p>Now, we will compose and send an HTTP <kbd>GET</kbd> request to retrieve the first page for the drones with the value for the <kbd>limit</kbd> query parameter set to <kbd>500</kbd>. This value is higher than the maximum limit we established:</p>
<pre>    <strong>http GET ":8000/drones/?limit=500"</strong>  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl -iX GET "localhost:8000/drones/?limit=500"</strong></pre>
<p>The code in the <kbd>get</kbd> method for the <kbd>views.DroneList</kbd> class-based view will use the new settings we added to enable the customized offset/limit pagination, and the result will provide us with the first eight drone resources because the maximum value for the limit query is set to <kbd>8</kbd>. The value specified for the <kbd>limit</kbd> query parameter is greater than <kbd>8</kbd>, and therefore, the maximum value of <kbd>8</kbd> is used, instead of the value indicated in the request.</p>
<div class="packt_tip">The key advantage of working with generic views is that we can easily customize the behavior for the methods defined in the mixins that compose these views with just a few lines of code. In this case, we took advantage of the pagination features available in the Django REST framework to specify how we wanted large results sets to be split into individual pages of data. Then, we customized paginated results with just a few lines of code to make the limit/offset pagination scheme match our specific requirements.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring filter backend classes</h1>
                </header>
            
            <article>
                
<p>So far, we have been working with the entire queryset as the result set. For example, whenever we requested the drones resource collection, the RESTful Web Service worked with the entire resource collection and used the default sorting we had configured in the model. Now, we want our RESTful Web Service to be able to provide filtering, searching, and sorting features.</p>
<p>It is very important to understand that we have to be careful with the fields we configure to be available in the filtering, searching, and ordering features. The configuration will have an impact on the queries executed on the database, and therefore, we must make sure that we have the appropriate database optimizations, considering the queries that will be executed. Specific database optimizations are outside of the scope of this book, but you definitely must take them into account when you configure these features.</p>
<p>Make sure you quit Django's development server. Remember that you just need to press <em><span class="KeyPACKT">Ctrl</span></em> + <em><span class="KeyPACKT">C</span></em> in the terminal or Command Prompt window in which it is running.</p>
<p>Run the following command to install the <kbd>django-filter</kbd> package in our virtual environment. This package will enable us to use many field filtering features that we can easily customize in the Django REST framework. Make sure the virtual environment is activated, and run the following command:</p>
<pre>    <strong>pip install django-filter</strong></pre>
<p>The last lines of the output will indicate that the <kbd>django-filter</kbd> package has been successfully installed:</p>
<pre>     <strong>Collecting django-filter</strong>
    <strong> Downloading django_filter-1.1.0-py2.py3-none-any.whl</strong>
     <strong>Installing collected packages: django-filter</strong>
     <strong>Successfully installed django-filter-1.1.0</strong></pre>
<p>We will work with the following three classes:</p>
<ul>
<li><kbd>rest_framework.filters.OrderingFilter</kbd>: This class allows the client to control how the results are ordered with a single query parameter. We can specify which fields may be ordered against.</li>
<li><kbd>django_filters.rest_framework.DjangoFilterBackend</kbd>: This class provides field filtering capabilities. We can specify the set of fields we want to be able to filter against, and the filter backend defined in the <kbd>django-filter</kbd> package will create a new <kbd>django_filters.rest_framework.FilterSet</kbd> class and associate it to the class-based view. It is also possible to create our own <kbd>rest_framework.filters.FilterSet</kbd> class, with more customized settings, and write our own code to associate it with the class-based view.</li>
<li><kbd>rest_framework.filters.SearchFilter</kbd>: This class provides single query parameter-based searching capabilities, and its behavior is based on the Django admin's search function. We can specify the set of fields we want to include for the search feature and the client will be able to filter items by making queries that search on these fields with a single query. It is useful when we want to make it possible for a request to search on multiple fields with a single query.</li>
</ul>
<p>It is possible to configure the filter backends by including any of the previously enumerated classes in a tuple and assigning it to the <kbd>filter_backends</kbd> class attribute for the generic view classes. In our RESTful Web Service, we want all our class-based views to use the same filter backends, and therefore, we will make changes in the global configuration.</p>
<p>Open the <kbd>restful01/restful01/settings.py</kbd> file that declares module-level variables that define the configuration of Django for the <kbd>restful01</kbd> project. We will make some changes to this Django settings file. Add the highlighted lines that declare the <kbd>'DEFAULT_FILTER_BACKENDS'</kbd> key and assign a tuple of strings as its value with the three classes we have analyzed. The following lines show the new declaration of the <kbd>REST_FRAMEWORK</kbd> dictionary. The code file for the sample is included in the <kbd>hillar_django_restful_07_03</kbd> folder in the <kbd>restful01/restful01/settings.py</kbd> file:</p>
<pre>  REST_FRAMEWORK = { 
    'DEFAULT_PAGINATION_CLASS': 
    'drones.custompagination.LimitOffsetPaginationWithUpperBound', 
    'PAGE_SIZE': 4, 
<strong>    'DEFAULT_FILTER_BACKENDS': (
        'django_filters.rest_framework.DjangoFilterBackend', 
        'rest_framework.filters.OrderingFilter', 
        'rest_framework.filters.SearchFilter', 
        ), 
</strong>  } </pre>
<p>Locate the lines that assign a string list to <kbd>INSTALLED_APPS</kbd> to declare the installed apps. Add the following string to the <kbd>INSTALLED_APPS</kbd> string list and save the changes to the <kbd>settings.py</kbd> file:</p>
<pre>  'django_filters',</pre>
<p>The following lines show the new code that declares the <kbd>INSTALLED_APPS</kbd> string list with the added line highlighted and with comments to understand what each added string means. The code file for the sample is included in the <kbd>hillar_django_restful_07_03</kbd> folder in the <kbd>restful01/restful01/settings.py</kbd> file:</p>
<pre>  INSTALLED_APPS = [ 
     'django.contrib.admin', 
     'django.contrib.auth', 
     'django.contrib.contenttypes', 
     'django.contrib.sessions', 
     'django.contrib.messages', 
     'django.contrib.staticfiles', 
     # Django REST Framework 
     'rest_framework', 
     # Drones application 
     'drones.apps.DronesConfig', 
     # Django Filters, 
<strong>     'django_filters', 
</strong> ]</pre>
<p>This way, we have added the <kbd>django_filters</kbd> application to our Django project named <kbd>restful01</kbd>.</p>
<p>The default query parameter names are <kbd>search</kbd> for the search feature and <kbd>ordering</kbd> for the ordering feature. We can specify other names by setting the desired strings in the <kbd>SEARCH_PARAM</kbd> and the <kbd>ORDERING_PARAM</kbd> settings. In this case, we will work with the default values.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding filtering, searching, and ordering</h1>
                </header>
            
            <article>
                
<p>Now, we will add the necessary code to configure the fields that we want to be included in the filtering, searching, and ordering features for each of the class-based views that retrieve the contents of each resource collection. Hence, we will make changes to all the classes with the <kbd>List</kbd> suffix in the <kbd>views.py</kbd> file: <kbd>DroneCategoryList</kbd>, <kbd>DroneList</kbd>, <kbd>PilotList</kbd>, and <kbd>CompetitionList</kbd>.</p>
<p>We will declare the following three class attributes in each of those classes:</p>
<ul>
<li><kbd>filter_fields</kbd>: This attribute specifies a tuple of strings whose values indicate the field names that we want to be able to filter against. Under the hood, the Django REST framework will automatically create a <kbd>rest_framework.filters.FilterSet</kbd> class and associate it to the class-based view in which we are declaring the attribute. We will be able to filter against the field names included in the tuple of strings.</li>
<li><kbd>search_fields</kbd>: This attribute specifies a tuple of strings whose values indicate the text type field names that we want to include in the search feature. In all the usages, we will want to perform a starts-with match. In order to do this, we will include <kbd>'^'</kbd> as a prefix of the field name to indicate that we want to restrict the search behavior to a starts-with match.</li>
<li><kbd>ordering_fields</kbd>: This attribute specifies a tuple of strings whose values indicate the field names that the HTTP request can specify to sort the results. If the request doesn't specify a field for ordering, the response will use the default ordering fields specified in the model that is related to the class-based view.</li>
</ul>
<p>Open the <kbd>restful01/drones/views.py</kbd> file. Add the following code after the last line that declares the imports, before the declaration of the <kbd>DroneCategoryList</kbd> class. The code file for the sample is included in the <kbd>hillar_django_restful_07_03</kbd> folder in the <kbd>restful01/drones/views.py</kbd> file:</p>
<pre>from rest_framework import filters 
from django_filters import AllValuesFilter, DateTimeFilter, NumberFilter </pre>
<p>Add the following highlighted lines to the <kbd>DroneList</kbd> class declared in the <kbd>views.py</kbd> file. The next lines show the new code that defines the class. The code file for the sample is included in the <kbd>hillar_django_restful_07_03</kbd> folder in the <kbd>restful01/drones/views.py</kbd> file:</p>
<pre>class DroneCategoryList(generics.ListCreateAPIView): 
    queryset = DroneCategory.objects.all() 
    serializer_class = DroneCategorySerializer 
    name = 'dronecategory-list' 
<strong>    filter_fields = ( 
        'name', 
        ) 
    search_fields = ( 
        '^name', 
        ) 
    ordering_fields = ( 
        'name', 
        )</strong> </pre>
<p>The changes in the <kbd>DroneList</kbd> class are easy to understand. We will be able to filter, search, and order by the <kbd>name</kbd> field.</p>
<p>Add the following highlighted lines to the <kbd>DroneList</kbd> class declared in the <kbd>views.py</kbd> file. The next lines show the new code that defines the class. The code file for the sample is included in the <kbd>hillar_django_restful_07_03</kbd> folder in the <kbd>restful01/drones/views.py</kbd> file:</p>
<pre>class DroneList(generics.ListCreateAPIView): 
    queryset = Drone.objects.all() 
    serializer_class = DroneSerializer 
    name = 'drone-list' 
<strong>    filter_fields = ( 
        'name',  
        'drone_category',  
        'manufacturing_date',  
        'has_it_competed',  
        ) 
    search_fields = ( 
        '^name', 
        ) 
    ordering_fields = ( 
        'name', 
        'manufacturing_date', 
        )</strong> </pre>
<p>In the <kbd>DroneList</kbd> class, we specified many field names in the <kbd>filter_fields</kbd> attribute. We included <kbd>'drone_category'</kbd> in the string tuple, and therefore, we will be able to include the ID values for this field in the filter.</p>
<div class="packt_tip">We will take advantage of other options for related models that will allow us to filter by fields of the related model later. This way, we will understand the different customizations available.</div>
<p>The <kbd>ordering_fields</kbd> attribute specifies two field names for the tuple of strings, and therefore, we will be able to order the results by either <kbd>name</kbd> or <kbd>manufacturing_date</kbd>. Don't forget that we must take into account database optimizations when enabling fields to order by.</p>
<p>Add the following highlighted lines to the <kbd>PilotList</kbd> class declared in the <kbd>views.py</kbd> file. The next lines show the new code that defines the class. The code file for the sample is included in the <kbd>hillar_django_restful_07_03</kbd> folder in the <kbd>restful01/drones/views.py</kbd> file:</p>
<pre>class PilotList(generics.ListCreateAPIView): 
    queryset = Pilot.objects.all() 
    serializer_class = PilotSerializer 
    name = 'pilot-list' 
<strong>    filter_fields = ( 
        'name',  
        'gender', 
        'races_count', 
        ) 
    search_fields = ( 
        '^name', 
        ) 
    ordering_fields = ( 
        'name', 
        'races_count' 
        )</strong></pre>
<p>The <kbd>ordering_fields</kbd> attribute specifies two field names for the tuple of strings, and therefore, we will be able to order the results by either <kbd>name</kbd> or <kbd>races_count</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with different types of Django filters</h1>
                </header>
            
            <article>
                
<p>Now, we will create a customized filter that we will apply to the <kbd>Competition</kbd> model. We will code the new <kbd>CompetitionFilter</kbd> class, specifically, a subclass of the <kbd>rest_framework.filters.FilterSet</kbd> class.</p>
<p>Open the <kbd>restful01/drones/views.py</kbd> file. Add the following code before the declaration of the <kbd>CompetitionList</kbd> class. The code file for the sample is included in the <kbd>hillar_django_restful_07_03</kbd> folder in the <kbd>restful01/drones/views.py</kbd> file:</p>
<pre>class CompetitionFilter(filters.FilterSet): 
    from_achievement_date = DateTimeFilter( 
        name='distance_achievement_date', lookup_expr='gte') 
    to_achievement_date = DateTimeFilter( 
        name='distance_achievement_date', lookup_expr='lte') 
    min_distance_in_feet = NumberFilter( 
        name='distance_in_feet', lookup_expr='gte') 
    max_distance_in_feet = NumberFilter( 
        name='distance_in_feet', lookup_expr='lte') 
    drone_name = AllValuesFilter( 
        name='drone__name') 
    pilot_name = AllValuesFilter( 
        name='pilot__name') 
 
    class Meta: 
        model = Competition 
        fields = ( 
            'distance_in_feet', 
            'from_achievement_date', 
            'to_achievement_date', 
            'min_distance_in_feet', 
            'max_distance_in_feet', 
            # drone__name will be accessed as drone_name 
            'drone_name', 
            # pilot__name will be accessed as pilot_name 
            'pilot_name', 
            )</pre>
<p>The <kbd>CompetitionFilter</kbd> class declares the following class attributes:</p>
<ul>
<li><kbd>from_achievement_date</kbd>: This attribute is a <kbd>django_filters.DateTimeFilter</kbd> instance that allows the request to filter the competitions whose <kbd>achievement_date</kbd> DateTime value is greater than or equal to the specified DateTime value. The value specified in the <kbd>name</kbd> argument indicates the field to which the DateTime filter is applied, <kbd>'distance_achievement_date'</kbd>, and the value for the <kbd>lookup_expr</kbd> argument indicates the lookup expression, <kbd>'gte'</kbd>, which means greater than or equal to.</li>
<li><kbd>to_achievement_date</kbd>: This attribute is a <kbd>django_filters.DateTimeFilter</kbd> instance that allows the request to filter the competitions whose <kbd>achievement_date</kbd> DateTime value is less than or equal to the specified DateTime value. The value specified in the <kbd>name</kbd> argument indicates the field to which the DateTime filter is applied, <kbd>'distance_achivement_date'</kbd>, and the value for the <kbd>lookup_expr</kbd> argument indicates the lookup expression, <kbd>'lte'</kbd>, which means less than or equal to.</li>
<li><kbd>min_distance_in_feet</kbd>: This attribute is a <kbd>django_filters.NumberFilter</kbd> instance that allows the request to filter the competitions whose <kbd>distance_in_feet</kbd> numeric value is greater than or equal to the specified number. The value for the <kbd>name</kbd> argument indicates the field to which the numeric filter is applied, <kbd>'distance_in_feet'</kbd>, and the value for the <kbd>lookup_expr</kbd> argument indicates the lookup expression, <kbd>'gte'</kbd>, which means greater than or equal to.</li>
<li><kbd>max_distance_in_feet</kbd>: This attribute is a <kbd>django_filters.NumberFilter</kbd> instance that allows the request to filter the competitions whose <kbd>distance_in_feet</kbd> numeric value is less than or equal to the specified number. The value for the <kbd>name</kbd> argument indicates the field to which the numeric filter is applied, <kbd>'distance_in_feet'</kbd>, and the value for the <kbd>lookup_expr</kbd> argument indicates the lookup expression, <kbd>'lte'</kbd>, which means less than or equal to.</li>
<li><kbd>drone_name</kbd>: This attribute is a <kbd>django_filters.AllValuesFilter</kbd> instance that allows the request to filter the competitions whose drones' names match the specified string value. The value for the <kbd>name</kbd> argument indicates the field to which the filter is applied, <kbd>'drone__name'</kbd>. Notice that there is a double underscore (<kbd>__</kbd>) between <kbd>drone</kbd> and <kbd>name</kbd>, and you can read it as the <kbd>name</kbd> field for the <kbd>drone</kbd> model or simply replace the double underscore with a dot and read <kbd>drone.name</kbd>. The name uses Django's double underscore syntax. However, we don't want the request to use <kbd>drone__name</kbd> to specify the filter for the drone's name. Hence, the instance is stored in the class attribute named <kbd>drone_name</kbd>, with just a single underscore between <kbd>player</kbd> and <kbd>name</kbd>, to make it more user-friendly. We will make configurations to make the browsable API display a drop-down with all the possible values for the drone's name to use as a filter. The drop-down will only include the drones' names that have registered competitions.</li>
<li><kbd>pilot_name</kbd>: This attribute is a <kbd>django_filters.AllValuesFilter</kbd> instance that allows the request to filter the competitions whose pilots' names match the specified string value. The value for the <kbd>name</kbd> argument indicates the field to which the filter is applied, <kbd>'pilot__name'</kbd>. The name uses Django's double underscore syntax. As happened with <kbd>drone_name</kbd>, we don't want the request to use <kbd>pilot__name</kbd> to specify the filter for the pilot's name, and therefore, we stored the instance in the class attribute named <kbd>pilot_name</kbd>, with just a single underscore between <kbd>pilot</kbd> and <kbd>name</kbd>. The browsable API will display a drop-down with all the possible values for the pilot's name to use as a filter. The drop-down will only include the pilots' names that have registered competitions because we used the <kbd>AllValuesFilter</kbd> class.</li>
</ul>
<p>The <kbd>CompetitionFilter</kbd> class defines a <kbd>Meta</kbd> inner class that declares the following two attributes:</p>
<ul>
<li><kbd>model</kbd>: This attribute specifies the model related to the filter set, that is, the <kbd>Competition</kbd> class.</li>
<li><kbd>fields</kbd>: This attribute specifies a tuple of strings whose values indicate the field names and filter names that we want to include in the filters for the related model. We included <kbd>'distance_in_feet'</kbd> and the names for all the previously explained filters. The string <kbd>'distance_in_feet'</kbd> refers to the field with this name. We want to apply the default numeric filter that will be built under the hood to allow the request to filter by an exact match on the <kbd>distance_in_feet</kbd> field. This way, the request will have plenty of options to filter competitions.</li>
</ul>
<p>Now, add the following highlighted lines to the <kbd>CompetitionList</kbd> class declared in the <kbd>views.py</kbd> file. The next lines show the new code that defines the class. The code file for the sample is included in the <kbd>hillar_django_restful_07_03</kbd> folder in the <kbd>restful01/drones/views.py</kbd> file:</p>
<pre>  class CompetitionList(generics.ListCreateAPIView): 
    queryset = Competition.objects.all() 
    serializer_class = PilotCompetitionSerializer 
    name = 'competition-list' 
<strong>    filter_class = CompetitionFilter 
    ordering_fields = ( 
        'distance_in_feet', 
        'distance_achievement_date', 
        )</strong> </pre>
<p>The <kbd>filter_class</kbd> attribute specifies <kbd>CompetitionFilter</kbd> as its value, that is, the <kbd>FilterSet</kbd> subclass that declares the customized filters that we want to use for this class-based view. In this case, the code didn't specify a tuple of strings for the <kbd>filter_class</kbd> attribute because we have defined our own <kbd>FilterSet</kbd> subclass.</p>
<p>The <kbd>ordering_fields</kbd> tuple of strings specifies the two field names that the request will be able to use for ordering the competitions.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making requests that filter results</h1>
                </header>
            
            <article>
                
<p>Now we can launch Django's development server to compose and send HTTP requests to understand how to use the previously coded filters. Execute any of the following two commands, based on your needs, to access the API in other devices or computers connected to your LAN. Remember that we analyzed the difference between them in <a href="dj-rst-websvc_ch13.html" target="_blank">Chapter 3</a>,&#160;<em>Creating API Views</em>, in the <em>Launching Django's development server</em> section:</p>
<pre>    <strong>python manage.py runserver</strong>
    <strong>python manage.py runserver 0.0.0.0:8000</strong></pre>
<p>After we run any of the previous commands, the development server will start listening at port <kbd>8000</kbd>.</p>
<p>Now, we will compose and send an HTTP request to retrieve all the drone categories whose <kbd>name</kbd> is equal to <kbd>Quadcopter</kbd>, as shown below:</p>
<pre>    <strong>http ":8000/drone-categories/?name=Quadcopter"</strong>  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl -iX GET "localhost:8000/drone-categories/?name=Quadcopter"</strong>  </pre>
<p>The following lines show a sample response with the single drone category whose <kbd>name</kbd> matches the specified <kbd>name</kbd> string in the filter and the list of hyperlinks for the drones that belong to the category. The following lines show the JSON response body without the headers. Notice that the results are paginated:</p>
<pre>    <strong>{</strong>
    <strong>    "count": 1, </strong>
    <strong>    "next": null, </strong>
    <strong>    "previous": null, </strong>
    <strong>    "results": [</strong>
    <strong>        {</strong>
    <strong>            "drones": [</strong>
    <strong>                "http://localhost:8000/drones/2", </strong>
    <strong>                "http://localhost:8000/drones/9", </strong>
    <strong>                "http://localhost:8000/drones/5", </strong>
    <strong>                "http://localhost:8000/drones/7", </strong>
    <strong>                "http://localhost:8000/drones/3", </strong>
    <strong>                "http://localhost:8000/drones/11", </strong>
    <strong>                "http://localhost:8000/drones/1"</strong>
    <strong>            ], </strong>
    <strong>            "name": "Quadcopter", </strong>
    <strong>            "pk": 1, </strong>
    <strong>            "url": "http://localhost:8000/drone-categories/1"</strong>
    <strong>        }</strong>
    <strong>    ]</strong>
    <strong>}</strong>  </pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Composing requests that filter and order results</h1>
                </header>
            
            <article>
                
<p>We will compose and send an HTTP request to retrieve all the drones whose related drone category ID is equal to <kbd>1</kbd> and whose value for the <kbd>has_it_competed</kbd> field is equal to <kbd>False</kbd>. The results must be sorted by <kbd>name</kbd> in descending order, and therefore, we specify <kbd>-name</kbd> as the value for the <kbd>ordering</kbd> query parameter.</p>
<div class="packt_tip">The hyphen (<kbd>-</kbd>) before the field name indicates that the ordering feature must use descending order instead of the default ascending order.</div>
<p>Make sure you replace <kbd>1</kbd> with the <kbd>pk</kbd> value of the previously retrieved drone category named <kbd>Quadcopter</kbd>. The <kbd>has_it_competed</kbd> field is a <kbd>bool</kbd> field, and therefore, we have to use Python valid bool values (<kbd>True</kbd> and <kbd>False</kbd>) when specifying the desired values for the bool field in the filter:</p>
<pre>    <strong>http ":8000/drones/?<br/>    drone_category=1&amp;has_it_competed=False&amp;ordering=-name"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl -iX GET "localhost:8000/drones/?<br/>    drone_category=1&amp;has_it_competed=False&amp;ordering=-name"</strong> </pre>
<p>The following lines show a sample response with the first four out of seven drones that match the specified criteria in the filter, sorted by name in descending order. Notice that the filters and the ordering have been combined with the previously configured pagination. The following lines show only the JSON response body, without the headers:</p>
<pre>    <strong>{</strong>
    <strong>    "count": 7, </strong>
    <strong>    "next": "http://localhost:8000/drones/? <br/>         <br/>     drone_category=1&amp;has_it_competed=False&amp;limit=4&amp;offset=4&amp;ordering=-<br/>     name", </strong>
    <strong>    "previous": null, </strong>
    <strong>    "results": [</strong>
    <strong>        {</strong>
    <strong>            "drone_category": "Quadcopter", </strong>
    <strong>            "has_it_competed": false, </strong>
    <strong>            "inserted_timestamp": "2017-11-03T01:58:49.135737Z", </strong>
    <strong>            "manufacturing_date": "2017-07-20T02:02:00.716312Z", </strong>
    <strong>            "name": "WonderDrone", </strong>
    <strong>            "url": "http://localhost:8000/drones/1"</strong>
    <strong>        }, </strong>
    <strong>        {</strong>
    <strong>            "drone_category": "Quadcopter", </strong>
    <strong>            "has_it_competed": false, </strong>
    <strong>            "inserted_timestamp": "2017-11-06T20:25:31.511881Z", </strong>
    <strong>            "manufacturing_date": "2017-09-20T02:02:00.716312Z", </strong>
    <strong>            "name": "Skipper", </strong>
    <strong>            "url": "http://localhost:8000/drones/11"</strong>
    <strong>        }, </strong>
    <strong>        {</strong>
    <strong>            "drone_category": "Quadcopter", </strong>
    <strong>            "has_it_competed": false, </strong>
    <strong>            "inserted_timestamp": "2017-11-06T20:25:29.636153Z", </strong>
    <strong>            "manufacturing_date": "2017-01-20T02:02:00.716312Z", </strong>
    <strong>            "name": "Need for Speed", </strong>
    <strong>            "url": "http://localhost:8000/drones/3"</strong>
    <strong>        }, </strong>
    <strong>        {</strong>
    <strong>            "drone_category": "Quadcopter", </strong>
    <strong>            "has_it_competed": false, </strong>
    <strong>            "inserted_timestamp": "2017-11-06T20:25:30.584031Z", </strong>
    <strong>            "manufacturing_date": "2017-05-20T02:02:00.716312Z", </strong>
    <strong>            "name": "Gulfstream I", </strong>
    <strong>            "url": "http://localhost:8000/drones/7"</strong>
    <strong>        }</strong>
    <strong>    ]</strong>
    <strong>}</strong></pre>
<div class="packt_tip">Notice that the response provides the value for the <kbd>next</kbd> key, <kbd>http://localhost:8000/drones/?drone_category=1&amp;has_it_competed=False&amp;limit=4&amp;offset=4&amp;ordering=-name</kbd>. This URL includes the combination of pagination, filtering, and ordering query parameters.</div>
<p>In the <kbd>DroneList</kbd> class, we included <kbd>'drone_category'</kbd> as one of the strings in the <kbd>filter_fields</kbd> tuple of strings. Hence, we had to use the drone category ID in the filter.</p>
<p>Now, we will use a filter on the drone's name related to a competition. As previously explained, our <kbd>CompetitionFilter</kbd> class provides us a filter to the name of the related drone in the <kbd>drone_name</kbd> query parameter.</p>
<p>We will combine the filter with another filter on the pilot's name related to a competition. Remember that the class also provides us a filter to the name of the related pilot in the <kbd>pilot_name</kbd> query parameter. We will specify two conditions in the criteria, and the filters are combined with the <kbd>AND</kbd> operator. Hence, both conditions must be met. The pilot's name must be equal to <kbd>'Penelope Pitstop'</kbd> and the drone's name must be equal to <kbd>'WonderDrone'</kbd>. The following command generates a request with the explained filter:</p>
<pre><strong>  http ":8000/competitions/?   <br/>  pilot_name=Penelope+Pitstop&amp;drone_name=WonderDrone"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre><strong>  curl -iX GET "localhost:8000/competitions/?  <br/>  pilot_name=Penelope+Pitstop&amp;drone_name=WonderDrone"</strong>
  </pre>
<p>The following lines show a sample response with the competition that matches the specified criteria in the filters. The following lines show only the JSON response body, without the headers:</p>
<pre><strong> { 
    "count": 1,  
    "next": null,  
    "previous": null,  
    "results": [ 
        { 
            "distance_achievement_date": "2017-10-21T06:02:23.776594Z",  
            "distance_in_feet": 2800,  
            "drone": "WonderDrone",  
            "pilot": "Penelope Pitstop",  
            "pk": 2,  
            "url": "http://localhost:8000/competitions/2" 
        } 
    ] 
 }</strong> </pre>
<p>Now, we will compose and send an HTTP request to retrieve all the competitions that match the following criteria. In addition, we want the results ordered by <kbd>distance_achievement_date</kbd>, in descending order:</p>
<ol>
<li>The <kbd>distance_achievement_date</kbd> is between <kbd>2017-10-18</kbd> and <kbd>2017-10-21</kbd></li>
<li>The <kbd>distance_in_feet</kbd> value is between <kbd>700</kbd> and <kbd>900</kbd></li>
</ol>
<p>The following command will do the job:</p>
<pre><strong>http ":8000/competitions/?  min_distance_in_feet=700&amp;max_distance_in_feet=9000&amp;from_achievement_date=2017-10-18&amp;to_achievement_date=2017-10-22&amp;ordering=-achievement_date"</strong>  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre><strong>curl -iX GET "localhost:8000/competitions/?min_distance_in_feet=700&amp;max_distance_in_feet=9000&amp;from_achievement_date=2017-10-18&amp;to_achievement_date=2017-10-22&amp;ordering=-achievement_date"</strong></pre>
<p>The previously analyzed <kbd>CompetitionFilter</kbd> class allowed us to create a request like the previous one, in which we take advantage of the customized filters. The following lines show a sample response with the two competitions that match the specified criteria in the filters. We overrode the default ordering specified in the model with the <kbd>ordering</kbd> field indicated in the request. The following lines show only the JSON body response, without the headers:</p>
<pre>    <strong>{</strong>
    <strong>    "count": 2, </strong>
    <strong>    "next": null, </strong>
    <strong>    "previous": null, </strong>
    <strong>    "results": [</strong>
    <strong>        {</strong>
    <strong>         "distance_achievement_date":<br/>             "2017-10-20T05:03:20.776594Z", </strong>
    <strong>            "distance_in_feet": 800, </strong>
    <strong>            "drone": "Atom", </strong>
    <strong>            "pilot": "Penelope Pitstop", </strong>
    <strong>            "pk": 1, </strong>
    <strong>            "url": "http://localhost:8000/competitions/1"</strong>
    <strong>        }, </strong>
    <strong>        {</strong>
    <strong>            "distance_achievement_date":<br/>                "2017-10-20T05:43:20.776594Z", </strong>
    <strong>            "distance_in_feet": 790, </strong>
    <strong>            "drone": "Atom", </strong>
    <strong>            "pilot": "Peter Perfect", </strong>
    <strong>            "pk": 3, </strong>
    <strong>            "url": "http://localhost:8000/competitions/3"</strong>
    <strong>        }</strong>
    <strong>    ]</strong>
    <strong>}</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making requests that perform starts with searches</h1>
                </header>
            
            <article>
                
<p>Now, we will take advantage of searches that are configured to check whether a value starts with the specified characters. We will compose and send an HTTP request to retrieve all the pilots whose <kbd>name</kbd> starts with <kbd>'G'</kbd>.</p>
<p>The next request uses the search feature that we configured to restrict the search behavior to a starts-with match on the <kbd>name</kbd> field for the <kbd>Drone</kbd> model:</p>
<pre>    <strong>http ":8000/drones/?search=G"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl -iX GET "localhost:8000/drones/?search=G"</strong></pre>
<p>The following lines show a sample response with the two drones that match the specified search criteria, that is, those drones whose <kbd>name</kbd> starts with <kbd>'G'</kbd>. The following lines show only the JSON response body, without the headers:</p>
<pre>    <strong>{</strong>
    <strong>    "count": 2, </strong>
    <strong>    "next": null, </strong>
    <strong>    "previous": null, </strong>
    <strong>    "results": [</strong>
    <strong>        {</strong>
    <strong>            "drone_category": "Quadcopter", </strong>
    <strong>            "has_it_competed": false, </strong>
    <strong>            "inserted_timestamp": "2017-11-06T20:25:30.127661Z", </strong>
    <strong>            "manufacturing_date": "2017-03-20T02:02:00.716312Z", </strong>
    <strong>            "name": "Gossamer Albatross", </strong>
    <strong>            "url": "http://localhost:8000/drones/5"</strong>
    <strong>        }, </strong>
    <strong>        {</strong>
    <strong>            "drone_category": "Quadcopter", </strong>
    <strong>            "has_it_competed": false, </strong>
    <strong>            "inserted_timestamp": "2017-11-06T20:25:30.584031Z", </strong>
    <strong>            "manufacturing_date": "2017-05-20T02:02:00.716312Z", </strong>
    <strong>            "name": "Gulfstream I", </strong>
    <strong>            "url": "http://localhost:8000/drones/7"</strong>
    <strong>        }</strong>
    <strong>    ]</strong>
    <strong>}</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using the browsable API to test pagination, filtering, searching, and ordering</h1>
                </header>
            
            <article>
                
<p>We enabled pagination and we added filtering, searching, and ordering features to our RESTful Web Service. All of these new features have an impact on how each web page is rendered when working with the browsable API.</p>
<p>We can work with a web browser to easily test pagination, filtering, searching, and ordering with a few clicks or taps.</p>
<p>Open a web browser and go to <kbd>http://localhost:8000/drones/</kbd>. Replace <kbd>localhost</kbd>&#160;with the IP of the computer that is running Django's development server if you use another computer or device to run the browser. The browsable API will compose and send a <kbd>GET</kbd> request to <kbd>/drones/</kbd> and will display the results of its execution, that is, the headers and the JSON drones list.</p>
<p>We have configured pagination, and therefore, the rendered web page will include the default pagination template associated with the base pagination class we are using and will display the available page numbers in the upper-right corner of the web page. The following screenshot shows the rendered web page after entering the URL in a web browser with the resource description, <span class="packt_screen">Drone List</span>, and the three pages generated with the limit/offset pagination scheme:</p>
<div class="CDPAlignCenter CDPAlign"><img height="411" width="423" src="images/474df671-756c-4855-8965-9a0e19565809.png"/></div>
<p>Now, go to <kbd>http://localhost:8000/competitions/</kbd>. The browsable API will compose and send a <kbd>GET</kbd> request to <kbd>/competitions/</kbd> and will display the results of its execution, that is, the headers and the JSON competitions list. The web page will include a <span class="packt_screen">Filters</span> button at the right-hand side of the resource description, <span class="packt_screen">Competition List</span>, and at the left-hand side of the <span class="packt_screen">OPTIONS</span> button.</p>
<p>Click or tap on <span class="packt_screen">Filters,</span> and the browsable API will render the <span class="packt_screen">Filter</span> model with the appropriate controls for each filter that you can apply below <span class="packt_screen">Field Filters</span>. In addition, the model will render the different ordering options below <span class="packt_screen">Ordering</span>. The following screenshot shows the <span class="packt_screen">Filters</span> model for the competitions:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="476" width="290" src="images/3b0c8dc5-1cb1-4db3-8ba1-34c40a5b0065.png"/></div>
<p>The <span class="packt_screen">Drone name</span> and <span class="packt_screen">Pilot name</span> drop-downs only provide the related drones' names and pilots' names that have participated in competitions because we used the <kbd>AllValuesFilter</kbd> class for both filters. We can easily enter all the values for each desired filter that we want to apply&#160;<span>and click or tap&#160;</span><span class="packt_screen">Submit</span><span>. Then, click on&#160;<span class="packt_screen">Filters</span>&#160;again,&#160;</span>select the ordering option, and click <span class="packt_screen">Submit</span>. The browsable API will compose and send the necessary HTTP request to apply the filters and ordering we have specified and it will render a web page with the first page of the results of the execution of the request.</p>
<p>The next screenshot shows the results of executing a request whose filters were composed with the previously explained model:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="285" width="568" src="images/8114b3f2-cb23-447b-bbf7-119af60badc9.png"/></div>
<p>The following are the parameters for the HTTP <kbd>GET</kbd> request. Notice that the browsable API generates the query parameters but doesn't specify values for the filters that were left without values in the previous modal. When the query parameters don't specify values, they are ignored:</p>
<pre>http://localhost:8000/competitions/?distance_in_feet=&amp;drone_name=Atom&amp;format=json&amp;from_achievement_date=&amp;max_distance_in_feet=&amp;min_distance_in_feet=85&amp;pilot_name=Penelope+Pitstop&amp;to_achievement_date= </pre>
<p>As happens whenever we have to test the different features included in our RESTful Web Service, the browsable API is also extremely helpful whenever we need to check filters and ordering.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test your knowledge</h1>
                </header>
            
            <article>
                
<p>Let's see whether you can answer the following questions correctly:</p>
<ol>
<li>The <kbd>django_filters.rest_framework.DjangoFilterBackend</kbd> class provides:
<ol>
<li>Control on how the results are ordered with a single query parameter</li>
<li>Single query parameter-based searching capabilities, based on the Django admin's search function</li>
<li>Field filtering capabilities</li>
</ol>
</li>
<li>The <kbd>rest_framework.filters.SearchFilter</kbd> class provides:
<ol>
<li>Control on how the results are ordered with a single query parameter</li>
<li>Single query parameter-based searching capabilities, based on the Django admin's search function</li>
<li>Field filtering capabilities</li>
</ol>
</li>
<li>If we want to create a unique constraint, what must be added to a <kbd>models.CharField</kbd> initializer&#160;<span>as one of the named arguments?</span>
<ol>
<li><kbd>unique=True</kbd></li>
<li><kbd>unique_constraint=True</kbd></li>
<li><kbd>force_unique=True</kbd></li>
</ol>
</li>
<li>Which of the following class attributes specifies a tuple of strings whose values indicate the field names that we want to be able to filter against in a class-based view that inherits from <kbd>generics.ListCreateAPIView</kbd>:
<ol>
<li><kbd>filters</kbd></li>
<li><kbd>filtering_fields</kbd></li>
<li><kbd>filter_fields</kbd></li>
</ol>
</li>
<li>Which of the following class attributes specifies a tuple of strings whose values indicate the field names that the HTTP request can specify to sort the results in a class-based view that inherits from <kbd>generics.ListCreateAPIView</kbd>:
<ol>
<li><kbd>order_by</kbd></li>
<li><kbd>ordering_fields</kbd></li>
<li><kbd>order_fields</kbd></li>
</ol>
</li>
</ol>
<p>&#160;</p>
<p><span>The rights answers are included in the <a href="https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&amp;action=edit#post_454" target="_blank">Appendix</a>,&#160;<em>Solutions</em>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we used the browsable API feature to navigate through the API with resources and relationships. We added unique constraints to improve consistency for the models in our RESTful Web Service.</p>
<p>We understood the importance of paginating results and we configured and tested a global limit/offset pagination scheme with the Django REST framework. Then, we created our own customized pagination class to make sure that requests weren't able to acquire a huge amount of elements in a single page.</p>
<p>We configured filter backend classes and we added code to the models to add filtering, searching, and ordering capabilities to the class-based views. We created a customized filter and we made requests to filter, search, and order results, and we understood how everything worked under the hood. Finally, we used the browsable API to test pagination, filtering, and ordering.</p>
<p>Now that we improved our RESTful Web Service with unique constraints, paginated results, fitering, searching, and ordering features, we will secure the API with authentication and permissions. We will cover these topics in the next chapter.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Securing the API with Authentication and Permissions</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will understand the difference between authentication and permissions in the Django REST framework. We will start securing our RESTful Web Service by adding requirements for authentication schemes and specifying permission policies. We will gain an understanding of:</p>
<ul>
<li>Understanding authentication and permissions in Django, the Django REST framework, and RESTful Web Services</li>
<li>Authentication classes</li>
<li>Security and permissions-related data to models</li>
<li>Working with object-level permissions via customized permission classes</li>
<li>Saving information about users that make requests</li>
<li>Setting permissions policies</li>
<li>Creating the superuser for Django</li>
<li>Creating a user for Django</li>
<li>Making authenticated requests</li>
<li>Browsing the secured API with the required authentication</li>
<li>Working with token-based authentication</li>
<li>Generating and using tokens</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding authentication and permissions in Django, the Django REST framework, and RESTful Web Services</h1>
                </header>
            
            <article>
                
<p>Right now, our sample RESTful Web Service processes all the incoming requests without requiring any kind of authentication, that is, any user can perform requests. The Django REST framework allows us to easily use diverse authentication schemes to identify a user that originated the request or a token that signed the request. Then, we can use these credentials to apply permission and throttling policies that will determine whether the request must be permitted or not.</p>
<p>We already know how configurations work with the Django REST framework. We can apply a global setting and override it if necessary in the appropriate class-based views. Hence, we can set the default authentication schemes in the global settings and override them whenever required for specific scenarios.</p>
<p>The settings allow us to declare a list of classes that specify the authentication schemes to be used for all the incoming HTTP requests. The Django REST framework will use all the specified classes in the list to authenticate a request, before running the appropriate method for the class-based view based on the request.</p>
<p>We can specify just one class. However, it is very important to understand the behavior in case we have to use more than one class. The first class in the list that generates a successful authentication will be responsible for setting the values for the following two attributes for the <kbd>request</kbd> object:</p>
<ul>
<li><kbd>user</kbd>: This attribute represents the user model instance. In our examples, we will work with an instance of the Django User class, specifically, the <kbd>django.contrib.auth.User</kbd> class.</li>
<li><kbd>auth</kbd>: This attribute provides additional authentication data required by the authentication scheme, such as an authentication token.</li>
</ul>
<p>After a successful authentication, we will be able to use the <kbd>request.user</kbd> attribute within the different methods in our class-based views that receive the <kbd>request</kbd> parameter. This way, we will be able to retrieve additional information about the <kbd>user</kbd> that generated the request.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Learning about the authentication classes</h1>
                </header>
            
            <article>
                
<p>The Django REST framework provides the following three authentication classes in the <kbd>rest_framework.authentication</kbd> module. All of them are subclasses of the <kbd>BaseAuthentication</kbd> class:</p>
<ul>
<li><kbd>BasicAuthentication</kbd>: This class provides an HTTP basic authentication against a username and a password.</li>
<li><kbd>SessionAuthentication</kbd>: This class works with Django's session framework for authentication.</li>
<li><kbd>TokenAuthentication</kbd>: This class provides a simple token-based authentication. The request must include the token generated for a user as the value for the <kbd>Authorization</kbd> HTTP header key with the <kbd>'Token '</kbd> string as a prefix for the token.</li>
</ul>
<div class="packt_tip">Of course, in a production environment, we must make sure that the RESTful Web Service is only available over HTTPS, with the usage of the latest TLS versions. We shouldn't use an HTTP basic authentication or a simple token-based authentication over plain HTTP in a production environment.</div>
<p>The previous classes are included in the Django REST framework out of the box. There are many additional authentication classes provided by many third-party libraries. We will work with some of these libraries later in this chapter.</p>
<p>Make sure you quit Django's development server. Remember that you just need to press <em><span class="KeyPACKT">Ctrl</span></em> + <em><span class="KeyPACKT">C</span></em> in the terminal or go to the Command Prompt window in which it is running. We have to edit the models and then execute migrations before starting Django's development server again.</p>
<p>We will make the necessary changes to combine HTTP basic authentication against a username and a password with Django's session framework for authentication. Hence, we will add the <kbd>BasicAuthentication</kbd> and <kbd>SessionAuthentication</kbd> classes in the global authentication classes list.</p>
<p>Open the <kbd>restful01/restful01/settings.py</kbd> file that declares the module-level variables that define the configuration of Django for the <kbd>restful01</kbd> project. We will make some changes to this Django settings file. Add the highlighted lines to the <kbd>REST_FRAMEWORK</kbd> dictionary. The following lines show the new declaration of the <kbd>REST_FRAMEWORK</kbd> dictionary. The code file for the sample is included in the <kbd>hillar_django_restful_08_01</kbd> folder in the <kbd>restful01/restful01/settings.py</kbd> file:</p>
<pre>REST_FRAMEWORK = { 
    'DEFAULT_PAGINATION_CLASS': 
    'drones.custompagination.LimitOffsetPaginationWithUpperBound', 
    'PAGE_SIZE': 4, 
    'DEFAULT_FILTER_BACKENDS': ( 
        'django_filters.rest_framework.DjangoFilterBackend', 
        'rest_framework.filters.OrderingFilter', 
        'rest_framework.filters.SearchFilter', 
        ), 
<strong>    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework.authentication.BasicAuthentication', 
        'rest_framework.authentication.SessionAuthentication', 
        )
</strong>} </pre>
<p>We added the <kbd>DEFAULT_AUTHENTICATION_CLASSES</kbd> settings key to the <kbd>REST_FRAMEWORK</kbd> dictionary. This new key specifies a global setting with a tuple of string whose values indicate the classes that we want to use for authentication: <kbd>BasicAuthentication</kbd> and <kbd>SessionAuthentication</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Including security and permissions-related data to models</h1>
                </header>
            
            <article>
                
<p>We want each drone to have an owner. Only an authenticated user will be able to create a drone and it will automatically become the owner of this new drone. We want only the owner of a drone to be able to update or delete the drone. Hence, an authenticated user that is also the owner of the drone will be able to execute <kbd>PATCH</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd> methods on the drone resource that he owns.</p>
<p>Any authenticated user that isn't the owner of a specific drone resource will have read-only access to this drone. In addition, unauthenticated requests will also have read-only access to drones.</p>
<p>We will combine authentication with specific permissions. Permissions use the authentication information included in the <kbd>request.user</kbd> and <kbd>request.auth</kbd> attributes to determine whether the request should be granted or denied access. Permissions allow us to control which types of users will be granted or denied access to the different features, methods, resources, or resource collections of our RESTful Web Service.</p>
<p>We will use the permissions features in the Django REST framework to allow only authenticated users to create new drones and automatically become their owners. We will make the necessary changes in the models to make a drone have a user as its owner. We will take advantage of the out-of-the-box permission classes included in the framework combined with a customized permission class, to define the previously explained permission policies for the drones and their related HTTP verbs supported in our web service.</p>
<p>In this case, we will stay focused on security and permissions and we will leave throttling rules for the next chapters. Bear in mind that throttling rules also determine whether a specific request must be authorized or not. However, we will work on throttling rules later and we will combine them with authentication and permissions.</p>
<p>Open the <kbd>restful01/drones/models.py</kbd> file and replace the code that declares the <kbd>Drone</kbd> class with the following code. The new lines are highlighted in the code listing. The code file for the sample is included in the <kbd>hillar_django_restful_08_01</kbd> folder, in the <kbd>restful01/drones/models.py</kbd> file:</p>
<pre>class Drone(models.Model): 
    name = models.CharField(max_length=250, unique=True) 
    drone_category = models.ForeignKey( 
        DroneCategory,  
        related_name='drones',  
        on_delete=models.CASCADE) 
    manufacturing_date = models.DateTimeField() 
    has_it_competed = models.BooleanField(default=False) 
    inserted_timestamp = models.DateTimeField(auto_now_add=True) 
<strong>    owner = models.ForeignKey( 
        'auth.User',  
        related_name='drones', 
        on_delete=models.CASCADE)</strong> 
 
    class Meta: 
        ordering = ('name',) 
 
    def __str__(self): 
        return self.name</pre>
<p>The highlighted lines declare a new <kbd>owner</kbd> field for the <kbd>Drone</kbd> model. The new field uses the <kbd>django.db.models.ForeignKey</kbd> class to provide a many-to-one relationship to the <kbd>django.contrib.auth.User</kbd> model.</p>
<p>This <kbd>User</kbd> model persists the users for the Django authentication system. Now, we are using this authentication system for our RESTful Web Service. The <kbd>'drones'</kbd> value specified for the <kbd>related_name</kbd> argument creates a backward relation from the <kbd>User</kbd> to the <kbd>Drone</kbd> model. Remember that this value indicates the name to use for the relation from the related <kbd>User</kbd> object back to a <kbd>Drone</kbd> object. This way, we will be able to access all the drones owned by a specific user.</p>
<p>Whenever we delete a <kbd>User</kbd>, we want all drones owned by this user to be deleted too, and therefore, we specified the <kbd>models.CASCADE</kbd> value for the <kbd>on_delete</kbd> argument.</p>
<p>Open the <kbd>restful01/drones/serializers.py</kbd> file and add the following code after the last line that declares the imports, before the declaration of the <kbd>DroneCategorySerializer</kbd> class. The code file for the sample is included in the <kbd>hillar_django_restful_08_01</kbd> folder, in the <kbd>restful01/drones/serializers.py</kbd> file:</p>
<pre>from django.contrib.auth.models import User 
 
 
class UserDroneSerializer(serializers.HyperlinkedModelSerializer): 
    class Meta: 
        model = Drone 
        fields = ( 
            'url', 
            'name') 
 
 
class UserSerializer(serializers.HyperlinkedModelSerializer): 
    drones = UserDroneSerializer( 
        many=True,  
        read_only=True) 
 
    class Meta: 
        model = User 
        fields = ( 
            'url',  
            'pk', 
            'username', 
            'drone')</pre>
<p>We don't want to use the <kbd>DroneSerializer</kbd> serializer class for the drones related to a user because we want to serialize fewer fields, and therefore, we created the <kbd>UserDroneSerializer</kbd> class. This class is a subclass of the <kbd>HyperlinkedModelSerializer</kbd> class. This new serializer allows us to serialize the drones related to a <kbd>User</kbd>. The <kbd>UserDroneSerializer</kbd> class defines a <kbd>Meta</kbd> inner class that declares the following two attributes:</p>
<ul>
<li><kbd>model</kbd>: This attribute specifies the model related to the serializer, that is, the <kbd>Drone</kbd> class.</li>
<li><kbd>fields</kbd>: This attribute specifies a tuple of string whose values indicate the field names that we want to include in the serialization from the related model. We just want to include the URL and the drone's name, and therefore, the code includes <kbd>'url'</kbd> and <kbd>'name'</kbd> as members of the tuple.</li>
</ul>
<p>The <kbd>UserSerializer</kbd> is a subclass of the <kbd>HyperlinkedModelSerializer</kbd> class. This new serializer class declares a <kbd>drones</kbd> attribute as an instance of the previously explained <kbd>UserDroneSerializer</kbd> class, with the <kbd>many</kbd> and <kbd>read_only</kbd> arguments equal to <kbd>True</kbd> because it is a one-to-many relationship and it is read-only. The code specifies the <kbd>drones</kbd> name that we specified as the string value for the <kbd>related_name</kbd> argument when we added the <kbd>owner</kbd> field as a <kbd>models.ForeignKey</kbd> instance in the <kbd>Drone</kbd> model. This way, the <kbd>drones</kbd> field will provide us with an array of URLs and names for each drone that belongs to the user.</p>
<p>Now, we will add an <kbd>owner</kbd> field to the existing <kbd>DroneSerializer</kbd> class. Open the <kbd>restful01/drones/serializers.py</kbd> file and replace the code that declares the <kbd>DroneSerializer</kbd> class with the following code. The new lines are highlighted in the code listing. The code file for the sample is included in the <kbd>hillar_django_restful_08_01</kbd> folder, in the <kbd>restful01/drones/serializers.py</kbd> file.</p>
<pre>class DroneSerializer(serializers.HyperlinkedModelSerializer): 
    # Display the category name 
    drone_category = serializers.SlugRelatedField(queryset=DroneCategory.objects.all(), slug_field='name') 
<strong>    # Display the owner's username (read-only) 
    owner = serializers.ReadOnlyField(source='owner.username')
</strong> 
    class Meta: 
        model = Drone 
        fields = ( 
            'url', 
            'name', 
            'drone_category', 
<strong>            'owner',
</strong>            'manufacturing_date', 
            'has_it_competed', 
            'inserted_timestamp',) </pre>
<p>The new version of the <kbd>DroneSerializer</kbd> class declares an <kbd>owner</kbd> attribute as an instance of <kbd>serializers.ReadOnlyField</kbd> with the <kbd>source</kbd> argument equal to <kbd>'owner.username'</kbd>. This way, the serializer will serialize the value for the <kbd>username</kbd> field of the related <kbd>django.contrib.auth.User</kbd> instance stored in the <kbd>owner</kbd> field.</p>
<p>The code uses the <kbd>ReadOnlyField</kbd> class because the owner is automatically populated when an authenticated user creates a new drone. It will be impossible to change the owner after a drone has been created with an HTTP <kbd>POST</kbd> method call. This way, the <kbd>owner</kbd> field will render the username that created the related drone. In addition, we added <kbd>'owner'</kbd> to the <kbd>fields</kbd> string tuple within the <kbd>Meta</kbd> inner class.</p>
<p>We made the necessary changes to the <kbd>Drone</kbd> model and its serializer (the <kbd>DroneSerializer</kbd> class) to make drones have owners.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with object-level permissions via customized permission classes</h1>
                </header>
            
            <article>
                
<p>The <kbd>rest_framework.permissions.BasePermission</kbd> class is the base class from which all customized permission classes should inherit to work with the Django REST framework. We want to make sure that only a drone owner can update or delete an existing drone.</p>
<p>Go to the <kbd>restful01/drones</kbd> folder and create a new file named <kbd>custompermission.py</kbd>. Write the following code in this new file. The following lines show the code for this file that declares the new <kbd>IsCurrentUserOwnerOrReadOnly</kbd> class declared as a subclass of the <kbd>BasePermission</kbd> class. The code file for the sample is included in the <kbd>hillar_django_restful_08_01</kbd> folder in the <kbd>restful01/drones/custompermission.py</kbd> file:</p>
<pre>from rest_framework import permissions 
 
 
class IsCurrentUserOwnerOrReadOnly(permissions.BasePermission): 
    def has_object_permission(self, request, view, obj): 
        if request.method in permissions.SAFE_METHODS: 
            # The method is a safe method 
            return True 
        else: 
            # The method isn't a safe method 
            # Only owners are granted permissions for unsafe methods 
            return obj.owner == request.user </pre>
<p>The previous lines declare the <kbd>IsCurrentUserOwnerOrReadOnly</kbd> class and override the <kbd>has_object_permission</kbd> method defined in the <kbd>BasePermission</kbd> superclass that returns a <kbd>bool</kbd> value indicating whether the permission should be granted or not.</p>
<p>The <kbd>permissions.SAFE_METHODS</kbd> tuple of string includes the three HTTP methods or verbs that are considered safe because they are read-only and they don't produce changes to the related resource or resource collection: <kbd>'GET'</kbd>, <kbd>'HEAD'</kbd>, and <kbd>'OPTIONS'</kbd>. The code in the <kbd>has_object_permission</kbd> method checks whether the HTTP verb specified in the <kbd>request.method</kbd> attribute is any of the three safe methods specified in <kbd>permission.SAFE_METHODS</kbd>. If this expression evaluates to <kbd>True</kbd>, the <kbd>has_object_permission</kbd> method returns <kbd>True</kbd> and grants permission to the request.</p>
<p>If the HTTP verb specified in the <kbd>request.method</kbd> attribute is not any of the three safe methods, the code returns <kbd>True</kbd> and grants permission only when the <kbd>owner</kbd> attribute of the received <kbd>obj</kbd> object (<kbd>obj.owner</kbd>) matches the user that originated the request (<kbd>request.user</kbd>). The user that originated the request will always be the authenticated user. This way, only the owner of the related resource will be granted permission for those requests that include HTTP verbs that aren't safe.</p>
<p>We will use the new <kbd>IsCurrentUserOwnerOrReadOnly</kbd> customized permission class to make sure that only the drone owners can make changes to an existing drone. We will combine this permission class with the <kbd>rest_framework.permissions.IsAuthenticatedOrReadOnly</kbd> one that only allows read-only access to resources when the request doesn't belong to an authenticated user. This way, whenever an anonymous user performs a request, he will only have read-only access to the resources.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Saving information about users that make requests</h1>
                </header>
            
            <article>
                
<p>Whenever a user performs an HTTP <kbd>POST</kbd> request to the drone resource collection to create a new drone resource, we want to make the authenticated user that makes the request the owner of the new drone. In order to make this happen, we will override the <kbd>perform_create</kbd> method in the <kbd>DroneList</kbd> class declared in the <kbd>views.py</kbd> file.</p>
<p>Open the <kbd>restful01/drones/views.py</kbd> file and replace the code that declares the <kbd>DroneList</kbd> class with the following code. The new lines are highlighted in the code listing. The code file for the sample is included in the <kbd>hillar_django_restful_08_01</kbd> folder, in the <kbd>restful01/drones/views.py</kbd> file:</p>
<pre>class DroneList(generics.ListCreateAPIView): 
    queryset = Drone.objects.all() 
    serializer_class = DroneSerializer 
    name = 'drone-list' 
    filter_fields = ( 
        'name',  
        'drone_category',  
        'manufacturing_date',  
        'has_it_competed',  
        ) 
    search_fields = ( 
        '^name', 
        ) 
    ordering_fields = ( 
        'name', 
        'manufacturing_date', 
        ) 
 
<strong>    def perform_create(self, serializer): 
        serializer.save(owner=self.request.user)</strong> </pre>
<p>The <kbd>generics.ListCreateAPIView</kbd> class inherits from the <kbd>CreateModelMixin</kbd> class and other classes. The <kbd>DroneList</kbd> class inherits the <kbd>perform_create</kbd> method from the <kbd>rest_framework.mixins.CreateModelMixin</kbd> class.</p>
<p>The code that overrides the <kbd>perform_create</kbd> method provides an additional <kbd>owner</kbd> field to the <kbd>create</kbd> method by setting a value for the <kbd>owner</kbd> argument in the call to the <kbd>serializer.save</kbd> method. The code sets the <kbd>owner</kbd> argument to the value of <kbd>self.request.user</kbd>, that is, to the authenticated user that is making the request. This way, whenever a new <kbd>Drone</kbd> is created and persisted, it will save the <kbd>User</kbd> associated to the request as its owner.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting permission policies</h1>
                </header>
            
            <article>
                
<p>We will configure permission policies for the class-based views that work with the <kbd>Drone</kbd> model. We will override the value for the <kbd>permission_classes</kbd> class attribute for the <kbd>DroneDetail</kbd> and <kbd>DroneList</kbd> classes.</p>
<p>We will add the same lines of code in the two classes. We will include the <kbd>IsAuthenticatedOrReadOnly</kbd> class and our recently declared <kbd>IsCurrentUserOwnerOrReadOnly</kbd> permission class in the <kbd>permission_classes</kbd> tuple.</p>
<p>Open the <kbd>restful01/drones/views.py</kbd> file and add the following lines after the last line that declares the imports, before the declaration of the <kbd>DroneCategorySerializer</kbd> class:</p>
<pre>from rest_framework import permissions 
from drones import custompermission </pre>
<p>Replace the code that declares the <kbd>DroneDetail</kbd> class with the following code in the same <kbd>views.py</kbd> file. The new lines are highlighted in the code listing. The code file for the sample is included in the <kbd>hillar_django_restful_08_01</kbd> folder, in the <kbd>restful01/drones/views.py</kbd> file:</p>
<pre>class DroneDetail(generics.RetrieveUpdateDestroyAPIView): 
    queryset = Drone.objects.all() 
    serializer_class = DroneSerializer 
    name = 'drone-detail' 
<strong>    permission_classes = ( 
        permissions.IsAuthenticatedOrReadOnly, 
        custompermission.IsCurrentUserOwnerOrReadOnly, 
        )</strong></pre>
<p>Replace the code that declares the <kbd>DroneList</kbd> class with the following code in the same <kbd>views.py</kbd> file. The new lines are highlighted in the code listing. The code file for the sample is included in the <kbd>hillar_django_restful_08_01</kbd> folder, in the <kbd>restful01/drones/views.py</kbd> file:</p>
<pre>class DroneList(generics.ListCreateAPIView): 
    queryset = Drone.objects.all() 
    serializer_class = DroneSerializer 
    name = 'drone-list' 
    filter_fields = ( 
        'name',  
        'drone_category',  
        'manufacturing_date',  
        'has_it_competed',  
        ) 
    search_fields = ( 
        '^name', 
        ) 
    ordering_fields = ( 
        'name', 
        'manufacturing_date', 
        ) 
<strong>    permission_classes = ( 
        permissions.IsAuthenticatedOrReadOnly, 
        custompermission.IsCurrentUserOwnerOrReadOnly, 
        )</strong>
 
    def perform_create(self, serializer): 
        serializer.save(owner=self.request.user) </pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating the superuser for Django</h1>
                </header>
            
            <article>
                
<p>Now, we will run the necessary command to create the <kbd>superuser</kbd> for Django that will allow us to authenticate our requests. We will create other users later.</p>
<p>Make sure you are in the <kbd>restful01</kbd> folder that includes the <kbd>manage.py</kbd> file in the activated virtual environment. Execute the following command that executes the <kbd>createsuperuser</kbd> subcommand for the <kbd>manage.py</kbd> script to allow us to create the <kbd>superuser</kbd>:</p>
<pre>    <strong>python manage.py createsuperuser</strong></pre>
<p>The command will ask you for the username you want to use for the <kbd>superuser</kbd>. Enter the desired username and press <em>Enter</em>. We will use <kbd>djangosuper</kbd> as the username for this example. You will see a line similar to the following one:</p>
<pre>    <strong>Username (leave blank to use 'gaston'):</strong></pre>
<p>Then, the command will ask you for the email address. Enter an email address and press <em>Enter.</em> You can enter <kbd>djangosuper@example.com</kbd>:</p>
<pre>    <strong>Email address:</strong></pre>
<p>Finally, the command will ask you for the password for the new superuser. Enter your desired password and press <em>Enter</em>. We will use <kbd>passwordforsuper</kbd> as an example in our tests. Of course, this password is not the best example of a strong password. However, the password is easy to type and read in our tests:</p>
<pre>    <strong>Password:</strong></pre>
<p>The command will ask you to enter the password again. Enter it and press <em>Enter</em>. If both entered passwords match, the superuser will be created:</p>
<pre>    <strong>Password (again): </strong>
    <strong>Superuser created successfully.</strong></pre>
<p>Our database has many rows in the <kbd>drones_drone</kbd> table. We added a new <kbd>owner</kbd> field for the <kbd>Drone</kbd> model and this required field will be added to the <kbd>drones_drone</kbd> table after we execute migrations. We have to assign a default owner for all the existing drones to make it possible to add this new required field without having to delete all these drones. We will use one of the features included in Django to solve the issue.</p>
<p>First, we have to know the <kbd>id</kbd> value for the superuser we have created to use it as the default owner for the existing drones. Then, we will use this value to let Django know which is the default owner for the existing drones.</p>
<p>We created the first user, and therefore, the <kbd>id</kbd> will be equal to <kbd>1</kbd>. However, we will check the procedure to determine the <kbd>id</kbd> value in case you create other users and you want to assign any other user as the default owner.</p>
<p>You can check the row in the <kbd>auth_user</kbd> table whose <kbd>username</kbd> field matches <kbd>'djangosuper'</kbd> in any tool that works with PostgreSQL. Another option is to run the following commands to retrieve the ID from the auth_user table for the row whose username is equal to <kbd>'djangosuper'</kbd>. In case you specified a different name, make sure you use the appropriate one. In addition, replace the username in the command with the username you used to create the PostgreSQL database and password with your chosen password for this database user. You specified this information when you executed the steps explained in <a href="dj-rst-websvc_ch16.html" target="_blank">Chapter 6</a>, <em>Working with Advanced Relationships and Serialization</em>, in the <em>Running migrations that generate relationships</em> section.</p>
<p>The command assumes that you are running PostgreSQL on the same computer in which you are executing the command:</p>
<pre>    <strong>psql --username=username --dbname=drones --command="SELECT id FROM <br/>    auth_user WHERE username = 'djangosuper';"</strong>
  </pre>
<p>The following lines show the output with the value for the <kbd>id</kbd> field: <kbd>1</kbd>:</p>
<pre>    <strong>id </strong>
    <strong>----</strong>
    <strong>  1</strong>
    <strong>(1 row)</strong></pre>
<p>Now, run the following Python script to generate the migrations that will allow us to synchronize the database with the new field we added to the <kbd>Drone</kbd> model:</p>
<pre>    <strong>python manage.py makemigrations drones</strong></pre>
<p>Django will explain to us that we cannot add a non-nullable field without a default and will ask us to select an option with the following message:</p>
<pre><strong> You are trying to add a non-nullable field 'owner' to drone without a   <br/>  default; we can't do that (the database needs something to populate <br/>   existing rows).</strong>
    <strong>Please select a fix:</strong>
    <strong> 1) Provide a one-off default now (will be set on all existing rows <br/>     with a null value for this column)</strong>
    <strong> 2) Quit, and let me add a default in models.py</strong>
       <strong>Select an option:</strong></pre>
<p>Enter <kbd>1</kbd> and press <em>Enter</em>. This way, we will select the first option to provide the one-off default that will be set on all the existing <kbd>drones_drone</kbd> rows.</p>
<p>Django will ask us to provide the default value we want to set for the <kbd>owner</kbd> field of the <kbd>drones_drone</kbd> table:</p>
<pre>    <strong>Please enter the default value now, as valid Python</strong>
    <strong>The datetime and django.utils.timezone modules are available, so <br/>     you can do e.g. timezone.now</strong>
    <strong>Type 'exit' to exit this prompt</strong>
    <strong>&gt;&gt;&gt;</strong></pre>
<p>Enter the value for the previously retrieved <kbd>id</kbd>: <kbd>1</kbd>. Then, press <em>Enter</em>. The following lines show the output generated after running the previous command:</p>
<pre>    <strong>Migrations for 'drones':</strong>
    <strong>  drones/migrations/0003_drone_owner.py</strong>
    <strong>    - Add field owner to drone</strong></pre>
<p>The output indicates that the <kbd>restful01/drones/migrations/0003_drone_owner.py</kbd> file includes the code to add the field named <kbd>owner</kbd> to the <kbd>drone</kbd> table. The following lines show the code for this file that was automatically generated by Django. The code file for the sample is included in the <kbd>hillar_django_restful_08_01</kbd> folder, in the <kbd>restful01/drones/migrations/0003_drone_owner.py</kbd> file:</p>
<pre># -*- coding: utf-8 -*-<br/># Generated by Django 1.11.5 on 2017-11-09 22:04<br/>from __future__ import unicode_literals<br/>from django.conf import settings<br/>from django.db import migrations, models<br/>import django.db.models.deletion<br/><br/><br/>class Migration(migrations.Migration):<br/><br/>    dependencies = [<br/>        migrations.swappable_dependency(settings.AUTH_USER_MODEL),<br/>        ('drones', '0002_auto_20171104_0246'),<br/>    ]<br/><br/>    operations = [<br/>        migrations.AddField(<br/>            model_name='drone',<br/>            name='owner',<br/>            field=models.ForeignKey(default=1, on_delete=django.db.models.deletion.CASCADE, related_name='drones', to=settings.AUTH_USER_MODEL),<br/>            preserve_default=False,<br/>        ),<br/>    ]<br/><br/></pre>
<p>The code declares the <kbd>Migration</kbd> class as a subclass of the <kbd>django.db.migrations.Migration</kbd> class. The <kbd>Migration</kbd> class defines an <kbd>operations</kbd> list with a <kbd>migrations.AddField</kbd> instance that will add the <kbd>owner</kbd> field to the table related to the <kbd>drone</kbd> model.</p>
<p>Now, run the following Python script to apply all the generated migrations and execute the changes in the database tables:</p>
<pre>    <strong>python manage.py migrate</strong></pre>
<p>The following lines show the output generated after running the previous command:</p>
<pre><strong>Operations to perform:<br/></strong><strong>Apply all migrations: admin, auth, contenttypes, drones, sessions<br/></strong><strong>Running migrations:<br/></strong><strong>Applying drones.0003_drone_owner... OK</strong></pre>
<p>After we run the previous command, we will have a new <kbd>owner_id</kbd> field in the <kbd>drones_drone</kbd> table in the PostgreSQL database. The existing rows in the <kbd>drones_drone</kbd> table will use the default value we instructed Django to use for the new <kbd>owner_id</kbd> field: <kbd>1</kbd>. This way, the superuser named <kbd>'djangosuper'</kbd> will be the owner for all the existing drones.</p>
<p>We can use the PostgreSQL command line or any other application that allows us to easily check the contents of the PostreSQL database to browse the <kbd>drones_drone</kbd> table that Django updated.</p>
<p>The following screenshot shows the new structure for the <kbd>drones_drone</kbd> table at the left-hand side and all its rows at the right-hand side:</p>
<div class="CDPAlignCenter CDPAlign"><img height="295" width="623" src="images/a9099daf-bfb1-41a2-aec6-80de7af1a110.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a user for Django</h1>
                </header>
            
            <article>
                
<p>Now, we will use Django's interactive shell to create a new user for Django. Run the following command to launch Django's interactive shell. Make sure you are within the <kbd>restful01</kbd> folder in the terminal, Command Prompt, or Windows Powershell window in which you have the virtual environment activated:</p>
<pre>    <strong>python manage.py shell</strong></pre>
<p>You will notice that a line that says <strong>(</strong><span class="packt_screen">InteractiveConsole</span><strong>)</strong> is displayed after the usual lines that introduce your default Python interactive shell. Enter the following code in the shell to create another user that is not a superuser. We will use this user and the superuser to test our changes in the permissions policies. The code file for the sample is included in the <kbd>hillar_django_restful_08_01</kbd> folder, in the <kbd>scripts/create_user.py</kbd> file. You can replace <kbd>user01</kbd> with your desired username, <kbd>user01@example.com</kbd> with the email and <kbd>user01password</kbd> with the password you want to use for this user. Notice that we will be using these credentials in the following sections. Make sure you always replace the credentials with your own credentials:</p>
<pre>from django.contrib.auth.models import User

user = User.objects.create_user('user01', 'user01@example.com', 'user01password')<br/>user.save()</pre>
<p>Finally, enter the following command to quit the interactive console:</p>
<pre><strong>quit()</strong></pre>
<p>You can achieve the same goal by pressing <em>Ctrl + D</em>. Now, we have a new user for Django named <kbd>user01</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making authenticated requests</h1>
                </header>
            
            <article>
                
<p>Now, we can launch Django's development server to compose and send authenticated HTTP requests to understand how the configured authentication classes, combined with the permission policies, work. Execute any of the following two commands based on your needs to access the API in other devices or computers connected to your LAN. Remember that we analyzed the difference between them in <a href="dj-rst-websvc_ch13.html" target="_blank">Chapter 3</a>,<em>&#160;</em><em>Creating API Views</em>, in the <em>Launching Django's development server</em> section:</p>
<pre>    <strong>python manage.py runserver</strong>
    <strong>python manage.py runserver 0.0.0.0:8000</strong></pre>
<p>After we run any of the previous commands, the development server will start listening at port <kbd>8000</kbd>.</p>
<p>We will compose and send an HTTP <kbd>POST</kbd> request without authentication credentials to try to create a new drone:</p>
<pre><strong>http POST :8000/drones/ name="Python Drone" drone_category="Quadcopter" manufacturing_date="2017-07-16T02:03:00.716312Z" has_it_competed=false</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl -iX POST -H "Content-Type: application/json" -d   <br/>   '{"name":"Python Drone", "drone_category":"Quadcopter", <br/>    "manufacturing_date": "2017-07-16T02:03:00.716312Z",  <br/>    "has_it_competed": "false"}' localhost:8000/drones/</strong></pre>
<p>We will receive an <kbd>HTTP 401 Unauthorized</kbd> status code in the response header and a <kbd>detail</kbd> message indicating that we didn't provide authentication credentials in the JSON body. The following lines show a sample response:</p>
<pre><strong>HTTP/1.0 401 Unauthorized<br/>Allow: GET, POST, HEAD, OPTIONS<br/>Content-Length: 58<br/>Content-Type: application/json<br/>Date: Tue, 19 Dec 2017 19:52:44 GMT<br/>Server: WSGIServer/0.2 CPython/3.6.2<br/>Vary: Accept, Cookie<br/>WWW-Authenticate: Basic realm="api"<br/>X-Frame-Options: SAMEORIGIN<br/><br/>{<br/>    "detail": "Authentication credentials were not provided."<br/>}</strong></pre>
<p>After the changes we made, if we want to create a new drone, that is, to make an HTTP <kbd>POST</kbd> request to <kbd>/drones/</kbd>, we need to provide authentication credentials by using HTTP authentication. Now, we will compose and send an HTTP request to create a new drone with authentication credentials, that is, with the superuser name and his password. Remember to replace <kbd>djangosuper</kbd> with the name you used for the superuser and <kbd>passwordforsuper</kbd> with the password you configured for this user:</p>
<pre><strong>http -a "djangosuper":"passwordforsuper" POST :8000/drones/ name="Python Drone" drone_category="Quadcopter" manufacturing_date="2017-07-16T02:03:00.716312Z" has_it_competed=false</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl --user "djangosuper":"passwordforsuper" -iX POST -H "Content-<br/>    Type: application/json" -d '{"name":"Python Drone", <br/>    "drone_category":"Quadcopter", "manufacturing_date": "2017-07-<br/>     16T02:03:00.716312Z", "has_it_competed": "false"}' <br/>     localhost:8000/drones/</strong></pre>
<p>The new <kbd>Drone</kbd> with the superuser named <kbd>djangosuper</kbd> as its owner has been successfully created and persisted in the database because the request was authenticated. As a result of the request, we will receive an <kbd>HTTP 201 Created</kbd> status code in the response header and the recently persisted <kbd>Drone</kbd> serialized to JSON in the response body. The following lines show an example response for the HTTP request, with the new <kbd>Drone</kbd> object in the JSON response body. Notice that the JSON response body includes the <kbd>owner</kbd> key and the username that created the drone as its value: <kbd>djangosuper</kbd>:</p>
<pre><strong>HTTP/1.0 201 Created<br/>Allow: GET, POST, HEAD, OPTIONS<br/>Content-Length: 219<br/>Content-Type: application/json<br/>Date: Fri, 10 Nov 2017 02:55:07 GMT<br/>Location: http://localhost:8000/drones/12<br/>Server: WSGIServer/0.2 CPython/3.6.2<br/>Vary: Accept, Cookie<br/>X-Frame-Options: SAMEORIGIN<br/><br/>{<br/>    "drone_category": "Quadcopter",<br/>    "has_it_competed": false,<br/>    "inserted_timestamp": "2017-11-10T02:55:07.361574Z",<br/>    "manufacturing_date": "2017-07-16T02:03:00.716312Z",<br/>    "name": "Python Drone",<br/>    "owner": "djangosuper",<br/>    "url": "http://localhost:8000/drones/12"<br/>}<br/></strong></pre>
<p>Now, we will try to update the <kbd>has_it_competed</kbd> field value for the previously created drone with an HTTP <kbd>PATCH</kbd> request. However, we will use the other user we created in Django to authenticate this HTTP <kbd>PATCH</kbd> request. This user isn't the owner of the drone, and therefore, the request shouldn't succeed.</p>
<p>Replace <kbd>user01</kbd> and <kbd>user01password</kbd> in the next command with the name and password you configured for this user. In addition, replace <kbd>12</kbd> with the ID generated for the previously created drone in your configuration:</p>
<pre><strong>http -a "user01":"user01password" PATCH :8000/drones/12 has_it_competed=true</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre><strong>curl --user "user01":"user01password" -iX PATCH -H "Content-Type: application/json" -d '{"has_it_competed": "true"}' localhost:8000/drones/12</strong></pre>
<p>We will receive an <kbd>HTTP 403 Forbidden</kbd> status code in the response header and a detail message indicating that we do not have permission to perform the action in the JSON body. The owner for the drone we want to update is <kbd>djangosuper</kbd> and the authentication credentials for this request use a different user: <kbd>user01</kbd>. Hence, the operation is rejected by the <kbd>has_object_permission</kbd> method in the <kbd>IsCurrentUserOwnerOrReadOnly</kbd> customized permission class we created. The following lines show a sample response:</p>
<pre>    <strong>HTTP/1.0 403 Forbidden</strong>
    <strong>Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS</strong>
    <strong>Content-Length: 63</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Fri, 10 Nov 2017 03:34:43 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>Vary: Accept, Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "detail": "You do not have permission to perform this action."</strong>
    <strong>}</strong>
  </pre>
<p>The user that isn't the drone's owner cannot make changes to the drone. However, he must be able to have read-only access to the drone. Hence, we must be able to compose and retrieve the previous drone details with an HTTP <kbd>GET</kbd> request with the same authentication credentials. It will work because <kbd>GET</kbd> is one of the safe methods and a user that is not the owner is allowed to read the resource. Replace <kbd>user01</kbd> and <kbd>user01password</kbd> in the next command with the name and password you configured for this user. In addition, replace <kbd>12</kbd> with the ID generated for the previously created drone in your configuration:</p>
<pre>    <strong>http -a "user01":"user01password" GET :8000/drones/12</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl --user "user01":"user01password" -iX GET <br/>    localhost:8000/drones/12</strong></pre>
<p>The response will return an <kbd>HTTP 200 OK</kbd> status code in the header and the requested <kbd>Drone</kbd> serialized to JSON in the response body.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making authenticated HTTP PATCH requests with Postman</h1>
                </header>
            
            <article>
                
<p>Now, we will use one of the GUI tools we installed in <em>Chapter 1,</em>&#160;<em>Installing the Required Software and Tools</em>, specifically, Postman. We will use this GUI tool to compose and send an HTTP <kbd>PATCH</kbd> request with the appropriate authentication credentials to the web service. In the previous chapters, whenever we worked with Postman, we didn't specify authentication credentials.</p>
<p>We will use the <span class="packt_screen">Builder</span> tab in Postman to compose and send an HTTP <kbd>PATCH</kbd> request to update the <kbd>has_it_competed</kbd> field for the previously created drone. Follow these steps:</p>
<ol>
<li>In case you made previous requests with Postman, click on the plus (<strong>+</strong>) button at the right-hand side of the tab that displayed the previous request. This way, you will create a new tab.</li>
<li>Select <span class="packt_screen">PATCH</span> in the drop-down menu at the left-hand side of the <span class="packt_screen">Enter request URL</span> textbox.</li>
<li>Enter <kbd>http://localhost:8000/drones/12</kbd> in that textbox at the right-hand side of the drop-down. Replace <kbd>12</kbd> with the ID generated for the previously created drone in your configuration.</li>
<li>Click the <span class="packt_screen">Authorization</span> tab below the textbox.</li>
<li>Select <span class="packt_screen">Basic Auth</span> in the <span class="packt_screen">TYPE</span> drop-down.</li>
<li>Enter the name you used to create <kbd>djangosuper</kbd> in the <span class="packt_screen">Username</span> textbox.</li>
<li>Enter the password you used instead of <kbd>passwordforsuper</kbd> for this user in the <span class="packt_screen">Password</span> textbox. The following screenshot shows the basic authentication configured in Postman for the HTTP <kbd>PATCH</kbd> request:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="images/0883be60-59a2-4a55-84b0-e89d32eb7be9.png"/></div>
<ol start="8">
<li>Click <span class="packt_screen">Body</span> at the right-hand side of the <span class="packt_screen">Authorization</span> and <span class="packt_screen">Headers</span> tabs, within the panel that composes the request.</li>
<li>Activate the <span class="packt_screen">raw</span> radio button and select <span class="packt_screen">JSON (application/json)</span> in the drop-down at the right-hand side of the binary radio button. Postman will automatically add a <span class="packt_screen">Content-type = application/json</span> header, and therefore, you will notice the <span class="packt_screen">Headers</span> tab will be renamed to <span class="packt_screen">Headers (1)</span>, indicating to us that there is one key/value pair specified for the request headers.</li>
<li>Enter the following lines in the textbox below the radio buttons, within the <span class="packt_screen">Body</span> tab:</li>
</ol>
<pre>   { 
       "has_it_competed": "true" 
   }</pre>
<p>The following screenshot shows the request body in Postman:</p>
<div class="CDPAlignCenter CDPAlign"><img height="181" width="514" class="alignnone size-full wp-image-478 image-border" src="images/043a3075-b78c-4ab1-839a-d2f2c47f6f94.png"/></div>
<p>We followed the necessary steps to create an HTTP <kbd>PATCH</kbd> request with a JSON body that specifies the necessary key/value pairs to update the value for the <kbd>was_included_in_home</kbd> field of an existing drone, with the necessary HTTP authentication credentials. Click <span class="packt_screen">Send</span> and Postman will display the following information:</p>
<ul>
<li><span class="packt_screen">Status</span>: <kbd>200 OK</kbd></li>
<li><span class="packt_screen">Time</span>: The time it took for the request to be processed</li>
<li><span class="packt_screen">Size</span>: The approximate response size (sum of body size plus headers size)</li>
<li><span class="packt_screen">Body</span>: The response body with the recently updated drone formatted as JSON with syntax highlighting</li>
</ul>
<p>The following screenshot shows the JSON response body in Postman for the HTTP <kbd>PATCH</kbd> request. In this case, the request updated the existing drone because we authenticated the request with the user that is the drone's owner:</p>
<div class="CDPAlignCenter CDPAlign"><img height="183" width="417" src="images/1d2fa033-b76a-418a-9082-c3ebaffef574.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Browsing the secured API with the required authentication</h1>
                </header>
            
            <article>
                
<p>We want the browsable API to display the log in and log out views. In order to make this possible, we have to add a line in the <kbd>urls.py</kbd> file in the <kbd>restful01/restful01</kbd> folder, specifically, in the <kbd>restful01/restful01/urls.py</kbd> file. The file defines the root URL configurations and we want to include the URL patterns provided by the Django REST framework that provide the log in and log out views.</p>
<p>The following lines show the new code for the <kbd>restful01/restful01/urls.py</kbd> file. The new line is highlighted. The code file for the sample is included in the <kbd>hillar_django_restful_08_01</kbd> folder, in the <kbd>restful01/restful01/urls.py</kbd> file:</p>
<pre>from django.conf.urls import url, include
 
urlpatterns = [
    url(r'^', include('drones.urls')),
<strong>    url(r'^api-auth/', include('rest_framework.urls'))
</strong>]</pre>
<p>Open a web browser and go to <kbd>http://localhost:8000/</kbd>. Replace localhost by the IP of the computer that is running Django's development server in case you use another computer or device to run the browser. The browsable API will compose and send a <kbd>GET</kbd> request to <kbd>/</kbd> and will display the results of its execution, that is, the <span class="packt_screen">Api Root</span>. You will notice there is a <span class="packt_screen">Log in</span> hyperlink at the upper-right corner.</p>
<p>Click or tap <span class="packt_screen">Log in</span> and the browser will display the Django REST framework login page. Enter the name you used to create <kbd>djangosuper</kbd> in the <span class="packt_screen">Username</span> textbox and the password you used instead of <kbd>passwordforsuper</kbd> for this user in the <span class="packt_screen">Password</span> textbox. Then, click <span class="packt_screen">Log in</span>.</p>
<p>Now, you will be logged in as <kbd>djangosuper</kbd> and all the requests you compose and send through the browsable API will use this user. You will be redirected again to the <span class="packt_screen">Api Root</span> and you will notice the <span class="packt_screen">Log in</span> hyperlink is replaced with the username (<span class="packt_screen">djangosuper</span>) and a drop-down menu that allows you to log out. The following screenshot shows the <span class="packt_screen">Api Root</span> after we are logged in as <kbd>djangosuper</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="302" width="372" src="images/b59a2e88-187a-492d-872b-64a39cc7b4fd.png"/></div>
<p>Click or tap on the username that is logged in (<span class="packt_screen">djangosuper</span>) and select <span class="packt_screen">Log Out</span> from the drop-down menu. We will log in as a different user.</p>
<p>Click or tap <span class="packt_screen">Log in</span> and the browser will display the Django REST framework login page. Enter the name you used to create <kbd>user01</kbd> in the <span class="packt_screen">Username</span> textbox and the password you used instead of <kbd>user01password</kbd> for this user in the <span class="packt_screen">Password</span> textbox. Then, click <span class="packt_screen">Log in</span>.</p>
<p>Now, you will be logged in as <kbd>user01</kbd> and all the requests you compose and send through the browsable API will use this user. You will be redirected again to the <span class="packt_screen">Api Root</span> and you will notice the <span class="packt_screen">Log in</span> hyperlink is replaced with the username (<span class="packt_screen">user01</span>).</p>
<p>Go to <kbd>http://localhost:8000/drones/12</kbd>. Replace <kbd>12</kbd> with the ID generated for the previously created drone in your configuration. The browsable API will render the web page with the results for the <kbd>GET</kbd> request to <kbd>localhost:8000/drones/12</kbd>.</p>
<p>Click or tap the <span class="packt_screen">OPTIONS</span> button and the browsable API will render the results of the HTTP <kbd>OPTIONS</kbd> request to <kbd>http://localhost:8000/drones/12</kbd> and will include the <span class="packt_screen">DELETE</span> button at the right-hand side of the <span class="packt_screen">Drone Detail</span> title.</p>
<p>Click or tap <span class="packt_screen">DELETE</span>. The web browser will display a confirmation modal. Click or tap the <span class="packt_screen">DELETE</span> button in the modal. As a result of the HTTP <kbd>DELETE</kbd> request, the web browser will display an <kbd>HTTP 403 Forbidden</kbd> status code in the response header and a detail message indicating that we do not have permission to perform the action in the JSON body. The owner for the drone we want to delete is <kbd>djangosuper</kbd> and the authentication credentials for this request use a different user, specifically, <kbd>user01</kbd>. Hence, the operation is rejected by the <kbd>has_object_permission</kbd> method in the <kbd>IsCurrentUserOwnerOrReadOnly</kbd> class. The following screenshot shows a sample response for the HTTP <kbd>DELETE</kbd> request:</p>
<div class="CDPAlignCenter CDPAlign"><img height="251" width="364" src="images/cd15f21d-27fe-49fc-a215-b63bfb46d6e6.png"/></div>
<div class="packt_tip">The browsable API makes it easy to compose and send authenticated requests to our RESTful Web Service.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with token-based authentication</h1>
                </header>
            
            <article>
                
<p>Now, we will make changes to use token-based authentication to retrieve, update, or delete pilots. Only those users that have a token will be able to make these operations with pilots. Hence, we will setup a specific authentication for pilots. It will still be possible to see the pilot's name rendered in unauthenticated requests.</p>
<p>The token-based authentication requires a new model named <kbd>Token</kbd>. Make sure you quit the Django's development server. Remember that you just need to press <em><span class="KeyPACKT">Ctrl</span></em> + <em><span class="KeyPACKT">C</span></em> in the terminal or command prompt window in which it is running.</p>
<div class="packt_tip">Of course, in a production environment, we must make sure that the RESTful Web Service is only available over HTTPS, with the usage of the latest TLS versions. We shouldn't use a token-based authentication over plain HTTP in a production environment.</div>
<p>Open the <kbd>restful01/restful01/settings.py</kbd> file that declares module-level variables that define the configuration of Django for the <kbd>restful01</kbd> project. Locate the lines that assign a strings list to <kbd>INSTALLED_APPS</kbd> to declare the installed apps. Add the following string to the <kbd>INSTALLED_APPS</kbd> strings list and save the changes to the <kbd>settings.py</kbd> file:</p>
<pre>'rest_framework.authtoken' </pre>
<p>The following lines show the new code that declares the <kbd>INSTALLED_APPS</kbd> strings list with the added line highlighted and with comments to understand what each added string means. The code file for the sample is included in the <kbd>hillar_django_restful_08_02</kbd> folder in the <kbd>restful01/restful01/settings.py</kbd> file:</p>
<pre>INSTALLED_APPS = [ 
    'django.contrib.admin', 
    'django.contrib.auth', 
    'django.contrib.contenttypes', 
    'django.contrib.sessions', 
    'django.contrib.messages', 
    'django.contrib.staticfiles', 
    # Django REST framework 
    'rest_framework', 
    # Drones application 
    'drones.apps.DronesConfig', 
    # Django Filters, 
    'django_filters', 
    # Token authentication 
<strong>    'rest_framework.authtoken',</strong>
]</pre>
<p>This way, we have added the <kbd>rest_framework.authtoken</kbd> application to our Django project named <kbd>restful01</kbd>.</p>
<p>Now, run the following Python script to execute all migrations required for the recently added <kbd>authtoken</kbd> application and apply the changes in the underlying database tables. This way, we will install the app:</p>
<pre>    <strong>python manage.py migrate</strong></pre>
<p>The following lines show the output generated after running the previous command. Notice that the order in which the migrations are executed can differ in your development computer:</p>
<pre>    <strong>Operations to perform:</strong>
    <strong>  Apply all migrations: admin, auth, authtoken, contenttypes, <br/>      drones, sessions</strong>
      <strong>Running migrations:</strong>
    <strong>  Applying authtoken.0001_initial... OK</strong>
    <strong>  Applying authtoken.0002_auto_20160226_1747... OK</strong></pre>
<p>After we run the previous command, we will have a new <kbd>authtoken_token</kbd> table in the PostgreSQL database. This table will persist the generated tokens and has a foreign key to the <kbd>auth_user</kbd> table.</p>
<p>We will configure authentication and permission policies for the class-based views that work with the <kbd>Pilot</kbd> model. We will override the values for the <kbd>authentication_classes</kbd> and <kbd>permission_classes</kbd> class attributes for the <kbd>PilotDetail</kbd> and <kbd>PilotList</kbd> classes.</p>
<p>We will add the same lines of code in the two classes. We will include the <kbd>TokenAuthentication</kbd> authentication class in the <kbd>authentication_classes</kbd> tuple, and the <kbd>IsAuthenticated</kbd> permission class in the <kbd>permission_classes</kbd> tuple.</p>
<p>Open the <kbd>restful01/drones/views.py</kbd> file and add the following lines after the last line that declares the imports, before the declaration of the <kbd>DroneCategorySerializer</kbd> class. The code file for the sample is included in the <kbd>hillar_django_restful_08_02</kbd> folder, in the <kbd>restful01/drones/views.py</kbd> file:</p>
<pre>from rest_framework.permissions import IsAuthenticated 
from rest_framework.authentication import TokenAuthentication</pre>
<p>Replace the code that declares the <kbd>PilotDetail</kbd> class with the following code in the same <kbd>views.py</kbd> file. The new lines are highlighted in the code listing. The code file for the sample is included in the <kbd>hillar_django_restful_08_02</kbd> folder, in the <kbd>restful01/drones/views.py</kbd> file:</p>
<pre>class PilotDetail(generics.RetrieveUpdateDestroyAPIView): 
    queryset = Pilot.objects.all() 
    serializer_class = PilotSerializer 
    name = 'pilot-detail' 
<strong>    authentication_classes = (
        TokenAuthentication,
        )
    permission_classes = (
        IsAuthenticated,
        )</strong></pre>
<p>Replace the code that declares the <kbd>PilotList</kbd> class with the following code in the same <kbd>views.py</kbd> file. The new lines are highlighted in the code listing. The code file for the sample is included in the <kbd>hillar_django_restful_08_02</kbd> folder, in the <kbd>restful01/drones/views.py</kbd> file:</p>
<pre>class PilotList(generics.ListCreateAPIView): 
    queryset = Pilot.objects.all() 
    serializer_class = PilotSerializer 
    name = 'pilot-list' 
    filter_fields = ( 
        'name',  
        'gender', 
        'races_count', 
        ) 
    search_fields = ( 
        '^name', 
        ) 
    ordering_fields = ( 
        'name', 
        'races_count' 
        ) 
<strong>    authentication_classes = (
        TokenAuthentication,
        )
    permission_classes = (
        IsAuthenticated,
        )</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generating and using tokens</h1>
                </header>
            
            <article>
                
<p>Now, we will launch our default Python interactive shell in our virtual environment and make all the Django project modules available to write code that will generate a token for an existing user. We will do this to understand how the token generation works.</p>
<p>Run the following command to launch the interactive shell. Make sure you are within the <kbd>restful01</kbd> folder in the terminal, Command Prompt, or Windows Powershell:</p>
<pre>   <strong>python manage.py shell</strong></pre>
<p>You will notice that a line that says <span class="packt_screen">(InteractiveConsole)</span> is displayed after the usual lines that introduce your default Python interactive shell. Enter the following code in the Python interactive shell to import all the things we will need to retrieve a <kbd>User</kbd> instance and generate a new token. The code file for the sample is included in the <kbd>hillar_django_restful_08_02</kbd> folder, in the <kbd>restful01/tokens_test_01.py</kbd> file.</p>
<pre>from rest_framework.authtoken.models import Token 
from django.contrib.auth.models import User </pre>
<p>Enter the following code to retrieve an instance of the <kbd>User</kbd> model whose username matches "user01" and create a new <kbd>Token</kbd> instance related to this user. The last line prints the value for the <kbd>key</kbd> attribute for the generated <kbd>Token</kbd> instance saved in the <kbd>token</kbd> variable. Replace <kbd>user01</kbd> in the next lines with the name you configured for this user. The code file for the sample is included in the <kbd>hillar_django_restful_08_02</kbd> folder, in the <kbd>restful01/tokens_test_01.py</kbd> file:</p>
<pre># Replace user01 with the name you configured for this user 
user = User.objects.get(username="user01") 
token = Token.objects.create(user=user) 
print(token.key) </pre>
<p>The following line shows a sample output from the previous code with the string value for <kbd>token.key</kbd>. Copy the output generated when running the code because we will use this token to authenticate requests. Notice that the token generated in your system will be different:</p>
<pre>    <strong>ebebe08f5d7fe5997f9ed1761923ec5d3e461dc3</strong></pre>
<p>Finally, enter the following command to quit the interactive console:</p>
<pre><strong>    quit()</strong></pre>
<p>Now, we have a token for the Django user named <kbd>user01</kbd>.</p>
<p>Now, we can launch Django's development server to compose and send HTTP requests to retrieve pilots to understand how the configured token authentication class combined with the permission policies work. Execute any of the following two commands based on your needs to access the API in other devices or computers connected to your LAN. Remember that we analyzed the difference between them in <a href="dj-rst-websvc_ch13.html" target="_blank">Chapter 3</a>,<em>&#160;</em><em>Creating API Views</em>, in the <em>Launching Django's development server</em> section:</p>
<pre>    <strong>python manage.py runserver</strong>
    <strong>python manage.py runserver 0.0.0.0:8000</strong></pre>
<p>After we run any of the previous commands, the development server will start listening at port <kbd>8000</kbd>.</p>
<p>We will compose and send an HTTP <kbd>GET</kbd> request without authentication credentials to try to retrieve the first page of the <kbd>pilots</kbd> collection:</p>
<pre>    <strong>http :8000/pilots/</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl -iX GET localhost:8000/pilots/</strong></pre>
<p>We will receive an <kbd>HTTP 401 Unauthorized</kbd> status code in the response header and a detail message indicating that we didn't provide authentication credentials in the JSON body. In addition, the value for the <kbd>WWW-Authenticate</kbd> header specifies the authentication method that must be applied to access the resource collection: <kbd>Token</kbd>. The following lines show a sample response:</p>
<pre><strong>HTTP/1.0 401 Unauthorized<br/>Allow: GET, POST, HEAD, OPTIONS<br/>Content-Length: 58<br/>Content-Type: application/json<br/>Date: Sat, 18 Nov 2017 02:28:31 GMT<br/>Server: WSGIServer/0.2 CPython/3.6.2<br/>Vary: Accept<br/>WWW-Authenticate: Token<br/>X-Frame-Options: SAMEORIGIN<br/><br/>{<br/>    "detail": "Authentication credentials were not provided."<br/>}</strong></pre>
<p><span>After the changes we made, if we want to retrieve the collection of pilots, that is, to make an HTTP</span> <kbd>GET</kbd> <span>request to</span> <kbd>/pilots/</kbd><span>, we need to provide authentication credentials by using the token-based authentication. Now, we will compose and send an HTTP request to retrieve the collection of pilots with authentication credentials, that is, with the token. Remember to replace</span> <kbd>PASTE-TOKEN-HERE</kbd> <span>with the previously generated token:</span></p>
<pre>    <strong>http :8000/pilots/ "Authorization: Token PASTE-TOKEN-HERE"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>  <strong>curl -iX GET http://localhost:8000/pilots/ -H "Authorization: Token <br/>  PASTE-TOKEN-HERE"</strong></pre>
<p>As a result of the request, we will receive an <kbd>HTTP 200 OK</kbd> status code in the response header and the first page of the pilots collection serialized to JSON in the response body. The following screenshot shows the first lines of a sample response for the request with the appropriate token:</p>
<div class="CDPAlignCenter CDPAlign"><img height="354" width="568" src="images/7b83974c-e9cd-4f8d-bddd-8f2dc13faea0.png"/></div>
<p>The token-based authentication provided with the Django REST framework is very simple and it requires customization to make it production ready. Tokens never expire and there is no setting to specify the default expiration time for a token.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test your knowledge</h1>
                </header>
            
            <article>
                
<p>Let's see whether you can answer the following questions correctly.</p>
<ol>
<li>The <kbd>permissions.SAFE_METHODS</kbd> tuple of string includes the following HTTP methods or verbs that are considered safe:
<ol>
<li><kbd>'GET'</kbd>, <kbd>'HEAD'</kbd>, and <kbd>'OPTIONS'</kbd></li>
<li><kbd>'POST'</kbd>, <kbd>'PATCH'</kbd>, and <kbd>'OPTIONS'</kbd></li>
<li><kbd>'GET'</kbd>, <kbd>'PUT'</kbd>, and <kbd>'OPTIONS'</kbd></li>
</ol>
</li>
<li>Which of the following settings key in the <kbd>REST_FRAMEWORK</kbd> dictionary specifies the global setting with a tuple of string whose values indicate the classes that we want to use for authentication?
<ol>
<li><kbd>'GLOBAL_AUTHENTICATION_CLASSES'</kbd></li>
<li><kbd>'DEFAULT_AUTHENTICATION_CLASSES'</kbd></li>
<li><kbd>'REST_FRAMEWORK_AUTHENTICATION_CLASSES'</kbd></li>
</ol>
</li>
<li>Which of the following is the model that persists a Django user?
<ol>
<li><kbd>Django.contrib.auth.DjangoUser</kbd></li>
<li><kbd>Django.contrib.auth.User</kbd></li>
<li><kbd>Django.rest-framework.User</kbd></li>
</ol>
</li>
<li>Which of the following classes is the base class from which all customized permission classes should inherit to work with the Django REST framework?
<ol>
<li><kbd>Django.contrib.auth.MainPermission</kbd></li>
<li><kbd>rest_framework.permissions.MainPermission</kbd></li>
<li><kbd>rest_framework.permissions.BasePermission</kbd></li>
</ol>
</li>
<li>In order to configure permission policies for a class-based view, which of the following class attributes do we have to override?
<ol>
<li><kbd>permission_classes</kbd></li>
<li><kbd>permission_policies_classes</kbd></li>
<li><kbd>rest_framework_permission_classes</kbd></li>
</ol>
</li>
</ol>
<p>&#160;</p>
<p><span>The rights answers are included in the <a href="https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&amp;action=edit#post_454" target="_blank">Appendix</a>,&#160;<em>Solutions</em>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned the differences between authentication and permissions in Django, the Django REST framework, and RESTful Web Services. We analyzed the authentication classes included in the Django REST framework out of the box.</p>
<p>We followed the necessary steps to include security and permissions-related data to models. We worked with object-level permissions via customized permission classes and we saved information about users that make requests. We understood that there are three HTTP methods or verbs that are considered safe.</p>
<p>We configured permission policies for the class-based views that worked with the <kbd>Drone</kbd> model. Then, we created a superuser and another user for Django to compose and send authenticated requests and to understand how the permission policies we configured were working.</p>
<p>We used command-line tools and GUI tools to compose and send authenticated requests. Then, we browsed the secured RESTful Web Service with the browsable API feature. Finally, we worked with a simple token-based authentication provided by the Django REST framework to understand another way of authenticating requests.</p>
<p>Now that we have improved our RESTful Web Service with authentication and permission policies, it is time to combine these policies with throttling rules and versioning. We will cover these topics in the next chapter.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Applying Throttling Rules and Versioning Management</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will work with throttling rules to limit the usage of our RESTful Web Service. We don't want to process requests until our RESTful Web Service runs out of resources, and therefore, we will analyze the importance of throttling rules. We will take advantage of the features included in the Django REST framework to manage different versions of our web service. We will gain an understanding of:</p>
<ul>
<li>Understanding the importance of throttling rules</li>
<li>Learning the purpose of the different throttling classes in the Django REST framework</li>
<li>Configuring throttling policies in the Django REST framework</li>
<li>Running tests to check that throttling policies work as expected</li>
<li>Understanding versioning classes</li>
<li>Configuring the versioning scheme</li>
<li>Running tests to check that versioning works as expected</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding the importance of throttling rules</h1>
                </header>
            
            <article>
                
<p>In <a href="dj-rst-websvc_ch17.html" target="_blank">Chapter 8</a>, <em>Securing the API with Authentication and Permissions</em>, we made sure that some requests were authenticated before processing them. We took advantage of many authentication schemes to identify the user that originated the request. Throttling rules also determine whether the request must be authorized or not. We will work with them in combination with authentication.</p>
<p>So far, we haven't established any limits on the usage of our RESTful Web Service. As a result of this configuration, both unauthenticated and authenticated users can compose and send as many requests as they want to. The only thing we have limited is the resultset size throughout the configuration of the pagination features available in the Django REST framework. Hence, large results sets are split into individual pages of data. However, a user might compose and send thousands of requests to be processed with any kind of limitation. Of course, the servers or virtual machines that run our RESTful Web Services or the underlying database can be overloaded by the huge amount of requests because we don't have limits.</p>
<p>Throttles control the rate of requests that users can make to our RESTful Web Service. The Django REST framework makes it easy to configure throttling rules. We will use throttling rules to configure the following limitations to the usage of our RESTful Web Service:</p>
<ul>
<li>A maximum of 3 requests per hour for unauthenticated users</li>
<li>A maximum of 10 requests per hour for authenticated users</li>
<li>A maximum of 20 requests per hour for the drones related views</li>
<li>A maximum of 15 requests per hour for the pilots related views</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Learning the purpose of the different throttling classes in the Django REST framework</h1>
                </header>
            
            <article>
                
<p>The Django REST framework provides three throttling classes in the <kbd>rest_framework.throttling</kbd> module. All of them are subclasses of the <kbd>SimpleRateThrottle</kbd> class which inherits from the <kbd>BaseThrottle</kbd> class.</p>
<p>The three classes allow us to specify throttling rules that indicate the maximum number of requests in a specific period of time and within a determined scope. Each class is responsible for computing and validating the maximum number of requests per period. The classes provide different mechanisms to determine the previous request information to specify the scope by comparing it with the new request. The Django REST framework stores the required data to analyze each throttling rule in the cache. Thus, the classes override the inherited <kbd>get_cache_key</kbd> method that determines the scope that will be used for computing and validating.</p>
<p>The following are the three throttling classes:</p>
<ul>
<li><kbd>AnonRateThrottle</kbd>: This class limits the rate of requests that an anonymous user can make, and therefore, its rules apply to unauthenticated users. The unique cache key is the IP address of the incoming request. Hence, all the requests originated in the same IP address will accumulate the total number of requests for this IP.</li>
<li><kbd>UserRateThrottle</kbd>: This class limits the rate of requests that a specific user can make and applies to both authenticated and non-authenticated users. Obviously, when the requests are authenticated, the authenticated user ID is the unique cache key. When the requests are unauthenticated and come from anonymous users, the unique cache key is the IP address of the incoming request.</li>
<li><kbd>ScopedRateThrottle</kbd>: This class is useful whenever we have to restrict access to specific features of our RESTful Web Service with different rates. The class uses the value assigned to the <kbd>throttle_scope</kbd> attribute to limit requests to the parts that are identified with the same value.</li>
</ul>
<p>The previous classes are included in the Django REST framework out of the box. There are many additional throttling classes provided by many third-party libraries.</p>
<p>Make sure you quit the Django's development server. Remember that you just need to press <em><span class="KeyPACKT">Ctrl</span></em> + <em><span class="KeyPACKT">C</span></em> in the terminal or Command Prompt window in which it is running. We will make the necessary changes to combine the different authentication mechanisms we set up in the previous chapter with the application of throttling rules. Hence, we will add the <kbd>AnonRateThrottle</kbd> and <kbd>UserRateThrottle</kbd> classes in the global throttling classes list.</p>
<p>The value for the <kbd>DEFAULT_THROTTLE_CLASSES</kbd> settings key specifies a global setting with a tuple of string whose values indicate the default classes that we want to use for throttling rules. We will specify the <kbd>AnonRateThrottle</kbd> and <kbd>UserRateThrottle</kbd> classes.</p>
<p>The <kbd>DEFAULT_THROTTLE_RATES</kbd> settings key specifies a dictionary with the default throttle rates. The next list specifies the keys, the values that we will assign and their meaning:</p>
<ul>
<li><kbd>'anon'</kbd>: We will specify <kbd>'3/hour'</kbd> as the value for this key, which means we want a maximum of 3 requests per hour for anonymous users. The <kbd>AnonRateThrottle</kbd> class will apply this throttling rule.</li>
<li><kbd>'user'</kbd>: We will specify <kbd>'10/hour'</kbd> as the value for this key, which means we want a maximum of 10 requests per hour for authenticated users. The <kbd>UserRateThrottle</kbd> class will apply this throttling rule.</li>
<li><kbd>'drones'</kbd>: We will specify <kbd>'20/hour'</kbd> as the value for this key, which means we want a maximum of 20 requests per hour for the drones-related views. The <kbd>ScopedRateThrottle</kbd> class will apply this throttling rule.</li>
<li><kbd>'pilots'</kbd>: We will specify <kbd>'15/hour'</kbd> as the value for this key, which means we want a maximum of 15 requests per hour for the drones-related views. The <kbd>ScopedRateThrottle</kbd> class will apply this throttling rule.</li>
</ul>
<p>The maximum rate value for each key is a string that specifies the number of requests per period with the following format: <kbd>'number_of_requests/period'</kbd>, where <kbd>period</kbd> can be any of the following:</p>
<ul>
<li><kbd>d</kbd>: day</li>
<li><kbd>day</kbd>: day</li>
<li><kbd>h</kbd>: hour</li>
<li><kbd>hour</kbd>: hour</li>
<li><kbd>m</kbd>: minute</li>
<li><kbd>min</kbd>: minute</li>
<li><kbd>s</kbd>: second</li>
<li><kbd>sec</kbd>: second</li>
</ul>
<div class="packt_tip">In this case, we will always work with a maximum number of requests per hour, and therefore, the values will use <kbd>/hour</kbd> after the maximum number of requests.</div>
<p>Open the <kbd>restful01/restful01/settings.py</kbd> file that declares module-level variables that define the configuration of Django for the <kbd>restful01</kbd> project. We will make some changes to this Django settings file. Add the highlighted lines to the <kbd>REST_FRAMEWORK</kbd> dictionary. The following lines show the new declaration of the <kbd>REST_FRAMEWORK</kbd> dictionary. The code file for the sample is included in the <kbd>hillar_django_restful_09_01</kbd> folder in the <kbd>restful01/restful01/settings.py</kbd> file:</p>
<pre>REST_FRAMEWORK = { 
    'DEFAULT_PAGINATION_CLASS': 
    'drones.custompagination.LimitOffsetPaginationWithUpperBound', 
    'PAGE_SIZE': 4, 
    'DEFAULT_FILTER_BACKENDS': ( 
        'django_filters.rest_framework.DjangoFilterBackend', 
        'rest_framework.filters.OrderingFilter', 
        'rest_framework.filters.SearchFilter', 
        ), 
    'DEFAULT_AUTHENTICATION_CLASSES': ( 
        'rest_framework.authentication.BasicAuthentication', 
        'rest_framework.authentication.SessionAuthentication', 
        ), 
    <strong>'DEFAULT_THROTTLE_CLASSES': ( 
        'rest_framework.throttling.AnonRateThrottle', 
        'rest_framework.throttling.UserRateThrottle', 
    ), 
    'DEFAULT_THROTTLE_RATES': { 
        'anon': '3/hour', 
        'user': '10/hour', 
        'drones': '20/hour', 
        'pilots': '15/hour', 
    } 
}</strong> </pre>
<p>We added values for the <kbd>DEFAULT_THROTTLE_CLASSES</kbd> and the <kbd>DEFAULT_THROTTLE_RATES</kbd> settings keys to configure the default throttling classes and the desired rates.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring throttling policies in the Django REST framework</h1>
                </header>
            
            <article>
                
<p>Now, we will configure throttling policies for the class-based views related to drones: <kbd>DroneList</kbd> and <kbd>DroneDetail</kbd>. We will override the values for the following class attributes for the class-based views:</p>
<ul>
<li><kbd>throttle_classes</kbd>: This class attribute specifies a tuple with the names of the classes that will manage throttling rules for the class. In this case, we will specify the <kbd>ScopedRateThrottle</kbd> class as the only member of the tuple.</li>
<li><kbd>throttle_scope</kbd>: This class attribute specifies the throttle scope name that the <kbd>ScopedRateThrottle</kbd> class will use to accumulate the number of requests and limit the rate of requests.</li>
</ul>
<p>This way, we will make these class-based views work with the <kbd>ScopedRateThrottle</kbd> class and we will configure the throttle scope that this class will consider for each of the class based views related to drones.</p>
<p>Open the <kbd>restful01/drones/views.py</kbd> file and add the following lines after the last line that declares the imports, before the declaration of the <kbd>DroneCategoryList</kbd> class:</p>
<pre>from rest_framework.throttling import ScopedRateThrottle  </pre>
<p>Replace the code that declares the <kbd>DroneDetail</kbd> class with the following code in the same <kbd>views.py</kbd> file. The new lines are highlighted in the code listing. The code file for the sample is included in the <kbd>hillar_django_restful_09_01</kbd> folder, in the <kbd>restful01/drones/views.py</kbd> file:</p>
<pre>class DroneDetail(generics.RetrieveUpdateDestroyAPIView): 
    <strong>throttle_scope = 'drones' 
    throttle_classes = (ScopedRateThrottle,)</strong> 
    queryset = Drone.objects.all() 
    serializer_class = DroneSerializer 
    name = 'drone-detail' 
    permission_classes = ( 
        permissions.IsAuthenticatedOrReadOnly, 
        custompermission.IsCurrentUserOwnerOrReadOnly, 
        )</pre>
<p>Replace the code that declares the <kbd>DroneList</kbd> class with the following code in the same <kbd>views.py</kbd> file. The new lines are highlighted in the code listing. The code file for the sample is included in the <kbd>hillar_django_restful_09_01</kbd> folder, in the <kbd>restful01/drones/views.py</kbd> file:</p>
<pre>class DroneList(generics.ListCreateAPIView): 
    <strong>throttle_scope = 'drones' 
    throttle_classes = (ScopedRateThrottle,)</strong> 
    queryset = Drone.objects.all() 
    serializer_class = DroneSerializer 
    name = 'drone-list' 
    filter_fields = ( 
        'name',  
        'drone_category',  
        'manufacturing_date',  
        'has_it_competed',  
        ) 
    search_fields = ( 
        '^name', 
        ) 
    ordering_fields = ( 
        'name', 
        'manufacturing_date', 
        ) 
    permission_classes = ( 
        permissions.IsAuthenticatedOrReadOnly, 
        custompermission.IsCurrentUserOwnerOrReadOnly, 
        ) 
 
    def perform_create(self, serializer): 
        serializer.save(owner=self.request.user) </pre>
<p>We added the same lines in the two classes. We assigned <kbd>'drones'</kbd> to the <kbd>throttle_scope</kbd> class attribute and we included <kbd>ScopedRateThrottle</kbd> in the tuple that defines the value for <kbd>throttle_classes</kbd>. This way, the two class-based views will use the settings specified for the <kbd>'drones'</kbd> scope and the <kbd>ScopeRateThrottle</kbd> class for throttling. We added the <kbd>'drones'</kbd> key to the <kbd>DEFAULT_THROTTLE_RATES</kbd> key in the <kbd>REST_FRAMEWORK</kbd> dictionary, and therefore, the <kbd>'drones'</kbd> scope is configured to serve a maximum of 20 requests per hour.</p>
<p>Now, we will configure throttling policies for the class-based views related to pilots: <kbd>PilotList</kbd> and <kbd>PilotDetail</kbd>. We will also override the values for the <kbd>throttle_scope</kbd> and <kbd>throttle_classes</kbd> class attributes.</p>
<p>Replace the code that declares the <kbd>PilotDetail</kbd> class with the following code in the same <kbd>views.py</kbd> file. The new lines are highlighted in the code listing. The code file for the sample is included in the <kbd>hillar_django_restful_09_01</kbd> folder, in the <kbd>restful01/drones/views.py</kbd> file:</p>
<pre>class PilotDetail(generics.RetrieveUpdateDestroyAPIView): 
    <strong>throttle_scope = 'pilots' 
    throttle_classes = (ScopedRateThrottle,)</strong> 
    queryset = Pilot.objects.all() 
    serializer_class = PilotSerializer 
    name = 'pilot-detail' 
    authentication_classes = ( 
        TokenAuthentication, 
        ) 
    permission_classes = ( 
        IsAuthenticated, 
        ) </pre>
<p>Replace the code that declares the <kbd>PilotList</kbd> class with the following code in the same <kbd>views.py</kbd> file. The new lines are highlighted in the code listing. The code file for the sample is included in the <kbd>hillar_django_restful_09_01</kbd> folder, in the <kbd>restful01/drones/views.py</kbd> file:</p>
<pre>class PilotList(generics.ListCreateAPIView): 
    <strong>throttle_scope = 'pilots' 
    throttle_classes = (ScopedRateThrottle,)</strong> 
    queryset = Pilot.objects.all() 
    serializer_class = PilotSerializer 
    name = 'pilot-list' 
    filter_fields = ( 
        'name',  
        'gender', 
        'races_count', 
        ) 
    search_fields = ( 
        '^name', 
        ) 
    ordering_fields = ( 
        'name', 
        'races_count' 
        ) 
    authentication_classes = ( 
        TokenAuthentication, 
        ) 
    permission_classes = ( 
        IsAuthenticated, 
        ) </pre>
<p>We added the same lines in the two classes. We assigned <kbd>'pilots'</kbd> to the <kbd>throttle_scope</kbd> class attribute and we included <kbd>ScopedRateThrottle</kbd> in the tuple that defines the value for <kbd>throttle_classes</kbd>. This way, the two class-based views will use the settings specified for the <kbd>'pilots'</kbd> scope and the <kbd>ScopeRateThrottle</kbd> class for throttling. We added the <kbd>'pilots'</kbd> key to the <kbd>DEFAULT_THROTTLE_RATES</kbd> key in the <kbd>REST_FRAMEWORK</kbd> dictionary, and therefore, the <kbd>'drones'</kbd> scope is configured to serve a maximum of 15 requests per hour.</p>
<div class="packt_tip">All the class-based views we have edited won't take into account the global settings that applied the default classes that we use for throttling: <kbd>AnonRateThrottle</kbd> and <kbd>UserRateThrottle</kbd>. These class-based views will use the configuration we have specified for them.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running tests to check that throttling policies work as expected</h1>
                </header>
            
            <article>
                
<p>Before Django runs the main body of a class-based view, it performs the checks for each throttle class specified in the throttle classes settings. In the drones and pilots-related views, we wrote code that overrides the default settings.</p>
<p>If a single throttle check fails, the code will raise a <kbd>Throttled</kbd> exception and Django won't execute the main body of the view. The cache is responsible for storing previous request information for throttling checking.</p>
<p>Now, we can launch Django's development server to compose and send HTTP requests to understand how the configured throttling rules, combined with all the previous configurations, work. Execute any of the following two commands based on your needs to access the API in other devices or computers connected to your LAN. Remember that we analyzed the difference between them in <a href="dj-rst-websvc_ch13.html" target="_blank">Chapter 3</a>,<em>&#160;</em><em>Creating API Views</em>, in the <em>Launching Django's development server</em> section.</p>
<pre>    <strong>python manage.py runserver</strong>
    <strong>python manage.py runserver 0.0.0.0:8000</strong></pre>
<p>After we run any of the previous commands, the development server will start listening at port <kbd>8000</kbd>.</p>
<p>Now, we will compose and send the following HTTP <kbd>GET</kbd> request without authentication credentials to retrieve the first page of the competitions four times:</p>
<pre>    <strong>http :8000/competitions/</strong></pre>
<p>We can also use the features of the shell in macOS or Linux to run the previous command four times with just a single line with a bash shell. The command is compatible with a Cygwin terminal in Windows. We must take into account that we will see all the results one after the other and we will have to scroll to understand what happened with each execution:</p>
<pre>    <strong>for i in {1..4}; do http :8000/competitions/; done;</strong></pre>
<p>The following line allows you to run the command four times with a single line in Windows PowerShell:</p>
<pre>    <strong>1..4 | foreach { http :8000/competitions/ }</strong></pre>
<p>The following is the equivalent curl command that we must execute four times:</p>
<pre>    <strong>curl -iX GET localhost:8000/competitions/</strong></pre>
<p>The following is the equivalent curl command that is executed four times with a single line in a bash shell in a macOS or Linux, or a Cygwin terminal in Windows:</p>
<pre>    <strong>for i in {1..4}; do curl -iX GET localhost:8000/competitions/; done;</strong></pre>
<p>The following is the equivalent curl command that is executed four times with a single line in Windows PowerShell:</p>
<pre>    <strong>1..4 | foreach { curl -iX GET localhost:8000/competitions/ }</strong></pre>
<p>The Django REST framework won't process the request number 4. The <kbd>AnonRateThrottle</kbd> class is configured as one of the default throttle classes and its throttle settings specify a maximum of 3 requests per hour. Hence, we will receive an HTTP <kbd>429 Too many requests</kbd> status code in the response header and a message indicating that the request was throttled and the time in which the server will be able to process an additional request. The value for the <kbd>Retry-After</kbd> key in the response header provides the number of seconds that we must wait until the next request: <kbd>2347</kbd>. The following lines show a sample response. Notice that the number of seconds might be different in your configuration:</p>
<pre>    <strong>HTTP/1.0 429 Too Many Requests</strong>
    <strong>Allow: GET, POST, HEAD, OPTIONS</strong>
    <strong>Content-Length: 71</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Thu, 30 Nov 2017 03:07:28 GMT</strong>
    <strong>Retry-After: 2347</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>Vary: Accept, Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "detail": "Request was throttled. Expected available in 2347 seconds."</strong>
    <strong>}</strong></pre>
<p>Now, we will compose and send the following HTTP <kbd>GET</kbd> request with authentication credentials to retrieve the first page of the competitions four times. We will use the superuser we created in the previous chapter. Remember to replace <kbd>djangosuper</kbd> with the name you used for the superuser and <kbd>passwordforsuper</kbd> with the password you configured for this user as shown here:</p>
<pre>    <strong>http -a "djangosuper":"passwordforsuper" :8000/competitions/</strong></pre>
<p>In a Linux, macOS or a Cygwin terminal, we can run the previous command four times with the following single line:</p>
<pre>    <strong>for i in {1..4}; do http -a "djangosuper":"passwordforsuper" :8000/competitions/; done;</strong></pre>
<p>The following line allows you to run the command four times with a single line in Windows PowerShell.</p>
<pre>    <strong>1..4 | foreach { http -a "djangosuper":"passwordforsuper" :8000/competitions/ }</strong>
  </pre>
<p>The following is the equivalent curl command that we must execute four times:</p>
<pre>    <strong>curl --user 'djangosuper':'passwordforsuper' -iX GET localhost:8000/competitions/</strong>
  </pre>
<p>The following is the equivalent curl command that we can execute four times in a Linux, macOS or a Cygwin terminal with a single line:</p>
<pre>    <strong>for i in {1..4}; do curl --user "djangosuper":"passwordforsuper" -iX GET localhost:8000/competitions/; done;</strong>
  </pre>
<p>The following is the equivalent curl command that is executed four times with a single line in Windows PowerShell:</p>
<pre>    <strong>1..4 | foreach { curl --user "djangosuper":"passwordforsuper" -iX GET localhost:8000/competitions/ }</strong>
  </pre>
<p>In this case, Django will process the request number 4 because we have composed and sent 4 authenticated requests with the same user. The <kbd>UserRateThrottle</kbd> class is configured as one of the default throttle classes and its throttle settings specify 10 requests per hour. We still have 6 requests before we accumulate the maximum number of requests per hour.</p>
<p>If we compose and send the same request 7 times more, we will accumulate 11 requests and we will will receive an HTTP <kbd>429 Too many requests</kbd> status code in the response header, a message indicating that the request was throttled and the time in which the server will be able to process an additional request after the last execution.</p>
<p>Now, we will compose and send the following HTTP <kbd>GET</kbd> request without authentication credentials to retrieve the first page of the drones collection 20 times:</p>
<pre>    <strong>http :8000/drones/</strong></pre>
<p>We can use the features of the shell in macOS or Linux to run the previous command 20 times with just a single line with a bash shell. The command is compatible with a Cygwin terminal in Windows:</p>
<pre>    <strong>for i in {1..20}; do http :8000/drones/; done;</strong></pre>
<p>The following line allows you to run the command 20 times with a single line in Windows PowerShell:</p>
<pre>    <strong>1..21 | foreach { http :8000/drones/ }</strong>
  </pre>
<p>The following is the equivalent curl command that we must execute 20 times:</p>
<pre>    <strong>curl -iX GET localhost:8000/drones/</strong></pre>
<p>The following is the equivalent curl command that is executed 20 times with a single line in a bash shell in macOS or Linux, or a Cygwin terminal in Windows:</p>
<pre>    <strong>for i in {1..21}; do curl -iX GET localhost:8000/drones/; done;</strong></pre>
<p>The following is the equivalent curl command that is executed 20 times with a single line in Windows PowerShell:</p>
<pre>    <strong>1..20 | foreach { curl -iX GET localhost:8000/drones/ }</strong></pre>
<p>The Django REST framework will process the 20 requests. The <kbd>DroneList</kbd> class has its <kbd>throttle_scope</kbd> class attribute set to <kbd>'drones'</kbd> and uses the <kbd>ScopedRateThrottle</kbd> class to accumulate the requests in the specified scope. The <kbd>'drones'</kbd> scope is configured to accept a maximum of 20 requests per hour, and therefore, if we make another request with the same non-authenticated user and this request accumulates in the same scope, the request will be throttled.</p>
<p>Now, we will compose and send an HTTP <kbd>GET</kbd> request to retrieve the details for a drone. Make sure you replace <kbd>1</kbd> for any existing drone ID value that was listed in the results for the previous requests:</p>
<pre>    <strong>http :8000/drones/1</strong></pre>
<p>The following is the equivalent curl command:</p>
<pre>    <strong>curl -iX GET localhost:8000/drones/1</strong></pre>
<p>The Django REST framework won't process this request. The request ends up routed to the <kbd>DroneDetail</kbd> class. The <kbd>DroneDetail</kbd> class has its <kbd>throttle_scope</kbd> class attribute set to <kbd>'drones'</kbd> and uses the <kbd>ScopedRateThrottle</kbd> class to accumulate the requests in the specified scope. Thus, both the <kbd>DroneList</kbd> and the <kbd>DroneDetail</kbd> class accumulate in the same scope. The new request from the same non-authenticated user becomes the request number 21 for the <kbd>'drones'</kbd> scope that is configured to accept a maximum of 20 requests per hour, and therefore, we will receive an HTTP <kbd>429 Too many requests</kbd> status code in the response header and a message indicating that the request was throttled and the time in which the server will be able to process an additional request. The value for the <kbd>Retry-After</kbd> key in the response header provides the number of seconds that we must wait until the next request: <kbd>3138</kbd>. The following lines show a sample response. Notice that the number of seconds might be different in your configuration:</p>
<pre>    <strong>HTTP/1.0 429 Too Many Requests</strong>
    <strong>Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS</strong>
    <strong>Content-Length: 71</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Mon, 04 Dec 2017 03:55:14 GMT</strong>
    <strong>Retry-After: 3138</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>Vary: Accept, Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "detail": "Request was throttled. Expected available in 3138 seconds."</strong>
    <strong>}</strong></pre>
<div class="packt_tip">Throttling rules are extremely important to make sure that users don't abuse our RESTful Web Service and that we keep control of the resources that are being used to process incoming requests. We should never put a RESTful Web Service in production without a clear configuration for throttling rules.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding versioning classes</h1>
                </header>
            
            <article>
                
<p>Sometimes, we have to keep many different versions of a RESTful Web Service alive at the same time. For example, we might need to have version 1 and version 2 of our RESTful Web Service accepting and processing requests. There are many versioning schemes that make it possible to serve many versions of a web service.</p>
<p>The Django REST framework provides five classes in the <kbd>rest_framework.versioning</kbd> module. All of them are subclasses of the <kbd>BaseVersioning</kbd> class. The five classes allow us to work with a specific versioning scheme.</p>
<p>We can use one of these classes in combination with changes in the URL configurations and other pieces of code to support the selected versioning scheme. Each class is responsible for determining the version based on the implemented schema and to make sure that the specified version number is a valid one based on the allowed version settings. The classes provide different mechanisms to determine the version number. The following are the five versioning classes:</p>
<ul>
<li><kbd>AcceptHeaderVersioning</kbd>: This class configures a versioning scheme that requires each request to specify the desired version as an additional value of the media type specified as a value for the <kbd>Accept</kbd> key in the header. For example, if a request specifies <kbd>'application/json; version=1.2'</kbd> as the value for the <kbd>Accept</kbd> key in the header, the <kbd>AcceptHeaderVersioning</kbd> class will set the <kbd>request.version</kbd> attribute to <kbd>'1.2'</kbd>. This scheme is known as media type versioning, content negotiation versioning or accept header versioning.</li>
<li><kbd>HostNameVersioning</kbd>: This class configures a versioning scheme that requires each request to specify the desired version as a value included in the hostname in the URL. For example, if a request specifies <kbd>v2.myrestfulservice.com/drones/</kbd> as the URL, it means that the request wants to work with version number 2 of the RESTful Web Service. This scheme is known as hostname versioning or domain versioning.</li>
<li><kbd>URLPathVersioning</kbd>: This class configures a versioning scheme that requires each request to specify the desired version as a value included in the URL path. For example, if a request specifies <kbd>v2/myrestfulservice.com/drones/</kbd> as the URL, it means that the request wants to work with version number 2 of the RESTful Web Service. The class requires us to work with a <kbd>version</kbd> URL keyword argument. This scheme is known as URI versioning or URL path versioning.</li>
<li><kbd>NamespaceVersioning</kbd>: This class configures the versioning scheme explained for the <kbd>URLPathVersioning</kbd> class. The only difference compared with this other class is that the configuration in the Django REST framework application is different. In this case, it is necessary to use URL namespacing.</li>
<li><kbd>QueryParameterVersioning</kbd>: This class configures a versioning scheme that requires each request to specify the desired version as a query parameter. For example, if a request specifies <kbd>myrestfulservice.com/?version=1.2</kbd>, the <kbd>QueryParameterVersioning</kbd> class will set the <kbd>request.version</kbd> attribute to <kbd>'1.2'</kbd>. This scheme is known as query parameter versioning or request parameter versioning.</li>
</ul>
<p>The previous classes are included in the Django REST framework out of the box. It is also possible to code our own customized versioning scheme. Each versioning scheme has its advantages and trade-offs. In this case, we will work with the <kbd>NamespaceVersioning</kbd> class to provide a new version of the RESTful Web Service with a minor change compared to the first version. However, it is necessary to analyze carefully whether you really need to use any versioning scheme. Then, you need to figure out which is the most appropriate one based on your specific needs. Of course, if possible, we should always avoid any versioning scheme because they add complexity to our RESTful Web Service.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring a versioning scheme</h1>
                </header>
            
            <article>
                
<p>Let's imagine we have to serve the following two versions of our RESTful Web Service:</p>
<ul>
<li><strong>Version 1</strong>: The version we have developed so far. However, we want to make sure that the clients understand that they are working with version 1, and therefore, we want to include a reference to the version number in the URL for each HTTP request.</li>
<li><strong>Version 2</strong>: This version has to allow clients to reference the drones resource collection with the <kbd>vehicles</kbd> name instead of <kbd>drones</kbd>. In addition, the drone categories resource collection must be accessed with the <kbd>vehicle-categories</kbd> name instead of <kbd>drone-categories</kbd>. We also want to make sure that the clients understand that they are working with version 2, and therefore, we want to include a reference to the version number in the URL for each HTTP request.</li>
</ul>
<p>The difference between the second and the first version will be minimal because we want to keep the example simple. In this case, we will take advantage of the previously explained <kbd>NamespaceVersioning</kbd> class to configure a <kbd>URL path versioning scheme.</kbd></p>
<p>Make sure you quit the Django's development server. Remember that you just need to press <em><span class="KeyPACKT">Ctrl + C</span></em> in the terminal or command prompt window in which it is running.</p>
<p>We will make the necessary changes to configure the usage of the <kbd>NameSpaceVersioning</kbd> class as the default versioning class for our RESTful Web Service. Open the <kbd>restful01/restful01/settings.py</kbd> file that declares module-level variables that define the configuration of Django for the <kbd>restful01</kbd> project. We will make some changes to this Django settings file. Add the highlighted lines to the <kbd>REST_FRAMEWORK</kbd> dictionary. The following lines show the new declaration of the <kbd>REST_FRAMEWORK</kbd> dictionary. The code file for the sample is included in the <kbd>hillar_django_restful_09_02</kbd> folder in the <kbd>restful01/restful01/settings.py</kbd> file:</p>
<pre>REST_FRAMEWORK = { 
    'DEFAULT_PAGINATION_CLASS': 
    'drones.custompagination.LimitOffsetPaginationWithUpperBound', 
    'PAGE_SIZE': 4, 
    'DEFAULT_FILTER_BACKENDS': ( 
        'django_filters.rest_framework.DjangoFilterBackend', 
        'rest_framework.filters.OrderingFilter', 
        'rest_framework.filters.SearchFilter', 
        ), 
    'DEFAULT_AUTHENTICATION_CLASSES': ( 
        'rest_framework.authentication.BasicAuthentication', 
        'rest_framework.authentication.SessionAuthentication', 
        ), 
    'DEFAULT_THROTTLE_CLASSES': ( 
        'rest_framework.throttling.AnonRateThrottle', 
        'rest_framework.throttling.UserRateThrottle', 
    ), 
    'DEFAULT_THROTTLE_RATES': { 
        'anon': '3/hour', 
        'user': '10/hour', 
        'drones': '20/hour', 
        'pilots': '15/hour', 
    } 
    <strong>'DEFAULT_VERSIONING_CLASS':  
        'rest_framework.versioning.NamespaceVersioning', 
}</strong> </pre>
<p>We added a value for the <kbd>DEFAULT_VERSIONING_CLASS</kbd> settings key to configure the default versioning class that we want to use. As happened whenever we added values for settings keys, the new configuration will be applied to all the views as a global setting that we are able to override if necessary in specific classes.</p>
<p>Create a new sub-folder named <kbd>v2</kbd> within the <kbd>restful01/drones</kbd> folder (<kbd>restful01\drones</kbd> in Windows). This new folder will be the baseline for the specific code required for version 2 of our RESTful Web Service.</p>
<p>Go to the recently created <kbd>restful01/drones/v2</kbd> folder and create a new file named <kbd>views.py</kbd>. Write the following code in this new file. The following lines show the code for this file that creates the new <kbd>ApiRootVersion2</kbd> class declared as a subclass of the <kbd>generics.GenericAPIView</kbd> class. The code file for the sample is included in the <kbd>hillar_django_restful_09_02</kbd> folder in the <kbd>restful01/drones/v2/views.py</kbd> file.</p>
<pre>from rest_framework import generics 
from rest_framework.response import Response 
from rest_framework.reverse import reverse 
from drones import views 
 
 
class ApiRootVersion2(generics.GenericAPIView): 
    name = 'api-root' 
    def get(self, request, *args, **kwargs): 
        return Response({ 
            'vehicle-categories': reverse(views.DroneCategoryList.name, request=request), 
            'vehicles': reverse(views.DroneList.name, request=request), 
            'pilots': reverse(views.PilotList.name, request=request), 
            'competitions': reverse(views.CompetitionList.name, request=request) 
            }) </pre>
<p>The <kbd>ApiRootVersion2</kbd> class is a subclass of the <kbd>rest_framework.generics.GenericAPIView</kbd> class and declares the <kbd>get</kbd> method. As we learned in <em><a href="dj-rst-websvc_ch16.html">Chapter 6</a>, Working with Advanced Relationships and Serialization</em>, the <kbd>GenericAPIView</kbd> class is the base class for all the generic views we have been working with. We will make the Django REST framework use this class instead of the <kbd>ApiRoot</kbd> class when the requests work with version 2.</p>
<p>The <kbd>ApiRootVersion2</kbd> class defines the <kbd>get</kbd> method that returns a <kbd>Response</kbd> object with key/value pairs of strings that provide a descriptive name for the view and its URL, generated with the <kbd>rest_framework.reverse.reverse</kbd> function. This URL resolver function returns a fully qualified URL for the view. Whenever we call the <kbd>reverse</kbd> function, we include the <kbd>request</kbd> value for the <kbd>request</kbd> argument. It is very important to do this in order to make sure that the <kbd>NameSpaceVersioning</kbd> class can work as expected to configure the versioning scheme.</p>
<p>In this case, the response defines keys named <kbd>'vehicle-categories'</kbd> and <kbd>'vehicles'</kbd> instead of the <kbd>'drone-cagories'</kbd> and <kbd>'drones'</kbd> keys that are included in the <kbd>views.py</kbd> file, in the <kbd>ApiRoot</kbd> class that will be used for version 1.</p>
<p>Now, go to the recently created <kbd>restful01/drones/v2</kbd> folder and create a new file named <kbd>urls.py</kbd>. Write the following code in this new file. The following lines show the code for this file that declares the <kbd>urlpatterns</kbd> array. The lines that are different compared to the first version are highlighted. The code file for the sample is included in the <kbd>hillar_django_restful_09_02</kbd> folder in the <kbd>restful01/drones/v2/urls.py</kbd> file.</p>
<pre>from django.conf.urls import url 
from drones import views 
from drones.v2 import views as views_v2 
 
 
urlpatterns = [ 
    <strong>url(r'^vehicle-categories/$',  
        views.DroneCategoryList.as_view(),  
        name=views.DroneCategoryList.name), 
    url(r'^vehicle-categories/(?P&lt;pk&gt;[0-9]+)$',  
        views.DroneCategoryDetail.as_view(), 
        name=views.DroneCategoryDetail.name), 
    url(r'^vehicles/$',  
        views.DroneList.as_view(), 
        name=views.DroneList.name), 
    url(r'^vehicles/(?P&lt;pk&gt;[0-9]+)$',  
        views.DroneDetail.as_view(), 
        name=views.DroneDetail.name),</strong> 
    url(r'^pilots/$',  
        views.PilotList.as_view(), 
        name=views.PilotList.name), 
    url(r'^pilots/(?P&lt;pk&gt;[0-9]+)$',  
        views.PilotDetail.as_view(), 
        name=views.PilotDetail.name), 
    url(r'^competitions/$',  
        views.CompetitionList.as_view(), 
        name=views.CompetitionList.name), 
    url(r'^competitions/(?P&lt;pk&gt;[0-9]+)$',  
        views.CompetitionDetail.as_view(), 
        name=views.CompetitionDetail.name), 
    url(r'^$', 
        views_v2.ApiRootVersion2.as_view(), 
        name=views_v2.ApiRootVersion2.name), 
] </pre>
<p>The previous code defines the URL patterns that specify the regular expressions that have to be matched in the request to run a specific method for a class-based view defined in the original version of the <kbd>views.py</kbd> file. We want version 2 to use <kbd>vehicle-categories</kbd> and <kbd>vehicles</kbd> instead of <kbd>drone-categories</kbd> and <kbd>drones</kbd>. However, we won't make changes in the serializer, and therefore, we will only change the URL that the clients must use to make requests related to drone categories and drones.</p>
<p>Now, we have to replace the code in the <kbd>urls.py</kbd> file in the <kbd>restful01/restful01</kbd> folder, specifically, the <kbd>restful01/restful01/urls.py</kbd> file. The file defines the root URL configurations, and therefore, we must include the URL patterns for the two versions declared in the <kbd>restful01/drones/urls.py</kbd> and in the <kbd>restful01/drones/v2/urls.py</kbd>. The following lines show the new code for the <kbd>restful01/restful01/urls.py</kbd> file. The code file for the sample is included in the <kbd>hillar_django_restful_09_02</kbd> folder, in the <kbd>restful01/restful01/urls.py</kbd> file.</p>
<pre>from django.conf.urls import url, include 
 
urlpatterns = [ 
    url(r'^v1/', include('drones.urls', namespace='v1')), 
    url(r'^v1/api-auth/', include('rest_framework.urls', namespace='rest_framework_v1')), 
    url(r'^v2/', include('drones.v2.urls', namespace='v2')), 
    url(r'^v2/api-auth/', include('rest_framework.urls', namespace='rest_framework_v2')), 
] </pre>
<p>Whenever a URL starts with <kbd>v1/</kbd>, the url patterns defined for the previous version will be used and the <kbd>namespace</kbd> will be set to <kbd>'v1'</kbd>. Whenever a URL starts with <kbd>v2/</kbd>, the url patterns defined for version 2 will be used and the namespace will be set to <kbd>'v2'</kbd>. We want the browsable API to display the log in and log out views for the two versions, and therefore, we included the necessary code to include the definitions included in <kbd>rest_framework.urls</kbd> for each of the versions, with different namespaces. This way, we will be able to easily test the two versions with the browsable API and the configured authentication.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running tests to check that versioning works as expected</h1>
                </header>
            
            <article>
                
<p>Now, we can launch Django's development server to compose and send HTTP requests to understand how the configured versioning scheme works. Execute any of the following two commands based on your needs to access the API in other devices or computers connected to your LAN. Remember that we analyzed the difference between them in <a href="dj-rst-websvc_ch13.html" target="_blank">Chapter 3</a>,&#160;<em>Creating API Views</em>, in the <em>Launching Django's development server</em> section.</p>
<pre>    <strong>python manage.py runserver</strong>
    <strong>python manage.py runserver 0.0.0.0:8000</strong></pre>
<p>After we run any of the previous commands, the development server will start listening at port <kbd>8000</kbd>.</p>
<p>Now, we will compose and send an HTTP <kbd>GET</kbd> request to retrieve the first page of the drone categories by working with the first version of our RESTful Web Service:</p>
<pre>    <strong>http :8000/v1/drone-categories/</strong></pre>
<p>The following is the equivalent curl command:</p>
<pre>    <strong>curl -iX GET localhost:8000/v1/drone-categories/</strong></pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>GET http://localhost:8000/v1/drone-categories/</kbd>. The request URL starts with <kbd>v1/</kbd> after the domain and the port number (<kbd>http://localhost:8000/</kbd>), and therefore, it will match the <kbd>'^v1/'</kbd> regular expression and will test the regular expressions defined in the <kbd>restful01/drones/urls.py</kbd> file and will work with a namespace equal to <kbd>'v1'</kbd>. Then, the URL without the version prefix (<kbd>'v1/'</kbd>) will match the <kbd>'drone-categories/$'</kbd>regular expression and run the <kbd>get</kbd> method for the <kbd>views.DroneCategoryList</kbd> class-based view.</p>
<p>The <kbd>NamespaceVersioning</kbd> class makes sure that the rendered URLs include the appropriate version prefix in the response. The following lines show a sample response for the HTTP request, with the first and only page of drone categories. Notice that the URLs for the drones list for each category include the version prefix. In addition, the value of the <kbd>url</kbd> key for each drone category includes the version prefix.</p>
<pre>    <strong>HTTP/1.0 200 OK</strong>
    <strong>Allow: GET, POST, HEAD, OPTIONS</strong>
    <strong>Content-Length: 670</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Sun, 03 Dec 2017 19:34:13 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>Vary: Accept, Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "count": 2, </strong>
    <strong>    "next": null, </strong>
    <strong>    "previous": null, </strong>
    <strong>    "results": [</strong>
    <strong>        {</strong>
    <strong>            "drones": [</strong>
    <strong>                "http://localhost:8000/v1/drones/6", </strong>
    <strong>                "http://localhost:8000/v1/drones/4", </strong>
    <strong>                "http://localhost:8000/v1/drones/8", </strong>
    <strong>                "http://localhost:8000/v1/drones/10"</strong>
    <strong>            ], </strong>
    <strong>            "name": "Octocopter", </strong>
    <strong>            "pk": 2, </strong>
    <strong>            "url": "http://localhost:8000/v1/drone-categories/2"</strong>
    <strong>        }, </strong>
    <strong>        {</strong>
    <strong>            "drones": [</strong>
    <strong>                "http://localhost:8000/v1/drones/2", </strong>
    <strong>                "http://localhost:8000/v1/drones/9", </strong>
    <strong>                "http://localhost:8000/v1/drones/5", </strong>
    <strong>                "http://localhost:8000/v1/drones/7", </strong>
    <strong>                "http://localhost:8000/v1/drones/3", </strong>
    <strong>                "http://localhost:8000/v1/drones/12", </strong>
    <strong>                "http://localhost:8000/v1/drones/11", </strong>
    <strong>                "http://localhost:8000/v1/drones/1"</strong>
    <strong>            ], </strong>
    <strong>            "name": "Quadcopter", </strong>
    <strong>            "pk": 1, </strong>
    <strong>            "url": "http://localhost:8000/v1/drone-categories/1"</strong>
    <strong>        }</strong>
    <strong>    ]</strong>
    <strong>}</strong>  </pre>
<p>Now, we will compose and send an HTTP <kbd>GET</kbd> request to retrieve the first page of the vehicle categories by working with the second version of our RESTful Web Service:</p>
<pre>    <strong>http :8000/v2/vehicle-categories/</strong></pre>
<p>The following is the equivalent curl command:</p>
<pre>    <strong>curl -iX GET localhost:8000/v2/vehicle-categories/</strong></pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>GET http://localhost:8000/v2/vehicle-categories/</kbd>. The request URL starts with <kbd>v2/</kbd> after the domain and the port number (<kbd>http://localhost:8000/</kbd>), and therefore, it will match the <kbd>'^v2/'</kbd> regular expression and will test the regular expressions defined in the <kbd>restful01/drones/v2/urls.py</kbd> file and will work with a namespace equal to <kbd>'v2'</kbd>. Then, the URL without the version prefix (<kbd>'v2/'</kbd>) will match the <kbd>'vehicle-categories/$'</kbd>regular expression and run the <kbd>get</kbd> method for the <kbd>views.DroneCategoryList</kbd> class-based view.</p>
<p>As happened with the previous request, the <kbd>NamespaceVersioning</kbd> class makes sure that the rendered URLs include the appropriate version prefix in the response. The following lines show a sample response for the HTTP request, with the first and only page of vehicle categories. We haven't made changes to the serializer in the new version, and therefore, each category will render a list named <kbd>drones</kbd>. However, the URLs for the drones list for each category include the version prefix and they use the appropriate URL with a <kbd>vehicle</kbd> in the URL instead of a drone. In addition, the value of the <kbd>url</kbd> key for each vehicle category includes the version prefix.</p>
<pre>    <strong>HTTP/1.0 200 OK</strong>
    <strong>Allow: GET, POST, HEAD, OPTIONS</strong>
    <strong>Content-Length: 698</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Sun, 03 Dec 2017 19:34:29 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>Vary: Accept, Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "count": 2, </strong>
    <strong>    "next": null, </strong>
    <strong>    "previous": null, </strong>
    <strong>    "results": [</strong>
    <strong>        {</strong>
    <strong>            "drones": [</strong>
    <strong>                "http://localhost:8000/v2/vehicles/6", </strong>
    <strong>                "http://localhost:8000/v2/vehicles/4", </strong>
    <strong>                "http://localhost:8000/v2/vehicles/8", </strong>
    <strong>                "http://localhost:8000/v2/vehicles/10"</strong>
    <strong>            ], </strong>
    <strong>            "name": "Octocopter", </strong>
    <strong>            "pk": 2, </strong>
    <strong>            "url": "http://localhost:8000/v2/vehicle-categories/2"</strong>
    <strong>        }, </strong>
    <strong>        {</strong>
    <strong>            "drones": [</strong>
    <strong>                "http://localhost:8000/v2/vehicles/2", </strong>
    <strong>                "http://localhost:8000/v2/vehicles/9", </strong>
    <strong>                "http://localhost:8000/v2/vehicles/5", </strong>
    <strong>                "http://localhost:8000/v2/vehicles/7", </strong>
    <strong>                "http://localhost:8000/v2/vehicles/3", </strong>
    <strong>                "http://localhost:8000/v2/vehicles/12", </strong>
    <strong>                "http://localhost:8000/v2/vehicles/11", </strong>
    <strong>                "http://localhost:8000/v2/vehicles/1"</strong>
    <strong>            ], </strong>
    <strong>            "name": "Quadcopter", </strong>
    <strong>            "pk": 1, </strong>
    <strong>            "url": "http://localhost:8000/v2/vehicle-categories/1"</strong>
    <strong>        }</strong>
    <strong>    ]</strong>
    <strong>}</strong></pre>
<p>Open a web browser and enter <kbd>http://localhost:8000/v1</kbd>. The browser will compose and send a <kbd>GET</kbd> request to <kbd>/v1</kbd> with <kbd>text/html</kbd> as the desired content type and the returned HTML web page will be rendered. The request will end up executing the <kbd>get</kbd> method defined in the <kbd>ApiRoot</kbd> class within the <kbd>restful01/drones/views.py</kbd> file. The following screenshot shows the rendered web page with the resource description: <span class="packt_screen">Api Root</span>. The Api Root for the first version uses the appropriate URLs for version 1, and therefore, all the URLs start with <kbd>http://localhost:8000/v1/</kbd>.</p>
<div class="CDPAlignCenter CDPAlign"><img height="296" width="476" src="images/b03ca25a-db69-4fe5-a709-08da995e95a0.png"/></div>
<p>Now, go to <kbd>http://localhost:8000/v2</kbd>. The browser will compose and send a <kbd>GET</kbd> request to <kbd>/v2</kbd> with <kbd>text/html</kbd> as the desired content type and the returned HTML web page will be rendered. The request will end up executing the <kbd>get</kbd> method defined in the <kbd>ApiRootVersion2</kbd> class within the <kbd>restful01/drones/v2/views.py</kbd> file. The following screenshot shows the rendered web page with the resource description: <span class="packt_screen">Api Root Version2</span>. The Api Root for the first version uses the appropriate URLs for version 2, and therefore, all the URLs start with <kbd>http://localhost:8000/v2/</kbd>. You can check the differences with the Api Root rendered for version 1.</p>
<div class="CDPAlignCenter CDPAlign"><img height="341" width="547" src="images/2d9c65a1-f6a5-41ea-904e-847a463e6510.png"/></div>
<p>This new version of the Api Root renders the following hyperlinks:</p>
<ul>
<li><kbd>http://localhost:8000/v2/vehicle-categories/</kbd>: The collection of vehicle categories</li>
<li><kbd>http://localhost:8000/v2/vehicles/</kbd>: The collection of vehicles</li>
<li><kbd>http://localhost:8000/v2/pilots/</kbd>: The collection of pilots</li>
<li><kbd>http://localhost:8000/v2/competitions/</kbd>: The collection of competitions</li>
</ul>
<p>We can use all the features provided by the browsable API with the two versions we have configured.</p>
<div class="packt_tip">Developing and maintaining multiple versions of a RESTful Web Service is an extremely complex task that requires a lot of planning. We must take into account the different versioning schemes that the Django REST framework provides out of the box to make our job simpler. However, it is always very important to avoid making things more complex than necessary. We should keep any versioning scheme as simple as possible and we must make sure that we continue to provide RESTful Web Services with easily identifiable resources and resource collections in the URLs.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test your knowledge</h1>
                </header>
            
            <article>
                
<p>Let's see whether you can answer the following questions correctly:</p>
<ol>
<li>The <kbd>rest_framework.throttling.UserRateThrottle</kbd> class:
<ol>
<li>Limits the rate of requests that a specific user can make and applies to <em>both authenticated and non-authenticated users</em></li>
<li>Limits the rate of requests that a specific user can make and applies <em>only to authenticated users</em></li>
<li>Limits the rate of requests that a specific user can make and applies <em>only to non-authenticated users</em></li>
</ol>
</li>
<li>Which of the following settings key in the <kbd>REST_FRAMEWORK</kbd> dictionary specifies the global setting with a tuple of string whose values indicate the classes that we want to use for throttling rules:
<ol>
<li><kbd>'DEFAULT_THROTTLE_CLASSES'</kbd></li>
<li><kbd>'GLOBAL_THROTTLE_CLASSES'</kbd></li>
<li><kbd>'REST_FRAMEWORK_THROTTLE_CLASSES'</kbd></li>
</ol>
</li>
<li>Which of the following settings key in the <kbd>REST_FRAMEWORK</kbd> dictionary specifies a dictionary with the default throttle rates:
<ol>
<li><kbd>'GLOBAL_THROTTLE_RATES'</kbd></li>
<li><kbd>'DEFAULT_THROTTLE_RATES'</kbd></li>
<li><kbd>'REST_FRAMEWORK_THROTTLE_RATES'</kbd></li>
</ol>
</li>
<li>The <kbd>rest_framework.throttling.ScopedRateThrottle</kbd> class:
<ol>
<li>Limits the rate of requests that an anonymous user can make</li>
<li>Limits the rate of requests that a specific user can make</li>
<li>Limits the rate of requests for specific parts of the RESTful Web Service identified with the value assigned to the&#160;<kbd>throttle_scope</kbd> property</li>
</ol>
</li>
</ol>
<p class="mce-root"></p>
<ol start="5">
<li>The <kbd>rest_framework.versioning.NamespaceVersioning</kbd> class configures a versioning scheme known as:
<ol>
<li>Query parameter versioning or request parameter versioning</li>
<li>Media type versioning, content negotiation versioning or accept header versioning</li>
<li>URI versioning or URL path versioning</li>
</ol>
</li>
</ol>
<p>&#160;</p>
<p><span>The rights answers are included in the <a href="https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&amp;action=edit#post_454" target="_blank">Appendix</a>,&#160;<em>Solutions</em>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we understood the importance of throttling rules and how we can combine them with authentication and permissions in Django, the Django REST framework and RESTful Web Services. We analyzed the throttling classes included in the Django REST framework out of the box.</p>
<p>We followed the necessary steps to configure many throttling policies in the Django REST framework. We worked with global and scope-related settings. Then, we used command-line tools to compose and send many requests to test how the throttling rules worked.</p>
<p>We understood versioning classes and we configured a URL path versioning scheme to allow us to work with two versions of our RESTful Web Service. We used command-line tools and the browsable API to understand the differences between the two versions.</p>
<p>Now that we can combine throttling rules, authentication and permission policies with versioning schemes, it is time to explore other features offered by the Django REST framework and third-party packages to improve our RESTful Web Service and automate tests. We will cover these topics in the next chapter.</p>
<p class="mce-root"></p>


            </article>

            
        </section>
    </div>
</body>
</html>