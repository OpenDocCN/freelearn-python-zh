- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharing Content on Your Website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you added success and error messages to your site using
    the Django messages framework. You also created an email authentication backend
    and added social authentication to your site using Google. You learned how to
    run your development server with HTTPS on your local machine using Django Extensions.
    You customized the social authentication pipeline to create a user profile for
    new users automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create a JavaScript bookmarklet to share
    content from other sites on your website, and you will implement asynchronous
    browser requests in your project using JavaScript and Django.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating many-to-many relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing behavior for forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JavaScript with Django
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a JavaScript bookmarklet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating image thumbnails using `easy-thumbnails`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing asynchronous HTTP requests with JavaScript and Django
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building infinite scroll pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, you will create an image bookmarking system. You will create
    models with many-to-many relationships and customize the behavior of forms. You
    will learn how to generate image thumbnails and how to build asynchronous browser
    functionalities using JavaScript and Django.
  prefs: []
  type: TYPE_NORMAL
- en: Functional overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Figure 6.1* shows a representation of the views, templates, and functionalities
    that will be built in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Diagram of functionalities built in Chapter 6'
  prefs: []
  type: TYPE_NORMAL
- en: In the chapter, you will implement a **Bookmark it** button that will allow
    users to bookmark images from any website. You will use JavaScript to display
    an image selector on top of any website for users to select an image to bookmark.
    You will implement the `image_create` view and a form to retrieve the image from
    its original source and store it on your website. You will build the `image_detail`
    view to display single images and you will generate image thumbnails automatically
    using the `easy-thumbnails` package. You will also implement the `image_like`
    view to allow users to *like/unlike* images. This view will handle asynchronous
    HTTP requests performed with JavaScript and return a response in JSON format.
    You will finally create the `image_list` view to display all bookmarked images
    and you will implement an infinite scroll using JavaScript and Django pagination.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter06](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: All Python packages used in this chapter are included in the `requirements.txt`
    file in the source code for the chapter. You can follow the instructions to install
    each Python package in the following sections, or you can install all requirements
    at once with the `python -m pip install -r requirements.txt` command.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an image bookmarking website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now learn how to allow users to bookmark images that they find on other
    websites and share them on our site. To build this functionality, we will need
    the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A data model to store images and related information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A form and a view to handle image uploads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript bookmarklet code that can be executed on any website. This code will
    find images across the page and allow users to select the image they want to bookmark.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, create a new application inside your `bookmarks` project directory by
    running the following command in the shell prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the new application to the `INSTALLED_APPS` setting in the `settings.py`
    file of the project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have activated the `images` application in the project.
  prefs: []
  type: TYPE_NORMAL
- en: Building the image model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit the `models.py` file of the `images` application and add the following
    code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the model that we will use to store images in the platform. Let’s take
    a look at the fields of this model:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user`: This indicates the `User` object that bookmarked this image. This is
    a foreign key field because it specifies a many-to-one relationship: a user can
    post multiple images, but each image is posted by a single user. We have used
    `CASCADE` for the `on_delete` parameter so that related images are deleted when
    a user is deleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: A title for the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slug`: A short label that contains only letters, numbers, underscores, or
    hyphens to be used for building beautiful SEO-friendly URLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url`: The original URL for this image. We use `max_length` to define a maximum
    length of `2000` characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image`: The image file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: An optional description for the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created`: The date and time that indicate when the object was created in the
    database. We have added `auto_now_add` to automatically set the current datetime
    when the object is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Meta` class of the model, we have defined a database index in descending
    order for the `created` field. We have also added the `ordering` attribute to
    tell Django that it should sort results by the `created` field by default. We
    indicate descending order by using a hyphen before the field name, such as `-created`,
    so that new images will be displayed first.
  prefs: []
  type: TYPE_NORMAL
- en: Database indexes improve query performance. Consider creating indexes for fields
    that you frequently query using `filter()`, `exclude()`, or `order_by()`. `ForeignKey`
    fields or fields with `unique=True` imply the creation of an index. You can learn
    more about database indexes at [https://docs.djangoproject.com/en/5.0/ref/models/options/#django.db.models.Options.indexes](https://docs.djangoproject.com/en/5.0/ref/models/options/#django.db.models.Options.indexes).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will override the `save()` method of the `Image` model to automatically
    generate the `slug` field based on the value of the `title` field. Import the
    `slugify()` function and add a `save()` method to the `Image` model, as follows.
    New lines are highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When an `Image` object is saved, if the `slug` field doesn’t have a value, the
    `slugify()` function is used to automatically generate a slug from the `title`
    field of the image. The object is then saved. By generating slugs automatically
    from the title, users won’t have to provide a slug when they share images on our
    website.
  prefs: []
  type: TYPE_NORMAL
- en: Creating many-to-many relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we will add another field to the `Image` model to store the users who
    like an image. We will need a many-to-many relationship in this case because a
    user might like multiple images and each image can be liked by multiple users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following field to the `Image` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we define a `ManyToManyField` field, Django creates an intermediary join
    table using the primary keys of both models. *Figure 6.2* shows the database table
    that will be created for this relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Intermediary database table for the many-to-many relationship'
  prefs: []
  type: TYPE_NORMAL
- en: The `images_image_users_like` table is created by Django as an intermediary
    table that has references to the `images_image` table (`Image` model) and `auth_user`
    table (`User` model). The `ManyToManyField` field can be defined in either of
    the two related models.
  prefs: []
  type: TYPE_NORMAL
- en: As with `ForeignKey` fields, the `related_name` attribute of `ManyToManyField`
    allows you to name the relationship from the related object back to this one.
    `ManyToManyField` fields provide a many-to-many manager that allows you to retrieve
    related objects, such as `image.users_like.all()`, or get them from a `user` object,
    such as `user.images_liked.all()`.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about many-to-many relationships at [https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the shell prompt and run the following command to create an initial migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the following command to apply your migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get an output that includes the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Image` model is now synced to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Registering the image model in the administration site
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit the `admin.py` file of the `images` application and register the `Image`
    model into the administration site, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the development server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `https://127.0.0.1:8000/admin/` in your browser, and you will see the
    `Image` model in the administration site, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: The Images block on the Django administration site index page'
  prefs: []
  type: TYPE_NORMAL
- en: You have completed the model to store images. Now you will learn how to implement
    a form to retrieve images by their URL and store them using the `Image` model.
  prefs: []
  type: TYPE_NORMAL
- en: Posting content from other websites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will allow users to bookmark images from external websites and share them
    on our site. Users will provide the URL of the image, a title, and an optional
    description. We will create a form and a view to download the image and create
    a new `Image` object in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by building a form to submit new images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `forms.py` file inside the `images` application directory and
    add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We have defined a `ModelForm` form from the `Image` model, including only the
    `title`, `url`, and `description` fields. Users will not enter the image URL directly
    in the form. Instead, we will provide them with a JavaScript tool to choose an
    image from an external site, and the form will receive the image’s URL as a parameter.
    We have overridden the default widget of the `url` field to use a `HiddenInput`
    widget. This widget is rendered as an HTML `input` element with a `type="hidden"`
    attribute. We use this widget because we don’t want this field to be visible to
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning form fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to verify that the provided image URL is valid, we will check that
    the filename ends with a `.jpg`, `.jpeg`, or `.png` extension to allow sharing
    JPEG and PNG files only. In the previous chapter, we used the `clean_<fieldname>()`
    convention to implement field validation. This method is executed for each field,
    if the field is present, when we call `is_valid()` on a form instance. In the
    `clean` method, you can alter the field’s value or raise any validation errors
    for the field.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `forms.py` file of the `images` application, add the following method
    to the `ImageCreateForm` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have defined a `clean_url()` method to clean the
    `url` field. The code works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `url` field is retrieved by accessing the `cleaned_data` dictionary
    of the form instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The URL is split to check whether the file has a valid extension. If the extension
    is invalid, a `ValidationError` is raised and the form instance is not validated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition to validating the given URL, we also need to download the image
    file and save it. We could, for example, use the view that handles the form to
    download the image file. Instead, let’s take a more general approach by overriding
    the `save()` method of the model form to perform this task when the form is saved.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Requests library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a user bookmarks an image, we will need to download the image file by its
    URL. We will use the Requests Python library for this purpose. Requests is the
    most popular HTTP library for Python. It abstracts the complexity of dealing with
    HTTP requests and provides a very simple interface to consume HTTP services. You
    can find the documentation for the Requests library at [https://requests.readthedocs.io/en/master/](https://requests.readthedocs.io/en/master/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the shell and install the Requests library with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We will now override the `save()` method of `ImageCreateForm` and use the Requests
    library to retrieve the image by its URL.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the save() method of a ModelForm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you know, `ModelForm` provides a `save()` method to save the current model
    instance to the database and return the object. This method receives a Boolean
    `commit` parameter, which allows you to specify whether the object has to be persisted
    to the database. If `commit` is `False`, the `save()` method will return a model
    instance but will not save it to the database. We will override the form’s `save()`
    method in order to retrieve the image file by the given URL and save it to the
    file system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following imports at the top of the `forms.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following `save()` method to the `ImageCreateForm` form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We have overridden the `save()` method, keeping the parameters required by
    `ModelForm`. The preceding code can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A new `image` instance is created by calling the `save()` method of the form
    with `commit=False`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The URL of the image is retrieved from the `cleaned_data` dictionary of the
    form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An image name is generated by combining the `image` title slug with the original
    file extension of the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Requests Python library is used to download the image by sending an HTTP
    `GET` request using the image URL. The response is stored in the `response` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `save()` method of the `image` field is called, passing it a `ContentFile`
    object that is instantiated with the downloaded file content. In this way, the
    file is saved to the media directory of the project. The `save=False` parameter
    is passed to prevent the object from being saved to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To maintain the same behavior as the original `save()` method of the model form,
    the form is only saved to the database if the `commit` parameter is `True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will need a view to create an instance of the form and handle its submission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `images` application and add the following
    code to it. New code is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have created a view to store images on the site.
    We have added the `login_required` decorator to the `image_create` view to prevent
    access to unauthenticated users. This is how this view works:'
  prefs: []
  type: TYPE_NORMAL
- en: Initial data has to be provided through a `GET` HTTP request in order to create
    an instance of the form. This data will consist of the `url` and `title` attributes
    of an image from an external website. Both parameters will be set in the `GET`
    request by the JavaScript bookmarklet that we will create later. For now, we can
    assume that this data will be available in the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the form is submitted with a `POST` HTTP request, it is validated with
    `form.is_valid()`. If the form data is valid, a new `image` instance is created
    by saving the form with `form.save(commit=False)`. The new instance is not saved
    to the database because of `commit=False`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A relationship to the current user performing the request is added to the new
    `image` instance with `new_image.user = request.user`. This is how we will know
    who uploaded each image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Image` object is saved to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, a success message is created using the Django messages framework and
    the user is redirected to the canonical URL of the new image. We haven’t yet implemented
    the `get_absolute_url()` method of the `Image` model; we will do that later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new `urls.py` file inside the `images` application and add the following
    code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the main `urls.py` file of the `bookmarks` project to include the patterns
    for the `images` application, as follows. The new code is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to create a template to render the form. Create the following
    directory structure inside the `images` application directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the new `create.html` template and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the development server with the following command in the shell prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `https://127.0.0.1:8000/images/create/?title=...&url=...` in your browser,
    including the `title` and `url` GET parameters, providing an existing JPEG image
    URL in the latter. For example, you can use the following URL: `https://127.0.0.1:8000/images/create/?title=%20Django%20and%20Duke&url=https://upload.wikimedia.org/wikipedia/commons/8/85/Django_Reinhardt_and_Duke_Ellington_%28Gottlieb%29.jpg`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the form with an image preview, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: The Bookmark an image bookmark page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a description and click on the **BOOKMARK IT!** button. A new `Image` object
    will be saved in your database. However, you will get an error that indicates
    that the `Image` model has no `get_absolute_url()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: An error showing that the Image object has no get_absolute_url
    attribute'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry about this error for now; we are going to implement the `get_absolute_url`
    method in the `Image` model later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `https://127.0.0.1:8000/admin/images/image/` in your browser and verify
    that the new `Image` object has been saved, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: The administration site image list page showing the created Image
    object'
  prefs: []
  type: TYPE_NORMAL
- en: Building a bookmarklet with JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bookmarklet is a bookmark stored in a web browser that contains JavaScript
    code to extend the browser’s functionality. When you click on the bookmark in
    the bookmarks or favorites bar of your browser, the JavaScript code is executed
    on the website being displayed in the browser. This is very useful for building
    tools that interact with other websites.
  prefs: []
  type: TYPE_NORMAL
- en: Some online services, such as Pinterest, implement their own bookmarklet to
    let users share content from other sites on their platforms. The Pinterest bookmarklet
    is implemented as a browser extension and is available at [https://help.pinterest.com/en/article/save-pins-with-the-pinterest-browser-button](https://help.pinterest.com/en/article/save-pins-with-the-pinterest-browser-button).
    The **Pinterest Save** extension allows users to save images or websites to their
    Pinterest account with just one click on the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: The Pinterest Save extension'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a bookmarklet in a similar way for your website. For that, we will
    be using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how your users will add the bookmarklet to their browser and use it:'
  prefs: []
  type: TYPE_NORMAL
- en: The user drags a link from your site to their browser’s bookmarks bar. The link
    contains JavaScript code in its `href` attribute. This code will be stored in
    the bookmark.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user navigates to any website and clicks on the bookmark in the bookmarks
    or favorites bar. The JavaScript code of the bookmark is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the JavaScript code will be stored as a bookmark, we will not be able
    to update it after the user has added it to their bookmarks bar. This is an important
    drawback that you can solve by implementing a launcher script. Users will save
    the launcher script as a bookmark, and the launcher script will load the actual
    JavaScript bookmarklet from a URL. By doing this, you will be able to update the
    code of the bookmarklet at any time. This is the approach that we will take to
    build the bookmarklet. Let’s start!
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new template under `images/templates/` and name it `bookmarklet_launcher.js`.
    This will be the launcher script. Add the following JavaScript code to the new
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding script checks whether the bookmarklet has already been loaded
    by checking the value of the `bookmarklet` window variable with `if(!window.bookmarklet)`:'
  prefs: []
  type: TYPE_NORMAL
- en: If `window.bookmarklet` is not defined or doesn’t have a truthy value (considered
    `true` in a Boolean context), a JavaScript file is loaded by appending a `<script>`
    element to the body of the HTML document loaded in the browser. The `src` attribute
    is used to load the URL of the `bookmarklet.js` script with a random 16-digit
    integer parameter generated with `Math.random()*9999999999999999`. Using a random
    number, we prevent the browser from loading the file from the browser’s cache.
    If the bookmarklet JavaScript has been previously loaded, the different parameter
    value will force the browser to load the script from the source URL again. This
    way, we make sure the bookmarklet always runs the most up-to-date JavaScript code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `window.bookmarklet` is defined and has a truthy value, the `bookmarkletLaunch()`
    function is executed. We will define `bookmarkletLaunch()` as a global function
    in the `bookmarklet.js` script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By checking the `bookmarklet` window variable, we prevent the bookmarklet JavaScript
    code from being loaded more than once if users click on the bookmarklet repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: You created the bookmarklet launcher code. The actual bookmarklet code will
    reside in the `bookmarklet.js` static file. Using launcher code allows you to
    update the bookmarklet code at any time without requiring users to change the
    bookmark they previously added to their browser.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add the bookmarklet launcher to the dashboard pages so that users can
    add it to the bookmarks bar of their browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `account/dashboard.html` template of the `account` application and
    make it look like the following. New lines are highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that no template tag is split over multiple lines; Django doesn’t
    support multiple-line tags.
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard now displays the total number of images bookmarked by the user.
    We have added a `{% with %}` template tag to create a variable with the total
    number of images bookmarked by the current user. We have included a link with
    an `href` attribute that contains the bookmarklet launcher script. This JavaScript
    code is loaded from the `bookmarklet_launcher.js` template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `https://127.0.0.1:8000/account/` in your browser. You should see the
    following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: The dashboard page, including the total images bookmarked and the
    button for the bookmarklet'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create the following directories and files inside the `images` application
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You will find a `static/css/` directory in the `images` application directory
    in the code that comes along with this chapter. Copy the `css/` directory into
    the `static/` directory of your code. You can find the contents of the directory
    at [https://github.com/PacktPublishing/Django-5-by-Example/tree/main/Chapter06/bookmarks/images/static](https://github.com/PacktPublishing/Django-5-by-Example/tree/main/Chapter06/bookmarks/images/static).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `css/bookmarklet.css` file provides the styles for the JavaScript bookmarklet.
    The `static/` directory should contain the following file structure now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `bookmarklet.js` static file and add the following JavaScript code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You have declared four different constants that will be used by the bookmarklet.
    These constants are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`siteUrl` and `staticUrl`: The base URL for the website and the base URL for
    static files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minWidth` and `minHeight`: The minimum width and height in pixels for the
    images that the bookmarklet will collect from the site. The bookmarklet will identify
    images that have at least `250px` width and `250px` height.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edit the `bookmarklet.js` static file and add the following code highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This section loads the CSS stylesheet for the bookmarklet. We use JavaScript
    to manipulate the **Document Object Model** (**DOM**). The DOM represents an HTML
    document in memory and it is created by the browser when a web page is loaded.
    The DOM is constructed as a tree of objects that comprise the structure and content
    of the HTML document.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code generates an object equivalent to the following JavaScript
    code and appends it to the `<head>` element of the HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s review how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: The `<head>` element of the site is retrieved with `document.getElementsByTagName()`.
    This function retrieves all HTML elements of the page with the given tag. By using
    `[0]`, we access the first instance found. We access the first element because
    all HTML documents should have a single `<head>` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `<link>` element is created with `document.createElement('link')`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `rel` and `type` attributes of the `<link>` element are set. This is equivalent
    to the HTML `<link rel="stylesheet" type="text/css">`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `href` attribute of the `<link>` element is set with the URL of the `bookmarklet.css`
    stylesheet. A 16-digit random number is used as a URL parameter to prevent the
    browser from loading the file from the cache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new `<link>` element is added to the `<head>` element of the HTML page using
    `head.appendChild(link)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will create the HTML element to display a `<div>` container on the website
    where the bookmarklet is executed. The HTML container will be used to display
    all images found on the site and let users choose the image they want to share.
    It will use the CSS styles defined in the `bookmarklet.css` stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `bookmarklet.js` static file and add the following code highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With this code, the `<body>` element of the DOM is retrieved and new HTML is
    added to it by modifying its property `innerHTML`. A new `<div>` element is added
    to the body of the page. The `<div>` container consists of the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A link to close the container defined with `<a href="#" id="close">&times;</a>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A title defined with `<h1>Select an image to bookmark:</h1>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `<div>` element to list the images found on the site defined with `<div class="images"></div>`.
    This container is initially empty and will be filled with the images found on
    the site.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The HTML container, including the previously loaded CSS styles, will look like
    *Figure 6.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: The image selection container'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s implement a function to launch the bookmarklet. Edit the `bookmarklet.js`
    static file and add the following code at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `bookmarkletLaunch()` function. Before the definition of this function,
    the CSS for the bookmarklet is loaded and the HTML container is added to the DOM
    of the page. The `bookmarkletLaunch()` function works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The bookmarklet’s main container is retrieved by getting the DOM element with
    the ID `bookmarklet` with `document.getElementById()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `bookmarklet` element is used to retrieve the child element with the class
    `images`. The `querySelector()` method allows you to retrieve DOM elements using
    CSS selectors. Selectors allow you to find DOM elements to which a set of CSS
    rules applies. You can find a list of CSS selectors at [https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors)
    and you can read more information about how to locate DOM elements using selectors
    at [https://developer.mozilla.org/en-US/docs/Web/API/Document_object_model/Locating_DOM_elements_using_selectors](https://developer.mozilla.org/en-US/docs/Web/API/Document_object_model/Locating_DOM_elements_using_selectors).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `images` container is cleared by setting its `innerHTML` attribute to an
    empty string and the bookmarklet is displayed by setting the `display` CSS property
    to `block`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `#close` selector is used to find the DOM element with the ID `close`. A
    `click` event is attached to the element with the `addEventListener()` method.
    When users click the element, the bookmarklet’s main container is hidden by setting
    its `display` property to `none`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `bookmarkletLaunch()` function is executed after its definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After loading the CSS styles and the HTML container of the bookmarklet, you
    have to find image elements in the DOM of the current website. Images that have
    the minimum required dimension have to be added to the HTML container of the bookmarklet.
    Edit the `bookmarklet.js` static file and add the following code highlighted in
    bold to the bottom of the `bookmarklet()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the `img[src$=".jpg"]`, `img[src$=".jpeg"]`, and `img[src$=".png"]`
    selectors to find all `<img>` DOM elements whose `src` attribute finishes with
    `.jpg`, `.jpeg`, or, `.png`, respectively. Using these selectors with `document.querySelectorAll()`
    allows you to find all images in JPEG and PNG format displayed on the website.
    Iteration over the results is performed with the `forEach()` method. Small images
    are filtered out because we don’t consider them to be relevant. Only images with
    a size larger than the one specified with the `minWidth` and `minHeight` variables
    are used for the results. A new `<img>` element is created for each image found,
    where the `src` source URL attribute is copied from the original image and added
    to the `imagesFound` container.
  prefs: []
  type: TYPE_NORMAL
- en: For security reasons, your browser will prevent you from running the bookmarklet
    over HTTP on a site served through HTTPS. That’s the reason we keep using `RunServerPlus`
    to run the development server using an auto-generated TLS/SSL certificate. Remember
    that you learned how to run the development server through HTTPS in *Chapter 5,
    Implementing Social Authentication*.
  prefs: []
  type: TYPE_NORMAL
- en: In a production environment, a valid TLS/SSL certificate will be required. When
    you own a domain name, you can apply for a trusted **Certification Authority**
    (**CA**) to issue a TLS/SSL certificate for it so that browsers can verify its
    identity. If you want to obtain a trusted certificate for a real domain, you can
    use the *Let’s Encrypt* service. *Let’s Encrypt* is a non-profit CA that simplifies
    obtaining and renewing trusted TLS/SSL certificates for free. You can find more
    information at [https://letsencrypt.org](https://letsencrypt.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the development server with the following command from the shell prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `https://127.0.0.1:8000/account/` in your browser. Log in with an existing
    user, then click and drag the **BOOKMARK IT** button to the bookmarks bar of your
    browser, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Adding the BOOKMARK IT button to the bookmarks bar'
  prefs: []
  type: TYPE_NORMAL
- en: Open a website of your choice in your browser and click on the **Bookmark it**
    bookmarklet in the bookmarks bar. You will see that a new white overlay appears
    on the website, displaying all JPEG and PNG images found with dimensions higher
    than 250×250 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6.11* shows the bookmarklet running on [https://amazon.com/](https://amazon.com/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: The bookmarklet loaded on amazon.com'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the HTML container doesn’t appear, check the `RunServer` shell console log.
    If you see a MIME type error, it is most likely that your MIME map files are incorrect
    or need to be updated. You can apply the correct mapping for JavaScript and CSS
    files by adding the following lines to the `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The HTML container includes the images that can be bookmarked. We will now implement
    the functionality for users to click on the desired image to bookmark it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `js/bookmarklet.js` static file and add the following code at the
    bottom of the `bookmarklet()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A `click()` event is attached to each image element within the `imagesFound`
    container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user clicks on any of the images, the image element clicked is stored
    in the variable `imageSelected`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The bookmarklet is then hidden by setting its `display` property to `none`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new browser window is opened with the URL to bookmark a new image on the site.
    The content of the `<title>` element of the website is passed to the URL in the
    `title` `GET` parameter and the selected image URL is passed in the `url` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a new URL with your browser, for example, [https://commons.wikimedia.org/](https://commons.wikimedia.org/),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: The Wikimedia Commons website'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figures 6.12* to *6.15* image: *A flock of cranes (Grus grus) in Hula Valley,
    Northern Israel* by Tomere (Licence: Creative Commons Attribution-Share Alike
    4.0 International: https://creativecommons.org/licenses/by-sa/4.0/deed.en)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Bookmark it** bookmarklet to display the image selection overlay.
    You will see the image selection overlay like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: The bookmarklet loaded on an external website'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on an image, you will be redirected to the image creation page,
    passing the title of the website and the URL of the selected image as `GET` parameters.
    The page will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: The form to bookmark an image'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! This is your first JavaScript bookmarklet, and it is fully
    integrated into your Django project. Next, we will create the detail view for
    images and implement the canonical URL for images.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a detail view for images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s now create a simple detail view to display images that have been bookmarked
    on the site. Open the `views.py` file of the `images` application and add the
    following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple view to display an image. Edit the `urls.py` file of the `images`
    application and add the following URL pattern highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `models.py` file of the `images` application and add the `get_absolute_url()`
    method to the `Image` model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the common pattern for providing canonical URLs for objects is
    to define a `get_absolute_url()` method in the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, create a template inside the `/templates/images/image/` template directory
    for the `images` application and name it `detail.html`. Add the following code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is the template for displaying the detail view of a bookmarked image. We
    have used the `{% with %}` tag to create the `total_likes` variable with the result
    of a QuerySet that counts all user likes. By doing so, we avoid evaluating the
    same QuerySet twice (first to display the total number of likes, then to use the
    `pluralize` template filter). We have also included the image description and
    we have added a `{% for %}` loop to iterate over `image.users_like.all` to display
    all the users who like this image.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you need to repeat a query in your template, use the `{% with %}` template
    tag to prevent additional database queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open an external URL in your browser and use the bookmarklet to bookmark
    a new image. You will be redirected to the image detail page after you post the
    image. The page will include a success message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: The image detail page for the image bookmark'
  prefs: []
  type: TYPE_NORMAL
- en: Great! You completed the bookmarklet functionality. Next, you will learn how
    to create thumbnails for images.
  prefs: []
  type: TYPE_NORMAL
- en: Creating image thumbnails using easy-thumbnails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are displaying the original image on the detail page, but the dimensions
    of different images may vary considerably. The file size of some images may be
    very large, and loading them might take too long. The best way to display optimized
    images in a uniform manner is to generate thumbnails. A thumbnail is a small image
    representation of a larger image. Thumbnails will load faster in the browser and
    are a great way to homogenize images of very different sizes. We will use a Django
    application called `easy-thumbnails` to generate thumbnails for the images bookmarked
    by users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the terminal and install `easy-thumbnails` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `settings.py` file of the `bookmarks` project and add `easy_thumbnails`
    to the `INSTALLED_APPS` setting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the following command to sync the application with your database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see an output that includes the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `easy-thumbnails` application offers you different ways to define image
    thumbnails. The application provides a `{% thumbnail %}` template tag to generate
    thumbnails in templates and a custom `ImageField` if you want to define thumbnails
    in your models. Let’s use the template tag approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `images/image/detail.html` template and consider the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines should replace the preceding one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We have defined a thumbnail with a fixed width of `300` pixels and a flexible
    height to maintain the aspect ratio by using the value `0`. The first time a user
    loads this page, a thumbnail image will be created. The thumbnail is stored in
    the same directory as the original file. The location is defined by the `MEDIA_ROOT`
    setting and the `upload_to` attribute of the `image` field of the `Image` model.
    The generated thumbnail will then be served in the following requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the development server with the following command from the shell prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Access the image detail page for an existing image. The thumbnail will be generated
    and displayed on the site. Right-click on the image and open it in a new browser
    tab, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: Opening the image in a new browser tab'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the URL of the generated image in your browser. It should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: The URL of the generated image'
  prefs: []
  type: TYPE_NORMAL
- en: The original filename is followed by additional details of the settings used
    to create the thumbnail. For a JPEG image, you will see a filename like `filename.jpg.300x0_q85.jpg`,
    where `300x0` indicates the size parameters used to generate the thumbnail, and
    `85` is the value for the default JPEG quality used by the library to generate
    the thumbnail.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a different quality value using the `quality` parameter. To set
    the highest JPEG quality, you can use the value `100`, like this: `{% thumbnail
    image.image 300x0 quality=100 %}`. A higher quality will imply a larger file size.'
  prefs: []
  type: TYPE_NORMAL
- en: The `easy-thumbnails` application offers several options to customize your thumbnails,
    including cropping algorithms and different effects that can be applied. If you
    run into any issues generating thumbnails, you can add `THUMBNAIL_DEBUG = True`
    to the `settings.py` file to obtain the debug information. You can read the full
    documentation of `easy-thumbnails` at [https://easy-thumbnails.readthedocs.io/](https://easy-thumbnails.readthedocs.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Adding asynchronous actions with JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to add a **like** button to the image detail page to let users
    click on it to like an image. When users click the *like* button, we will send
    an HTTP request to the web server using JavaScript. This will perform the *like*
    action without reloading the whole page. For this functionality, we will implement
    a view that allows users to like/unlike images.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript **Fetch API** is the built-in way to make asynchronous HTTP requests
    to web servers from web browsers. By using the Fetch API, you can send and retrieve
    data from the web server without the need for a whole page refresh. The Fetch
    API was launched as a modern successor to the `XMLHttpRequest` (XHR) object that
    is built into the browser, used to make HTTP requests without reloading the page.
    The set of web development techniques to send and retrieve data from a web server
    asynchronously without reloading the page is also known as **AJAX**, which stands
    for **Asynchronous JavaScript and XML**. AJAX is a misleading name because AJAX
    requests can exchange data not only in XML format but also in formats such as
    JSON, HTML, and plain text. You might find references to the Fetch API and AJAX
    indistinctively on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: You can find information about the Fetch API at [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).
  prefs: []
  type: TYPE_NORMAL
- en: We will start by implementing the view to perform the *like* and *unlike* actions,
    and then we will add the JavaScript code to the related template to perform asynchronous
    HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `images` application and add the following
    code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We have used two decorators for the new view. The `login_required` decorator
    prevents users who are not logged in from accessing this view. The `require_POST`
    decorator returns an `HttpResponseNotAllowed` object (status code `405`) if the
    HTTP request is not done via `POST`. This way, you only allow `POST` requests
    for this view.
  prefs: []
  type: TYPE_NORMAL
- en: Django also provides a `require_GET` decorator to only allow `GET` requests
    and a `require_http_methods` decorator to which you can pass a list of allowed
    methods as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'This view expects the following `POST` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`image_id`: The ID of the `Image` object on which the user is performing the
    action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`action`: The action that the user wants to perform, which should be a string
    with the value `like` or `unlike`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have used the manager provided by Django for the `users_like` many-to-many
    field of the `Image` model in order to add or remove objects from the relationship
    using the `add()` or `remove()` methods. If the `add()` method is called passing
    an object that is already present in the related object set, it will not be duplicated.
    If the `remove()` method is called with an object that is not in the related object
    set, nothing will happen. Another useful method of many-to-many managers is `clear()`,
    which removes all objects from the related object set.
  prefs: []
  type: TYPE_NORMAL
- en: To generate the view response, we have used the `JsonResponse` class provided
    by Django, which returns an HTTP response with an `application/json` content type,
    converting the given object into a JSON output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `urls.py` file of the `images` application and add the following URL
    pattern highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Loading JavaScript on the DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to add JavaScript code to the image detail template. To use JavaScript
    in our templates, we will add a base wrapper in the `base.html` template of the
    project first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `base.html` template of the `account` application and include the
    following code highlighted in bold before the closing `</body>` HTML tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We have added a `<script>` tag to include JavaScript code. The `document.addEventListener()`
    method is used to define a function that will be called when the given event is
    triggered. We pass the event name `DOMContentLoaded`, which fires when the initial
    HTML document has been completely loaded and the DOM hierarchy has been fully
    constructed. By using this event, we make sure the DOM is fully constructed before
    we interact with any HTML elements and we manipulate the DOM. The code within
    the function will only be executed once the DOM is ready.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the document-ready handler, we have included a Django template block
    called `domready`. Any template that extends the `base.html` template can use
    this block to include specific JavaScript code to execute when the DOM is ready.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t get confused by the JavaScript code and Django template tags. The Django
    template language is rendered on the server side to generate the HTML document,
    and JavaScript is executed in the browser on the client side. In some cases, it
    is useful to generate JavaScript code dynamically using Django in order to use
    the results of QuerySets or server-side calculations to define variables in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this chapter include JavaScript code in Django templates. The
    preferred method to add JavaScript code to your templates is by loading `.js`
    files, which are served as static files, especially if you are using large scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site request forgery for HTTP requests in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You learned about **cross-site request forgery** (**CSRF**) in *Chapter 2*,
    *Enhancing Your Blog with Advanced Features*. With CSRF protection active, Django
    looks for a CSRF token in all `POST` requests. When you submit forms, you can
    use the `{% csrf_token %}` template tag to send the token along with the form.
    HTTP requests made in JavaScript have to pass the CSRF token as well in every
    `POST` request.
  prefs: []
  type: TYPE_NORMAL
- en: Django allows you to set a custom `X-CSRFToken` header in your HTTP requests
    with the value of the CSRF token.
  prefs: []
  type: TYPE_NORMAL
- en: To include the token in HTTP requests that originate from JavaScript, we will
    need to retrieve the CSRF token from the `csrftoken` cookie, which is set by Django
    if the CSRF protection is active. To handle cookies, we will use JavaScript Cookie.
    JavaScript Cookie is a lightweight JavaScript API for handling cookies. You can
    learn more about it at [https://github.com/js-cookie/js-cookie](https://github.com/js-cookie/js-cookie).
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `base.html` template of the `account` application and add the following
    code highlighted in bold at the bottom of the `<body>` element like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We have implemented the following functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript Cookie plugin is loaded from a public **Content Delivery Network**
    (**CDN**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value of the `csrftoken` cookie is retrieved with `Cookies.get()` and stored
    in the JavaScript constant `csrftoken`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have to include the CSRF token in all JavaScript fetch requests that use
    unsafe HTTP methods, such as `POST` or `PUT`. We will later include the `csrftoken`
    constant in a custom HTTP header named `X-CSRFToken` when sending HTTP `POST`
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about Django’s CSRF protection and AJAX at [https://docs.djangoproject.com/en/5.0/ref/csrf/#ajax](https://docs.djangoproject.com/en/5.0/ref/csrf/#ajax).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will implement the HTML and JavaScript code for users to like/unlike
    images.
  prefs: []
  type: TYPE_NORMAL
- en: Performing HTTP requests with JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit the `images/image/detail.html` template and add the following code highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have added another variable to the `{% with %}` template
    tag to store the results of the `image.users_like.all` query and prevent the query
    from being executed against the database multiple times. This variable is used
    to check whether the current user is in this list with `{% if request.user in
    users_like %}` and then with `{% if request.user not in users_like %}`. The same
    variable is then used to iterate over the users that like this image with `{%
    for user in users_like %}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added to this page the total number of users who like the image and
    have included a link for the user to like/unlike the image. The related object
    set, `users_like`, is used to check whether `request.user` is contained in the
    related object set, to display the text **Like** or **Unlike** based on the current
    relationship between the user and this image. We have added the following attributes
    to the `<a>` HTML link element:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data-id`: The ID of the image displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data-action`: The action to perform when the user clicks on the link. This
    can be either `like` or `unlike`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any attribute on any HTML element with a name that starts with `data-` is a
    data attribute. Data attributes are used to store custom data for your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will send the value of the `data-id` and `data-action` attributes in the
    HTTP request to the `image_like` view. When a user clicks on the **like/unlike**
    link, we will need to perform the following actions in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: Send an HTTP `POST` request to the `image_like` view, passing the image `id`
    and the `action` parameters to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the HTTP request is successful, update the `data-action` attribute of the
    `<a>` HTML element with the opposite action (`like` / `unlike`), and modify its
    display text accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the total number of likes displayed on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `domready` block at the bottom of the `images/image/detail.html`
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `{% url %}` template tag is used to build the `images:like` URL. The generated
    URL is stored in the `url` JavaScript constant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An `options` object is created with the options that will be passed to the
    HTTP request with the Fetch API. These are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`method`: The HTTP method to use. In this case, it’s `POST`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers`: Additional HTTP headers to include in the request. We include the
    `X-CSRFToken` header with the value of the `csrftoken` constant that we defined
    in the `base.html` template.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode`: The mode of the HTTP request. We use `same-origin` to indicate the
    request is made to the same origin. You can find more information about modes
    at [https://developer.mozilla.org/en-US/docs/Web/API/Request/mode](https://developer.mozilla.org/en-US/docs/Web/API/Request/mode).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `a.like` selector is used to find all `<a>` elements of the HTML document
    with the `like` class using `document.querySelector()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An event listener is defined for the `click` event on the elements targeted
    with the selector. This function is executed every time the user clicks on the
    **like/unlike** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the handler function, `e.preventDefault()` is used to avoid the default
    behavior of the `<a>` element. This will prevent the default behavior of the link
    element, stopping the event propagation, and preventing the link from following
    the URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `likeButton` variable is used to store the reference to `this`, the element
    on which the event was triggered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to send the HTTP request using the Fetch API. Edit the `domready`
    block of the `images/image/detail.html` template and add the following code highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The new code works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A `FormData` object is created to construct a set of key/value pairs representing
    form fields and their values. The object is stored in the `formData` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `id` and `action` parameters expected by the `image_like` Django view are
    added to the `formData` object. The values for these parameters are retrieved
    from the `likeButton` element clicked. The `data-id` and `data-action` attributes
    are accessed with `dataset.id` and `dataset.action`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new `body` key is added to the `options` object that will be used for the
    HTTP request. The value for this key is the `formData` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Fetch API is used by calling the `fetch()` function. The `url` variable
    defined previously is passed as the URL for the request, and the `options` object
    is passed as the options for the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `fetch()` function returns a promise that resolves with a `Response` object,
    which is a representation of the HTTP response. The `.then()` method is used to
    define a handler for the promise. To extract the JSON body content, we use `response.json()`.
    You can learn more about the `Response` object at [https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `.then()` method is used again to define a handler for the data extracted
    to JSON. In this handler, the `status` attribute of the data received is used
    to check whether its value is `ok`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You added the functionality to send the HTTP request and handle the response.
    After a successful request, you need to change the button and its related action
    to the opposite: from *like* to *unlike*, or from *unlike* to *like*. By doing
    so, users are able to undo their action.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `domready` block of the `images/image/detail.html` template and add
    the following code highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The previous action of the button is retrieved from the `data-action` attribute
    of the link and it is stored in the `previousAction` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `data-action` attribute of the link and the link text are toggled. This
    allows users to undo their actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The total like count is retrieved from the DOM by using the selector `span.count.total`
    and the value is parsed to an integer with `parseInt()`. The total like count
    is increased or decreased according to the action performed (*like* or *unlike*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the image detail page in your browser for an image that you have uploaded.
    You should be able to see the following initial likes count and the **LIKE** button,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.18: The likes count and LIKE button in the image detail template'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **LIKE** button. You will note that the total likes count increases
    by one and the button text changes to **UNLIKE**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.19: The likes count and button after clicking the LIKE button'
  prefs: []
  type: TYPE_NORMAL
- en: If you click on the **UNLIKE** button, the action is performed, and then the
    button’s text changes back to **LIKE** and the total count changes accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: When programming JavaScript, especially when performing AJAX requests, it is
    recommended to use a tool for debugging JavaScript and HTTP requests. Most modern
    browsers include developer tools to debug JavaScript. Usually, you can right-click
    anywhere on the website to open the contextual menu and click on **Inspect** or
    **Inspect Element** to access the web developer tools of your browser.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to use asynchronous HTTP requests with
    JavaScript and Django to implement infinite scroll pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Adding infinite scroll pagination to the image list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we need to list all bookmarked images on the website. We will use JavaScript
    requests to build an infinite scroll functionality. Infinite scroll is achieved
    by loading the next results automatically when the user scrolls to the bottom
    of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement an image list view that will handle both standard browser requests
    and requests originating from JavaScript. When the user initially loads the image
    list page, we will display the first page of images. When they scroll to the bottom
    of the page, we will retrieve the following page of items with JavaScript and
    append it to the bottom of the main page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same view will handle both standard and AJAX infinite scroll pagination.
    Edit the `views.py` file of the `images` application and add the following code
    highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In this view, a QuerySet is created to retrieve all images from the database.
    Then, a `Paginator` object is created to paginate over the results, retrieving
    eight images per page. The `page` HTTP `GET` parameter is retrieved to get the
    requested page number. The `images_only` HTTP `GET` parameter is retrieved to
    know if the whole page has to be rendered or only the new images.
  prefs: []
  type: TYPE_NORMAL
- en: We will render the whole page when it is requested by the browser. However,
    we will only render the HTML with new images for Fetch API requests, since we
    will be appending them to the existing HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `EmptyPage` exception will be triggered if the requested page is out of
    range. If this is the case and only images have to be rendered, an empty `HttpResponse`
    will be returned. This will allow you to stop the AJAX pagination on the client
    side when reaching the last page. The results are rendered using two different
    templates:'
  prefs: []
  type: TYPE_NORMAL
- en: For JavaScript HTTP requests, which will include the `images_only` parameter,
    the `list_images.html` template will be rendered. This template will only contain
    the images of the requested page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For browser requests, the `list.html` template will be rendered. This template
    will extend the `base.html` template to display the whole page and will include
    the `list_images.html` template to include the list of images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edit the `urls.py` file of the `images` application and add the following URL
    pattern highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you need to create the templates mentioned here. Inside the `images/image/`
    template directory, create a new template and name it `list_images.html`. Add
    the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The preceding template displays the list of images. You will use it to return
    results for AJAX requests. In this code, you iterate over images and generate
    a square thumbnail for each image. You normalize the size of the thumbnails to
    `300x300` pixels. You also use the `smart` cropping option. This option indicates
    that the image has to be incrementally cropped down to the requested size by removing
    slices from the edges with the least entropy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another template in the same directory and name it `images/image/list.html`.
    Add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The list template extends the `base.html` template. To avoid repeating code,
    you include the `images/image/list_images.html` template for displaying images.
    The `images/image/list.html` template will hold the JavaScript code for loading
    additional pages when scrolling to the bottom of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `images/image/list.html` template and add the following code highlighted
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code provides the infinite scroll functionality. You include
    the JavaScript code in the `domready` block that you defined in the `base.html`
    template. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You define the following variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`page`: Stores the current page number.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`empty_page`: Allows you to know whether the user is on the last page and retrieves
    an empty page. As soon as you get an empty page, you will stop sending additional
    HTTP requests because you will assume that there are no more results.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`block_request`: Prevents you from sending additional requests while an HTTP
    request is in progress.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You use `window.addEventListener()` to capture the `scroll` event and to define
    a handler function for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You calculate the `margin` variable to get the difference between the total
    document height and the window inner height, because that’s the height of the
    remaining content for the user to scroll. You subtract a value of `200` from the
    result so that you load the next page when the user is closer than 200 pixels
    to the bottom of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before sending an HTTP request, you check that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `window.pageYOffset` is higher than the calculated margin.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The user didn’t get to the last page of results (`emptyPage` has to be `false`).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no other ongoing HTTP request (`blockRequest` has to be `false`).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the previous conditions are met, you set `blockRequest` to `true` to prevent
    the `scroll` event from triggering additional HTTP requests, and you increase
    the `page` counter by `1` to retrieve the next page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You use `fetch()` to send an HTTP `GET` request, setting the URL parameters
    `image_only=1` to retrieve only the HTML for images instead of the whole HTML
    page, and `page` for the requested page number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The body content is extracted from the HTTP response with `response.text()`
    and the HTML returned is treated accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**If the response has no content**: You get to the end of the results and there
    are no more pages to load. You set `emptyPage` to `true` to prevent additional
    HTTP requests.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**If the response contains data**: You append the data to the HTML element
    with the `image-list` ID. The page content expands vertically, appending results
    when the user approaches the bottom of the page. You remove the lock for additional
    HTTP requests by setting `blockRequest` to `false`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Below the event listener, you simulate an initial `scroll` event when the page
    is loaded. You create the event by creating a new `Event` object, and then you
    launch it with `window.dispatchEvent()`. By doing this, you ensure that the event
    is triggered if the initial content fits the window and has no scroll.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `https://127.0.0.1:8000/images/` in your browser. You will see the list
    of images that you have bookmarked so far. It should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.20: The image list page with infinite scroll pagination'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6.19* image attributions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chick Corea* by ataelw (license: Creative Commons Attribution 2.0 Generic:
    https://creativecommons.org/licenses/by/2.0/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Al Jarreau - Düsseldorf 1981* by Eddi Laumanns aka RX-Guru (license: Creative
    Commons Attribution 3.0 Unported: https://creativecommons.org/licenses/by/3.0/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Al Jarreau* by Kingkongphoto and www.celebrity-photos.com (license: Creative
    Commons Attribution-ShareAlike 2.0 Generic: https://creativecommons.org/licenses/by-sa/2.0/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scroll to the bottom of the page to load additional pages. Ensure that you have
    bookmarked more than eight images using the bookmarklet, because that’s the number
    of images you are displaying per page.
  prefs: []
  type: TYPE_NORMAL
- en: You can use your browser developer tools to track the AJAX requests. Usually,
    you can right-click anywhere on the website to open the contextual menu and click
    on **Inspect** or **Inspect Element** to access the web developer tools of your
    browser. Look for the panel for network requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reload the page and scroll to the bottom of the page to load new pages. You
    will see the request for the first page and the AJAX requests for additional pages,
    like in *Figure 6.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_06_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.21: HTTP requests registered in the developer tools of the browser'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the shell where you are running Django, you will see the requests as well,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, edit the `base.html` template of the `account` application and add
    the URL for the `images` item highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Now you can access the image list from the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you created models with many-to-many relationships and learned
    how to customize the behavior of forms. You built a JavaScript bookmarklet to
    share images from other websites on your site. This chapter has also covered the
    creation of image thumbnails using the `easy-thumbnails` application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you implemented AJAX views using the JavaScript Fetch API and added
    infinite scroll pagination to the image list view.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to build a follow system and an activity
    stream. You will work with generic relations, signals, and denormalization. You
    will also learn how to use Redis with Django to count image views and generate
    an image ranking.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources provide additional information related to the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Source code for this chapter: [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter06](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter06)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Database indexes: [https://docs.djangoproject.com/en/5.0/ref/models/options/#django.db.models.Options.indexes](https://docs.djangoproject.com/en/5.0/ref/models/options/#django.db.models.Options.indexes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many-to-many relationships: [https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Requests HTTP library for Python: [https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pinterest Save extension: [https://help.pinterest.com/en/article/save-pins-with-the-pinterest-browser-button](https://help.pinterest.com/en/article/save-pins-with-the-pinterest-browser-button)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Static content for the account application: [https://github.com/PacktPublishing/Django-5-by-Example/tree/main/Chapter06/bookmarks/images/static](https://github.com/PacktPublishing/Django-5-by-Example/tree/main/Chapter06/bookmarks/images/static)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CSS selectors: [https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Locating DOM elements using CSS selectors: [https://developer.mozilla.org/en-US/docs/Web/API/Document_object_model/Locating_DOM_elements_using_selectors](https://developer.mozilla.org/en-US/docs/Web/API/Document_object_model/Locating_DOM_elements_using_selectors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s Encrypt free automated certificate authority: [https://letsencrypt.org](https://letsencrypt.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django `easy-thumbnails` app: [https://easy-thumbnails.readthedocs.io/](https://easy-thumbnails.readthedocs.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JavaScript Fetch API usage: [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JavaScript Cookie library: [https://github.com/js-cookie/js-cookie](https://github.com/js-cookie/js-cookie)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django’s CSRF protection and AJAX: [https://docs.djangoproject.com/en/5.0/ref/csrf/#ajax](https://docs.djangoproject.com/en/5.0/ref/csrf/#ajax)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JavaScript Fetch API Request mode: [https://developer.mozilla.org/en-US/docs/Web/API/Request/mode](https://developer.mozilla.org/en-US/docs/Web/API/Request/mode)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JavaScript Fetch API Response: [https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
