<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Building Robots</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building a Rover-Pi robot with forward driving motors</li><li class="listitem" style="list-style-type: disc">Using advanced motor control</li><li class="listitem" style="list-style-type: disc">Building a six-legged Pi-Bug robot</li><li class="listitem" style="list-style-type: disc">Controlling servos directly with ServoBlaster</li><li class="listitem" style="list-style-type: disc">Avoiding objects and obstacles</li><li class="listitem" style="list-style-type: disc">Getting a sense of direction</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec67"/>Introduction</h1></div></div></div><p>A little computer with a "brain the size of a planet" (to quote Douglas Adams, the author of <em>Hitchhikers Guide to the Galaxy</em>) is perfect to be the brain of your own robotic creation. In reality, the Raspberry Pi probably provides far more processing power than a little robot or rover would need; however, its small size, excellent connectivity, and fairly low-power requirements mean that it is ideally suited.</p><p>This chapter will focus on exploring the various ways in which we can combine motors or servos to produce robotic movement and use sensors to gather information and allow our creation to act upon it.</p><div><div><h3 class="title"><a id="tip25"/>Tip</h3><p>Be sure to check out the <a class="link" href="apa.html" title="Appendix A. Hardware and Software List">Appendix</a>, <em>Hardware and Software List</em>; it lists all the items used in this chapter and the places you can obtain them from.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec68"/>Building a Rover-Pi robot with forward driving motors</h1></div></div></div><p>Creating <a class="indexterm" id="id686"/>robots does not need to be<a class="indexterm" id="id687"/> an expensive hobby. A small, rover-type robot can be constructed using household items for the chassis (the base everything is attached to), and a couple of small driving motors can be used to move it.</p><p>The Rover-Pi robot is a small, buggy-type robot that has just two wheels and a skid or caster at the front to allow it to turn. One such robot is shown in the following image:</p><div><img alt="Building a Rover-Pi robot with forward driving motors" src="img/6623OT_09_001.jpg"/><div><p>A home-built Rover-Pi robot</p></div></div><p>While it may not be in the same league as a Mars Exploration Rover, as you will see, there is plenty for you to experiment with.</p><p>You can also purchase many inexpensive robot kits that contain most of what you need in a single package (see the <em>There's more…</em> section at the end of this example).</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec187"/>Getting ready</h2></div></div></div><p>The Rover we are building will need to contain the elements shown in the following diagram:</p><div><img alt="Getting ready" src="img/6623OT_09_002.jpg"/><div><p>The separate parts of the Rover-Pi robot</p></div></div><p>The elements <a class="indexterm" id="id688"/>are discussed in detail as <a class="indexterm" id="id689"/>follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Chassis</strong>: This example <a class="indexterm" id="id690"/>uses a modified, battery-operated push <a class="indexterm" id="id691"/>nightlight (although any suitable platform can be used). Remember that the larger and heavier your robot is, the more powerful the driving motors will need to be to move it. Alternatively, you can use one of the chassis kits listed in the <em>There's more…</em> section. A suitable push nightlight is shown in the following image:<div><img alt="Getting ready" src="img/6623OT_09_003.jpg"/><div><p>This push nightlight forms the basic chassis of a Rover-Pi robot</p></div></div></li><li class="listitem" style="list-style-type: disc"><strong>Front skid or caster</strong>: This can be <a class="indexterm" id="id692"/>as simple <a class="indexterm" id="id693"/>as a large paper clip (76 mm/3 inches) bent into shape, or a small caster wheel. A skid <a class="indexterm" id="id694"/>works best when it is on a smooth surface, but it<a class="indexterm" id="id695"/> may get stuck on the carpet. A <a class="indexterm" id="id696"/>caster wheel works well on all surfaces, but sometimes, it can have problems turning.</li><li class="listitem" style="list-style-type: disc"><strong>Wheels</strong>, <strong>motors</strong>, and <strong>gears</strong>: The <a class="indexterm" id="id697"/>wheel <a class="indexterm" id="id698"/>movement of the Rover-Pi robot is a combination of the <a class="indexterm" id="id699"/>motor, gears, and wheels. The gears are helpful as they allow a fast-spinning motor to turn the wheels at a slower speed and more force (torque); this will allow better control of our robot. A unit that combines the wheels, motors, and gears in a single unit is shown in the following image:<div><img alt="Getting ready" src="img/6623OT_09_004.jpg"/><div><p>These wheels with built-in geared motors are ideal for small rovers</p></div></div></li><li class="listitem" style="list-style-type: disc"><strong>Battery/power source</strong>: The <a class="indexterm" id="id700"/>Rover-Pi robot <a class="indexterm" id="id701"/>will be powered using 4 x AA batteries fitted into the bay of the chassis. Alternatively, a <a class="indexterm" id="id702"/>standard battery holder can be used, or even<a class="indexterm" id="id703"/> a long wire connected to suitable power supply. It is recommended that you power the motors from a supply independent from the Raspberry Pi. This will help avoid a situation in which the Raspberry Pi suddenly loses power when driving the motors, which requires a big jump in current to move. Alternatively, you can power the Raspberry Pi with the batteries using a 5V regulator. The following image shows a chassis with 4 x AA batteries:<div><img alt="Getting ready" src="img/6623OT_09_005.jpg"/><div><p>4x AA batteries provide a power source to drive the wheels</p></div></div></li><li class="listitem" style="list-style-type: disc"><strong>Motor driver/controller</strong>: Motors will <a class="indexterm" id="id704"/>require a<a class="indexterm" id="id705"/> voltage and current greater than the GPIO can handle. Therefore, we will use a <strong>Darlington array module</strong> (which uses a <strong>ULN2003</strong> chip). See the <em>There's more…</em> section<a class="indexterm" id="id706"/> at the end of this example for more <a class="indexterm" id="id707"/>details on how this particular module works. The following image shows a Darlington array module:<div><img alt="Getting ready" src="img/6623OT_09_006.jpg"/><div><p>This Darlington array module, available at dx.com, can be used to drive small motors</p></div></div></li><li class="listitem" style="list-style-type: disc"><strong>Small cable ties or wire ties</strong>: This <a class="indexterm" id="id708"/>will allow us to attach items such as the motors or a controller to the chassis. The following image shows the use of cable ties:<div><img alt="Getting ready" src="img/6623OT_09_007.jpg"/><div><p>We use cable ties to secure the motors and wheels to the chassis</p></div></div></li><li class="listitem" style="list-style-type: disc"><strong>The Raspberry Pi connection</strong>: The easiest setup is to attach the control wires to the Raspberry Pi<a class="indexterm" id="id709"/> using long cables, so you can easily control your robot <a class="indexterm" id="id710"/>directly using an attached screen and keyboard. Later, you can consider mounting the Raspberry Pi on the robot and controlling it remotely (or even autonomously if you include sensors and intelligence to make sense of them).</li></ul></div><p>In this chapter, we will <a class="indexterm" id="id711"/>use the <strong>WiringPi2</strong>
<a class="indexterm" id="id712"/> Python library to <a class="indexterm" id="id713"/>control the GPIO; see <a class="link" href="ch07.html" title="Chapter 7. Sense and Display Real-World Data">Chapter 7</a>, <em>Sense and Display Real-World Data</em>, for details on how to install it using PIP (a Python package manager).</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec188"/>How to do it…</h2></div></div></div><p>Perform the following steps to create a small Rover-Pi robot:</p><div><ol class="orderedlist arabic"><li class="listitem">At the front of the chassis, you will need to mount the skid by bending the paperclip/wire into a V shape. Attach the paperclip/wire to the front of the chassis by drilling small holes on either side, and thread cable ties through the holes around the wire and pull tight to secure. The fitted wire skid should look similar to the one shown in the following image:<div><img alt="How to do it…" src="img/6623OT_09_008.jpg"/><div><p>Wire skid fitted to the front of the Rover-Pi robot</p></div></div></li><li class="listitem">Before you <a class="indexterm" id="id714"/>mount the wheels, you <a class="indexterm" id="id715"/>need to work out the approximate center of gravity of the chassis (do this with the batteries fitted in the chassis as they will affect the balance). Get a feel of where the center is by trying to balance the unit on two fingers on either side, and find out how far forward or backward the chassis tilts. For my unit, this was about 1 cm (approximately one-third of an inch) back from the center. You should aim to place the wheel axles slightly behind this so that the Rover will rest slightly forward on the skid. Mark the location of the wheels on the chassis.</li><li class="listitem">Drill three holes on each side to mount the wheels using the cable ties. If the cable ties aren't long enough, you can join two together by pulling the end of one through the end of the other (only pull through far enough for the tie to grip so that it extends the tie). The following diagram shows how you can use the cable ties:<div><img alt="How to do it…" src="img/6623OT_09_009.jpg"/><div><p>Securely fix the motors to the chassis</p></div></div></li><li class="listitem">Next, test the motors by inserting the batteries into the unit; then, disconnect the wires that originally connected to the bulb and touch them to the motor contacts. Determine<a class="indexterm" id="id716"/> which connection<a class="indexterm" id="id717"/> on the motor should be positive and which should be negative for the motor to move the robot forward (the top of the wheel should move forward when the robot is facing forwards). Connect red and black wires to the motor (on mine, black equals negative at the top and red equals positive at the bottom of the motor), ensuring that the wires are long enough to reach anywhere on the chassis (around 14 cm, that is, approximately 5 and a half inches is enough for the nightlight).<p>The Rover-Pi robot components should be wired up as shown in the following diagram:</p><div><img alt="How to do it…" src="img/6623OT_09_010.jpg"/><div><p>The wiring layout of the Rover-Pi robot</p></div></div></li></ol></div><p>To make the connections, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Connect the black wires of the motors to the <strong>OUT 1</strong> (left) and <strong>OUT 2</strong> (right) output of the Darlington module, and connect the red wires to the last pin (the COM connection).</li><li class="listitem">Next, connect the battery wires to the <strong>GND</strong>/<strong>V-</strong> and <strong>V+</strong> connections at the bottom of the module.</li><li class="listitem">Finally, connect the <strong>GND</strong> from the GPIO connector (<strong>Pin 6</strong>) to the same <strong>GND</strong> connection.</li><li class="listitem">Test the motor<a class="indexterm" id="id718"/> control by<a class="indexterm" id="id719"/> connecting 3.3V (GPIO <strong>Pin 1</strong>) to <strong>IN1</strong> or <strong>IN2</strong> to simulate a GPIO output. When happy, connect GPIO <strong>Pin 16</strong> to <strong>IN1</strong> (for left) and GPIO <strong>Pin 18</strong> to <strong>IN2</strong> (for right).</li></ol></div><p>The wiring should now match the details given in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Raspberry Pi GPIO</p>
</th><th style="text-align: left" valign="bottom">
<p>Darlington module</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Pin 16: Left</p>
</td><td style="text-align: left" valign="top">
<p>IN1</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Pin 18: Right</p>
</td><td style="text-align: left" valign="top">
<p>IN2</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Pin 6: GND</p>
</td><td style="text-align: left" valign="top">
<p>GND/V- (marked with "–")</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Motor 4 x AA battery Darlington module</strong>
</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>Positive side of battery</p>
</td><td style="text-align: left" valign="top">
<p>V+ (marked with "+")</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Negative side of battery</p>
</td><td style="text-align: left" valign="top">
<p>GND/V- (marked with "–")</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Motors</strong>
</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>Left motor: black wire</p>
</td><td style="text-align: left" valign="top">
<p>OUT 1 (top pin in white socket)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Right motor: black wire</p>
</td><td style="text-align: left" valign="top">
<p>OUT 2 (second pin in white socket)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Both motors: red wires</p>
</td><td style="text-align: left" valign="top">
<p>COM (last pin in white socket)</p>
</td></tr></tbody></table></div><p>Use the<a class="indexterm" id="id720"/> following <code class="literal">rover_drivefwd.py</code> script<a class="indexterm" id="id721"/> to test the control:</p><div><pre class="programlisting">#!/usr/bin/env python3
#rover_drivefwd.py
#HARDWARE SETUP
# GPIO
# 2[==X====LR====]26[=======]40
# 1[=============]25[=======]39
import time
import wiringpi2
ON=1;OFF=0
IN=0;OUT=1
STEP=0.5
PINS=[16,18] # PINS=[L-motor,R-motor]
FWD=[ON,ON]
RIGHT=[ON,OFF]
LEFT=[OFF,ON]
DEBUG=True

class motor:
  # Constructor
  def __init__(self,pins=PINS,steptime=STEP):
    self.pins = pins
    self.steptime=steptime
    self.GPIOsetup()

  def GPIOsetup(self):
    wiringpi2.wiringPiSetupPhys()
    for gpio in self.pins:
      wiringpi2.pinMode(gpio,OUT)

  def off(self):
    for gpio in self.pins:
      wiringpi2.digitalWrite(gpio,OFF)

  def drive(self,drive,step=STEP):
    for idx,gpio in enumerate(self.pins):
      wiringpi2.digitalWrite(gpio,drive[idx])
      if(DEBUG):print("%s:%s"%(gpio,drive[idx]))
    time.sleep(step)
    self.off()

  def cmd(self,char,step=STEP):
    if char == 'f':
      self.drive(FWD,step)
    elif char == 'r':
      self.drive(RIGHT,step)
    elif char == 'l':
      self.drive(LEFT,step)
    elif char == '#':
      time.sleep(step)

def main():
  import os
  if "CMD" in os.environ:
    CMD=os.environ["CMD"]
    INPUT=False
    print("CMD="+CMD)
  else:
    INPUT=True
  roverPi=motor()
  if INPUT:
    print("Enter CMDs [f,r,l,#]:")
    CMD=input()
  for idx,char in enumerate(CMD.lower()):
    if(DEBUG):print("Step %s of %s: %s"%(idx+1,len(CMD),char))
    roverPi.cmd(char)

if __name__=='__main__':
  try:
    main()
  finally:
    print ("Finish")
#End</pre></div><div><div><h3 class="title"><a id="tip26"/>Tip</h3><p>Remember that WiringPi2 should be installed before running the scripts in this chapter (see <a class="link" href="ch07.html" title="Chapter 7. Sense and Display Real-World Data">Chapter 7</a>, <em>Sense and Display Real-world Data</em>).</p></div></div><p>Run the previous <a class="indexterm" id="id722"/>code using the following <a class="indexterm" id="id723"/>command:</p><div><pre class="programlisting">
<strong>sudo python3 rover_drivefwd.py</strong>
</pre></div><p>The script will prompt you with following message:</p><div><pre class="programlisting">
<strong>Enter CMDs [f,r,l,#]:</strong>
</pre></div><p>You can enter a series of commands to follow, for example:</p><div><pre class="programlisting">
<strong>ffrr#ff#llff</strong>
</pre></div><p>The previous command will instruct the Rover-Pi robot to perform a series of movements—forward (<code class="literal">f</code>), right (<code class="literal">r</code>), pause (<code class="literal">#</code>), and left (<code class="literal">l</code>).</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec189"/>How it works…</h2></div></div></div><p>Once you have built the robot and wired up the wheels to the motor controller, you can discover how to control it.</p><p>Start by importing <code class="literal">time</code> (which will allow you to put pauses in the motor control) and <code class="literal">wiringpi2</code> to allow control of the GPIO pins. Use <code class="literal">wiringpi2</code> here since it makes it much easier to make use of IO expanders and other I<sup>2</sup>C devices if you want to later on.</p><p>Define values to use for setting the pins <code class="literal">ON</code>/<code class="literal">OFF</code>, for the direction <code class="literal">IN</code>/<code class="literal">OUT</code>, as well as the duration of each motor <code class="literal">STEP</code>. Also, define which <code class="literal">PINS</code> are wired to the motor controls and our movements <code class="literal">FWD</code>, <code class="literal">RIGHT</code>, and <code class="literal">LEFT</code>. The movement is defined in such a way that by switching both motors <code class="literal">ON</code>, you will move forward or, by switching just one motor <code class="literal">ON</code>, you will turn. By setting these values at the start of the file using variables, our code is easier to maintain and understand.</p><p>We define a <code class="literal">motor</code> class that will allow us to reuse it in other code or easily swap it with alternative <code class="literal">motor</code> classes so we can use other hardware if we want to. We set the default pins we are using and our <code class="literal">steptime</code> value (the <code class="literal">steptime</code> object defines how long we drive the motor(s) for each step). However, both can still be specified when initializing the object if desired.</p><p>Next, we call <code class="literal">GPIOsetup()</code>; it selects the physical pin numbering mode (so we can refer to the pins as they are located on the board). We also set all of the pins we are using to output.</p><p>Finally, for the <code class="literal">motor</code> class, we define the following three functions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first function we define (called <code class="literal">off()</code>) will allow us to switch off the motors, so we cycle through the pins list and set each GPIO pin to low (and therefore switch the motors off).</li><li class="listitem" style="list-style-type: disc">The <code class="literal">drive()</code> function allows us to provide a list of drive actions (a combination of <code class="literal">ON</code> and <code class="literal">OFF</code> for each of the GPOI pins). Again, we cycle through each of the pins and set them to the corresponding drive action, wait for the step time, and then switch off the motors using the <code class="literal">off()</code> function.</li><li class="listitem" style="list-style-type: disc">The last function we define (called <code class="literal">cmd()</code>) simply allows us to send <code class="literal">char</code> (a single character) and use it to select the set of drive actions we want to use (<code class="literal">FWD</code>, <code class="literal">RIGHT</code>, or <code class="literal">LEFT</code>, or wait (<code class="literal">#</code>)).</li></ul></div><p>For testing, <code class="literal">main()</code> allows us to specify a list of actions that need to be performed from the command line using the following command:</p><div><pre class="programlisting">
<strong>sudo CMD=f#lrr##fff python3 rover_drivefwd.py</strong>
</pre></div><p>Using <code class="literal">os.environ</code> (by <a class="indexterm" id="id724"/>importing the <code class="literal">os</code> module so we can use it), we can check for <code class="literal">CMD</code> in the command and use it as our list of drive actions. If no <code class="literal">CMD</code> command has been provided, we can use the <code class="literal">input()</code> function to<a class="indexterm" id="id725"/> prompt for a list of drive actions directly. To use the <code class="literal">motor</code> class, we set <code class="literal">roverPi=motor()</code>; this allows us to call the <code class="literal">cmd()</code> function (of the motor class) with each character from the list of drive actions.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec190"/>There's more…</h2></div></div></div><p>Your robot should only be limited by your own creativity. There are lots of suitable chassis you can use, other motors, wheels, and ways to control and drive the wheels. You should experiment and test things to determine which combinations work best together. That is all part of the fun!</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec71"/>Darlington array circuits</h3></div></div></div><p>Darlington transistors <a class="indexterm" id="id726"/>are a low-cost way to drive higher powered devices, such as motors or even relays. They consist of two transistors arranged in a series, where one feeds the other (allowing the gain in the current to be multiplied). That is, if the first transistor has a gain of 20, and the second also has a gain of 20, together they will provide an overall gain of 400. This means that 1 mA on the base pin (1) will allow you to drive up to 400 mA through the Darlington transistor. The Darlington transistor's electrical symbol is shown in the following diagram:</p><div><img alt="Darlington array circuits" src="img/6623OT_09_011.jpg"/><div><p>The electrical symbol for a Darlington transistor shows how two transistors are packaged together</p></div></div><p>The ULN2003 chip is<a class="indexterm" id="id727"/> used in the previous module and provides 7 NPN Darlington transistors (an 8-way version ULN2803 is also available if more output is required or to use with two stepper motors). The following diagram shows how a Darlington array can be used to drive motors:</p><div><img alt="Darlington array circuits" src="img/6623OT_09_012.jpg"/><div><p>A Darlington array being used to drive two small motors</p></div></div><p>Each output from the chip can supply a maximum of 500 mA at up to 50V (enough to power most small motors). However, with extended use, the chip may overheat, so a heat sink is recommended when driving larger motors. An internal diode connected across each Darlington for protection is built into the chip. This is needed because when the motor moves without being driven (this can occur due to the natural momentum of the motor), it will act like a generator. A<a class="indexterm" id="id728"/> reverse voltage called <strong>back EMF</strong>
<a class="indexterm" id="id729"/> is created, which would destroy the transistor if it wasn't dissipated back through the diode.</p><p>One disadvantage of the chip is that the positive supply voltage must always be connected to the common pin (COM), so each output is only able to sink current. That is, it will only drive the motor in one direction, with the positive voltage on COM and the negative voltage on the OUT pins. Therefore, we will need a different solution if we wish to drive our Rover-Pi robot in different directions (see the next example in the <em>Using advanced motor control</em> recipe).</p><p>These chips can also be used to drive certain types of stepper motors. One of the modules from <a class="ulink" href="http://dx.com">dx.com</a> includes a stepper motor as a part of the kit. Although the gearing is for very slow movement at around 12 seconds per rotation (too slow for a rover), it is still interesting to use (for a clock perhaps).</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec72"/>Transistor and relay circuits</h3></div></div></div><p>Relays are able to handle <a class="indexterm" id="id730"/>much more highly powered motors since they are mechanical switches <a class="indexterm" id="id731"/>controlled by an electromagnetic coil that physically moves the contacts together. However, they require a reasonable amount of current to be turned on and usually more than 3.3V. To switch even small relays, we need around 60 mA at 5V (more than is available from the GPIO), so we will still need to use some additional components to switch it.</p><p>We can use the Darlington array (as used previously) or a small transistor (any small transistor, such as the 2N2222, will be fine) to provide the current and voltage required to switch it. The following circuit will allow us to do this:</p><div><img alt="Transistor and relay circuits" src="img/6623OT_09_013.jpg"/><div><p>The transistor and relay circuit used to drive external circuits</p></div></div><p>Much like a motor, a relay can also generate EMF spikes, so a protection diode is also needed to avoid any reverse voltage on the transistor.</p><p>This is a very useful <a class="indexterm" id="id732"/>circuit, not just for driving motors but for any external circuit as well; the <a class="indexterm" id="id733"/>physical switch allows it to be independent and electrically isolated from the Raspberry Pi controlling it.</p><p>As long as the relay is rated correctly, you can drive DC or AC devices through it.</p><div><div><h3 class="title"><a id="note85"/>Note</h3><p>You can use some relays to control items powered by the mains. However, this should be done only with extreme caution and proper electrical training. Electricity from the mains can kill or cause serious harm.</p></div></div><p>PiBorg has a ready-made module named the <strong>PicoBorg</strong>
<a class="indexterm" id="id734"/> that will allow the switching of up to four relays. It uses devices called <a class="indexterm" id="id735"/>
<strong>MOSFETs</strong> that are essentially high-power versions of transistors that function with the same principle as discussed previously.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec73"/>Tethered or untethered robots</h3></div></div></div><p>An important choice when<a class="indexterm" id="id736"/> designing your own Rover-Pi robot is to decide if you want to make it fully self-contained or if you are happy to have a tether (a long control/power cable connected to the Rover-Pi). Using a tether, you can keep the weight of the Rover-Pi <a class="indexterm" id="id737"/>robot down, which means the small motors will be able to move the unit with ease. This will allow you to keep the Raspberry Pi separate from the main unit so it can remain connected to a screen and keyboard for easy programming and debugging. The main disadvantage is that you will need a long, umbilical-like connection to your Rover-Pi robot (with a wire for each control signal) that may impede its movement. However, as we will see later, you may only need three or four wires to provide all the control you need (see the <em>Using I/O expanders</em> section in the next recipe).</p><p>If you intend to mount the Raspberry Pi directly on the Rover-Pi robot, you will need a suitable power supply, such as a phone charger battery pack. If the battery pack has two USB ports, then you may be able to use it as a power source to drive both the Raspberry Pi and the motors. The unit must be able to maintain the supplies independently as any power spike caused by driving the motors could reset the Raspberry Pi.</p><p>Remember that if the Raspberry Pi is now attached to the robot, you will need a means to control it. This can be a USB Wi-Fi dongle that will allow a remote connection via SSH and so on, or a wireless keyboard (that uses RF/Bluetooth), or even the GPIO D-Pad from <a class="link" href="ch06.html" title="Chapter 6. Using Python to Drive Hardware">Chapter 6</a>, <em>Using Python to Drive Hardware</em>, can be used for direct control.</p><p>However, the more you mount on the chassis, the harder the motors will need to work to move. You may find that stronger motors are required, rather than the little ones used here. A Rover-Pi robot powered by a USB battery pack is shown in the following image:</p><div><img alt="Tethered or untethered robots" src="img/6623OT_09_014.jpg"/><div><p>A battery-powered Raspberry Rover-Pi robot being controlled via Wi-Fi (cable management is optional)</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec74"/>Rover kits</h3></div></div></div><p>If you don't <a class="indexterm" id="id738"/>fancy making your own chassis, there are also a number of pre-made rover chassis available that can be used. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">2WD Magician Robot Chassis from SparkFun</li><li class="listitem" style="list-style-type: disc">4 Motor Smart Car Chassis from DX.com</li><li class="listitem" style="list-style-type: disc">2 Wheel Smart Car Model DX.com<div><img alt="Rover kits" src="img/6623OT_09_015.jpg"/><div><p>The Tiddlybot show how multiple components can be integrated together within a single platform, as shown in my modified version</p></div></div></li></ul></div><p>A particularly nice robot setup is the Tiddlybot<a class="indexterm" id="id739"/> (from <a class="ulink" href="http://PiBot.org">PiBot.org</a>), which combines multiple sensors, continuous servos, an onboard battery pack, and the Raspberry <a class="indexterm" id="id740"/>Pi camera. The SD card is set up so the TiddlyBot acts as a Wi-Fi hotspot hosting a simple drag and drop programming platform with a remote control interface. This shows how simple components such as the ones described in this chapter can be combined into a complete system.</p><div><img alt="Rover kits" src="img/6623OT_09_016.jpg"/><div><p>The Tiddlybot GUI provides a cross-platform drag and drop interface as well as Python support</p></div></div><div><div><h3 class="title"><a id="tip27"/>Tip</h3><p>Be sure to check out the <a class="link" href="apa.html" title="Appendix A. Hardware and Software List">Appendix</a>, <em>Hardware and Software List</em>; it lists all the items used in this chapter and the places you can obtain them from.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec69"/>Using advanced motor control</h1></div></div></div><p>The <a class="indexterm" id="id741"/>previous driving circuits are not suitable for driving motors in more than one direction (as they only switch the motor on or off). However, using a circuit named an H-bridge, you can switch and control the motor's direction too. The switch combinations are shown in the following diagram:</p><div><img alt="Using advanced motor control" src="img/6623OT_09_017.jpg"/><div><p>The direction of the motor can be controlled by different switch combinations</p></div></div><p>Using a different combination of switching, we can change the direction of the motor by switching the positive and negative supply to the motor (<strong>SW1</strong> and <strong>SW4</strong> activate the motor, and <strong>SW2</strong> and <strong>SW3</strong> reverse the motor). However, not only do we need four switching devices for each motor, but since the ULN2X03 devices and PiBorg's PicoBorg module can only sink current, equivalent devices would be required to source current (to make up the top section of switches).</p><p>Fortunately, there are purpose-built H-bridge chips, such as L298N, that contain the previous circuit inside them to provide a powerful and convenient solution to control motors.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec191"/>Getting ready</h2></div></div></div><p>We shall <a class="indexterm" id="id742"/>replace the previous Darlington array module with the H-bridge motor controller shown in the following image:</p><div><img alt="Getting ready" src="img/6623OT_09_018.jpg"/><div><p>The H-bridge motor controller allows directional control of motors</p></div></div><p>There is some detailed information about this unit available at <a class="ulink" href="http://www.geekonfire.com/wiki/index.php?title=Dual_H-Bridge_Motor_Driver">http://www.geekonfire.com/wiki/index.php?title=Dual_H-Bridge_Motor_Driver</a>.</p><p>The datasheet of L298N<a class="indexterm" id="id743"/> is available at <a class="ulink" href="http://www.st.com/resource/en/datasheet/l298.pdf">http://www.st.com/resource/en/datasheet/l298.pdf</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec192"/>How to do it…</h2></div></div></div><p>The unit will need to be wired as follows (this will be similar for other H-bridge type controllers, but check with the relevant datasheet if unsure).</p><p>The following table shows how the motors and motor power supply connect to the H-bridge controller module:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th colspan="7" style="text-align: center" valign="bottom">
<p>The motor side of the module – connecting to the battery and motors</p>
</th></tr><tr><th colspan="2" style="text-align: center" valign="bottom">
<p>Motor A</p>
</th><th style="text-align: left" valign="bottom">
<p>VMS</p>
</th><th style="text-align: left" valign="bottom">
<p>GND</p>
</th><th style="text-align: left" valign="bottom">
<p>5V OUT</p>
</th><th colspan="2" style="text-align: center" valign="bottom">
<p>Motor B</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Left motor Red wire</p>
</td><td style="text-align: left" valign="top">
<p>Left motor Black wire</p>
</td><td style="text-align: left" valign="top">
<p>Battery positive</p>
</td><td style="text-align: left" valign="top">
<p>Battery GND</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>Right motor Red wire</p>
</td><td style="text-align: left" valign="top">
<p>Right motor Black wire</p>
</td></tr></tbody></table></div><p>The following table shows how the H-bridge controller module connects to the Raspberry Pi:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th colspan="8" style="text-align: center" valign="bottom">
<p>Control side of the module – connecting to the Raspberry Pi GPIO header</p>
</th></tr><tr><th style="text-align: left" valign="bottom">
<p>ENA</p>
</th><th style="text-align: left" valign="bottom">
<p>IN1</p>
</th><th style="text-align: left" valign="bottom">
<p>IN2</p>
</th><th style="text-align: left" valign="bottom">
<p>IN3</p>
</th><th style="text-align: left" valign="bottom">
<p>IN4</p>
</th><th style="text-align: left" valign="bottom">
<p>ENB</p>
</th><th style="text-align: left" valign="bottom">
<p>GND</p>
</th><th style="text-align: left" valign="bottom">
<p>5V</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>Pin 15</p>
</td><td style="text-align: left" valign="top">
<p>Pin 16</p>
</td><td style="text-align: left" valign="top">
<p>Pin 18</p>
</td><td style="text-align: left" valign="top">
<p>Pin 22</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>Pin 6</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td></tr></tbody></table></div><p>It is<a class="indexterm" id="id744"/> recommended that you keep the pull-up resistor jumpers on (UR1-UR4) and allow the motor supply to power the onboard voltage regulator, which in turn will power the L298N controller (jumper 5V_EN). The on-board regulator (the 78M05 device) can supply up to 500 mA, enough for the L298N controller plus any additional circuits, such as an IO expander (see the <em>There's more…</em> section for more information). Both the ENA and ENB pins should be disconnected (the motor output will stay enabled by default).</p><p>You will need to make the following changes to the previous <code class="literal">rover_drivefwd.py</code> script (you can save it as <code class="literal">rover_drive.py</code>).</p><p>At the top of the file, redefine <code class="literal">PINS</code> as follows:</p><div><pre class="programlisting">PINS=[15,16,18,22]   # PINS=[L_FWD,L_BWD,R_FWD,R_BWD]</pre></div><p>And update the control patterns as follows:</p><div><pre class="programlisting">FWD=[ON,OFF,ON,OFF]
BWD=[OFF,ON,OFF,ON]
RIGHT=[OFF,ON,ON,OFF]
LEFT=[ON,OFF,OFF,ON]</pre></div><p>Next, we need to add the backwards command to <code class="literal">cmd()</code> as follows:</p><div><pre class="programlisting">  def cmd(self,char,step=STEP):
    if char == 'f':
      self.drive(FWD,step)
    elif char == 'b':
      self.drive(BWD,step)
    elif char == 'r':
      self.drive(RIGHT,step)
    elif char == 'l':
      self.drive(LEFT,step)
    elif char == '#':
      time.sleep(step)</pre></div><p>Finally, we can update the prompt that we have within the <code class="literal">main()</code> function to include <code class="literal">b</code> (backwards) as an option, as follows:</p><div><pre class="programlisting">print("Enter CMDs [f,b,r,l,#]:")</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec193"/>How it works…</h2></div></div></div><p>The <a class="indexterm" id="id745"/>H-bridge motor controller recreates the previous switching circuit with additional circuitry to ensure that the electronic switches cannot create a short circuit (by not allowing <strong>SW1</strong> and <strong>SW3</strong> or <strong>SW2</strong> and <strong>SW4</strong> to be enabled at the same time). The H-bridge motor controller's switching circuit is as shown in the following diagram:</p><div><img alt="How it works…" src="img/6623OT_09_019.jpg"/><div><p>An approximation of the H-bridge switching circuit (in Motor off state)</p></div></div><p>The input (<strong>IN1</strong> and <strong>IN2</strong>) will produce the following action on the motors:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>IN1</p>
<p>IN2</p>
</th><th style="text-align: left" valign="bottom">
<p>0</p>
</th><th style="text-align: left" valign="bottom">
<p>1</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>Motor off</p>
</td><td style="text-align: left" valign="top">
<p>Motor backwards</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>Motor forwards</p>
</td><td style="text-align: left" valign="top">
<p>Motor off</p>
</td></tr></tbody></table></div><p>As we did in <a class="indexterm" id="id746"/>the previous recipe, we can move forward by driving both motors forward; however, now we can drive them both backwards (to move backwards) as well as in opposite directions (allowing us to turn the Rover-Pi robot on the spot).</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec194"/>There's more…</h2></div></div></div><p>We can achieve finer control of the motors using a <strong>pulse width modulated</strong> (<strong>PWM</strong>) signal<a class="indexterm" id="id747"/> and expand the available input/output using an IO expander.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec75"/>Motor speed control using PWM control</h3></div></div></div><p>Currently, the <a class="indexterm" id="id748"/>Rover-Pi robot motors are controlled<a class="indexterm" id="id749"/> by being switched on and off; however, if the robot is moving too fast (for example, if you have fitted bigger motors or used higher gearing), we could make use of the <strong>ENA</strong> and <strong>ENB</strong> input on the controller. If these are set low, the motor output is disabled, and if set high, it is enabled again. Therefore, by driving them with a PWM signal, we can control the speed of the motors. We could even set slightly different PWM rates (if required) to compensate for any differences in the motors/wheels or surface to drive them at slightly different speeds, as shown in the following diagram:</p><div><img alt="Motor speed control using PWM control" src="img/6623OT_09_020.jpg"/><div><p>A PWM signal controls the ratio of the ON and OFF times</p></div></div><p>A PWM signal is a digital on/off signal that has different amounts of <strong>ON</strong> time compared to <strong>OFF</strong> time. A motor driven with a 50:50, <code class="literal">ON:OFF</code> signal would drive a motor with half the power of an ON signal at 100 percent and would therefore run more slowly. Using different ratios, we can drive the motors at different speeds.</p><p>We can use the hardware PWM of the Raspberry Pi (GPIO Pin 12 can use the PWM driver).</p><div><div><h3 class="title"><a id="note86"/>Note</h3><p>The PWM driver normally provides one of the audio channels of the analog audio output. Sometimes, this generates interference; therefore, it is suggested that you disconnect any devices connected to the analog audio socket.</p></div></div><p>The hardware <a class="indexterm" id="id750"/>PWM function is enabled in <code class="literal">wiringpi2</code> by<a class="indexterm" id="id751"/> setting the pin mode to <code class="literal">2</code> (which is the value of <code class="literal">PWM</code>) and specifying the on time (represented as <code class="literal">ON_TIME</code>) as follows:</p><div><pre class="programlisting">PWM_PIN=12; PWM=2; ON_TIME=512  #0-1024 Off-On

  def GPIOsetup(self):
    wiringpi2.wiringPiSetupPhys()
    wiringpi2.pinMode(PWM_PIN,PWM)
    wiringpi2.pwmWrite(PWM_PIN,ON_TIME)
    for gpio in self.pins:
      wiringpi2.pinMode(gpio,OUT)</pre></div><p>However, this is only suitable for joint PWM motor control (as it is connected to both ENA and ENB) since there is only the one available hardware PWM output.</p><p>Another alternative is to use the software PWM function of <code class="literal">wiringpi2</code>. This creates a crude PWM signal using software; depending on your requirements, this may acceptable. The code for generating a software PWM signal on GPIO Pin 7 and GPIO Pin 11 is as follows:</p><div><pre class="programlisting">PWM_PIN_ENA=7;PWM_PIN_ENA=11;RANGE=100 #0-100 (100Hz Max)
ON_TIME1=20; ON_TIME2=75 #0-100
ON_TIME1=20  #0-100
  def GPIOsetup(self):
    wiringpi2.wiringPiSetupPhys()
    wiringpi2.softPwmCreate(PWM_PIN_ENA,ON_TIME1,RANGE)
    wiringpi2.softPwmCreate(PWM_PIN_ENB,ON_TIME2,RANGE)
    for gpio in self.pins:
      wiringpi2.pinMode(gpio,OUT)</pre></div><p>The previous code sets both pins to 100 Hz, with GPIO Pin 7 set to an on time of 2 ms (and an off time of 8 ms) and GPIO Pin 11 set to 7.5 ms/2.5 ms.</p><p>To adjust the PWM timings, use <code class="literal">wiringpi2.softPwmWrite(PWM_PIN_ENA,ON_TIME2)</code>.</p><p>The accuracy of<a class="indexterm" id="id752"/> the PWM signal may be interrupted by other <a class="indexterm" id="id753"/>system processes, but it can control a small micro servo, even if it's slightly jittery.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec76"/>Using I/O expanders</h3></div></div></div><p>As we have <a class="indexterm" id="id754"/>seen previously (in <a class="link" href="ch07.html" title="Chapter 7. Sense and Display Real-World Data">Chapter 7</a>, <em>Sense and Display Real-World Data</em>), <code class="literal">wiringpi2</code> allows us to easily adjust our code to make use of I/O expanders using I<sup>2</sup>C. In this case, it can be useful to add additional circuits, such as sensors and LED status indicators, perhaps even displays and control buttons to assist with debugging and controlling the Rover-Pi robot as you develop it.</p><p>It can be particularly helpful if you intend to use it as a tethered device, since you will only require three wires to connect back to the Raspberry Pi (I<sup>2</sup>C Data GPIO Pin 3, I<sup>2</sup>C Clock GPIO Pin 5, and Ground GPIO Pin 6), with I<sup>2</sup>C VCC being provided by the motor controller 5V output.</p><p>As done earlier, add defines for the I<sup>2</sup>C address and pin base as follows:</p><div><pre class="programlisting">IO_ADDR=0x20
AF_BASE=100</pre></div><p>Then, in <code class="literal">gpiosetup()</code>, set up the MCP23017 device using the following code:</p><div><pre class="programlisting">wiringpi2.mcp23017Setup(AF_BASE,IO_ADDR)</pre></div><p>Ensure that any pin references you make are numbered 100-115 (to refer to the I/O expander pins A0-7 and B0-7) with <code class="literal">AF_BASE</code> added (which is the pin offset for the I/O expander).</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec70"/>Building a six-legged Pi-Bug robot</h1></div></div></div><p>Controlling motors <a class="indexterm" id="id755"/>is very useful for creating vehicle-like robots, but creating more naturally behaving robot components such as servos can provide excellent results. There are many creative designs of insect-like robots, or even biped designs (with humanoid-like legs), that use servos to provide natural joint movements. The design in this example uses three servos, but these principles and concepts can easily be applied to far more complex designs, to control legs/arms that use multiple servos. The Pi-Bug robot is shown in the following image:</p><div><img alt="Building a six-legged Pi-Bug robot" src="img/6623OT_09_021.jpg"/><div><p>The six-legged Pi-Bug robot uses a servo driver to control three servos to scuttle around</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec195"/>Getting ready</h2></div></div></div><p>You will need the <a class="indexterm" id="id756"/>following hardware:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>A PWM driver module</strong>: A driver module such as the Adafruit 16-Channel 12-bit PWM/Servo Driver will be needed. This uses a PCA9685 device; see the datasheet at <a class="ulink" href="http://www.adafruit.com/datasheets/PCA9685.pdf">http://www.adafruit.com/datasheets/PCA9685.pdf</a> for details.</li><li class="listitem" style="list-style-type: disc"><strong>3 x micro servos</strong>: The MG90S 9g <a class="indexterm" id="id757"/>Metal Gear Servos provide a reasonable amount of torque at a low cost.</li><li class="listitem" style="list-style-type: disc"><strong>A heavy gauge wire</strong>: This will form the legs; three giant paper clips (76 mm/3 inches) are ideal for this.</li><li class="listitem" style="list-style-type: disc"><strong>A light gauge wire / cable ties</strong>: These will be used to connect the legs to the servos and to mount the servos to the main board.</li><li class="listitem" style="list-style-type: disc"><strong>A small section of plywood or fiberboard</strong>: Holes can be drilled into this, and the servos can be mounted on it.</li></ul></div><p>You will need to have wiringPi2 installed to control the PWM module, and it will be useful to install the I<sup>2</sup>C tools for debugging. See <a class="link" href="ch07.html" title="Chapter 7. Sense and Display Real-World Data">Chapter 7</a>, <em>Sense and Display Real-world Data</em>, for details on how to install WiringPi2 and the I<sup>2</sup>C tools. The I<sup>2</sup>C connections are as shown in the following diagram:</p><div><img alt="Getting ready" src="img/6623OT_09_022.jpg"/><div><p>I<sup>2</sup>C connections on the Raspberry Pi GPIO header</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec196"/>How to do it…</h2></div></div></div><p>The Pi-Bug robot uses <a class="indexterm" id="id758"/>three servos, one on either side and one in the middle. Mount each servo by drilling a hole on either side of the servo body, loop a wire or cable ties through it, and pull to hold the servo tightly.</p><p>Bend the paper clip wire into a suitable shape to form the Pi-Bug robot's legs, and add a small kink that will allow you to wire the legs securely to the servo arms. It is recommended that you run the program first, with the Pi-Bug robot set to the home position <code class="literal">h</code> before you screw the servo arms in place. This will ensure that the legs are located in the middle.</p><p>The following diagram shows the components on the Pi-Bug robot:</p><div><img alt="How to do it…" src="img/6623OT_09_023.jpg"/><div><p>The layout of components on the Pi-Bug robot</p></div></div><p>Create the <a class="indexterm" id="id759"/>following <code class="literal">servoAdafruit.py</code> script to control the servos:</p><div><pre class="programlisting">#!/usr/bin/env python3
#servoAdafruit.py
import wiringpi2
import time

#PWM Registers
MODE1=0x00
PRESCALE=0xFE
LED0_ON_L=0x06
LED0_ON_H=0x07
LED0_OFF_L=0x08
LED0_OFF_H=0x09

PWMHZ=50
PWMADR=0x40


class servo:
  # Constructor
  def __init__(self,pwmFreq=PWMHZ,addr=PWMADR):
    self.i2c = wiringpi2.I2C()
    self.devPWM=self.i2c.setup(addr)
    self.GPIOsetup(pwmFreq,addr)

  def GPIOsetup(self,pwmFreq,addr):
    self.i2c.read(self.devPWM)
    self.pwmInit(pwmFreq)

  def pwmInit(self,pwmFreq):
    prescale = 25000000.0 / 4096.0   # 25MHz / 12-bit
    prescale /= float(pwmFreq)
    prescale = prescale - 0.5 #-1 then +0.5 to round to
                              # nearest value
    prescale = int(prescale)
    self.i2c.writeReg8(self.devPWM,MODE1,0x00) #RESET
    mode=self.i2c.read(self.devPWM)
    self.i2c.writeReg8(self.devPWM,MODE1,
                       (mode &amp; 0x7F)|0x10) #SLEEP
    self.i2c.writeReg8(self.devPWM,PRESCALE,prescale)
    self.i2c.writeReg8(self.devPWM,MODE1,mode) #restore mode
    time.sleep(0.005)
    self.i2c.writeReg8(self.devPWM,MODE1,mode|0x80) #restart

  def setPWM(self,channel, on, off):
    on=int(on)
    off=int(off)
    self.i2c.writeReg8(self.devPWM,
                       LED0_ON_L+4*channel,on &amp; 0xFF)
    self.i2c.writeReg8(self.devPWM,LED0_ON_H+4*channel,on&gt;&gt;8)
    self.i2c.writeReg8(self.devPWM,
                       LED0_OFF_L+4*channel,off &amp; 0xFF)
    self.i2c.writeReg8(self.devPWM,LED0_OFF_H+4*channel,off&gt;&gt;8)

def main():
  servoMin = 205  # Min pulse 1ms 204.8 (50Hz)
  servoMax = 410  # Max pulse 2ms 409.6 (50Hz)
  myServo=servo()
  myServo.setPWM(0,0,servoMin)
  time.sleep(2)
  myServo.setPWM(0,0,servoMax)
  
if __name__=='__main__':
  try:
    main()
  finally:
    print ("Finish")
#End</pre></div><p>Create the <a class="indexterm" id="id760"/>following <code class="literal">bug_drive.py</code> script to control the Pi-Bug robot:</p><div><pre class="programlisting">#!/usr/bin/env python3
#bug_drive.py
import time
import servoAdafruit as servoCon

servoMin = 205  # Min pulse 1000us 204.8 (50Hz)
servoMax = 410  # Max pulse 2000us 409.6 (50Hz)

servoL=0; servoM=1; servoR=2
TILT=10
MOVE=30
MID=((servoMax-servoMin)/2)+servoMin
CW=MID+MOVE; ACW=MID-MOVE
TR=MID+TILT; TL=MID-TILT
FWD=[TL,ACW,ACW,TR,CW,CW]#[midL,fwd,fwd,midR,bwd,bwd]
BWD=[TR,ACW,ACW,TL,CW,CW]#[midR,fwd,fwd,midL,bwd,bwd]
LEFT=[TR,ACW,CW,TL,CW,ACW]#[midR,fwd,bwd,midL,bwd,fwd]
RIGHT=[TL,ACW,CW,TR,CW,ACW]#[midL,fwd,bwd,midR,bwd,fwd]
HOME=[MID,MID,MID,MID,MID,MID]
PINS=[servoM,servoL,servoR,servoM,servoL,servoR]    
STEP=0.2
global DEBUG
DEBUG=False

class motor:
  # Constructor
  def __init__(self,pins=PINS,steptime=STEP):
    self.pins = pins
    self.steptime=steptime
    self.theServo=servoCon.servo()

  def off(self):
    #Home position
    self.drive(HOME,step)

  def drive(self,drive,step=STEP):
    for idx,servo in enumerate(self.pins):
      if(drive[idx]==servoM):
        time.sleep(step)
      self.theServo.setPWM(servo,0,drive[idx])
      if(drive[idx]==servoM):
        time.sleep(step)
      if(DEBUG):print("%s:%s"%(gpio,drive[idx]))

  def cmd(self,char,step=STEP):
    if char == 'f':
      self.drive(FWD,step)
    elif char == 'b':
      self.drive(BWD,step)
    elif char == 'r':
      self.drive(RIGHT,step)
    elif char == 'l':
      self.drive(LEFT,step)
    elif char == 'h':
      self.drive(HOME,step)
    elif char == '#':
      time.sleep(step)

def main():
  import os
  DEBUG=True
  if "CMD" in os.environ:
    CMD=os.environ["CMD"]
    INPUT=False
    print("CMD="+CMD)
  else:
    INPUT=True
  bugPi=motor()
  if INPUT:
    print("Enter CMDs [f,b,r,l,h,#]:")
    CMD=input()
  for idx,char in enumerate(CMD.lower()):
    if(DEBUG):print("Step %s of %s: %s"%(idx+1,len(CMD),char))
    bugPi.cmd(char)
  
if __name__ == '__main__':
  try:
    main()
  except KeyboardInterrupt:
    print ("Finish")
#End</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec197"/>How it works…</h2></div></div></div><p>We explain <a class="indexterm" id="id761"/>how the previous script functions by exploring how the servos are controlled using a PWM. Next, we see how the servo class provides the methods to control the PCA9685 device. Finally, we look at how the movements of the three servos combine to produce forward and turning motions for the Pi-Bug robot itself.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec77"/>Controlling the servos</h3></div></div></div><p>To control the servos <a class="indexterm" id="id762"/>used for the Pi-Bug robot, we require a special control signal that will determine the angle that the servo is required to move to. We will send the servo a PWM signal where the duration of the on time will allow us to control the angle of the servo arm (and thereby allow us to control the Pi-Bug robot's legs). The following diagram shows how a PWM signal can be used to control the angle of the servo:</p><div><img alt="Controlling the servos" src="img/6623OT_09_024.jpg"/><div><p>The angle of the servo is controlled by the duration of the Up Time of the PWM signal</p></div></div><p>Most servos will have an angular range of approximately 180 degrees and the mid-position of 90 degrees. A PWM frequency of 50 Hz will have a period of 20 ms, and the mid-position of 90 degrees typically corresponds to an <strong>Up Time</strong> of 1.5 ms, with a range of +/- 0.5 ms to 0.4 ms for near 0 degrees and near 180 degrees. Each type of servo will be slightly different, but you should be able to adjust the code to suit if required. The following diagram shows how you can control the servo angle using different PWM Up Times:</p><div><img alt="Controlling the servos" src="img/6623OT_09_025.jpg"/><div><p>The servo angle is controlled by sending a PWM Up-Time between 1 ms and 2 ms</p></div></div><div><div><h3 class="title"><a id="note87"/>Note</h3><p>Another type of servo is called a <strong>continuous servo</strong>
<a class="indexterm" id="id763"/> (not used here). It allows you to control the rotation speed instead of the angle, and will rotate at a constant speed, depending on the PWM signal that has been applied. Both servo types have internal feedback loops that will continuously drive the servo until the required angle or speed is reached.</p></div></div><p>Although it is theoretically <a class="indexterm" id="id764"/>possible to generate these signals using software, you will find that any tiny interruption by other processes on the system will interfere with the signal timing; this, in turn, will produce an erratic response from the servo. This is why we use a hardware PWM controller, which only needs to be set with a specific up and down time, to then generate the required signal automatically for us.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec78"/>The servo class</h3></div></div></div><p>The servo code is based on the<a class="indexterm" id="id765"/> PWM driver that Adafruit uses for their module; however, it is not Python 3 friendly, so we need to create our own version. We will use Wiringpi2's I<sup>2</sup>C driver to initialize and control the I<sup>2</sup>C PWM controller. We define the registers that we will need to use (see the datasheet for the PCA9685 device) as well as its default bus address <code class="literal">0x40</code> (PWMADR) and the PWM frequency of 50 Hz (PWMHZ).</p><p>Within our servo class, we initialize the I<sup>2</sup>C driver in <code class="literal">wiringpi2</code> and set up our <code class="literal">devPWM</code> device on the bus. Next, we initialize the PWM device itself (using <code class="literal">pwmInit()</code>). We have to calculate the <strong>prescaler</strong>
<a class="indexterm" id="id766"/> required for the device to convert the onboard 25 MHz clock to a 50 Hz signal to generate the PWM frequency we need; we will use the following formula:</p><div><img alt="The servo class" src="img/6623OT_09_026.jpg"/><div><p>The prescale register value sets the PWM frequency using a 12-bit value to scale the 25 MHz clock</p></div></div><p>The prescale value is loaded into the device, and a device reset is triggered to enable it.</p><p>Next, we create a function to allow the PWM ON and OFF times to be controlled. The <code class="literal">ON</code> and <code class="literal">OFF</code> times are 12-bit values (0-4096), so each value is split into upper and lower bytes (8 bits each) that need to be loaded into two registers. For the <code class="literal">L</code> (low) registers, we mask off the upper 8 bits using <code class="literal">&amp;0xFF</code>, and for the <code class="literal">H</code> (high) registers, we shift down by 8 bits to provide the higher 8 bits. Each PWM channel will have two registers for the on time and two for the off time, so we can multiply the addresses of the first PWM channel registers by 4 and the channel number to get the addresses of any of the others.</p><p>To test our <code class="literal">servo</code> class, we define the minimum and maximum ranges of the servos, which we calculate as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The PWM frequency of 50 Hz has a 20 ms period (<em>T=1/f</em>)</li><li class="listitem" style="list-style-type: disc">The ON/OFF times range from 0-4,096 (so 0 ms to 20 ms)</li></ul></div><p>Now, we can calculate the <a class="indexterm" id="id767"/>control values for 0 degrees (1 ms) and 180 degrees (2 ms) as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">1 ms (servo min) is equal to 4,096/20 ms, which is 204.8</li><li class="listitem" style="list-style-type: disc">2 ms (servo max) is equal to 4,096/10 ms, which is 409.6</li></ul></div><p>We round the values to the nearest whole number.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec79"/>Learning to walk</h3></div></div></div><p>The Pi-Bug robot uses a <a class="indexterm" id="id768"/>common design that allows three servos to be used to create a small, six-legged robot. The servos at the two ends provide forward and backward movement, while the servo in the middle provides the control. The following image shows the mounted servos:</p><div><img alt="Learning to walk" src="img/6623OT_09_027.jpg"/><div><p>The servos are mounted upside down on the underside of the board</p></div></div><p>The following table <a class="indexterm" id="id769"/>assumes that the left and right servos are mounted upside down on the underside of the board, with the middle servo fitted vertically. You shall have to adjust the code if mounted differently.</p><p>The following table shows the servo movements used to walk forward:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Direction</p>
</th><th style="text-align: left" valign="bottom">
<p>Middle (<code class="literal">servoM</code>)</p>
</th><th style="text-align: left" valign="bottom">
<p>Left (<code class="literal">servoL</code>)</p>
</th><th style="text-align: left" valign="bottom">
<p>Right (<code class="literal">servoR</code>)</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<strong>home</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">MID</code>/Middle</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">MID</code>/Middle</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">MID</code>/Middle</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>fwdStep1</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">TR</code>/Right side up</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ACW</code>/Legs forward</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ACW</code>/Legs backward</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>fwdStep2</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">TL</code>/Left side up</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">CW</code>/Legs backward</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">CW</code>/Legs forward</p>
</td></tr></tbody></table></div><p>The following diagram shows how the movement makes the Pi-Bug robot step forward:</p><div><img alt="Learning to walk" src="img/6623OT_09_028.jpg"/><div><p>The Pi-Bug robot moving forward</p></div></div><p>While it may seem a little confusing at first, when you see the robot moving, it should make more sense.</p><p>For the first forward step, we <a class="indexterm" id="id770"/>move the middle servo (<code class="literal">servoM</code>) clockwise so that the left side of the Pi-Bug robot is lifted off the ground by the movement of the remaining middle leg. We can then move the left servo (<code class="literal">servoL</code>) to move the legs on the left side forward (ready for movement later, they are not touching the ground at this point). Now by moving the right servo (<code class="literal">servoR</code>), we can move the legs on the right backwards (allowing the Pi-Bug robot to be pushed forward on that side).</p><p>The second forward step is the same, except that we use the middle servo (<code class="literal">servoM</code>) to lift the right side off the ground. Again, we move the legs that are off the ground forward (ready for next time) and then move the legs on the other side backward (allowing that side of the Pi-Bug robot to move forward). By repeating the forward steps, the Pi-Bug robot will move forward, or by swapping the sides that are being lifted up by the middle servo (<code class="literal">servoM</code>), it will move backward. The result is a rather bug-like scuttle!</p><p>To make the Pi-Bug robot turn, we perform a similar action, except that just like the advanced motor control for the Rover-Pi robot, we move one side of the robot forward and the other side backward. The following table shows the servo movements used to turn right:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Direction</p>
</th><th style="text-align: left" valign="bottom">
<p>Middle (<code class="literal">servoM</code>)</p>
</th><th style="text-align: left" valign="bottom">
<p>Left (<code class="literal">servoL</code>)</p>
</th><th style="text-align: left" valign="bottom">
<p>Right (<code class="literal">servoR</code>)</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<strong>home</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">MID</code>/Middle</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">MID</code>/Middle</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">MID</code>/Middle</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>rightStep1</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">TL</code>/Left side up</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">CW</code>/Legs backward</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ACW</code>/Legs backward</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>rightStep2</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">TR</code>/Right side up</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ACW</code>/Legs forward</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">CW</code>/Legs forward</p>
</td></tr></tbody></table></div><p>The steps to turn the Pi-Bug robot to the right are shown in the following diagram:</p><div><img alt="Learning to walk" src="img/6623OT_09_029.jpg"/><div><p>The Pi-Bug robot making a right turn</p></div></div><p>To turn right, we lift the <a class="indexterm" id="id771"/>left side of the Pi-Bug robot off the ground, but this time, we move the legs on both sides backward. This allows the right side of the Pi-Bug robot to move forward. The second half of the step lifts the right side off the ground, and we move the legs forward (which will push the left side of the Pi-Bug robot backward). In this manner, the bug will turn as it steps; again, just by swapping the sides that are being lifted, we can change the direction that the Pi-Bug robot will turn in.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec80"/>The Pi-Bug code for walking</h3></div></div></div><p>The code for the <a class="indexterm" id="id772"/>Pi-Bug robot has been designed to provide the same interface as the Rover-Pi robot so that they can be interchanged easily. You should notice that each class consists of the same four functions (<code class="literal">__init__()</code>, <code class="literal">off()</code>, <code class="literal">drive()</code>, and <code class="literal">cmd()</code>). The <code class="literal">__init__()</code> function defines the set of pins we will control, the <code class="literal">steptime</code> value of the walking action (this time, the gap between movements), and the previously defined servo module.</p><p>Once again, we have an <code class="literal">off()</code> function that provides a function that can be called to set the servos in their middle positions (which is very useful for when you need to fit the legs in position, as described previously in the home position). The <code class="literal">off()</code> function uses the <code class="literal">drive()</code> function to set each servo to the <code class="literal">MID</code> position. The <code class="literal">MID</code> value is halfway between <code class="literal">servoMin</code> and <code class="literal">servoMax</code> (1.5 ms to give a position of 90 degrees).</p><p>The <code class="literal">drive()</code> function is just like the previous motor control version; it cycles through each of the actions required for each servo as defined in the various movement patterns (<code class="literal">FWD</code>, <code class="literal">BWD</code>, <code class="literal">LEFT</code>, and <code class="literal">RIGHT</code>) we discussed previously. However, to reproduce the required pattern of movement, we cycle through each servo twice, while inserting a small delay whenever we move the middle servo (<code class="literal">servoM</code>). This allows time for the servo to move and provide the necessary tilt to lift the other legs off the ground before allowing them to move.</p><p>We define each<a class="indexterm" id="id773"/> of the servo commands as a clockwise (CW) or anticlockwise/counterclockwise (ACW) movement of the servo arm. Since the servos are mounted upside down, an anticlockwise (clockwise if viewed from above) movement of the left servo (<code class="literal">servoL</code>) will bring the legs forwards, while the same direction of movement on the right servo (<code class="literal">servoR</code>) will move the legs backward (which is <strong>fwdStep1</strong> in the previous diagram). In this way, each of the patterns can be defined.</p><p>Once again, we provide a test function using the following command that allows a list of instructions to either be defined from the command line or directly entered at the prompt:</p><div><pre class="programlisting">
<strong>sudo CMD=fffll##rr##bb##h python3 bug_drive.py</strong>
</pre></div><p>This includes the addition of <code class="literal">h</code> to return to the <code class="literal">home</code> position, if desired.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec71"/>Controlling servos directly with Servoblaster</h1></div></div></div><p>The previous<a class="indexterm" id="id774"/> recipe demonstrated using a dedicated servo <a class="indexterm" id="id775"/>controller to handle the control of the servos used by the PiBug. This has the advantage that any disturbances in the processing taking place on the Raspberry Pi does not cause interference with the delicate servo control (since the controller will continue to send the correct signals).</p><p>However, the Raspberry Pi is also capable of direct servo control. To achieve this we will make use of Richard Hurst's Servoblaster, which is a multiple servo driver.</p><p>In this recipe, we will control four servos attached to the MeArm, a simple laser-cut robot arm; however, you can choose to fit servos to whatever device you like.</p><div><img alt="Controlling servos directly with Servoblaster" src="img/6623OT_09_030.jpg"/><div><p>The MeArm is a simple robot arm powered by four miniature servos</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec198"/>Getting ready</h2></div></div></div><p>Most common<a class="indexterm" id="id776"/> servos will have three wires and a three pin<a class="indexterm" id="id777"/> connector as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>Black/Brown</p>
</td><td style="text-align: left" valign="top">
<p>Red</p>
</td><td style="text-align: left" valign="top">
<p>Orange/White/Yellow/Blue</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Ground</p>
</td><td style="text-align: left" valign="top">
<p>Positive Supply (Typically 5V for small servos)</p>
</td><td style="text-align: left" valign="top">
<p>Signal</p>
</td></tr></tbody></table></div><p>While it is usually possible to power the servos directly from the Raspberry Pi 5V pins on the GPIO header, they can draw a significant amount of current when moving. Unless you have a very good power supply, this can cause the Raspberry Pi to reset unexpectedly, risking corrupting the SD card. Therefore it is recommended that you power them separately, for example, with an additional USB power supply and cable connected to the ground and positive supply.</p><p>By default the servos can be wired as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<strong>Servo</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top">
<p>3</p>
</td><td style="text-align: left" valign="top">
<p>4</p>
</td><td style="text-align: left" valign="top">
<p>5</p>
</td><td style="text-align: left" valign="top">
<p>6</p>
</td><td style="text-align: left" valign="top">
<p>7</p>
</td><td style="text-align: left" valign="top">
<p>All GND</p>
</td><td style="text-align: left" valign="top">
<p>All Power</p>
</td></tr><tr><td rowspan="2" style="text-align: left" valign="top">
<p>
<strong>Raspberry Pi</strong>
</p>
<p>
<strong>GPIO Pin</strong>
</p>
</td><td colspan="9" style="text-align: center" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>7</p>
</td><td style="text-align: left" valign="top">
<p>11</p>
</td><td style="text-align: left" valign="top">
<p>12</p>
</td><td style="text-align: left" valign="top">
<p>13</p>
</td><td style="text-align: left" valign="top">
<p>15</p>
</td><td style="text-align: left" valign="top">
<p>16</p>
</td><td style="text-align: left" valign="top">
<p>19</p>
</td><td style="text-align: left" valign="top">
<p>22</p>
</td><td style="text-align: left" valign="top">
<p>6</p>
</td><td style="text-align: left" valign="top">
<p>No Connect</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>5V Power Supply</strong>
</p>
</td><td colspan="8" style="text-align: center" valign="top"> </td><td style="text-align: left" valign="top">
<p>GND</p>
</td><td style="text-align: left" valign="top">
<p>+5V</p>
</td></tr></tbody></table></div><p>We will assume we are controlling four servos (0, 1, 2 and 3) that will be fitted later to the MeArm or similar device.</p><div><img alt="Getting ready" src="img/Image11157.jpg"/></div><p>To install <a class="indexterm" id="id778"/>Servoblaster, start by downloading the <a class="indexterm" id="id779"/>source files from the Git repository:</p><div><pre class="programlisting">
<strong>cd ~</strong>
<strong>wget https://github.com/richardghirst/PiBits/archive/master.zip</strong>
</pre></div><p>Unzip and open the <code class="literal">matplotlib-master</code> folder, as follows:</p><div><pre class="programlisting">
<strong>unzip master.zip</strong>
<strong>rm master.zip</strong>
<strong>cd PiBits-master/ServoBlaster/user</strong>
</pre></div><p>We will use the user space daemon (which is located in the user directory) that is called <code class="literal">servod</code>. Before we can use it, we should compile it with this command:</p><div><pre class="programlisting">
<strong>make servod</strong>
</pre></div><p>There should be no errors, showing the following text:</p><div><pre class="programlisting">
<strong>gcc -Wall -g -O2 -o servod servod.c mailbox.c -lm</strong>
</pre></div><p>For usage information use the following command:</p><div><pre class="programlisting">
<strong>./servod --help</strong>
</pre></div><p>Now we can test a servo, first start the <strong>servod</strong> daemon (with a timeout of 2,000ms to switch off the servo off after it has moved):</p><div><pre class="programlisting">
<strong>sudo servod --idle-timeout=2000</strong>
</pre></div><p>You can move the servo's position to 0% of the servo's range:</p><div><pre class="programlisting">
<strong>echo 0=0% &gt; /dev/servoblaster</strong>
</pre></div><p>Now update the servo to 50%, causing the servo to rotate to 90 degrees (servo mid-point):</p><div><pre class="programlisting">
<strong>echo 0=50% &gt; /dev/servoblaster</strong>
</pre></div><p>As recommended by the MeArm build instructions, the servos should be connected and calibrated before building the arm, to ensure that each servo is able to move the arm in its correct range. This is done by ensuring each servo is powered up and commanded to its mid-point position (50%/90 degrees) and the servo-arm fitted at the expected orientation:</p><div><img alt="Getting ready" src="img/6623OT_09_031.jpg"/><div><p>Each of the servos should be calibrated in the correct position before you fit them on the MeArm</p></div></div><p>You can now set<a class="indexterm" id="id780"/> each of the MeArm servos (0, 1, 2 and 3) to their<a class="indexterm" id="id781"/> mid-points (by commanding each in turn to 50%) before building and fitting them to completed arm.</p><p>The servos could be used to control a wide range of alternative devices other than the MeArm, but your servos will probably need to be calibrated in a similar manor.</p><div><img alt="Getting ready" src="img/6623OT_09_032.jpg"/><div><p>The precision control of servos means they can be used for a variety of applications. For example, controlling simulated hands</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec199"/>How to do it…</h2></div></div></div><p>Create the<a class="indexterm" id="id782"/> following<a class="indexterm" id="id783"/> <code class="literal">servo_control.py</code> script:</p><div><pre class="programlisting">#!/usr/bin/env python3
#servo_control.py
import curses
import os
#HARDWARE SETUP
# GPIO	
# 2[=VX==2=======]26[=======]40
# 1[===013=======]25[=======]39
# V=5V X=Gnd
# Servo 0=Turn 1=Shoulder 2=Elbow 3=Claw
name=["Turn","Shoulder","Elbow","Claw"]
CAL=[90,90,90,90]
MIN=[0,60,40,60]; MAX=[180,165,180,180]
POS=list(CAL)
KEY_CMD=[ord('c'),ord('x')]
#Keys to rotate counter-clockwise
KEY_LESS={ord('d'):0,ord('s'):1,ord('j'):2,ord('k'):3}
#Keys to rotate clockwise
KEY_MORE={ord('a'):0,ord('w'):1,ord('l'):2,ord('i'):3}

STEP=5; LESS=-STEP; MORE=STEP #Define control steps
DEG2MS=1.5/180.0; OFFSET=1 #mseconds
IDLE=2000 #Timeout servo after command
SERVOD="/home/pi/PiBits-mater/ServoBlaster/user/servod" #Location of servod
DEBUG=True
text="Use a-d, w-s, j-l and i-k to control the MeArm. c=Cal x=eXit"

def initialize():
  cmd=("sudo %s --idle-timeout=%s"%(SERVOD, IDLE))
  os.system(cmd)

def limitServo(servo,value):
  global text
  if value &gt; MAX[servo]:
    text=("Max %s position %s:%s"%(name[servo],servo,POS[servo]))
    return MAX[servo]
  elif value &lt; MIN[servo]:
    text=("Min %s position %s:%s"%(name[servo],servo,POS[servo]))
    return MIN[servo]
  else:
    return value

def updateServo(servo,change):
  global text
  POS[servo]=limitServo(servo,POS[servo]+change)
  setServo(servo,POS[servo])
  text=str(POS)

def setServo(servo,position):
  ms=OFFSET+(position*DEG2MS)
  os.system("echo %d=%dus &gt; /dev/servoblaster" %(servo, ms/1000))

def calibrate():
  global text
  text="Calibrate 90deg"
  for i,value in enumerate(CAL):
    POS[i]=value
    setServo(i,value)

def main(term):
  term.nodelay(1)
  term.addstr(text)
  term.refresh()
  while True:
    term.move(1,0)
    c = term.getch()
    if c != -1:
      if c in KEY_MORE:
        updateServo(KEY_MORE[c],MORE)
      elif c in KEY_LESS:
        updateServo(KEY_LESS[c],LESS)
      elif c in KEY_CMD:
        if c == ord('c'):
          calibrate()
        elif c == ord('x'):
          exit()
      if DEBUG:term.addstr(text+"   ")

if __name__=='__main__':
  initialize()
  curses.wrapper(main)
#End</pre></div><p>Run the <a class="indexterm" id="id784"/>script:</p><div><pre class="programlisting">
<strong>python3 servo_control.py</strong>
</pre></div><p>You can control <a class="indexterm" id="id785"/>the servos fitted to the MeArm (or whatever you are using) as prompted:</p><div><pre class="programlisting">Use a-d, w-s, j-l and i-k to control the MeArm. c=Cal x=eXit</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec200"/>How it works…</h2></div></div></div><p>The script starts by importing the <code class="literal">curses</code> and <code class="literal">os</code> modules. A standard python <code class="literal">input()</code> command would require the <em>Enter</em> key to be pressed after each key press before we could act upon it. However, as we will see shortly, the <code class="literal">curses</code> module simply allows us to scan for keyboard presses and respond to them immediately. We use the <code class="literal">os</code> module to call the servoblaster commands, as we would via the terminal.</p><p>First, we define our setup, such as the servo mappings, calibration positions, min/max ranges, our control keys and the STEP size in degrees for each control command. We also define our parameters for our requested angle (in degrees) to target PWM signal up-time (in milliseconds) calculation.</p><div><div><h3 class="title"><a id="note88"/>Note</h3><p>Note: For these particular servos an up-time of 1 ms is equal to 0 degrees and 2.5 ms is 180 degrees, so we have an offset (<code class="literal">OFFSET</code>) of 1 ms and a scale (<code class="literal">DEG2MS</code>) of 180 degrees/1.5 ms.</p></div></div><p>Therefore, our required up-time (in milliseconds) can be calculated as <em>OFFSET + (degrees*DEG2MS)</em>. Finally, we define the SERVOD command line and servo <code class="literal">IDLE</code> timeout to initialize the servoblaster user daemon. Within <code class="literal">initialize ()</code> we use <code class="literal">os.system()</code> to start the servod daemon as we did before.</p><p>In order to detect keypresses, we call the <code class="literal">main()</code> function of the script from <code class="literal">curses.wrapper()</code>, allowing term to control the terminal input and output. We use <code class="literal">term.nodelay(1)</code> so when we do check for any keypresses (using <code class="literal">term.getch()</code>) execution will continue normally. We use <code class="literal">term.addstr(text)</code> to show the user the control keys and then update the display via <code class="literal">term.refresh()</code>. The remaining script checks the terminal for keypresses and the result assigned to <code class="literal">c</code>. If no key was pressed, then <code class="literal">term.getch()</code> returns <code class="literal">-1</code>, otherwise the ASCII equivalent value is returned and we can check for it in each of the dictionaries we defined for control keys. We will use <code class="literal">KEY_MORE</code> and <code class="literal">KEY_LESS</code> to change the servo positions and <code class="literal">KEY_CMD</code> (<code class="literal">c</code> or <code class="literal">x</code>) to allow us to set all the servos to their calibrated position or to exit cleanly. Finally, we display any useful debugging information (if <code class="literal">DEBUG</code> is set to <code class="literal">True</code>) using <code class="literal">term.addstr()</code> and ensure it is displayed at (1,0) in the terminal (one line down from the top).</p><p>For normal control, the position of the servos will be controlled using the <code class="literal">updateServo()</code> function, which adjusts the current position (stored in the POS array) by the required change (either <code class="literal">+STEP</code> or <code class="literal">–STEP</code>). We ensure the new position is within the MAX/MIN limits defined and report if we've hit them. The servo is then instructed to move to the required position using <code class="literal">setServo()</code> specifying the needed PWM up-time in micro seconds.</p><p>The <a class="indexterm" id="id786"/>last function, <code class="literal">calibrate()</code>, called when c is pressed, simply <a class="indexterm" id="id787"/>sets each of the servos to the angle defined in the <code class="literal">CAL</code> array (using <code class="literal">setServo()</code>) and ensures the current position is kept up to date.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec72"/>Using an Infra-Red Remote Control with your Raspberry Pi</h1></div></div></div><p>It is often<a class="indexterm" id="id788"/> useful to control robots remotely. An <a class="indexterm" id="id789"/>easy way to add additional input is to make use of an IR (infra-red) receiver and a standard remote control. Fortunately, the receiver is well supported.</p><p>We will use a module called LIRC to capture and decode IR signals from a standard remote control.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec201"/>Getting Ready</h2></div></div></div><p>LIRC supports many types of IR detectors, such as Energenie's PiMote IR board; however, since we only need to receive IR signals, we can use a simple (TSOP38238) IR detector.</p><div><img alt="Getting Ready" src="img/6623OT_09_033.jpg"/><div><p>The three pins of the TSOP38238 IR Receiver can fit directly onto the Raspberry Pi header</p></div></div><p>Install the following packages using <code class="literal">apt-get</code>:</p><div><pre class="programlisting">
<strong>sudo apt-get install lirc lirc-x</strong>
</pre></div><p>Add the following to <code class="literal">/boot/config.txt</code>. This will enable the driver and define the pin the receiver is fitted on (BCM GPIO24):</p><div><pre class="programlisting">
<strong>dtoverlay=lirc-rpi,gpio_in_pin=23</strong>
</pre></div><p>Perform a <a class="indexterm" id="id790"/>restart of the Raspberry Pi so <a class="indexterm" id="id791"/>that the configuration takes effect:</p><div><pre class="programlisting">
<strong>sudo reboot</strong>
</pre></div><p>We should now find that the IR device is located at <code class="literal">/dev/lirc0</code>. We can observe the output of the receiver if we point a remote control at it and press some buttons after using the following command (use <em>Ctrl</em> + <em>Z</em> to exit):</p><div><pre class="programlisting">
<strong>mode2 –d /dev/lirco0</strong>
</pre></div><div><div><h3 class="title"><a id="note89"/>Note</h3><p>
<strong>Note</strong>: If the <code class="literal">lirc0</code> resource is reported as busy:</p><div><pre class="programlisting">
<strong>  mode2: could not open /dev/lirc0</strong>
<strong>  mode2: default_init(): Device or resource busy</strong>
</pre></div><p>We will need to stop the <code class="literal">lirc</code> service:</p><div><pre class="programlisting">
<strong>sudo /etc/init.d/lirc stop</strong>
</pre></div><p>Which will give the following response:</p><div><pre class="programlisting">
<strong>[ ok ] Stopping lirc (via systemctl): lirc.service</strong>
</pre></div><p>When you are ready, you can start the service again:</p><div><pre class="programlisting">
<strong>sudo /etc/init.d/lirc start</strong>
</pre></div><p>This will give the following response:</p><div><pre class="programlisting">
<strong>[ ok ] Starting lirc (via systemctl): lirc.service</strong>
</pre></div></div></div><p>You will see output similar to the following (if not ensure you have connected the receiver connected to the correct pins on the Raspberry Pi GPIO):</p><div><pre class="programlisting">
<strong>space 16300</strong>
<strong>pulse 95</strong>
<strong>space 28794</strong>
<strong>pulse 80</strong>
<strong>space 19395</strong>
<strong>pulse 83</strong>
<strong>...etc…</strong>
</pre></div><p>Now that we know our device is working, we can configure it.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec202"/>How to do it…</h2></div></div></div><p>The global LIRC <a class="indexterm" id="id792"/>configurations are<a class="indexterm" id="id793"/> stored in <code class="literal">/etc/lirc</code>. We are interested in the following files:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">hardware.conf</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Defines where our IR sensor is installed and overall setting for our sensor.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">lircd.conf</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The remote control configuration file; this contains the recorded outputs for your remote control's keys and maps them to specific key symbols. You can often obtain pre-recorded files from <a class="ulink" href="http://lirc.sourceforge.net/remotes">lirc.sourceforge.net/remotes</a> or we can record a custom one as shown next.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">lircrc</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This file provides mapping of each of the key symbols to specific commands or keyboard mappings.</p>
</td></tr></tbody></table></div><div><div><h3 class="title"><a id="note94"/>Note</h3><p>
<strong>Note</strong>: All the LIRC configurations stored in <code class="literal">/etc/lirc</code> are available for all users; however, if required, different configurations can be defined for each user by placing them in specific home folders, for example <code class="literal">/home/pi/.config/</code>, allowing the defaults to be overridden.</p></div></div><p>There are three parts steps setting up the sensor, one for each of the LIRC configuration files:</p><div><ol class="orderedlist arabic"><li class="listitem">First, ensure <code class="literal">hardware.conf</code> is set up. For our sensor, we must ensure the following is set:<div><pre class="programlisting">    LIRCD_ARGS="--uinput"
    DRIVER="default"
    DEVICE="/dev/lirc0"
    MODULES="lirc_rpi"</pre></div></li><li class="listitem">Next, obtain a <code class="literal">lircd.conf</code> file, or if you do not have one for your remote, we can generate it. The following process will now take you through detecting each of the individual keys on the remote. For the purpose of this recipe, we only need to map eight keys (to control the four servos from the previous recipe).</li><li class="listitem">If you want map additional keys, use the following command to find out the full list of valid key symbols:<div><pre class="programlisting">
<strong>irrecord --list-namespace</strong>
</pre></div><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">KEY_UP</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KEY_RIGHT</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KEY_VOLUMEUP</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KEY_CHANNELUP</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">KEY_DOWN</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KEY_LEFT</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KEY_VOLUMEDOWN</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">KEY_CHANNELDOWN</code></p>
</td></tr></tbody></table></div><div><img alt="How to do it…" src="img/6623OT_09_034.jpg"/><div><p>We can use the volume, channel, and direction buttons on this Goodmans remote as our MeArm controller</p></div></div></li></ol></div><p>First, we will<a class="indexterm" id="id794"/> need to stop the <code class="literal">lirc</code> service, which, if it <a class="indexterm" id="id795"/>was running would be using the <code class="literal">/dev/lirc0</code> device:</p><div><pre class="programlisting">
<strong>sudo /etc/init.d/lirc stop</strong>
</pre></div><p>Next, start the capture process using the following commands:</p><div><pre class="programlisting">
<strong>irrecord –d /dev/lirc0 ~/lircd.conf</strong>
</pre></div><div><img alt="How to do it…" src="img/6623OT_09_035.jpg"/><div><p>Record each button on the remote using the irrecord tool</p></div></div><p>Now that we have <a class="indexterm" id="id796"/>captured the required keys, we<a class="indexterm" id="id797"/> ensure the name of the remote is set (by default it will be set to name of the <code class="literal">lirc.conf</code> file when the buttons are captured):</p><div><pre class="programlisting">
<strong>nano ~/lircd.conf</strong>
</pre></div><p>Set the name of the remote in the file, for example, Goodmans:</p><div><pre class="programlisting">
<strong>...</strong>
<strong>begin remote</strong>
<strong>  name  Goodmans</strong>
<strong>  bits           16 </strong>
<strong>...</strong>
</pre></div><p>Finally, we can replace the configuration in the <code class="literal">/etc/lirc</code> folder:</p><div><pre class="programlisting">
<strong>sudo cp ~/lircd.conf /etc/lirc/lirc.conf</strong>
</pre></div><div><div><h3 class="title"><a id="note95"/>Note</h3><p>
<strong>Note</strong>: We can confirm the key symbols which are mapped to the remote using the <code class="literal">irw</code> program as follows:</p><div><pre class="programlisting">
<strong>irw</strong>
</pre></div></div></div><p>This will report the details of the key pressed and the remote control as defined:</p><div><pre class="programlisting">0000000000fe7a85 00 KEY_UP Goodmans
0000000000fe7a85 01 KEY_UP Goodmans
0000000000fe6a95 00 KEY_DOWN Goodmans
0000000000fe6a95 01 KEY_DOWN Goodmans
...</pre></div><p>Now we can map the<a class="indexterm" id="id798"/> keys to specific commands; in this <a class="indexterm" id="id799"/>case we will map them to the keys we used for controlling the MeArm servos. Create a new <code class="literal">/etc/lirc/lircrc</code> file:</p><div><pre class="programlisting">
<strong>sudo nano /etc/lirc/lircrc</strong>
</pre></div><p>Replace with the following content:</p><div><pre class="programlisting">begin
  prog=irxevent
  button=KEY_UP
  config=Key w CurrentWindow
end
begin
  prog=irxevent
  button=KEY_DOWN
  config=Key s CurrentWindow
end
begin
  prog=irxevent
  button=KEY_LEFT
  config=Key a CurrentWindow
end
begin
  prog=irxevent
  button=KEY_RIGHT
  config=Key d CurrentWindow
end
begin
  prog=irxevent
  button=KEY_VOLUMEUP
  config=Key i CurrentWindow
end
begin
  prog=irxevent
  button=KEY_VOLUMEDOWN
  config=Key k CurrentWindow
end
begin
  prog=irxevent
  button=KEY_CHANNELUP
  config=Key l CurrentWindow
end
begin
  prog=irxevent
  button=KEY_CHANNELDOWN
  config=Key j CurrentWindow
end</pre></div><p>To apply the configuration, you<a class="indexterm" id="id800"/> may need to restart the<a class="indexterm" id="id801"/> service (or if that doesn't work, try restarting the Raspberry Pi):</p><div><pre class="programlisting">
<strong>sudo /etc/init.d/lirc restart</strong>
</pre></div><p>When we run the <code class="literal">servo_control.py</code> script in the previous recipe, the remote should control the arm directly.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec203"/>There's more…</h2></div></div></div><p>LIRC supports<a class="indexterm" id="id802"/> several helper programs, of which <code class="literal">irxevent</code> is just one:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td rowspan="2" style="text-align: left" valign="top">
<p>remote</p>
</td><td style="text-align: left" valign="top">
<p>By default, LIRC<a class="indexterm" id="id803"/> supports some simple controls, for example:</p>
<div><pre class="programlisting">  prog=remote
  button=KEY_UP
  config=UP</pre></div><p>
</p>
<p>This will provide <a class="indexterm" id="id804"/>simple cursor control from a remote (UP, DOWN, LEFT, RIGHT and also ENTER) that are perfect for simple menu control.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.lirc.org/html/configure.html#lircrc_format">http://www.lirc.org/html/configure.html#lircrc_format</a>
</p>
</td></tr><tr><td rowspan="2" style="text-align: left" valign="top">
<p>
<code class="literal">irxevent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Emulates button <a class="indexterm" id="id805"/>clicks and key presses within X applications. You can specify that the key event occurs in the <code class="literal">CurrentWindow</code> or in a specific window by name, that is, <code class="literal">leafpad</code>. This only works if you <a class="indexterm" id="id806"/>are running from the graphical desktop environment (or using X-forwarding).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.lirc.org/html/irxevent.html">http://www.lirc.org/html/irxevent.html</a>
</p>
</td></tr><tr><td rowspan="2" style="text-align: left" valign="top">
<p>irpty</p>
</td><td style="text-align: left" valign="top">
<p>Converts<a class="indexterm" id="id807"/> infrared remote commands into key strokes for controlling a particular program:</p>
<div><pre class="programlisting">  rog=irpty
  button=KEY_EXIT
  config=x</pre></div><p>
</p>
<p>Start it by specifying <a class="indexterm" id="id808"/>the <code class="literal">lircrc</code> configuration and program you want to control:</p>
<div><pre class="programlisting">irpty /etc/lirc/lircrc -- leafpad</pre></div><p>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.lirc.org/html/irpty.html">http://www.lirc.org/html/irpty.html</a>
</p>
</td></tr><tr><td rowspan="2" style="text-align: left" valign="top">
<p>irexec</p>
</td><td style="text-align: left" valign="top">
<p>Allows<a class="indexterm" id="id809"/> commands to be run directly from the<a class="indexterm" id="id810"/> remote control:</p>
<div><pre class="programlisting">
<code class="literal">  prog=irexec</code>
<code class="literal">  button=KEY_POWER</code>
<code class="literal">  config=sudo halt #Power Down</code>
</pre></div><p>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.lirc.org/html/irexec.html">http://www.lirc.org/html/irexec.html</a>
</p>
</td></tr></tbody></table></div><p>You can test any part of the <code class="literal">lircrc</code> file by using <code class="literal">ircat</code> with the required <code class="literal">prog</code>:</p><div><pre class="programlisting">
<strong>ircat irxevent</strong>
</pre></div><p>The preceding command will report the following:</p><div><pre class="programlisting">
<strong>Key k CurrentWindow</strong>
<strong>Key i CurrentWindow</strong>
</pre></div><p>Finally, if you have suitable IR Transmitter LED attached (including protective resistor/switching transistor) you can also use LIRC to send infra-red signals from the Raspberry Pi. For this you can use the <code class="literal">irsend</code> command, for example:</p><div><pre class="programlisting">
<strong>irsend SEND_ONCE Goodmans KEY_PROGRAMUP</strong>
</pre></div><p>The IR output channel is enabled within the <code class="literal">/boot/config.txt</code> file (assuming connected to GPIO Pin 19):</p><div><pre class="programlisting">
<strong>dtoverlay=lirc-rpi,gpio_in_pin=24,gpio_out_pin=19</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec73"/>Avoiding objects and obstacles</h1></div></div></div><p>To avoid obstacles, you <a class="indexterm" id="id811"/>can place sensors around the robot's perimeter to activate <a class="indexterm" id="id812"/>whenever an object is encountered. Depending on how you want your robot to behave, one avoidance strategy is to just reverse any action (with an additional turn for forward/backward actions) that was last taken that caused one of the sensors to be activated.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec204"/>Getting ready</h2></div></div></div><p>You need some micro switches to be triggered when there is an impact with objects. Depending on the type you have, you need to place enough switches to detect any object around the outside (if required, you can use an additional length of wire to extend the reach of the switch). Shown in the following image are two possible sensors that will cause the switch to activate when the spring or the metal arm hits an object. You need to determine which contacts of the <a class="indexterm" id="id813"/>switch open <a class="indexterm" id="id814"/>or close the circuit (this will depend on the device).</p><div><img alt="Getting ready" src="img/6623OT_09_036.jpg"/><div><p>Small micro switches can be used as collision sensors</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec205"/>How to do it…</h2></div></div></div><p>Connect the switches to the GPIO using a method similar to the one we used previously in <a class="link" href="ch06.html" title="Chapter 6. Using Python to Drive Hardware">Chapter 6</a>, <em>Using Python to Drive Hardware</em>, for the D-Pad controller. A circuit diagram of the switches is as follows:</p><div><img alt="How to do it…" src="img/6623OT_09_037.jpg"/><div><p>The switches should include current limiting resistors (1K ohm is ideal)</p></div></div><p>How you connect to the<a class="indexterm" id="id815"/> Raspberry Pi's GPIO will depend on how your motor/servo drive <a class="indexterm" id="id816"/>is wired up. For example, a Rover-Pi robot with the H-bridge motor controller can be wired up as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th colspan="8" style="text-align: center" valign="bottom">
<p>Control side of the module – connecting to the Raspberry Pi GPIO header</p>
</th></tr><tr><th style="text-align: left" valign="bottom">
<p>ENA</p>
</th><th style="text-align: left" valign="bottom">
<p>IN1</p>
</th><th style="text-align: left" valign="bottom">
<p>IN2</p>
</th><th style="text-align: left" valign="bottom">
<p>IN3</p>
</th><th style="text-align: left" valign="bottom">
<p>IN4</p>
</th><th style="text-align: left" valign="bottom">
<p>ENB</p>
</th><th style="text-align: left" valign="bottom">
<p>GND</p>
</th><th style="text-align: left" valign="bottom">
<p>5V</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>Pin 15</p>
</td><td style="text-align: left" valign="top">
<p>Pin 16</p>
</td><td style="text-align: left" valign="top">
<p>Pin 18</p>
</td><td style="text-align: left" valign="top">
<p>Pin 22</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td><td style="text-align: left" valign="top">
<p>Pin 6</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td></tr></tbody></table></div><p>Four additional proximity/collision sensors can be connected to the Raspberry Pi GPIO as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th colspan="5" style="text-align: center" valign="bottom">
<p>Proximity/collision sensors – connecting to the Raspberry Pi GPIO header</p>
</th></tr><tr><th style="text-align: left" valign="bottom">
<p>R_FWD</p>
</th><th style="text-align: left" valign="bottom">
<p>L_FWD</p>
</th><th style="text-align: left" valign="bottom">
<p>R_BWD</p>
</th><th style="text-align: left" valign="bottom">
<p>L_BWD</p>
</th><th style="text-align: left" valign="bottom">
<p>GND</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Pin 7</p>
</td><td style="text-align: left" valign="top">
<p>Pin 11</p>
</td><td style="text-align: left" valign="top">
<p>Pin 12</p>
</td><td style="text-align: left" valign="top">
<p>Pin 13</p>
</td><td style="text-align: left" valign="top">
<p>Pin 6</p>
</td></tr></tbody></table></div><p>If you wired it differently, you <a class="indexterm" id="id817"/>can adjust the pin numbers within the code as required. If you <a class="indexterm" id="id818"/>require additional pins, then any of the multipurpose pins, such as RS232 RX/TX (pins 8 and 10) or the SPI/I<sup>2</sup>C, can be used as normal GPIO pins too; just set them as input or output as normal. Normally, we just avoid using them as they are often more useful for expansion and other things, so it is sometimes useful to keep them available.</p><p>You can even use a single GPIO pin for all your sensors if you are just using the following example code, since the action is the same, regardless of which sensor is triggered. However, by wiring each one separately, you can adjust your strategy based on where the obstacle is around the robot or provide additional debug information about which sensor has been triggered.</p><p>Create the following <code class="literal">avoidance.py</code> script:</p><div><pre class="programlisting">#!/usr/bin/env python3
#avoidance.py
import rover_drive as drive
import wiringpi2
import time

opCmds={'f':'bl','b':'fr','r':'ll','l':'rr','#':'#'}
PINS=[7,11,12,13]   # PINS=[L_FWD,L_BWD,R_FWD,R_BWD]
ON=1;OFF=0
IN=0;OUT=1
PULL_UP=2;PULL_DOWN=1

class sensor:
  # Constructor
  def __init__(self,pins=PINS):
    self.pins = pins
    self.GPIOsetup()

  def GPIOsetup(self):
    wiringpi2.wiringPiSetupPhys()
    for gpio in self.pins:
      wiringpi2.pinMode(gpio,IN)
      wiringpi2.pullUpDnControl(gpio,PULL_UP)    

  def checkSensor(self):
    hit = False
    for gpio in self.pins:
      if wiringpi2.digitalRead(gpio)==False:
        hit = True
    return hit

def main():
  myBot=drive.motor()
  mySensors=sensor()
  while(True):
    print("Enter CMDs [f,b,r,l,#]:")
    CMD=input()
    for idx,char in enumerate(CMD.lower()):
      print("Step %s of %s: %s"%(idx+1,len(CMD),char))
      myBot.cmd(char,step=0.01)#small steps
      hit = mySensors.checkSensor()
      if hit:
        print("We hit something on move: %s Go: %s"%(char,
                                              opCmds[char]))
        for charcmd in opCmds[char]:
          myBot.cmd(charcmd,step=0.02)#larger step

if __name__ == '__main__':
  try:
    main()
  except KeyboardInterrupt:
    print ("Finish")
#End</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec206"/>How it works…</h2></div></div></div><p>We import <code class="literal">rover_drive</code> to control <a class="indexterm" id="id819"/>the robot (if we are using a Pi-Bug robot, <code class="literal">bug_drive</code> can be used) and <code class="literal">wiringpi2</code> so that we can use the GPIO to read the sensors (defined as <code class="literal">PINS</code>). We <a class="indexterm" id="id820"/>define <code class="literal">opCmds</code>, which uses a Python dictionary to allocate new commands in response to the original command (using <code class="literal">opCmds[char]</code>, where <code class="literal">char</code> is the original command).</p><p>We create a new class called <code class="literal">sensor</code> and set up each of the switches as GPIO input (each with an internal pull-ups set). Now, whenever we make a movement (as earlier, from the list of requested commands in the <code class="literal">main()</code> function), we check to see if any of the switches have been triggered (by calling <code class="literal">mySensor.checkSensor()</code>).</p><p>If a switch was tripped, we stop the current movement and then move in the opposite direction. However, if we are moving forward when one of the sensors is triggered, we move backward and then turn. This <a class="indexterm" id="id821"/>allows the robot to gradually turn away from the object that<a class="indexterm" id="id822"/> is blocking its path and continue its movement in another direction. Similarly, if we are moving backwards and a sensor is triggered, we move forward and then turn. By combining simple object avoidance with directional information, the robot can be commanded to navigate around as desired.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec207"/>There's more…</h2></div></div></div><p>There are also ways to detect objects that are near the robot without actually making physical contact with it. One such way is to use ultrasonic sensors, commonly used for vehicle reversing/parking sensors.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec81"/>Ultrasonic reversing sensors</h3></div></div></div><p>Ultrasonic sensors provide <a class="indexterm" id="id823"/>an excellent way to measure the distance of the robot from obstacles (providing a measurement of between 2 cm and 20 cm) and are available at most electrical hobby stores (see the <a class="link" href="apa.html" title="Appendix A. Hardware and Software List">Appendix</a>, <em>Hardware and Software List</em>). The ultrasonic module functions by sending a short burst of ultrasonic pulses and then measures the time it takes for the receiver to detect the echo. The module then produces a pulse on the echo output that is equal to the time measured. This time is equal to the distance travelled divided by the speed of sound (340.29 m/sec or 34,029 cm/s), which is the distance from the sensor to the object and back again. An ultrasonic module is shown in the following image:</p><div><img alt="Ultrasonic reversing sensors" src="img/6623OT_09_38.jpg"/><div><p>The HC-SR04 ultrasonic sensor module</p></div></div><p>The sensor requires 5V to power it; it has an input that will receive the trigger pulse and an output that the echo pulse will be sent on. While the module works with a 3.3V trigger pulse, it responds with a 5V signal on the echo line; so, it requires some extra resistors to protect the Raspberry Pi's GPIO. </p><p>The following circuit diagram shows the connection of the sensor output:</p><div><img alt="Ultrasonic reversing sensors" src="img/6623OT_09_39.jpg"/><div><p>The sensor echo output must be connected to the Raspberry Pi via a potential divider</p></div></div><p>The resistors <strong>Rt</strong> and <strong>Rb</strong> create a <a class="indexterm" id="id824"/>potential divider; the aim is to drop the echo voltage from 5V to around 3V (but not less than 2.5V). Use the following equation from <a class="link" href="ch07.html" title="Chapter 7. Sense and Display Real-World Data">Chapter 7</a>, <em>Sense and Display Real-world Data</em>, to obtain the output voltage:</p><div><img alt="Ultrasonic reversing sensors" src="img/6623OT_09_40.jpg"/><div><p>The output voltage (Vout) of the potential divider is calculated using this equation</p></div></div><p>This means that we should aim for an <strong>Rt</strong> to <strong>Rb</strong> ratio of 2:3 to give 3V (and not lower than 1:1, which would give 2.5V); that is, <strong>Rt</strong> equals 2K ohm and <strong>Rb</strong> equals 3K ohm, or 330 ohm and 470 ohm will be fine.</p><p>If you have a voltage meter, you can check it (with everything else disconnected). Connect the top of the potential divider to GPIO Pin 2 (5V), the bottom to GPIO Pin 6 (GND), and measure the voltage from the <a class="indexterm" id="id825"/>middle (it should be around 3V).</p><p>Create the following <code class="literal">sonic.py</code> script:</p><div><pre class="programlisting">#!/usr/bin/python3
#sonic.py
import wiringpi2
import time
import datetime

ON=1;OFF=0; IN=0;OUT=1
TRIGGER=15; ECHO=7
PULSE=0.00001 #10us pulse

SPEEDOFSOUND=34029 #34029 cm/s

def gpiosetup():
  wiringpi2.wiringPiSetupPhys()
  wiringpi2.pinMode(TRIGGER,OUT)
  wiringpi2.pinMode(ECHO,IN)
  wiringpi2.digitalWrite(TRIGGER,OFF)
  time.sleep(0.5)

def pulse():
  wiringpi2.digitalWrite(TRIGGER,ON)
  time.sleep(PULSE)
  wiringpi2.digitalWrite(TRIGGER,OFF)
  starttime=time.time()
  stop=starttime
  start=starttime
  while wiringpi2.digitalRead(ECHO)==0 and start&lt;starttime+2:
    start=time.time()
  while wiringpi2.digitalRead(ECHO)==1 and stop&lt;starttime+2:
    stop=time.time()
  delta=stop-start
  print("Start:%f Stop:%f Delta:%f"%(start,stop,delta))
  distance=delta*SPEEDOFSOUND
  return distance/2.0
  
def main():
  global run
  gpiosetup()
  while(True):
    print("Sample")
    print("Distance:%.1f"%pulse())
    time.sleep(2)
    
if __name__ == '__main__':
  try:
    main()
  except KeyboardInterrupt:
    print ("Finish")
#End</pre></div><p>First, we define the pins <code class="literal">TRIGGER</code> and <code class="literal">ECHO</code>, the length of the trigger pulse, and also the speed of sound (340.29 m/s). The <code class="literal">TRIGGER</code> pin is set as an output and the <code class="literal">ECHO</code> as an input (we will not need a pull-up or pull-down resistor since the module already has one).</p><p>The <code class="literal">pulse()</code> function <a class="indexterm" id="id826"/>will send a short trigger pulse (10 microseconds); then it will time the duration of the echo pulse. We then calculate the total distance travelled by dividing the duration by the speed of sound (the distance to the object is just half of this value).</p><p>Unfortunately, the sensor can get confused with certain types of objects; it will either detect echoes that bounce off a nearby object before being reflected back or not pick up narrow items such as chair legs. However, combined with localized collision sensors, the ultrasonic sensor can aid with the general navigation and avoidance of the larger objects.</p><p>An improvement to this setup would be to mount the sonic sensor on top of a servo, thereby allowing you to make a sensor sweep of the robot's surroundings. By making multiple sweeps, taking distance measurements, and tracking the angle of the servo, you could build an internal map of the robot's surroundings.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec74"/>Getting a sense of direction</h1></div></div></div><p>In order to navigate your robot <a class="indexterm" id="id827"/>around the environment, you will need to keep track of which way your robot is facing. You can estimate the angle that your robot turns at by measuring the angle that it turned at in a fixed time period. For wheeled robots, you can also measure the rotation of each wheel using a rotary encoder (a device that provides a count of the wheel's rotations). However, as you make the robot take multiple turns, the direction the robot is facing becomes more and more uncertain as differences in the surfaces and the grip of the wheels or legs cause differences in the angles that the robot is turning at.</p><p>Fortunately, we can use an electronic version of a compass; it allows us to determine the direction that the robot is facing by providing an angle from magnetic North. If we know which direction the robot is facing, we can receive commands requesting a particular angle and ensure that the robot moves towards it. This allows the robot to perform controlled movements and navigate as required.</p><p>When given a target angle, we can determine which direction we need to turn towards, until we reach it.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec208"/>Getting ready</h2></div></div></div><p>You need a magnetometer <a class="indexterm" id="id828"/>device such as the PiBorg's<a class="indexterm" id="id829"/> <strong>XLoBorg</strong> module (which is a combined I<sup>2</sup>C magnetometer and accelerometer). In this example, we focus on the magnetometer (the smaller chip on the left) output only. The XLoBorg module looks as shown in the following image:</p><div><img alt="Getting ready" src="img/6623OT_09_41.jpg"/><div><p>The PiBorg XLoBorg module contains a 3-axis magnetometer and accelerometer</p></div></div><p>This device can be used with both types of robot, and the angle information received from the module can be used to determine which direction the robot needs to move in.</p><p>The module is designed to connect directly to the GPIO header, which will block all the remaining pins. So in order to use <a class="indexterm" id="id830"/>other GPIO devices, a GPIO splitter (such as the PiBorg <strong>TriBorg</strong>) can be used. Alternatively, you can use Dupont female to male patch wires to connect just the I<sup>2</sup>C pins. The connections to be made are shown in the following diagram:</p><div><img alt="Getting ready" src="img/6623OT_09_42.jpg"/><div><p>Connections to manually wire the XLoBorg module to the Raspberry Pi (using standard I<sup>2</sup>C connections)</p></div></div><p>When viewed from the <a class="indexterm" id="id831"/>underside, the PiBorg XLoBorg pins are mirrored compared to the Raspberry Pi GPIO header.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec209"/>How to do it…</h2></div></div></div><p>Create a Python 3-friendly version of the XLoBorg library (<code class="literal">XLoBorg3.py</code>) using <code class="literal">wiringpi2</code> as follows:</p><div><pre class="programlisting">#!/usr/bin/env python3
#XLoBorg3.py
import wiringpi2
import struct
import time

def readBlockData(bus,device,register,words):
  magData=[]
  for i in range(words):
    magData.append(bus.readReg16(device,register+i))
  return magData

class compass:
  def __init__(self):
    addr = 0x0E #compass
    self.i2c = wiringpi2.I2C()
    self.devMAG=self.i2c.setup(addr)
    self.initCompass()

  def initCompass(self):
    # Acquisition mode
    register = 0x11   # CTRL_REG2
    data  = (1 &lt;&lt; 7)  # Reset before each acquisition
    data |= (1 &lt;&lt; 5)  # Raw mode, do not apply user offsets
    data |= (0 &lt;&lt; 5)  # Disable reset cycle
    self.i2c.writeReg8(self.devMAG,register,data)
    # System operation
    register = 0x10   # CTRL_REG1
    data  = (0 &lt;&lt; 5)  # Output data rate
                      # (10 Hz when paired with 128 oversample)
    data |= (3 &lt;&lt; 3)  # Oversample of 128
    data |= (0 &lt;&lt; 2)  # Disable fast read
    data |= (0 &lt;&lt; 1)  # Continuous measurement
    data |= (1 &lt;&lt; 0)  # Active mode
    self.i2c.writeReg8(self.devMAG,register,data)

  def readCompassRaw(self):
    #x, y, z = readCompassRaw()
    self.i2c.write(self.devMAG,0x00)
    [status, xh, xl, yh, yl,
      zh, zl, who, sm, oxh, oxl,
      oyh, oyl, ozh, ozl,
      temp, c1, c2] = readBlockData(self.i2c,self.devMAG, 0, 18)
    # Convert from unsigned to correctly signed values
    bytes = struct.pack('BBBBBB', xl, xh, yl, yh, zl, zh)
    x, y, z = struct.unpack('hhh', bytes)
    return x, y, z

if __name__ == '__main__':
  myCompass=compass()
  try:
    while True:
      # Read the MAG Data
      mx, my, mz = myCompass.readCompassRaw()
      print ("mX = %+06d, mY = %+06d, mZ = %+06d" % (mx, my, mz))
      time.sleep(0.1)
  except KeyboardInterrupt:
    print("Finished")
#End</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec210"/>How it works…</h2></div></div></div><p>The script is based on the <a class="indexterm" id="id832"/>XLoBorg library available for the XLoBorg module, except that we use WiringPi2, which is Python 3-friendly, to perform the I<sup>2</sup>C actions. Just like our motor/servo drivers, we also define it as a class so that we can drop it into our code and easily replace it with alternative devices if required.</p><p>We import <code class="literal">wiringpi2</code>, <code class="literal">time</code>, and also a library called <code class="literal">struct</code> (which allows us to quickly unpack a block of data read from the device into separate items).</p><p>We create the <code class="literal">compass</code> class, which will include the <code class="literal">__init__()</code>, <code class="literal">initCompass()</code>, and <code class="literal">readCompassRaw()</code> functions. The <code class="literal">readCompassRaw()</code> function is the equivalent of the standard XLoBorg <code class="literal">ReadCompassRaw()</code> function provided by their library.</p><p>The <code class="literal">__init__()</code> function sets up the I<sup>2</sup>C bus with <code class="literal">wiringpi2</code> and registers the <code class="literal">degMAG</code> device on the bus address <code class="literal">0x0E</code>. The <code class="literal">initCompass()</code> function sets the <code class="literal">CTRL_REG1</code> and <code class="literal">CTRL_REG2</code> registers of the device with the settings required to quickly get raw readings from the device.</p><p>More details on the MAG3110 registers<a class="indexterm" id="id833"/> are available at <a class="ulink" href="http://www.freescale.com/files/sensors/doc/data_sheet/MAG3110.pdf">http://www.freescale.com/files/sensors/doc/data_sheet/MAG3110.pdf</a>.</p><p>The <code class="literal">readCompassRaw()</code> function reads the data registers of the device in a single block (using the custom <a class="indexterm" id="id834"/>function <code class="literal">readBlockData()</code>). It reads all the 18 registers of the device (<code class="literal">0x00</code> through to <code class="literal">0x11</code>). The sensor readings we need are contained within the registers <code class="literal">0x01</code> to <code class="literal">0x06</code>, which contain the <em>x</em>, <em>y</em>, and <em>z</em> readings split into upper and lower bytes (8-bit values). The <code class="literal">struct.pack()</code> and <code class="literal">struct.unpack()</code> functions provide an easy way to package them together and resplit them as separate words (16-bit values).</p><p>We can test our script by creating a <code class="literal">myCompass</code> object from the <code class="literal">compass</code> class and reading the sensor values using <code class="literal">myCompass.readCompassRaw()</code>. You will see the raw x, y, and z values from the device, just as you would from the standard XLoBorg library.</p><p>As you will find, these values aren't much use on their own since they are uncalibrated and only give you RAW readings from the magnetometer. What we need is a far more useful angle relative to magnetic North (see the following <em>There's more…</em> section for details on how to do this).</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec211"/>There's more…</h2></div></div></div><p>So far, the basic library allows us to see the strength of the magnetic field on each of the three axes around the sensor (up/down, left/right, and forward/backward). While we can see that these values will change as we move the sensor around, this is not enough to steer our robot. First, we need to calibrate the sensor and then determine the direction of the robot from the readings of the <em>x</em> and <em>y</em> axes.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec82"/>Calibrating the compass</h3></div></div></div><p>The compass needs to be <a class="indexterm" id="id835"/>calibrated in order to report values that are centered and equalized. This is needed because there are magnetic fields all around, so by calibrating the sensor, we can cancel out the effect of any localized fields.</p><p>By measuring the readings of the compass on all axes, we can determine the minimum and maximum values for each axis. This will allow us to calculate both the midpoint of the readings and also the scaling so that each axis will read the same value whenever it is facing the same way.</p><p>Add the following code at the top of the file (after the <code class="literal">import</code> statements):</p><div><pre class="programlisting">CAL=100 #take CAL samples</pre></div><p>Add the following code to <code class="literal">__init__(self)</code> of the <code class="literal">compass</code> class:</p><div><pre class="programlisting">    self.offset,self.scaling=self.calibrateCompass()
    if DEBUG:print("offset:%s scaling:%s"%(str(self.offset),
                                           str(self.scaling)))</pre></div><p>Add a new function<a class="indexterm" id="id836"/> named <code class="literal">calibrateCompass()</code> within the <code class="literal">compass</code> class as follows:</p><div><pre class="programlisting">  def calibrateCompass(self,samples=CAL):
    MAXS16=32768
    SCALE=1000.0
    avg=[0,0,0]
    min=[MAXS16,MAXS16,MAXS16];max=[-MAXS16,-MAXS16,-MAXS16]
    print("Rotate sensor around axis (start in 5 sec)")
    time.sleep(5)
    for calibrate in range(samples):
      for idx,value in enumerate(self.readCompassRaw()):
        avg[idx]+=value
        avg[idx]/=2
        if(value&gt;max[idx]):
          max[idx]=value
        if(value&lt;min[idx]):
          min[idx]=value
      time.sleep(0.1)
      if DEBUG:print("#%d min=[%+06d,%+06d,%+06d]"
                     %(calibrate,min[0],min[1],min[2])
                     +" avg[%+06d,%+06d,%+06d]"
                     %(avg[0],avg[1],avg[2])
                     +" max=[%+06d,%+06d,%+06d]"
                     %(max[0],max[1],max[2]))
    offset=[]
    scaling=[]
    for idx, value in enumerate(min):
      magRange=max[idx]-min[idx]
      offset.append((magRange/2)+min[idx])
      scaling.append(SCALE/magRange)
    return offset,scaling</pre></div><p>Add another new function named <code class="literal">readCompass()</code> in the <code class="literal">compass</code> class as follows:</p><div><pre class="programlisting">  def readCompass(self):
    raw = self.readCompassRaw()
    if DEBUG:print("mX = %+06d, mY = %+06d, mZ = %+06d"
                   % (raw[0],raw[1],raw[2]))
    read=[]
    for idx,value in enumerate(raw):
      adj=value-self.offset[idx]
      read.append(adj*self.scaling[idx])
    return read</pre></div><p>If you look closely at<a class="indexterm" id="id837"/> the readings (if you use <code class="literal">readCompass()</code>), you will now find that all the readings have the same range and are centered around the same values.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec83"/>Calculating the compass bearing</h3></div></div></div><p>The XLoBorg library<a class="indexterm" id="id838"/> only provides access to the RAW values of the MAG3110 device, which provides a measure of how strong the magnetic field is on each of the axes. To determine the direction of the sensor, we can use the readings from the <em>x</em> and <em>y</em> axes (assuming we have mounted and calibrated the sensor horizontally). The readings of the <em>x</em> and <em>y</em> axes are proportional to the magnetic field in each direction around the sensor, as shown in the following diagram:</p><div><img alt="Calculating the compass bearing" src="img/6623OT_09_43.jpg"/><div><p>The magnetometer measures the strength of the magnetic field on each axis</p></div></div><p>The angle at which we turned away from the north can be calculated with the formula shown in the following diagram:</p><div><img alt="Calculating the compass bearing" src="img/6623OT_09_44.jpg"/><div><p>The angle we are pointing towards that is relative to magnetic North can be calculated using the measurements Rx and Ry</p></div></div><p>We can now obtain<a class="indexterm" id="id839"/> the <code class="literal">compass</code> angle by adding the following <code class="literal">readCompassAngle()</code> function to our <code class="literal">compass</code> class, as follows:</p><div><pre class="programlisting">  def readCompassAngle(self,cal=True):
    if cal==True:
      read = self.readCompass()
    else:
      read = self.readCompassRaw()
    angle = math.atan2 (read[1],read[0]) # cal angle in radians
    if (angle &lt; 0):
      angle += (2 * math.pi) # ensure positive
    angle = (angle * 360)/(2*math.pi); #report in degrees
    return angle</pre></div><p>We also need to add the following import with the other <code class="literal">import</code> statements:</p><div><pre class="programlisting">import math</pre></div><p>We use the math function, <code class="literal">math.atan2()</code>, to calculate our angle (<code class="literal">atan2</code> will return with the angle relative to the <em>x</em> axis of the coordinates <code class="literal">read[1]</code> and <code class="literal">read[2]</code>—the angle we want). The angle is in radians, which means one full turn is defined as 2Pi rather than 360 degrees. We convert it back to degrees by multiplying it by 360 and dividing by 2Pi. Since we wish to have our angle between the range of 0 to 360 degrees (rather than -180 to 180 degrees), we must ensure that it is positive by adding the equivalent of a full circle (2Pi) to any negative values.</p><p>With the sensor calibrated and the angle calculated, we should now have proper compass bearing to use on our robot. To compare, you can see the result of using the uncalibrated value in our<a class="indexterm" id="id840"/> calculation by calling the function with <code class="literal">readCompassAngle (cal=False)</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec84"/>Saving the calibration</h3></div></div></div><p>Having calibrated the<a class="indexterm" id="id841"/> sensor once in its current position, it would be inconvenient to have to calibrate it each and every time that you run the robot. Therefore, you can add the following code to your library to automatically save your calibration and read it from a file the next time you run your robot. To create a new calibration, either delete or rename <code class="literal">mag.cal</code> (which is created in the same folder as your script) or create your <code class="literal">compass</code> object with <code class="literal">compass(newCal=True)</code>.</p><p>Add the following code near the top of the file (after the <code class="literal">imports</code> statements):</p><div><pre class="programlisting">FILENAME="mag.cal"</pre></div><p>Change <code class="literal">__init__(self)</code> to <code class="literal">__init__(self,newCal=False)</code>.</p><p>Also, consider the following line:</p><div><pre class="programlisting">self.offset,self.scaling=self.calibrateCompass()</pre></div><p>Change the previous line to the following line:</p><div><pre class="programlisting">self.offset,self.scaling=self.readCal(newCal)</pre></div><p>Add <code class="literal">readCal()</code> to the <code class="literal">compass</code> class as follows:</p><div><pre class="programlisting">  def readCal(self,newCal=False,filename=FILENAME):
    if newCal==False:
      try:
        with open(FILENAME,'r') as magCalFile:
          line=magCalFile.readline()
          offset=line.split()
          line=magCalFile.readline()
          scaling=line.split()
          if len(offset)==0 or len(scaling)==0:
            raise ValueError()
          else:
            offset=list(map(float, offset))
            scaling=list(map(float, scaling))
      except (OSError,IOError,TypeError,ValueError) as e:
        print("No Cal Data")
        newCal=True
        pass
    if newCal==True:
      print("Perform New Calibration")
      offset,scaling=self.calibrateCompass()
      self.writeCal(offset,scaling)
    return offset,scaling</pre></div><p>Add <code class="literal">writeCal()</code> to <a class="indexterm" id="id842"/>the <code class="literal">compass</code> class as follows:</p><div><pre class="programlisting">  def writeCal(self,offset,scaling):
      if DEBUG:print("Write Calibration")
      if DEBUG:print("offset:"+str(offset))
      if DEBUG:print("scaling:"+str(scaling))
      with open(FILENAME,'w') as magCalFile:
        for value in offset:
          magCalFile.write(str(value)+" ")
        magCalFile.write("\n")
        for value in scaling:
          magCalFile.write(str(value)+" ")
        magCalFile.write("\n")</pre></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec85"/>Driving the robot using the compass</h3></div></div></div><p>All that remains for us to do now is to <a class="indexterm" id="id843"/>use the compass bearing to steer our<a class="indexterm" id="id844"/> robot to the desired angle.</p><p>Create the following <code class="literal">compassDrive.py</code> script:</p><div><pre class="programlisting">#!/usr/bin/env python3
#compassDrive.py
import XLoBorg3 as XLoBorg
import rover_drive as drive
import time

MARGIN=10 #turn until within 10degs
LEFT="l"; RIGHT="r"; DONE="#"

def calDir(target, current, margin=MARGIN):
  target=target%360
  current=current%360
  delta=(target-current)%360
  print("Target=%f Current=%f Delta=%f"%(target,current,delta))
  
  if delta &lt;= margin:
    CMD=DONE
  else:
    if delta&gt;180:
      CMD=LEFT
    else:
      CMD=RIGHT
  return CMD

def main():
  myCompass=XLoBorg.compass()
  myBot=drive.motor()
  while(True):
    print("Enter target angle:")
    ANGLE=input()
    try:
      angleTarget=float(ANGLE)
      CMD=LEFT
      while (CMD!=DONE):
        angleCompass=myCompass.readCompassAngle()
        CMD=calDir(angleTarget,angleCompass)
        print("CMD: %s"%CMD)
        time.sleep(1)
        myBot.cmd(CMD)
      print("Angle Reached!")
    except ValueError:
      print("Enter valid angle!")
      pass

if __name__ == '__main__':
  try:
    main()
  except KeyboardInterrupt:
    print ("Finish")
#End</pre></div><p>We import the <a class="indexterm" id="id845"/>modules that we previously created: <code class="literal">XLoBorg3</code>, <code class="literal">rover_drive</code> (for the Rover-Pi robot or the alternative <code class="literal">bug_drive</code>, as required), and <code class="literal">time</code>. Next, we <a class="indexterm" id="id846"/>create a function that will return <code class="literal">LEFT</code>, <code class="literal">RIGHT</code>, or <code class="literal">DONE</code> based on the given target angle (requested by the user) and the current angle (read from the <code class="literal">compass</code> class). If the compass angle is within 180 degrees less than the target angle, then we turn <code class="literal">LEFT</code>. Similarly, if it is within 180 degrees, we turn <code class="literal">RIGHT</code>. Finally, if the compass angle is within the margin (+10 degrees/-10 degrees), then we are <code class="literal">DONE</code>. By using <code class="literal">angle%360</code> (which gives us the remainder from dividing the angle by 360), we ensure the angles are all 0-360 (that is, -90 becomes 270).</p><p>For the <code class="literal">main()</code> function, we create <code class="literal">myCompass</code> (an <code class="literal">XLoBorg.compass</code> object) and <code class="literal">myBot</code> (a <code class="literal">drive.motor()</code> object); these allow us to determine the direction we are facing in and provide us with a way to drive in the desired direction. Within the main loop, we prompt for a target angle, find the current angle that our robot is facing at, and then continue to turn towards the required angle until we reach it (or reach somewhere near enough).</p></div></div></div></body></html>