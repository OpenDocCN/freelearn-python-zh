<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Building and Managing Applications for Distribution</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Working with<code class="literal"> StandardPaths</code></li><li class="listitem" style="list-style-type: disc">Persisting the state of the UI</li><li class="listitem" style="list-style-type: disc">Using the<code class="literal"> SingleInstanceChecker</code></li><li class="listitem" style="list-style-type: disc">Exception handling</li><li class="listitem" style="list-style-type: disc">Optimizing for OS X</li><li class="listitem" style="list-style-type: disc">Supporting internationalization</li><li class="listitem" style="list-style-type: disc">Distributing an application</li></ul></div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec01"/>Introduction</h1></div></div></div><p>An application's infrastructure provides the backbone for the application's inner workings, which are often things that are not directly apparent to the user but are critical to the application's functionality. This includes things such as storing configuration and external data files, error handling, and installation. Each of these areas provides important functionality and contributes to the usability and the end-user's overall perception of the application. In this chapter, we will take an in-depth tour of a number of these topics and more, in order to provide you with the appropriate tools to help build and distribute your application.<a id="id430" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec02"/>Working with StandardPaths</h1></div></div></div><p>Nearly every non-trivial application is going to have the need to store data to use between usage of the program and to load resources such as images. The question is where to put this stuff? The appropriate locations where the operating system and users expect to find these files will vary from platform to platform. This recipe shows how to use<code class="literal"> wx.StandardPaths</code> to manage an application's configuration and resource files.<a id="id431" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec01"/>How to do it...</h2></div></div></div><p>Here, we will create a thin wrapper utility class to help manage an application's configuration files and data. The constructor will ensure that any predefined directories have been set up in the configuration storage location on the system.<a id="id432" class="indexterm"/>
</p><div><pre class="programlisting">class ConfigHelper(object):
    def __init__(self, userdirs=None):
        """@keyword userdirs: list of user config
                              subdirectories names
        """
        super(ConfigHelper, self).__init__()

        # Attributes
        self.userdirs = userdirs

        # Setup
        self.InitializeConfig()

    def InitializeConfig(self):
        """Setup config directories"""
        # Create main user config directory if it does
        # not exist.
        datap = wx.StandardPaths_Get().GetUserDataDir()
        if not os.path.exists(datap):
            os.mkdir(datap)
        # Make sure that any other application specific
        # config subdirectories have been created.
        if self.userdirs:
            for dname in userdirs:
                self.CreateUserCfgDir(dname)

</pre></div><p>Here, we add a helper function to create a directory in the current user's data directory:</p><div><pre class="programlisting">    def CreateUserCfgDir(self, dirname):
        """Create a user config subdirectory"""
        path = wx.StandardPaths_Get().GetUserDataDir()
        path = os.path.join(path, dirname)
        if not os.path.exists(path):
            os.mkdir(path)

</pre></div><p>The next function can be used to get the absolute path to a file or directory in the user's data directory:</p><div><pre class="programlisting">    def GetUserConfigPath(self, relpath):
        """Get the path to a resource file
        in the users configuration directory.
        @param relpath: relative path (i.e config.cfg)
        @return: string
        """
        path = wx.StandardPaths_Get().GetUserDataDir()
        path = os.path.join(path, relpath)
        return path

</pre></div><p>Finally, the last method in this class can be used to check if a given configuration file has been created yet or not:</p><div><pre class="programlisting">    def HasConfigFile(self, relpath):
        """Does a given config file exist"""
        path = self.GetUserConfigPath(relpath)
        return os.path.exists(path)

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec02"/>How it works...</h2></div></div></div><p>The<code class="literal"> ConfigHelper</code> class just provides a thin simple wrapper around some of the<code class="literal"> StandardPaths</code> methods, in order to make it a little easier to use. When the object is created, it will make sure that the user data directory and any of its application-specific subdirectories have been created. The<code class="literal"> StandardPaths</code> singleton uses the application's name to determine the name of the user's data directory. Because of this, it is important to wait until the<code class="literal"> App</code> object has been created and had its name set with<code class="literal"> SetAppName</code>.<a id="id433" class="indexterm"/>
</p><div><pre class="programlisting">class SuperFoo(wx.App):
    def OnInit(self):
        self.SetAppName("SuperFoo")
        <strong>self.config = ConfigHelper()</strong>
        self.frame = SuperFooFrame(None, title="SuperFoo")
        self.frame.Show()
        return True

    def GetConfig(self):
        return self.config

</pre></div><p>The<code class="literal"> CreateUserCfgDir</code> provides a convenient way to create a new directory inside the user's main configuration directory.<code class="literal"> GetUserConfigPath</code> can be used to get the full path to a file or directory in the configuration directory or subdirectory, by using a path relative to the main directory. Finally,<code class="literal"> HasConfigFile</code> is a simple way to check if a file exists in the user's configuration files.<a id="id434" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec03"/>There's more...</h2></div></div></div><p>The<code class="literal"> StandardPaths</code> singleton provides a number of other methods to get other system and installation-specific installation paths. The following table describes some of these additional methods:<a id="id435" class="indexterm"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Methods</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GetConfigDir()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the system-level configuration directory</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GetDataDir()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the application's global (non user specific) data directory</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GetDocumentsDir()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the current user's documents directory</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GetExecutablePath()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the path to the currently-running executable</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GetPluginsDir()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the path to where the application's plug-ins should reside</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GetTempDir()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the path to the system's<code class="literal"> TEMP</code> directory</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GetUserConigDir()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the path to the current user's configuration directory</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec04"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<em> Creating Singletons</em> recipe in<a class="link" href="ch09.html" title="Chapter 9. Design Approaches and Techniques"> Chapter 9</a>,<em> Design Approaches and Techniques</em> for a discussion about what singletons, such as the<code class="literal"> StandardPaths</code> object, are.</li><li class="listitem" style="list-style-type: disc">See the<em> Persisting the state of the UI</em> recipe in this chapter for more information on storing confirmation information.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec03"/>Persisting the state of the UI</h1></div></div></div><p>A common feature that many applications have is to be able to remember and restore their window size and position between launches of the program. This is not a built-in feature provided by the toolkit, so this recipe will create a simple<code class="literal"> Frame</code> base class that will automatically save and restore its size and position on the desktop between uses of the application.<a id="id436" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec05"/>How to do it...</h2></div></div></div><p>This example shows one approach to creating a<code class="literal"> Frame</code> class that will automatically restore its position and size between runs of the program:<a id="id437" class="indexterm"/>
</p><div><pre class="programlisting">class PersistentFrame(wx.Frame):
    def __init__(self, *args, **kwargs):
        super(PersistentFrame, self).__init__(*args, **kwargs)

        # Setup
        wx.CallAfter(self.RestoreState)

        # Event Handlers
        self.Bind(wx.EVT_CLOSE, self._OnClose)

</pre></div><p>Here, we handle<code class="literal"> EVT_CLOSE</code> for when the<code class="literal"> Frame</code> is closing, in order to save its position and size to the<code class="literal"> Config</code> object, which is the registry on Windows and a<code class="literal"> .ini</code> file on other platforms:<a id="id438" class="indexterm"/>
</p><div><pre class="programlisting">    def _OnClose(self, event):
        position = self.GetPosition()
        size = self.GetSize()
        cfg = wx.Config()
        cfg.Write('pos', repr(position.Get()))
        cfg.Write('size', repr(size.Get()))
        event.Skip()

</pre></div><p>The<code class="literal"> RestoreState</code> method restores the currently-stored window state or the default state if nothing has been stored yet:<a id="id439" class="indexterm"/>
</p><div><pre class="programlisting">    def RestoreState(self):
        """Restore the saved position and size"""
        cfg = wx.Config()
        name = self.GetName()
        position = cfg.Read(name + '.pos',
                            repr(wx.DefaultPosition))
        size = cfg.Read(name + '.size',
                        repr(wx.DefaultSize))
        # Turn strings back into tuples
        position = eval(position)
        size = eval(size)
        # Restore settings to Frame
        self.SetPosition(position)
        self.SetSize(size)

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec06"/>How it works...</h2></div></div></div><p>The<code class="literal"> PersistentFrame</code> should be used as a base class for any<code class="literal"> Frame</code> in an application that should persist its size and position on exit. The way in which this class works is rather simple, so let's take a quick look at how it works.</p><p>First, in order to save its size and position, the<code class="literal"> PersisistentFrame</code> binds an event handler to<code class="literal"> EVT_CLOSE</code>. Its<code class="literal"> _OnClose</code> method will then be called when the user closes the<code class="literal"> Frame</code>. In this event handler, we simply get the current size and position of the<code class="literal"> Frame</code> and save it to a<code class="literal"> wx.Config</code> object, which will be the registry on Windows and a<code class="literal"> .ini</code> file on other platforms.</p><p>Conversely, when the<code class="literal"> PersistentFrame</code> is created, it tries to read the previously-saved size and position from the configuration. This happens in the<code class="literal"> RestoreState</code> method, which is initiated with<code class="literal"> CallAfter</code>. This was done to make sure that we don't restore the settings until after the<code class="literal"> Frame</code> has been created, so that if a subclass sets up some default sizes they won't override the last state that the user left it in. In<code class="literal"> RestoreState</code>, if there is stored information for the<code class="literal"> Frame</code>, it will load the strings and convert them back to tuples using the<code class="literal"> eval</code> function, and then will simply apply the settings.<a id="id440" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec07"/>There's more...</h2></div></div></div><p>For simplicity, we just used<code class="literal"> wx.Config</code> for storing the settings between running the application. We could have also used<code class="literal"> StandardPaths</code> and written out our own configuration file to the user's configuration directory, like we did in the previous recipe in order to ensure that this information was kept where the user expects it to be.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec08"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<em> Working with StandardPaths</em> recipe in this chapter for information about another class that can help with storing and locating configuration information.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec04"/>Using the SingleInstanceChecker</h1></div></div></div><p>Sometimes it is desirable to only allow a single instance of an application to exist at any given time. The<code class="literal"> SingleInstanceChecker</code> class provides a way to detect if any instances of the application are already running. This recipe creates an<code class="literal"> App</code> class that uses the<code class="literal"> SingleInstanceChecker</code> to maintain only a single running instance of the application on the computer at one time, and also uses a simple IPC mechanism to allow any subsequent instances of the application to send a message to the original instance to tell it to open a new window.<a id="id441" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec09"/>How to do it...</h2></div></div></div><p>Here, we will create an<code class="literal"> App</code> base class that ensures that only one instance of the process is running at a time, and supports a simple, socket-based inter-process communication mechanism to inform an already-running instance that a new one tried to start:<a id="id442" class="indexterm"/>
</p><div><pre class="programlisting">import wx
import threading
import socket
import select

class SingleInstApp(wx.App):
    """App baseclass that only allows a single instance to
    exist at a time.
    """
    def __init__(self, *args, **kwargs):
        super(SingleInstApp, self).__init__(*args, **kwargs)

        # Setup (note this will happen after subclass OnInit)
        instid = "%s-%s" % (self.GetAppName(), wx.GetUserId())
        self._checker = wx.SingleInstanceChecker(instid)
        if self.IsOnlyInstance():
           # First instance so start IPC server
           self._ipc = IpcServer(self, instid, 27115)
           self._ipc.start()
           # Open a window
           self.DoOpenNewWindow()
        else:
            # Another instance so just send a message to
            # the instance that is already running.
            cmd = "OpenWindow.%s" % instid
            if not SendMessage(cmd, port=27115):
                print "Failed to send message!"

    def __del__(self):
        self.Cleanup()

</pre></div><p>The<code class="literal"> SingleInstanceChecker</code> needs to be explicitly deleted when the application exits to ensure that the file lock that it creates is released:<a id="id443" class="indexterm"/>
</p><div><pre class="programlisting">    def Cleanup(self):
        # Need to cleanup instance checker on exit
        if hasattr(self, '_checker'):
            del self._checker
        if hasattr(self, '_ipc'):
            self._ipc.Exit()

    def Destroy(self):
        self.Cleanup()
        super(SingleInstApp, self).Destroy()

    def IsOnlyInstance(self):
        return not self._checker.IsAnotherRunning()

    def DoOpenNewWindow(self):
        """Interface for subclass to open new window
        on ipc notification.
        """
        pass

</pre></div><p>The<code class="literal"> IpcServer</code> class implements the inter-process communication by opening a connection to a socket on the local loopback of the machine. This has been implemented as a background thread that loops, waiting for messages, until it is told to exit:<a id="id444" class="indexterm"/>
</p><div><pre class="programlisting">class IpcServer(threading.Thread):
    """Simple IPC Server"""
    def __init__(self, app, session, port):
        super(IpcServer, self).__init__()

        # Attributes
        self.keeprunning = True
        self.app = app
        self.session = session
        self.socket = socket.socket(socket.AF_INET,
                                    socket.SOCK_STREAM)

        # Setup TCP socket
        self.socket.bind(('127.0.0.1', port))
        self.socket.listen(5)
        self.setDaemon(True)

</pre></div><p>The<code class="literal"> run</code> method runs the server thread's main loop of checking the socket for messages and using<code class="literal"> CallAfter</code> to notify the<code class="literal"> App</code> to call its<code class="literal"> DoOpenNewWindow</code> method when the server has received an<code class="literal">'OpenWindow'</code> command:<a id="id445" class="indexterm"/>
</p><div><pre class="programlisting">    def run(self):
        """Run the server loop"""
        while self.keeprunning:
            try:
                client, addr = self.socket.accept()

                # Read from the socket
                # blocking up to 2 seconds at a time
                ready = select.select([client,],[], [],2)
                if ready[0]:
                    recieved = client.recv(4096)

                if not self.keeprunning:
                    break

                # If message ends with correct session
                # ID then process it.
                if recieved.endswith(self.session):
                    if recieved.startswith('OpenWindow'):
                        wx.CallAfter(self.app.DoOpenNewWindow)
                    else:
                        # unknown command message
                        pass
                recieved = ''
            except socket.error, msg:
                print "TCP error! %s" % msg
                break

        # Shutdown the socket
        try:
            self.socket.shutdown(socket.SHUT_RDWR)
        except:
            pass

        self.socket.close()

    def Exit(self):
        self.keeprunning = False

</pre></div><p>The<code class="literal"> SendMessage</code> function is used to open a client connection to the<code class="literal"> IpcServer's</code> socket and send it the given message:<a id="id446" class="indexterm"/>
</p><div><pre class="programlisting">def SendMessage(message, port):
    """Send a message to another instance of the app"""
    try:
        # Setup the client socket
        client = socket.socket(socket.AF_INET,
                               socket.SOCK_STREAM)
        client.connect(('127.0.0.1', port))
        client.send(message)
        client.shutdown(socket.SHUT_RDWR)
        client.close()
    except Exception, msg:
        return False
    else:
        return True

</pre></div><p>Included with the code that accompanies this chapter is a complete running application showing how to use the above framework. To test it out, try starting multiple instances of the application on the same computer, and see that only the original process is running and that each subsequent launch results in a new window being opened in the original process.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec10"/>How it works...</h2></div></div></div><p>We packed a lot of stuff into a small amount of code in this recipe, so let's go through how each class works.</p><p>The<code class="literal"> SingleInstApp</code> class creates a<code class="literal"> SingleInstanceChecker</code> object to make it possible to detect if there is already another instance of the application running. As a part of the ID for the<code class="literal"> SingleInstanceChecker</code>, we used the user's login ID to make sure that the instance checker is only checking for other instances that the same user has started.<a id="id447" class="indexterm"/>
</p><p>In our<code class="literal"> SingleInstanceApp</code> object's<code class="literal"> __init__</code> method, it is important to realize the order of operations that will take place when a derived class is initialized. Calling the base<code class="literal"> wx.App</code> class<code class="literal"> __init__</code> will result in the derived class's virtual<code class="literal"> OnInit</code> being called, and then after that the rest of the code in the<code class="literal"> SingleInstApp's __init__</code> will run. If it detects that this is the first instance of the application running, it will create and start our<code class="literal"> IpcServer</code>. If not, it will simply create and send a simple string command to the other, already-running,<code class="literal"> IpcServer</code> object to tell it to inform the other application instance to create a new window.</p><p>Before moving on to look at the<code class="literal"> IpcServer</code> class, one very important thing to keep in mind when using the<code class="literal"> SingleInstanceChecker</code> is that you need to explicitly delete it when you are done with it. If it is not deleted, the file lock that it uses for determining if another instance is active or not may never get released, which can cause problems on future launches of the program.<a id="id448" class="indexterm"/>
</p><p>The<code class="literal"> IpcServer</code> class is a simple class derived from<code class="literal"> Thread</code> that uses a TCP socket for inter-process communication. As mentioned, the first<code class="literal"> SingleInstanceApp</code> that is started will create an instance of this server. The server will run in its own thread, checking for messages at the socket. The<code class="literal"> IpcServer</code> thread's<code class="literal"> run</code> method just runs a loop, checking the socket for new data. If it is able to read a message, it checks that the last part of the message matches the key that was used to create the<code class="literal"> App's SingleInstanceChecker</code>, to make sure that the command is coming from another instance of the application. We have only designed support for a single<code class="literal">'OpenWindow'</code> command in our simple IPC protocol right now, but it could be easily expanded to support more. Upon receiving an<code class="literal"> OpenWindow</code> message, the<code class="literal"> IpcServer</code> will use<code class="literal"> CallAfter</code> to call the<code class="literal"> SingleInstanceApp's</code> interface method<code class="literal"> DoOpenNewWindow</code> to inform the application to open a new instance of its main window.<a id="id449" class="indexterm"/>
</p><p>The last part of this little framework is the<code class="literal"> SendMessage</code> function, which is used as a client method to connect and send a message to the<code class="literal"> IpcServer</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec11"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<em> Understanding inheritance limitations</em> recipe in<a class="link" href="ch01.html" title="Chapter 1. Getting Started with wxPython"> Chapter 1</a>,<em> Getting Started with wxPython</em> for an explanation about overriding virtual methods in wxPython classes.</li><li class="listitem" style="list-style-type: disc">See the<em> Understanding thread safety</em> recipe in<a class="link" href="ch11.html" title="Chapter 11. Using Threads and Timers to Create Responsive Interfaces"> Chapter 11</a>,<em> Responsive Interfaces</em> for more information about working with threads in a wxPython GUI.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec05"/>Exception handling</h1></div></div></div><p>In even seemingly-simple applications, it can be difficult to account for all possible error conditions that could occur in the application. This recipe shows how to handle unhandled exceptions, and how to display a notification to the user to let them know that an unexpected error has happened, before the application exits.<a id="id450" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec12"/>How to do it...</h2></div></div></div><p>For this recipe, we will show how to create a simple exception hook to handle and inform the user of any unexpected errors that occur while the program is running:<a id="id451" class="indexterm"/>
</p><div><pre class="programlisting">import wx
import sys
import traceback

def ExceptionHook(exctype, value, trace):
    """Handler for all unhandled exceptions
    @param exctype: Exception Type
    @param value: Error Value
    @param trace: Trace back info
    """
    # Format the traceback
    exc = traceback.format_exception(exctype, value, trace)
    ftrace = "".join(exc)
    app = wx.GetApp()
    if app:
        msg = "An unexpected error has occurred: %s" % ftrace
        wx.MessageBox(msg, app.GetAppName(),
                      style=wx.ICON_ERROR|wx.OK)
        app.Exit()
    else:
        sys.stderr.write(ftrace)

class ExceptionHandlerApp(wx.App):
    def OnInit(self):
        sys.excepthook = ExceptionHook
        return True

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec13"/>How it works...</h2></div></div></div><p>This recipe showed a very simple way to create an exception hook to catch unhandled exceptions in the application. During the start-up of the application, all that we needed to do was replace the default<code class="literal"> excepthook</code> function with our own<code class="literal"> ExceptionHook</code> function. The<code class="literal"> ExceptionHook</code> function will then be called any time that an unhandled exception is raised in the application. In this function, all we do is pop up a<code class="literal"> MessageBox</code> to show that an unexpected error has occurred, and then tell the<code class="literal"> MainLoop</code> to exit.<a id="id452" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec14"/>There's more...</h2></div></div></div><p>The purpose of this example was to show the process of how to handle these errors in a graceful manor. So we kept it pretty simple by just using a<code class="literal"> MessageBox</code>. It would be easy to extend and customize this example to also log the error, or to allow the user to send a notification to the developer of the application so that the error can be debugged.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec06"/>Optimizing for OS X</h1></div></div></div><p>There are a number of things that can be done in a wxPython application in order to help it fit in better when running on a Macintosh OS X system. There are a number of things that users expect from an application on OS X, and this recipe shows some of the things to do in order to make sure your application runs and looks good on OS X as well as on other platforms. This will include the proper positioning of standard menus and menu items, main window behavior, and how to enable some Macintosh-specific functionality.<a id="id453" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec15"/>How to do it...</h2></div></div></div><p>As an example of some of the things to take into consideration, we will create a simple application that shows how to make an application conform to Macintosh UI standards:</p><div><pre class="programlisting">import wx
import sys

class OSXApp(wx.App):
    def OnInit(self):
        # Enable native spell checking and right
        # click menu for Mac TextCtrl's
        if wx.Platform == '__WXMAC__':
            spellcheck = "mac.textcontrol-use-spell-checker"
            wx.SystemOptions.SetOptionInt(spellcheck, 1)
        self.frame = OSXFrame(None,
                              title="Optimize for OSX")
        self.frame.Show()
        return True

    def MacReopenApp(self):
        self.GetTopWindow().Raise()

class OSXFrame(wx.Frame):
    """Main application window"""
    def __init__(self, *args, **kwargs):
        super(OSXFrame, self).__init__(*args, **kwargs)

        # Attributes
        self.textctrl = wx.TextCtrl(self,
                                    style=wx.TE_MULTILINE)

        # Setup Menus
        mb = wx.MenuBar()
        fmenu = wx.Menu()
        fmenu.Append(wx.ID_OPEN)
        fmenu.Append(wx.ID_EXIT)
        mb.Append(fmenu, "&amp;File")
        emenu = wx.Menu()
        emenu.Append(wx.ID_COPY)
        emenu.Append(wx.ID_PREFERENCES)
        mb.Append(emenu, "&amp;Edit")
        hmenu = wx.Menu()
        hmenu.Append(wx.NewId(), "&amp;Online Help...")
        hmenu.Append(wx.ID_ABOUT, "&amp;About...")
        mb.Append(hmenu, "&amp;Help")
        
        if wx.Platform == '__WXMAC__':
            # Make sure we don't get duplicate
            # Help menu since we used non standard name
            app = wx.GetApp()
            app.SetMacHelpMenuTitleName("&amp;Help")

        self.SetMenuBar(mb)
        self.SetInitialSize()

if __name__ == '__main__':
    app = OSXApp(False)
    app.MainLoop()

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec16"/>How it works...</h2></div></div></div><p>This simple application creates a<code class="literal"> Frame</code> with a<code class="literal"> MenuBar</code> and a<code class="literal"> TextCtrl</code> in it, and demonstrates a few things to take note of when preparing an application that will be deployed to Macintosh systems.<a id="id454" class="indexterm"/>
</p><p>Starting in our<code class="literal"> OSXApp</code> object's<code class="literal"> OnInit</code> method, we used the<code class="literal"> SystemOptions</code> singleton to enable the native context menu and spellchecking feature of the<code class="literal"> TextCtrl</code> objects on OS X. This option is disabled by default; setting it to<code class="literal"> 1</code> enables it. Also in our<code class="literal"> OSXApp</code> class, we overrode the<code class="literal"> MacReopenApp</code> method, which is a callback for an<code class="literal"> AppleEvent</code> that occurs when the application's dock icon is clicked on. We overrode it to make sure that this click will cause our application's main window to be brought to the front, as expected.</p><p>Next, in our<code class="literal"> OSXFrame</code> class, it can be seen that there is some special handling needed for the<code class="literal"> Menus</code>. All native OS X applications have some common elements in their menus. All applications have a Help menu, a Windows menu, and an Application menu. If your application needs to create a custom Help or Windows menu, then some additional steps are necessary to make sure that they will work as expected on OS X. In our previous example, we created a custom Help menu that included a mnemonic accelerator in its title for Windows/GTK to use with keyboard navigation. Since the menu title is not the same as the default, we needed to call<code class="literal"> SetMacHelpMenuTitleName</code> on the<code class="literal"> App</code> object so that it knows that our Help menu should be used. If we omit this step, our application will end up with two help menus shown in the<code class="literal"> MenuBar</code> on OS X. The other important thing to note is to use stock IDs whenever possible for menu items. The About, Exit, and Preferences entries in particular will always be shown under the Application menu on OS X. By using the stock IDs for these items, wxPython will ensure that they end up in the proper locations on each platform.<a id="id455" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec17"/>There's more...</h2></div></div></div><p>Included below are some additional Macintosh-specific methods and notes, for quick reference.</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec01"/>wx.App Macintosh specific methods</h3></div></div></div><p>There are some other additional Macintosh-specific helper methods that belong to the<code class="literal"> App</code> object that can be used to customize the handling for the three special menu items. These methods will be a no-op when the application is running on another platform.<a id="id456" class="indexterm"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Methods</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SetMacAboutMenuItemId</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Change the ID used to identify the<code class="literal"> About</code> menu item from<code class="literal"> ID_ABOUT</code> to a custom value</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SetMacExitMenuItemId</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Change the ID used to identify the<code class="literal"> Exit</code> menu item from<code class="literal"> ID_EXIT</code> to a custom value</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SetMacPreferencesMenuItemId</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Change the ID used to identify the<code class="literal"> Preferences</code> menu item from<code class="literal"> ID_PREFERENCES</code> to a custom value</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SetMacSupportPCMenuShortcuts</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Enable the use of menu mnemonics on OS X</p>
</td></tr></tbody></table></div></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec02"/>wx.MenuBar</h3></div></div></div><p>It is possible to disable the automatic creation of the Windows menu on OS X by using the<code class="literal"> wx.MenuBar's</code> static<code class="literal"> SetAutoWindowMenu</code> method. Calling<code class="literal"> SetAutoWindowMenu</code> with the value of<code class="literal"> False</code> before creating a<code class="literal"> MenuBar</code> will prevent the Windows menu from being created.<a id="id457" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec18"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<em> Utilizing Stock IDs</em> recipe in<a class="link" href="ch01.html" title="Chapter 1. Getting Started with wxPython"> Chapter 1</a>,<em> Getting Started with wxPython</em> for a detailed discussion about using the built-in stock IDs.</li><li class="listitem" style="list-style-type: disc">See the<em> Handling Apple events</em> recipe in<a class="link" href="ch02.html" title="Chapter 2. Responding to Events"> Chapter 2</a>,<em> Responding to Events</em> for an example of how handle AppleEvents in a wxPython application.</li><li class="listitem" style="list-style-type: disc">See the<em> Distributing an application</em> recipe in this chapter for a discussion of how to distribute an application on OS X.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec07"/>Supporting internationalization</h1></div></div></div><p>In the interconnected world that we live in today, it is very important to take internationalization into account when developing an application's interface. There is very little to lose in designing an application that completely supports internationalization right from the beginning, but a whole lot to lose if you don't. This recipe will show how to set up an application to use wxPython's built-in support for interface translations.<a id="id458" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec19"/>How to do it...</h2></div></div></div><p>Below, we will create a complete sample application that shows how to support localization in a wxPython application's user interface. The first thing to note is the alias for<code class="literal"> wx.GetTranslation</code> that we use below to wrap all interface strings in the application:<a id="id459" class="indexterm"/>
</p><div><pre class="programlisting">import wx
import os

# Make a shorter alias
_ = wx.GetTranslation

</pre></div><p>Next, during the creation of our<code class="literal"> App</code> object, we create and save a reference to a<code class="literal"> Locale</code> object. We then tell the<code class="literal"> Locale</code> object where we keep our translation files, so that it knows where to look up translations when the<code class="literal"> GetTranslation</code> function is called:</p><div><pre class="programlisting">class I18NApp(wx.App):
    def OnInit(self):
        self.SetAppName("I18NTestApp")
        # Get Language from last run if set
        config = wx.Config()
        language = config.Read('lang', 'LANGUAGE_DEFAULT')

        # Setup the Locale
        self.locale = wx.Locale(getattr(wx, language))
        path = os.path.abspath("./locale") + os.path.sep
        self.locale.AddCatalogLookupPathPrefix(path)
        self.locale.AddCatalog(self.GetAppName())

        # Local is not setup so we can create things that
        # may need it to retrieve translations.
        self.frame = TestFrame(None,
                               title=_("Sample App"))
        self.frame.Show()
        return True

</pre></div><p>Then, in the rest, we create a simple user interface that will allow the application to switch the language between English and Japanese:</p><div><pre class="programlisting">class TestFrame(wx.Frame):
    """Main application window"""
    def __init__(self, *args, **kwargs):
        super(TestFrame, self).__init__(*args, **kwargs)

        # Attributes
        self.panel = TestPanel(self)

        # Layout
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.panel, 1, wx.EXPAND)
        self.SetSizer(sizer)
        self.SetInitialSize((300, 300))

class TestPanel(wx.Panel):
    def __init__(self, parent):
        super(TestPanel, self).__init__(parent)

        # Attributes
        self.closebtn = wx.Button(self, wx.ID_CLOSE)
        self.langch = wx.Choice(self,
                                choices=[_("English"),
                                         _("Japanese")])

        # Layout
        self.__DoLayout()

        # Event Handler
        self.Bind(wx.EVT_CHOICE, self.OnChoice)
        self.Bind(wx.EVT_BUTTON,
                  lambda event: self.GetParent().Close())

    def __DoLayout(self):
        vsizer = wx.BoxSizer(wx.VERTICAL)
        hsizer = wx.BoxSizer(wx.HORIZONTAL)

        label = wx.StaticText(self, label=_("Hello"))
        hsizer.AddStretchSpacer()
        hsizer.Add(label, 0, wx.ALIGN_CENTER)
        hsizer.AddStretchSpacer()

        langsz = wx.BoxSizer(wx.HORIZONTAL)
        langlbl = wx.StaticText(self, label=_("Language"))
        langsz.AddStretchSpacer()
        langsz.Add(langlbl, 0, wx.ALIGN_CENTER_VERTICAL)
        langsz.Add(self.langch, 0, wx.ALL, 5)
        langsz.AddStretchSpacer()
        
        vsizer.AddStretchSpacer()
        vsizer.Add(hsizer, 0, wx.EXPAND)
        vsizer.Add(langsz, 0, wx.EXPAND|wx.ALL, 5)
        vsizer.Add(self.closebtn, 0, wx.ALIGN_CENTER)
        vsizer.AddStretchSpacer()

        self.SetSizer(vsizer)

    def OnChoice(self, event):
        sel = self.langch.GetSelection()
        config = wx.Config()
        if sel == 0:
            val = 'LANGUAGE_ENGLISH'
        else:
            val = 'LANGUAGE_JAPANESE'
        config.Write('lang', val)

if __name__ == '__main__':
    app = I18NApp(False)
    app.MainLoop()

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec20"/>How it works...</h2></div></div></div><p>The little sample application above shows how to make use of the support for translations in a wxPython application. Changing the selected language in the<code class="literal"> Choice</code> control and restarting the application will change the interface strings between English and Japanese. Making use of translations is pretty easy, so let's just take a look at the important parts that make it work.<a id="id461" class="indexterm"/>
</p><p>First, we created an alias of<code class="literal"> _</code> for the function<code class="literal"> wx.GetTranslation</code>, so that it is shorter to type and easier to read. This function should be wrapped around any string in the application that will be shown to the user in the interface.</p><p>Next, in our Application's<code class="literal"> OnInit</code> method, we did a few things to set up the proper locale information for loading the configured translations. First, we created a<code class="literal"> Locale</code> object. It is necessary to keep a reference to this object so that it does not get garbage collected. Hence, we saved it to<code class="literal"> self.locale</code>. Next, we set up the<code class="literal"> Locale</code> object to let it know where our translation resource files are located, by first calling<code class="literal"> AddCatalogLookupPathPrefix</code> with the directory where we keep our translation files. Then we tell it the name of the resource files for our application by calling<code class="literal"> AddCatalog</code> with the name of our application object. In order for the translations to be loaded, the following directory structure is required for each language under the catalog lookup path prefix directory:</p><div><pre class="programlisting">Lang_Canonical_Name/LC_MESSAGES/CatalogName.mo
</pre></div><p>So, for example, for our application's Japanese translation, we have the following directory layout under our locale directory.</p><div><pre class="programlisting">ja_JP/LC_MESSAGES/I18NTestApp.mo
</pre></div><p>After the<code class="literal"> Locale</code> object has been created, any calls to<code class="literal"> GetTranslation</code> will use the locale to load the appropriate string from the<code class="literal"> gettext</code> catalog file.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec21"/>There's more...</h2></div></div></div><p>wxPython uses<code class="literal"> gettext-formatted</code> files for loading string resources from. There are two files for each translation. The<code class="literal"> .po</code> file (Portable Object) is the file that is edited to create the mapping of the default string to the translated version. The other file is the<code class="literal"> .mo</code> file (Machine Object) which is the compiled version of the<code class="literal"> .po</code> file. To compile a<code class="literal"> .po</code> file to a<code class="literal"> .mo</code> file, you need to use the<code class="literal"> msgfmt</code> tool. This is part of<code class="literal"> gettext</code> on any Linux platform. It can also be installed on OS X through<code class="literal"> fink</code>, and on Windows through<code class="literal"> Cygwin</code>. The following command line statement will generate the<code class="literal"> .mo</code> file from the given input<code class="literal"> .po</code> file.<a id="id462" class="indexterm"/>
</p><div><pre class="programlisting"><strong>msgfmt ja_JP.po</strong>
</pre></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec08"/>Distributing an application</h1></div></div></div><p>Once the application that you have been working on is complete, it is time to put together a way to distribute the application to its users. wxPython applications can be distributed like any other Python application or script, by creating a<code class="literal"> setup.py</code> script and using the<code class="literal"> distutils</code> module's<code class="literal"> setup</code> function. However, this recipe will focus on how to create standalone executables for Windows and OS X by creating a build script that uses<code class="literal"> py2exe</code> and<code class="literal"> py2app</code> respectively for the two target platforms. Creating a standalone application makes it much easier for the user to install the application on their system, which means that more people are likely to use it.<a id="id463" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec22"/>Getting ready</h2></div></div></div><p>To build standalone binaries, some extension modules are needed in addition to wxPython. So if you haven't already done so, you will need to install<code class="literal"> py2exe</code> (Windows) or<code class="literal"> py2app</code> (OS X).</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec23"/>How to do it...</h2></div></div></div><p>Here, we will create a simple<code class="literal"> setup.py</code> template that, with a few simple customizations, can be used to build Windows and OS X binaries for most wxPython applications. The<strong> Application Information</strong> section here at the top can be modified to specify the application's name and other specific information.</p><div><pre class="programlisting">import wx
import sys

#---- Application Information ----#
APP = "FileEditor.py"
NAME = "File Editor"
VERSION = "1.0"
AUTHOR = "Author Name"
AUTHOR_EMAIL = "authorname@someplace.com"
URL = "http://fileeditor_webpage.foo"
LICENSE = "wxWidgets"
YEAR = "2010"

#---- End Application Information ----#

</pre></div><p>Here, we will define a method that uses<code class="literal"> py2exe</code> to build a Windows executable from the Python script specified in the<code class="literal"> APP</code> variable in the Application Information section:</p><div><pre class="programlisting">RT_MANIFEST = 24

def BuildPy2Exe():
    """Generate the Py2exe files"""
    from distutils.core import setup
    try:
        import py2exe
    except ImportError:
        print "\n!! You dont have py2exe installed. !!\n"
        exit()

</pre></div><p>Windows binaries have a manifest embedded in them that specifies dependencies and other settings. The sample code that accompanies this chapter includes the following two XML files that will ensure that the GUI has the proper themed controls when running on Windows XP and greater:<a id="id464" class="indexterm"/>
</p><div><pre class="programlisting">    pyver = sys.version_info[:2]
    if pyver == (2, 6):
        fname = "py26manifest.xml"
    elif pyver == (2, 5):
        fname = "py25manifest.xml"
    else:
        vstr = ".".join(pyver)
        assert False, "Unsupported Python Version %s" % vstr
    with open(fname, 'rb') as handle:
        manifest = handle.read()
        manifest = manifest % dict(prog=NAME)


</pre></div><p>The<code class="literal"> OPTS</code> dictionary specifies the<code class="literal"> py2exe</code> options. These are some standard settings that should be good for most applications, but they can be tweaked further if necessary for specific use cases:</p><div><pre class="programlisting">    OPTS = {"py2exe" : {"compressed" : 1,
                        "optimize" : 1,
                        "bundle_files" : 2,
                        "excludes" : ["Tkinter",],
                        "dll_excludes": ["MSVCP90.dll"]}}

</pre></div><p>The<code class="literal"> windows</code> keyword to the<code class="literal"> setup</code> function is used to specify that we are creating a GUI application and is used to specify what the application icon and manifest are to embed in the binary:<a id="id465" class="indexterm"/>
</p><div><pre class="programlisting">    setup(
        name = NAME,
        version = VERSION,
        options = OPTS,
        windows = [{"script": APP,
                    "icon_resources": [(1, "Icon.ico")],
                    "other_resources" : [(RT_MANIFEST, 1,
                                          manifest)],
                  }],
        description = NAME,
        author = AUTHOR,
        author_email = AUTHOR_EMAIL,
        license = LICENSE,
        url = URL,
        )

</pre></div><p>Next we have our OS X build method that uses py2app to build the binary applet bundle:</p><div><pre class="programlisting">def BuildOSXApp():
    """Build the OSX Applet"""
    from setuptools import setup

</pre></div><p>Here, we define a<code class="literal"> PLIST</code>, which is very similar in purpose to the manifest used by Windows binaries. It is used to define some information about the application that the OS uses to know what roles the application fills.<a id="id466" class="indexterm"/>
</p><div><pre class="programlisting">    # py2app uses this to generate the plist xml for
    # the applet.
    copyright = "Copyright %s %s" % (AUTHOR, YEAR)
    appid = "com.%s.%s" % (NAME, NAME)
    PLIST = dict(CFBundleName = NAME,
             CFBundleIconFile = 'Icon.icns',
             CFBundleShortVersionString = VERSION,
             CFBundleGetInfoString = NAME + " " + VERSION,
             CFBundleExecutable = NAME,
             CFBundleIdentifier = appid,
             CFBundleTypeMIMETypes = ['text/plain',],
             CFBundleDevelopmentRegion = 'English',
             NSHumanReadableCopyright = copyright
             )

</pre></div><p>The following dictionary specifies the<code class="literal"> py2app</code> options that<code class="literal"> setup()</code> will use when building the application:</p><div><pre class="programlisting">    PY2APP_OPTS = dict(iconfile = "Icon.icns",
                       argv_emulation = True,
                       optimize = True,
                       plist = PLIST)

    setup(
        app = [APP,],
        version = VERSION,
        options = dict( py2app = PY2APP_OPTS),
        description = NAME,
        author = AUTHOR,
        author_email = AUTHOR_EMAIL,
        license = LICENSE,
        url = URL,
        setup_requires = ['py2app'],
        )

if __name__ == '__main__':
    if wx.Platform == '__WXMSW__':
        # Windows
        BuildPy2Exe()
    elif wx.Platform == '__WXMAC__':
        # OSX
        BuildOSXApp()
    else:
        print "Unsupported platform: %s" % wx.Platform

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec24"/>How it works...</h2></div></div></div><p>With the previous set-up script, we can build standalone binaries on both Windows and OS X for our<code class="literal"> FileEditor</code> script. So let's take a look at each of the two functions,<code class="literal"> BuildPy2exe</code> and<code class="literal"> BuildOSXApp</code>, to see how each of them works.<a id="id467" class="indexterm"/>
</p><p>
<code class="literal">BuildPy2exe</code> performs the necessary preparations in order to run<code class="literal"> setup</code> for building a standalone binary on Windows machines by using<code class="literal"> py2exe</code>. There are three important parts to take note of in this function. First is the section where we create the manifest. Between versions 2.5 and 2.6, the Windows runtime libraries that were used to build the Python interpreter binaries changed. Due to this, we need to specify different dependencies in our binary's manifest in order for it to be able to load the correct runtimes and give our GUI application the correct themed appearance. The two possible manifests for either Python 2.5 or 2.6 are included with this topic's sample source code.<a id="id468" class="indexterm"/>
</p><p>Second is the<code class="literal"> py2exe</code> options dictionary. This dictionary contains the<code class="literal"> py2exe</code> specific options to use when bundling the script. We used five options:<code class="literal"> compressed, optimize, bundle_files, excludes</code>, and<code class="literal"> dll_excludes</code>. The<code class="literal"> compressed</code> option states that we want to compress the resulting<code class="literal"> .exe</code> file. The<code class="literal"> optimize</code> says to optimize the Python byte code. We can specify<code class="literal"> 0, 1</code>, or<code class="literal"> 2</code> here, for different levels of optimizations. The<code class="literal"> bundle_files</code> option specifies the level at which to bundle dependencies into the<code class="literal"> library.zip</code> file. The lower the number (<code class="literal">1-3</code>), the greater the number of files that will be bundled into the ZIP file, reducing the overall number of individual files that need to be distributed. Using<code class="literal"> 1</code> can often cause problems with wxPython applications, so using<code class="literal"> 2</code> or<code class="literal"> 3</code> is suggested. Next, the<code class="literal"> excludes</code> option is a list of modules to exclude from the resulting bundle. We specified<code class="literal"> Tkinter</code> here just to ensure that none of its dependencies accidentally get drawn in making our binary larger. Finally, the<code class="literal"> dll_excludes</code> option was used to work around an issue when using<code class="literal"> py2exe</code> with Python 2.6.<a id="id469" class="indexterm"/>
</p><p>Third and finally is the<code class="literal"> windows</code> parameter in the<code class="literal"> setup</code> command. This is used to specify that we are building a GUI application, and is where we specify the application's icon to embed into the<code class="literal"> .exe</code> as well as the manifest that we spoke of earlier.</p><p>Running<code class="literal"> setup</code> with<code class="literal"> py2exe</code> is as simple as the following command line statement:<a id="id470" class="indexterm"/>
</p><div><pre class="programlisting">
<strong>python setup.py py2exe</strong>
</pre></div><p>Now let's look at how<code class="literal"> py2app</code> works. It is very similar to<code class="literal"> py2exe</code> and actually even a little easier to use since there is no need to worry about runtime dependencies like there is on Windows. The main difference is the<code class="literal"> PLIST</code>, which is somewhat similar to a manifest on Windows, but is used to define some application behavior and to store information about the application for use by the operating system.<code class="literal"> Py2app</code> will use the specified dictionary to generate the<code class="literal"> Plist</code> XML file in the resulting application. To learn about the available<code class="literal"> Plist</code> options, see the properly listed documentation available at<a class="ulink" href="http://developer.apple.com"> http://developer.apple.com</a>. The<code class="literal"> PLIST</code> dictionary is passed to<code class="literal"> py2app</code> through the setup function's<code class="literal"> options</code> parameter, along with the other<code class="literal"> py2app</code> options that we specified, such as the application's icon. Also, very similar to<code class="literal"> py2exe</code>, running<code class="literal"> py2app</code> just requires the following command line statement:</p><div><pre class="programlisting">
<strong>python setup.py py2app</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec25"/>There's more...</h2></div></div></div><p>Included below is some additional information about some specific distribution dependency issues for Windows applications, as well as some references for creating installers for applications on Windows and OS X.</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec03"/>Py2Exe dependencies</h3></div></div></div><p>After running the<code class="literal"> py2exe</code> setup command, make sure that you review the list of dependencies that were not included, and that are listed at the end of the output. There are a couple of additional files that you may need to manually include in your application's<code class="literal"> dist</code> folder for it to run properly when deployed on a different computer. For Python 2.5, the<code class="literal"> msvcr71.dll</code> and<code class="literal"> gdiplus.dll</code> files are typically needed. For Python 2.6, the<code class="literal"> msvcr90.dll</code> and<code class="literal"> gdiplus.dll</code> files are needed. The<code class="literal"> msvcr .dll</code> files are copyrighted by Microsoft, so you should review the licensing terms to make sure you have the rights to redistribute them. If not, users may be required to install them separately using the freely-availably redistributable runtime package that can be downloaded from Microsoft's website.<a id="id471" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec04"/>Installers</h3></div></div></div><p>After building your application with either<code class="literal"> py2exe</code> or<code class="literal"> py2app</code>, you will need a way to help the application's users to properly install the files onto their systems. For Windows, there are a number of options available for building installers: NSIS (<a class="ulink" href="http://nsis.sourceforge.net">http://nsis.sourceforge.net</a>) and Inno Setup (<a class="ulink" href="http://www.jrsoftware.org/isinfo.php">http://www.jrsoftware.org/isinfo.php</a>) are two popular free options. On OS X, the necessary tools are already installed. Simply use the Disk Utility application to make a disk image (<code class="literal">.dmg</code>) file and then copy the built applet into it.<a id="id472" class="indexterm"/>
</p></div></div></div></div>
</body></html>