["```py\n     class Dice:\n    ```", "```py\n     def __init__(self) -> None: \n\n            self.faces: tuple[int, int] = (0, 0)\n    ```", "```py\n     def roll(self) -> None: \n\n            self.faces = (randint(1,6), randint(1,6))\n    ```", "```py\n     def total(self) -> int: \n\n            return sum(self.faces)\n    ```", "```py\n     def hardway(self) -> bool: \n\n            return self.faces[0] == self.faces[1] \n\n        def easyway(self) -> bool: \n\n            return self.faces[0] != self.faces[1] \n    ```", "```py\n     >>> import random \n\n    >>> random.seed(1)\n    ```", "```py\n     >>> d1 = Dice() \n\n    >>> d1.roll() \n\n    >>> d1.total() \n\n    7 \n\n    >>> d1.faces \n\n    (2, 5)\n    ```", "```py\n     import random \n    ```", "```py\n     class Dice:\n    ```", "```py\n     RNG = random.Random()\n    ```", "```py\n     def __init__(self, n: int, sides: int = 6) -> None: \n\n            self.n_dice = n \n\n            self.sides = sides \n\n            self.faces: list[int] \n\n            self.roll_number = 0\n    ```", "```py\n     def __str__(self) -> str: \n\n            return \", \".join( \n\n                f\"{i}: {f}\" \n\n                for i, f in enumerate(self.faces) \n\n            ) \n\n        def total(self) -> int: \n\n            return sum(self.faces) \n\n        def average(self) -> float: \n\n            return sum(self.faces) / self.n_dice\n    ```", "```py\n     def first_roll(self) -> list[int]: \n\n            self.roll_number = 0 \n\n            self.faces = [ \n\n                self.RNG.randint(1, self.sides) \n\n                for _ in range(self.n_dice) \n\n            ] \n\n            return self.faces \n\n        def reroll(self, positions: set[int]) -> list[int]: \n\n            self.roll_number += 1 \n\n            for p in positions: \n\n                self.faces[p] = self.RNG.randint(1, self.sides) \n\n            return self.faces\n    ```", "```py\n def example_mypy_failure() -> None: \n\n    d = Dice(2.5) \n\n    d.first_roll() \n\n    print(d)\n```", "```py\nsrc/ch07/recipe_02_bad.py:9: error: Argument 1 to \"Dice\" has incompatible type \"float\"; expected \"int\"  [arg-type]\n```", "```py\n r1: list[str] = d.first_roll()\n```", "```py\n data = Counter({7: 80, \n\n         6: 67, \n\n         8: 62, \n\n         9: 50,\n```", "```py\n... Details omitted ...\n```", "```py\n 2: 3, \n\n         3: 2, \n\n         1: 1})\n```", "```py\n     from collections import Counter \n\n    import math\n    ```", "```py\n     class CounterStatistics:\n    ```", "```py\n     def __init__(self, raw_counter: Counter[int]) ->  None: \n\n            self.raw_counter = raw_counter\n    ```", "```py\n     self.mean = self.compute_mean() \n\n            self.stddev = self.compute_stddev()\n    ```", "```py\n     def compute_mean(self) -> float: \n\n            total, count = 0.0, 0 \n\n            for value, frequency in self.raw_counter.items(): \n\n                total += value * frequency \n\n                count += frequency \n\n            return total / count\n    ```", "```py\n     def compute_stddev(self) -> float: \n\n            total, count = 0.0, 0 \n\n            for value, frequency in self.raw_counter.items(): \n\n                total += frequency * (value - self.mean) ** 2 \n\n                count += frequency \n\n            return math.sqrt(total / (count - 1))\n    ```", "```py\n >>> from pathlib import Path \n\n>>> import csv \n\n>>> from collections import Counter \n\n>>> data_path = Path.cwd() / \"data\" / \"binned.csv\" \n\n>>> with data_path.open() as data_file: \n\n...     reader = csv.DictReader(data_file) \n\n...     extract = { \n\n...         int(row[’size_code’]): int(row[’frequency’]) \n\n...         for row in reader \n\n...     } \n\n>>> data = Counter(extract)\n```", "```py\n >>> stats = CounterStatistics(data) \n\n>>> print(f\"Mean: {stats.mean:.1f}\") \n\nMean: 10.4 \n\n>>> print(f\"Standard Deviation: {stats.stddev:.2f}\") \n\nStandard Deviation: 4.17\n```", "```py\n     from typing import NamedTuple \n    ```", "```py\n     class Card(NamedTuple): \n\n        rank: int \n\n        suit: str\n    ```", "```py\n >>> eight_hearts = Card(rank=8, suit=’\\N{White Heart Suit}’) \n\n>>> eight_hearts \n\nCard(rank=8, suit=’’) \n\n>>> eight_hearts.rank \n\n8 \n\n>> eight_hearts.suit \n\n’’ \n\n>>> eight_hearts[0]\n```", "```py\n >>> eight_hearts.suit = ’\\N{Black Spade Suit}’ \n\nTraceback (most recent call last): \n\n... \n\nAttributeError: can’t set attribute\n```", "```py\n class CardPoints(NamedTuple): \n\n    rank: int \n\n    suit: str \n\n    def points(self) -> int: \n\n        if 1 <= self.rank < 10: \n\n            return self.rank \n\n        else: \n\n            return 10\n```", "```py\n     from dataclasses import dataclass\n    ```", "```py\n     @dataclass \n\n    class CribbageHand:\n    ```", "```py\n     cards: list[CardPoints]\n    ```", "```py\n     def to_crib(self, card1: CardPoints, card2: CardPoints) -> None: \n\n            self.cards.remove(card1)\n    ```", "```py\n @dataclass \n\nclass CribbageHand: \n\n    cards: list[CardPoints] \n\n    def to_crib(self, card1: CardPoints, card2: CardPoints) -> None: \n\n        self.cards.remove(card1) \n\n        self.cards.remove(card2)\n```", "```py\n >>> cards = [ \n\n... CardPoints(rank=3, suit=’\\N{WHITE DIAMOND SUIT}’), \n\n... CardPoints(rank=6, suit=’\\N{BLACK SPADE SUIT}’), \n\n... CardPoints(rank=7, suit=’\\N{WHITE DIAMOND SUIT}’), \n\n... CardPoints(rank=1, suit=’\\N{BLACK SPADE SUIT}’), \n\n... CardPoints(rank=6, suit=’\\N{WHITE DIAMOND SUIT}’), \n\n... CardPoints(rank=10, suit=’\\N{WHITE HEART SUIT}’)] \n\n>>> ch1 = CribbageHand(cards) \n\n>>> from pprint import pprint \n\n>>> pprint(ch1) \n\nCribbageHand(cards=[CardPoints(rank=3, suit=’’), \n\n                    CardPoints(rank=6, suit=’’), \n\n                    CardPoints(rank=7, suit=’’), \n\n                    CardPoints(rank=1, suit=’’), \n\n                    CardPoints(rank=6, suit=’’), \n\n                    CardPoints(rank=10, suit=’’)]) \n\n>>> [c.points() for c in ch1.cards] \n\n[3, 6, 7, 1, 6, 10] \n```", "```py\n >>> ch1.to_crib( \n\n...     CardPoints(rank=3, suit=’\\N{WHITE DIAMOND SUIT}’), \n\n...     CardPoints(rank=1, suit=’\\N{BLACK SPADE SUIT}’)) \n\n>>> pprint(ch1) \n\nCribbageHand(cards=[CardPoints(rank=6, suit=’’), \n\n                    CardPoints(rank=7, suit=’’), \n\n                    CardPoints(rank=6, suit=’’), \n\n                    CardPoints(rank=10, suit=’’)]) \n\n>>> [c.points() for c in ch1.cards] \n\n[6, 7, 6, 10]\n```", "```py\n import random \n\nfrom typing import ClassVar \n\n@dataclass(init=False) \n\nclass Deck: \n\n    SUITS: ClassVar[tuple[str, ...]] = ( \n\n    ’\\N{Black Club Suit}’, \n\n    ’\\N{White Diamond Suit}’, \n\n    ’\\N{White Heart Suit}’, \n\n    ’\\N{Black Spade Suit}’ \n\n    ) \n\n    cards: list[CardPoints] \n\n    def __init__(self) -> None: \n\n        self.cards = [ \n\n            CardPoints(rank=r, suit=s) \n\n            for r in range(1, 14)\n```", "```py\n     from dataclasses import dataclass\n    ```", "```py\n     @dataclass(frozen=True, order=True) \n\n    class Card:\n    ```", "```py\n     rank: int \n\n        suit: str\n    ```", "```py\n >>> eight_hearts = Card(rank=8, suit=’\\N{White Heart Suit}’) \n\n>>> eight_hearts \n\nCard(rank=8, suit=’’) \n\n>>> eight_hearts.rank \n\n8 \n\n>>> eight_hearts.suit \n\n’’\n```", "```py\n >>> eight_hearts.suit = ’\\N{Black Spade Suit}’ \n\nTraceback (most recent call last): \n\n... \n\ndataclasses.FrozenInstanceError: cannot assign to field ’suit’\n```", "```py\n from dataclasses import dataclass, field \n\n@dataclass(frozen=True, order=True) \n\nclass Hand: \n\n    cards: list[CardPoints] = field(default_factory=list)\n```", "```py\n >>> cards = [ \n\n... CardPoints(rank=3, suit=’\\N{WHITE DIAMOND SUIT}’), \n\n... CardPoints(rank=6, suit=’\\N{BLACK SPADE SUIT}’), \n\n... CardPoints(rank=7, suit=’\\N{WHITE DIAMOND SUIT}’), \n\n... CardPoints(rank=1, suit=’\\N{BLACK SPADE SUIT}’), \n\n... CardPoints(rank=6, suit=’\\N{WHITE DIAMOND SUIT}’), \n\n... CardPoints(rank=10, suit=’\\N{WHITE HEART SUIT}’)] \n\n>>> \n\n>>> h = Hand(cards)\n```", "```py\n >>> crib = Hand() \n\n>>> d3 = CardPoints(rank=3, suit=’\\N{WHITE DIAMOND SUIT}’) \n\n>>> h.cards.remove(d3) \n\n>>> crib.cards.append(d3) \n\n>>> from pprint import pprint \n\n>>> pprint(crib) \n\nHand(cards=[CardPoints(rank=3, suit=’’)])\n```", "```py\n     class Cribbage:\n    ```", "```py\n     __slots__ = (’deck’, ’players’, ’crib’, ’dealer’, ’opponent’)\n    ```", "```py\n     def __init__( \n\n                self, \n\n                deck: Deck, \n\n                player1: Player, \n\n                player2: Player \n\n        ) -> None: \n\n            self.deck = deck \n\n            self.players = [player1, player2] \n\n            random.shuffle(self.players) \n\n            self.dealer, self.opponent = self.players \n\n            self.crib = Hand()\n    ```", "```py\n     def new_deal(self) -> None: \n\n            self.deck.shuffle() \n\n            self.players = list(reversed(self.players)) \n\n            self.dealer, self.opponent = self.players \n\n            self.crib = Hand() \n    ```", "```py\n >>> deck = Deck() \n\n>>> c = Cribbage(deck, Player(\"1\"), Player(\"2\")) \n\n>>> c.dealer \n\nPlayer(name=’2’) \n\n>>> c.opponent \n\nPlayer(name=’1’) \n\n>>> c.new_deal() \n\n>>> c.dealer \n\nPlayer(name=’1’) \n\n>>> c.opponent \n\nPlayer(name=’2’)\n```", "```py\n >>> c.some_other_attribute = True \n\nTraceback (most recent call last): \n\n... \n\nAttributeError: ’Cribbage’ object has no attribute ’some_other_attribute’ \n```", "```py\n     class StatsList(list[float]):\n    ```", "```py\n     def sum(self) -> float: \n\n            return sum(v for v in self)\n    ```", "```py\n     def size(self) -> float: \n\n            return sum(1 for v in self)\n    ```", "```py\n     def mean(self) -> float: \n\n            return self.sum() / self.size()\n    ```", "```py\n     def sum2(self) -> float: \n\n            return sum(v ** 2 for v in self) \n\n        def variance(self) -> float: \n\n            return ( \n\n              (self.sum2() - self.sum() ** 2 / self.size()) \n\n              / (self.size() - 1) \n\n            ) \n\n        def stddev(self) -> float: \n\n            return math.sqrt(self.variance())\n    ```", "```py\n >>> subset1 = StatsList([10, 8, 13, 9, 11]) \n\n>>> data = StatsList([14, 6, 4, 12, 7, 5]) \n\n>>> data.extend(subset1)\n```", "```py\n >>> data \n\n[14, 6, 4, 12, 7, 5, 10, 8, 13, 9, 11]\n```", "```py\n >>> data.mean() \n\n9.0 \n\n>>> data.variance() \n\n11.0\n```", "```py\n from collections.abc import MutableMapping \n\nclass MyFancyMapping(MutableMapping[int, int]): \n\n    ... # etc.\n```", "```py\n     class LazyCounterStatistics:\n    ```", "```py\n     def __init__(self, raw_counter: Counter[int]) -> None: \n\n            self.raw_counter = raw_counter\n    ```", "```py\n     @property \n\n        def sum(self) -> float: \n\n            return sum( \n\n                f * v \n\n                for v, f in self.raw_counter.items() \n\n            ) \n\n        @property \n\n        def count(self) -> float: \n\n            return sum( \n\n                f \n\n                for v, f in self.raw_counter.items() \n\n            )\n    ```", "```py\n     @property \n\n        def mean(self) -> float: \n\n            return self.sum / self.count\n    ```", "```py\n     @property \n\n        def sum2(self) -> float: \n\n            return sum( \n\n                f * v ** 2 \n\n                for v, f in self.raw_counter.items() \n\n            ) \n\n        @property \n\n        def variance(self) -> float: \n\n          return ( \n\n              (self.sum2 - self.sum ** 2 / self.count) / \n\n              (self.count - 1) \n\n          ) \n\n        @property \n\n        def stddev(self) -> float: \n\n            return math.sqrt(self.variance)\n    ```", "```py\n >>> from pathlib import Path \n\n>>> import csv \n\n>>> from collections import Counter \n\n>>> data_path = Path.cwd() / \"data\" / \"binned.csv\" \n\n>>> with data_path.open() as data_file: \n\n...     reader = csv.DictReader(data_file) \n\n...     extract = { \n\n...         int(row[’size_code’]): int(row[’frequency’]) \n\n...         for row in reader \n\n...     } \n\n>>> data = Counter(extract)\n```", "```py\n >>> stats = LazyCounterStatistics(data) \n\n>>> print(f\"Mean: {stats.mean:.1f}\") \n\nMean: 10.4 \n\n>>> print(f\"Standard Deviation: {stats.stddev:.2f}\") \n\nStandard Deviation: 4.17\n```", "```py\n from typing import cast \n\nclass CachingLazyCounterStatistics: \n\n    def __init__(self, raw_counter: Counter[int]) -> None: \n\n        self.raw_counter = raw_counter \n\n        self._sum: float | None = None \n\n        self._count: float | None = None \n\n    @property \n\n    def sum(self) -> float: \n\n        if self._sum is None: \n\n            self._sum = sum( \n\n                f * v \n\n                for v, f in self.raw_counter.items() \n\n            ) \n\n        return self._sum\n```", "```py\n >>> with Distance(r=NM) as nm_dist: \n\n...     print(f\"{nm_dist(p1, p2)=:.2f}\") \n\n...     print(f\"{nm_dist(p2, p3)=:.2f}\") \n\nnm_dist(p1, p2)=39.72 \n\nnm_dist(p2, p3)=30.74\n```", "```py\n     class Distance:\n    ```", "```py\n     def __init__(self, r: float) -> None: \n\n            self.r = r\n    ```", "```py\n     def __enter__(self) -> Callable[[Point, Point], float]: \n\n            return self.distance\n    ```", "```py\n     def __exit__( \n\n            self, \n\n            exc_type: type[Exception] | None, \n\n            exc_val: Exception | None, \n\n            exc_tb: TracebackType | None \n\n        ) -> bool | None: \n\n            return None\n    ```", "```py\n     def distance(self, p1: Point, p2: Point) -> float: \n\n            return haversine( \n\n                p1.lat, p1.lon, p2.lat, p2.lon, R=self.r \n\n            )\n    ```", "```py\n from collections.abc import Callable \n\nfrom types import TracebackType \n\nfrom typing import NamedTuple\n```", "```py\n class Point(NamedTuple): \n\n    lat: float \n\n    lon: float\n```", "```py\n >>> p1 = Point(38.9784, -76.4922) \n\n>>> p2 = Point(36.8443, -76.2922) \n\n>>> nm_distance = Distance(r=NM) \n\n>>> with nm_distance as nm_calc: \n\n...     print(f\"{nm_calc(p1, p2)=:.2f}\") \n\nnm_calc(p1, p2)=128.48\n```", "```py\n def __exit__( \n\n        self, \n\n        exc_type: type[Exception] | None, \n\n        exc_val: Exception | None, \n\n        exc_tb: TracebackType | None \n\n    ) -> bool | None: \n\n        # Cleanup goes here. \n\n        return None \n```", "```py\n >>> p1 = Point(38.9784, -76.4922) \n\n>>> p2 = Point(36.8443, -76.2922) \n\n>>> with Distance(None) as nm_dist: \n\n...     print(f\"{nm_dist(p1, p2)=:.2f}\") \n\nTraceback (most recent call last): \n\n... \n\nTypeError: unsupported operand type(s) for *: ’NoneType’ and ’int’\n```", "```py\n class Distance_2: \n\n    def __init__(self, r: float) -> None: \n\n        self.r = r \n\n    def __enter__(self) -> Callable[[Point, Point], float]: \n\n        return self.distance \n\n    def __exit__( \n\n        self, \n\n        exc_type: type[Exception] | None, \n\n        exc_val: Exception | None, \n\n        exc_tb: TracebackType | None \n\n    ) -> bool | None: \n\n        if exc_type is TypeError: \n\n            raise ValueError(f\"Invalid r={self.r!r}\") \n\n        return None \n\n    def distance(self, p1: Point, p2: Point) -> float: \n\n        return haversine(p1.lat, p1.lon, p2.lat, p2.lon, R=self.r)\n```", "```py\n @dataclass(frozen=True) \n\nclass Point: \n\n    lat: float \n\n    lon: float\n```", "```py\n @dataclass \n\nclass Leg: \n\n    start: Point \n\n    end: Point \n\n    distance: float = field(init=False)\n```", "```py\n from types import TracebackType \n\nclass LegMaker: \n\n    def __init__(self, r: float=NM) -> None: \n\n        self.last_point: Point | None = None \n\n        self.last_leg: Leg | None = None \n\n        self.r = r \n\n    def __enter__(self) -> \"LegMaker\": \n\n        return self \n\n    def __exit__( \n\n        self, \n\n        exc_type: type[Exception] | None, \n\n        exc_val: Exception | None, \n\n        exc_tb: TracebackType | None \n\n    ) -> bool | None: \n\n        return None\n```", "```py\n def waypoint(self, next_point: Point) -> Leg | None: \n\n        leg: Leg | None \n\n        if self.last_point is None: \n\n            # Special case for the first leg \n\n            self.last_point = next_point \n\n            leg = None \n\n        else: \n\n            leg = Leg(self.last_point, next_point) \n\n            d = haversine( \n\n                leg.start.lat, leg.start.lon, \n\n                leg.end.lat, leg.end.lon, \n\n                R=self.r \n\n            ) \n\n            leg.distance = round(d) \n\n            self.last_point = next_point \n\n        return leg\n```", "```py\n     from collections.abc import Iterable \n\n    import csv \n\n    from dataclasses import asdict \n\n    from pathlib import Path\n    ```", "```py\n     HEADERS = [\"start_lat\", \"start_lon\", \"end_lat\", \"end_lon\", \"distance\"]\n    ```", "```py\n     def flat_dict(leg: Leg) -> dict[str, float]: \n\n        struct = asdict(leg) \n\n        return dict( \n\n            start_lat=struct[\"start\"][\"lat\"], \n\n            start_lon=struct[\"start\"][\"lon\"], \n\n            end_lat=struct[\"end\"][\"lat\"], \n\n            end_lon=struct[\"end\"][\"lon\"], \n\n            distance=struct[\"distance\"], \n\n        )\n    ```", "```py\n     def make_route_file( \n\n        points: Iterable[Point], target: Path \n\n    ) -> None:\n    ```", "```py\n     with ( \n\n            LegMaker(r=NM) as legger, \n\n            target.open(’w’, newline=’’) as csv_file \n\n        ):\n    ```", "```py\n     writer = csv.DictWriter(csv_file, HEADERS) \n\n            writer.writeheader() \n\n            for point in points: \n\n                leg = legger.waypoint(point) \n\n                if leg is not None: \n\n                    writer.writerow(flat_dict(leg))\n    ```", "```py\n     print(f\"Finished creating {target}\")\n    ```", "```py\n import bz2 \n\ndef make_route_bz2(points: Iterable[Point], target: Path) -> None: \n\n    with ( \n\n        LegMaker(r=NM) as legger, \n\n        bz2.open(target, \"wt\") as archive \n\n    ): \n\n        writer = csv.DictWriter(archive, HEADERS) \n\n        writer.writeheader() \n\n        for point in points: \n\n            leg = legger.waypoint(point) \n\n            if leg is not None: \n\n                writer.writerow(flat_dict(leg)) \n\n    print(f\"Finished creating {target}\")\n```"]