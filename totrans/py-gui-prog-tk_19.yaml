- en: B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Quick SQL Tutorial
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For over three decades, relational database systems have remained a de facto
    standard for storing business data. They are more commonly known as SQL databases,
    after the **Structured Query Language** (**SQL**) used to interact with them.
    Although a full treatment of SQL warrants a book of its own, this appendix will
    provide a brief coverage of its basic concepts and syntax that will be adequate
    for following its usage in this book.
  prefs: []
  type: TYPE_NORMAL
- en: SQL concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SQL databases are made up of **tables**. A table is something like a CSV or
    spreadsheet file, in that it has rows representing individual items and columns
    representing data values associated with each item. A SQL table has some important
    differences from a spreadsheet, though:'
  prefs: []
  type: TYPE_NORMAL
- en: First, each column in the table is assigned a **data type**, which is strictly
    enforced. Just as Python will produce an error when you try to convert `"abcd"`
    to an `int` or `0.03` into a `date`, a SQL database will return an error if you
    try to insert letters into a numeric column or decimal values into a date column.
    SQL databases typically support basic data types like text, numbers, dates and
    times, Boolean values, and binary data; in addition, some implementations have
    specialized data types for things like IP addresses, JSON data, currency, or images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL tables can also have **constraints**, which further enforce the validity
    of data inserted into the table. For example, a column can be given a **unique
    constraint**, which prevents two rows from having the same value in that column,
    or a **not null** constraint, which means that every row must have a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL databases commonly contain many tables, and these can be joined together
    to represent much more complicated data structures. By breaking data into multiple
    linked tables, we can store it in a way that is much more efficient and resilient
    than a two-dimensional plaintext CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax differences from Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''ve only ever programmed in Python, SQL may feel odd at first, as the
    rules and syntax are very different. We''ll be going over the individual commands
    and keywords, but here are some general differences from Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL is (mostly) **case-insensitive**: Although it''s conventional for readability
    purposes to type the SQL keywords in all caps, most SQL implementations are not
    case-sensitive. There are a few small exceptions here and there, but, for the
    most part, you can type SQL in whatever case is easiest for you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Whitespace** is not significant: In Python, new lines and indentation can
    change the meaning of a piece of code. In SQL, whitespace is not significant and
    statements are terminated with a semicolon. Indents and new lines in a query are
    only there for readability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQL is **declarative**: Python could be described as an **imperative programming
    language**: we tell Python what we want it to do by telling it how to do it. SQL
    is more of a declarative language: we *describe* what we want done, and the SQL
    engine figures out how to do it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll encounter additional syntax differences as we look at specific SQL code
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: SQL operations and syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL is a powerful and expressive language for doing mass manipulations of tabular
    data, but the basics can be grasped quickly. SQL code is executed as individual
    queries that either define, manipulate, or select data in the database. SQL dialects
    vary somewhat between different relational database products, but most of them
    support **ANSI/ISO-standard SQL** for core operations.
  prefs: []
  type: TYPE_NORMAL
- en: While most of the basic concepts and keywords covered here will work across
    SQL implementations, we'll be using PostgreSQL's dialect for the examples in this
    section. If you wish to try these examples on a different SQL implementation,
    be prepared to make some adjustments to the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: To follow along with this section, connect to an empty database on your PostgreSQL
    database server, either using the `psql` command-line tool, the `pgAdmin` graphical
    tool, or another database client software of your choosing.
  prefs: []
  type: TYPE_NORMAL
- en: Defining tables and inserting data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL tables are created using the `CREATE TABLE` command, as shown in the following
    SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're creating a table called `musicians`. After the name,
    we specify a list of column definitions. Each column definition follows the format
    `column_name data_type constraints`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down the details of these columns we''ve defined:'
  prefs: []
  type: TYPE_NORMAL
- en: The `id` column will be an arbitrary ID value for the row. Its type is `SERIAL`,
    which means it will be an auto-incrementing integer field, and its constraint
    is `PRIMARY KEY`, which means it will be used as the unique identifier for the
    row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` field is of type `TEXT`, so it can hold a string of any length. Its
    constraint of `NOT NULL` means that a `NULL` value is not allowed in this field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `born` and `died` fields are of type `DATE`, so they can only hold a date
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `born` field has no constraints but `died` has a `CHECK` constraint enforcing
    that its value must be greater than the value of `born` for any given row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although it's not required, it's a good practice to specify a **primary key**
    for each table. Primary keys can be one field, or a combination of fields, but
    the value must be unique for any given row. For example, if we made `name` the
    primary key field, we couldn't have two musicians with the same name in our table.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add rows of data to this table, we use the `INSERT INTO` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `INSERT INTO` command takes a table name and an optional list specifying
    the fields to receive data; other fields will receive their default value (`NULL`
    if not otherwise specified in the `CREATE` statement). The `VALUES` keyword indicates
    that a list of data values will follow, formatted as a comma-separated list of
    tuples. Each tuple corresponds to one table row and must match the order of the
    field list specified after the table name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that strings are delimited by the single quote character. Unlike Python,
    single quotes and double quotes have different meanings in SQL: a single quote
    indicates a string literal, while double quotes are used for object names that
    include spaces or need to preserve case. For example, if we had called our table
    `Musicians of the ''70s`, we would need to enclose that name in double-quotes
    due to the spaces, apostrophe, and capitalization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using double-quotes to enclose a string literal results in an error, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To make our database more interesting, let''s create and populate another table;
    this time, an `instruments` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `VALUES` lists must always use parentheses around each row, even
    if there's only one value per row.
  prefs: []
  type: TYPE_NORMAL
- en: 'To relate the `musicians` table to the `instruments` table, we''ll need to
    add a column to it. Tables can be changed after they are created using the `ALTER
    TABLE` command. For example, we can add our new column like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `ALTER TABLE` command takes a table name, then a command altering some aspect
    of the table. In this case, we're adding a new column called `main_instrument`,
    which will be an integer.
  prefs: []
  type: TYPE_NORMAL
- en: The `REFERENCES` constraint we've specified is known as a **foreign key constraint**;
    it limits the possible values of `main_instrument` to existing ID numbers in the
    `instruments` table.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data from tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To retrieve data from tables, we can use a `SELECT` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `SELECT` command takes a column or comma-separated list of columns followed
    by a `FROM` clause, which specifies the table or tables containing the specified
    columns. This query asks for the `name` column from the `musicians` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| name |'
  prefs: []
  type: TYPE_TB
- en: '| Bill Bruford |'
  prefs: []
  type: TYPE_TB
- en: '| Keith Emerson |'
  prefs: []
  type: TYPE_TB
- en: '| Greg Lake |'
  prefs: []
  type: TYPE_TB
- en: '| Robert Fripp |'
  prefs: []
  type: TYPE_TB
- en: '| David Gilmour |'
  prefs: []
  type: TYPE_TB
- en: 'Instead of a list of columns, we can also specify an asterisk, which means
    "all columns." For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding SQL query returns the following table of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ID | name | born | died | main_instrument |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Bill Bruford | 1949-05-17 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Keith Emerson | 1944-11-02 | 2016-03-11 |  |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Greg Lake | 1947-11-10 | 2016-12-07 |  |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Robert Fripp | 1946-05-16 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | David Gilmour | 1946-03-06 |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'To filter out rows we don''t want, we can specify a `WHERE` clause, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `WHERE` command must be followed by a conditional expression that evaluates
    to `True` or `False`; rows for which the expression evaluates `True` are shown,
    while rows for which it evaluates `False` are left out.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we have asked for the names of musicians for which the `died`
    date is `NULL`. We can specify more complex conditions by combining expressions
    with the `AND` and `OR` operators, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we would only get musicians born before 1945 who don't have a
    died date in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SELECT` command can also do operations on fields, or re-order the results
    by certain columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're using the `age()` function to determine the age of the
    musicians from their birth dates. We're also doing math on the `died` and `born`
    dates to determine the age at death for those who have passed. Notice that we're
    using the `AS` keyword to **alias**, or rename, the generated column.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this query, you should get output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| name | age | age at death |'
  prefs: []
  type: TYPE_TB
- en: '| Bill Bruford | 72 years 4 mons 18 days |  |'
  prefs: []
  type: TYPE_TB
- en: '| Greg Lake | 73 years 10 mons 24 days | 69 |'
  prefs: []
  type: TYPE_TB
- en: '| Robert Fripp | 75 years 4 mons 19 days |  |'
  prefs: []
  type: TYPE_TB
- en: '| David Gilmour | 75 years 6 mons 29 days |  |'
  prefs: []
  type: TYPE_TB
- en: '| Keith Emerson | 76 years 11 mons 2 days | 71 |'
  prefs: []
  type: TYPE_TB
- en: Notice that `age at death` is `NULL` for those without a date of death. Mathematical
    or logical operations on a `NULL` value always return an answer of `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: The `ORDER BY` clause specifies a column or list of columns by which the results
    should be ordered. It also takes an argument of `DESC` or `ASC` to specify descending
    or ascending order, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We have ordered the output here by date of birth in descending order. Note that
    each data type has its own rules for sorting data, just like in Python. Dates
    are ordered by their calendar position, strings by alphabetical order, and numbers
    by their numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: Updating rows, deleting rows, and more WHERE clauses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To update or delete existing rows, we use the `UPDATE` and `DELETE FROM` keywords
    in conjunction with a `WHERE` clause to select the affected rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deleting is fairly simple; for example, if we wanted to delete the `instrument`
    record with an `id` value of `5`, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DELETE FROM` command will delete any rows that match the `WHERE` conditions.
    In this case, we match the primary key to ensure only one row is deleted. If no
    rows match the `WHERE` conditions, no rows will be deleted. Note, however, that
    the `WHERE` clause is technically optional: `DELETE FROM instruments` will simply
    delete all rows in the table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating is similar, except it includes a `SET` clause to specify new column
    values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are setting `main_instrument` in the `musicians` table to the primary
    key value from the `instruments` table that identifies the instrument we want
    to associate with each musician.
  prefs: []
  type: TYPE_NORMAL
- en: We can select the `musician` records we want to update using the primary key,
    name, or any combination of conditions. Like `DELETE`, omitting the `WHERE` clause
    would cause the query to affect all rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any number of columns can be updated in the `SET` clause; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Additional columns to be updated are just separated by commas. Note that we''ve
    also matched the record using the `LIKE` operator in tandem with the `%` wildcard
    character. `LIKE` can be used with text and string data types to match partial
    values. Standard SQL supports two wildcard characters: `%`, which matches zero
    or more characters, and `_`, which matches a single character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also match against transformed column values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've used the `LOWER` function to match our string against the lowercase
    version of the column value. This doesn't permanently change the data in the table;
    it just temporarily changes the value for the purpose of the comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Standard SQL specifies that `LIKE` is a case-sensitive match. PostgreSQL offers
    an `ILIKE` operator that does case-insensitive matching, as well as a `SIMILAR
    TO` operator that matches using more advanced regular expression syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Subqueries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inserting data using meaningless primary key values is not very user-friendly.
    To make inserting these values a little more intuitive, we can use a **subquery**,
    as shown in the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A subquery is a SQL query within a SQL query. If your subquery can be guaranteed
    to return a single value, it can be used anywhere you would use a literal value.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we're letting our database do the work of figuring out what the
    primary key of `'guitar'` is, and inserting the returned integer for our `main_instrument`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WHERE` clause, we''ve also used the `IN` operator to match the musician''s
    name. Just like the Python `in` keyword, this SQL keyword allows us to match against
    a list of values. `IN` can be used with a subquery as well; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we've asked the database to give us every musician whose main
    instrument contains the letter "r". Since `IN` is meant to be used with a list
    of values, any query that returns a single column with any number of rows is valid.
    In this case, our subquery returns several rows with only the `id` column, so
    it works with `IN` just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subqueries that return multiple rows and multiple columns can be used anywhere
    that a table can be used; for example, we can use a subquery in a `FROM` clause,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this case, SQL treats our subquery as though it were a table in the database.
    Note that subqueries used in a `FROM` clause require an alias; we've aliased this
    subquery as `living_musicians`.
  prefs: []
  type: TYPE_NORMAL
- en: Joining tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Subqueries are one way of using multiple tables together, but a more flexible
    and powerful way is to use `JOIN`. `JOIN` is used in the `FROM` clause of a SQL
    statement, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A `JOIN` statement requires an `ON` clause that specifies the conditions used
    to match rows in each table. The `ON` clause acts like a filter, much like the
    `WHERE` clause does; you can imagine that the `JOIN` creates a new table containing
    every possible combination of rows from both tables, then filters out the ones
    that don't match the `ON` conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Tables are typically joined by matching the values in common fields, such as
    those specified in a foreign key constraint. In this case, our `musicians.main_instrument`
    column contains the `id` values from the `instrument` table, so we can join the
    two tables based on this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Joins are used to implement four types of table relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '**One-to-one joins** match exactly one row in the first table to exactly one
    row in the second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Many-to-one joins** match multiple rows in the first table to exactly one
    row in the second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One-to-many joins** match one row in the first table to multiple rows in
    the second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Many-to-many joins** match multiple rows in both tables. This kind of join
    requires the use of an intermediary table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous query shows a many-to-one join, since many `musicians` can have
    the same main instrument. Many-to-one joins are often used when a column's value
    should be limited to a set of options, such as fields that our GUI might represent
    with a `Combobox` widget. The table joined is often called a **lookup table**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to reverse our last query, it would be one-to-many:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'One-to-many joins are commonly used when a record has a list of sub-records
    associated with it; in this case, each instrument has a list of musicians who
    consider it their main instrument. The joined table is often called a **detail
    table**. The preceding SQL query will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '| instrument | musician |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| drums | Bill Bruford |'
  prefs: []
  type: TYPE_TB
- en: '| keyboards | Keith Emerson |'
  prefs: []
  type: TYPE_TB
- en: '| bass | Greg Lake |'
  prefs: []
  type: TYPE_TB
- en: '| guitar | Robert Fripp |'
  prefs: []
  type: TYPE_TB
- en: '| guitar | David Gilmour |'
  prefs: []
  type: TYPE_TB
- en: Notice that `guitar` is duplicated in the `instrument` list. When two tables
    are joined, the rows of the result no longer refer to the same entity. One row
    in the `instrument` table represents an instrument.
  prefs: []
  type: TYPE_NORMAL
- en: One row in the `musician` table represents one musician. One row in *this* table
    represents an instrument-musician relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we wanted to keep the output such that one row represented one instrument,
    but still include information about associated musicians in each row. To do this,
    we''ll need to combine the matched musician rows using an **aggregate function**
    and a `GROUP BY` clause, as shown in the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `GROUP BY` clause specifies which column or columns describe what each row
    in the output table represents. Output columns not in the `GROUP BY` clause must
    then be reduced to single values using an aggregate function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we''re using the `count()` aggregate function to count the total
    number of musician records associated with each instrument. Its output looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| instrument | musicians |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| drums | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| keyboards | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| bass | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| guitar | 2 |'
  prefs: []
  type: TYPE_TB
- en: Standard SQL contains several more aggregate functions, such as `min()`, `max()`,
    and `sum()`, and most SQL implementations extend this with their own functions
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-one and one-to-many joins don't quite cover every possible situation
    that databases need to model; quite often, a many-to-many relationship is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate a many-to-many join, let''s create a new table called `bands`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A band has multiple musicians, and musicians can be part of multiple bands.
    How can we create a relationship between musicians and bands? If we added a `band`
    field to the `musicians` table, this would limit each musician to one band. If
    we added a `musician` field to the `band` table, this would limit each band to
    one musician. To make the connection, we need to create a **junction table**,
    in which each row represents a musician's membership in a band.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `musicians_bands` table like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `musicians_bands` table simply contains two foreign key fields, one to point
    to a musician's ID and one to point to the band's ID.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that instead of creating or specifying one field as the primary key,
    we use the combination of both fields as the primary key. It wouldn't make sense
    to have multiple rows with the same two values in them, so the combination makes
    an acceptable primary key.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a query that uses this relationship, our `FROM` clause needs to specify
    two `JOIN` statements: one from `musicians` to `musicians_bands` and one from
    `bands` to `musicians_bands`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s get the names of the bands each musician has been in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This query ties musicians to bands using the junction table, then displays
    musician names next to an aggregated list of the bands they''ve been in, and orders
    it by the musician''s name. It gives you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '| name | bands |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Bill Bruford | {ABWH,"King Crimson",Yes} |'
  prefs: []
  type: TYPE_TB
- en: '| David Gilmour | {"Pink Floyd"} |'
  prefs: []
  type: TYPE_TB
- en: '| Greg Lake | {ELP,"King Crimson"} |'
  prefs: []
  type: TYPE_TB
- en: '| Keith Emerson | {ELP} |'
  prefs: []
  type: TYPE_TB
- en: '| Robert Fripp | {"King Crimson"} |'
  prefs: []
  type: TYPE_TB
- en: The `array_agg()` function used here aggregates string values into an array
    structure. This method, and the `ARRAY` data type, are specific to PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: There is no SQL standard function for aggregating string values, though most
    SQL implementations have a solution for it.
  prefs: []
  type: TYPE_NORMAL
- en: Managing transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we can accomplish a lot of data manipulation in a single SQL query, there
    are times when a change requires multiple queries. Often in these cases, if one
    query fails, the whole set of queries must be reversed or else the data would
    be corrupted.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we want to insert `''Vocals''` as a value in the `instruments`
    table, but we want it to be ID #1\. To do that, we''d need to first move the other
    ID values in the `instruments` table up by one, adjust the foreign key values
    in the `musicians` table, then add the new row. The queries would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, all three queries must run successfully in order to effect
    the change we want, and at the very least the first two must run to avoid data
    corruption. If only the first query ran, our data would be corrupt.
  prefs: []
  type: TYPE_NORMAL
- en: To do this safely, we need to use a **transaction**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using transactions in PostgreSQL involves three keywords, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Keyword | Function |'
  prefs: []
  type: TYPE_TB
- en: '| `BEGIN` | Start a transaction |'
  prefs: []
  type: TYPE_TB
- en: '| `ROLLBACK` | Undo the transaction and start fresh |'
  prefs: []
  type: TYPE_TB
- en: '| `COMMIT` | Permanently save the transaction |'
  prefs: []
  type: TYPE_TB
- en: 'To put our queries in a transaction, we simply add `BEGIN` before the queries
    and `COMMIT` afterward, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, if anything goes wrong with one of our queries, we can execute a `ROLLBACK`
    statement to revert the database to the state it was in when we called `BEGIN`.
  prefs: []
  type: TYPE_NORMAL
- en: In DBAPI2-compatible modules like the `psycopg2` module that we use in *Chapter
    12*, *Improving Data Storage with SQL*, transaction management is often handled
    implicitly through connection settings, or explicitly through connection object
    methods, rather than using SQL statements.
  prefs: []
  type: TYPE_NORMAL
- en: Learning more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has been a quick overview of SQL concepts and syntax; we've covered most
    of what you need to know to write a simple database application, but there's much
    more to learn. The PostgreSQL manual, available at [https://www.postgresql.org/docs/manuals](https://www.postgresql.org/docs/manuals),
    is a great resource and reference for SQL syntax and the specific features of
    PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
