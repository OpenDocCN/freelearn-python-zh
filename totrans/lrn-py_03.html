<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Iterating and Making Decisions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Iterating and Making Decisions</h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"Insanity: doing the same thing over and over again and expecting different results."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Albert Einstein</em></span></span></td></tr></table></div><p>In the previous chapter, we've seen Python built-in data types. Now that you're familiar with data in its many forms and shapes, it's time to start looking at how a program can use it.</p><p>According to Wikipedia:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>In computer science, control flow (or alternatively, flow of control) refers to the specification of the order in which the individual statements, instructions or function calls of an imperative program are executed or evaluated.</em></span></p></blockquote></div><p>In order<a id="id189" class="indexterm"/> to control the flow of a program, we have two <a id="id190" class="indexterm"/>main weapons: <span class="strong"><strong>conditional programming</strong></span> (also known as <span class="strong"><strong>branching</strong></span>) and <span class="strong"><strong>looping</strong></span>. We can use them in many different combinations and variations, but in <a id="id191" class="indexterm"/>this chapter, instead of going through all possible various forms of those two constructs in a "documentation" fashion, I'd rather give you the basics and then I'll write a couple of small scripts with you. In the first one, we'll see how to create a rudimentary prime number generator, while in the second one, we'll see how to apply discounts to customers based on coupons. This way you should get a better feeling about how conditional programming and looping can be used.</p><div class="section" title="Conditional programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Conditional programming</h1></div></div></div><p>Conditional<a id="id192" class="indexterm"/> programming, or branching, is something you do every day, every moment. It's about evaluating conditions: <span class="emphasis"><em>if the light is green, then I can cross</em></span>, <span class="emphasis"><em>if it's raining, then I'm taking the umbrella</em></span>, and <span class="emphasis"><em>if I'm late for work, then I'll call my manager</em></span>.</p><p>The main tool is the <code class="literal">if</code> statement, which comes in different forms and colors, but basically what it does is evaluate an expression and, based on the result, choose which part of the code to execute. As usual, let's see an example:</p><p>
<code class="literal">conditional.1.py</code>
</p><div class="informalexample"><pre class="programlisting">late = True
if <span class="strong"><strong>late</strong></span>:
    print('I need to call my manager!')</pre></div><p>This is possibly the simplest example: when fed to the <code class="literal">if</code> statement, <code class="literal">late</code> acts as a conditional<a id="id193" class="indexterm"/> expression, which is evaluated in a Boolean context (exactly like if we were calling <code class="literal">bool(late)</code>). If the result of the evaluation is <code class="literal">True</code>, then we enter the body of code immediately after the <code class="literal">if</code> statement. Notice that the <code class="literal">print</code> instruction is indented: this means it belongs to a scope defined by the <code class="literal">if</code> clause. Execution of this code yields:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python conditional.1.py</strong></span>
<span class="strong"><strong>I need to call my manager!</strong></span>
</pre></div><p>Since <code class="literal">late</code> is <code class="literal">True</code>, the <code class="literal">print</code> statement was executed. Let's expand on this example:</p><p>
<code class="literal">conditional.2.py</code>
</p><div class="informalexample"><pre class="programlisting">late = False
if late:
    print('I need to call my manager!')  #1
<span class="strong"><strong>else</strong></span>:
    print('no need to call my manager...')  #2</pre></div><p>This time I set <code class="literal">late = False</code>, so when I execute the code, the result is different:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python conditional.2.py</strong></span>
<span class="strong"><strong>no need to call my manager...</strong></span>
</pre></div><p>Depending on the result of evaluating the <code class="literal">late</code> expression, we can either enter block <code class="literal">#1</code> or block <code class="literal">#2</code>, <span class="emphasis"><em>but not both</em></span>. Block <code class="literal">#1</code> is executed when <code class="literal">late</code> evaluates to <code class="literal">True</code>, while block <code class="literal">#2</code> is executed when <code class="literal">late</code> evaluates to <code class="literal">False</code>. Try assigning <code class="literal">False/True</code> values to the <code class="literal">late</code> name, and see how the output for this code changes accordingly.</p><p>The preceding example also introduces the <code class="literal">else</code> clause, which becomes very handy when we want to provide an alternative set of instructions to be executed when an expression evaluates to <code class="literal">False</code> within an <code class="literal">if</code> clause. The else clause is optional, as it's evident by comparing the preceding two examples.</p><div class="section" title="A specialized else: elif"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>A specialized else: elif</h2></div></div></div><p>Sometimes <a id="id194" class="indexterm"/>all you need is to do something if a condition is met (simple <code class="literal">if</code> clause). Other times you need to provide an alternative, in case the condition is <code class="literal">False</code> (<code class="literal">if</code>/<code class="literal">else</code> clause), but there are situations where you may have more than two paths to choose from, so, since calling the manager (or not calling them) is kind of a binary type of example (either you call or you don't), let's change the type of example and keep expanding. This time we decide tax percentages. If my income is less then 10k, I won't pay any taxes. If it is between 10k and 30k, I'll pay 20% taxes. If it is between 30k and 100k, I'll pay 35% taxes, and over 100k, I'll (gladly) pay 45% taxes. Let's put this<a id="id195" class="indexterm"/> all down into beautiful Python code:</p><p>
<code class="literal">taxes.py</code>
</p><div class="informalexample"><pre class="programlisting">income = 15000
if <span class="strong"><strong>income &lt; 10000</strong></span>:
    tax_coefficient = 0.0  #1
<span class="strong"><strong>elif</strong></span> <span class="strong"><strong>income &lt; 30000</strong></span>:
    tax_coefficient = 0.2  #2
<span class="strong"><strong>elif</strong></span> <span class="strong"><strong>income &lt; 100000</strong></span>:
    tax_coefficient = 0.35  #3
<span class="strong"><strong>else</strong></span>:
    tax_coefficient = 0.45  #4

print('I will pay:', income * tax_coefficient, 'in taxes')</pre></div><p>Executing the preceding code yields:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python taxes.py</strong></span>
<span class="strong"><strong>I will pay: 3000.0 in taxes</strong></span>
</pre></div><p>Let's go through the example line by line: we start by setting up the income value. In the example, my income is 15k. We enter the <code class="literal">if</code> clause. Notice that this time we also introduced the <code class="literal">elif</code> clause, which is a contraction for <code class="literal">else-if</code>, and it's different from a bare <code class="literal">else</code> clause in that it also has its own condition. So, the <code class="literal">if</code> expression <code class="literal">income &lt; 10000</code>, evaluates to <code class="literal">False</code>, therefore block <code class="literal">#1</code> is not executed. The control passes to the next condition evaluator: <code class="literal">elif income &lt; 30000</code>. This one evaluates to <code class="literal">True</code>, therefore block <code class="literal">#2</code> is executed, and because of this, Python then resumes execution after the whole <code class="literal">if</code>/<code class="literal">elif</code>/<code class="literal">elif</code>/<code class="literal">else</code> clause (which we can just call <code class="literal">if</code> clause from now on). There is only one instruction after the <code class="literal">if</code> clause, the <code class="literal">print</code> call, which tells us I will pay 3k in taxes this year (<span class="emphasis"><em>15k * 20%</em></span>). Notice that the order is mandatory: <code class="literal">if</code> comes first, then (optionally) as many <code class="literal">elif</code> as you need, and then (optionally) an <code class="literal">else</code> clause.</p><p>Interesting, right? No matter how many lines of code you may have within each block, when one of the conditions evaluates to <code class="literal">True</code>, the associated block is executed and then execution resumes after the whole clause. If none of the conditions evaluates to <code class="literal">True</code> (for example, <code class="literal">income = 200000</code>), then the body of the <code class="literal">else</code> clause would be executed (block <code class="literal">#4</code>). This example expands our understanding of the behavior of the <code class="literal">else</code> clause. Its block of code is executed when none of the preceding <code class="literal">if</code>/<code class="literal">elif</code>/.../<code class="literal">elif</code> expressions has evaluated to <code class="literal">True</code>.</p><p>Try to modify the value of <code class="literal">income</code> until you can comfortably execute all blocks at your will (one per execution, of course). And then try the <span class="strong"><strong>boundaries</strong></span>. This is crucial, whenever you have conditions expressed as <span class="strong"><strong>equalities</strong></span> or <span class="strong"><strong>inequalities</strong></span> (<code class="literal">==</code>, <code class="literal">!=</code>, <code class="literal">&lt;</code>, <code class="literal">&gt;</code>, <code class="literal">&lt;=</code>, <code class="literal">&gt;=</code>), those<a id="id196" class="indexterm"/> numbers represent boundaries. It is essential to test boundaries<a id="id197" class="indexterm"/> thoroughly. Should I allow you to drive at 18 or 17? Am I checking <a id="id198" class="indexterm"/>your age with <code class="literal">age &lt; 18</code>, or <code class="literal">age &lt;= 18</code>? You can't imagine how many times I had to fix subtle bugs that stemmed from using the wrong operator, so go ahead and experiment with the preceding code. Change some <code class="literal">&lt;</code> to <code class="literal">&lt;=</code> and set income to be one of the boundary values (10k, 30k, 100k) as well as any value in between. See how the result changes, get a good understanding of it before proceeding.</p><p>Before <a id="id199" class="indexterm"/>we move to the next topic, let's see another example that shows us how to nest <code class="literal">if</code> clauses. Say your program encounters an error. If the alert system is the console, we print the error. If the alert system is an e-mail, we send it according to the severity of the error. If the alert system is anything other than console or e-mail, we don't know what to do, therefore we do nothing. Let's put this into code:</p><p>
<code class="literal">errorsalert.py</code>
</p><div class="informalexample"><pre class="programlisting">alert_system = 'console'  # other value can be 'email'
error_severity = 'critical'  # other values: 'medium' or 'low'
error_message = 'OMG! Something terrible happened!'

if alert_system == 'console':
    print(error_message)  #1
elif alert_system == 'email':
    if error_severity == 'critical':
        send_email('admin@example.com', error_message)  #2
    elif error_severity == 'medium':
        send_email('support.1@example.com', error_message)  #3
    else:
        send_email('support.2@example.com', error_message)  #4</pre></div><p>The preceding <a id="id200" class="indexterm"/>example is quite interesting, in its silliness. It shows us two <a id="id201" class="indexterm"/>nested <code class="literal">if</code> clauses (<span class="strong"><strong>outer</strong></span> and <span class="strong"><strong>inner</strong></span>). It also shows us the outer <code class="literal">if</code> clause doesn't have any <code class="literal">else</code>, while the inner one does. Notice how indentation is what allows us to nest one clause within another one.</p><p>If <code class="literal">alert_system == 'console'</code>, body <code class="literal">#1</code> is executed, and nothing else happens. On the other hand, if <code class="literal">alert_system == 'email'</code>, then we enter into another <code class="literal">if</code> clause, which we called inner. In the inner <code class="literal">if</code> clause, according to <code class="literal">error_severity</code>, we send an e-mail to either an admin, first-level support, or second-level support (blocks <code class="literal">#2</code>, <code class="literal">#3</code>, and <code class="literal">#4</code>). The <code class="literal">send_email</code> function is not defined in this example, therefore trying to run it would give you an error. In the source code of the book, which you can download from the website, I included a trick to redirect that call to a regular <code class="literal">print</code> function, just so you can experiment on the console without actually sending an e-mail. Try changing the values and see how it all works.</p></div><div class="section" title="The ternary operator"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>The ternary operator</h2></div></div></div><p>One last <a id="id202" class="indexterm"/>thing I would like to show you before<a id="id203" class="indexterm"/> moving on to the next subject, is the <span class="strong"><strong>ternary operator</strong></span> or, in layman's terms, the short version of an <code class="literal">if</code>/<code class="literal">else</code> clause. When the value of a name is to be assigned according to some condition, sometimes it's easier and more readable to use the ternary operator instead of a proper <code class="literal">if</code> clause. In the following example, the two code blocks do exactly the same thing:</p><p>
<code class="literal">ternary.py</code>
</p><div class="informalexample"><pre class="programlisting">order_total = 247  # GBP

# classic if/else form
if order_total &gt; 100:
    discount = 25  # GBP
else:
    discount = 0  # GBP
print(order_total, discount)

# ternary operator
<span class="strong"><strong>discount = 25 if order_total &gt; 100 else 0</strong></span>
print(order_total, discount)</pre></div><p>For simple cases like this, I find it very nice to be able to express that logic in one line instead of four. Remember, as a coder, you spend much more time reading code then writing it, so Python conciseness is invaluable.</p><p>Are you clear on how the ternary operator works? Basically is <code class="literal">name = something if condition else something-else</code>. So <code class="literal">name</code> is assigned <code class="literal">something</code> if <code class="literal">condition</code> evaluates to <code class="literal">True</code>, and <code class="literal">something-else</code> if <code class="literal">condition</code> evaluates to <code class="literal">False</code>.</p><p>Now that you know everything about controlling the path of the code, let's move on to the next subject: looping.</p></div></div></div>
<div class="section" title="Looping"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Looping</h1></div></div></div><p>If you <a id="id204" class="indexterm"/>have any experience with looping in other programming languages, you will find Python's way of looping a bit different. First of all, what is looping? <span class="strong"><strong>Looping</strong></span> means being able to repeat the execution of a code block more than once, according to the loop parameters we're given. There are different looping constructs, which serve different purposes, and Python has distilled all of them down to just two, which you can use to achieve everything you need. These are the <span class="strong"><strong>for</strong></span> and <span class="strong"><strong>while</strong></span> statements.</p><p>While it's definitely possible to do everything you need using either of them, they serve different purposes and therefore they're usually used in different contexts. We'll explore this difference<a id="id205" class="indexterm"/> thoroughly through this chapter.</p><div class="section" title="The for loop"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>The for loop</h2></div></div></div><p>The <code class="literal">for</code> loop is <a id="id206" class="indexterm"/>used when looping over a sequence, like a list, tuple, or a collection of objects. Let's start with a simple example that is more like C++ style, and then let's gradually see how to achieve the same results in Python (you'll love Python's syntax).</p><p>
<code class="literal">simple.for.py</code>
</p><div class="informalexample"><pre class="programlisting">for number in [0, 1, 2, 3, 4]:
    print(number)</pre></div><p>This simple snippet of code, when executed, prints all numbers from 0 to 4. The <code class="literal">for</code> loop is fed the list <code class="literal">[0, 1, 2, 3, 4]</code> and at each iteration, <code class="literal">number</code> is given a value from the sequence (which is iterated sequentially, in order), then the body of the loop is executed (the print line). <code class="literal">number</code> changes at every iteration, according to which value is coming next from the sequence. When the sequence is exhausted, the <code class="literal">for</code> loop terminates, and the execution of the code resumes normally with the code after the loop.</p><div class="section" title="Iterating over a range"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec03"/>Iterating over a range</h3></div></div></div><p>Sometimes<a id="id207" class="indexterm"/> we need to iterate over a range of numbers, and it would be quite unpleasant to have to do so by hardcoding the list somewhere. In such cases, the <code class="literal">range</code> function comes to the rescue. Let's see the equivalent of the previous snippet of code:</p><p>
<code class="literal">simple.for.py</code>
</p><div class="informalexample"><pre class="programlisting">for number in range(5):
    print(number)</pre></div><p>The range function is used extensively in Python programs when it comes to creating sequences: you can call it by passing one value, which acts as <code class="literal">stop</code> (counting from 0), or you can pass two values (<code class="literal">start</code> and <code class="literal">stop</code>), or even three (<code class="literal">start</code>, <code class="literal">stop</code>, and <code class="literal">step</code>). Check out the following example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; list(range(10))  # one value: from 0 to value (excluded)</strong></span>
<span class="strong"><strong>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; list(range(3, 8))  # two values: from start to stop (excluded)</strong></span>
<span class="strong"><strong>[3, 4, 5, 6, 7]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; list(range(-10, 10, 4))  # three values: step is added</strong></span>
<span class="strong"><strong>[-10, -6, -2, 2, 6]</strong></span>
</pre></div><p>For the moment, ignore that we need to wrap <code class="literal">range(...)</code> within a <code class="literal">list</code>. The <code class="literal">range</code> object is a little bit special, but in this case we're just interested in understanding what are the values it will return to us. You see that the deal is the same with slicing: <code class="literal">start</code> is included, <code class="literal">stop</code> excluded, and optionally you can add a <code class="literal">step</code> parameter, which by default is 1.</p><p>Try <a id="id208" class="indexterm"/>modifying the parameters of the <code class="literal">range()</code> call in our <code class="literal">simple.for.py</code> code and see what it prints, get comfortable with it.</p></div><div class="section" title="Iterating over a sequence"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec04"/>Iterating over a sequence</h3></div></div></div><p>Now we<a id="id209" class="indexterm"/> have all the tools to iterate over a sequence, so let's build on that example:</p><p>
<code class="literal">simple.for.2.py</code>
</p><div class="informalexample"><pre class="programlisting">surnames = ['Rivest', 'Shamir', 'Adleman']
for position in range(len(surnames)):
    print(position, surnames[position])</pre></div><p>The preceding code adds a little bit of complexity to the game. Execution will show this result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python simple.for.2.py</strong></span>
<span class="strong"><strong>0 Rivest</strong></span>
<span class="strong"><strong>1 Shamir</strong></span>
<span class="strong"><strong>2 Adleman</strong></span>
</pre></div><p>Let's use <a id="id210" class="indexterm"/>the <span class="strong"><strong>inside-out</strong></span> technique to break it down, ok? We start from the innermost part of what we're trying to understand, and we expand outwards. So, <code class="literal">len(surnames)</code> is the length of the <code class="literal">surnames</code> list: <code class="literal">3</code>. Therefore, <code class="literal">range(len(surnames))</code> is actually transformed into <code class="literal">range(3)</code>. This gives us the range [0, 3), which is basically a sequence <code class="literal">(0, 1, 2)</code>. This means that the <code class="literal">for</code> loop will run three iterations. In the first one, <code class="literal">position</code> will take value <code class="literal">0</code>, while in the second one, it will take value <code class="literal">1</code>, and finally value <code class="literal">2</code> in the third and last iteration. What is <code class="literal">(0, 1, 2)</code>, if not the possible indexing positions for the <code class="literal">surnames</code> list? At position <code class="literal">0</code> we find <code class="literal">'Rivest'</code>, at position <code class="literal">1</code>, <code class="literal">'Shamir'</code>, and at position <code class="literal">2</code>, <code class="literal">'Adleman'</code>. If you are curious about what these three men created together, change <code class="literal">print(position, surnames[position])</code> to <code class="literal">print(surnames[position][0], end='')</code> add a final <code class="literal">print()</code> outside of the loop, and run the code again.</p><p>Now, this style of looping is actually much closer to languages like Java or C++. In Python it's quite rare to see code like this. You can just iterate over any sequence or collection, so there is no need to get the list of positions and retrieve elements out of a sequence at each iteration. It's expensive, needlessly expensive. Let's change the example into a more Pythonic form:</p><p>
<code class="literal">simple.for.3.py</code>
</p><div class="informalexample"><pre class="programlisting">surnames = ['Rivest', 'Shamir', 'Adleman']
for surname in surnames:
    print(surname)</pre></div><p>Now <a id="id211" class="indexterm"/>that's something! It's practically English. The <code class="literal">for</code> loop can iterate over the <code class="literal">surnames</code> list, and it gives back each element in order at each interaction. Running this code will print the three surnames, one at a time. It's much easier to read, right?</p><p>What if you wanted to print the position as well though? Or what if you actually needed it for any reason? Should you go back to the <code class="literal">range(len(...))</code> form? No. You can use the <code class="literal">enumerate</code> built-in function, like this:</p><p>
<code class="literal">simple.for.4.py</code>
</p><div class="informalexample"><pre class="programlisting">surnames = ['Rivest', 'Shamir', 'Adleman']
for <span class="strong"><strong>position, surname</strong></span> in <span class="strong"><strong>enumerate(surnames)</strong></span>:
    print(position, surname)</pre></div><p>This code is very interesting as well. Notice that enumerate gives back a 2-tuple <code class="literal">(position, surname)</code> at each iteration, but still, it's much more readable (and more efficient) than the <code class="literal">range(len(...))</code> example. You can call <code class="literal">enumerate</code> with a <code class="literal">start</code> parameter, like <code class="literal">enumerate(iterable, start)</code>, and it will start from <code class="literal">start</code>, rather than <code class="literal">0</code>. Just another little thing that shows you how much thought has been given in designing Python so that it makes your life easy.</p><p>Using a <code class="literal">for</code> loop it is possible to iterate over lists, tuples, and in general anything that in Python is called iterable. This is a very important concept, so let's talk about it a bit more.</p></div></div><div class="section" title="Iterators and iterables"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Iterators and iterables</h2></div></div></div><p>According<a id="id212" class="indexterm"/> to the Python documentation, an iterable is:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"An object capable of returning its members one at a time. Examples of iterables include all sequence types (such as <code class="literal">list</code>, <code class="literal">str</code>, and tuple) and some non-sequence types like <code class="literal">dict</code>, <code class="literal">file</code> objects, and objects of any classes you define with an <code class="literal">__iter__()</code> or <code class="literal">__getitem__()</code> method. Iterables can be used in a <code class="literal">for</code> loop and in many other places where a sequence is needed (<code class="literal">zip()</code>, <code class="literal">map()</code>, ...). When an iterable object is passed as an argument to the built-in function <code class="literal">iter()</code>, it returns an iterator for the object. This iterator is good for one pass over the set of values. When using iterables, it is usually not necessary to call <code class="literal">iter()</code> or deal with iterator objects yourself. The <code class="literal">for</code> statement does that automatically for you, creating a temporary unnamed variable to hold the iterator for the duration of the loop."</em></span></p></blockquote></div><p>Simply put, what happens when you write <code class="literal">for k in sequence: ... body ...</code>, is that the <code class="literal">for</code> loop asks <code class="literal">sequence</code> for the next element, it gets something back, it calls that something <code class="literal">k</code>, and then executes its body. Then, once again, the <code class="literal">for</code> loop asks <code class="literal">sequence</code> again for the next element, it calls it <code class="literal">k</code> again, and executes the body again, and so on and so forth, until the sequence is exhausted. Empty sequences will result in zero executions of the body.</p><p>Some<a id="id213" class="indexterm"/> data structures, when iterated over, produce their elements in order, like lists, tuples, and strings, while some others don't, like sets and dictionaries.</p><p>Python <a id="id214" class="indexterm"/>gives us the ability to iterate over iterables, using a type of object called <span class="strong"><strong>iterator</strong></span>. According to the official documentation, an iterator is:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"An object representing a stream of data. Repeated calls to the iterator's <code class="literal">__next__()</code> method (or passing it to the built-in function <code class="literal">next()</code>) return successive items in the stream. When no more data are available a <code class="literal">StopIteration</code> exception is raised instead. At this point, the iterator object is exhausted and any further calls to its <code class="literal">__next__()</code> method just raise <code class="literal">StopIteration</code> again. Iterators are required to have an <code class="literal">__iter__()</code> method that returns the iterator object itself so every iterator is also iterable and may be used in most places where other iterables are accepted. One notable exception is code which attempts multiple iteration passes. A container object (such as a <code class="literal">list</code>) produces a fresh new iterator each time you pass it to the <code class="literal">iter()</code> function or use it in a <code class="literal">for</code> loop. Attempting this with an iterator will just return the same exhausted iterator object used in the previous iteration pass, making it appear like an empty container."</em></span></p></blockquote></div><p>Don't worry if you don't fully understand all the preceding legalese, you will in due time. I put it here as a handy reference for the future.</p><p>In practice, the whole iterable/iterator mechanism is somewhat hidden behind the code. Unless you need to code your own iterable or iterator for some reason, you won't have to worry about this too much. But it's very important to understand how Python handles this key aspect of control flow because it will shape the way you will write your code.</p></div><div class="section" title="Iterating over multiple sequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Iterating over multiple sequences</h2></div></div></div><p>Let's see <a id="id215" class="indexterm"/>another example of how to iterate over two sequences of the same length, in order to work on their respective elements in pairs. Say we have a list of people and a list of numbers representing the age of the people in the first list. We want to print a pair person/age on one line for all of them. Let's start with an example and let's refine it gradually.</p><p>
<code class="literal">multiple.sequences.py</code>
</p><div class="informalexample"><pre class="programlisting">people = ['Jonas', 'Julio', 'Mike', 'Mez']
ages = [25, 30, 31, 39]
for position in range(len(people)):
    person = people[position]
    age = ages[position]
    print(person, age)</pre></div><p>By now, this code should be pretty straightforward for you to understand. We need to iterate<a id="id216" class="indexterm"/> over the list of positions (0, 1, 2, 3) because we want to retrieve elements from two different lists. Executing it we get the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python multiple.sequences.py</strong></span>
<span class="strong"><strong>Jonas 25</strong></span>
<span class="strong"><strong>Julio 30</strong></span>
<span class="strong"><strong>Mike 31</strong></span>
<span class="strong"><strong>Mez 39</strong></span>
</pre></div><p>This code is both inefficient and not Pythonic. Inefficient because retrieving an element given the position can be an expensive operation, and we're doing it from scratch at each iteration. The mail man doesn't go back to the beginning of the road each time he delivers a letter, right? He moves from house to house. From one to the next one. Let's try to make it better using enumerate:</p><p>
<code class="literal">multiple.sequences.enumerate.py</code>
</p><div class="informalexample"><pre class="programlisting">people = ['Jonas', 'Julio', 'Mike', 'Mez']
ages = [25, 30, 31, 39]
for position, person in enumerate(people):
    age = ages[position]
    print(person, age)</pre></div><p>Better, but still not perfect. And still a bit ugly. We're iterating properly on <code class="literal">people</code>, but we're still fetching <code class="literal">age</code> using positional indexing, which we want to lose as well. Well, no worries, Python gives you the <code class="literal">zip</code> function, remember? Let's use it!</p><p>
<code class="literal">multiple.sequences.zip.py</code>
</p><div class="informalexample"><pre class="programlisting">people = ['Jonas', 'Julio', 'Mike', 'Mez']
ages = [25, 30, 31, 39]
for person, age in zip(people, ages):
    print(person, age)</pre></div><p>Ah! So much better! Once again, compare the preceding code with the first example and admire Python's elegance. The reason I wanted to show this example is twofold. On the one hand, I wanted to give you an idea of how shorter the code in Python can be compared to other languages where the syntax doesn't allow you to iterate over sequences or collections as easily. And on the other hand, and much more importantly, notice that when the <code class="literal">for</code> loop asks <code class="literal">zip(sequenceA, sequenceB)</code> for the next element, it gets back a <code class="literal">tuple</code>, not just a single object. It gets back a <code class="literal">tuple</code> with as many elements as the number of sequences we feed to the <code class="literal">zip</code> function. Let's expand a little on the previous example in two ways: using explicit and implicit assignment:</p><p>
<code class="literal">multiple.sequences.explicit.py</code>
</p><div class="informalexample"><pre class="programlisting">people = ['Jonas', 'Julio', 'Mike', 'Mez']
ages = [25, 30, 31, 39]
nationalities = ['Belgium', 'Spain', 'England', 'Bangladesh']
for <span class="strong"><strong>person, age, nationality</strong></span> in zip(<span class="strong"><strong>people, ages, nationalities</strong></span>):
    print(person, age, nationality)</pre></div><p>In the <a id="id217" class="indexterm"/>preceding code, we added the nationalities list. Now that we feed three sequences to the <code class="literal">zip</code> function, the for loop gets back a <span class="emphasis"><em>3-tuple</em></span> at each iteration. Notice that the position of the elements in the tuple respects the position of the sequences in the <code class="literal">zip</code> call. Executing the code will yield the following result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python multiple.sequences.explicit.py</strong></span>
<span class="strong"><strong>Jonas 25 Belgium</strong></span>
<span class="strong"><strong>Julio 30 Spain</strong></span>
<span class="strong"><strong>Mike 31 England</strong></span>
<span class="strong"><strong>Mez 39 Bangladesh</strong></span>
</pre></div><p>Sometimes, for reasons that may not be clear in a simple example like the preceding one, you may want to explode the tuple within the body of the <code class="literal">for</code> loop. If that is your desire, it's perfectly possible to do so.</p><p>
<code class="literal">multiple.sequences.implicit.py</code>
</p><div class="informalexample"><pre class="programlisting">people = ['Jonas', 'Julio', 'Mike', 'Mez']
ages = [25, 30, 31, 39]
nationalities = ['Belgium', 'Spain', 'England', 'Bangladesh']
for <span class="strong"><strong>data</strong></span> in zip(people, ages, nationalities):
    <span class="strong"><strong>person, age, nationality = data</strong></span>
    print(person, age, nationality)</pre></div><p>It's basically doing what the <code class="literal">for</code> loop does automatically for you, but in some cases you may want to do it yourself. Here, the 3-tuple <code class="literal">data</code> that comes from <code class="literal">zip(...)</code>, is exploded within the body of the <code class="literal">for</code> loop into three variables: <code class="literal">person</code>, <code class="literal">age</code>, and <code class="literal">nationality</code>.</p></div><div class="section" title="The while loop"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec48"/>The while loop</h2></div></div></div><p>In the <a id="id218" class="indexterm"/>preceding pages, we saw the <code class="literal">for</code> loop in action. It's incredibly useful when you need to loop over a sequence or a collection. The key point to keep in mind, when you need to be able to discriminate which looping construct to use, is that the <code class="literal">for</code> loop rocks when you have to iterate over a finite amount of elements. It can be a huge amount, but still, something that at some point ends.</p><p>There are other cases though, when you just need to loop until some condition is satisfied, or even loop indefinitely until the application is stopped. Cases where we don't really have something to iterate on, and therefore the <code class="literal">for</code> loop would be a poor choice. But fear not, for these cases Python provides us with the <code class="literal">while</code> loop.</p><p>The <code class="literal">while</code> loop is similar to the <code class="literal">for</code> loop, in that they both loop and at each iteration they execute a body of instructions. What is different between them is that the <code class="literal">while</code> loop doesn't loop over a sequence (it can, but you have to manually write the logic and it wouldn't make any sense, you would just want to use a <code class="literal">for</code> loop), rather, it loops as long as a certain condition is satisfied. When the condition is no longer satisfied, the loop ends.</p><p>As usual, let's<a id="id219" class="indexterm"/> see an example which will clarify everything for us. We want to print the binary representation of a positive number. In order to do so, we repeatedly divide the number by two, collecting the remainder, and then produce the inverse of the list of remainders. Let me give you a small example using number 6, which is 110 in binary.</p><div class="informalexample"><pre class="programlisting">6 / 2 = 3 (remainder: 0)
3 / 2 = 1 (remainder: 1)
1 / 2 = 0 (remainder: 1)
List of remainders: 0, 1, 1.
Inverse is 1, 1, 0, which is also the binary representation of 6: 110</pre></div><p>Let's write some code to calculate the binary representation for number 39: 100111<sub>2</sub>.</p><p>
<code class="literal">binary.py</code>
</p><div class="informalexample"><pre class="programlisting">n = 39
remainders = []
while <span class="strong"><strong>n &gt; 0</strong></span>:
    remainder = n % 2  # remainder of division by 2
    remainders.append(remainder)  # we keep track of remainders
    n //= 2  # we divide n by 2

# reassign the list to its reversed copy and print it
remainders = <span class="strong"><strong>remainders[::-1]</strong></span>
print(remainders)</pre></div><p>In the preceding code, I highlighted two things: <code class="literal">n &gt; 0</code>, which is the condition to keep looping, and <code class="literal">remainders[::-1]</code> which is a nice and easy way to get the reversed version of a list (missing <code class="literal">start</code> and <code class="literal">end</code> parameters, <code class="literal">step = -1</code>, produces the same list, from <code class="literal">end</code> to <code class="literal">start</code>, in reverse order). We can make the code a little shorter (and more Pythonic), by using the <code class="literal">divmod</code> function, which is called with a number and a divisor, and returns a tuple with the result of the integer division and its remainder. For example, <code class="literal">divmod(13, 5)</code> would return <code class="literal">(2, 3)</code>, and indeed <span class="emphasis"><em>5 * 2 + 3 = 13</em></span>.</p><p>
<code class="literal">binary.2.py</code>
</p><div class="informalexample"><pre class="programlisting">n = 39
remainders = []
while n &gt; 0:
    <span class="strong"><strong>n, remainder = divmod(n, 2)</strong></span>
    remainders.append(remainder)

# reassign the list to its reversed copy and print it
remainders = remainders[::-1]
print(remainders)</pre></div><p>In the<a id="id220" class="indexterm"/> preceding code, we have reassigned n to the result of the division by 2, and the remainder, in one single line.</p><p>Notice that the condition in a <code class="literal">while</code> loop is a condition to continue looping. If it evaluates to <code class="literal">True</code>, then the body is executed and then another evaluation follows, and so on, until the condition evaluates to <code class="literal">False</code>. When that happens, the loop is exited immediately without executing its body.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>If the<a id="id221" class="indexterm"/> condition never evaluates to <code class="literal">False</code>, the loop becomes a so called <span class="strong"><strong>infinite loop</strong></span>. Infinite loops are used for example when polling from network devices: you ask the socket if there is any data, you do something with it if there is any, then you sleep for a small amount of time, and then you ask the socket again, over and over again, without ever stopping.</p></div></div><p>Having the ability to loop over a condition, or to loop indefinitely, is the reason why the <code class="literal">for</code> loop alone is not enough, and therefore Python provides the <code class="literal">while</code> loop.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>By the way, if you need the binary representation of a number, checkout the <code class="literal">bin</code> function.</p></div></div><p>Just for fun, let's adapt one of the examples (<code class="literal">multiple.sequences.py</code>) using the while logic.</p><p>
<code class="literal">multiple.sequences.while.py</code>
</p><div class="informalexample"><pre class="programlisting">people = ['Jonas', 'Julio', 'Mike', 'Mez']
ages = [25, 30, 31, 39]
<span class="strong"><strong>position = 0</strong></span>
while <span class="strong"><strong>position &lt; len(people)</strong></span>:
    person = people[position]
    age = ages[position]
    print(person, age)
    <span class="strong"><strong>position += 1</strong></span>
</pre></div><p>In the preceding code, I have highlighted the <span class="emphasis"><em>initialization</em></span>, <span class="emphasis"><em>condition</em></span>, and <span class="emphasis"><em>update</em></span> of the variable <code class="literal">position</code>, which makes it possible to simulate the equivalent <code class="literal">for</code> loop code by handling the iteration variable manually. Everything that can be done with a <code class="literal">for</code> loop can also be done with a <code class="literal">while</code> loop, even though you can see there's a bit of boilerplate you have to go through in order to achieve the same result. The opposite is also true, but simulating a never ending <code class="literal">while</code> loop using a <code class="literal">for</code> loop requires some real trickery, so why would you do that? Use the right tool for the job, and 99.9% of the times you'll be fine.</p><p>So, to <a id="id222" class="indexterm"/>recap, use a <code class="literal">for</code> loop when you need to iterate over one (or a combination of) iterable, and a <code class="literal">while</code> loop when you need to loop according to a condition being satisfied or not. If you keep in mind the difference between the two purposes, you will never choose the wrong looping construct.</p><p>Let's now see how to alter the normal flow of a loop.</p></div><div class="section" title="The break and continue statements"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec49"/>The break and continue statements</h2></div></div></div><p>According<a id="id223" class="indexterm"/> to the task at hand, sometimes you will need to alter the regular flow of a loop. You can either skip a single iteration (as many times you want), or you can break out of the loop entirely. A common use case for skipping iterations is for example when you're iterating over a list of items and you need to work on each of them only if some condition is verified. On the other hand, if you're iterating over a collection of items, and you have found one of them that satisfies some need you have, you may decide not to continue the loop entirely and therefore break out of it. There are countless possible scenarios, so it's better to see a couple of examples.</p><p>Let's say you want to apply a 20% discount to all products in a basket list for those which have an expiration date of today. The way you achieve this is to use the <span class="strong"><strong>continue</strong></span> statement, which tells the looping construct (<code class="literal">for</code> or <code class="literal">while</code>) to immediately stop execution of the body and go to the next iteration, if any. This example will take us a little deeper down the rabbit whole, so be ready to jump.</p><p>
<code class="literal">discount.py</code>
</p><div class="informalexample"><pre class="programlisting">from datetime import date, timedelta

today = date.today()
tomorrow = today + timedelta(days=1)  # today + 1 day is tomorrow
products = [
    {'sku': '1', 'expiration_date': <span class="strong"><strong>today</strong></span>, 'price': 100.0},
    {'sku': '2', 'expiration_date': tomorrow, 'price': 50},
    {'sku': '3', 'expiration_date': <span class="strong"><strong>today</strong></span>, 'price': 20},
]
for product in products:
    if product['expiration_date'] != today:
        <span class="strong"><strong>continue</strong></span>
    product['price'] *= 0.8  # equivalent to applying 20% discount
    print(
        'Price for sku', product['sku'],
        'is now', product['price'])</pre></div><p>You see we start by importing the <code class="literal">date</code> and <code class="literal">timedelta</code> objects, then we set up our products. Those with sku <code class="literal">1</code> and <code class="literal">3</code> have an expiration date of <code class="literal">today</code>, which means we want to apply 20% discount on them. We loop over each <code class="literal">product</code> and we inspect the expiration date. If it is not (inequality operator, <code class="literal">!=</code>) <code class="literal">today</code>, we don't want to execute the rest of the body suite, so we <code class="literal">continue</code>.</p><p>Notice<a id="id224" class="indexterm"/> that is not important where in the body suite you place the <code class="literal">continue</code> statement (you can even use it more than once). When you reach it, execution stops and goes back to the next iteration. If we run the <code class="literal">discount.py</code> module, this is the output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python discount.py</strong></span>
<span class="strong"><strong>Price for sku 1 is now 80.0</strong></span>
<span class="strong"><strong>Price for sku 3 is now 16.0</strong></span>
</pre></div><p>Which shows you that the last two lines of the body haven't been executed for sku number 2.</p><p>Let's now see an example of breaking out of a loop. Say we want to tell if at least any of the elements in a list evaluates to <code class="literal">True</code> when fed to the <code class="literal">bool</code> function. Given that we need to know if there is at least one, when we find it we don't need to keep scanning the list any further. In Python code, this translates to using the <span class="strong"><strong>break</strong></span> statement. Let's write this down into code:</p><p>
<code class="literal">any.py</code>
</p><div class="informalexample"><pre class="programlisting">items = [0, None, 0.0, True, 0, 7]  # True and 7 evaluate to True
<span class="strong"><strong>found = False</strong></span>  # this is called "flag"
for item in items:
    print('scanning item', item)
    if item:
        <span class="strong"><strong>found = True</strong></span>  # we update the flag
        <span class="strong"><strong>break</strong></span>

<span class="strong"><strong>if found:</strong></span>  # we inspect the flag
    print('At least one item evaluates to True')
else:
    print('All items evaluate to False')</pre></div><p>The preceding code is such a common pattern in programming, you will see it a lot. When you inspect items this way, basically what you do is to set up a <code class="literal">flag</code> variable, then start the inspection. If you find one element that matches your criteria (in this example, that evaluates to <code class="literal">True</code>), then you update the flag and stop iterating. After iteration, you inspect the flag and take action accordingly. Execution yields:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python any.py</strong></span>
<span class="strong"><strong>scanning item 0</strong></span>
<span class="strong"><strong>scanning item None</strong></span>
<span class="strong"><strong>scanning item 0.0</strong></span>
<span class="strong"><strong>scanning item True</strong></span>
<span class="strong"><strong>At least one item evaluates to True</strong></span>
</pre></div><p>See<a id="id225" class="indexterm"/> how execution stopped after <code class="literal">True</code> was found?</p><p>The <code class="literal">break</code> statement acts exactly like the <code class="literal">continue</code> one, in that it stops executing the body of the loop immediately, but also, prevents any other iteration to run, effectively breaking out of the loop.</p><p>The <code class="literal">continue</code> and <code class="literal">break</code> statements can be used together with no limitation in their number, both in the <code class="literal">for</code> and <code class="literal">while</code> looping constructs.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>By the way, there is no need to write code to detect if there is at least one element in a sequence that evaluates to <code class="literal">True</code>. Just check out the <code class="literal">any</code> built-in function.</p></div></div></div><div class="section" title="A special else clause"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec50"/>A special else clause</h2></div></div></div><p>One<a id="id226" class="indexterm"/> of the features I've seen only in the Python language is the ability to have <code class="literal">else</code> clauses after <code class="literal">while</code> and <code class="literal">for</code> loops. It's very rarely used, but it's definitely nice to have. In short, you can have an <code class="literal">else</code> suite after a <code class="literal">for</code> or <code class="literal">while</code> loop. If the loop ends normally, because of exhaustion of the iterator (<code class="literal">for</code> loop) or because the condition is finally not met (<code class="literal">while</code> loop), then the <code class="literal">else</code> suite (if present) is executed. In case execution is interrupted by a <code class="literal">break</code> statement, the <code class="literal">else</code> clause is not executed. Let's take an example of a <code class="literal">for</code> loop that iterates over a group of items, looking for one that would match some condition. In case we don't find at least one that satisfies the condition, we <a id="id227" class="indexterm"/>want to raise an <span class="strong"><strong>exception</strong></span>. This means we want to arrest the regular execution of the program and signal that there was an error, or exception, that we cannot deal with. Exceptions will be the subject of <a class="link" href="ch07.html" title="Chapter 7. Testing, Profiling, and Dealing with Exceptions">Chapter 7</a>, <span class="emphasis"><em>Testing, Profiling, and Dealing with Exceptions</em></span>, so don't worry if you don't fully understand them now. Just bear in mind that they will alter the regular flow of the code. Let me now show you two examples that do exactly the same thing, but one of them is using the special <code class="literal">for</code> ... <code class="literal">else</code> syntax. Say that we want to find among a collection of people one that could drive a car.</p><p>
<code class="literal">for.no.else.py</code>
</p><div class="informalexample"><pre class="programlisting">class DriverException(Exception):
    pass

people = [('James', 17), ('Kirk', 9), ('Lars', 13), ('Robert', 8)]
<span class="strong"><strong>driver = None</strong></span>
for person, age in people:
    if age &gt;= 18:
        <span class="strong"><strong>driver = (person, age)</strong></span>
<span class="strong"><strong>        break</strong></span>

<span class="strong"><strong>if driver is None:</strong></span>
    raise DriverException('Driver not found.')</pre></div><p>Notice the <code class="literal">flag</code> pattern again. We set driver to be <code class="literal">None</code>, then if we find one we update the <code class="literal">driver</code> flag, and then, at the end of the loop, we inspect it to see if one was found. I kind of have<a id="id228" class="indexterm"/> the feeling that those kids would drive a very metallic car, but anyway, notice that if a driver is not found, a <code class="literal">DriverException</code> is raised, signaling the program that execution cannot continue (we're lacking the driver).</p><p>The same functionality can be rewritten a bit more elegantly using the following code:</p><p>
<code class="literal">for.else.py</code>
</p><div class="informalexample"><pre class="programlisting">class DriverException(Exception):
    pass

people = [('James', 17), ('Kirk', 9), ('Lars', 13), ('Robert', 8)]
for person, age in people:
    if age &gt;= 18:
        <span class="strong"><strong>driver = (person, age)</strong></span>
        break
<span class="strong"><strong>else</strong></span>:
    raise DriverException('Driver not found.')</pre></div><p>Notice that we aren't forced to use the <code class="literal">flag</code> pattern any more. The exception is raised as part of the <code class="literal">for</code> loop logic, which makes good sense because the <code class="literal">for</code> loop is checking on some condition. All we need is to set up a <code class="literal">driver</code> object in case we find one, because the rest of the code is going to use that information somewhere. Notice the code is shorter and more elegant, because the logic is now correctly grouped together where it belongs.</p></div></div>
<div class="section" title="Putting this all together"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Putting this all together</h1></div></div></div><p>Now that you have seen all there is to see about conditionals and loops, it's time to spice things up a little, and see those two examples I anticipated at the beginning of this chapter. We'll mix and match here, so you can see how one can use all these concepts together. Let's start by writing some code to generate a list of prime numbers up to some limit. Please bear in mind that I'm going to write a very inefficient and rudimentary algorithm to detect primes. The important thing for you is to concentrate on those bits in the code that belong to this chapter's subject.</p><div class="section" title="Example 1 – a prime generator"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec51"/>Example 1 – a prime generator</h2></div></div></div><p>According<a id="id229" class="indexterm"/> to Wikipedia:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"A prime number (or a prime) is a natural number greater than 1 that has no positive divisors other than 1 and itself. A natural number greater than 1 that is not a prime number is called a composite number."</em></span></p></blockquote></div><p>Based on this definition, if we consider the first 10 natural numbers, we can see that 2, 3, 5, and 7 are primes, while 1, 4, 6, 8, 9, 10 are not. In order to have a computer tell you if a number <span class="emphasis"><em>N</em></span> is prime, you can divide that number by all natural numbers in the range [2, <span class="emphasis"><em>N</em></span>). If any of those divisions yields zero as a remainder, then the number is not a prime. Enough chatter, let's get down to business. I'll write two versions of this, the second of which will exploit the <code class="literal">for</code> ... <code class="literal">else</code> syntax.</p><p>
<code class="literal">primes.py</code>
</p><div class="informalexample"><pre class="programlisting">primes = []  # this will contain the primes in the end
upto = 100  # the limit, inclusive
for n in range(2, upto + 1):
    <span class="strong"><strong>is_prime = True</strong></span>  # flag, new at each iteration of outer for
    for divisor in range(2, n):
        <span class="strong"><strong>if n % divisor == 0:</strong></span>
            <span class="strong"><strong>is_prime = False</strong></span>
<span class="strong"><strong>            break</strong></span>
    <span class="strong"><strong>if is_prime:</strong></span>  # check on flag
        primes.append(n)
print(primes)</pre></div><p>Lots of things to notice in the preceding code. First of all we set up an empty list <code class="literal">primes</code>, which will contain the primes at the end. The limit is 100, and you can see it's inclusive in the way we call <code class="literal">range()</code> in the outer loop. If we wrote <code class="literal">range(2, upto)</code> that would be [2, upto), right? Therefore <code class="literal">range(2, upto + 1)</code> gives us <span class="emphasis"><em>[2, upto + 1) == [2, upto]</em></span>.</p><p>So, two <code class="literal">for</code> loops. In the outer one we loop over the candidate primes, that is, all natural numbers from 2 to <code class="literal">upto</code>. Inside each iteration of this outer loop we set up a flag (which is set to <code class="literal">True</code> at each iteration), and then start dividing the current <code class="literal">n</code> by all numbers from 2 to <span class="emphasis"><em>n</em></span> – 1. If we find a proper divisor for <code class="literal">n</code>, it means <code class="literal">n</code> is composite, and therefore we set the flag to <code class="literal">False</code> and break the loop. Notice that when we break the inner one, the outer one keeps on going normally. The reason why we break after having found a proper divisor for <code class="literal">n</code> is that we don't need any further information to be able to tell that <code class="literal">n</code> is not a prime.</p><p>When we check on the <code class="literal">is_prime</code> flag, if it is still <code class="literal">True</code>, it means we couldn't find any number in [2, <span class="emphasis"><em>n</em></span>) that is a proper divisor for <code class="literal">n</code>, therefore <code class="literal">n</code> is a prime. We append <code class="literal">n</code> to the <code class="literal">primes</code> list, and hop! Another iteration, until <span class="emphasis"><em>n</em></span> equals 100.</p><p>Running this code yields:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python primes.py</strong></span>
<span class="strong"><strong>[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]</strong></span>
</pre></div><p>Before we proceed, one question: of all iterations of the outer loop, one of them is different than all the others. Could you tell which one, and why? Think about it for a second, go back to the code and try to figure it out for yourself, and then keep reading on.</p><p>Did you<a id="id230" class="indexterm"/> figure it out? If not, don't feel bad, it's perfectly normal. I asked you to do it as a small exercise because it's what coders do all the time. The skill to understand what the code does by simply looking at it is something you build over time. It's very important, so try to exercise it whenever you can. I'll tell you the answer now: the iteration that behaves differently from all others is the first one. The reason is because in the first iteration, <code class="literal">n</code> is 2. Therefore the innermost <code class="literal">for</code> loop won't even run, because it's a <code class="literal">for</code> loop which iterates over <code class="literal">range(2, 2)</code>, and what is that if not [2, 2)? Try it out for yourself, write a simple <code class="literal">for</code> loop with that iterable, put a <code class="literal">print</code> in the body suite, and see if anything happens (it won't...).</p><p>Now, from an algorithmic point of view this code is inefficient so let's at least make it more beautiful:</p><p>
<code class="literal">primes.else.py</code>
</p><div class="informalexample"><pre class="programlisting">primes = []
upto = 100
for n in range(2, upto + 1):
    for divisor in range(2, n):
        if n % divisor == 0:
            break
    <span class="strong"><strong>else:</strong></span>
<span class="strong"><strong>        primes.append(n)</strong></span>
print(primes)</pre></div><p>Much nicer, right? The <code class="literal">is_prime</code> flag is completely gone, and we append <code class="literal">n</code> to the <code class="literal">primes</code> list when we know the inner <code class="literal">for</code> loop hasn't encountered any <code class="literal">break</code> statements. See how the code looks cleaner and reads better?</p></div><div class="section" title="Example 2 – applying discounts"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec52"/>Example 2 – applying discounts</h2></div></div></div><p>In this<a id="id231" class="indexterm"/> example, I want to show you a technique I like a lot. In many programming languages, other than the <code class="literal">if</code>/<code class="literal">elif</code>/<code class="literal">else</code> constructs, in whatever form or syntax they may come, you can find another statement, usually called <code class="literal">switch</code>/<code class="literal">case</code>, that in Python is missing. It is the equivalent of a cascade of <code class="literal">if</code>/<code class="literal">elif</code>/.../<code class="literal">elif</code>/else clauses, with a syntax similar to this (warning! JavaScript code!):</p><p>
<code class="literal">switch.js</code>
</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>switch</strong></span> (day_number) {
    <span class="strong"><strong>case</strong></span> 1:
    <span class="strong"><strong>case</strong></span> 2:
    <span class="strong"><strong>case</strong></span> 3:
    <span class="strong"><strong>case</strong></span> 4:
    <span class="strong"><strong>case</strong></span> 5:
        day = "Weekday";
        break;
    <span class="strong"><strong>case</strong></span> 6:
        day = "Saturday";
        break;
    <span class="strong"><strong>case</strong></span> 0:
        day = "Sunday";
        break;
    <span class="strong"><strong>default</strong></span>:
        day = "";
        alert(day_number + ' is not a valid day number.')
}</pre></div><p>In the preceding code, we <code class="literal">switch</code> on a variable called <code class="literal">day_number</code>. This means we get its value and then we decide what case it fits in (if any). From 1 to 5 there is a cascade, which means no matter the number, [1, 5] all go down to the bit of logic that sets <code class="literal">day</code> as <code class="literal">"Weekday"</code>. Then we have single cases for 0 and 6 and a <code class="literal">default</code> case to prevent errors, which alerts the system that <code class="literal">day_number</code> is not a valid day number, that is, not in [0, 6]. Python is perfectly capable of realizing such logic using <code class="literal">if</code>/<code class="literal">elif</code>/<code class="literal">else</code> statements:</p><p>
<code class="literal">switch.py</code>
</p><div class="informalexample"><pre class="programlisting">if 1 &lt;= day_number &lt;= 5:
    day = 'Weekday'
elif day_number == 6:
    day = 'Saturday'
elif day_number == 0:
    day = 'Sunday'
else:
    day = ''
    raise ValueError(
        str(day_number) + ' is not a valid day number.')</pre></div><p>In the preceding code, we reproduce the same logic of the JavaScript snippet, in Python, using <code class="literal">if</code>/<code class="literal">elif</code>/<code class="literal">else</code> statements. I raised <code class="literal">ValueError</code> exception just as an example at the end, if <code class="literal">day_number</code> is not in [0, 6]. This is one possible way of translating the <code class="literal">switch</code>/<code class="literal">case</code> logic, but there is also another one, sometimes called dispatching, which I will show you in the last version of the next example.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>By the way, did you notice the first line of the previous snippet? Have you noticed that Python can make double (actually, even multiple) comparisons? It's just wonderful!</p></div></div><p>Let's start the new example by simply writing some code that assigns a discount to customers<a id="id232" class="indexterm"/> based on their coupon value. I'll keep the logic down to a minimum here, remember that all we really care about is conditionals and loops.</p><p>
<code class="literal">coupons.py</code>
</p><div class="informalexample"><pre class="programlisting">customers = [
    dict(id=1, total=200, coupon_code='F20'),  # F20: fixed, £20
    dict(id=2, total=150, coupon_code='P30'),  # P30: percent, 30%
    dict(id=3, total=100, coupon_code='P50'),  # P50: percent, 50%
    dict(id=4, total=110, coupon_code='F15'),  # F15: fixed, £15
]
for customer in customers:
    code = customer['coupon_code']
    if code == 'F20':
        customer['discount'] = 20.0
    elif code == 'F15':
        customer['discount'] = 15.0
    elif code == 'P30':
        customer['discount'] = customer['total'] * 0.3
    elif code == 'P50':
        customer['discount'] = customer['total'] * 0.5
    else:
        customer['discount'] = 0.0

for customer in customers:
    print(customer['id'], customer['total'], customer['discount'])</pre></div><p>We start by setting up some customers. They have an order total, a coupon code, and an id. I made up four different types of coupon, two are fixed and two are percentage based. You can see that in the <code class="literal">if</code>/<code class="literal">elif</code>/<code class="literal">else</code> cascade I apply the discount accordingly, and I set it as a <code class="literal">'discount'</code> key in the <code class="literal">customer</code> dict.</p><p>At the end I just print out part of the data to see if my code is working properly.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python coupons.py</strong></span>
<span class="strong"><strong>1 200 20.0</strong></span>
<span class="strong"><strong>2 150 45.0</strong></span>
<span class="strong"><strong>3 100 50.0</strong></span>
<span class="strong"><strong>4 110 15.0</strong></span>
</pre></div><p>This code is simple to understand, but all those clauses are kind of cluttering the logic. It's not easy to see what's going on at a first glance, and I don't like it. In cases like this, you can exploit a dictionary to your advantage, like this:</p><p>
<code class="literal">coupons.dict.py</code>
</p><div class="informalexample"><pre class="programlisting">customers = [
    dict(id=1, total=200, coupon_code='F20'),  # F20: fixed, £20
    dict(id=2, total=150, coupon_code='P30'),  # P30: percent, 30%
    dict(id=3, total=100, coupon_code='P50'),  # P50: percent, 50%
    dict(id=4, total=110, coupon_code='F15'),  # F15: fixed, £15
]
discounts = {
    'F20': (0.0, 20.0),  # each value is (percent, fixed)
    'P30': (0.3, 0.0),
    'P50': (0.5, 0.0),
    'F15': (0.0, 15.0),
}
for customer in customers:
    code = customer['coupon_code']
    <span class="strong"><strong>percent, fixed = discounts.get(code, (0.0, 0.0))</strong></span>
    customer['discount'] = <span class="strong"><strong>percent * customer['total'] + fixed</strong></span>

for customer in customers:
    print(customer['id'], customer['total'], customer['discount'])</pre></div><p>Running<a id="id233" class="indexterm"/> the preceding code yields exactly the same result we had from the snippet before it. We spared two lines, but more importantly, we gained a lot in readability, as the body of the <code class="literal">for</code> loop now is just three lines long, and very easy to understand. The <a id="id234" class="indexterm"/>concept here is to use a dictionary as <span class="strong"><strong>dispatcher</strong></span>. In other words, we try to fetch something from the dictionary based on a code (our <code class="literal">coupon_code</code>), and by using <code class="literal">dict.get(key, default)</code>, we make sure we also cater for when the <code class="literal">code</code> is not in the dictionary and we need a default value.</p><p>Notice that I had to apply some very simple linear algebra in order to calculate the discount properly. Each discount has a percentage and fixed part in the dictionary, represented by a 2-tuple. By applying <code class="literal">percent * total + fixed</code>, we get the correct discount. When <code class="literal">percent</code> is <code class="literal">0</code>, the formula just gives the fixed amount, and it gives <code class="literal">percent * total</code> when fixed is <code class="literal">0</code>. Simple but effective.</p><p>This technique is important because it is also used in other contexts, with functions, where it actually becomes much more powerful than what we've seen in the preceding snippet. If it's not completely clear to you how it works, I suggest you to take your time and experiment <a id="id235" class="indexterm"/>with it. Change values and add print statements to see what's going on while the program is running.</p></div></div>
<div class="section" title="A quick peek at the itertools module"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>A quick peek at the itertools module</h1></div></div></div><p>A chapter<a id="id236" class="indexterm"/> about iterables, iterators, conditional logic, and looping wouldn't be complete without spending a few words about the <code class="literal">itertools</code> module. If you are into iterating, this is a kind of heaven.</p><p>According to the Python official documentation, the <code class="literal">itertools</code> module is:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"A module which implements a number of iterator building blocks inspired by constructs from APL, Haskell, and SML. Each has been recast in a form suitable for Python. The module standardizes a core set of fast, memory efficient tools that are useful by themselves or in combination. Together, they form an "iterator algebra" making it possible to construct specialized tools succinctly and efficiently in pure Python."</em></span></p></blockquote></div><p>By no means do I have the room here to show you all the goodies you can find in this module, so I encourage you to go and check it out for yourself, I promise you'll enjoy it.</p><p>In a nutshell, it provides you with three broad categories of iterators. I will give you a very small example of one iterator taken from each one of them, just to make your mouth water a little.</p><div class="section" title="Infinite iterators"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec53"/>Infinite iterators</h2></div></div></div><p>Infinite<a id="id237" class="indexterm"/> iterators allow you to work with a <code class="literal">for</code> loop in a different fashion, like if it was a <code class="literal">while</code> loop.</p><p>
<code class="literal">infinite.py</code>
</p><div class="informalexample"><pre class="programlisting">from itertools import count
for n in count(5, 3):
    if n &gt; 20:
        break
    print(n, end=', ')  # instead of newline, comma and space</pre></div><p>Running the code gives this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python infinite.py</strong></span>
<span class="strong"><strong>5, 8, 11, 14, 17, 20,</strong></span>
</pre></div><p>The <code class="literal">count</code> factory class makes an iterator that just goes on and on counting. It starts from 5 and keeps adding 3 to it. We need to manually break it if we don't want to get stuck in an infinite loop.</p></div><div class="section" title="Iterators terminating on the shortest input sequence"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec54"/>Iterators terminating on the shortest input sequence</h2></div></div></div><p>This<a id="id238" class="indexterm"/> category is very interesting. It allows you to create an iterator based on multiple iterators, combining their values according to some logic. The key point here is that among those iterators, in case any of them are shorter than the rest, the resulting iterator won't break, it will simply stop as soon as the shortest iterator is exhausted. This is very theoretical, I know, so let me give you an example using <code class="literal">compress</code>. This iterator gives you back the data according to a corresponding item in a selector being <code class="literal">True</code> or <code class="literal">False</code>:</p><p>
<code class="literal">compress('ABC', (1, 0, 1))</code> would give back <code class="literal">'A'</code> and <code class="literal">'C'</code>, because they correspond to the <code class="literal">1's</code>. Let's see a simple example:</p><p>
<code class="literal">compress.py</code>
</p><div class="informalexample"><pre class="programlisting">from itertools import compress
data = range(10)
even_selector = [1, 0] * 10
odd_selector = [0, 1] * 10

even_numbers = list(<span class="strong"><strong>compress(data, even_selector)</strong></span>)
odd_numbers = list(<span class="strong"><strong>compress(data, odd_selector)</strong></span>)

print(odd_selector)
print(list(data))
print(even_numbers)
print(odd_numbers)</pre></div><p>Notice that <code class="literal">odd_selector</code> and <code class="literal">even_selector</code> are 20 elements long, while <code class="literal">data</code> is just 10 elements long. <code class="literal">compress</code> will stop as soon as <code class="literal">data</code> has yielded its last element. Running this code produces the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python compress.py</strong></span>
<span class="strong"><strong>[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]</strong></span>
<span class="strong"><strong>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</strong></span>
<span class="strong"><strong>[0, 2, 4, 6, 8]</strong></span>
<span class="strong"><strong>[1, 3, 5, 7, 9]</strong></span>
</pre></div><p>It's a very fast and nice way of selecting elements out of an iterable. The code is very simple, just notice that instead of using a <code class="literal">for</code> loop to iterate over each value that is given back by the compress calls, we used <code class="literal">list()</code>, which does the same, but instead of executing a body of instructions, puts all the values into a list and returns it.</p></div><div class="section" title="Combinatoric generators"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec55"/>Combinatoric generators</h2></div></div></div><p>Last but <a id="id239" class="indexterm"/>not least, combinatoric generators. These are really fun, if you are into this kind of thing. Let's just see a simple example on permutations.</p><p>According to Wolfram Mathworld:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"A permutation, also called an "arrangement number" or "order", is a rearrangement of the elements of an ordered list S into a one-to-one correspondence with S itself."</em></span></p></blockquote></div><p>For example, the permutations of ABC are 6: ABC, ACB, BAC, BCA, CAB, and CBA.</p><p>If a set has <span class="emphasis"><em>N</em></span> elements, then the number of permutations of them is <span class="emphasis"><em>N!</em></span> (<span class="emphasis"><em>N</em></span> factorial). For the string ABC the permutations are <span class="emphasis"><em>3! = 3 * 2 * 1 = 6</em></span>. Let's do it in Python:</p><p>
<code class="literal">permutations.py</code>
</p><div class="informalexample"><pre class="programlisting">from itertools import permutations
print(list(<span class="strong"><strong>permutations('ABC')</strong></span>))</pre></div><p>This very short snippet of code produces the following result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python permutations.py</strong></span>
<span class="strong"><strong>[('A', 'B', 'C'), ('A', 'C', 'B'), ('B', 'A', 'C'), ('B', 'C', 'A'), ('C', 'A', 'B'), ('C', 'B', 'A')]</strong></span>
</pre></div><p>Be very careful when you play with permutation. Their number grows at a rate that is proportional to the factorial of the number of the elements you're permuting, and that number can get really big, really fast.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Summary</h1></div></div></div><p>In this chapter, we've taken another step forward to expand our coding vocabulary. We've seen how to drive the execution of the code by evaluating conditions, and we've seen how to loop and iterate over sequences and collections of objects. This gives us the power to control what happens when our code is run, which means we are getting an idea on how to shape it so that it does what we want and it reacts to data that changes dynamically.</p><p>We've also seen how to combine everything together in a couple of simple examples, and in the end we have taken a brief look at the <code class="literal">itertools</code> module, which is full of interesting iterators which can enrich our abilities with Python even more.</p><p>Now it's time to switch gears, to take another step forward and talk about functions. The next chapter is all about them because they are extremely important. Make sure you're comfortable with what has been done up to now: I want to provide you with interesting examples, so I'll have to go a little faster. Ready? Turn the page.</p></div></body></html>