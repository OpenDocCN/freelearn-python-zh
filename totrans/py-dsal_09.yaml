- en: Searching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索
- en: With the data structures that have been developed in the preceding chapters,
    one critical operation performed on all of them is searching. In this chapter,
    we shall explore the different strategies that can be used to find elements in
    a collection of items.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中已经开发出的数据结构中，对它们进行的一个关键操作是搜索。在本章中，我们将探讨可以用来在项目集合中查找元素的不同策略。
- en: One other important operation that makes use of searching is sorting. It is
    virtually impossible to sort without some variant of a search operation. The "how
    of searching" is also important as it has a bearing on how quick a sorting algorithm
    ends up performing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的操作是排序，它利用了搜索。没有搜索操作的某种变体，几乎不可能进行排序。"如何搜索"也很重要，因为它影响着排序算法最终执行的速度。
- en: Searching algorithms are categorized under two broad types. One category assumes
    that the list of items to apply the searching operation on, has already been sorted
    whiles the other does not.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索算法分为两大类。一类假设要应用搜索操作的项列表已经排序，而另一类则没有。
- en: The performance of a search operation is heavily influenced by whether the items
    about to be searched have already been sorted or not as we will see in the subsequent
    topics too.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索操作的性能受到即将搜索的项是否已经排序的严重影响，正如我们将在后续主题中看到的。
- en: Linear Search
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性搜索
- en: Let us focus our discussions on linear search, performed on a typical Python
    list.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们集中讨论线性搜索，这是在典型的Python列表上执行的。
- en: '![](img/image_09_001.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_001.jpg)'
- en: The preceding list has elements that are accessible through the list index.
    To find an element in the list we employ the linear searching technique. This
    technique traverses the list of elements, by using the index to move from the
    beginning of the list to the end. Each element is examined and if it does not
    match the search item, the next item is examined. By hopping from one item to
    its next, the list is traversed sequentially.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表中的元素可以通过列表索引访问。要找到列表中的元素，我们采用线性搜索技术。这种技术通过使用索引从列表的开始移动到结束来遍历元素列表。每个元素都会被检查，如果不匹配搜索项，则检查下一个项。通过从一个项跳到其下一个项，列表被顺序遍历。
- en: In treating the sections in this chapter and others, we use a list with integers
    to enhance our understanding since integers lend themselves to easy comparison.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理本章和其他章节的内容时，我们使用整数列表来增强我们的理解，因为整数易于比较。
- en: Unordered linear search
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无序线性搜索
- en: A list containing elements **60**, **1**, **88**, **10**, and **100** is an
    example of an unordered list. The items in the list have no order by magnitude.
    To perform a search operation on such a list, one proceeds from the very first
    item, compares that with the search item. If a match is not made the next element
    in the list is examined. This continues till we reach the last element in the
    list or until a match is made.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 包含元素**60**、**1**、**88**、**10**和**100**的列表是一个无序列表的例子。列表中的项没有按大小排序。要对这样的列表执行搜索操作，需要从第一个项开始，将其与搜索项进行比较。如果没有匹配，则检查列表中的下一个元素。这个过程一直持续到我们到达列表的最后一个元素或直到找到匹配项。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `search` function takes as parameters, the list that houses our data and
    the item that we are looking for called the **search term**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`函数接受两个参数，一个是存放我们数据列表，另一个是我们正在寻找的项，称为**搜索项**。'
- en: The size of the array is obtained and determines the number of times the `for`
    loop is executed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数组的大小并确定`for`循环执行的次数。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On every pass of the `for` loop, we test if the search term is equal to the
    item that the index points to. If true, then there is no need to proceed with
    the search. We return the position where the match occurred.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次`for`循环的迭代中，我们测试搜索项是否等于索引指向的项。如果是真的，则不需要继续搜索。我们返回匹配发生的位置。
- en: If the loop runs to the end of the list with no match being made, `None` is
    returned to signify that there is no such item in the list.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果循环运行到列表的末尾而没有找到匹配项，则返回`None`以表示列表中没有这样的项。
- en: In an unordered list of items, there is no guiding rule for how elements are
    inserted. This therefore impacts the way the search is done. The lack of order
    means that we cannot rely on any rule to perform the search. As such, we must
    visit the items in the list one after the other. As can be seen in the following
    image, the search for the term **66**, starts from the first element and moves
    to next element in the list. Thus **60** compared with **66** and if it is not
    equal, we compare **66** with **1**, **88** and so on till we find the search
    term in the list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在无序列表中，没有关于如何插入元素的指导规则。因此，这影响了搜索的方式。缺乏顺序意味着我们无法依赖任何规则来进行搜索。因此，我们必须逐个访问列表中的项目。如图所示，搜索术语**66**的搜索从第一个元素开始，然后移动到列表中的下一个元素。因此，**60**与**66**进行比较，如果不相等，则将**66**与**1**、**88**等比较，直到在列表中找到搜索词。
- en: '![](img/image_09_002.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_002.jpg)'
- en: The unordered linear search has a worst case running time of `O(n)`. All the
    elements may need to be visited before finding the search term. This will be the
    case if the search term is located at the last position of the list.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 无序线性搜索的最坏情况运行时间为`O(n)`。在找到搜索词之前可能需要访问所有元素。如果搜索词位于列表的最后一个位置，就会发生这种情况。
- en: Ordered linear search
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有序线性搜索
- en: In the case where the elements of a list have been already sorted, our search
    algorithm can be improved. Assuming the elements have been sorted in ascending
    order, the search operation can take advantage of the ordered nature of the list
    to make search more efficient.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表元素已经排序的情况下，我们的搜索算法可以改进。假设元素已经按升序排序，搜索操作可以利用列表的有序性来提高搜索效率。
- en: 'The algorithm is reduced to the following steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 算法简化为以下步骤：
- en: Move through the list sequentially.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顺序遍历列表。
- en: If a search item is greater than the object or item currently under inspection
    in the loop, then quit and return None.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果搜索项大于循环中当前检查的对象或项，则退出并返回`None`。
- en: In the process of iterating through the list, if the search term is greater
    than the current item, then there is no need to continue with the search.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历列表的过程中，如果搜索词大于当前项，则无需继续搜索。
- en: '![](img/image_09_003.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_003.jpg)'
- en: When the search operation starts and the first element is compared with (**5**),
    no match is made. But because there are more elements in the list the search operation
    moves on to examine the next element. A more compelling reason to move on is that
    we know the search item may match any of the elements greater than **2**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当搜索操作开始时，将第一个元素与(**5**)进行比较，没有匹配。但由于列表中还有更多元素，搜索操作继续进行，以检查下一个元素。继续前进的更有说服力的原因是，我们知道搜索项可能与大于**2**的任何元素匹配。
- en: After the 4th comparison, we come to the conclusion that the search term, can
    not be found in any position above where **6** is located. In other words, if
    the current item is greater than the search term, then it means there is no need
    to further search the list.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 经过第4次比较后，我们得出结论，搜索词无法在任何位置找到，这些位置都在**6**所在位置之上。换句话说，如果当前项大于搜索词，那么这意味着没有必要进一步搜索列表。
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `if` statement now caters for this check. The `elif` portion tests the condition
    where `ordered_list[i] > term`. The method returns `None` if the comparison evaluates
    to `True`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`if`语句处理了这个检查。`elif`部分测试`ordered_list[i] > term`的条件。如果比较结果为`True`，则方法返回`None`。
- en: The last line in the method returns `None` because the loop may go through the
    list and still not find any element matching the search term.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 方法中的最后一行返回`None`，因为循环可能遍历列表，但仍找不到任何与搜索词匹配的元素。
- en: The worst case time complexity of an ordered linear search is `O(n)`. In general,
    this kind of search is considered inefficient especially when dealing with large
    data sets.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有序线性搜索的最坏情况时间复杂度为`O(n)`。一般来说，这种搜索被认为效率低下，尤其是在处理大数据集时。
- en: Binary search
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二分搜索
- en: A binary search is a search strategy used to find elements within a list by
    consistently reducing the amount of data to be searched and thereby increasing
    the rate at which the search term is found.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索是一种搜索策略，用于通过持续减少要搜索的数据量来找到列表中的元素，从而提高找到搜索词的速率。
- en: To use a binary search algorithm, the list to be operated on must have already
    been sorted.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用二分搜索算法，要操作列表必须已经排序。
- en: The *binary* term carries a number of meanings and helps us put our minds in
    the right frame to understand the algorithm.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: “二分”这个词有几个含义，帮助我们正确理解算法。
- en: A binary decision has to be made at each attempt to find an item in the list.
    One critical decision is to guess which part of the list is likely to house the
    item we are looking for. Would the search term be in the first half of second
    half of the list, that is, if we always perceive the list as being comprised of
    two parts?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中寻找一个项目时，每次尝试都需要做出一个二进制决策。一个关键的决策是猜测列表的哪一部分可能包含我们正在寻找的项目。搜索词会在列表的前半部分还是后半部分，也就是说，如果我们总是把列表看作由两部分组成的话？
- en: Instead of moving from one cell of the list to the other, if we employ the use
    of an educated guessing strategy, we are likely to arrive at the position where
    the item will be found much faster.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与其从一个列表的单元格移动到另一个单元格，如果我们采用一种有根据的猜测策略，我们很可能会更快地到达找到项目所在的位置。
- en: As an example, lets take it that we want to find the middle page of a 1000 page
    book. We already know that every book has its pages numbered sequentially from
    1 upwards. So it figures that the 500th page should be found right at the middle
    of the book, instead of moving and flipping from page 1, 2 to reach the 500th
    page. Let's say we decide to now look for the page 250\. We can still use our
    strategy to find the page easily. We guess that page 500 cuts the book in half.
    Page 250, will lay to the left of the book. No need to worry about whether we
    can find 250th page between page 500 and 1000 because it can never be found there.
    So using page 500 as reference, we can open to about half of the pages that lay
    between the 1st and 500th page. That brings us closer to finding the 250th page.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要找到一本1000页书的中间页。我们已经知道每本书的页码都是按顺序从1往上编号的。所以可以推断出第500页应该正好在书的中间，而不是从第1页、第2页翻到第500页。假设我们现在要找第250页。我们仍然可以使用我们的策略轻松地找到页面。我们猜测第500页将书分成两半。第250页将位于书的左侧。无需担心是否能在第500页和第1000页之间找到第250页，因为那里永远找不到。所以以第500页为参考，我们可以打开到大约位于第1页和第500页之间的半数页面。这使我们更接近找到第250页。
- en: 'The following is the algorithm for conducting a binary search on an ordered
    list of items:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对有序项目列表进行二分搜索的算法：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s assume we have to find the position where the item **10** is located
    in the list as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须找到列表中项目**10**的位置如下：
- en: '![](img/image_09_004.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_004.jpg)'
- en: The algorithm uses a `while` loop to iteratively adjust the limits in the list
    within which to find a search term. So far as the difference between the starting
    index, `index_of_first_element` and the `index_of_last_element` index is positive,
    the `while` loop will run.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 算法使用`while`循环来迭代调整列表中的限制，以在其中找到搜索词。只要起始索引`index_of_first_element`和`index_of_last_element`索引之间的差值为正，`while`循环就会运行。
- en: The algorithm first finds the mid point of the list by adding the index of the
    first element (**0**) to that of the last (**4**) and dividing it by **2** to
    find the middle index, `mid_point`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 算法首先通过将第一个元素的索引（**0**）与最后一个元素的索引（**4**）相加，然后除以**2**来找到中间索引`mid_point`。
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this case, **10** is not found at the middle position or index in the list.
    If we were searching for **120**, we would have had to adjust the `index_of_first_element`
    to `mid_point +1`. But because **10** lies on the other side of the list, we adjust
    `index_of_last_element` to `mid_point-1`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**10**没有在列表的中间位置或索引处找到。如果我们正在寻找**120**，我们就必须将`index_of_first_element`调整为`mid_point
    +1`。但由于**10**位于列表的另一侧，我们将`index_of_last_element`调整为`mid_point-1`：
- en: '![](img/image_09_005.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_005.jpg)'
- en: With our new index of `index_of_first_element` and `index_of_last_element` now
    being **0** and **1** respectively, we compute the mid `(0 + 1)/2`, which equals
    `0`. The new midpoint is **0** , We find the middle item and compare with the
    search item, `ordered_list[0]` which yields the value **10**. Voila! Our search
    term is found.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们新的索引`index_of_first_element`和`index_of_last_element`分别是**0**和**1**，我们计算中点`(0
    + 1)/2`，等于**0**。新的中点是**0**，我们找到中间的项目并与搜索项`ordered_list[0]`进行比较，其值为**10**。哇！我们的搜索词找到了。
- en: This reduction of our list size by half, by re-adjusting the index of the `index_of_first_element`
    and `index_of_last_element` continues as long as `index_of_first_element` is less
    than `index_of_last_element`. When this fails to be the case it is most likely
    that our search term is not in the list.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重新调整 `index_of_first_element` 和 `index_of_last_element` 的索引，我们的列表大小减半，只要 `index_of_first_element`
    小于 `index_of_last_element`，这个过程就会继续。当这种情况不再成立时，最可能的情况是我们的搜索词不在列表中。
- en: The implementation here is an iterative one. We can also develop a recursive
    variant of the algorithm by applying the same principle of shifting the pointers
    that mark the beginning and ending of the search list.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的实现是迭代的。我们也可以通过应用相同的原理，即移动标记搜索列表开始和结束的指针，来开发算法的递归变体。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A call to this recursive implementation of the binary search algorithm and
    its output is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个二分查找算法递归实现的调用及其输出如下：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There only distinction between the recursive binary search and the iterative
    binary search is the function definition and also the way in which `mid_point`
    is calculated. The calculation for the `mid_point` after the `((last_element_index
    - first_element_index) / 2)` operation must add its result to `first_element_index`.
    That way we define the portion of the list to attempt the search.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 递归二分查找和迭代二分查找之间唯一的区别是函数定义以及 `mid_point` 的计算方式。在 `((last_element_index - first_element_index)
    / 2)` 操作之后的 `mid_point` 计算必须将结果加到 `first_element_index` 上。这样我们就定义了尝试搜索的列表部分。
- en: The binary search algorithm has a worst time complexity of `O(log n)`. The half-ing
    of the list on each iteration follows a log n of the number of elements progression.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找算法的最坏时间复杂度为 `O(log n)`。每次迭代中对列表的减半遵循元素数量的 log n 进程。
- en: It goes without saying that in `log x` is assumed to be referring to log base
    2.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，`log x` 是指以 2 为底的对数。
- en: Interpolation search
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值搜索
- en: There is another variant of the binary search algorithm that may closely be
    said to mimic more, how humans perform search on any list of items. It is still
    based off trying to make a good guess of where in a sorted list of items, a search
    item is likely to be found.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找算法还有一种变体，可以更接近地说是模仿人类在任意项目列表上执行搜索的方式。它仍然基于尝试对排序列表中搜索项可能被找到的位置进行良好猜测。
- en: 'Examine the following list of items for example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，检查以下项目列表：
- en: '![](img/image_09_006.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_006.jpg)'
- en: To find **120**, we know to look at the right hand portion of the list. Our
    initial treatment of binary search would typically examine the middle element
    first in order to determine if it matches the search term.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到 **120**，我们知道要查看列表的右侧部分。我们最初的二分查找处理通常会首先检查中间元素，以确定它是否与搜索词匹配。
- en: 'A more human thing would be to pick a middle element in a such a way as to
    not only split the array in half but to get as close as possible to the search
    term. The middle position was calculated for using the following rule:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 更符合人类做法的是，选择一个中间元素，不仅要将数组分成两半，还要尽可能接近搜索词。中间位置的计算遵循以下规则：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We shall replace this formula with a better one that brings us close to the
    search term. `mid_point` will receive the return value of the `nearest_mid` function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用更好的公式替换这个公式，使其接近搜索词。`mid_point` 将接收 `nearest_mid` 函数的返回值。
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `nearest_mid` function takes as arguments, the list on which to perform
    the search. The `lower_bound_index` and `upper_bound_index` parameters represent
    the bounds in the list within which we are hoping to find the search term. `search_value`
    represents the value being searched for.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`nearest_mid` 函数接受要执行搜索的列表作为参数。`lower_bound_index` 和 `upper_bound_index` 参数表示列表中我们希望找到搜索词的界限。`search_value`
    表示要搜索的值。'
- en: 'These are used in the formula:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用于以下公式：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Given our search list, **44**, **60**, **75**, **100**, **120**, **230** and
    **250**, the `nearest_mid` will be computed with the following values:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 给定我们的搜索列表 **44**、**60**、**75**、**100**、**120**、**230** 和 **250**，`nearest_mid`
    将使用以下值进行计算：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It can now be seen that, the `mid_point` will receive the value **5**, which
    is the index of the location of our search term. A binary search would have chosen
    **100** as the mid which will require another run of the algorithm.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以看出，`mid_point` 将接收值为 **5**，这是我们的搜索词位置的索引。二分查找会选择 **100** 作为中间值，这将需要算法的另一次运行。
- en: 'A more visual illustration of how a typical binary search differs from an interpolation
    is given as follows. For a typical binary search finds the midpoint like so:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面给出了一个更直观的说明，说明了典型的二分搜索与插值之间的区别。对于典型的二分搜索，找到中点的方式如下：
- en: '![](img/image_09_007.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_007.jpg)'
- en: One can see that the midpoint is actually standing approximately in the middle
    of the preceding list. This is as a result of dividing by list 2.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，中点实际上位于前一个列表的中间位置。这是由于除以列表2的结果。
- en: 'An interpolation search on the other hand would move like so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，插值搜索将移动如下：
- en: '![](img/image_09_008.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_008.jpg)'
- en: In interpolation search, our midpoint is swayed more to the left or right. This
    is caused by the effect of the multiplier used when dividing to obtain the midpoint.
    From the preceding image, our midpoint has been skewed to the right.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在插值搜索中，我们的中点更偏向左边或右边。这是由于在除以获取中点时使用的乘数效应造成的。从前面的图像中，我们可以看到中点已经偏向右边。
- en: The remainder of the interpolation algorithm remains the same as that of the
    binary search except for the way the mid position is calculated for.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 插值算法的其余部分与二分搜索相同，只是计算中点位置的方式不同。
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `nearest_mid` function makes use of a multiplication operation. This can
    produce values that are greater than the `upper_bound_index` or lower than the
    `lower_bound_index`. When this occurs, it means the search term, `term`, is not
    in the list. `None` is therefore returned to represent this.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`nearest_mid`函数使用乘法运算。这可能会产生大于`upper_bound_index`或小于`lower_bound_index`的值。当这种情况发生时，这意味着搜索项`term`不在列表中。因此返回`None`来表示这一点。'
- en: So what happens when `ordered_list[mid_point]` does not equal the search them?
    Well, we must now re-adjust the `index_of_first_element` and `index_of_last_element`
    such that the algorithm will focus on the part of the array that is likely to
    contain the search term. This is like exactly what we did in the binary search.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当`ordered_list[mid_point]`不等于搜索项时会发生什么？嗯，我们现在必须重新调整`index_of_first_element`和`index_of_last_element`，以便算法将关注可能包含搜索项的数组部分。这就像我们在二分搜索中所做的那样。
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the search term is greater than the value stored at `ordered_list[mid_point]`,
    then we only adjust the `index_of_first_element` variable to point to the index
    `mid_point + 1`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果搜索项大于`ordered_list[mid_point]`存储的值，那么我们只调整`index_of_first_element`变量，使其指向`mid_point
    + 1`的索引。
- en: The following image shows how the adjustment occurs. The `index_of_first_element`
    is adjusted and pointed to the index of `mid_point+1.`
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图像显示了调整发生的方式。`index_of_first_element`被调整并指向`mid_point+1`的索引。
- en: '![](img/image_09_009.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_009.jpg)'
- en: The image only illustrates the adjustment of the midpoint. In interpolation
    rarely does the midpoint divide the list in 2 equal halves.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图像仅说明了中点的调整。在插值中，中点很少将列表分成两个相等的部分。
- en: On the other hand, if the search term is lesser than the value stored at `ordered_list[mid_point]`,
    then we only adjust the `index_of_last_element` variable to point to the index
    `mid_point - 1`. This logic is captured in the else part of the if statement `index_of_last_element
    = mid_point - 1`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果搜索项小于`ordered_list[mid_point]`存储的值，那么我们只调整`index_of_last_element`变量，使其指向`mid_point
    - 1`的索引。这个逻辑被if语句的else部分所捕获`index_of_last_element = mid_point - 1`。
- en: '![](img/image_09_010.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_010.jpg)'
- en: The image shows the effect of the recalculation of `index_of_last_element` on
    the position of the midpoint.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图像显示了重新计算`index_of_last_element`对中点位置的影响。
- en: Let's use a more practical example to understand the inner workings of both
    the binary search and interpolation algorithms.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个更实际的例子来理解二分搜索和插值算法的内部工作原理。
- en: 'Take the list with elements:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑具有以下元素的列表：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At index 0 is stored 2 and at index 7 is found the value 77\. Now, assume that
    we want to find the element 2 in the list. How will the two different algorithms
    go about it?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引0处存储了2，在索引7处找到了值77。现在，假设我们想要在列表中找到元素2。两种不同的算法将如何进行？
- en: If we pass this list to the interpolation `search` function, the `nearest_mid`
    function will return a value equal to `0`. Just by one comparison, we would have
    found the search term.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此列表传递给插值`search`函数，`nearest_mid`函数将返回一个等于`0`的值。仅通过一次比较，我们就能找到搜索项。
- en: 'On the other hand, the binary search algorithm would need three comparisons
    to arrive at the search term as illustrated in the following image:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，二分搜索算法需要三次比较才能到达搜索项，如下面的图像所示：
- en: '![](img/CH_09_01.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/CH_09_01.png)'
- en: The first `mid_point` calculated is `3`. The second `mid_point` is `1` and the
    last `mid_point` where the search term is found is `0`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 计算的第一个`mid_point`是`3`。第二个`mid_point`是`1`，最后一个找到搜索项的`mid_point`是`0`。
- en: Choosing a search algorithm
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择搜索算法
- en: The binary search and interpolation search operations are better in performance
    than both ordered and unordered linear search functions. Because of the sequential
    probing of elements in the list to find the search term, ordered and unordered
    linear search have a time complexity of `O(n)`. This gives very poor performance
    when the list is large.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找和插值搜索操作在性能上优于有序和无序线性搜索函数。由于在列表中按顺序探测元素以找到搜索项，有序和无序线性搜索的时间复杂度为`O(n)`。当列表很大时，这会导致非常差的表现。
- en: The binary search operation on the other hand, slices the list in two, anytime
    a search is attempted. On each iteration, we approach the search term much faster
    than in a linear strategy. The time complexity yields `O(log n)`. Despite the
    speed gain in using binary search, it is most it can not be used on an unsorted
    list of items neither is it advised to be used for list of small sizes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，二分查找操作在每次搜索尝试时将列表分成两半。在每次迭代中，我们比线性策略更快地接近搜索项。时间复杂度为`O(log n)`。尽管使用二分查找可以获得速度提升，但它不能用于未排序的项目列表，也不建议用于小尺寸的列表。
- en: The ability to get to the portion of the list that houses a search term determines
    to a large extent, how well a search algorithm will perform. In the interpolation
    search algorithm, the mid is calculated for which gives a higher probability of
    obtaining our search term. The time complexity of the interpolation search is
    `O( log ( log n))`. This gives rise to a faster search compared to its variant,
    binary search.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 能够到达包含搜索项的列表部分在很大程度上决定了搜索算法的性能。在插值搜索算法中，计算中间值，这提高了获得搜索项的概率。插值搜索的时间复杂度为`O(log(log
    n))`。这使得搜索速度比其变体二分搜索更快。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have examined two breeds of search algorithms. The implementation
    of both linear and binary search algorithms have been discussed and their comparisons
    drawn. The binary search variant, interpolation search has also been treated in
    this section. Knowing which kind of search operation to use will be relevant in
    subsequent chapters.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们考察了两种搜索算法。讨论了线性搜索和二分搜索算法的实现，并进行了比较。本节还介绍了二分搜索的变体，插值搜索。了解使用哪种搜索操作将在后续章节中变得相关。
- en: In our next chapter, we shall use the knowledge that we have gained to enable
    us perform sorting operations on a list of items.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用我们所获得的知识来使我们能够在项目列表上执行排序操作。
