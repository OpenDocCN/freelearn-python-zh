- en: Chapter 4. Drops, Hideouts, Meetups, and Lairs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll extend some of the techniques introduced in [Chapter 2](ch02.html "Chapter 2. Acquiring
    Intelligence Data"), *Acquiring Intelligence Data*, to make RESTful web service
    requests for geocoding. This will allow us to pinpoint various kinds of secret
    locations. This will also build on image location processing from [Chapter 3](ch03.html
    "Chapter 3. Encoding Secret Messages with Steganography"), *Encoding Secret Messages
    with Steganography*.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at some online datasets that will lead us to more techniques in
    data gathering. In order to work with a wide variety of data, we will need to
    add an HTML parser to our toolkit. We'll download BeautifulSoup, since it's very
    good at tracking down the information buried in HTML pages.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll also look at some more sophisticated Python algorithms.
    We'll start with geocoding services to translate address and latitude-longitude
    coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at the **haversine** formula to compute distances between locations.
    This will mean using the `math` library to access trigonometric functions.
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn about the various kinds of grid coding schemes, which will help
    us reduce the complexity of latitude and longitude. These coding schemes will
    show us a number of data representation techniques. This chapter will show ways
    to compress numbers via a change in representation.
  prefs: []
  type: TYPE_NORMAL
- en: We'll see ways to parse HTML `<table>` tags and create Python collections that
    we can work with. We'll also look at online data sources that provide clean data
    in the JSON format. This can be easier to gather and work with.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to use Python to combine multiple online services. This will allow
    us to integrate geocoding and data analysis. With that information, we can locate
    the best place to meet our contacts without traveling too far from our secret
    base of operations.
  prefs: []
  type: TYPE_NORMAL
- en: Background briefing – latitude, longitude, and GPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can get geographic information, we'll need to review some essential
    terminology. One powerful piece of modern technology that helps civilians as well
    as secret agents is the **Global Positioning System** (**GPS**), a satellite-based
    system to determine location. The GPS allows a terrestrial device to pinpoint
    its location in both space and time.
  prefs: []
  type: TYPE_NORMAL
- en: The idea underlying GPS is quite elegant. Each satellite produces a stream of
    data that includes position and super accurate timestamps. A receiver with multiple
    streams of data can plug the positions and timestamps into a matrix of simultaneous
    equations to determine the receiver's position with respect to the various satellites.
    Given enough satellites, a receiver can precisely calculate latitude, longitude,
    elevation, and even the current time.
  prefs: []
  type: TYPE_NORMAL
- en: For more information see [http://en.wikipedia.org/wiki/Global_Positioning_System#Navigation_equations](http://en.wikipedia.org/wiki/Global_Positioning_System#Navigation_equations).
  prefs: []
  type: TYPE_NORMAL
- en: 'A position''s latitude is an angle measured relative to the equator and poles.
    We must provide the direction for this angle: N or S for latitude. For example,
    36°50′40.12″N is given in degrees (°), minutes (′), and seconds (″) with the all-important
    N to show which side of the equator the position is on.'
  prefs: []
  type: TYPE_NORMAL
- en: We can also state latitude as 36°50.6687′N using degrees and minutes; or, we
    could use 36.844478, known as using decimal degrees. Directions toward the north
    are written in positive angles. Directions to the south are negative. The underlying
    `math` library works in radians, but radians are not widely used to display positions
    to humans.
  prefs: []
  type: TYPE_NORMAL
- en: Longitude is an angle east of the **prime meridian** or the **Greenwich meridian**.
    Angles to the west of Greenwich are stated as negative numbers. Consequently,
    76°17′35.21″W can also be stated as -76.293114.
  prefs: []
  type: TYPE_NORMAL
- en: When we look at a globe, we notice that the latitude lines are all parallel
    with the equator. Each degree of latitude is about 60 nautical miles in the north-south
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: The longitude lines, however, all intersect at the north and south pole. Those
    north-south lines are not parallel. On a map or a nautical chart, however, a distortion
    (actually known as a **projection**) is used so that the longitude lines are parallel
    to each other. With our usual experience of driving short distances on land, the
    distortion doesn't matter much, since we're often constrained to driving on highways
    that wander around rivers and mountains. What's important is that the rectangular
    grid of a map is handy, but misleading. Simple analytical plane geometry isn't
    appropriate. Hence, we have to switch to spherical geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Coping with GPS device limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A GPS receiver needs to receive data from a number of satellites concurrently;
    a minimum of three satellites can be used for triangulation. There may be interference
    with microwave signals indoors, and even outdoors in urban environments, making
    it difficult (or impossible) to get enough data to properly compute the receiver's
    location. Tall buildings and other obstructions such as walls, prevent the direct
    signal access needed for accuracy. It may take a long time to acquire enough high-quality
    satellite signals to compute a position.
  prefs: []
  type: TYPE_NORMAL
- en: A common workaround to the satellite visibility problem is to rely on cellular
    telephone towers as a way to compute a position very quickly even without GPS
    satellite data. A phone which is in contact with several cell towers can have
    the position triangulated based on the overlapping transmission patterns. In many
    telephone devices, the GPS calculation requires local cellphone towers before
    it can calculate a GPS position.
  prefs: []
  type: TYPE_NORMAL
- en: There are many non-phone GPS devices that can be directly connected to a computer
    to get accurate GPS fixes without relying on cellular data. Navigation computers
    (mariners call them **chart plotters**) work without the need to connect to a
    cellular network. In many cases, we can use modules such as `pyserial` to extract
    data from these devices.
  prefs: []
  type: TYPE_NORMAL
- en: See [http://pyserial.sourceforge.net](http://pyserial.sourceforge.net) for more
    information on the pySerial project and how we can use this read data from a GPS
    device via a serial to a USB adapter.
  prefs: []
  type: TYPE_NORMAL
- en: Handling politics – borders, precincts, jurisdictions, and neighborhoods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Borders create endless problems—some profound, some subtle. The entire sweep
    of human history seems to center on borders and wars. The edges of neighborhoods
    are often subjective. In an urban environment, a block or two may not matter much
    when discussing the difference between Los Feliz and East Hollywood. On the other
    hand, this kind of knowledge is what defines the *local* restaurants as recognized
    by people who live there.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to more formal definitions—such as election districts at city,
    state, and federal levels—the side of the street may have profound implications.
    In some cities, this political division information is readily available via RESTful
    web service requests. In other locales, this information is buried in a drawer
    somewhere, or published in some kind of hard-to-process PDF document.
  prefs: []
  type: TYPE_NORMAL
- en: Some media companies provide neighborhood information. The LA Times Data Desk,
    for example, has a fairly rigorous definition of the various neighborhoods around
    the greater Los Angeles area. For excellent background information on how to work
    with this kind of information, see [http://www.latimes.com/local/datadesk/](http://www.latimes.com/local/datadesk/).
  prefs: []
  type: TYPE_NORMAL
- en: Finding out where we are with geocoding services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use some geocoding services to get answers to the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What's the latitude and longitude of a given street address? This is called
    address geocoding or simply geocoding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which street address is closest to a given latitude and longitude? This is called
    reverse geocoding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are, of course, many more questions we could ask. We might want to know
    a route to navigate between two addresses. We might want to know what public transportation
    choices we have to get from one place to another. For now, we'll limit ourselves
    to these two essential geocoding questions.
  prefs: []
  type: TYPE_NORMAL
- en: There are many geocoding services available on the World wide web (WWW). There
    are a number of terms related to geocoding, including geomarketing, geo targeting,
    geolocation, and geotagging. They're all essentially similar; they depict location-based
    information. It can take a fair amount of espionage to track down a service with
    the features we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following link gives a list of services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://geoservices.tamu.edu/Services/Geocode/OtherGeocoders/](http://geoservices.tamu.edu/Services/Geocode/OtherGeocoders/)'
  prefs: []
  type: TYPE_NORMAL
- en: This list is far from definitive. Some of the services listed here don't work
    very well. Some large companies aren't listed; for example, MapQuest appears to
    be missing. See [http://mapquest.com](http://mapquest.com) for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Most geocoding services want to track usage. For large batches of requests,
    they want to be paid for the services they offer. Consequently, they issue credentials
    (a key) that must be part of every request. The procedure to get a key varies
    from service to service.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look closely at the services offered by Google. They offer a limited service
    without the overhead of requesting credentials. Instead of asking us to get a
    key, they'll throttle our requests if we make too much use of their service.
  prefs: []
  type: TYPE_NORMAL
- en: Geocoding an address
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The forward geocoding service from address to latitude and longitude can be
    accessed via Python's `urllib.request` module. For a quick review, see the *Using
    a REST API in Python* section of [Chapter 2](ch02.html "Chapter 2. Acquiring Intelligence
    Data"), *Acquiring Intelligence Data*. This is usually a three-step process.
  prefs: []
  type: TYPE_NORMAL
- en: Define the parts of the URL. It helps to separate the static portions from the
    dynamic query portion. We need to use the `urllib.parse.urlencode()` function
    to encode the query string.
  prefs: []
  type: TYPE_NORMAL
- en: Open the URL using a `with` statement context. This will send the request and
    get the response. The JSON document must be parsed in this `with` context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Process the object that was received. This is done outside the `with` context.
    Here''s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a dictionary with the two required fields: `address` and `sensor`.
    If you want to sign up with Google for additional support and higher-volume requests,
    you can get an API key. It will become a third field in the request dictionary.
    We used a `#` comment to include a reminder about the use of the key item.'
  prefs: []
  type: TYPE_NORMAL
- en: An HTML web page form is essentially this kind of dictionary with names and
    values. When the browser makes a request, the form is encoded before it is transmitted
    to the web server. Our Python program does this using `urllib.parse.urlencode()`
    to encode the form data into something that a web server can use.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Google requires us to use the `safe=","` parameter. This assures us that the
    `","` characters in the address will be preserved instead of being rewritten as
    `"%2C"`.
  prefs: []
  type: TYPE_NORMAL
- en: A complete URL has a scheme, location, path, and an optional query. The scheme,
    location, and path tend to remain fixed. We assembled a complete URL from the
    fixed portions and the dynamic query content, printed it, and also used it as
    an argument to the `urllib.request.urlopen()` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the `with` statement, we created a processing context. This will send the
    request and read the response. Inside the `with` context, we printed the headers
    to confirm that the request worked. More importantly, we loaded the JSON response,
    which will create a Python object. We saved that object in the `response` variable.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the Python object, we can release the resources tied up in making
    the geocoding request. Leaving the indented block of the `with` statement assures
    that all the resources are released and the file-like response is closed.
  prefs: []
  type: TYPE_NORMAL
- en: After the `with` context, we can work with the response. In this case, we merely
    print the object. Later, we'll do more with the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll see three things, as shown in the following snippet—the URL that we
    built, headers from the HTTP response, and finally the geocoding output as a JSON-formatted
    document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The JSON document can be loaded using the `json` module. This will create a
    dictionary with two keys: `results` and `status`. In our example, we loaded the
    dictionary into a variable named `response`. The value of `response[''results'']`
    is a list of dictionaries. Since we only requested one address, we only expect
    one element in this list. Most of what we want, then, is in `response[''results''][0]`.'
  prefs: []
  type: TYPE_NORMAL
- en: When we examine that structure, we find a subdictionary with four keys. Of those,
    the `'geometry'` key has the geocoding latitude and longitude information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend this script to access the location details using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides us with a small dictionary that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is what we wanted to know about the street address.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as a purely technical note on the Python language, we included `#` comments
    to show the important steps in our algorithm. A comment starts with `#` and goes
    to the end of the line. In this example, the comments are on the lines by themselves.
    In general, they can be placed at the end of any line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we called this out with a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The form dictionary has two keys. A third key can be added by removing the `#`
    comment indicator and filling in the API key that Google has supplied.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse geocoding a latitude-longitude point
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The reverse geocoding service locates nearby addresses from a latitude and
    longitude position. This kind of query involves a certain amount of inherent ambiguity.
    A point that''s midway between two large buildings, for example, could be associated
    with either or both buildings. Also, we might be interested in different levels
    of details: rather than a street address, we may only wish to know the state or
    country for a particular position.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what this web service request looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The form has two required fields: `latlng` and `sensor`.'
  prefs: []
  type: TYPE_NORMAL
- en: Signing up with Google for additional support and higher-volume requests requires
    an API key. It would become a third field in the request form; we have left a
    `#` comment in the code as a reminder.
  prefs: []
  type: TYPE_NORMAL
- en: We encoded the form data and assigned it to the `query` variable. The `safe=","`
    parameter assures us that the `","` characters in the latitude-longitude pair
    will be preserved instead of being rewritten into a `%2C` escape code.
  prefs: []
  type: TYPE_NORMAL
- en: We assembled a complete address from the fixed portions of the URL (the scheme,
    net location, and path) plus the dynamic query content. The scheme, location,
    and path are generally fixed. The query is encoded from the form data.
  prefs: []
  type: TYPE_NORMAL
- en: In the `with` statement, we created a processing context to send the request
    and read the response. Inside the `with` context, we displayed the headers and
    loaded the resulting JSON document, creating a Python object. Once we have the
    Python object, we can exit the processing context and release the resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response is a Python dictionary. There are two keys: `''results''` and
    `''status''`. The value of `response[''results'']` is a list of dictionaries.
    There are a number of alternative addresses in the `results` list. Each result
    is a dictionary with two interesting keys: the `''types''` key, which shows the
    type of address and the `''formatted_address''` key, which is a well-formatted
    address close to the given location.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the alternatives shows a hierarchy of nested political containers for
    the address: postal code, locality, state (called `administrative_area_level_1`),
    and country.'
  prefs: []
  type: TYPE_NORMAL
- en: How close? What direction?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to calculate the distance between two points, we'll need to use some
    spherical geometry calculations. The problem we will have to overcome is that
    our charts and maps are flat. But the actual planet is very close to being spherical.
    While the spherical geometry may be a bit advanced, the programming is pretty
    simple. It will show us several features of the Python `math` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The distance between two latitude and longitude points on a sphere is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How close? What direction?](img/0420OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This formula determines the cosine between the two positions; the angle with
    that cosine is multiplied by the radius of the earth, R, to get the distance along
    the surface. We can use R = 3,440 NM, R = 3,959 mi, or R = 6,371 km; we get reasonably
    accurate distances in nautical miles, statute miles, or kilometers.
  prefs: []
  type: TYPE_NORMAL
- en: This formula doesn't work well with small distances. The haversine formula is
    preferred to compute distances more accurately. Here is some background information
    [http://en.wikipedia.org/wiki/Haversine_formula](http://en.wikipedia.org/wiki/Haversine_formula).
  prefs: []
  type: TYPE_NORMAL
- en: According to the OED, the term "haversine" was coined in 1835 by Prof. James
    Inman. The term refers to the way the sine function is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The haversine calculation is often shown as a sequence of five steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How close? What direction?](img/0420OS_04_02.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_IMG
- en: '![How close? What direction?](img/0420OS_04_03.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_IMG
- en: '![How close? What direction?](img/0420OS_04_04.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_IMG
- en: '![How close? What direction?](img/0420OS_04_05.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_IMG
- en: '![How close? What direction?](img/0420OS_04_06.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_IMG
- en: The required sine, cosine, and square root portions of this are part of Python's
    `math` library. When we look at the definitions of sine and cosine, we see that
    they work in radians. We'll need to convert our latitude and longitude values
    from degrees to radians. The rule is simple (![How close? What direction?](img/0420OS_04_07.jpg)),
    but the `math` library includes a function, `radians()`, which will do this for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: We can look at [http://rosettacode.org/wiki/Haversine_formula#Python](http://rosettacode.org/wiki/Haversine_formula#Python)
    to learn from the example already there.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use this as the distance between two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We've imported the five functions from the `math` library that we require for
    this calculation.
  prefs: []
  type: TYPE_NORMAL
- en: We've defined three constants with the earth's radius in various units. We can
    plug any of these into our `haversine()` function as the `R` parameter to compute
    distances in different units. These values are approximations, but they'll work
    to determine how far apart two points are. We can plug in more accurate values
    if we want more precise answers. Since the earth isn't perfectly spherical, we
    have to be sure to use mean radius values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `haversine()` function will accept two required positional parameters and
    an optional parameter. The two positional parameters will be two-tuples of latitude
    and longitude. We''d like to use a syntax like `(36.12, -86.67)` to keep the two
    coordinates bound in a single Python value. The `R` parameter is optional because
    we''ve provided a default value for it. We can use this function to get distances
    in kilometers instead of in miles: `haversine( (36.12, -86.67), (33.94, -118.40),
    R=KM)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The body of our function breaks down the two-tuples into their component latitude
    and longitude values. We compute the `Δ_lat` variable by subtracting and converting
    the result to radians. Similarly, we compute the `Δ_lon` variable by subtracting
    and converting the result to radians. And yes variable names which begin with
    the Greek Δ character are perfectly valid in Python. After this, we can also convert
    the other two latitudes to radians. We can then plug these values to other formulae
    to compute `a`, `c`, and finally the distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a test case based on the example from the Rosetta Code website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that we rounded the answer to five decimal places. Floating-point numbers
    are an approximation; it's possible to see some variations between hardware and
    OS in precisely how floating-point numbers work. By limiting ourselves to five
    decimal places, we're confident that variations in hardware won't upset the test
    case.
  prefs: []
  type: TYPE_NORMAL
- en: We can use this `haversine()` function with our geocode results to compute distances
    between locations; this will help us find the closest locations.
  prefs: []
  type: TYPE_NORMAL
- en: Combining geocoding and haversine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Between geocoding and the `haversine()` function, we have the tools to compute
    the approximate distance between addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take 333 Waterside, Norfolk, Virginia, as our current base of operations.
    Let's say our informant wants to meet either at 456 Granby or 111 W Tazewell.
    Which one is closer?
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll need to clean up our geocoding script to make it a usable function.
    Rather than simply printing a result, we'll need to get the values out of the
    results dictionary to make a sequence of the two-tuples of the latitude and longitude
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we''ll need to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We've used two generator expressions to dismantle the results. The first generator
    expression took the location information from each alternative in the `response['results']`
    sequence. For geocoding, there should only be one expression, but it's simpler
    if we pretend we'll get multiple responses.
  prefs: []
  type: TYPE_NORMAL
- en: The second generator expression turned the `'lat'` and `'lng'` elements of the
    location dictionary into a two-tuple. Having latitude and longitude two-tuples
    will play well with our `havesine()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can get three latitude-longitude pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We've applied our `geocode()` function to get a list of two-tuples and then
    used `[0]` to pick the first element from each response list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can report the distances from the base to each location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We applied our `haversine()` function to compute distances. By default, the
    distances are in miles, not that the units matter to carry out a relative comparison
    of closer versus further away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the second location (`Loc2`), the Tazewell address, is much
    closer to our base than the Granby street address.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can see that we need to format these numbers to make them look better.
    Since we're only working with an approximate mean earth radius in miles, most
    of those decimal places are just visual noise.
  prefs: []
  type: TYPE_NORMAL
- en: Compressing data to make grid codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Latitudes and longitudes are bulky to transmit. They have a lot of digits and
    some peculiar punctuation. Over the years, some alternatives have risen that abbreviate
    a location using a simpler notation. The essential idea is to convert latitude
    and longitude numbers from their degree-minute-second numbers into a sequence
    of letters and digits that represent the same information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at three compression schemes: the GeoRef system, the Maindenhead
    Locator, and NAC. Each of these encodings involves doing some arithmetic calculations
    to convert numbers from decimal (base 10) to another base. We''ll also use a number
    of string operations to translate numbers to characters and characters to numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting programming issue is that these encodings don''t work directly
    with latitudes and longitudes. The problem with simply using latitudes and longitudes
    is that they''re signed numbers: -90 (S) to +90 (N) and -180 (W) to +180 (E).
    Also, longitudes have a bigger range (360 values), whereas latitudes have a smaller
    range (180 values). To simplify the encoding, we''ll apply a common programming
    hack: we''ll offset and scale the values. We''ll see a number of ways to apply
    this clever technique.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In effect, the scaling and offsetting moves the map''s (0, 0) origin to somewhere
    in Antarctica: at the south pole and right on 180° longitude. The center of these
    grid maps is somewhere off the coast of West Africa, and the upper-right corner
    will wind up in the Bering Sea, right at the north pole and next to the 180° longitude.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating GeoRef codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GeoRef system compresses a latitude-longitude position using four letters
    and as many as eight digits. This system can also be used to encode descriptions
    of regions as well as altitudes. We'll stick with locations on the surface.
  prefs: []
  type: TYPE_NORMAL
- en: For some background information, see [http://en.wikipedia.org/wiki/Georef](http://en.wikipedia.org/wiki/Georef).
  prefs: []
  type: TYPE_NORMAL
- en: 'This system encodes decimal numbers using 24-letter codes chosen from A to
    Z, omitting I and O. This means that we can''t simply rely on a handy copy of
    the alphabet such as `string.ascii_uppercase` to provide the letter codes. We''ll
    have to define our own GeoRef letters. We can compute the letters with an expression
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The GeoRef codes slice the world map into a 12 x 24 grid of 15° x 15° quadrangles.
    The latitude is measured in positive numbers from the South Pole. The longitude
    is measured in positive numbers from the International Date Line. When we divide
    180° of latitude into 15° steps, we can encode a part of this three-digit number
    using 12 letters from A to M (omitting I). When we divide 360° of longitude into
    15° steps, we can encode a part of this three-digit number using 24 letters from
    A to Z (omitting I and O).
  prefs: []
  type: TYPE_NORMAL
- en: We can then divide each 15° quadrangles into 15 bands using letters A to Q (again,
    skipping I and O). This creates a four- character code for the entire degrees
    portion of a latitude and longitude position.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had a latitude of 38°17′10″N, we''d offset this to be 128° north of the
    south pole and divide it by 15°:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These values are encoded as J and J.
  prefs: []
  type: TYPE_NORMAL
- en: 'A longitude of 76°24′42″W is encoded as shown in the following code. This is
    -76.41167°, which we offset by 180° before using `divmod` to calculate the two
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This gives us letters G and P. We interleave longitude and latitude characters
    so that the whole string is GJPJ. We've encoded six digits of latitude and longitude
    into four characters.
  prefs: []
  type: TYPE_NORMAL
- en: The leftover minutes and seconds can be encoded as two, three, or four digits.
    For the latitude, 17′10″ can be encoded as 17.16 minutes. This is 17, an intermediate
    171, or a detailed 1716.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the entire encoder the for GeoRef codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We offset the latitudes and longitudes so that we don't have to deal with signed
    numbers. We used the `divmod()` function to divide by 15° and get both a quotient
    and a remainder. We can then use our `georef_uppercase` letters to translate the
    numeric quotients and remainders into expected character codes.
  prefs: []
  type: TYPE_NORMAL
- en: The fractional values, for example, `f_lat-int(f_lat)`, are scaled by 6000 to
    create a number between 0000 and 5999, which is simply the number of minutes in
    100ths.
  prefs: []
  type: TYPE_NORMAL
- en: We've used the string `format()` method to assemble the four-character codes
    and four-digit numeric codes into a single string. The first two letters are longitude
    and latitude to provide a position to the nearest 15°. The next two letters have
    more longitude and latitude details to refine this to the nearest 1°. The digits
    are in two blocks of four to provide the detailed minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a more complete example of the output. We''ll encode 36°50.63′N 076°17.49′W:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve converted degrees and minutes to degrees. Then, we applied our GeoRef
    conversion to the values in degrees. Here''s what the output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The code `GJPG` is an approximation of the given location; it could be off by
    almost 80 nautical miles at the equator. The error gets smaller toward the poles.
    The code `GJPG4250` uses the two-digit encoding of whole minutes to get within
    a few miles of the coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding a GeoRef code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we decode a GeoRef code, we have to separate the two parts: the four characters
    at the beginning and the numeric details at the end. Once we''ve split off the
    first four characters, we can divide the number of remaining characters in half.
    One half of the digits will be longitude and the rest will be latitude.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first four characters must be looked up in our special GeoRef alphabet.
    We''ll find each character''s position in the `ABCDEFGHJKLMNPQRSTUVWXYZ` string
    to get a numeric value. An expression such as `georef_uppercase.find(''Q'')` gives
    us 14: the position of Q in that alphabet. We can then multiply one position by
    15° and add the other position number to translate two characters to the degrees
    portion of GeoRef.'
  prefs: []
  type: TYPE_NORMAL
- en: The remaining digits are simply minutes, which are 1/60 of a degree. During
    conversion there is a matter of creating a number and possibly dividing it by
    10 or 100\. The final step is to take out the offsets that were used to avoid
    signed arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole thing looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This works by separating the first four positions of the code into four longitude
    and latitude characters. Note that the positions are interleaved: longitude first,
    latitude second.'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the string is divided in half. If there are any characters in the
    second half, then the first half (two, three, or four characters) will be longitude
    minutes; the second half will be latitude minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve used a simple literal mapping from the length (two, three, or four)
    to the scaling values (1, 10, and 100). We defined a dictionary with the mapping
    from the position to scale factor and applied the number of positions, `pos`,
    to that dictionary. We could have done this using an arithmetic calculation, too:
    `10**(pos-1)`; this calculation also works to convert `pos` to a power of 10.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take the string of characters, convert them to float and then scale
    them to create a proper value for minutes. Here is an example of what the scaling
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `else` condition handles the case where there are only four positions in
    the grid code. If this is true, then the letters are all we have and the minutes
    will be zero.
  prefs: []
  type: TYPE_NORMAL
- en: We can calculate the offset values using one letter scaled by 15°, the next
    letter scaled by 1°, and the minutes by the 60th of a degree. The final step,
    of course, is to remove the offsets to create the expected signed numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that we use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll see an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We chopped the longer GeoRef down to a 10-digit code. This has two 3-digit encodings
    of the minutes. We have elected to lose some accuracy, but this can also simplify
    the transmission of secret information.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Maidenhead grid codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As compared to relatively simple grid codes covered previously, we have an alternative
    notation called the **Maidenhead system**. This is used by Ham radio operators
    to exchange information about the locations of their stations. Maidenhead is a
    town in England; the Maidenhead code is **IO91PM**.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, see [http://en.wikipedia.org/wiki/Maidenhead_Locator_System](http://en.wikipedia.org/wiki/Maidenhead_Locator_System).
  prefs: []
  type: TYPE_NORMAL
- en: The Maidenhead algorithms involve somewhat more sophisticated math based on
    creating a base 240 representation of the latitude and longitude numbers. We can
    encode each *digit* of a base 240 number using a letter-digit combination. We'll
    show a common technique to convert a floating-point number to an integer using
    a series of steps.
  prefs: []
  type: TYPE_NORMAL
- en: The Maidenhead system slices the world map into a 180 × 180 grid of quadrangles;
    each quadrangle has 1° in the N-S direction and 2° in the E-W direction. We can
    encode these quadrangles using a base 240 numbering system where a letter and
    digit are used to denote each of the digits of the base 240 system. Since the
    grid is only 180×180, we don't need the full range of our base 240 numbers.
  prefs: []
  type: TYPE_NORMAL
- en: To specify a position more accurately, we can slice each cell of the grid into
    240 x 240 smaller cells. This means that an eight-position code gets us within
    .25 nautical miles in the N-S direction and .5 nautical miles in the E-W direction.
    For Ham radio purposes, this may be sufficient. For our address-level geocoding,
    we'll need more accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: We can apply the same letter-number operation a third time, dividing each tiny
    rectangle into 240 even smaller pieces. This gets us more than the accuracy we
    need.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are creating a three-digit number in a 240-number system where each base
    240 digit is represented by a letter-number pair. We''re performing the following
    calculation to create the three digits ![Creating Maidenhead grid codes](img/0420OS_04_08.jpg)
    that encode a number, ![Creating Maidenhead grid codes](img/0420OS_04_09.jpg):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Maidenhead grid codes](img/0420OS_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the whole process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We've defined an internal function, `let_num()`, inside our `ll_2_mh()` function.
    The internal `let_num()` function translates a number in the 0 to 240 range into
    a letter and a digit. It uses the `divmod()` function to decompose the number
    into a quotient from 0 to 24 and a remainder from 0 to 9\. This function then
    uses these two numeric values as indices in the `string.ascii_uppercase` and `string.digits`
    strings to return two characters. Each letter-number pair is a representation
    for a single digit of the base 240 number system. Rather than invent 240-digit
    symbols, we've repurposed a letter-digit pair to write the 240 distinct values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first real step is to convert the raw, signed latitude and longitude to
    our maidenhead grid version. The `f_lat` variable is the original latitude with
    an offset of 90 to make it strictly positive, in the range 0 to 180\. The `f_lon`
    variable is the original longitude offset by 180 and divided by 2 to make it strictly
    positive, in the range 0 to 180\. We created the initial letter-number pairs from
    these initial values of degrees: `f_lat` and `f_lon`.'
  prefs: []
  type: TYPE_NORMAL
- en: This works nicely for degrees. What about the fractions of a degree? Here's
    a common technique to work with representations of floating-point values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use something like `lat-int(lat)`, we''ll compute the fractional portion
    of the latitude. If we scale that by 240, we''ll get a number that we can use
    with `divmod()` to get one of the 240-letter positions and a digit. The expression
    `240*(f_lat-int(f_lat))` will expand the fractional part of `f_lat` to a scale
    of 0 to 240\. Here''s an example of how this scaling works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The original latitude is `36.84383`. The value of `f_lat-int(f_lat)` will be
    the fractional portion of that value, which is `.84383`. We multiply this by `240`
    to get the value, with an approximate result of `202.5192`.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `let_num()` function to create a letter-and-digit pair. The remaining
    fractional value (`0.5192`) can be scaled again by 240 to get yet another letter-and-digit
    pair.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the details have reached the limit of relevance. 1/240/240 of
    a degree is about 6 feet. Most civilian GPS instruments are only accurate to about
    16 feet.
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to interleave longitude and latitude characters. We've done
    this by creating a list of characters in the desired order. The `string.join()`
    method uses the given string as a separator when assembling a list of strings.
    It's common to use `", ".join(some_list)` to create comma-separated items. We
    have used `"".join()` to assemble the final string with no separator characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a more complete example of the output. We''ll encode 36°50.63′N 076°17.49′W:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We converted degrees and minutes to degrees. Then, we applied our Maidenhead
    conversion to the values in degrees. The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can use portions of this to encode with varying degrees of accuracy. `FM16`
    is pretty coarse, whereas `FM16UU` is more accurate.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding the Maidenhead grid codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To decode the Maidenhead codes, we need to reverse the procedure we used to
    create the codes from latitudes and longitudes. We'll need to take all the even
    positions as a sequence of digits to create the longitude and all the odd positions
    as a sequence of digits to create the latitude. By looking up against `string.ascii_uppercase`
    and `string.digits`, we can transform characters into numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a sequence of numbers, we can apply a sequence of weighing factors
    and add up the results. The whole thing looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We used Python's very elegant slice notation to take the string apart into even
    and odd positions. The expression `grid[0::2]` specifies a slice of the `grid`
    string. The `[0::2]` slice starts at position `0`, extends to the very end, and
    increments by `2`. The `[1::2]` slice starts at position `1`, extends to the very
    end, and also increments by `2`.
  prefs: []
  type: TYPE_NORMAL
- en: The `decode` list contains six strings that will be used to translate each character
    into a numeric value. The first character will be found in `string.ascii_uppercase`
    and the second character will be found in `string.digits`. The positions at which
    the characters are found in these strings will become the numeric values that
    we can use to compute latitudes and longitudes.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the value of `'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.find('M')` is `12`.
  prefs: []
  type: TYPE_NORMAL
- en: We've used a generator expression and the `zip()` function to do the real work
    of the translation. The `zip()` function will produce a sequence of pairs; each
    pair will have one character chosen from the input grid code and one lookup string
    chosen from the `decode` lists. We can then use `lookup.find(char.upper())` to
    locate the given character in the given lookup string. The result will be a sequence
    of integer positions.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a sequence of the numeric values, we can apply the sequence of
    weightings to convert each position to a degree or a fraction of a degree. Again,
    we used `zip()` to create two-tuples from the digits and the weights. The generator
    then multiplied the numeric value by the weight. The built-in `sum()` function
    created the final value from the numbers and weights.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we might have a value in the `lons` variable of `[5, 1, 20, 6,
    0, 0]`. The weights are `[10.0, 1.0, 0.0416, 0.00416, 0.00017361, 1.7361e-05]`.
    When we use `zip()` to zip these two sequences, we''ll get pairs like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The products look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The sum is `51.85696`.
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to undo the offsets we used to force the latitudes to be positive
    and the longitudes to have values between 0 and 180 instead of -180 to +180\.
    The intermediate longitude result `51.85696` becomes `-76.28608`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that we evaluate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following decoded positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This nicely decodes the values we encoded in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating natural area codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Natural Area Code** (**NAC**) is yet another way to encode geographic
    position information into a short character string. The whole NAC system can include
    altitude information along with the surface position. We'll focus on the latitude
    and longitude conversions for NAC.
  prefs: []
  type: TYPE_NORMAL
- en: See [http://www.nacgeo.com/nacsite/documents/nac.asp](http://www.nacgeo.com/nacsite/documents/nac.asp),
    for more information
  prefs: []
  type: TYPE_NORMAL
- en: This uses base 30 instead of base 240; we can use most of the alphabets plus
    some digits to represent a single base 30 digit. This implementation will show
    a different approach to convert floating-point numbers to an integer approximation.
    This will combine multiple calculation steps into longer expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'NAC uses a 30-character encoding that employs digits and consonants. The string
    used for encoding and decoding is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can take a longitude (-180 to +180), and add an offset to put it in the range
    of 0 to 360\. If we scale this by `(30**4)/360`, we'll get a number in the range
    0 to 810000\. This can be converted to a four-digit base 30 number.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can take a latitude (-90 to +90), and add an offset to put it
    in the range of 0 to 180\. If we scale this by `(30**4)/180`, similarly, we'll
    get a number that can be converted to a four-digit base 30 number. The big win
    here is that we've replaced long strings of base 10 digits with shorter strings
    of base 30 digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The suggested algorithm to encode this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We've scaled the longitude by adding an offset and dividing it by 360\. This
    creates a number between `0` and `1.0`. We can then encode this into base 30 using
    a large number of multiplications and subtractions. There are a number of ways
    to optimize this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each step follows a similar pattern. We''ll step through the longitude calculation.
    Here''s the first character calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first step computes `f_lon`, the fraction of 360 for this longitude (151.3947W).
    When we multiply `f_lon` by `30`, we get `2.383775`. The integer portion, `2`,
    will become the first character. The fraction will be encoded in the remaining
    three characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the next character, based on the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The calculation of `(f_lon*30-x0)` computes the fraction, `.383775`. We then
    scale this by `30` to get `11.51325`. The integer portion, `11`, will become the
    second character. The fraction will be encoded in the remaining two characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'At each step, we take all of the previous digits to compute the remaining fractional
    components. Here are the last two characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Each of these character, takes the difference between the original number (`f_lon`)
    and the previously computed digits to get the remaining fraction. The final step
    involves a lot of multiplication. Previously, in the *Creating Maidenhead grid
    codes* section, we showed a variation on this theme that didn't use quite so many
    multiplication operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we may perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is a pretty tidy summary of a latitude and longitude.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding natural area codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Decoding natural area codes is actually a conversion from a base 30 number
    to a value between 0 and 810,000\. This is then scaled into a proper latitude
    or longitude value. Although base 30 numbers don''t seem simple, the programming
    is actually pretty succinct. Here''s the suggested algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We've decomposed each part of the nine-character NAC grid code into a longitude
    substring and a latitude substring. We used a generator function to lookup each
    character in our `nac_uppercase` alphabet. This will map each character to a numeric
    position between 0 and 29.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the sequence of the four base 30 digits, we can compute a number
    from the digits. The following expression does the essential work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The preceding expression is an optimization of the polynomial, ![Decoding natural
    area codes](img/0420OS_04_11.jpg). The Python code simplifies the constants in
    each term—rather than computing `x[0]*30**3/30**4`; this is reduced to `x[0]/30`.
  prefs: []
  type: TYPE_NORMAL
- en: The intermediate results are scaled by 360 or 180 and offset to get the expected
    signed values for the final result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that we evaluate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This shows how we decode an NAC to recover the latitude and longitude of a position.
  prefs: []
  type: TYPE_NORMAL
- en: Solving problems – closest good restaurant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to meet our secret informant at a good restaurant that's a reasonable
    distance from our base. In order to locate a good restaurant, we need to gather
    some additional information. In this case, good means a passing grade from the
    health inspectors.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can even have a meeting, we'll need to use basic espionage skills
    to locate the health code survey results for local restaurants.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a Python application to combine many things to sort through the
    results. We''ll perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with the restaurant health score information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to geocode the restaurant addresses if it hasn't been done already.
    In some cases, geocoding is done for us. In other cases, we'll be using a web
    service for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to filter and organize restaurants by good scores. We'll also need to
    use our `haversine()` function to compute the distance from our base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to communicate this to our network, ideally using a short NAC
    code embedded within an image that we post to a social media site. See [Chapter
    3](ch03.html "Chapter 3. Encoding Secret Messages with Steganography"), *Encoding
    Secret Messages with Steganography*, for details on this final step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In many cities, the health code data is available online. A careful search will
    reveal a useful dataset. In other cities, the health inspection data isn't readily
    available online. We might have to dig considerably deep to track down even a
    few restaurants near our base of operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some cities use **Yelp** to publicize restaurant health code inspection data.
    We can read about the YELP API to search for restaurants on the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.yelp.com/developers/documentation](http://www.yelp.com/developers/documentation)'
  prefs: []
  type: TYPE_NORMAL
- en: We might also find some useful data on InfoChimps at [http://www.infochimps.com/tags/restaurant](http://www.infochimps.com/tags/restaurant).
  prefs: []
  type: TYPE_NORMAL
- en: One complexity we often encounter is the use of HTML-based APIs for this kind
    of information. This is not intentional obfuscation, but the use of HTML complicates
    analysis of the data. Parsing HTML to extract meaningful information isn't easy;
    we'll need an extra library to handle this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at two approaches: good, clean data and more complex HTML data
    parsing. In both cases, we need to create a Python object that acts as a container
    for a collection of attributes. First, we''ll divert to look at the `SimpleNamespace`
    class. Then, we''ll use this to collect information.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating simple Python objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a wide variety of ways to define our own Python objects. We can use
    the central built-in types such as dict to define an object that has a collection
    of attribute values. When looking at information for a restaurant, we could use
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is a mutable object, we can add attribute values and change the
    values of the existing attributes. The syntax is a bit *clunky*, though. Here''s
    what an update to this object looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The extra `[]` brackets and `''` characters seem needless. We'd like to have
    a notation that's a little cleaner than this very general key-value syntax used
    for dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common solution is to use a proper class definition. The syntax looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a class with an initialization method, `__init__()`. The name
    of the initialization method is special, and only this name can be used. When
    the object is built, the initialization method is evaluated to assign initial
    values to the attributes of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to create an object more succinctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We've used explicit keyword arguments. The use of `name=` and `address=` isn't
    *required*. However, as class definitions become more complex, it's often more
    flexible and more clear to use keyword argument values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can update the object nicely too, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This works out best when we have a lot of unique processing that is bound to
    each object. In this case, we don't actually have any processing to associate
    with the attributes; we just want to collect those attributes in a tidy capsule.
    The formal class definition is too much overhead for such a simple problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python also gives us a very flexible structure called a **namespace**. This
    is a mutable object that we can access using simple attribute names, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax to create a namespace *must* use keyword arguments (`name=''The
    Name''`). Once we''ve created this object, we can update it using a pleasant attribute
    access, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `SimpleNamespace` class gives us a way to build an object that contains
    a number of individual attribute values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a namespace from a dictionary using Python''s `**` notation.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `**` notation tells Python that a dictionary object contains keyword arguments
    for the function. The dictionary keys are the parameter names. This allows us
    to build a dictionary object and then use it as the arguments to a function.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that JSON tends to encode complex data structures as a dictionary. Using
    this `**` technique, we can transform a JSON dictionary into `SimpleNamespace`,
    and replace the clunky `object['key']` notation with a cleaner `object.key` notation.
  prefs: []
  type: TYPE_NORMAL
- en: Working with HTML web services – tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, the data we want is tied up in HTML websites. The City of Norfolk,
    for example, relies on the State of Virginia's VDH health portal to store its
    restaurant health code inspection data.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make sense of the intelligence encoded in the HTML notation on the
    WWW, we need to be able to parse the HTML markup that surrounds the data. Our
    job is greatly simplified by the use of special higher-powered weaponry; in this
    case, BeautifulSoup.
  prefs: []
  type: TYPE_NORMAL
- en: Start with [https://pypi.python.org/pypi/beautifulsoup4/4.3.2](https://pypi.python.org/pypi/beautifulsoup4/4.3.2)
    or [http://www.crummy.com/software/BeautifulSoup/](http://www.crummy.com/software/BeautifulSoup/).
  prefs: []
  type: TYPE_NORMAL
- en: If we have Easy Install (or PIP), we can use these tools to install BeautifulSoup.
    Back in [Chapter 1](ch01.html "Chapter 1. Our Espionage Toolkit"), *Our Espionage
    Toolkit*, we should have installed one (or both) of these tools to install more
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use Easy Install to install BeautifulSoup like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Mac OS X and GNU/Linux users will need to use the `sudo` command. Windows users
    won't use the `sudo` command.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have BeautifulSoup, we can use it to parse the HTML code looking for
    specific facts buried in an otherwise cryptic jumble of HTML tags.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can go on, you'll need to read the quickstart documentation and bring
    yourself up to speed on BeautifulSoup. Once you've done that, we'll move to extracting
    data from HTML web pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with [http://www.crummy.com/software/BeautifulSoup/bs4/doc/#quick-start](http://www.crummy.com/software/BeautifulSoup/bs4/doc/     #quick-start).'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative tool is **scrapy**. For information see [http://scrapy.org](http://scrapy.org).
    Also, read *Instant Scrapy Web Mining and Scraping*, *Travis Briggs*, *Packt Publishing*,
    for details on using this tool. Unfortunately, as of this writing, scrapy is focused
    on Python 2, not Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: Working with HTML web services – getting the page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the case of VDH health data for the City of Norfolk, the HTML scraping is
    reasonably simple. We can leverage the strengths of BeautifulSoup to dig into
    the HTML page very nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've created a BeautifulSoup object from the HTML page, we will have an
    elegant technique to navigate down through the hierarchy of the HTML tags. Each
    HTML tag name (`html`, `body`, and so on) is also a BeautifulSoup query that locates
    the first instance of that tag.
  prefs: []
  type: TYPE_NORMAL
- en: An expression such as `soup.html.body.table` can locate the first `<table>`
    in the HTML `<body>` tag. In the case of the VDH restaurant data, that's precisely
    the data we want.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've found the table, we need to extract the rows. The HTML tag for each
    row is `<tr>` and we can use the BeautifulSoup `table.find_all("tr")` expression
    to locate all rows within a given `<table>` tag. Each tag's text is an attribute,
    `.text`. If the tag has attributes, we can treat the tag as if it's a dictionary
    to extract the attribute values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll break down the processing of the VDH restaurant data into two parts:
    the web services query that builds Soup from HTML and the HTML parsing to gather
    restaurant information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the first part, which is getting the raw BeautifulSoup object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This repeats the web services queries we''ve seen before. We''ve separated
    three things here: the `scheme_host` string, the `path` string, and `query`. The
    reason for this is that our overall script will be using the `scheme_host` with
    other paths. And we''ll be plugging in lots of different query data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this basic `food_list_by_name` query, we''ve built a form that will get
    400 restaurant inspections. The `RestrictToCategory` field in the form has a magical
    key that we must provide to get the Norfolk restaurants. We found this via a basic
    web espionage technique: we poked around on the website and checked the URLs used
    when we clicked on each of the links. We also used the Developer mode of Safari
    to explore the page source.'
  prefs: []
  type: TYPE_NORMAL
- en: In the long run, we want all of the inspections. To get started, we've limited
    ourselves to 400 so that we don't spend too long waiting to run a test of our
    script.
  prefs: []
  type: TYPE_NORMAL
- en: The response object was used by BeautifulSoup to create an internal representation
    of the web page. We assigned this to the `soup` variable and returned it as the
    result of the function.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to returning the `soup` object, it can also be instructive to print
    it. It's quite a big pile of HTML. We'll need to parse this to get the interesting
    details away from the markup.
  prefs: []
  type: TYPE_NORMAL
- en: Working with HTML web services – parsing a table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have a page of HTML information parsed into a BeautifulSoup object,
    we can examine the details of that page. Here's a function that will locate the
    table of restaurant inspection details buried inside the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use a generator function to yield each individual row of the table,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this function begins with a triple-quoted string. This is a *docstring*
    and it provides documentation about the function. Good Python style insists on
    a docstring in every function. The Python help system will display the docstrings
    for functions, modules, and classes. We've omitted them to save space. Here, we
    included it because the results of this particular iterator can be quite confusing.
  prefs: []
  type: TYPE_NORMAL
- en: This function requires a parsed Soup object. The function uses simple tag navigation
    to locate the first `<table>` tag in the HTML `<body>` tag. It then uses the table's
    `find_all()` method to locate all of the rows within that table.
  prefs: []
  type: TYPE_NORMAL
- en: For each row, there are two pieces of processing. First, a generator expression
    is used to find all the `<td>` tags within that row. Each `<td>` tag's text is
    stripped of excess white space and the collection forms a list of cell values.
    In some cases, this kind of processing is sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, however, we also need to decode an HTML `<a>` tag, which has a
    reference to the details for a given restaurant. We use a second `find_all("td")`
    expression to examine each column again. Within each column, we check for the
    presence of an `<a>` tag using a simple `if td.a:` loop. If there is an `<a>`
    tag, we can get the value of the `href` attribute on that tag. When looking at
    the source HTML, this is the value inside the quotes of `<a href="">`.
  prefs: []
  type: TYPE_NORMAL
- en: This value of an HTML `href` attribute is a URL. We don't actually need the
    whole URL. We only need the query string within the URL. We've used the `urllib.parse.urlparse()`
    function to extract the various bits and pieces of the URL. The value of the `url.query`
    attribute is just the query string, after the `?`.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out, we don't even want the entire query string; we only want the value
    for the key `RestrictToCategory`. We can parse the query string with `urllib.parse.parse_qs()`
    to get a form-like dictionary, which we assigned to the variable `form`. This
    function is the inverse of `urllib.parse.urlencode()`. The dictionary built by
    the `parse_qs()` function associates each key with a list of values. We only want
    the first value, so we use `form['RestrictToCategory'][0]` to get the key required
    for a restaurant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this `food_table_iter ()` function is a generator, it must be used with
    a `for` statement or another generator function. We can use this function with
    a `for` statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints each row of data from the HTML table. It starts like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This goes on for 400 locations.
  prefs: []
  type: TYPE_NORMAL
- en: The results are unsatisfying because each row is a flat list of attributes.
    The name is in `row[0]` and the address in `row[2]`. This kind of reference to
    columns by position can be obscure. It would be much nicer to have named attributes.
    If we convert the results to a `SimpleNamespace` object, we can then use the `row.name`
    and `row.address` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Making a simple Python object from columns of data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We really want to work with an object that has easy-to-remember attribute names
    and not a sequence of anonymous column names. Here''s a generator function that
    will build a `SimpleNamespace` object from a sequence of values produced by a
    function such as the `food_table_iter()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This function's argument must be an iterator like `food_table_iter(get_food_list_by_name())`.
    The function uses `next(table_iter)` to grab the first row, since that's only
    going to be a bunch of column titles. We'll assert that the column titles really
    are the standard column titles in the VDH data. If the assertion ever fails, it's
    a hint that VDH web data has changed.
  prefs: []
  type: TYPE_NORMAL
- en: For every row after the first row, we build a `SimpleNamespace` object by taking
    the specific columns from each row and assigning them nice names.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The processing can now use nice attribute names, for example, `business.name`,
    to refer to the data we extracted from the HTML page. This makes the rest of the
    programming meaningful and clear.
  prefs: []
  type: TYPE_NORMAL
- en: What's also important is that we've combined two generator functions. The `food_table_iter()`
    function will yield small lists built from HTML table rows. The `food_row_iter()`
    function expects a sequence of lists that can be iterated, and will build `SimpleNamespace`
    objects from that sequence of lists. This defines a kind of composite processing
    pipeline built from smaller steps. Each row of the HTML table that starts in `food_table_iter()`
    is touched by `food_row_iter()` and winds up being processed by the `print()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Enriching Python objects with geocodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Norfolk data we've gotten so far is only a list of restaurants. We still
    neither have inspection scores, nor do we have useful geocodes. We need to add
    these details to each business that we found in the initial list. This means making
    two more RESTful web services requests for each individual business.
  prefs: []
  type: TYPE_NORMAL
- en: 'The geocoding is relatively easy. We can use a simple request and update the
    `SimpleNamespace` object that we''re using to model each business. The function
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We're using the Google geocoding API that we used earlier. We've made a few
    modifications. First, the data in the `form` variable has the `business.address`
    attribute from the `SimpleNamespace` object. We've had to add the city and state
    information, since that's not provided in the VDH address.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with previous examples, we took only the first location of the response
    list with `response[''results''][0][''geometry''][''location'']`, which is a small
    dictionary object with two keys: `lat` and `lon`. We''ve updated the namespace
    that represents our business by setting two more attributes, `business.latitude`
    and `business.longitude` from the values in this small dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: The namespace object is mutable, so this function will update the object referred
    to by the variable `business`. We also returned the object. The `return` statement
    is not necessary, but sometimes it's handy because it allows us to create a fluent
    API for a sequence of functions.
  prefs: []
  type: TYPE_NORMAL
- en: Enriching Python objects with health scores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The bad news is that getting health scoring details requires yet more HTML
    parsing. The good news is that the details are placed in an easy-to-locate HTML
    `<table>` tag. We''ll break this process into two functions: a web service request
    to get the BeautifulSoup object and more HTML parsing to explore that Soup.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the URL request. This requires the category key that we parsed from
    the `<a>` tag in the `food_table_iter()` function shown previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This request, like other HTML requests, builds a query string, opens the URL
    response object, and parses it to create a `BeautifulSoup` object. We're only
    interested in the `soup` instance. We return this value for use with HTML processing.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that part of the path, `Norolk_Website.nsf`, has a spelling error.
    Secret agents in the field are responsible for finding information in spite of
    these kind of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use this in a function that updates the `SimpleNamespace` object that
    we''re using to model each business. The data extraction function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This function gets the `BeautifulSoup` object for a specific business. Given
    that Soup, it navigates to the first `<h2>` tag within the `<body>` tag. This
    should repeat the business name. We've updated the `business` object with this
    second copy of the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function also navigates to the first `<table>` tag within the `<body>`
    tag via the `soup.body.table` expression. The HTML table has two columns: the
    left column contains a label and the right column contains the value.'
  prefs: []
  type: TYPE_NORMAL
- en: To parse this kind of table, we stepped through each row using `table.find_all("tr")`.
    For each row, we built a list from `row.find_all( "td" )`. The first item in this
    list is the `<td>` tag that contains a name. The second item is the `<td>` tag
    that contains a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a dictionary, `vdh_detail_translate`, to translate the names in
    the left column to a better looking Python attribute name, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Using a dictionary like this allows us to use the expression `vdh_detail_translate[name]`
    to locate a pleasant attribute name (such as `core_item`) instead of the long
    string that's displayed in the original HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to look closely at the use of the `setattr()` function that''s used
    to update the `business` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In other functions, we've used a simple assignment statement such as `business.attribute=
    value` to set an attribute of the namespace object. Implicitly, the simple assignment
    statement actually means `setattr( business, 'attribute', value )`. We can think
    of `setattr(object, attribute_string, value)` as the reason why Python implements
    the simple `variable.attribute= value` assignment statement.
  prefs: []
  type: TYPE_NORMAL
- en: In this function, we can't use a simple assignment statement, because the attribute
    name is a string that's looked up via a translation. We can use the `setattr()`
    function to update the business object using the attribute name string computed
    from `vdh_detail_translate[name]`.
  prefs: []
  type: TYPE_NORMAL
- en: Combining the pieces and parts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now look at the real question: finding high-quality restaurants. We
    can build a composite function that combines our previous functions. This can
    become a generator function that yields all of the details in a sequence of namespace
    objects, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This will build a small object, `base`, to describe our base. The object will
    start with just the `address` attribute. After we apply the `geocode_detail()`
    function, it will also have a latitude and longitude.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `print()` function will produce a line that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `get_food_list_by_name()` function will get a batch of restaurants. We use
    `food_table_iter()` to get the HTML table, and `food_row_iter()` to build individual
    `SimpleNamespace` objects from the HTML table. We then do some updates on each
    of those `SimpleNamespace` objects to provide restaurant inspection results and
    geocode information. We update the object yet again to add the distance from our
    base to the restaurant.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we yield the richly detailed namespace object that represents everything
    we need to know about a business.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this sequence of objects, we can apply some filters to exclude places
    over .75 miles away or with more than one problem reported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This script will apply four different filters to each response. If the business,
    for example, is too far away, the `continue` statement will end the processing
    of this item: the `for` statement will advance to the next. If the business has
    too many items, the `continue` statements will reject this business and advance
    to the next item. Only a business that passes all four tests will be printed.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we've inefficiently processed each business through the `geocode_detail()`
    and `inspection_detail()` functions. A more efficient algorithm would apply the
    distance filter early in the processing. If we immediately reject places that
    are too far away, we will only need to get detailed restaurant health data for
    places that are close enough.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing about this sequence of examples is that we integrated data
    from two different web services and folded them in our own value-added intelligence
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: Working with clean data portals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A good example of a clean data portal is the City of Chicago. We can get the
    restaurant inspection data with a simple URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://data.cityofchicago.org/api/views/4ijn-s7e5/rows.json?accessType=DOWNLOAD](https://data.cityofchicago.org/api/views/4ijn-s7e5/rows.json?accessType=DOWNLOAD)'
  prefs: []
  type: TYPE_NORMAL
- en: This will download all the restaurant inspection information in a tidy, easy-to-parse,
    JSON document. The only problem is the size. It has over 83,000 inspections and
    takes a very long time to download. If we apply a filter (for instance, only inspects
    done this year), we can cut the document down to a manageable size. More details
    on the various kinds of filters supported can be found at [http://dev.socrata.com/docs/queries.html](http://dev.socrata.com/docs/queries.html).
  prefs: []
  type: TYPE_NORMAL
- en: There's a lot of sophistication available. We'll define a simple filter based
    on the inspection date to limit ourselves to a subset of the available restaurant
    inspections.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function to get the data looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `schem_netloc_path` variable includes two interesting details in path. `4ijn-s7e5`
    is the internal identity of the dataset we're looking for and `rows.json` specifies
    the format we want the data in.
  prefs: []
  type: TYPE_NORMAL
- en: The form we built includes a `$where` clause that will cut down on the volume
    of data to just the recent inspection reports. The Socrata API pages show us that
    we have a great deal of flexibility here.
  prefs: []
  type: TYPE_NORMAL
- en: As with other web services requests, we created a query and made the request
    using the `urllib.request.urlopen()` function. We opened an output file named
    `chicago_data.json` and wrote the document to that file for further processing.
    This saves us from having to retrieve the data repeatedly since it doesn't change
    too quickly.
  prefs: []
  type: TYPE_NORMAL
- en: We've done the processing via nested `with` statements to be assured that the
    files are closed and the network resources are properly released.
  prefs: []
  type: TYPE_NORMAL
- en: Making a simple Python object from a JSON document
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JSON document contains lots of individual dict objects. While a dict is
    a handy general-purpose structure, the syntax is a bit clunky. Having to use `object['some_key']`
    is awkward. It's nicer to work with `SimpleNamespace` objects and use pleasant
    attribute names. Using `object.some_key` is nicer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a function that will iterate through the massive JSON document with
    all of the inspection details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We've built a `SimpleNamespace` object from each individual row that was in
    the source data. The JSON document's data, in `inspections["data"]`, is a list
    of lists. It's rather hard to interpret because we need to know the position of
    each relevant field.
  prefs: []
  type: TYPE_NORMAL
- en: We created a list of headings based on the field names we found in `inspections["meta"]["view"]["columns"]`.
    The field names seem to all be valid Python variable names and will make good
    Python attribute names in a `SimpleNamespace` object.
  prefs: []
  type: TYPE_NORMAL
- en: Given this list of headings, we can then use the `zip()` function to interleave
    headings and data from each row that we find. This sequence of two-tuples can
    be used to create a dictionary by employing `dict( zip( headings, row ) )`. The
    dictionary can then be used to build the `SimpleNamespace` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `**` syntax specifies that the items in the dictionary will become individual
    keyword parameters for `SimpleNamespace`. This will elegantly transform a dictionary
    such as `{''zip'': ''60608'', ''results'': ''Fail'', ''city'': ''CHICAGO'', ...
    }` to a `SimpleNamespace` object as if we had written `SimpleNamespace( zip=''60608'',
    results=''Fail'', city=''CHICAGO'', ... )`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a sequence of `SimpleNamespace` objects, we can do some minor
    updates to make them easier to work with. Here''s a function that makes a few
    tweaks to each object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We've converted the longitude and latitude values from strings to float numbers.
    We need to do this in order to properly use the `haversine()` function to compute
    distance from our secret base. We've also split the `business.violations` value
    to a list of individual detailed violations. It's not clear what we'd do with
    this, but it might be helpful in understanding the `business.res` `ults` value.
  prefs: []
  type: TYPE_NORMAL
- en: Combining different pieces and parts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can combine the processing into a function that's very similar to the `choice_iter()`
    function shown previously in the *Combining the pieces and parts* section. The
    idea is to create code that looks similar but starts with different source data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will iterate through the restaurant choices, depending on having `SimpleNamespace`
    objects that have been updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This function defines our secret base at 3420 W Grace St. We've already worked
    out the latitude and longitude, and don't need to make a geocoding request for
    the location.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each row produced by `food_row_iter()`, we''ve used `parse_details()` to
    update the row. We needed to use a `try:` block because some of the rows have
    invalid (or missing) latitude and longitude information. When we try to compute
    `float(None)`, we get a `TypeError` exception. We just skipped those locations.
    We can geocode them separately, but this is Chicago: there''s another restaurant
    down the block that''s probably better.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this function is a sequence of objects that include the distance
    from our base and health code inspection details. We might, for example, apply
    some filters to exclude places over .25 miles away or those that got a status
    of `Fail`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The important thing about this sequence of examples is that we leveraged data
    from a web source, adding value to the raw data by doing our own intelligence
    processing. We also combined several individual steps into a more sophisticated
    composite function.
  prefs: []
  type: TYPE_NORMAL
- en: Final steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've located places where we can meet, we have two more things to
    do. First, we need to create a proper grid code for our chosen locations. The
    NAC codes are pretty terse. We simply need to agree with our informant about what
    code we're going to use.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we need to use our steganography script from [Chapter 3](ch03.html "Chapter 3. Encoding
    Secret Messages with Steganography"), *Encoding Secret Messages with Steganography*,
    to conceal the message in an image. Again, we'll need to be sure that our informant
    can locate the encoded message in the image.
  prefs: []
  type: TYPE_NORMAL
- en: We'll leave the design of these final processing steps as a mission for you
    to tackle on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the data – schema and metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data is described by additional data that we often call metadata. A basic datum
    might be 6371\. Without some metadata, we have no idea what this means. Minimally,
    metadata has to include the unit of measurement (kilometers in this case) as well
    as the thing being measured (mean radius of the earth).
  prefs: []
  type: TYPE_NORMAL
- en: In the case of less objective data, there may be no units, but rather a domain
    of possible values. For restaurants, it may be an A-B-C score or a pass-fail outcome.
    It's important to track down the metadata in order to interpret the actual data.
  prefs: []
  type: TYPE_NORMAL
- en: An additional consideration is the schema problem. A set of data should consist
    of multiple instances of some essential entity. In our case, the entity is the
    recent health inspection results for a given restaurant. If each instance has
    a consistent collection of attributes, we can call that set of attributes the
    schema for the set of data.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the data isn't consistent. Perhaps there are multiple schemata
    or perhaps the schema is quite complex with options and alternatives. If there's
    good metadata, it should explain the schema.
  prefs: []
  type: TYPE_NORMAL
- en: The City of Chicago data has a very tidy and complete metadata description for
    the restaurant health inspection information. We can read it at [https://data.cityofchicago.org/api/assets/BAD5301B-681A-4202-9D25-51B2CAE672FF?download=true](https://data.cityofchicago.org/api/assets/BAD5301B-681A-4202-9D25-51B2CAE672FF?download=true).
    It explains the risk category assigned to the facility and the ultimate result
    (pass, pass with conditions, fail). Note the long ugly URL; opaque paths like
    this are often a bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: The Virginia Department of Health data isn't quite so tidy or complete. We can
    eventually work out what the data appears to mean. To be completely sure, we'd
    need to contact the curator of the data to find out precisely what each attribute
    means. This would involve an e-mail exchange with the department of health at
    the state level. A field agent might find this extra effort necessary in the case
    of ambiguous data names.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use web services to perform geocoding and
    reverse geocoding. We also used web services to get large sets of publicly available
    information.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `math` library to implement the haversine formula to compute distances
    between locations. We saw some sophisticated processing, encoding, and decoding
    techniques and used them to abbreviate grid locations.
  prefs: []
  type: TYPE_NORMAL
- en: We saw more techniques in data gathering using the BeautifulSoup HTML parser.
    We combined multiple web services to create really sophisticated applications
    that integrate geocoding and data analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll turn up the sensitivity by performing more sophisticated
    data analysis using deeper statistical techniques. We'll compute means, modes,
    and medians and look at correlations among data items.
  prefs: []
  type: TYPE_NORMAL
