<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Accessing and Mining Data from Network</h1>
                </header>
            
            <article>
                
<p>Looking back, we now have a fair idea of the basics of writing Python scripts and how to get meaningful data out of information. We have covered how to write Python scripts, interact with network devices, and have also worked on the basics of PowerShell so that we can work with both PowerShell and Python scripts. Now we will move towards a deeper understanding of using Python by looking at various examples. In this chapter we will focus on working with various Network devices to dig or fetch relevant information from devices, working on that information to create new configurations and pushing it back to the devices for added or enhanced functionality.</p>
<p>We will work on some common scenarios that we may face and try to solve them with Python. These examples or scenarios can be extended depending on a programmer's needs, and can be used as a reference to achieve automation in complex tasks.</p>
<p>Some of the key concepts we will be covering are as follows:</p>
<ul>
<li>Device configuration</li>
<li class="mce-root">Multi-vendor environments</li>
<li class="mce-root">IPv4 to IPv6 conversion</li>
<li class="mce-root">Office/DC relocations</li>
<li class="mce-root">Site rollouts</li>
<li class="mce-root">BYOD configs for switches</li>
<li class="mce-root">Device OS upgrades</li>
<li class="mce-root">IP configs/interface parsing</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Device configurations</h1>
                </header>
            
            <article>
                
<p>We need to deploy three routers with a standard base configuration. The base configuration remains the same on each router, but as each router is different, we need to automate the generation of the three config files for each router. The assumption is that all the routers have a standard hardware configuration with the same types of ports:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d50bf4ba-cbd3-4e52-b0fc-0259d1dd9c06.jpg" style="width:33.50em;height:17.00em;"/></div>
<p>As we can see in the diagram, routers R1, R2, and R3 have the following cabling:</p>
<ul>
<li>R1 <kbd>f1/0</kbd> (FastEthernet1/0) connected R2 <kbd>f1/0</kbd></li>
<li>R1 <kbd>f0/0</kbd> connected to R3 <kbd>f0/0</kbd></li>
<li>R2 <kbd>f0/1</kbd> connected to R3 <kbd>f0/1</kbd></li>
</ul>
<p class="mce-root">The standard config or template is as follows:</p>
<pre class="mce-root"> hostname &lt;hname&gt;<br/> ip domain-lookup<br/> ip name-server &lt;nameserver&gt;<br/> logging host &lt;loghost&gt;<br/> username cisco privilege 15 password cisco<br/> enable password cisco<br/> ip domain-name checkmetest.router<br/>line vty 0 4<br/> exec-timeout 5</pre>
<p>Adding some more complexity, we need to ensure the <kbd>name-server</kbd> is different for each router. If each router is going to be deployed in different networks, here is the mapping that we want:</p>
<ul>
<li class="mce-root">R1 -&gt; hostname testindia</li>
<li class="mce-root">R2 -&gt; hostname testusa</li>
<li class="mce-root">R3 -&gt; hostname testUK</li>
</ul>
<p>The logging host and name server will depend upon the region, so the mapping will be as follows:</p>
<ul>
<li><strong>India router</strong>: logserver (1.1.1.1) and nameserver (1.1.1.2)</li>
<li><strong>USA router</strong>: logserver (2.1.1.1) and nameserver (2.1.1.2)</li>
<li><strong>UK router</strong>: logserver (3.1.1.1) and nameserver (3.1.1.2)</li>
</ul>
<p>The code to perform the requested task is as follows:</p>
<pre>ipdict={'india': '1.1.1.1,1.1.1.2', 'uk': '3.1.1.1,3.1.1.2', 'usa': '2.1.1.1,2.1.1.2'}<br/><br/>standardtemplate="""<br/>hostname &lt;hname&gt;<br/>ip domain-lookup<br/>ip name-server &lt;nameserver&gt;<br/>logging host &lt;loghost&gt;<br/>username cisco privilege 15 password cisco<br/>enable password cisco<br/>ip domain-name checkmetest.router<br/><br/>line vty 0 4<br/> exec-timeout 5<br/>"""<br/><br/>routerlist="R1,R2,R3"<br/>routers=routerlist.split(",")<br/>for router in routers:<br/>print ("Now printing config for",router)<br/>    if "R1" in router:<br/>        hostname="testindia"<br/>        getips=ipdict["india"]<br/>        getips=getips.split(",")<br/>        logserver=getips[0]<br/>        nameserver=getips[1]<br/>    if "R2" in router:<br/>        hostname="testusa"<br/>        getips=ipdict["usa"]<br/>        getips=getips.split(",")<br/>        logserver=getips[0]<br/>        nameserver=getips[1]<br/>    if "R3" in router:<br/>        hostname="testUK"<br/>        getips=ipdict["uk"]<br/>        getips=getips.split(",")<br/>        logserver=getips[0]<br/>        nameserver=getips[1]<br/>    generatedconfig=standardtemplate<br/>    generatedconfig=generatedconfig.replace("&lt;hname&gt;",hostname)<br/>    generatedconfig=generatedconfig.replace("&lt;nameserver&gt;",nameserver)<br/>    generatedconfig=generatedconfig.replace("&lt;loghost&gt;",logserver)<br/>    print (generatedconfig)</pre>
<p>The first list is a dictionary that defines the logging host and nameserver config based upon the region. The <kbd>standardtemplate</kbd> <span>variable</span><span> </span><span>is used to store the template. If we have a multi-line value that needs to be stored in a variable, we can use the three-quote format as we see in the preceding example.</span></p>
<p>Now, as we currently know the generic or default hostnames, we can just parse through each of the current hostnames, and, based upon the hostname values, generate the config. This output can be saved onto a file or can be directly generated from the script and pasted onto the router for the basic configuration. Similarly, we can enhance this by adding the IP addresses shown in the next example in the format <kbd>&lt;ipaddress&gt;</kbd> <kbd>&lt;subnet mask</kbd>&gt;:</p>
<ul>
<li>testindia f1/0: <kbd>10.0.0.1</kbd> <kbd>255.0.0.0</kbd></li>
<li>testusa  f1/0: <kbd>10.0.0.2</kbd> <kbd>255.0.0.0</kbd></li>
<li>testindia f0/0: <kbd>11.0.0.1</kbd> <kbd>255.0.0.0</kbd></li>
<li>testUK f0/0: <kbd>11.0.0.2</kbd> <kbd>255.0.0.0</kbd></li>
<li>testusa f0/1: <kbd>12.0.0.1</kbd> <kbd>255.0.0.0</kbd></li>
<li>testUK f0/1: <kbd>12.0.0.2</kbd> <kbd>255.0.0.0</kbd></li>
</ul>
<p>The code to perform this task is as follows:</p>
<pre>def getipaddressconfig(routername):<br/>    intconfig=""<br/>    sampletemplate="""<br/>    interface f0/0<br/>     ip address ipinfof0/0<br/>    interface f1/0<br/>     ip address ipinfof1/0<br/>    interface f0/1<br/>     ip address ipinfof0/1<br/>    """<br/>    if (routername == "testindia"):<br/>        f0_0="11.0.0.1 255.0.0.0"<br/>        f1_0="10.0.0.1 255.0.0.0"<br/>        sampletemplate=sampletemplate.replace("ipinfof0/0",f0_0)<br/>        sampletemplate=sampletemplate.replace("ipinfof1/0",f1_0)<br/>        sampletemplate=sampletemplate.replace("interface f0/1\n","")<br/>        sampletemplate=sampletemplate.replace("ip address ipinfof0/1\n","")<br/>    if (routername == "testusa"):<br/>        f0_0="11.0.0.1 255.0.0.0"<br/>        f0_1="12.0.0.1 255.0.0.0"<br/>        sampletemplate=sampletemplate.replace("ipinfof0/0",f0_0)<br/>        sampletemplate=sampletemplate.replace("ipinfof0/1",f0_1)<br/>        sampletemplate=sampletemplate.replace("interface f1/0\n","")<br/>        sampletemplate=sampletemplate.replace("ip address ipinfof1/0\n","")<br/>    if (routername == "testUK"):<br/>        f0_0="11.0.0.2 255.0.0.0"<br/>        f0_1="12.0.0.2 255.0.0.0"<br/>        sampletemplate=sampletemplate.replace("ipinfof0/0",f0_0)<br/>        sampletemplate=sampletemplate.replace("ipinfof0/1",f0_1)<br/>        sampletemplate=sampletemplate.replace("interface f1/0\n","")<br/>        sampletemplate=sampletemplate.replace("ip address ipinfof1/0\n","")<br/>    return sampletemplate<br/><br/>#calling this function<br/>myfinaloutput=getipaddressconfig("testUK") #for UK router<br/>myfinaloutput=getipaddressconfig("testindia") #for USA router<br/>myfinaloutput=getipaddressconfig("testusa") #for India router</pre>
<p>In this case, we define a function that has a standard interface template. The template is now modified with the specific IP addresses and updated <span>depending upon the calling value in the function (which is the router name)</span><span>. Also, we remove the unused lines by replacing them with a none value denoted by two double quotes <kbd>""</kbd> without any spaces between them.</span></p>
<p>Once we have the generated config, we can use a simple file handling operation to save it: </p>
<pre>#Suppose our final value is in myfinaloutput and file name is myrouterconfig.txt<br/>fopen=open("C:\check\myrouterconfig.txt","w")<br/>fopen.write(myfinaloutput)<br/>fopen.close()</pre>
<p>As we can see, the output for both the generic template and interface configuration can be concatenated or added to a variable named <kbd>myfinaloutput</kbd>, and that is now being saved in a file called <kbd>myrouterconfig.txt</kbd> in the <kbd>C:\check</kbd> folder.</p>
<p>Similarly, we can enhance the script by adding more functions for specific tasks such as <strong>Open Shortest Path First</strong> (<strong>OSPF</strong>) configs and <strong>Border Gateway Protocol</strong> (<strong>BGP</strong>) configs, create enhanced and complex configurations based upon specific router names, and store them in separate <kbd>.txt</kbd> files that would be ready for the final push to the network devices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multi-vendor environments</h1>
                </header>
            
            <article>
                
<p>Sometimes we have many vendors participating in a configuration change or even creating various templates from scratch. We have vendors such as Arista, Cisco (IOS, NXOS), and Juniper that participate in network design in different layers. While dealing with situations such as this we need to be clear which layer each of the vendors is working on and create dynamic templates for each type of vendor involved.</p>
<p>Taking a scenario in which we know the hardware platform and the role of the device (such as access layer, core layer, or <strong>top of rack</strong> (<strong>TOR</strong>) layer; we can generate configs quickly with very basic parameters.</p>
<p>If a device is in production, we can use the SNMP protocol to fetch information for that device and create dynamic values based upon the return type of devices.</p>
<div class="packt_tip">As a basic idea, we can have a look at <a href="https://wiki.opennms.org/wiki/Hardware_Inventory_Entity_MIB" target="_blank">https://wiki.opennms.org/wiki/Hardware_Inventory_Entity_MIB.</a><br/>
This has the information on the current open standard <strong>Managed Information Base</strong> (<strong>MIB</strong>) that is used by SNMP to get basic device information.</div>
<p>Again following good practice, we should ensure we create a generic function that can return the device type. Additionally, SNMP <strong>Object Identifiers (OIDs</strong>) can go deep inside to fetch information such as the current number of interfaces, the state of the interfaces, and even which interfaces are operational so that we can quickly make intelligent decisions based upon a device's current health or information fetched from a device.</p>
<p>We will be installing and using the <kbd><span>PySNMP</span></kbd> library<strong> </strong>to query SNMP with device. To install it we will use the earlier method of <kbd>pip install pysnmp</kbd>.</p>
<div class="packt_infobox"><span>Basic </span> <kbd><span>PySNMP</span></kbd><strong> </strong>documentation can be viewed at the following URL:<br/>
<a href="https://pynet.twb-tech.com/blog/snmp/python-snmp-intro.html" target="_blank">https://pynet.twb-tech.com/blog/snmp/python-snmp-intro.html<br/></a></div>
<p>As an example, we will try to fetch the current version of a network device:</p>
<pre>from pysnmp.hlapi import *<br/><br/>errorIndication, errorStatus, errorIndex, varBinds = next(<br/>    getCmd(SnmpEngine(),<br/>           CommunityData('public', mpModel=0),<br/>           UdpTransportTarget(('192.168.255.249', 161)),<br/>           ContextData(),<br/>           ObjectType(ObjectIdentity('SNMPv2-MIB', 'sysDescr', 0)))<br/>)<br/><br/>if errorIndication:<br/>    print(errorIndication)<br/>elif errorStatus:<br/>    print('%s at %s' % (errorStatus.prettyPrint(),<br/>                        errorIndex and varBinds[int(errorIndex) - 1][0] or '?'))<br/>else:<br/>    for varBind in varBinds:<br/>        print(' = '.join([x.prettyPrint() for x in varBind]))</pre>
<p>The sample output for the preceding code when queried against a network device is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/77a31f3a-e4ed-4b2d-832d-148e5a11a9bf.jpg" style="width:38.50em;height:13.08em;"/></div>
<p>On our test router, we enabled SNMP using the <kbd>snmp-server community public RO</kbd> command, and through executing the preceding Python code written, got the <kbd>RO</kbd> string public to read the <kbd>sysDescr.0</kbd> value, which is in Cisco standards the truncated show version.</p>
<p>Using this method of fetching information using SNMP, we can discover what types of device there are and based on the output, we can make intelligent decisions such as generating device-specific configs without asking for device type inputs.</p>
<p>Additionally, here is an example using PySNMP to fetch the current interfaces on a router:</p>
<pre>from pysnmp.entity.rfc3413.oneliner import cmdgen<br/><br/>cmdGen = cmdgen.CommandGenerator()<br/><br/>errorIndication, errorStatus, errorIndex, varBindTable = cmdGen.bulkCmd(<br/>    cmdgen.CommunityData('public'),<br/>    cmdgen.UdpTransportTarget(('192.168.255.249', 161)),<br/>    0,25,<br/>    '1.3.6.1.2.1.2.2.1.2'<br/>)<br/><br/># Check for errors and print out results<br/>if errorIndication:<br/>    print(errorIndication)<br/>else:<br/>    if errorStatus:<br/>        print('%s at %s' % (<br/>            errorStatus.prettyPrint(),<br/>            errorIndex and varBindTable[-1][int(errorIndex)-1] or '?'<br/>            )<br/>        )<br/>    else:<br/>        for varBindTableRow in varBindTable:<br/>            for name, val in varBindTableRow:<br/>                print('%s = %s' % (name.prettyPrint(), val.prettyPrint()))</pre>
<p>The output when queried for interface info on our sample router is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c0cae82a-c71e-4d5a-a69e-fe20240f9b9e.jpg" style="width:41.17em;height:15.08em;"/></div>
<p>As we can see, we use the <kbd>bulkCmd</kbd> method, which walks through all the SNMP values and returns the output for the interfaces.</p>
<p>The OID <kbd>1.3.6.1.2.1.2.2.1.2</kbd> is used as reference to fetch these values from the device.</p>
<p>In a similar way, we can utilize the available SNMP OIDs for different vendors to fetch the specific information from multiple devices and proceed with our expected tasks based upon the returned values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IP configs/interface parsing</h1>
                </header>
            
            <article>
                
<p>There are many instances in which we need to parse interface configs to fetch useful information. For example, from a list of devices, find all the interfaces that are trunk. Another example could be to find all the interfaces that are <kbd>admin-shutdown</kbd> (shutdown on the router), or even fetch the IP address configurations from interfaces.</p>
<p>There might be instances wherein we need to find out whether particular IP addresses or subnets are configured on the router.</p>
<p>A good way to extract any information is using regex. Regex is term that is used to match a particular pattern and either fetch the matched pattern or validate whether a certain pattern is present in the parsed text.</p>
<p>Here are the most basic and important regexes that are used in Python:</p>
<table>
<tbody>
<tr>
<td><kbd>.</kbd></td>
<td>Match any character except newline</td>
</tr>
<tr>
<td><kbd>^</kbd></td>
<td>Match the start of the string</td>
</tr>
<tr>
<td><kbd>$</kbd></td>
<td>Match the end of the string</td>
</tr>
<tr>
<td><kbd>*</kbd></td>
<td>Match 0 or more repetitions</td>
</tr>
<tr>
<td><kbd>+</kbd></td>
<td>Match 1 or more repetitions</td>
</tr>
<tr>
<td><kbd>?</kbd></td>
<td>Match 0 or 1 repetitions</td>
</tr>
<tr>
<td><kbd>\A</kbd></td>
<td>Match only at the start of the string</td>
</tr>
<tr>
<td><kbd>\b</kbd></td>
<td>Match an empty string, only at the beginning or end of a word</td>
</tr>
<tr>
<td><kbd>\B</kbd></td>
<td>Match an empty string, only when it is not at the beginning or end of a word</td>
</tr>
<tr>
<td><kbd>\d</kbd></td>
<td>Match digits (such as [0-9])</td>
</tr>
<tr>
<td><kbd>\D</kbd></td>
<td>Match any non digit (such as [^0-9])</td>
</tr>
<tr>
<td><kbd>\Z</kbd></td>
<td>Match only at the end of a string</td>
</tr>
<tr>
<td><kbd>\</kbd></td>
<td>Escape special characters</td>
</tr>
<tr>
<td><kbd>[]</kbd></td>
<td>Match a set of characters</td>
</tr>
<tr>
<td><kbd>[a-z]</kbd></td>
<td>Match any lowercase ASCII letter</td>
</tr>
<tr>
<td><kbd>[^]</kbd></td>
<td>Match characters NOT in a set</td>
</tr>
<tr>
<td><kbd>A|B</kbd></td>
<td>Match either A or B regular expressions (non-greedy)</td>
</tr>
<tr>
<td><kbd>\s</kbd></td>
<td>Match whitespace characters (such as [ \t\n\r\f\v])</td>
</tr>
<tr>
<td><kbd>\S</kbd></td>
<td>Match non whitespace characters (such as [^ \t\n\r\f\v])</td>
</tr>
<tr>
<td><kbd>\w</kbd></td>
<td>Match unicode word characters (such as  [a-zA-Z0-9_])</td>
</tr>
<tr>
<td><kbd>\W</kbd></td>
<td>Match any character not a Unicode word character (such as  [^a-zA-Z0-9_])</td>
</tr>
</tbody>
</table>
<p> </p>
<p>From this string, My IP address is <kbd>10.10.10.20</kbd> and by subnet mask is <kbd>255.255.255.255</kbd>, we need to get the IP address and subnet mask using regex:</p>
<pre>import re<br/>mystring='My ip address is 10.10.10.20 and by subnet mask is 255.255.255.255'<br/><br/>if (re.search("ip address",mystring)):<br/>    ipaddregex=re.search("ip address is \d+.\d+.\d+.\d+",mystring)<br/>    ipaddregex=ipaddregex.group(0)<br/>    ipaddress=ipaddregex.replace("ip address is ","")<br/>    print ("IP address is :",ipaddress)<br/><br/>if (re.search("subnet mask",mystring)):<br/>    ipaddregex=re.search("subnet mask is \d+.\d+.\d+.\d+",mystring)<br/>    ipaddregex=ipaddregex.group(0)<br/>    ipaddress=ipaddregex.replace("subnet mask is ","")<br/>    print ("Subnet mask is :",ipaddress)<br/><br/></pre>
<p>The output when the preceding code is executed is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5842005f-74fc-4bdf-8fac-fb8cd53aa768.jpg" style="width:39.58em;height:12.00em;"/></div>
<p>As we can see, the regex for the IP address that we used is <kbd>\d+.\d+.\d+.\d+</kbd>. The <kbd>\d</kbd> means a digit, and <kbd>+</kbd> means multiple repetitions, because we are looking for a value of multiple digits separated by three dots.</p>
<p>However, in our case we have this type of repetition in two places, one in the IP address and the other in the subnet mask, so we modify the regex to search for <kbd>ip address is  \d+.\d+.\d+.\d+</kbd><strong> </strong>for the IP address and <kbd>subnet mask is \d+.\d+.\d+.\d+</kbd> <span>for the subnet mask. The command </span><kbd>re.search</kbd> <span>inside both the <kbd>if</kbd> loops returns true if a match is found, and false if a match isn't found. In the example, once we find the pattern in the <kbd>if</kbd> condition we use <kbd>re.search</kbd> again and extract the value using <kbd>.group(0)</kbd>, which now contains the matched regex pattern.</span></p>
<p>Since, we are only concerned with the IP address and the subnet mask, we replace the other string values with a blank or none value so we only get the specific IP address and subnet mask values.</p>
<p>Additionally, using the inbuilt <kbd>socket</kbd> library, there might be a reason to check whether the IP address (IPv4 or IPv6) is valid or not. Here is an example of this:</p>
<pre>import socket<br/><br/>def validateipv4ip(address):<br/>    try:<br/>        socket.inet_aton(address)<br/>        print ("Correct IPv4 IP")<br/>    except socket.error:<br/>        print ("wrong IPv4 IP")<br/><br/>def validateipv6ip(address):<br/>    ### for IPv6 IP address validation<br/>    try:<br/>        socket.inet_pton(socket.AF_INET6,address)<br/>        print ("Correct IPv6 IP")<br/>    except socket.error:<br/>        print ("wrong IPv6 IP")<br/><br/>#correct IPs:<br/>validateipv4ip("2.2.2.1")<br/>validateipv6ip("2001:0db8:85a3:0000:0000:8a2e:0370:7334")<br/><br/><br/>#Wrong IPs:<br/>validateipv4ip("2.2.2.500")<br/>validateipv6ip("2001:0db8:85a3:0000:0000:8a2e")<br/><br/></pre>
<p>The output for the preceding code is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/78441d58-8d1c-4c0d-945f-c447f5593419.jpg" style="width:40.67em;height:15.00em;"/></div>
<p>Using the <kbd>socket</kbd> library, we validate the IPv4 and IPv6 IP addresses.</p>
<p>Another task, as we mentioned earlier, is finding the interfaces that have <kbd>trunk</kbd> enabled:</p>
<pre>import re<br/>sampletext="""<br/>interface fa0/1<br/>switchport mode trunk<br/>no shut<br/><br/>interface fa0/0<br/>no shut<br/><br/>interface fa1/0<br/>switchport mode trunk<br/>no shut<br/><br/>interface fa2/0<br/>shut<br/><br/>interface fa2/1<br/>switchport mode trunk<br/>no shut<br/><br/>interface te3/1<br/>switchport mode trunk<br/>shut<br/>"""<br/><br/>sampletext=sampletext.split("interface")<br/>#check for interfaces that are in trunk mode<br/>for chunk in sampletext:<br/>    if ("mode trunk" in chunk):<br/>        intname=re.search("(fa|te)\d+/\d+",chunk)<br/>        print ("Trunk enabled on "+intname.group(0))<br/>    </pre>
<p>The output for the preceding code is given as:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/09766937-eb10-44a3-9c56-c4fd4d5feac2.jpg" style="width:40.00em;height:15.67em;"/></div>
<p>Here, we need to find out the common config that separates each chunk of interface. As we see in every interface configuration, the <span>word</span><span> </span><span><kbd>interface</kbd> separates the configurations of each interface, so we split out the config in chunks on interface work using the <kbd>split</kbd> command. </span></p>
<p>Once we have each chunk, we use the <kbd>(fa|te)\d+/\d+</kbd> <span><kbd>re</kbd> pattern</span><span> </span><span>to get the interface name on any chunk that contains the word <kbd>trunk</kbd>. The pattern says that any value that starts with <kbd>fa</kbd> or <kbd>te</kbd>, is followed by any number of digits with a <kbd>\</kbd>, and again is followed by any number of digits, will be a match. </span></p>
<p>Similarly in the same code, we only want to know which interfaces that are configured as <kbd>trunk</kbd> are in the active state (not shut). Here is the code:</p>
<pre>import re<br/>sampletext="""<br/>interface fa0/1<br/>switchport mode trunk<br/>no shut<br/><br/>interface fa0/0<br/>no shut<br/><br/>interface fa1/0<br/>switchport mode trunk<br/>no shut<br/><br/>interface fa2/0<br/>shut<br/><br/>interface fa2/1<br/>switchport mode trunk<br/>no shut<br/><br/>interface te3/1<br/>switchport mode trunk<br/>shut<br/>"""<br/><br/>sampletext=sampletext.split("interface")<br/>#check for interfaces that are in trunk mode<br/>for chunk in sampletext:<br/>    if ("mode trunk" in chunk):<br/>        if ("no shut" in chunk):<br/>            intname=re.search("(fa|te)\d+/\d+",chunk)<br/>            print ("Trunk enabled on "+intname.group(0))</pre>
<p>The output for the preceding code is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6cd711c9-5afc-47ef-ae62-6bf447e5fc36.jpg" style="width:43.42em;height:14.92em;"/></div>
<p>We added an extra condition to proceed with only those chunks that have <kbd>no shut</kbd> in addition to <kbd>trunk</kbd> keywords. In this case, we only proceed with chunks that meet both conditions and in the preceding example, <kbd>te3/1</kbd> is not in the list as it is in the <kbd>shut</kbd> state.</p>
<p>When validating any IP config, we can parse the config, fetch the IP addresses, validate each IP address (IPv4 or IPv6), and if there are any incorrect values, point out the incorrect values. This can help to ensure we are validating the IP addresses that might have crept in because of any manual copy or paste actions. Of course, this also means we will not see any production issues because the config will already be pre-validated for correctness using this logic.</p>
<p>The code to validate any given IPv4 or IPv6 address from a device config is as follows:</p>
<pre>import socket<br/>import re<br/><br/>def validateipv4ip(address):<br/>    try:<br/>        socket.inet_aton(address)<br/>    except socket.error:<br/>        print ("wrong IPv4 IP",address)<br/><br/>def validateipv6ip(address):<br/>    ### for IPv6 IP address validation<br/>    try:<br/>        socket.inet_pton(socket.AF_INET6,address)<br/>    except socket.error:<br/>        print ("wrong IPv6 IP", address)<br/><br/>        <br/>sampletext="""<br/>ip tacacs server 10.10.10.10<br/>int fa0/1<br/>ip address 25.25.25.298 255.255.255.255<br/>no shut<br/>ip name-server 100.100.100.200<br/>int fa0/0<br/>ipv6 address 2001:0db8:85a3:0000:0000:8a2e:0370:7334<br/>ip logging host 90.90.91.92<br/>int te0/2<br/>ipv6 address 2602:306:78c5:6a40:421e:6813:d55:ce7f<br/>no shut<br/>exit<br/><br/>"""<br/><br/>sampletext=sampletext.split("\n")<br/>for line in sampletext:<br/>    if ("ipv6" in line):<br/>        ipaddress=re.search("(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))",line)<br/>        validateipv6ip(ipaddress.group(0))<br/>    elif(re.search("\d+.\d+.\d+.\d+",line)):<br/>        ipaddress=re.search("\d+.\d+.\d+.\d+",line)<br/>        validateipv4ip(ipaddress.group(0))</pre>
<p><span>The output for the preceding code is as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ad4c8a01-4998-4f15-86f5-626c6cbfa9db.jpg" style="width:43.17em;height:16.75em;"/></div>
<p>We take each line from <kbd>sampletext</kbd> and find out the IPv4 or IPv6 IPs from each line. Then we parse that information into our IP validation functions, and if there is an incorrect IP, it will print out the IP address that is not correct.</p>
<p>Similarly, we can validate other aspects of the config by creating specific functions and perform a full sanity and validation check on any given config.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Device OS upgrades</h1>
                </header>
            
            <article>
                
<p>Sometimes we need to upgrade devices such as routers, switches, and firewalls. It is easy to perform upgrades on one device, but we need automation to upgrade multiple routers. Different devices have different ways of upgrading IOS or OS images, and the automation or scripts are created with different methods depending on the device.</p>
<p>Taking an example of upgrading a Cisco IOS router; there are two basic steps or tasks that need to be performed:</p>
<ol>
<li>Copy the relevant OS or IOS image into <kbd>flash:</kbd> or <kbd>bootflash:</kbd>.</li>
<li>Change the config to reload the router with the new image.</li>
</ol>
<p><strong>Task 1: Prerequisites (to copy relevant OS or IOS image):</strong></p>
<ul>
<li><span>We need a FTP server that's accessible from the router and has the IOS image that we need on the router</span></li>
<li><span>We need the image, the correct MD5 checksum, and the image size for validation</span></li>
</ul>
<p>The sample code for task 1 is as follows:</p>
<pre>from netmiko import ConnectHandler<br/>import time<br/><br/>def pushimage(imagename,cmd,myip,imgsize,md5sum=None):<br/>    uname="cisco"<br/>    passwd="cisco"<br/>    print ("Now working on IP address: ",myip)<br/>    device = ConnectHandler(device_type='cisco_ios', ip=myip, username=uname, password=passwd)<br/>    outputx=device.send_command("dir | in Directory")<br/>    outputx=outputx.split(" ")<br/>    outputx=outputx[-1]<br/>    outputx=outputx.replace("/","")<br/>    precmds="file prompt quiet"<br/>    postcmds="file prompt"<br/>    xcheck=device.send_config_set(precmds)<br/>    output = device.send_command_timing(cmd)<br/>    flag=True<br/>    devicex = ConnectHandler(device_type='cisco_ios', ip=myip, username=uname, password=passwd)<br/>    outputx=devicex.send_command("dir")<br/>    print (outputx)<br/>    while (flag):<br/>        time.sleep(30)<br/>        outputx=devicex.send_command("dir | in "+imagename)<br/>        print (outputx)<br/>        if imgsize in outputx:<br/>            print("Image copied with given size. Now validating md5")<br/>            flag=False<br/>        else:<br/>            print (outputx)<br/>        if (flag == False):<br/>            cmd="verify /md5 "+imagename<br/>            outputmd5=devicex.send_command(cmd,delay_factor=50)<br/>        if (md5sum not in outputmd5):<br/>            globalflag=True<br/>            print ("Image copied but Md5 validation failed on ",myip)<br/>        else:<br/>            print ("Image copied and validated on ",myip)<br/>    devicex.send_config_set(postcmds)<br/>    devicex.disconnect()<br/>    device.disconnect()<br/>    <br/><br/>ipaddress="192.168.255.249"<br/>imgname="c3745-adventerprisek9-mz.124-15.T14.bin"<br/>imgsize="46509636"<br/>md5sum="a696619869a972ec3a27742d38031b6a"<br/>cmd="copy ftp://ftpuser:ftpuser@192.168.255.250/c3745-adventerprisek9-mz.124-15.T14.bin flash:"<br/>pushimage(imgname,cmd,ipaddress,imgsize,md5sum)</pre>
<p>This code is going to push the IOS image into the router. The <kbd>while</kbd> loop will continue to monitor the progress of code copying until the specific image size is not met in the directory. The moment we have specified image size, the script will move to the next action, which is validating the MD5 checksum.  Once the MD5 checksum is validated, it prints out a final confirmation that the IOS image is not copied and MD5 validated.</p>
<p>We can use this function on any router with just a couple of tweaks to the image name, size, and MD5 checksums for different sets of images.</p>
<div class="packt_tip">An important thing to note here is the <kbd>file prompt quiet</kbd> command. This needs to be executed before we start copying the command, as it suppresses any confirmation prompts in the router. If we get these confirmation prompts, it is tough to deal with all the prompts, thus adding to the complexity of the code. <br/>
By adding this command, we suppress the confirmation and once we have the code copied, we enable it to its default state of file prompt.</div>
<p><strong>Task 2: To change the bootvar of the router to a new OS image</strong>:</p>
<p> This is where we set the bootvar in Cisco, to point to the new IOS image to be loaded:</p>
<pre>from netmiko import ConnectHandler<br/>import time<br/><br/>uname="cisco"<br/>passwd="cisco"<br/>device = ConnectHandler(device_type='cisco_ios', ip="192.168.255.249", username=uname, password=passwd)<br/>output=device.send_command("show run | in boot")<br/>print ("Current config:")<br/>print (output)<br/>cmd="boot system flash:c3745-adventerprisek9-mz.124-15.T14.bin"<br/>device.send_config_set(cmd)<br/>print ("New config:")<br/>output=device.send_command("show run | in boot")<br/>print (output)<br/>device.send_command("wr mem")<br/>device.disconnect()</pre>
<p><span>The output for the preceding code is as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/82c715a9-ffb6-43f3-b9c3-90f3caa1a79e.jpg" style="width:44.42em;height:19.17em;"/></div>
<p>As we can see, in this code we create a command with the new image and <span>send it to the router </span><span>using the <kbd>send_config_set</kbd> method. This method executes the command under <kbd>config t</kbd>. Once this is done, we validate from the new output fetched from running the <kbd>show run | in boot</kbd><strong> </strong>command again, to confirm that the bootvar is now pointing to the new OS image. </span></p>
<p>If all is good, then we run <kbd>wr mem</kbd> to save this new config.</p>
<div class="packt_tip">Once both the tasks are completed, we need to reload the router for the change to take affect. There are multiple scenarios that need to be taken care of before a reload. A direct reload can be performed as Task 3 using the <kbd>reload</kbd> command, but as a best practice we need to ensure no production or live traffic is currently on the router, as a reload will disrupt the current traffic flow. Also, it is advisable to be logged into the console to validate the reload progress and for faster recovery if there is a reload failure.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IPv4 to IPv6 conversion</h1>
                </header>
            
            <article>
                
<p>There are multiple ways to convert an IPv4 address to an IPv6 address. In Python 3, we have the inbuilt <kbd>ipaddress</kbd> <span>module</span><span>:</span></p>
<pre>import ipaddress<br/><br/>def convertusingipaddress(ipv4address):<br/>    print(ipaddress.IPv6Address('2002::' + ipv4address).compressed)<br/><br/>convertusingipaddress("10.10.10.10")<br/>convertusingipaddress("192.168.100.1")</pre>
<p><span>The output for the preceding code is as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4955c089-e699-458b-b816-1efcb3c6d5c1.jpg" style="width:37.50em;height:11.83em;"/></div>
<div class="packt_infobox">There are many different methods or functions in the <kbd>ipaddress</kbd> library that we can use for various purposes. The documentation and details can be found at <a href="https://docs.python.org/3/library/ipaddress.html" target="_blank">https://docs.python.org/3/library/ipaddress.html.</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Site rollouts</h1>
                </header>
            
            <article>
                
<p>As we continue to work with multi-vendor environments, there is a demand to quickly roll out devices and configs to get a particular site up and running. Multiple techniques can be deployed for site rollouts, which involves a standard set of devices connected to standard ports with a standard IOS or code image on each device ready to be racked and powered up.  To determine the standard <strong>Stock Keeping Unit</strong> (<strong>SKU</strong>) for a specific site, we can segregate it as t-shirt sizes. At the planning stage we can create t-shirt sizes based upon certain parameters, such as usage, load, and redundancy.</p>
<p>At the lowest level, let's say <strong>extra small size</strong> (<strong>XS</strong>) can have a single router and a single switch with the router terminating at an internet link. The switch is connected to the <kbd>FastEthernet 0/1</kbd> (for 100 Mbps) or <kbd>Gi0/1</kbd>(for 1000 Mbps) port on the router, and end users directly plug in to the switch to get access. Based upon this XS SKU (or t-shirt size), we can determine the hardware vendor, such as Cisco, DLink, or other network device providers, for each of the router and the switch.  Next, when we have finalized the hardware providers, we work on generating the config template.</p>
<p>The config template is typically based on two criteria:</p>
<ul>
<li>Role of the device</li>
<li>Hardware vendor</li>
</ul>
<p>In the same XS size, let's say we have Cisco 3064 (Cisco Nexus running Cisco NXOS) as the router, and an Alcatel switch in the switch layer. As we have now finalized the hardware vendor and the role of each device, we can easily create template configs.</p>
<p>As mentioned earlier, once we have the standard hardware, we also need to ensure the ports are standard (for example, the uplink of switch will be connected from port <kbd>Gi1/0</kbd> to the router's <kbd>Gi1/1</kbd>). This will help us by ensuring we create a near-complete template with the interface configuration also being taken into consideration. </p>
<p>A template contains a basic configuration with certain values being determined later on. It is a very generic layout that we can fill in with values from various inputs, such as identifying free IP addresses, the next hostname in the sequence, and which routing needs to be in place as a standard configuration:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/11e0779b-374e-4781-9052-5e450fbd3b77.jpg" style="width:29.83em;height:18.58em;"/></div>
<p>As we see in the preceding figure, the central Python script is calling different functions (with the initial inputs being the vendor and the standard role-based template), and fetching specific information such as free IP addresses, next available hostname (such as <kbd>rtr01</kbd> or <kbd>rtr05</kbd>) and routing information (such as <span><strong>Enhanced Interior Gateway Routing Protocol</strong> (<strong>EIGRP</strong>) </span>with subnet <kbd>10.10.10.0/255</kbd> being advertised on the network). Each of these inputs and more (depending upon the requirements) are separate Python functions, with the template being changed depending upon the return values of the Python function.</p>
<p>As an example, we need to get the IP address from a SQL table where the IP address shows as unassigned using Python (we would be using <kbd>MySQLdb</kbd> library in Python for this):</p>
<pre class="prettyprint notranslate prettyprinted">import MySQLdb<br/><br/>def getfreeip():<br/>    # Open database connection<br/>    db = MySQLdb.connect("testserver","user","pwd","networktable" )<br/>    cursor = db.cursor()<br/><br/>    sql = "select top 1 from freeipaddress where isfree='true'"<br/>    try:<br/>       # Execute the SQL command<br/>       cursor.execute(sql)<br/>       # Fetch all the rows in a list of lists.<br/>       results = cursor.fetchall()<br/>       for eachrow in results:<br/>          freeip=eachrow[0]<br/>          return (freeip)<br/>    except:<br/>       print "Error: unable to fetch data"<br/>       return "error in accessing table"<br/>    db.close()<br/><br/><br/>print (getfreeip())</pre>
<p>This returns a free IP address from the SQL table that we can call into other functions to generate our configs. Of course, once this is given, we also need to update the table to ensure we set the <kbd>isfree</kbd> value in the record to <kbd>false</kbd> so that a new call to this function would ensure that we get the next free IP address in the SQL table.</p>
<p>Adding all of this together, we can fetch details from multiple tables and even call APIs for specific tools to get specialized information, and, taking the return values  from all of these functions or methods as inputs,  the template would be called with these return values replacing the variables specified in the template. Once the template values are filled in, the output will be the final generated config that is ready to be deployed on the router/network devices.</p>
<p>By creating this baseline automation based upon the t-shirt size specifications, the script can be called again with a new t-shirt size that can include a new set of devices, such as load balancers, multiple routers, and each of the different routers in different roles depending on the t-shirt size and complexity.</p>
<p>The next step after the generation of the final config templates is to apply the configs to the router. It is always advisable to perform this functionality using the console. Once we have the basic config in place to get SSH/Telnet access to the device, we can keep a session open with the console while performing the push of the remaining configs on the various devices. Netmiko can be used for this purpose, with the intention of pushing all the configs using the newly generated templates.</p>
<p>Assuming the cables are connected properly, as per the standards, the next step is to validate the traffic and configurations. To do this we again rely on Netmiko to fetch routes, logs, and even specific information such as interface counters and BGP router tables.</p>
<p>Additionally, we could also work on SNMP inputs to validate the current running health of each device. A device can sometime perform well in test conditions, but once production or live traffic is on its data plane, it can spike in hardware resources, causing latency or packet drops. The SNMP stats will give us a clear idea of the health of each device, such as CPU usage, memory usage, and even the current temperature of certain devices and its modules, to display the overall health of the SKU or the t-shirt size site rollout.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Office/DC relocations</h1>
                </header>
            
            <article>
                
<p>There are times when we need to relocate, shut down, or migrate a site to a different location. This involves a lot of pre-checks, pre-validations, and ensuring the same setup of network PoD is active in the other location.</p>
<p>In a multi-vendor environment, and with the increasing SKU size based upon t-shirt size, keeping a track of all active sessions, traffic flows, current interface status, and specific routes <span>manually </span><span>is difficult. Using Python, we can create an automated way to create a basic checklist and it can be ensured that after relocation the same checklist acts as a post validation checklist.</span></p>
<p>As an example, we create a basic script that asks if we need to perform a pre-check/post-check and save that in files named <kbd>pre-check</kbd> and <kbd>post-check</kbd>:</p>
<pre>from netmiko import ConnectHandler<br/>import time<br/><br/>def getoutput(cmd):<br/>    uname="cisco"<br/>    passwd="cisco"<br/>    device = ConnectHandler(device_type='cisco_ios', ip="192.168.255.249", username=uname, password=passwd)<br/>    output=device.send_command(cmd)<br/>    return (output)<br/><br/><br/>checkprepost=input("Do you want a pre or post check [pre|post]: ")<br/>checkprepost=checkprepost.lower()<br/>if ("pre" in checkprepost ):<br/>    fname="precheck.txt"<br/>else:<br/>    fname="postcheck.txt"<br/><br/>file=open(fname,"w")<br/>file.write(getoutput("show ip route"))<br/>file.write("\n")<br/>file.write(getoutput("show clock"))<br/>file.write("\n")<br/>file.write(getoutput("show ip int brief"))<br/>file.write("\n")<br/><br/>print ("File write completed",fname)<br/><br/>file.close()</pre>
<p><span>The output for the preceding code is as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e726fcd4-c421-400b-94c8-b54c2c0a1acf.jpg" style="width:39.92em;height:18.92em;"/></div>
<p>Assume that the <kbd>precheck.txt</kbd> file was taken at the site for multiple devices before the migration or relocation, and <kbd>postcheck.txt</kbd> was taken at the site after relocation. Now let's write a quick script that compares both files and prints out the difference.</p>
<p>Python has a library called <kbd>difflib</kbd> to perform this task:</p>
<pre>import difflib<br/><br/>file1 = "precheck.txt"<br/>file2 = "postcheck.txt"<br/><br/>diff = difflib.ndiff(open(file1).readlines(),open(file2).readlines())<br/>print (''.join(diff),)</pre>
<p><span>The output for the preceding code is as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5657105f-a8e3-4959-ba83-bc03896f61a7.jpg" style="width:45.92em;height:25.42em;"/></div>
<p>As we can see in <kbd>precheck.txt</kbd> and <kbd>postcheck.txt</kbd>, the files are being compared line by line. Anything that is unchanged is displayed as it is, but anything that is different is shown by either a <kbd>-</kbd> or <kbd>+</kbd>. The <kbd>-</kbd> sign at start of the line specifies that the specific line is from first file (which is <kbd>precheck.txt</kbd> in our case), and a <kbd>+</kbd> sign depicts the same line has been output in the new file (which is <kbd>postcheck.txt</kbd>). Using this method, we can quickly validate the differences between <kbd>precheck</kbd> and <kbd>postcheck</kbd> and work on fixing the relevant issues after the migration or relocation.</p>
<p>There are times when we want to automatically run the script to take a backup of the current config of routers. In this case, let's assume that the relocation is planned for tomorrow. Before any activity starts we want to ensure we have a backup of the current device configs.</p>
<p>A simple script stated would do the trick:</p>
<pre>from netmiko import ConnectHandler<br/><br/>def takebackup(cmd,rname):<br/>    uname="cisco"<br/>    passwd="cisco"<br/>    device = ConnectHandler(device_type='cisco_ios', ip=rname, username=uname, password=passwd)<br/>    output=device.send_command(cmd)<br/>    fname=rname+".txt"<br/>    file=open(fname,"w")<br/>    file.write(output)<br/>    file.close()<br/><br/><br/># assuming we have two routers in network <br/>devices="rtr1,rtr2"<br/>devices=devices.split(",")<br/><br/>for device in devices:<br/>    takebackup("show run",device)</pre>
<p>The script is going to parse each device in the devices list one by one, execute the <kbd>show run</kbd> command, and save it in the given filename (the filename is the same as the given device name or IP). However, the next question is how to ensure this runs at the scheduled time. In Linux we have cron job that we can set up for this, and there is also Windows Task Scheduler.</p>
<p>The following example shows the basic process of creating the task in Task Scheduler:</p>
<ol>
<li>Open <span class="packt_screen">Task Scheduler</span> in Windows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign">&gt;<img src="assets/84456129-2387-4ac2-a8bf-c1f53df878ae.jpg" style="width:44.50em;height:21.33em;"/></div>
<ol start="2">
<li>Click on <span class="packt_screen">Create a Basic Task</span> on the right side of the Task Scheduler:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/00a1e53b-6b7a-44ec-9cb1-f6d363d092cc.jpg" style="width:43.83em;height:24.50em;"/></div>
<ol start="3">
<li>Click on <span class="packt_screen">Next</span> and select the frequency of the task:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9c3fc115-aea5-45be-8b1b-7c4c2bc786fc.jpg" style="width:33.67em;height:22.67em;"/></div>
<ol start="4">
<li>Click <span class="packt_screen">Next</span>, select the time, and again click <span class="packt_screen">Next</span>. Move to <span class="packt_screen">Start a Program</span>. At this point, you need to add the details shown in the following screenshot. We have to provide the full path of <kbd>python.exe</kbd> in the <span class="packt_screen">Program/script:</span> window, and in the <span class="packt_screen">Add arguments (optional)</span> section, the full path of the Python script (with the <kbd>.py</kbd> extension) enclosed in double quotes:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/49199f49-4c8e-436d-8156-a0433d3f1292.jpg" style="width:46.83em;height:33.00em;"/></div>
<ol start="5">
<li>On the final page, click on <span class="packt_screen">Finish</span> to submit the changes and create the task:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b23de7e1-ff39-460f-9d89-55bd5f3de113.jpg" style="width:46.75em;height:32.08em;"/></div>
<p>Once this is done, you can run it manually by right-clicking on the created task and clicking on the <span class="packt_screen">Run</span> option. If the task succeeds, it will return the same in the Task Scheduler window. If all is fine, the task will automatically run at the given time in the Task Scheduler.</p>
<p>This can also be run as a service and at regular intervals, such as daily and hourly, depending on how frequently we want to run the script in our environment.</p>
<p>These scheduled backups can sometimes be taken as baseline and can also act as last known good configuration scenarios.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bring Your Own Device (BYOD) configs for switches</h1>
                </header>
            
            <article>
                
<p>As our network becomes more scalable, we need to broaden the current architecture designs of our network to incorporate better switches and routers to meet the demand. There may be times when we have a specialized demand and a specific set of hardware needs to be added to our network to meet those demands.</p>
<p>Another requirement may be to lower the cost while increasing the scalability. In this case we would need to add different vendor switches to meet the demand. There might also be a very specific demand for a certain office or a site. In this case, we need to add different vendor hardware to fulfill some specific requirements.</p>
<p>All of the scenarios that we have just observed have one thing in common. To meet demand or specific requirements, we cannot rely on a single vendor solution on the network. There would be a random collection of devices to ensure a particular set of requirements are met. This is where we introduce the term BYOD. BYOD is a new standard that embraces new designs, hardware, and architecture to gel with our current SKU or design. It can be as simple as adding a new mobile phone to our corporate network using wireless, or a bit more complex, such as adding specific vendor hardware to the network.</p>
<p>Architects need to ensure they have good way of forecasting the demand and knowing whether the current network design or hardware can meet those demands. In any case, there needs to be a requirement in the initial design to ensure that cross-vendor platforms are supported with the current technologies. There is a bit of conflict in this design methodology. For example, a certain vendor, such as Cisco, has the neighbor discovery protocol, <span><strong>Cisco-specific protocol</strong> (</span><strong>CDP</strong>), which discovers the correct Cisco devices as neighbors of the current device. However, to ensure the CDP is discovering and showing the correct information, every device needs to be Cisco. On the other hand we have <span><strong>Link Layer Discovery Protocol</strong> (<strong>LLDP</strong>)</span>, which is nearly the same as CDP but is open source, so lot of other vendors including Cisco also have the option to perform discovery using LLDP instead of CDP. Now, Cisco CDP is a Cisco-specific protocol; Cisco has ensured that certain parameters can only be exchanged or discovered using CDP, and for that matter, every device participating in CDP must be a Cisco device. </p>
<p>LLDP, being open source, is limited to parameters that are part of open standards or the <strong>Internet Engineering Task Force</strong> (<span><strong>IETF</strong>) </span>framework, and all vendors supporting LLDP <span>only</span><span> </span><span>adhere to those open standards for cross-platform and hardware compatibility. This also results in some participating vendors not sending or discovering specialized parameters that are meant specifically for that vendor (such as Cisco). Going back to the earlier point, in this case the architecture design from day one needs to ensure those standards that are multi-vendor or open source only need to be used in a baseline design or architecture. A similar example to LLDP would be using open standards such as OSPF or BGP instead of EIGRP, which is meant only for Cisco devices.</span></p>
<p>As mentioned earlier, we need to have specific roles defined and hardware or vendor templates that should be created based upon the device or hardware that we are introducing in the current design as a BYOD strategy. Keeping the open standard approach, we need to ensure that the templates being created are generic, and vendor-specific configs can later be introduced into the device.</p>
<p>SNMP is a powerful protocol that helps manage a lot of these cross-vendor or BYOD strategies seamlessly. With a basic configuration of enabling SNMP with a specific read-only community string, we can create quick scripts in Python to get basic information from BYOD devices. Taking an example, let's assume we have two devices that we need to know the type and vendor of:</p>
<pre>from pysnmp.hlapi import *<br/><br/>def finddevices(ip):<br/>    errorIndication, errorStatus, errorIndex, varBinds = next(<br/>        getCmd(SnmpEngine(),<br/>               CommunityData('public', mpModel=0),<br/>               UdpTransportTarget((ip, 161)),<br/>               ContextData(),<br/>               ObjectType(ObjectIdentity('SNMPv2-MIB', 'sysDescr', 0)))<br/>    )<br/><br/>    if errorIndication:<br/>        print(errorIndication)<br/>    elif errorStatus:<br/>        print('%s at %s' % (errorStatus.prettyPrint(),<br/>                            errorIndex and varBinds[int(errorIndex) - 1][0] or '?'))<br/>    else:<br/>        for varBind in varBinds:<br/>            print(' = '.join([x.prettyPrint() for x in varBind]))<br/><br/>ipaddress="192.168.255.248,192.168.255.249"<br/>ipaddress=ipaddress.split(",")<br/>for ip in ipaddress:<br/>    print (ip)<br/>    finddevices(ip)<br/>    print ("\n")    </pre>
<p>The output for the previous code is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/632e5f8d-0b08-408f-9861-148edd3bfc17.jpg" style="width:38.58em;height:25.00em;"/></div>
<p>As we can see in the preceding output, now we just need to know the IP address and the open standard SNMP OID, SNMPv2-MIB. <kbd>sysDescr</kbd> will give the output for both devices. In this case, we can see that one is Cisco 3600 and the other is Cisco 3700. Based upon the information returned, we can proceed with the configuration.</p>
<p>There are various other tasks that need to be performed based upon the BYOD strategy. If there was a mobile phone that you wanted to connect to your network, the only thing needed is a connection to a corporate network and a policy that you could push to the devices to check for various compliance checks such as operating system and anti-virus. Based upon these results, the queried devices can be placed in another VLAN that can be called either a quarantine VLAN, which has very limited access, or a corporate VLAN, which has full access to corporate resources.</p>
<p>In a similar way, as part of the BYOD for switches strategy, we need to perform certain checks to ensure the device is suitable to be part of our network design. Yes, we need to keep an open policy for various types of device, but there needs to be a loosely coupled framework under which devices can qualify to be part of BYOD acceptance.</p>
<p>Let's look at an example that ensures that a device is compatible enough to be part of a BYOD framework. The core requirement is the switch from Cisco and it should have <kbd>FastEthernet0/0</kbd> as one of the interfaces:</p>
<pre>from pysnmp.hlapi import *<br/>from pysnmp.entity.rfc3413.oneliner import cmdgen<br/><br/>cmdGen = cmdgen.CommandGenerator()<br/><br/>def validateinterface(ip):<br/>    errorIndication, errorStatus, errorIndex, varBindTable = cmdGen.bulkCmd(<br/>        cmdgen.CommunityData('public'),<br/>        cmdgen.UdpTransportTarget((ip, 161)),<br/>        0,25,<br/>        '1.3.6.1.2.1.2.2.1.2',<br/>        '1.3.6.1.2.1.2.2.1.7'<br/>    )<br/>    flag=False<br/>    # Check for errors and print out results<br/>    if errorIndication:<br/>        print(errorIndication)<br/>    else:<br/>        if errorStatus:<br/>            print('%s at %s' % (<br/>                errorStatus.prettyPrint(),<br/>                errorIndex and varBindTable[-1][int(errorIndex)-1] or '?'<br/>                )<br/>            )<br/>        else:<br/>            for varBindTableRow in varBindTable:<br/>                for name, val in varBindTableRow:<br/>                    if ("FastEthernet0/0" in val.prettyPrint()):<br/>                        flag=True<br/>    if (flag):<br/>        return True<br/>    else:<br/>        return False<br/><br/>def finddevice(ip):<br/>    errorIndication, errorStatus, errorIndex, varBinds = next(<br/>        getCmd(SnmpEngine(),<br/>               CommunityData('public', mpModel=0),<br/>               UdpTransportTarget((ip, 161)),<br/>               ContextData(),<br/>               ObjectType(ObjectIdentity('SNMPv2-MIB', 'sysDescr', 0)))<br/>    )<br/><br/>    if errorIndication:<br/>        print(errorIndication)<br/>    elif errorStatus:<br/>        print('%s at %s' % (errorStatus.prettyPrint(),<br/>                            errorIndex and varBinds[int(errorIndex) - 1][0] or '?'))<br/>    else:<br/>        for varBind in varBinds:<br/>            if ("Cisco" in varBind.prettyPrint()):<br/>                return True<br/>    return False<br/> <br/>mybyoddevices="192.168.255.249,192.168.255.248"<br/>mybyoddevices=mybyoddevices.split(",")<br/>for ip in mybyoddevices:<br/>    getvendorvalidation=False<br/>    getipvalidation=False<br/>    print ("Validating IP",ip)<br/>    getipvalidation=validateinterface(ip)<br/>    print ("Interface has fastethernet0/0 :",getipvalidation)<br/>    getvendorvalidation=finddevice(ip)<br/>    print ("Device is of vendor Cisco:",getvendorvalidation)<br/>    if getipvalidation and getvendorvalidation:<br/>        print ("Device "+ip+" has passed all validations and eligible for BYOD")<br/>        print ("\n\n")<br/>    else:<br/>        print ("Device "+ip+" has failed validations and NOT eligible for BYOD")<br/>        print ("\n\n")  </pre>
<p><span>The output for the previous code is as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/addb3b92-1f37-493f-8e27-ade47fdfe9a7.jpg" style="width:43.00em;height:22.08em;"/></div>
<p>We parse two devices and, using open source SNMP, get the vendor and interface info. Next, we validate, and based upon our conditions we return a <kbd>True</kbd> or <kbd>False</kbd>. A true condition for all checks results in acceptance of the device as BYOD.</p>
<p>Let's change the rule a bit. Let's say if any device has an Ethernet interface, then it is not eligible for BYOD:</p>
<pre>from pysnmp.hlapi import *<br/>from pysnmp.entity.rfc3413.oneliner import cmdgen<br/><br/>cmdGen = cmdgen.CommandGenerator()<br/><br/>def validateinterface(ip):<br/>    errorIndication, errorStatus, errorIndex, varBindTable = cmdGen.bulkCmd(<br/>        cmdgen.CommunityData('public'),<br/>        cmdgen.UdpTransportTarget((ip, 161)),<br/>        0,25,<br/>        '1.3.6.1.2.1.2.2.1.2',<br/>        '1.3.6.1.2.1.2.2.1.7'<br/>    )<br/>    flag=False<br/>    # Check for errors and print out results<br/>    if errorIndication:<br/>        print(errorIndication)<br/>    else:<br/>        if errorStatus:<br/>            print('%s at %s' % (<br/>                errorStatus.prettyPrint(),<br/>                errorIndex and varBindTable[-1][int(errorIndex)-1] or '?'<br/>                )<br/>            )<br/>        else:<br/>            for varBindTableRow in varBindTable:<br/>                for name, val in varBindTableRow:<br/>                    if ((val.prettyPrint()).startswith("Ethernet")):<br/>                        return False<br/>                    if ("FastEthernet0/0" in val.prettyPrint()):<br/>                        flag=True<br/>    if (flag):<br/>        return True<br/>    else:<br/>        return False<br/><br/>def finddevice(ip):<br/>    errorIndication, errorStatus, errorIndex, varBinds = next(<br/>        getCmd(SnmpEngine(),<br/>               CommunityData('public', mpModel=0),<br/>               UdpTransportTarget((ip, 161)),<br/>               ContextData(),<br/>               ObjectType(ObjectIdentity('SNMPv2-MIB', 'sysDescr', 0)))<br/>    )<br/><br/>    if errorIndication:<br/>        print(errorIndication)<br/>    elif errorStatus:<br/>        print('%s at %s' % (errorStatus.prettyPrint(),<br/>                            errorIndex and varBinds[int(errorIndex) - 1][0] or '?'))<br/>    else:<br/>        for varBind in varBinds:<br/>            if ("Cisco" in varBind.prettyPrint()):<br/>                return True<br/>    return False<br/>    <br/>mybyoddevices="192.168.255.249,192.168.255.248"<br/>mybyoddevices=mybyoddevices.split(",")<br/>for ip in mybyoddevices:<br/>    getvendorvalidation=False<br/>    getipvalidation=False<br/>    print ("Validating IP",ip)<br/>    getipvalidation=validateinterface(ip)<br/>    print ("Device has No Ethernet only Interface(s) :",getipvalidation)<br/>    getvendorvalidation=finddevice(ip)<br/>    print ("Device is of vendor Cisco:",getvendorvalidation)<br/>    if getipvalidation and getvendorvalidation:<br/>        print ("Device "+ip+" has passed all validations and eligible for BYOD")<br/>        print ("\n\n")<br/>    else:<br/>        print ("Device "+ip+" has failed validations and NOT eligible for BYOD")<br/>        print ("\n\n")    </pre>
<p><span>The output for the previous code is as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b8fbf329-19c7-45c1-aa9b-96f25d9ed2b4.jpg" style="width:42.92em;height:24.42em;"/></div>
<p>As we can see in this example, we validated for any interface that starts with the <kbd>Ethernet</kbd> keyword. The <kbd>string.startswith("given string")</kbd> <span>function</span><span> </span><span>is used to evaluate if any given string is at the start of the string that it is being compared with. In our case, the device with the IP <kbd>192.168.255.248</kbd> had an Ethernet-only interface, which returned the value <kbd>True</kbd> for validation the Ethernet-only interface. As this is considered a failure for our validation, a <kbd>False</kbd> was returned, and the script calls it out as a BYOD acceptance failure because this specific condition has failed.</span></p>
<p>In a similar way, we can validate and ensure multiple checks on on any number of devices, and ensure only those that pass the BYOD framework checks are accepted in the network.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at various complex scenarios to see how new site migrations and validations are performed. We also looked at the concepts of multi-vendor configurations, creating templates, and generating configs for devices, and also IPv4 to IPv6 migration techniques.</p>
<p>We focused on specialized extraction of particular data, such as an IP addresses, validations of that data, and conditions of failure or acceptance of the data. Additionally, site rollouts and BYOD strategies were discussed, along with best practices such as t-shirt size and validations of BYOD conditions. </p>
<p>In the next chapter, we will go deeper and introduce the web-enabled framework. This will help us create our own APIs and create browser-based Python scripts that can be executed from anywhere.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>