- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Debugging
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: 'Generally speaking, the cycle for debugging problems has the following steps:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，调试问题的周期包括以下步骤：
- en: Detecting the problem. A new problem or defect is discovered
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测问题。发现了一个新的问题或缺陷
- en: Analyzing and assigning priority to this problem, to be sure that we spend time
    on meaningful problems and focus on the most important ones
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析并分配此问题的优先级，以确保我们在有意义的问题上花费时间，并专注于最重要的那些
- en: Investigating what exactly causes the problem. Ideally, this should end with
    a way of replicating the problem in a local environment
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调查导致问题的确切原因。理想情况下，这应该以在本地环境中复制问题的方法结束
- en: Replicating the problem locally, and getting into the specific details on why
    it happens
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地复制问题，并深入了解为什么它会发生
- en: Fixing the problem
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决问题
- en: As you can see, the general strategy is to first locate and understand the problem,
    so we can then properly debug and fix it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一般的策略是首先定位和理解问题，然后我们可以适当地调试和修复它。
- en: 'In this chapter, we''ll cover the following topics to see effective techniques
    on how to work through all those phases:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题，以了解如何有效地处理所有这些阶段的技术：
- en: Detecting and processing defects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测和处理缺陷
- en: Investigation in production
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产环境中的调查
- en: Understanding the problem in production
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解生产环境中的问题
- en: Local debugging
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地调试
- en: Python introspection tools
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python内省工具
- en: Debugging with logs
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用日志进行调试
- en: Debugging with breakpoints
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用断点进行调试
- en: Let's take a look at the very first step when dealing with defects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看处理缺陷时的第一步。
- en: Detecting and processing defects
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测和处理缺陷
- en: The first step is actually detecting the problem. This can sound a bit silly,
    but it's a quite crucial stage.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步实际上是检测问题。这听起来可能有点愚蠢，但它是一个相当关键的阶段。
- en: While we will mainly use the term "bug" to describe any defect, remember that
    it may include details like bad performance or unexpected behavior that may not
    be properly categorized as a "bug." The proper tool to fix the problem could be
    different, but the detection is normally done in a similar way.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们主要使用“bug”这个词来描述任何缺陷，但请记住，它可能包括像性能不佳或意外行为这样的细节，这些可能不会被正确分类为“bug”。修复问题的正确工具可能不同，但检测通常是以相似的方式进行。
- en: Detecting problems can be done in different ways, and some may be more evident
    than others. Normally, once the code is in production, defects will be detected
    by a user, either internally (best case) or externally (worst case), or through
    monitoring.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 发现问题可以通过不同的方式，有些可能比其他方式更明显。通常，一旦代码投入生产，缺陷将由用户检测到，无论是内部（最佳情况）还是外部（最坏情况），或者通过监控。
- en: Keep in mind that monitoring will only be able to capture obvious, and typically
    serious, errors.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，监控只能捕获明显的、通常也是严重的错误。
- en: 'Based on how problems are detected, we can categorize them into different severities,
    for example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据问题的检测方式，我们可以将它们分类为不同的严重程度，例如：
- en: '**Catastrophic problems** that are completely stopping the operation. These
    bugs mean that nothing, not even non-related tasks in the same system, works'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灾难性问题**，这些问题会完全停止操作。这些错误意味着系统中的任何东西都无法工作，甚至包括同一系统中的非相关任务'
- en: '**Critical problems** that stop the execution of some tasks, but not others'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键问题**，这些问题会停止某些任务的执行，但不会停止其他任务'
- en: '**Serious problems** that will stop or cause problems with certain tasks, but
    only in some circumstances. For example, a parameter is not checked and produces
    an exception, or some combination produces a task so slow that it produces a timeout'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**严重问题**，这些问题会停止或在某些情况下导致某些任务的麻烦。例如，一个参数未进行检查并产生异常，或者某些组合产生了一个运行速度如此之慢的任务，以至于产生了超时'
- en: '**Mild problems**, which include tasks containing errors or inaccuracies. For
    example, a task produces an empty result in certain circumstances, or a problem
    in the UI that doesn''t allow calling a functionality'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻微问题**，包括包含错误或不准确性的任务。例如，某个任务在特定情况下产生空结果，或者UI中的问题不允许调用功能'
- en: '**Cosmetic or minor problems** like typos and similar'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外观或轻微问题**，如拼写错误等'
- en: Because every development team is limited, there will always be too many bugs
    and having the proper approach on what to pay attention to and what to fix first
    is critical. Normally bugs in the first group will obviously be quite pressing
    to fix and will require an immediate all-hands reaction. But categorization and
    prioritization are important.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个开发团队都是有限的，因此总会存在太多错误，并且对关注什么以及首先修复什么有适当的处理方法至关重要。通常，第一组的错误显然非常紧迫，需要立即的全员反应。但分类和优先排序很重要。
- en: Having a clear signal on what things to look for next will help developers have
    a clear view and be efficient by spending time on important problems and not whatever
    is the latest. Teams themselves can perform some triage of problems, but it's
    good to add some context.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对接下来要寻找的事物有一个清晰的信号将帮助开发者有一个清晰的视角，通过专注于重要问题而不是最新事物来提高效率。团队本身可以对问题进行一些分类，但添加一些背景信息是好的。
- en: Keep in mind that usually, you need to both correct bugs and implement new features,
    and each of these tasks can distract from the other.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，通常你需要同时纠正错误和实现新功能，并且每一项任务都可能分散对另一项任务的注意力。
- en: Fixing bugs is important, not only for the resulting quality of the service,
    as any user will find working with a buggy service very frustrating. But it's
    also important for the development team, as working with a low-quality service
    is also frustrating for developers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 修复错误很重要，不仅因为服务的结果质量，因为任何用户都会发现与有缺陷的服务一起工作非常令人沮丧。但它对开发团队也很重要，因为与低质量的服务一起工作对开发者来说也很沮丧。
- en: A proper balance needs to be struck between bug fixing and introducing new features.
    Also remember to allocate time for the corresponding new bugs introduced for new
    features. A feature is not ready when released, it's ready when its bugs are fixed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复错误和引入新功能之间需要找到一个适当的平衡。同时，记得为新功能引入的相应新错误分配时间。一个功能在发布时并不准备就绪，而是在其错误被修复时才准备就绪。
- en: Any detected problem, except the catastrophic ones, where context is irrelevant,
    should capture the context surrounding the steps that were required to produce
    the error. The objective of this is to be able to *reproduce* the error.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 任何检测到的问题，除了那些背景信息无关的灾难性错误，都应该捕捉到产生错误所需的步骤周围的上下文。这个目标是为了能够*重现*错误。
- en: Reproducing the error is a critical element of fixing it. The worst-case scenario
    is that a bug is intermittent or appears to happen at random times. More digging
    will be required in order to understand why it is happening when it's happening.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 重现错误是解决问题的关键要素。最坏的情况是，一个错误是间歇性的或似乎在随机时间发生。为了理解为什么它在发生时发生，需要更多的挖掘。
- en: When a problem can be replicated, you're halfway to the solution. The problem
    can be ideally replicated into a test, so it can be tested over and over until
    the problem is understood and fixed. In the best situations, this test can be
    a unit test, if the problem affects a single system and all the conditions are
    understood and can be replicated. If the problem affects more than one system,
    it may be necessary to create integration tests.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个问题可以被复制时，你就已经解决了一半。理想情况下，这个问题可以被复制成一个测试，这样就可以反复测试，直到问题被理解和解决。在最佳情况下，这个测试可以是一个单元测试，如果问题影响单个系统，并且所有条件都被理解和可以复制的话。如果问题影响多个系统，可能需要创建集成测试。
- en: A common problem during an investigation is to find out what the specific circumstances
    are that are provoking the problem, for example, data that's set up in a particular
    way in production and that triggers some issue. Finding exactly what is causing
    the problem can be complicated in this environment. We will talk later in the
    chapter about finding a problem in production.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查过程中，一个常见的问题是找出具体是什么特定情况触发了问题，例如，在生产中以一种特定方式设置的数据，这触发了某些问题。在这个环境中，找出确切导致问题的原因可能很复杂。我们将在本章后面讨论如何在生产中找到问题。
- en: Once a problem is categorized and replicable, the investigation can proceed
    to understand *why*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦问题被分类并可以复制，调查就可以继续进行，以了解*为什么*。
- en: Visually inspecting the code and trying to reason where problems and bugs are
    is normally not good enough. Even very simple code will surprise you in terms
    of how it's executed. Being able to analyze how, in a particular case, the code
    is executing with precision is critical for analyzing and fixing problems that
    are found.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过视觉检查代码并试图推理问题和错误通常是不够的。即使是简单的代码，在执行方面也会让你感到惊讶。能够精确分析在特定情况下代码是如何执行的，对于分析和修复发现的问题至关重要。
- en: Investigation in production
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产中的调查
- en: Once we are aware that we have a problem in production, we need to understand
    what is happening and what the key elements that produce it are.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们意识到生产中存在问题，我们需要了解发生了什么，以及产生问题的关键要素是什么。
- en: It's very important to remark on the importance of being able to replicate a
    problem. If that's the case, tests can be done to produce the error and follow
    the consequences.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 强调能够复制问题的能力非常重要。如果是这样，可以进行测试来产生错误并跟踪其后果。
- en: The most important tools when analyzing why a particular problem is produced
    are the observability tools. That's why it is important to do preparation work
    in advance to be sure to be able to find problems when required.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 分析为什么产生特定问题时最重要的工具是可观察性工具。这就是为什么在需要时确保能够找到问题的准备工作很重要。
- en: We talked in previous chapters about logs and metrics. When debugging, metrics
    are normally not relevant, except to show the relative importance of a bug. Checking
    an increase in returned errors can be important to detect that there's an error,
    but detecting what error will require more precise information.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了日志和指标。在调试时，指标通常与问题无关，除非用来显示错误的相对重要性。检查返回错误的增加可能对于检测错误很重要，但检测错误本身需要更精确的信息。
- en: Do not underestimate metrics, though. They can help quickly determine what specific
    component is failing or if there's any relationship with other elements, for example,
    if there's a single server that's producing errors, or if it has run out of memory
    or hard drive space.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不要低估指标。它们可以帮助快速确定哪个特定组件失败，或者是否有与其他元素的关系，例如，如果有一个服务器正在产生错误，或者如果它已经耗尽了内存或硬盘空间。
- en: For example, a problematic server can produce apparently random errors, if the
    external requests are directed to different servers, and the failure is related
    to a combination of a specific request addressed to a specific server.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个有问题的服务器可能会产生看似随机的错误，如果外部请求被指向不同的服务器，并且故障与针对特定服务器的特定请求的组合有关。
- en: 'But in any case, logs will generally be more useful in determining which part
    of the code is behaving badly. As we saw in *Chapter 12*, *Logging*, we can describe
    error logs as detecting two kinds of problems:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但无论如何，日志通常在确定代码的哪个部分表现不佳时更有用。正如我们在*第12章*，*日志*中看到的，我们可以将错误日志描述为检测两种类型的问题：
- en: '**Expected errors**. In this case, we did the work of debugging the error beforehand
    and knowing what happened should be easy. Examples of this can be an external
    request that returns an error, a database that cannot be connected to, etc.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预期错误**。在这种情况下，我们事先进行了调试错误的操作，并且应该很容易了解发生了什么。这类错误的例子可以是返回错误的外部请求，无法连接的数据库等。'
- en: Most of these errors will be related to external services (from the point of
    view of the one raising the error) that are misbehaving. This could indicate a
    network problem, misconfiguration, or problems in other services. It is not rare
    that errors propagate through the system as an error may provoke a cascading failure.
    Typically, though, the origin will be an unexpected error and the rest will be
    expected ones, as they'll receive the error from an external source.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些错误中的大多数将与外部服务（从引发错误的一方来看）有关，这些服务表现不佳。这可能表明存在网络问题、配置错误或其他服务的问题。错误在系统中传播并不罕见，因为一个错误可能会引发级联故障。通常，尽管如此，起源将是意外错误，其余的将是预期的错误，因为它们将从外部来源接收错误。
- en: '**Unexpected errors**. The sign of these errors are logs indicating that something
    has gone wrong, and in most modern programming languages, a stack trace of some
    sort in the logs detailing the line of code when the error was produced.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**意外错误**。这些错误的标志是日志表明出了问题，并且在大多数现代编程语言中，日志中会有某种形式的堆栈跟踪，详细说明了错误产生时的代码行。'
- en: By default, any kind of framework that executes tasks, like a web framework
    or task management system, will produce an error, but keep the system stable.
    This means that only the task producing the error will be interrupted and any
    new task will be handled from scratch.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，任何执行任务的框架，如Web框架或任务管理系统，都会产生错误，但保持系统稳定。这意味着只有产生错误的任务会被中断，任何新的任务都将从头开始处理。
- en: The system should provide the proper handling for the task. For example, a web
    server will return a 500 error, and a task management system may retry the task
    after some delay. This may lead to the error being propagated, as we saw before.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应该为任务提供适当的处理。例如，一个网络服务器将返回500错误，而一个任务管理系统可能会在延迟后重试任务。这可能导致错误像我们之前所见的那样被传播。
- en: In any of the two cases, the main tool to detect what the problem was will be
    logs. Either the logs show a known problem that is captured and properly labeled,
    or the logs show a stack trace that should indicate what specific part of the
    code is showing the error.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何一种情况下，检测问题的主要工具将是日志。要么日志显示一个已知的问题，该问题已被捕获并正确标记，要么日志显示一个堆栈跟踪，这应该表明代码的哪个具体部分正在显示错误。
- en: Finding the element and part of the code that is the source of the error is
    important for understanding the problem and for debugging the specific problem.
    This is particularly important in microservices architectures, as they'll have
    multiple independent elements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 找到错误源和代码中的具体部分对于理解问题和调试特定问题非常重要。这在微服务架构中尤为重要，因为它们将具有多个独立元素。
- en: We talked about microservices and monolithic architectures in *Chapter 9*,*Microservices
    vs Monolith*. Monoliths are easier to deal with in terms of bugs, as all the code
    is handled on the same site, but anyway they'll become more and more complex as
    they grow.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第9章*，“微服务与单体架构”中讨论了微服务和单体架构。在处理错误方面，单体架构更容易处理，因为所有代码都在同一地点处理，但无论如何，随着其增长，它们将变得越来越复杂。
- en: Keep in mind that sometimes it is not possible to totally avoid errors. For
    example, if there's an external dependency calling an external API and it has
    a problem, this may trigger internal errors. These can be mitigated, failing gracefully,
    or generating a state of "service not available." But the root of the error may
    not be possible to fix totally.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，有时完全避免错误是不可能的。例如，如果有一个外部依赖调用外部API并且出现问题，这可能会触发内部错误。这些问题可以通过优雅地失败或生成“服务不可用”的状态来缓解。但错误的根源可能无法完全修复。
- en: Mitigating external dependencies may require creating redundancy, even using
    different suppliers so as not to be dependent on a single point of failure, though
    this may not be realistic, as it can be extremely costly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解外部依赖可能需要创建冗余，甚至使用不同的供应商，以便不依赖于单一故障点，尽管这可能并不现实，因为这可能非常昂贵。
- en: We can have these cases be notified to us, but they won't require further short-term
    action.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些情况通知我们，但它们不会要求采取进一步的短期行动。
- en: In other cases, when the error is not immediately obvious and further investigation
    needs to be done, it will require some debugging.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，当错误不是立即明显的并且需要进一步调查时，将需要进行一些调试。
- en: Understanding the problem in production
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解生产中的问题
- en: The challenge in complex systems is the fact that detecting problems becomes
    exponentially more complicated. As multiple layers and modules are added and interact
    with each other, bugs become potentially more subtle and more complex.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂系统中，挑战在于检测问题变得指数级复杂。随着多个层和模块被添加并相互交互，错误可能变得更加微妙和复杂。
- en: As we saw before, microservice architectures can be especially difficult to
    debug. The interaction between different microservices can produce complex interactions
    that can produce subtle problems in the integration of its different parts. This
    integration can be difficult to test in integration tests, or perhaps the source
    of the problem is in a blind spot of the integration tests.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，微服务架构可能特别难以调试。不同微服务之间的交互可能会产生复杂的交互，这可能导致其不同部分的集成中出现微妙的问题。这种集成在集成测试中可能很难测试，或者问题的源头可能位于集成测试的盲点中。
- en: But monoliths can also have problems as their parts grow more complex. Difficult
    bugs may be produced due to the interaction of specific production data that interacts
    in an unexpected way. A big advantage of monolithic systems is that the tests
    will cover the whole system, making it easier to replicate with unit or integration
    tests.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但随着其部分变得更加复杂，单体架构也可能出现问题。由于特定生产数据以意想不到的方式交互，可能会产生难以发现的错误。单体系统的一个大优点是测试将覆盖整个系统，这使得通过单元测试或集成测试进行复现变得更加容易。
- en: The objective in this step, though, should be to analyze enough of the problem
    in production to be able to replicate it in a local environment, where the smaller
    scale of the environment will make it easier and less invasive to probe and make
    changes. Once enough information has been collected, it's better to leave any
    production environment alone and focus on the specifics of the problem.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个步骤中，目标应该是分析足够的生产环境中的问题，以便能够在本地环境中复制它，因为环境的较小规模将使其更容易和更少侵入性地进行探测和更改。一旦收集到足够的信息，最好让任何生产环境保持原样，并专注于问题的具体细节。
- en: Remember that having a replicable bug is more than half the battle! Once the
    problem can be categorized as a replicable set of steps locally, a test can be
    created to produce it over and over and debug in a controlled environment.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，拥有可复制的错误已经超过了一半的战斗！一旦问题可以归类为本地可复制的步骤集，就可以创建一个测试来反复产生它，并在受控环境中调试。
- en: Sometimes, general logging enabled is enough to determine exactly what the bug
    is or how to replicate it locally. In those cases, it may be necessary to research
    the circumstances that trigger the problem.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，启用通用日志记录就足以确定确切是什么错误或如何在本地复制它。在这些情况下，可能需要研究触发问题的环境。
- en: Logging a request ID
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录请求ID
- en: One of the problems when analyzing a large number of logs is correlating them.
    To properly group logs that are related to each other, we could filter by the
    host that generates them and select a short window of time, but even that may
    not be good enough as two or more different tasks can be running at the same time.
    We need a unique identifier per task or request that can trace all logs coming
    from the same source. We will call this identifier a request ID, as they are added
    automatically in many frameworks. This sometimes is called a task ID in task managers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 分析大量日志时遇到的一个问题是关联它们。为了正确地将相关的日志分组，我们可以通过生成它们的宿主机进行过滤，并选择一个短时间窗口，但即使这样可能也不够好，因为可能同时运行两个或更多不同的任务。我们需要每个任务或请求的唯一标识符，以便跟踪来自同一来源的所有日志。我们将此标识符称为请求ID，因为它们在许多框架中是自动添加的。这有时在任务管理器中被称为任务ID。
- en: In cases where multiple services are involved, like in microservice architectures,
    it is very important to keep a common request ID that can work to trace the different
    requests between different services. That allows you to follow and correlate different
    logs in the system from different services that have the same origin.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及多个服务的情况下，例如在微服务架构中，保持一个通用的请求ID非常重要，它可以用于跟踪不同服务之间的不同请求。这允许您跟踪和关联来自具有相同来源的不同服务的不同日志。
- en: The following diagram shows the flow between a frontend and two backend services
    that are called internally. Note that the `X-Request-ID` header is set by the
    frontend and it's forwarded to service A, which then forwards it toward service
    B.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了前端和两个内部调用的后端服务之间的流程。请注意，`X-Request-ID`头由前端设置，并将其转发到服务A，然后服务A将其转发到服务B。
- en: '![A picture containing diagram'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![包含图表的图片'
- en: Description automatically generated](img/B17580_15_01.png)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_15_01.png)
- en: 'Figure 15.1: Request ID across multiple services'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：多个服务之间的请求ID
- en: Because all of them share the same request ID, logs can be filtered by that
    information to obtain all the information about a single task.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们都共享相同的请求ID，所以可以通过该信息过滤日志，以获取单个任务的所有信息。
- en: To achieve this, we can use the module `django_log_request_id` to create a request
    ID in Django applications.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以使用模块`django_log_request_id`在Django应用程序中创建请求ID。
- en: 'You can see the whole documentation here: [https://github.com/dabapps/django-log-request-id/](https://github.com/dabapps/django-log-request-id/).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处查看完整文档：[https://github.com/dabapps/django-log-request-id/](https://github.com/dabapps/django-log-request-id/)。
- en: We show some code in GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_15_debug](https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_15_debug)
    following the example across the book. This requires creating a virtual environment
    and installing the package, alongside the rest of the requirements.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在GitHub上展示了部分代码，地址为[https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_15_debug](https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_15_debug)，按照书中的示例进行。这需要创建一个虚拟环境并安装该包，以及其余的要求。
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code has been changed to include some extra logs in the `microposts/api/views.py`
    file (as seen at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/microposts/api/views.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/microposts/api/views.py)):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 代码已被修改，在`microposts/api/views.py`文件中包含了一些额外的日志（如[https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/microposts/api/views.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/microposts/api/views.py)所示）：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note how this is now adding some logs when accessing the list collections page
    and the individual micropost page. We will use the example URL `/api/users/jaime/collection/5`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在在访问列表集合页面和单个micropost页面时添加了一些日志。我们将使用示例URL `/api/users/jaime/collection/5`。
- en: 'To enable the usage of the request ID, we need to properly set up the configuration
    in `microposts/settings.py` ([https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/microposts/microposts/settings.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/microposts/microposts/settings.py)):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用请求ID的使用，我们需要在`microposts/settings.py`中正确设置配置（[https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/microposts/microposts/settings.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/microposts/microposts/settings.py)）：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `LOGGING` dictionary is a characteristic in Django that describes how to
    log. `filters` adds extra information, in this case, our `request_id`, `formatter`
    describes the specific format to use (note that we add `request_id` as a parameter,
    which will be presented in brackets).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOGGING`字典是Django的一个特性，用于描述如何进行日志记录。`filters`添加了额外的信息，在这种情况下，我们的`request_id`，`formatter`描述了要使用的特定格式（注意，我们将`request_id`作为一个参数添加，它将以括号的形式呈现）。'
- en: '`handlers` describes what happens to each message, joining `filters` and `formatter`
    with information about levels to display and where to send the info. In this case,
    `StreamHandler` will send the log to `stdout`. We set all the logs on the `root`
    level to use this `handler`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`handlers`描述了每个消息的处理方式，将`filters`和`formatter`与显示级别和发送信息的位置的信息结合起来。在这种情况下，`StreamHandler`将日志发送到`stdout`。我们将所有日志的`root`级别设置为使用此`handler`。'
- en: 'Check the Django documentation for more information: [https://docs.djangoproject.com/en/3.2/topics/logging/](https://docs.djangoproject.com/en/3.2/topics/logging/).
    Logging in Django may take a bit of experience in setting all the parameters correctly.
    Take your time when configuring it.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅Django文档以获取更多信息：[https://docs.djangoproject.com/en/3.2/topics/logging/](https://docs.djangoproject.com/en/3.2/topics/logging/)。在Django中进行日志记录可能需要对设置所有参数的正确性有一些经验。配置时请耐心。
- en: The lines,
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行，
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: state that a new `Request ID` parameter should be created if not found as a
    header in the input and that the name of the header will be `X-Request-ID`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在输入中没有找到作为头部的`Request ID`参数，则应创建一个新的参数，该参数的名称为`X-Request-ID`。
- en: 'Once all of this is configured, we can run a test starting the server with:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些配置完成，我们可以通过以下命令启动服务器来运行测试：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On another screen, make a call to the test URL with `curl`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个屏幕上，使用`curl`调用测试URL：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At the same time, you''ll see the logs on the server screen:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，你会在服务器屏幕上看到日志：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Which, as you can see, added a new request ID element, `66e9f8f1b43140338ddc3ef569b8e845`
    in this case.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，添加了一个新的请求ID元素，在这个例子中是`66e9f8f1b43140338ddc3ef569b8e845`。
- en: But the request ID can also be created by calling with the proper header. Let's
    try again, making another `curl` request and the `-H` parameter to add a header.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但请求ID也可以通过调用并使用正确的头部来创建。让我们再次尝试，通过另一个`curl`请求和`-H`参数添加一个头部。
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can check the logs in the server again:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在服务器上再次检查日志：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This shows that the request ID has been set by the value in the header.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明请求ID已经通过头部中的值设置。
- en: The request ID can be passed over other services by using the `Session` included
    in the same module, which acts as a `Session` in the `requests` module.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用同一模块中包含的`Session`将请求ID传递到其他服务，它充当`requests`模块中的`Session`。
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will set the proper header in the request, passing through it to the next
    step of the chain, like service A or service B.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在请求中设置正确的头部，并通过它传递到链的下一个步骤，如服务A或服务B。
- en: Be sure to check the `django-log-request-id` documentation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要检查`django-log-request-id`的文档。
- en: Analyzing data
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析数据
- en: If the default logs are not enough to understand the problem, the next stage
    in those cases is understanding the data related to the problem. Typically, the
    data storage may be inspected to follow up on the related data for the task, to
    see if there's any indication about that.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认日志不足以理解问题，那么在这些情况下，下一步是理解与问题相关的数据。通常，数据存储可能需要被检查，以追踪与任务相关的数据，看看是否有任何迹象。
- en: This step may be complicated by either missing data or data restrictions that
    make it difficult or impossible to obtain the data. Sometimes only a few people
    in the organization can access the required data, which may delay the investigation.
    Another possibility is that the data is impossible to retrieve. For example, data
    policies may not store the data, or the data may be encrypted. This is a regular
    occurrence in cases involving **Personally Identifiable Information** (**PII**),
    passwords, or similar data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤可能会因为数据缺失或数据限制而变得复杂，这些限制使得获取数据变得困难或不可能。有时，组织中只有少数人可以访问所需的数据，这可能会延迟调查。另一种可能是数据无法检索。例如，数据政策可能不会存储数据，或者数据可能被加密。这在涉及**个人身份信息**（**PII**）、密码或类似数据的情况下是一个常见现象。
- en: Analyzing the stored data may require performing ad hoc manual queries to databases
    or other kinds of data storage to find out if the related data is consistent or
    if there is any combination of parameters that's not expected.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 分析存储的数据可能需要执行临时的手动查询到数据库或其他类型的数据存储，以找出相关数据是否一致，或者是否存在任何不期望的参数组合。
- en: Remember that the objective is to capture information from production to be
    able to understand and replicate the problem independently.In some cases, when
    investigating a problem in production, it is possible that changing the data manually
    will fix the issue. This could be necessary in some emergency situations, but
    the objective still needs to be to understand why this inconsistent situation
    of the data has been possible or how the service should be changed to allow you
    to deal with this data situation. Then the code can be changed accordingly to
    ensure that the problem doesn't happen in the future.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，目标是捕获生产中的信息，以便能够独立理解和复制问题。在某些情况下，当调查生产中的问题时，手动更改数据可能会解决问题。这可能在某些紧急情况下是必要的，但目标仍然是理解为什么这种数据不一致的情况是可能的，或者服务应该如何改变以允许你处理这种数据情况。然后，代码可以相应地更改，以确保问题在未来不会发生。
- en: If investigating the data is not enough to be able to understand the problem,
    it may be necessary to increase the information on the logs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调查数据不足以理解问题，可能有必要增加日志上的信息。
- en: Increasing logging
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增加日志
- en: If the regular logs and an investigation of the data don't bear fruit, it may
    be necessary to increase the level of logging with special logs, following the
    problem.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果常规日志和数据调查没有结果，可能有必要通过特殊日志提高日志级别，以追踪问题。
- en: 'This is a last-resort method, because it has two main problems:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个最后的手段，因为它有两个主要问题：
- en: Any change in the logs needs to be deployed, which makes it costly and expensive
    to run.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何日志的变化都需要部署，这使得运行成本高昂。
- en: The number of logs in the system will be incremented, which will require more
    space to store them. Depending on the number of requests in the system, this can
    create pressure on the logging system.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中的日志数量将会增加，这将需要更多的空间来存储它们。根据系统中的请求数量，这可能会对日志系统造成压力。
- en: These extra logs should always be short term, and should be reverted as soon
    as possible.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的日志应该始终是短期的，并且应该尽快撤销。
- en: While enabling an extra level of logging, like setting logs to `DEBUG` level,
    is technically possible, this will probably increase the logs too much, and will
    make it difficult to know what the key ones are in the massive amount of logs.
    With some `DEBUG` logs, specifics of the area under investigation can be temporally
    promoted to `INFO` or higher to make sure that they are properly logged.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然启用额外的日志级别，如将日志设置为`DEBUG`级别，在技术上是可以实现的，但这可能会产生过多的日志，使得在大量日志中确定关键日志变得困难。在一些`DEBUG`日志中，调查区域的详细信息可以临时提升到`INFO`或更高级别，以确保它们被正确记录。
- en: Be extra careful with information that's logged temporally. Confidential information
    like PII should not be logged. Instead, try to log surrounding information that
    can help find out the problem.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对临时记录的信息要格外小心。像PII这样的机密信息不应被记录。相反，尝试记录周围的信息，这些信息有助于找出问题。
- en: For example, if there's a suspicion that some unexpected character may be producing
    a problem with the algorithm to check the password, instead of logging the password,
    some code can be added to detect whether there's an invalid character.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果有怀疑某些意外的字符可能正在导致密码检查算法出现问题，而不是记录密码，可以添加一些代码来检测是否存在无效字符。
- en: 'For example, assuming there''s a problem with a password or secret that has
    an emoji, we could extract only non-ASCII characters to find out if this is the
    problem, like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设有一个密码或秘密包含表情符号的问题，我们可以提取仅非ASCII字符来找出这是否是问题，如下所示：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The value in `bad_characters` can be then logged, as it won't contain the full
    password.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 可以记录`bad_characters`中的值，因为它不会包含完整的密码。
- en: Note that this assumption is probably easier to test quickly and without any
    secret data with a unit test. This is just an example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个假设可能更容易通过单元测试快速测试，而不需要任何秘密数据。这只是一个例子。
- en: Adding temporal logs is cumbersome, as it typically will involve several deployments
    until finding out the problem. It's always important to keep the number of logs
    to a minimum, cleaning up the useless ones as quickly as possible, and remember
    to remove them completely after the work is done.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 添加临时日志很麻烦，因为它通常需要几次部署才能找出问题。始终重要的是将日志数量保持在最低，尽快清理无用的日志，并在工作完成后完全删除它们。
- en: Remember that the work is just to be able to reproduce the problem locally,
    so you can more efficiently investigate and fix the problem locally. Sometimes
    the problem may be deemed obvious after some temporal log, but, good TDD practice,
    as we saw in *Chapter 10*, *Testing and TDD*, tests displaying and then fixing
    the bug.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，工作的目的仅仅是为了能够本地复现问题，这样你就可以更有效地本地调查和修复问题。有时，在查看一些临时日志后，问题可能显得很明显，但，良好的TDD实践，正如我们在第10章“测试和TDD”中看到的，是显示并修复bug。
- en: Once we can detect the problem locally, it is time to go to the next step.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们可以在本地检测到问题，就是进行下一步的时候了。
- en: Local debugging
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地调试
- en: Debugging locally means exposing and fixing a problem once we have a local reproduction.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本地调试意味着在我们有了本地复现之后，暴露并修复一个问题。
- en: The basic steps of debugging are reproducing the problem, knowing what the current,
    incorrect result is, and knowing what the correct result should be. With that
    information, we can start debugging.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 调试的基本步骤是复现问题，了解当前的不正确结果是什么，以及正确的预期结果应该是什么。有了这些信息，我们就可以开始调试。
- en: A great way of creating the reproduction of the problem is with a test, if that's
    possible. As we saw in *Chapter 10*, *Testing and TDD*, this is the basis of TDD.
    Create a test that fails and then change the code to make it pass. This approach
    is very usable when fixing bugs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个创建问题复现的好方法是通过测试，如果可能的话。正如我们在第10章“测试和TDD”中看到的，这是TDD的基础。创建一个失败的测试，然后修改代码使其通过。这种方法在修复bug时非常实用。
- en: 'Taking a step back, any debugging process follows the following process:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，任何调试过程都遵循以下过程：
- en: You realize there's a problem
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你意识到有问题
- en: You understand what the correct behavior should be
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你理解了正确的行为应该是什么
- en: You investigate and discover why the current system behaves incorrectly
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你调查并发现为什么当前系统表现不正确
- en: You fix the problem
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你修复了问题
- en: Keeping this process in mind is also useful from a local debugging perspective,
    though at this point, it is likely that *steps 1* and *2* are already sorted out.
    In the vast majority of cases, the difficult step is *3*, as we've been seeing
    throughout the chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从本地调试的角度来看，记住这个过程也是有用的，尽管在这个阶段，*步骤1*和*步骤2*可能已经解决了。在大多数情况下，困难的是*步骤3*，正如我们在本章中看到的。
- en: 'To understand, once presented with the code, *why* the code is behaving as
    it is, a method similar to the scientific method can be used to systematize the
    approach:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解，一旦提供了代码，*为什么*代码会以这种方式表现，可以使用类似于科学方法的步骤来系统化地处理：
- en: Measure and observe the code
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量和观察代码
- en: Produce a hypothesis on why a certain result is being produced
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对产生某个结果的原因提出一个假设
- en: Validate or disprove the hypothesis by either analyzing the produced state,
    if possible, or creating a specific "experiment" (some specific code, like a test)
    to force it to be produced
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过分析产生的状态（如果可能）或创建一个特定的“实验”（一些特定的代码，如测试）来验证或反驳假设，以强制产生该状态
- en: Use the resulting information to iterate the process until the source of the
    problem is totally understood
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用得到的信息迭代这个过程，直到完全理解问题的根源
- en: Note that this process doesn't necessarily need to be applied to the whole problem.
    It can be focused on the specific parts of the code that can influence the problem.
    For example, is this setting activated in this case? Is this loop in the code
    being accessed? Is the value calculated lower than a threshold, which will later
    send us down a different code path?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个过程不一定需要应用到整个问题上。它可以集中在可能影响问题的代码的特定部分。例如，这个设置在这个情况下是否被激活了？代码中的这个循环是否被访问了？计算出的值是否低于阈值，这将会让我们走上一条不同的代码路径？
- en: All those answers will increase the knowledge of why the code is behaving in
    the way that it's behaving.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些答案都会增加我们对代码为何以这种方式运行的了解。
- en: Debugging is a skill. Some people may say it's an art. In any case, it can be
    improved over time, as more time gets invested in it. Practice plays an important
    role in developing the kind of intuition that involves knowing when to take a
    deeper look into some areas over others to identify the promising areas where
    the code may be failing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是一项技能。有些人可能会说它是一门艺术。无论如何，随着时间的推移，它可以得到改善，因为更多的精力投入其中。练习在培养涉及知道何时深入某些区域而忽略其他区域以识别代码可能失败的潜在区域这种直觉方面起着重要作用。
- en: 'There are some general ideas that can be very helpful when approaching debugging:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理调试问题时，有一些一般性的想法可能会非常有帮助：
- en: '**Divide and conquer**. Take small steps and isolate areas of the code so it''s
    possible to simplify the code and make it digestible. As important as understanding
    when there''s a problem in the code is detecting when there isn''t so we can set
    our focus on the relevant bits.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分而治之**。采取小步骤，隔离代码的各个区域，这样就可以简化代码并使其易于理解。理解代码中存在问题的重要性与检测没有问题同样重要，这样我们就可以将注意力集中在相关部分。'
- en: 'Edward J. Gauss described this method in what he called the "**wolf fence algorithm**"
    in a 1982 article:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 爱德华·J·高斯在1982年的一篇文章中描述了这种方法，他称之为“**狼栅栏算法**”：
- en: '*There''s one wolf in Alaska; how do you find it? First build a fence down
    the middle of the state, wait for the wolf to howl, determine which side of the
    fence it is on. Repeat process on that side only, until you get to the point where
    you can see the wolf*.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*阿拉斯加有一只狼；你怎么找到它？首先在州的中部建一个栅栏，等待狼嚎叫，确定它在栅栏的哪一侧。只在那一边重复这个过程，直到你能看到狼*。'
- en: '**Move backward from the visible error**. It''s quite common that the source
    of a problem is not where an error is raised or obvious, but instead the error
    was produced earlier. A good approach is to move backward from the position where
    the problem is obvious and then validate the flow. This allows you to ignore all
    code that comes *after* the problem, and have a clear path of analysis.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从可见的错误回溯**。通常情况下，问题的源头并不是错误发生的地方或明显的地方，而是错误在之前就已经产生了。一个好的方法是从问题明显的地方回溯，然后验证流程。这允许你忽略所有在问题之后出现的代码，并有一个清晰的路径进行分析。'
- en: '**You can make an assumption, as long as you can then prove that this assumption
    is correct.** Code is complex, and you won''t be able to keep the whole codebase
    in your head. Instead, focus needs to be carefully moved across different parts,
    making assumptions about what the rest is returning.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你可以做出一个假设，只要你能证明这个假设是正确的**。代码很复杂，你不可能把整个代码库都记在脑子里。相反，需要仔细地将注意力转移到不同的部分，对其他部分返回的内容做出假设。'
- en: 'As Sherlock Holmes once said:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如福尔摩斯曾说过：
- en: '*When you have eliminated the impossible, whatever remains, however improbable,
    must be the truth*.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你排除了所有不可能的情况后，无论多么不可能，剩下的就是真相*。'
- en: Properly eliminating everything can be arduous, but removing proven assumptions
    from the mind will reduce the amount of code to analyze and verify.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正确地消除所有东西可能很困难，但将已证实的假设从脑海中移除将减少需要分析和验证的代码量。
- en: But those assumptions need to be validated to really prove that they are correct,
    or we risk the chance of making a wrong assumption. It's very easy to fall into
    bad assumptions and think that the problem is in a particular part of the code
    when it really is in another.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但那些假设需要得到验证，才能真正证明它们是正确的，否则我们可能会冒出错误的假设。很容易陷入错误的假设，认为问题出在代码的某个特定部分，而实际上问题可能出在其他地方。
- en: Though the whole range of techniques and possibilities of debugging is there,
    and certainly sometimes bugs can be convoluted and difficult to detect and fix,
    most bugs are typically easy to understand and fix. Perhaps they are a typo, an
    off-by-one error, or a type error that needs to be checked.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管调试的所有技术和可能性都在那里，而且确实有时错误可能很复杂，难以检测和修复，但大多数错误通常很容易理解和修复。也许它们是一个打字错误，一个加一错误，或者需要检查的类型错误。
- en: Keeping the code simple helps a lot in later debugging problems. Simple code
    is easy to understand and debug.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 保持代码简单对于后续的调试问题有很大帮助。简单的代码易于理解和调试。
- en: Before we move on to specific techniques, we need to understand the tools in
    Python help in our investigation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论具体技术之前，我们需要了解Python中的工具如何帮助我们进行调查。
- en: Python introspection tools
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python内省工具
- en: As Python is a dynamic language, it's very flexible and allows you to perform
    actions on its objects to discover their properties or types.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python是一种动态语言，它非常灵活，允许你对其对象执行操作以发现它们的属性或类型。
- en: This is called *introspection*, and allows you to inspect elements without having
    too much context about the objects to be inspected. This can be performed at runtime,
    so it can be used while debugging to discover the attributes and methods of any
    object.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*内省*，允许你在不需要太多关于要检查的对象的上下文的情况下检查元素。这可以在运行时执行，因此可以在调试时使用，以发现任何对象的属性和方法。
- en: 'The main starting point is the `type` function. The `type` function simply
    returns the class of an object. For example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的起点是`type`函数。`type`函数简单地返回对象的类。例如：
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This can be used to double-check that an object is of the expected `type`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来再次确认对象是否为预期的`type`。
- en: A typical example error is to have a problem because a variable can be either
    an object or `None`. In that case, it's possible that a mistake handling the variable
    makes it necessary to double-check that the type is the expected one.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的错误示例是，由于一个变量可以是对象或`None`，因此可能存在一个问题。在这种情况下，处理变量的错误可能需要我们再次检查类型是否为预期的类型。
- en: While `type` is useful in debugging environments, avoid using it directly in
    your code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`type`在调试环境中很有用，但请避免直接在代码中使用它。
- en: 'For example, avoid comparing defaults of `None`, `True`, and `False` with their
    types, as they are created as singletons. That means there''s a single instance
    of each of these objects, so every time that we need to verify if an object is
    `None`, it''s better to make an identity comparison, like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，避免将`None`、`True`和`False`的默认值与它们的类型进行比较，因为它们作为单例创建。这意味着每个这些对象只有一个实例，所以每次我们需要验证一个对象是否为`None`时，最好进行身份比较，如下所示：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Identity comparisons can prevent the kind of problem where the usage of `None`
    or `False` can't be distinguished in an `if` block.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 身份比较可以防止在`if`块中无法区分`None`或`False`的使用所引起的问题。
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Instead, only checking against the identity comparison will allow you to detect
    only the value of `None` properly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，仅通过身份比较才能正确检测`None`的值。
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The same can be used for Boolean values.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以用于布尔值。
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For other cases, there''s the `isinstance` function, which can be used to find
    if a particular object is an instance of a particular class:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他情况，有`isinstance`函数，它可以用来检查一个特定对象是否是特定类的实例：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is better than making comparisons with `type`, because it is aware of any
    inheritance that may have been produced. For example, in the following code we
    see how an object from a class that inherits from another will return that it's
    an instance of either, while the `type` function will only return one.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这比使用`type`进行比较更好，因为它了解可能产生的任何继承。例如，在以下代码中，我们看到一个从继承自另一个类的类创建的对象将返回它是任一类的实例，而`type`函数只会返回一个。
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The most useful function for introspection, though, is `dir`. `dir` allows you
    to see all the methods and attributes in an object, and it's particularly useful
    when analyzing objects from a not-clear origin, or where the interface is not
    clear.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最实用的内省函数是`dir`。`dir`允许你查看对象中的所有方法和属性，当分析来源不明确或接口不明确的对象时尤其有用。
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Obtaining the whole attributes can be a bit too much in certain situations,
    so the returned values can filter out the double-underscore ones to reduce the
    amount of noise and be able to detect attributes that can give some clue about
    the object usage more easily.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，获取所有属性可能会有些过多，因此返回的值可以过滤掉双下划线的属性，以减少噪声的数量，并能够更容易地检测到可以给出关于对象使用线索的属性。
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Another interesting function is `help`, which displays the help from objects.
    This is particularly helpful for methods:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的功能是`help`，它显示对象的帮助信息。这对于方法特别有帮助：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This function displays the defined `docstring` from the object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能显示对象的定义`docstring`。
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All these methods can help you navigate code that's new or under analysis without
    being an expert, and avoid many checks with code that can be hard to search through.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都可以帮助您在不成为专家的情况下导航新代码或正在分析的代码，并避免许多难以搜索的代码检查。
- en: 'Adding sensible `docstrings` is a great help not only for keeping the code
    well commented and adding context for developers working in the code, but also
    in case of debugging in parts where the function or object is used. You can learn
    more about `docstrings` in the PEP 257 document: [https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 添加合理的`docstrings`不仅有助于保持代码注释良好并为在代码中工作的开发者提供上下文，而且在调试函数或对象使用的地方时也非常有帮助。您可以在PEP
    257文档中了解更多关于`docstrings`的信息：[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)。
- en: Using these tools is good, but let's see how we can understand the behavior
    of the code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些工具是好的，但让我们看看我们如何理解代码的行为。
- en: Debugging with logs
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用日志进行调试
- en: A simple yet effective way of detecting what's going on and how the code is
    being executed is adding comments that are displayed either containing statements
    like `starting the loop here` or including values of variables like `Value of
    A = X`. By strategically locating these kinds of outputs, the developer can understand
    the flow of the program.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 添加注释是一种简单而有效的方法，可以检测正在发生的事情以及代码是如何执行的。这些注释可以是显示包含类似`在这里开始循环`的语句或包括变量值，如`A的值
    = X`。通过战略性地定位这些类型的输出，开发者可以理解程序的流程。
- en: We touched on this earlier in this chapter as well as in *Chapter 10*, *Testing
    and TDD*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章以及*第10章，测试和TDD*中已经提到了这一点。
- en: The simplest form of this approach is **print debugging**. It consists of adding
    `print` statements to be able to watch the output from them, normally while executing
    the code locally in a test or similar.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的最简单形式是**打印调试**。它包括添加`print`语句，以便能够监视它们的输出，通常是在本地执行代码时在测试或类似环境中进行。
- en: Print debugging can be considered a bit controversial to some people. It has
    been around for a long time, and it's considered a crude way of debugging. In
    any case, it can be very quick and flexible and can fit some debug cases very
    well, as we will see.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 打印调试可能对某些人来说有点争议。它已经存在很长时间了，被认为是一种粗略的调试方式。无论如何，它可能非常快速和灵活，并且可以很好地适应一些调试案例，正如我们将看到的。
- en: Obviously, these `print` statements need to be removed after the process has
    been finished. One of the main complaints about this technique is precisely this,
    that there's a chance that some `print` statements intended for debugging are
    not removed, and it's a common mistake.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些`print`语句在过程完成后需要被删除。关于这种技术的主要抱怨正是这一点，即有可能会遗漏一些用于调试的`print`语句，这是一个常见的错误。
- en: This can be refined, though, by instead of directly using `print` statements,
    using logs instead, as we introduced in *Chapter 12*, *Logging*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可以通过使用日志而不是直接使用`print`语句来改进这一点，正如我们在*第12章，日志*中介绍的。
- en: Ideally, these logs will be `DEBUG` logs, which will only be displayed when
    running tests, but won't be produced in a production environment.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，这些日志将是`DEBUG`日志，它们仅在运行测试时显示，但在生产环境中不会生成。
- en: While logs can be added and not produced later, it's good practice anyway to
    remove any spurious logs after fixing the bug. Logs can accumulate and there will
    be an excessive amount of them unless they are periodically taken care of. It
    can be difficult to find information in a big wall of text.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然日志可以添加而不在以后生成，但修复错误后删除任何虚假日志是良好的实践。日志会积累，如果不定期处理，将会出现过多的日志。在大量文本中查找信息可能会很困难。
- en: The advantage of this method is that it can be done quickly and it can also
    be used to explore logs that can then be promoted to permanent ones, once adapted.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是它可以快速完成，还可以用来探索日志，一旦适应后，可以将这些日志提升为永久日志。
- en: Another important advantage is that tests can be run very quickly, as adding
    more logs is a simple operation, and logs won't interfere with the execution of
    code. This makes it a good combination to use with TDD practices.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要优势是测试可以非常快速地运行，因为添加更多日志是一个简单的操作，日志不会干扰代码的执行。这使得它与 TDD 实践相结合成为一个很好的选择。
- en: The fact that the logs won't interfere with the code and code can be running
    unaffected can make some difficult bugs based on concurrency easier to debug,
    as interrupting the flow of the operation in those cases will affect the behavior
    of the bug.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 日志不会干扰代码，并且代码可以不受影响地运行，这使得基于并发的某些难以调试的bug更容易调试，因为在这些情况下中断操作流程将影响bug的行为。
- en: Concurrent bugs can be quite complicated. They are produced when two independent
    threads interact in an unexpected way. Because of the uncertain nature of what
    one thread will start and stop or when an action from one thread will affect the
    other, they normally require extensive logs to try to capture the specifics of
    that problem.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 并发bug可能相当复杂。它们是在两个独立的线程以意想不到的方式交互时产生的。由于一个线程将开始和停止什么或一个线程的动作何时会影响另一个线程的不确定性，它们通常需要大量的日志来尝试捕捉那个问题的具体细节。
- en: While debugging through logs can be quite convenient, it requires certain knowledge
    of where and what logs to set to obtain the relevant information. Anything not
    logged won't be visible in the next run. This knowledge can come through a discovery
    process and take time to pinpoint the relevant information that will lead to fixing
    the bug.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通过日志进行调试可能非常方便，但它需要一定的知识，了解在哪里设置什么日志以获取相关信息。任何未记录的内容在下次运行时都不会可见。这种知识可能来自于一个发现过程，并且需要时间来定位将导致修复bug的相关信息。
- en: Another problem is that new logs are new code, and they can create problems
    if there are errors introduced like bad assumptions or typos. This will normally
    be easy to fix, but can be an annoyance and require a new run.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是新日志是新代码，如果引入了错误，如错误的假设或打字错误，它们可能会引起问题。这通常很容易修复，但可能会造成不便并需要重新运行。
- en: Remember that all introspection tools that we talked about before in the chapter
    are available.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们在本章之前讨论的所有内省工具都可用。
- en: Debugging with breakpoints
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用断点进行调试
- en: In other situations, it's better to stop the execution of the code and take
    a look at the current status. Given that Python is a dynamic language, it means
    that, if we stop the execution of the script and enter the interpreter, we can
    run any kind of code and see its results.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，最好停止代码的执行并查看当前状态。鉴于 Python 是一种动态语言，这意味着如果我们停止脚本的执行并进入解释器，我们可以运行任何类型的代码并查看其结果。
- en: This is exactly what is done through the usage of the `breakpoint` function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是通过使用 `breakpoint` 函数所做的事情。
- en: '`breakpoint` is a relatively new addition to Python, available since Python
    3.7\. Previously, it was necessary to import the module `pdb`, typically in this
    way in a single line:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`breakpoint` 是 Python 中相对较新的功能，自 Python 3.7 版本起可用。之前，需要导入模块 `pdb`，通常以这种方式在单行中完成：'
- en: '`import pdb; pdb.set_trace()`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`import pdb; pdb.set_trace()`'
- en: Other than the ease of usage, `breakpoint` has some other advantages that we
    will see.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用方便之外，`breakpoint` 还有一些其他优点，我们将在后面看到。
- en: When the interpreter finds a `breakpoint` call, it stops and opens an interactive
    interpreter. From this interactive interpreter, the current status of the code
    can be examined and any investigation can take place, simply executing the code.
    This makes it possible to understand interactively what the code is doing.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当解释器找到 `breakpoint` 调用时，它会停止并打开一个交互式解释器。从这个交互式解释器中，可以检查代码的当前状态，并进行任何调查，只需简单地执行代码。这使得可以交互式地了解代码正在做什么。
- en: 'Let''s take a look at some code and analyze how it runs. The code can be found
    on GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/debug.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/debug.py)
    and it''s the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些代码并分析它是如何运行的。代码可以在 GitHub 上找到，地址为 [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/debug.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/debug.py)，内容如下：
- en: '[PRE22]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Perhaps you are able to understand what the code does, but let's take a look
    at it interactively. You can check first that all the `assert` statements at the
    end are correct.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你能理解代码的功能，但让我们交互式地看看它。首先，你可以检查末尾的所有`assert`语句是否正确。
- en: '[PRE23]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: But we now introduce a `breakpoint` call before line 9, right at the start of
    the `while` loop.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们现在在第9行之前引入了一个`breakpoint`调用，正好在`while`循环的开始处。
- en: '[PRE24]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Execute the program again and it now stops at that line and presents an interactive
    prompt:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 再次执行程序，它现在会停在那一行并显示一个交互式提示符：
- en: '[PRE25]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Check the value of `candidate` and both operations.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`candidate`的值以及两个操作。
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This line is checking whether dividing `candidate` by `lower` produces an exact
    integer, as in that case both operations will return the same. Execute the next
    line by hitting `n`, from the command `n(ext)`, and check that the loop ends and
    it returns `True`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码正在检查将`candidate`除以`lower`是否产生一个精确的整数，因为在那种情况下，这两个操作将返回相同的值。通过按`n`（即`n(ext)`）命令来执行下一行，并检查循环结束并返回`True`：
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Continue the execution until a new `breakpoint` is found using the command `c`,
    from `c(ontinue)`. Note this happens on the next call to `valid`, which has an
    input of 15.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令`c`（即`c(ontinue)`）继续执行，直到找到新的`breakpoint`。注意这发生在对`valid`的下一个调用上，其输入为15。
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can also use the command `l(ist)` to display the surrounding code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`l(ist)`命令显示周围的代码。
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Continue freely investigating the code. When you are finished, run `q(uit)`
    to exit.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 自由地继续调查代码。当你完成时，运行`q(uit)`以退出。
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After analyzing the code carefully, you probably know what it does. It checks
    whether a number is prime or not by checking if it's divisible by any number lower
    than the number itself.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 经过仔细分析代码后，你可能知道它做什么。它通过检查一个数是否可以被小于它本身的任何数整除来确定这个数是否为素数。
- en: We investigated similar code and improvements in *Chapter 14*, *Profiling*.
    This is, needless to say, not the most efficient way of setting code to check
    this, but it has been added as an example and for teaching purposes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第14章*，*性能分析*中调查了类似的代码和改进。不用说，这不是设置代码检查的最有效方式，但它已被添加为例子以及教学目的。
- en: Another two useful debug commands are `s(tep)`, to get into a function call,
    and `r(eturn)`, to execute the code until the current function returns its execution.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个有用的调试命令是`s(tep)`，用于进入函数调用，和`r(eturn)`，用于执行代码直到当前函数返回其执行。
- en: '`breakpoint` can also be customized to call other debuggers, not only `pdb`.
    There are other debuggers for Python that include more contextual information
    or with more advanced usages, like `ipdb` ([https://pypi.org/project/ipdb/](https://pypi.org/project/ipdb/)).
    To use them, you need to set the `PYTHONBREAKPOINT` environment variable with
    the endpoint for the debugger, after installing the debugger.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`breakpoint`也可以自定义以调用其他调试器，而不仅仅是`pdb`。还有其他Python调试器，它们包括更多上下文信息或更高级的使用，例如`ipdb`([https://pypi.org/project/ipdb/](https://pypi.org/project/ipdb/))。要使用它们，您需要在安装调试器后设置`PYTHONBREAKPOINT`环境变量，并指定调试器的端点。'
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This environment variable can be set to 0 to skip any breakpoint, effectively
    deactivating the debug process: `PYTHONBREAKPOINT=0`. This can be used as a failsafe
    to avoid being interrupted by breakpoint statements that haven''t been properly
    removed, or to quickly run the code without interruptions.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此环境变量可以设置为0以跳过任何断点，从而有效地禁用调试过程：`PYTHONBREAKPOINT=0`。这可以用作安全措施，以避免被未正确删除的断点语句中断，或者快速运行代码而不受干扰。
- en: 'There are multiple debuggers that can be used, including support from IDEs
    like Visual Studio or PyCharm. Here are examples of two other debuggers:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个调试器可以使用，包括来自Visual Studio或PyCharm等IDE的支持。以下是两个其他调试器的示例：
- en: '`pudb` ([https://github.com/inducer/pudb](https://github.com/inducer/pudb)):
    Has a console-based graphical interface and more context around the code and variables'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pudb`([https://github.com/inducer/pudb](https://github.com/inducer/pudb))：具有基于控制台的图形界面，以及关于代码和变量的更多上下文信息'
- en: '`remote-pdb` ([https://github.com/ionelmc/python-remote-pdb](https://github.com/ionelmc/python-remote-pdb)):
    Allows you to debug remotely, connecting to a TCP socket. This allows you to debug
    a program running in a different machine or trigger the debugger in a situation
    where there''s no good access to the `stdout` of the process, for example, because
    it''s running in the background'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remote-pdb`([https://github.com/ionelmc/python-remote-pdb](https://github.com/ionelmc/python-remote-pdb))：允许你远程调试，连接到TCP套接字。这允许你在不同的机器上调试程序，或者在无法访问进程的`stdout`的情况下触发调试器，例如，因为它在后台运行'
- en: Using a debugger properly is a skill that requires time to learn. Be sure to
    try different options and get comfortable with them. Debugging will also be used
    while running tests, as we described in *Chapter 10*, *Testing and TDD*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用调试器是一项需要时间来学习的技能。确保尝试不同的选项，并熟悉它们。调试也会在运行测试时使用，正如我们在第10章*测试和TDD*中描述的那样。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described the general process of detecting and fixing problems.
    When working in complex systems, there's the challenge of properly detecting and
    categorizing the different reports to be sure that they are prioritized. It's
    very important to be able to reliably reproduce the problem in order to show all
    the conditions and context that are producing the issue.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了检测和修复问题的通用过程。当在复杂系统中工作时，存在一个挑战，那就是正确地检测和分类不同的报告，以确保它们得到优先处理。能够可靠地重现问题，以便展示产生问题的所有条件和上下文，这一点非常重要。
- en: Once a problem is deemed important, there needs to be an investigation into
    why this problem is happening. This can be on the running code, and use the available
    tools in production to see if it can be understood why the problem occurs. The
    objective of this investigation is to be able to replicate the problem locally.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个问题被认为很重要，就需要调查为什么会出现这个问题。这可以针对正在运行的代码，并使用生产环境中可用的工具来查看是否可以理解问题发生的原因。这次调查的目标是能够在本地复制这个问题。
- en: Most issues will be easy to reproduce locally and move forward, but we also
    described some tools in case it remains a mystery why the issue is being produced.
    As the main tool to understand the behavior of the code in production is logs,
    we talked about creating a request ID that can help us to trace the different
    calls and relate logs from different systems. We also described how the data in
    the environment may have the key to why the problem is occurring there. If it
    is necessary, the number of logs may need to be increased to extract information
    from production, though this should be reserved for very elusive bugs.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数问题都可以在本地轻松重现并继续前进，但我们还介绍了一些工具，以防问题仍然是个谜。作为理解生产中代码行为的主要工具是日志，我们讨论了创建一个请求ID，这可以帮助我们追踪不同的调用并关联来自不同系统的日志。我们还描述了环境中的数据可能有助于理解问题发生的原因。如果需要，可能需要增加日志的数量来从生产中提取信息，尽管这应该仅限于非常难以追踪的bug。
- en: We then moved on to how to debug locally, after replicating the problem, ideally,
    as we saw in *Chapter 10*, *Testing and TDD*, in the form of a unit test. We gave
    some general ideas to help with debugging, though it must be said that debugging
    is a skill that needs to be practiced.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在复制问题后，理想情况下，如我们在第10章*测试和TDD*中看到的那样，以单元测试的形式讨论了如何在本地进行调试。我们提供了一些一般性的想法来帮助调试，尽管必须说，调试是一项需要练习的技能。
- en: Debugging can be learned and improved, so it's an area where more experienced
    developers can help their junior counterparts. Be sure to create a team where
    it is encouraged to help with debugging when required in difficult cases. Two
    pairs of eyes see more than one!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 调试可以学习和改进，因此这是一个经验丰富的开发者可以帮助初级开发者的领域。确保创建一个团队，在困难情况下需要帮助调试时，鼓励互相帮助。两个眼睛看到的比一个多！
- en: We introduced some of the tools that help with debugging in Python, which make
    use of the possibilities that Python presents for introspection. As Python is
    a dynamic language, there are a lot of possibilities, as it's able to execute
    any code, including all the introspection capabilities.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了一些帮助调试Python的工具，这些工具利用了Python提供的内省可能性。由于Python是一种动态语言，所以有很多可能性，因为它能够执行任何代码，包括所有的内省能力。
- en: We then talked about how to create logs to debug, which is an improved version
    of using `print` statements, and, when done in a systematic way, can help to create
    better logs in the long run. Finally, we moved on to debugging using the `breakpoint`
    function call, which stops the execution of the program and allows you to inspect
    and understand the status at that point, as well as continuing with the flow.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着讨论了如何创建用于调试的日志，这是使用`print`语句的改进版本，并且如果以系统化的方式进行，长期来看可以帮助创建更好的日志。最后，我们转向使用`breakpoint`函数调用来进行调试，这会停止程序的执行，并允许你在那个点检查和理解状态，同时继续执行流程。
- en: In the next chapter, we will talk about the challenges of working in the architecture
    of a system when it's running and needs to be evolved.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论在系统运行并需要演进时在该系统架构中工作的挑战。
