- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generally speaking, the cycle for debugging problems has the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the problem. A new problem or defect is discovered
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analyzing and assigning priority to this problem, to be sure that we spend time
    on meaningful problems and focus on the most important ones
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Investigating what exactly causes the problem. Ideally, this should end with
    a way of replicating the problem in a local environment
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replicating the problem locally, and getting into the specific details on why
    it happens
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fixing the problem
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, the general strategy is to first locate and understand the problem,
    so we can then properly debug and fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics to see effective techniques
    on how to work through all those phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting and processing defects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigation in production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the problem in production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python introspection tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging with logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging with breakpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at the very first step when dealing with defects.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting and processing defects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is actually detecting the problem. This can sound a bit silly,
    but it's a quite crucial stage.
  prefs: []
  type: TYPE_NORMAL
- en: While we will mainly use the term "bug" to describe any defect, remember that
    it may include details like bad performance or unexpected behavior that may not
    be properly categorized as a "bug." The proper tool to fix the problem could be
    different, but the detection is normally done in a similar way.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting problems can be done in different ways, and some may be more evident
    than others. Normally, once the code is in production, defects will be detected
    by a user, either internally (best case) or externally (worst case), or through
    monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that monitoring will only be able to capture obvious, and typically
    serious, errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on how problems are detected, we can categorize them into different severities,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Catastrophic problems** that are completely stopping the operation. These
    bugs mean that nothing, not even non-related tasks in the same system, works'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Critical problems** that stop the execution of some tasks, but not others'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serious problems** that will stop or cause problems with certain tasks, but
    only in some circumstances. For example, a parameter is not checked and produces
    an exception, or some combination produces a task so slow that it produces a timeout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mild problems**, which include tasks containing errors or inaccuracies. For
    example, a task produces an empty result in certain circumstances, or a problem
    in the UI that doesn''t allow calling a functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cosmetic or minor problems** like typos and similar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because every development team is limited, there will always be too many bugs
    and having the proper approach on what to pay attention to and what to fix first
    is critical. Normally bugs in the first group will obviously be quite pressing
    to fix and will require an immediate all-hands reaction. But categorization and
    prioritization are important.
  prefs: []
  type: TYPE_NORMAL
- en: Having a clear signal on what things to look for next will help developers have
    a clear view and be efficient by spending time on important problems and not whatever
    is the latest. Teams themselves can perform some triage of problems, but it's
    good to add some context.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that usually, you need to both correct bugs and implement new features,
    and each of these tasks can distract from the other.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing bugs is important, not only for the resulting quality of the service,
    as any user will find working with a buggy service very frustrating. But it's
    also important for the development team, as working with a low-quality service
    is also frustrating for developers.
  prefs: []
  type: TYPE_NORMAL
- en: A proper balance needs to be struck between bug fixing and introducing new features.
    Also remember to allocate time for the corresponding new bugs introduced for new
    features. A feature is not ready when released, it's ready when its bugs are fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Any detected problem, except the catastrophic ones, where context is irrelevant,
    should capture the context surrounding the steps that were required to produce
    the error. The objective of this is to be able to *reproduce* the error.
  prefs: []
  type: TYPE_NORMAL
- en: Reproducing the error is a critical element of fixing it. The worst-case scenario
    is that a bug is intermittent or appears to happen at random times. More digging
    will be required in order to understand why it is happening when it's happening.
  prefs: []
  type: TYPE_NORMAL
- en: When a problem can be replicated, you're halfway to the solution. The problem
    can be ideally replicated into a test, so it can be tested over and over until
    the problem is understood and fixed. In the best situations, this test can be
    a unit test, if the problem affects a single system and all the conditions are
    understood and can be replicated. If the problem affects more than one system,
    it may be necessary to create integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: A common problem during an investigation is to find out what the specific circumstances
    are that are provoking the problem, for example, data that's set up in a particular
    way in production and that triggers some issue. Finding exactly what is causing
    the problem can be complicated in this environment. We will talk later in the
    chapter about finding a problem in production.
  prefs: []
  type: TYPE_NORMAL
- en: Once a problem is categorized and replicable, the investigation can proceed
    to understand *why*.
  prefs: []
  type: TYPE_NORMAL
- en: Visually inspecting the code and trying to reason where problems and bugs are
    is normally not good enough. Even very simple code will surprise you in terms
    of how it's executed. Being able to analyze how, in a particular case, the code
    is executing with precision is critical for analyzing and fixing problems that
    are found.
  prefs: []
  type: TYPE_NORMAL
- en: Investigation in production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we are aware that we have a problem in production, we need to understand
    what is happening and what the key elements that produce it are.
  prefs: []
  type: TYPE_NORMAL
- en: It's very important to remark on the importance of being able to replicate a
    problem. If that's the case, tests can be done to produce the error and follow
    the consequences.
  prefs: []
  type: TYPE_NORMAL
- en: The most important tools when analyzing why a particular problem is produced
    are the observability tools. That's why it is important to do preparation work
    in advance to be sure to be able to find problems when required.
  prefs: []
  type: TYPE_NORMAL
- en: We talked in previous chapters about logs and metrics. When debugging, metrics
    are normally not relevant, except to show the relative importance of a bug. Checking
    an increase in returned errors can be important to detect that there's an error,
    but detecting what error will require more precise information.
  prefs: []
  type: TYPE_NORMAL
- en: Do not underestimate metrics, though. They can help quickly determine what specific
    component is failing or if there's any relationship with other elements, for example,
    if there's a single server that's producing errors, or if it has run out of memory
    or hard drive space.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a problematic server can produce apparently random errors, if the
    external requests are directed to different servers, and the failure is related
    to a combination of a specific request addressed to a specific server.
  prefs: []
  type: TYPE_NORMAL
- en: 'But in any case, logs will generally be more useful in determining which part
    of the code is behaving badly. As we saw in *Chapter 12*, *Logging*, we can describe
    error logs as detecting two kinds of problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expected errors**. In this case, we did the work of debugging the error beforehand
    and knowing what happened should be easy. Examples of this can be an external
    request that returns an error, a database that cannot be connected to, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of these errors will be related to external services (from the point of
    view of the one raising the error) that are misbehaving. This could indicate a
    network problem, misconfiguration, or problems in other services. It is not rare
    that errors propagate through the system as an error may provoke a cascading failure.
    Typically, though, the origin will be an unexpected error and the rest will be
    expected ones, as they'll receive the error from an external source.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Unexpected errors**. The sign of these errors are logs indicating that something
    has gone wrong, and in most modern programming languages, a stack trace of some
    sort in the logs detailing the line of code when the error was produced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, any kind of framework that executes tasks, like a web framework
    or task management system, will produce an error, but keep the system stable.
    This means that only the task producing the error will be interrupted and any
    new task will be handled from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: The system should provide the proper handling for the task. For example, a web
    server will return a 500 error, and a task management system may retry the task
    after some delay. This may lead to the error being propagated, as we saw before.
  prefs: []
  type: TYPE_NORMAL
- en: In any of the two cases, the main tool to detect what the problem was will be
    logs. Either the logs show a known problem that is captured and properly labeled,
    or the logs show a stack trace that should indicate what specific part of the
    code is showing the error.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the element and part of the code that is the source of the error is
    important for understanding the problem and for debugging the specific problem.
    This is particularly important in microservices architectures, as they'll have
    multiple independent elements.
  prefs: []
  type: TYPE_NORMAL
- en: We talked about microservices and monolithic architectures in *Chapter 9*,*Microservices
    vs Monolith*. Monoliths are easier to deal with in terms of bugs, as all the code
    is handled on the same site, but anyway they'll become more and more complex as
    they grow.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that sometimes it is not possible to totally avoid errors. For
    example, if there's an external dependency calling an external API and it has
    a problem, this may trigger internal errors. These can be mitigated, failing gracefully,
    or generating a state of "service not available." But the root of the error may
    not be possible to fix totally.
  prefs: []
  type: TYPE_NORMAL
- en: Mitigating external dependencies may require creating redundancy, even using
    different suppliers so as not to be dependent on a single point of failure, though
    this may not be realistic, as it can be extremely costly.
  prefs: []
  type: TYPE_NORMAL
- en: We can have these cases be notified to us, but they won't require further short-term
    action.
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, when the error is not immediately obvious and further investigation
    needs to be done, it will require some debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem in production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The challenge in complex systems is the fact that detecting problems becomes
    exponentially more complicated. As multiple layers and modules are added and interact
    with each other, bugs become potentially more subtle and more complex.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw before, microservice architectures can be especially difficult to
    debug. The interaction between different microservices can produce complex interactions
    that can produce subtle problems in the integration of its different parts. This
    integration can be difficult to test in integration tests, or perhaps the source
    of the problem is in a blind spot of the integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: But monoliths can also have problems as their parts grow more complex. Difficult
    bugs may be produced due to the interaction of specific production data that interacts
    in an unexpected way. A big advantage of monolithic systems is that the tests
    will cover the whole system, making it easier to replicate with unit or integration
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: The objective in this step, though, should be to analyze enough of the problem
    in production to be able to replicate it in a local environment, where the smaller
    scale of the environment will make it easier and less invasive to probe and make
    changes. Once enough information has been collected, it's better to leave any
    production environment alone and focus on the specifics of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that having a replicable bug is more than half the battle! Once the
    problem can be categorized as a replicable set of steps locally, a test can be
    created to produce it over and over and debug in a controlled environment.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, general logging enabled is enough to determine exactly what the bug
    is or how to replicate it locally. In those cases, it may be necessary to research
    the circumstances that trigger the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Logging a request ID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the problems when analyzing a large number of logs is correlating them.
    To properly group logs that are related to each other, we could filter by the
    host that generates them and select a short window of time, but even that may
    not be good enough as two or more different tasks can be running at the same time.
    We need a unique identifier per task or request that can trace all logs coming
    from the same source. We will call this identifier a request ID, as they are added
    automatically in many frameworks. This sometimes is called a task ID in task managers.
  prefs: []
  type: TYPE_NORMAL
- en: In cases where multiple services are involved, like in microservice architectures,
    it is very important to keep a common request ID that can work to trace the different
    requests between different services. That allows you to follow and correlate different
    logs in the system from different services that have the same origin.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows the flow between a frontend and two backend services
    that are called internally. Note that the `X-Request-ID` header is set by the
    frontend and it's forwarded to service A, which then forwards it toward service
    B.
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_15_01.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.1: Request ID across multiple services'
  prefs: []
  type: TYPE_NORMAL
- en: Because all of them share the same request ID, logs can be filtered by that
    information to obtain all the information about a single task.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we can use the module `django_log_request_id` to create a request
    ID in Django applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the whole documentation here: [https://github.com/dabapps/django-log-request-id/](https://github.com/dabapps/django-log-request-id/).'
  prefs: []
  type: TYPE_NORMAL
- en: We show some code in GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_15_debug](https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_15_debug)
    following the example across the book. This requires creating a virtual environment
    and installing the package, alongside the rest of the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The code has been changed to include some extra logs in the `microposts/api/views.py`
    file (as seen at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/microposts/api/views.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/microposts/api/views.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note how this is now adding some logs when accessing the list collections page
    and the individual micropost page. We will use the example URL `/api/users/jaime/collection/5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the usage of the request ID, we need to properly set up the configuration
    in `microposts/settings.py` ([https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/microposts/microposts/settings.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/microposts/microposts/settings.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `LOGGING` dictionary is a characteristic in Django that describes how to
    log. `filters` adds extra information, in this case, our `request_id`, `formatter`
    describes the specific format to use (note that we add `request_id` as a parameter,
    which will be presented in brackets).
  prefs: []
  type: TYPE_NORMAL
- en: '`handlers` describes what happens to each message, joining `filters` and `formatter`
    with information about levels to display and where to send the info. In this case,
    `StreamHandler` will send the log to `stdout`. We set all the logs on the `root`
    level to use this `handler`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the Django documentation for more information: [https://docs.djangoproject.com/en/3.2/topics/logging/](https://docs.djangoproject.com/en/3.2/topics/logging/).
    Logging in Django may take a bit of experience in setting all the parameters correctly.
    Take your time when configuring it.'
  prefs: []
  type: TYPE_NORMAL
- en: The lines,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: state that a new `Request ID` parameter should be created if not found as a
    header in the input and that the name of the header will be `X-Request-ID`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all of this is configured, we can run a test starting the server with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On another screen, make a call to the test URL with `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At the same time, you''ll see the logs on the server screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Which, as you can see, added a new request ID element, `66e9f8f1b43140338ddc3ef569b8e845`
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: But the request ID can also be created by calling with the proper header. Let's
    try again, making another `curl` request and the `-H` parameter to add a header.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the logs in the server again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the request ID has been set by the value in the header.
  prefs: []
  type: TYPE_NORMAL
- en: The request ID can be passed over other services by using the `Session` included
    in the same module, which acts as a `Session` in the `requests` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will set the proper header in the request, passing through it to the next
    step of the chain, like service A or service B.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to check the `django-log-request-id` documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the default logs are not enough to understand the problem, the next stage
    in those cases is understanding the data related to the problem. Typically, the
    data storage may be inspected to follow up on the related data for the task, to
    see if there's any indication about that.
  prefs: []
  type: TYPE_NORMAL
- en: This step may be complicated by either missing data or data restrictions that
    make it difficult or impossible to obtain the data. Sometimes only a few people
    in the organization can access the required data, which may delay the investigation.
    Another possibility is that the data is impossible to retrieve. For example, data
    policies may not store the data, or the data may be encrypted. This is a regular
    occurrence in cases involving **Personally Identifiable Information** (**PII**),
    passwords, or similar data.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the stored data may require performing ad hoc manual queries to databases
    or other kinds of data storage to find out if the related data is consistent or
    if there is any combination of parameters that's not expected.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the objective is to capture information from production to be
    able to understand and replicate the problem independently.In some cases, when
    investigating a problem in production, it is possible that changing the data manually
    will fix the issue. This could be necessary in some emergency situations, but
    the objective still needs to be to understand why this inconsistent situation
    of the data has been possible or how the service should be changed to allow you
    to deal with this data situation. Then the code can be changed accordingly to
    ensure that the problem doesn't happen in the future.
  prefs: []
  type: TYPE_NORMAL
- en: If investigating the data is not enough to be able to understand the problem,
    it may be necessary to increase the information on the logs.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the regular logs and an investigation of the data don't bear fruit, it may
    be necessary to increase the level of logging with special logs, following the
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a last-resort method, because it has two main problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Any change in the logs needs to be deployed, which makes it costly and expensive
    to run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of logs in the system will be incremented, which will require more
    space to store them. Depending on the number of requests in the system, this can
    create pressure on the logging system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These extra logs should always be short term, and should be reverted as soon
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: While enabling an extra level of logging, like setting logs to `DEBUG` level,
    is technically possible, this will probably increase the logs too much, and will
    make it difficult to know what the key ones are in the massive amount of logs.
    With some `DEBUG` logs, specifics of the area under investigation can be temporally
    promoted to `INFO` or higher to make sure that they are properly logged.
  prefs: []
  type: TYPE_NORMAL
- en: Be extra careful with information that's logged temporally. Confidential information
    like PII should not be logged. Instead, try to log surrounding information that
    can help find out the problem.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if there's a suspicion that some unexpected character may be producing
    a problem with the algorithm to check the password, instead of logging the password,
    some code can be added to detect whether there's an invalid character.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, assuming there''s a problem with a password or secret that has
    an emoji, we could extract only non-ASCII characters to find out if this is the
    problem, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The value in `bad_characters` can be then logged, as it won't contain the full
    password.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this assumption is probably easier to test quickly and without any
    secret data with a unit test. This is just an example.
  prefs: []
  type: TYPE_NORMAL
- en: Adding temporal logs is cumbersome, as it typically will involve several deployments
    until finding out the problem. It's always important to keep the number of logs
    to a minimum, cleaning up the useless ones as quickly as possible, and remember
    to remove them completely after the work is done.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the work is just to be able to reproduce the problem locally,
    so you can more efficiently investigate and fix the problem locally. Sometimes
    the problem may be deemed obvious after some temporal log, but, good TDD practice,
    as we saw in *Chapter 10*, *Testing and TDD*, tests displaying and then fixing
    the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Once we can detect the problem locally, it is time to go to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Local debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging locally means exposing and fixing a problem once we have a local reproduction.
  prefs: []
  type: TYPE_NORMAL
- en: The basic steps of debugging are reproducing the problem, knowing what the current,
    incorrect result is, and knowing what the correct result should be. With that
    information, we can start debugging.
  prefs: []
  type: TYPE_NORMAL
- en: A great way of creating the reproduction of the problem is with a test, if that's
    possible. As we saw in *Chapter 10*, *Testing and TDD*, this is the basis of TDD.
    Create a test that fails and then change the code to make it pass. This approach
    is very usable when fixing bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking a step back, any debugging process follows the following process:'
  prefs: []
  type: TYPE_NORMAL
- en: You realize there's a problem
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You understand what the correct behavior should be
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You investigate and discover why the current system behaves incorrectly
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You fix the problem
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keeping this process in mind is also useful from a local debugging perspective,
    though at this point, it is likely that *steps 1* and *2* are already sorted out.
    In the vast majority of cases, the difficult step is *3*, as we've been seeing
    throughout the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand, once presented with the code, *why* the code is behaving as
    it is, a method similar to the scientific method can be used to systematize the
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Measure and observe the code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Produce a hypothesis on why a certain result is being produced
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate or disprove the hypothesis by either analyzing the produced state,
    if possible, or creating a specific "experiment" (some specific code, like a test)
    to force it to be produced
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the resulting information to iterate the process until the source of the
    problem is totally understood
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that this process doesn't necessarily need to be applied to the whole problem.
    It can be focused on the specific parts of the code that can influence the problem.
    For example, is this setting activated in this case? Is this loop in the code
    being accessed? Is the value calculated lower than a threshold, which will later
    send us down a different code path?
  prefs: []
  type: TYPE_NORMAL
- en: All those answers will increase the knowledge of why the code is behaving in
    the way that it's behaving.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging is a skill. Some people may say it's an art. In any case, it can be
    improved over time, as more time gets invested in it. Practice plays an important
    role in developing the kind of intuition that involves knowing when to take a
    deeper look into some areas over others to identify the promising areas where
    the code may be failing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some general ideas that can be very helpful when approaching debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Divide and conquer**. Take small steps and isolate areas of the code so it''s
    possible to simplify the code and make it digestible. As important as understanding
    when there''s a problem in the code is detecting when there isn''t so we can set
    our focus on the relevant bits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edward J. Gauss described this method in what he called the "**wolf fence algorithm**"
    in a 1982 article:'
  prefs: []
  type: TYPE_NORMAL
- en: '*There''s one wolf in Alaska; how do you find it? First build a fence down
    the middle of the state, wait for the wolf to howl, determine which side of the
    fence it is on. Repeat process on that side only, until you get to the point where
    you can see the wolf*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Move backward from the visible error**. It''s quite common that the source
    of a problem is not where an error is raised or obvious, but instead the error
    was produced earlier. A good approach is to move backward from the position where
    the problem is obvious and then validate the flow. This allows you to ignore all
    code that comes *after* the problem, and have a clear path of analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**You can make an assumption, as long as you can then prove that this assumption
    is correct.** Code is complex, and you won''t be able to keep the whole codebase
    in your head. Instead, focus needs to be carefully moved across different parts,
    making assumptions about what the rest is returning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As Sherlock Holmes once said:'
  prefs: []
  type: TYPE_NORMAL
- en: '*When you have eliminated the impossible, whatever remains, however improbable,
    must be the truth*.'
  prefs: []
  type: TYPE_NORMAL
- en: Properly eliminating everything can be arduous, but removing proven assumptions
    from the mind will reduce the amount of code to analyze and verify.
  prefs: []
  type: TYPE_NORMAL
- en: But those assumptions need to be validated to really prove that they are correct,
    or we risk the chance of making a wrong assumption. It's very easy to fall into
    bad assumptions and think that the problem is in a particular part of the code
    when it really is in another.
  prefs: []
  type: TYPE_NORMAL
- en: Though the whole range of techniques and possibilities of debugging is there,
    and certainly sometimes bugs can be convoluted and difficult to detect and fix,
    most bugs are typically easy to understand and fix. Perhaps they are a typo, an
    off-by-one error, or a type error that needs to be checked.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the code simple helps a lot in later debugging problems. Simple code
    is easy to understand and debug.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to specific techniques, we need to understand the tools in
    Python help in our investigation.
  prefs: []
  type: TYPE_NORMAL
- en: Python introspection tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Python is a dynamic language, it's very flexible and allows you to perform
    actions on its objects to discover their properties or types.
  prefs: []
  type: TYPE_NORMAL
- en: This is called *introspection*, and allows you to inspect elements without having
    too much context about the objects to be inspected. This can be performed at runtime,
    so it can be used while debugging to discover the attributes and methods of any
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main starting point is the `type` function. The `type` function simply
    returns the class of an object. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This can be used to double-check that an object is of the expected `type`.
  prefs: []
  type: TYPE_NORMAL
- en: A typical example error is to have a problem because a variable can be either
    an object or `None`. In that case, it's possible that a mistake handling the variable
    makes it necessary to double-check that the type is the expected one.
  prefs: []
  type: TYPE_NORMAL
- en: While `type` is useful in debugging environments, avoid using it directly in
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, avoid comparing defaults of `None`, `True`, and `False` with their
    types, as they are created as singletons. That means there''s a single instance
    of each of these objects, so every time that we need to verify if an object is
    `None`, it''s better to make an identity comparison, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Identity comparisons can prevent the kind of problem where the usage of `None`
    or `False` can't be distinguished in an `if` block.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Instead, only checking against the identity comparison will allow you to detect
    only the value of `None` properly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The same can be used for Boolean values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For other cases, there''s the `isinstance` function, which can be used to find
    if a particular object is an instance of a particular class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is better than making comparisons with `type`, because it is aware of any
    inheritance that may have been produced. For example, in the following code we
    see how an object from a class that inherits from another will return that it's
    an instance of either, while the `type` function will only return one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The most useful function for introspection, though, is `dir`. `dir` allows you
    to see all the methods and attributes in an object, and it's particularly useful
    when analyzing objects from a not-clear origin, or where the interface is not
    clear.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Obtaining the whole attributes can be a bit too much in certain situations,
    so the returned values can filter out the double-underscore ones to reduce the
    amount of noise and be able to detect attributes that can give some clue about
    the object usage more easily.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Another interesting function is `help`, which displays the help from objects.
    This is particularly helpful for methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This function displays the defined `docstring` from the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All these methods can help you navigate code that's new or under analysis without
    being an expert, and avoid many checks with code that can be hard to search through.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding sensible `docstrings` is a great help not only for keeping the code
    well commented and adding context for developers working in the code, but also
    in case of debugging in parts where the function or object is used. You can learn
    more about `docstrings` in the PEP 257 document: [https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/).'
  prefs: []
  type: TYPE_NORMAL
- en: Using these tools is good, but let's see how we can understand the behavior
    of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A simple yet effective way of detecting what's going on and how the code is
    being executed is adding comments that are displayed either containing statements
    like `starting the loop here` or including values of variables like `Value of
    A = X`. By strategically locating these kinds of outputs, the developer can understand
    the flow of the program.
  prefs: []
  type: TYPE_NORMAL
- en: We touched on this earlier in this chapter as well as in *Chapter 10*, *Testing
    and TDD*.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest form of this approach is **print debugging**. It consists of adding
    `print` statements to be able to watch the output from them, normally while executing
    the code locally in a test or similar.
  prefs: []
  type: TYPE_NORMAL
- en: Print debugging can be considered a bit controversial to some people. It has
    been around for a long time, and it's considered a crude way of debugging. In
    any case, it can be very quick and flexible and can fit some debug cases very
    well, as we will see.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, these `print` statements need to be removed after the process has
    been finished. One of the main complaints about this technique is precisely this,
    that there's a chance that some `print` statements intended for debugging are
    not removed, and it's a common mistake.
  prefs: []
  type: TYPE_NORMAL
- en: This can be refined, though, by instead of directly using `print` statements,
    using logs instead, as we introduced in *Chapter 12*, *Logging*.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, these logs will be `DEBUG` logs, which will only be displayed when
    running tests, but won't be produced in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: While logs can be added and not produced later, it's good practice anyway to
    remove any spurious logs after fixing the bug. Logs can accumulate and there will
    be an excessive amount of them unless they are periodically taken care of. It
    can be difficult to find information in a big wall of text.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this method is that it can be done quickly and it can also
    be used to explore logs that can then be promoted to permanent ones, once adapted.
  prefs: []
  type: TYPE_NORMAL
- en: Another important advantage is that tests can be run very quickly, as adding
    more logs is a simple operation, and logs won't interfere with the execution of
    code. This makes it a good combination to use with TDD practices.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the logs won't interfere with the code and code can be running
    unaffected can make some difficult bugs based on concurrency easier to debug,
    as interrupting the flow of the operation in those cases will affect the behavior
    of the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent bugs can be quite complicated. They are produced when two independent
    threads interact in an unexpected way. Because of the uncertain nature of what
    one thread will start and stop or when an action from one thread will affect the
    other, they normally require extensive logs to try to capture the specifics of
    that problem.
  prefs: []
  type: TYPE_NORMAL
- en: While debugging through logs can be quite convenient, it requires certain knowledge
    of where and what logs to set to obtain the relevant information. Anything not
    logged won't be visible in the next run. This knowledge can come through a discovery
    process and take time to pinpoint the relevant information that will lead to fixing
    the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem is that new logs are new code, and they can create problems
    if there are errors introduced like bad assumptions or typos. This will normally
    be easy to fix, but can be an annoyance and require a new run.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that all introspection tools that we talked about before in the chapter
    are available.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with breakpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In other situations, it's better to stop the execution of the code and take
    a look at the current status. Given that Python is a dynamic language, it means
    that, if we stop the execution of the script and enter the interpreter, we can
    run any kind of code and see its results.
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly what is done through the usage of the `breakpoint` function.
  prefs: []
  type: TYPE_NORMAL
- en: '`breakpoint` is a relatively new addition to Python, available since Python
    3.7\. Previously, it was necessary to import the module `pdb`, typically in this
    way in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import pdb; pdb.set_trace()`'
  prefs: []
  type: TYPE_NORMAL
- en: Other than the ease of usage, `breakpoint` has some other advantages that we
    will see.
  prefs: []
  type: TYPE_NORMAL
- en: When the interpreter finds a `breakpoint` call, it stops and opens an interactive
    interpreter. From this interactive interpreter, the current status of the code
    can be examined and any investigation can take place, simply executing the code.
    This makes it possible to understand interactively what the code is doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some code and analyze how it runs. The code can be found
    on GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/debug.py](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_15_debug/debug.py)
    and it''s the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Perhaps you are able to understand what the code does, but let's take a look
    at it interactively. You can check first that all the `assert` statements at the
    end are correct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: But we now introduce a `breakpoint` call before line 9, right at the start of
    the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the program again and it now stops at that line and presents an interactive
    prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Check the value of `candidate` and both operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This line is checking whether dividing `candidate` by `lower` produces an exact
    integer, as in that case both operations will return the same. Execute the next
    line by hitting `n`, from the command `n(ext)`, and check that the loop ends and
    it returns `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Continue the execution until a new `breakpoint` is found using the command `c`,
    from `c(ontinue)`. Note this happens on the next call to `valid`, which has an
    input of 15.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the command `l(ist)` to display the surrounding code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Continue freely investigating the code. When you are finished, run `q(uit)`
    to exit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After analyzing the code carefully, you probably know what it does. It checks
    whether a number is prime or not by checking if it's divisible by any number lower
    than the number itself.
  prefs: []
  type: TYPE_NORMAL
- en: We investigated similar code and improvements in *Chapter 14*, *Profiling*.
    This is, needless to say, not the most efficient way of setting code to check
    this, but it has been added as an example and for teaching purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Another two useful debug commands are `s(tep)`, to get into a function call,
    and `r(eturn)`, to execute the code until the current function returns its execution.
  prefs: []
  type: TYPE_NORMAL
- en: '`breakpoint` can also be customized to call other debuggers, not only `pdb`.
    There are other debuggers for Python that include more contextual information
    or with more advanced usages, like `ipdb` ([https://pypi.org/project/ipdb/](https://pypi.org/project/ipdb/)).
    To use them, you need to set the `PYTHONBREAKPOINT` environment variable with
    the endpoint for the debugger, after installing the debugger.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This environment variable can be set to 0 to skip any breakpoint, effectively
    deactivating the debug process: `PYTHONBREAKPOINT=0`. This can be used as a failsafe
    to avoid being interrupted by breakpoint statements that haven''t been properly
    removed, or to quickly run the code without interruptions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple debuggers that can be used, including support from IDEs
    like Visual Studio or PyCharm. Here are examples of two other debuggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pudb` ([https://github.com/inducer/pudb](https://github.com/inducer/pudb)):
    Has a console-based graphical interface and more context around the code and variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remote-pdb` ([https://github.com/ionelmc/python-remote-pdb](https://github.com/ionelmc/python-remote-pdb)):
    Allows you to debug remotely, connecting to a TCP socket. This allows you to debug
    a program running in a different machine or trigger the debugger in a situation
    where there''s no good access to the `stdout` of the process, for example, because
    it''s running in the background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a debugger properly is a skill that requires time to learn. Be sure to
    try different options and get comfortable with them. Debugging will also be used
    while running tests, as we described in *Chapter 10*, *Testing and TDD*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described the general process of detecting and fixing problems.
    When working in complex systems, there's the challenge of properly detecting and
    categorizing the different reports to be sure that they are prioritized. It's
    very important to be able to reliably reproduce the problem in order to show all
    the conditions and context that are producing the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Once a problem is deemed important, there needs to be an investigation into
    why this problem is happening. This can be on the running code, and use the available
    tools in production to see if it can be understood why the problem occurs. The
    objective of this investigation is to be able to replicate the problem locally.
  prefs: []
  type: TYPE_NORMAL
- en: Most issues will be easy to reproduce locally and move forward, but we also
    described some tools in case it remains a mystery why the issue is being produced.
    As the main tool to understand the behavior of the code in production is logs,
    we talked about creating a request ID that can help us to trace the different
    calls and relate logs from different systems. We also described how the data in
    the environment may have the key to why the problem is occurring there. If it
    is necessary, the number of logs may need to be increased to extract information
    from production, though this should be reserved for very elusive bugs.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to how to debug locally, after replicating the problem, ideally,
    as we saw in *Chapter 10*, *Testing and TDD*, in the form of a unit test. We gave
    some general ideas to help with debugging, though it must be said that debugging
    is a skill that needs to be practiced.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging can be learned and improved, so it's an area where more experienced
    developers can help their junior counterparts. Be sure to create a team where
    it is encouraged to help with debugging when required in difficult cases. Two
    pairs of eyes see more than one!
  prefs: []
  type: TYPE_NORMAL
- en: We introduced some of the tools that help with debugging in Python, which make
    use of the possibilities that Python presents for introspection. As Python is
    a dynamic language, there are a lot of possibilities, as it's able to execute
    any code, including all the introspection capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: We then talked about how to create logs to debug, which is an improved version
    of using `print` statements, and, when done in a systematic way, can help to create
    better logs in the long run. Finally, we moved on to debugging using the `breakpoint`
    function call, which stops the execution of the program and allows you to inspect
    and understand the status at that point, as well as continuing with the flow.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about the challenges of working in the architecture
    of a system when it's running and needs to be evolved.
  prefs: []
  type: TYPE_NORMAL
