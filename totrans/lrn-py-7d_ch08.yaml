- en: Modules and Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about the Python functions. In this chapter,
    you will learn the Python modules. A Python module is the Python source file,
    which can consist of statements, classes, functions, and variables.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules are code files meant to be used by other programs. In order to use a
    module, we use the `import` statement. A module can import other modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss the simple Python program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a very easy and basic example. Let's save the program
    as `module1.py`. You can consider that the preceding program is the Python module.
    We will use `module1.py`. Consider, while making another program, you need multiplication
    or addition of two numbers. You need not make any function. You can take the advantage
    of `module1.py`.
  prefs: []
  type: TYPE_NORMAL
- en: The import statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use the functions and variables of the `module1.py` program, we
    will use the `import` statement. The syntax of the `import` statement is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, you can import multiple modules. Let''s make another program `mod1.py`,
    which will import `module1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you know, the module contains statements and definitions and these statements
    and definitions are executed for the first time when the interpreter encounters
    the module name in the `import` statement.
  prefs: []
  type: TYPE_NORMAL
- en: In preceding code, the `module1` module gets executed when the interpreter encounters
    the `module1` name in the `import` statement.  In order to use the module variables
    and functions, use the `module_name.variable` and `module_name.function()` notations.
    In the preceding code, we want to use the `sum1()` function of `module1`, that's
    why we use `module1.mul1()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/mod1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the mod1.py program
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think it is tedious and time consuming to write `module1` with every
    function of `module1.py`, then Python allows you to use the `as` statement as
    shown. The syntax is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a program `mod2.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `module1` is used as `md`. Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/mod2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the mod2.py program
  prefs: []
  type: TYPE_NORMAL
- en: You can explicitly define the function as per your need. Consider we want only
    the `sum1()` function not `mul1()`. Syntax is given as *module-name import function-name*
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line, I defined from where I am taking the `sum1()` function,
    then there will be no need to use `module1` with the function name. Let''s see
    the output of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/mod3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the mod3 program
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a module that contains many functions and you have to import all the
    functions. You can use the following statement as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'But I advise you don''t use the preceding statement because if you are importing
    more than one module, then it is very difficult to identify which function is
    taken from which module. Let''s take an example. Consider one more module named
    as `module2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have two modules `module1` and `module2`. We have defined `module1`
    earlier. Let''s write the next program `mod4.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding function, we imported all the functions of `module1` and `module2`.
    But it is very difficult to identify which function is coming from which module.
    The output of the program is as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/mod4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the mod4 program
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Python offers you the built-in function `dir()`, which can be used
    to identify the functions. See the example `mod5.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/mod5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding is the output of the `mod5` program. After seeing the output,
    we can say that the `mul1()` and `sum1()` functions came from the `module1` module.
  prefs: []
  type: TYPE_NORMAL
- en: Locating Python modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After encountering the `import` statement, the Python interpreter searches
    the module in the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: The current directory, which contains the running script. I advise you, be sure,
    that the name of your program is different from the importing modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PYTHONPATH` has to be defined in the environment variable in Windows OS. Let''s
    learn by example. Consider we move the `mod5.py` program to another directory
    as covered in the following screenshot.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'But the current directory does not contain any `module1` module. The output
    will be as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Pythonpath1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of mod5.py  in a different directory
  prefs: []
  type: TYPE_NORMAL
- en: 'We are running the `mod5.py` program from `F:project_7daysmodulepack`. The
    output shown there is no `module1` module found. Let''s set the `PYTHONPATH` variable
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Pythonpathsetting.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the PYTHONPATH variable
  prefs: []
  type: TYPE_NORMAL
- en: After setting `PYTHONPATH`, you will have to reboot your computer. After reboot,
    start the program again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Pythonpath2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the output of the program after setting `PYTHONPATH`. Now you can see
    that there is no error, meaning the interpreter is able to find the `module1` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you have Python installed by default. If you want to know the installation
    path, you can check the `sys.path` variable in the `sys` module. Refer to the
    following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/syspath.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot showing sys path
  prefs: []
  type: TYPE_NORMAL
- en: The `sys.path` returns a list of default paths.
  prefs: []
  type: TYPE_NORMAL
- en: Compiled Python files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever `module1.py` and `module2.py` are successfully compiled, an attempt
    is made to write the compiled version to `module1.pyc` and `module2.pyc` respectively.
    Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/complied.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot showing the compiled files
  prefs: []
  type: TYPE_NORMAL
- en: The contents of the compiled file is platform independent, so a Python module
    can be used by machines on different architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss a special scenario, consider Bob make a program named `myprog.py`
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/main1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the myprog.py program
  prefs: []
  type: TYPE_NORMAL
- en: Bob's  program is running successfully. Consider another user, Alice, who uses
    your program as a module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to Alice''s program `alice1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding program is very simple, just import `myprog.py` as a module and
    use the `sum1()` function of the `myprog` module. Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/main22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the alice1.py program
  prefs: []
  type: TYPE_NORMAL
- en: The program is running successfully. With the output from `alice1.py` the output
    of `myprog.py` is also printed, which is unwanted. Any user who imports `myprog.py`
    as a module unwantedly would get the output of `myprog.py`.  To avoid this situation,
    we made some amendments in `myprog.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the new version of program `myprog.py` here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, what is the significance of `__name__` and `__main__`. `__name__`
    is a special variable that holds a string  `"__main__"`.  If the program is being
    imported from another program, then `__name__` would  be set to the module's name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the output of both the programs `myprog.py` and `alice1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/main2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the myprog.py and alice1.py programs
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are still not getting the point of the `__name__` variable, let''s discuss
    with examples. I have made temporary changes in the `myprog.py` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run both the programs `myprog.py` and `alice1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/main3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of  the myprog.py and alice1.py programs
  prefs: []
  type: TYPE_NORMAL
- en: So, in the preceding output, when `myprog.py` is being run, the `__name__` variable
    returns a string value `"__main__"`. Further, when `myprog` has been imported
    by another program as a module, then it returns a module named `myprog`. I hope
    everything is clear now.
  prefs: []
  type: TYPE_NORMAL
- en: The Python package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python modules is a single file, whereas a Python package is a collection of
    modules. A package is a directory that contains Python modules and one additional
    file: `__init__.py`. What is the need of a package? Consider a team gets a project
    to convert the recording sound into MP3 format. One developer writes a code `rectomp3.py`
    to convert the recording voice to MP3 sound in the `sound_conversion` directory.
    After some time, the team gets new requirements to convert the recording voice
    to `.wav` format. Instead of writing in the `rectomp3.py` file, we write our own
    code `rectowav.py` file in `sound_conversion`. Then, a new requirement comes by
    where you need to convert the recording to WMA format. Again, a new author writes
    a new code `rectowma.py` file in the same directory `sound_conversion`. In this
    way, they make a package just adding one more file `__init__.py`. Let's take a practical
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see the code `rectomp3.py` in `sound_conversion`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is a dummy code, just for understanding. Let''s see the
    second code `rectowav.py` in the same directory `sound_conversion`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code converts the recording voice to WAV format. Let''s see the
    new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that all the code is written, make an empty file `__init__.py` in the directory
    `sound_conversion`. The `__init__.py` file can be an empty file, but it can also
    be used to import the module.  Now our package is ready; let''s import it. We
    will write a new program `voice_changer.py`. Put the program outside the directory
    `sound_conversion`. Refer to the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: While executing the preceding file, the interpreter might give an error because
    the Python interpreter doesn't know the `sound_conversion` path as shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the `PYTHONPATH` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/package1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot also shows that the code is running. If you want to
    create `voice_changer.py` in another directory say `F:/`, let''s copy and paste
    the code of `voice_changer.py` in `F:/` and run it. You might get an error if
    the interpreter is not able to find the package as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/packagerror.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An output showing error
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we are getting the error `No module named sound_conversion`,
    which means the interpreter did not get the package or module. Let''s edit the
    code. Refer to the code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `voice_changer1.py` program, we edit the `sys.path` for the program
    using `syntax sys.path.append("F:project_7daysmodulepackprograms")` . Let''s see
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/pythonpaackgetlast.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the voice_chnager1.py program
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows that the code is running successfully. In this
    way, you can load the package and modules.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Module* section, you have learned how to make modules and how to import
    them. By using the `dir()` function, you can check the involved function in the
    modules. The Python package is a collection of modules: generally a Python package
    is a directory. You have learned how Python searches the modules and packages.'
  prefs: []
  type: TYPE_NORMAL
