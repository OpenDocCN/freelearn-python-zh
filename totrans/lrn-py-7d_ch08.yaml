- en: Modules and Packages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和包
- en: In the previous chapter, you learned about the Python functions. In this chapter,
    you will learn the Python modules. A Python module is the Python source file,
    which can consist of statements, classes, functions, and variables.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了 Python 函数。在本章中，你将学习 Python 模块。Python 模块是 Python 源文件，它可以包含语句、类、函数和变量。
- en: Modules
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: Modules are code files meant to be used by other programs. In order to use a
    module, we use the `import` statement. A module can import other modules.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是旨在供其他程序使用的代码文件。为了使用模块，我们使用 `import` 语句。一个模块可以导入其他模块。
- en: 'Let''s discuss the simple Python program:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一个简单的 Python 程序：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code is a very easy and basic example. Let's save the program
    as `module1.py`. You can consider that the preceding program is the Python module.
    We will use `module1.py`. Consider, while making another program, you need multiplication
    or addition of two numbers. You need not make any function. You can take the advantage
    of `module1.py`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个非常简单和基本的例子。让我们将程序保存为 `module1.py`。你可以认为上述程序是 Python 模块。我们将使用 `module1.py`。考虑，在编写另一个程序时，你需要两个数字的乘法或加法。你不需要创建任何函数。你可以利用
    `module1.py`。
- en: The import statement
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`import` 语句'
- en: 'In order to use the functions and variables of the `module1.py` program, we
    will use the `import` statement. The syntax of the `import` statement is shown
    here:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `module1.py` 程序的函数和变量，我们将使用 `import` 语句。`import` 语句的语法如下所示：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this way, you can import multiple modules. Let''s make another program `mod1.py`,
    which will import `module1.py`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以导入多个模块。让我们再写一个程序 `mod1.py`，它将导入 `module1.py`：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you know, the module contains statements and definitions and these statements
    and definitions are executed for the first time when the interpreter encounters
    the module name in the `import` statement.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，模块包含语句和定义，并且这些语句和定义在解释器首次遇到 `import` 语句中的模块名时执行。
- en: In preceding code, the `module1` module gets executed when the interpreter encounters
    the `module1` name in the `import` statement.  In order to use the module variables
    and functions, use the `module_name.variable` and `module_name.function()` notations.
    In the preceding code, we want to use the `sum1()` function of `module1`, that's
    why we use `module1.mul1()`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当解释器遇到 `import` 语句中的 `module1` 名称时，`module1` 模块将被执行。为了使用模块变量和函数，使用 `module_name.variable`
    和 `module_name.function()` 表示法。在前面代码中，我们想要使用 `module1` 的 `sum1()` 函数，这就是为什么我们使用
    `module1.mul1()`。
- en: 'Let''s see the output:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出：
- en: '![](img/mod1.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/mod1.jpg)'
- en: Output of the mod1.py program
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod1.py` 程序的输出'
- en: 'If you think it is tedious and time consuming to write `module1` with every
    function of `module1.py`, then Python allows you to use the `as` statement as
    shown. The syntax is given as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为每次都要写 `module1` 和 `module1.py` 中的每个函数很繁琐且耗时，那么 Python 允许你使用 `as` 语句，如下所示。语法如下：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s write a program `mod2.py`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个程序 `mod2.py`：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, `module1` is used as `md`. Let''s see the output:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`module1` 被用作 `md`。让我们看看输出：
- en: '![](img/mod2.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/mod2.jpg)'
- en: Output of the mod2.py program
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod2.py` 程序的输出'
- en: You can explicitly define the function as per your need. Consider we want only
    the `sum1()` function not `mul1()`. Syntax is given as *module-name import function-name*
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以明确地定义所需的函数。考虑我们只想使用 `sum1()` 函数而不是 `mul1()`。语法如下：*module-name import function-name*
- en: 'Let''s write the code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the first line, I defined from where I am taking the `sum1()` function,
    then there will be no need to use `module1` with the function name. Let''s see
    the output of the code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我定义了从哪里获取 `sum1()` 函数，然后将不再需要使用 `module1` 与函数名一起使用。让我们看看代码的输出：
- en: '![](img/mod3.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/mod3.jpg)'
- en: Output of the mod3 program
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod3` 程序的输出'
- en: 'Consider a module that contains many functions and you have to import all the
    functions. You can use the following statement as shown:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含许多函数的模块，你必须导入所有这些函数。你可以使用以下语句，如下所示：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But I advise you don''t use the preceding statement because if you are importing
    more than one module, then it is very difficult to identify which function is
    taken from which module. Let''s take an example. Consider one more module named
    as `module2`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但我建议你不要使用前面的语句，因为如果你导入多个模块，那么很难确定哪个函数来自哪个模块。让我们举一个例子。考虑另一个名为 `module2` 的模块：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we have two modules `module1` and `module2`. We have defined `module1`
    earlier. Let''s write the next program `mod4.py`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个模块 `module1` 和 `module2`。我们之前已经定义了 `module1`。接下来，让我们编写下一个程序 `mod4.py`：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding function, we imported all the functions of `module1` and `module2`.
    But it is very difficult to identify which function is coming from which module.
    The output of the program is as shown here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们导入了 `module1` 和 `module2` 的所有函数。但很难确定哪个函数来自哪个模块。程序的输出如下所示：
- en: '![](img/mod4.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/mod4.jpg)'
- en: Output of the mod4 program
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: mod4 程序的输出
- en: 'However, Python offers you the built-in function `dir()`, which can be used
    to identify the functions. See the example `mod5.py`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python 提供了一个内置函数 `dir()`，可以用来识别函数。请参考 `mod5.py` 的示例：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of the program is as shown here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下所示：
- en: '![](img/mod5.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/mod5.jpg)'
- en: The preceding is the output of the `mod5` program. After seeing the output,
    we can say that the `mul1()` and `sum1()` functions came from the `module1` module.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出是 `mod5` 程序的输出。看到输出后，我们可以确定 `mul1()` 和 `sum1()` 函数来自 `module1` 模块。
- en: Locating Python modules
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位 Python 模块
- en: 'After encountering the `import` statement, the Python interpreter searches
    the module in the following sequence:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在遇到 `import` 语句后，Python 解释器会按照以下顺序搜索模块：
- en: The current directory, which contains the running script. I advise you, be sure,
    that the name of your program is different from the importing modules.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前目录，包含正在运行的脚本。我建议你确保，你的程序名称与导入的模块名称不同。
- en: '`PYTHONPATH` has to be defined in the environment variable in Windows OS. Let''s
    learn by example. Consider we move the `mod5.py` program to another directory
    as covered in the following screenshot.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 操作系统中，`PYTHONPATH` 必须在环境变量中定义。让我们通过示例来学习。假设我们将 `mod5.py` 程序移动到另一个目录，如下截图所示。
- en: 'But the current directory does not contain any `module1` module. The output
    will be as shown here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但当前目录不包含任何 `module1` 模块。输出将如下所示：
- en: '![](img/Pythonpath1.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Pythonpath1.jpg)'
- en: Output of mod5.py  in a different directory
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不同目录中 mod5.py 的输出
- en: 'We are running the `mod5.py` program from `F:project_7daysmodulepack`. The
    output shown there is no `module1` module found. Let''s set the `PYTHONPATH` variable
    as shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从 `F:project_7daysmodulepack` 运行 `mod5.py` 程序。那里显示的输出是找不到 `module1` 模块。让我们按照以下截图设置
    `PYTHONPATH` 变量：
- en: '![](img/Pythonpathsetting.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Pythonpathsetting.jpg)'
- en: Setting the PYTHONPATH variable
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 PYTHONPATH 变量
- en: After setting `PYTHONPATH`, you will have to reboot your computer. After reboot,
    start the program again.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `PYTHONPATH` 后，你将需要重新启动计算机。重启后，再次启动程序。
- en: 'The output will be as shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/Pythonpath2.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Pythonpath2.jpg)'
- en: This is the output of the program after setting `PYTHONPATH`. Now you can see
    that there is no error, meaning the interpreter is able to find the `module1` module.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设置 `PYTHONPATH` 后程序的输出。现在你可以看到没有错误，这意味着解释器能够找到 `module1` 模块。
- en: 'Here you have Python installed by default. If you want to know the installation
    path, you can check the `sys.path` variable in the `sys` module. Refer to the
    following example:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里默认安装了 Python。如果你想了解安装路径，可以在 `sys` 模块中检查 `sys.path` 变量。请参考以下示例：
- en: '![](img/syspath.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/syspath.jpg)'
- en: A screenshot showing sys path
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 展示 sys 路径的截图
- en: The `sys.path` returns a list of default paths.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.path` 返回一个默认路径列表。'
- en: Compiled Python files
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译后的 Python 文件
- en: 'Whenever `module1.py` and `module2.py` are successfully compiled, an attempt
    is made to write the compiled version to `module1.pyc` and `module2.pyc` respectively.
    Refer to the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 `module1.py` 和 `module2.py` 成功编译后，都会尝试将编译版本分别写入 `module1.pyc` 和 `module2.pyc`。请参考以下截图：
- en: '![](img/complied.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/complied.jpg)'
- en: A screenshot showing the compiled files
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 展示编译文件的截图
- en: The contents of the compiled file is platform independent, so a Python module
    can be used by machines on different architectures.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 编译文件的 内容与平台无关，因此 Python 模块可以在不同架构的机器上使用。
- en: 'Let''s discuss a special scenario, consider Bob make a program named `myprog.py`
    as shown:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一个特殊场景，假设 Bob 编写了一个名为 `myprog.py` 的程序，如下所示：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s run it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它：
- en: '![](img/main1.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/main1.jpg)'
- en: Output of the myprog.py program
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: myprog.py 程序的输出
- en: Bob's  program is running successfully. Consider another user, Alice, who uses
    your program as a module.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Bob 的程序正在成功运行。考虑另一个用户 Alice，她将你的程序作为模块使用。
- en: 'Refer to Alice''s program `alice1.py`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 参考 Alice 的程序 `alice1.py`：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding program is very simple, just import `myprog.py` as a module and
    use the `sum1()` function of the `myprog` module. Let''s see the output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序非常简单，只需将`myprog.py`作为模块导入，并使用`myprog`模块的`sum1()`函数。让我们看看输出：
- en: '![](img/main22.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/main22.jpg)'
- en: Output of the alice1.py program
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: alice1.py程序的输出
- en: The program is running successfully. With the output from `alice1.py` the output
    of `myprog.py` is also printed, which is unwanted. Any user who imports `myprog.py`
    as a module unwantedly would get the output of `myprog.py`.  To avoid this situation,
    we made some amendments in `myprog.py`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 程序运行成功。从`alice1.py`的输出中，`myprog.py`的输出也被打印出来，这是不需要的。任何意外将`myprog.py`作为模块导入的用户都会得到`myprog.py`的输出。为了避免这种情况，我们在`myprog.py`中做了一些修改。
- en: 'You can see the new version of program `myprog.py` here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到程序`myprog.py`的新版本：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From the preceding code, what is the significance of `__name__` and `__main__`. `__name__`
    is a special variable that holds a string  `"__main__"`.  If the program is being
    imported from another program, then `__name__` would  be set to the module's name.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，`__name__`和`__main__`有什么意义？`__name__`是一个特殊变量，它包含字符串`"__main__"`。如果程序是从另一个程序导入的，那么`__name__`将被设置为模块的名称。
- en: 'Let''s see the output of both the programs `myprog.py` and `alice1.py`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看程序`myprog.py`和`alice1.py`的输出：
- en: '![](img/main2.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/main2.jpg)'
- en: Output of the myprog.py and alice1.py programs
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: myprog.py和alice1.py程序的输出
- en: 'If you are still not getting the point of the `__name__` variable, let''s discuss
    with examples. I have made temporary changes in the `myprog.py` program:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然不明白`__name__`变量的含义，让我们通过例子来讨论。我在`myprog.py`程序中做了临时修改：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s run both the programs `myprog.py` and `alice1.py`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行两个程序`myprog.py`和`alice1.py`：
- en: '![](img/main3.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/main3.jpg)'
- en: Output of  the myprog.py and alice1.py programs
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: myprog.py和alice1.py程序的输出
- en: So, in the preceding output, when `myprog.py` is being run, the `__name__` variable
    returns a string value `"__main__"`. Further, when `myprog` has been imported
    by another program as a module, then it returns a module named `myprog`. I hope
    everything is clear now.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面的输出中，当运行`myprog.py`时，`__name__`变量返回字符串值`"__main__"`。进一步地，当`myprog`被另一个程序作为模块导入时，它返回名为`myprog`的模块。我希望现在一切都变得清晰了。
- en: The Python package
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python包
- en: Python modules is a single file, whereas a Python package is a collection of
    modules. A package is a directory that contains Python modules and one additional
    file: `__init__.py`. What is the need of a package? Consider a team gets a project
    to convert the recording sound into MP3 format. One developer writes a code `rectomp3.py`
    to convert the recording voice to MP3 sound in the `sound_conversion` directory.
    After some time, the team gets new requirements to convert the recording voice
    to `.wav` format. Instead of writing in the `rectomp3.py` file, we write our own
    code `rectowav.py` file in `sound_conversion`. Then, a new requirement comes by
    where you need to convert the recording to WMA format. Again, a new author writes
    a new code `rectowma.py` file in the same directory `sound_conversion`. In this
    way, they make a package just adding one more file `__init__.py`. Let's take a practical
    example.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Python模块是一个单独的文件，而Python包是一组模块的集合。包是一个包含Python模块和一个额外的文件`__init__.py`的目录。为什么需要包？假设一个团队接到了一个将录音转换为MP3格式的项目。一位开发者编写了`rectomp3.py`代码，在`sound_conversion`目录中将录音语音转换为MP3声音。过了一段时间，团队得到了新的需求，需要将录音转换为`.wav`格式。我们不是在`rectomp3.py`文件中编写代码，而是在`sound_conversion`目录中编写自己的代码`rectowav.py`文件。然后，又有一个新的需求，需要将录音转换为WMA格式。再次，另一位开发者在同一目录`sound_conversion`中编写了新的代码`rectowma.py`文件。这样，他们通过添加一个额外的文件`__init__.py`来创建了一个包。让我们举一个实际例子。
- en: 'Here, you can see the code `rectomp3.py` in `sound_conversion`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你可以看到`sound_conversion`目录中的代码`rectomp3.py`：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code is a dummy code, just for understanding. Let''s see the
    second code `rectowav.py` in the same directory `sound_conversion`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是示例代码，仅用于理解。让我们看看同一目录`sound_conversion`中的第二个代码`rectowav.py`：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code converts the recording voice to WAV format. Let''s see the
    new code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将录音语音转换为WAV格式。让我们看看新的代码：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that all the code is written, make an empty file `__init__.py` in the directory
    `sound_conversion`. The `__init__.py` file can be an empty file, but it can also
    be used to import the module.  Now our package is ready; let''s import it. We
    will write a new program `voice_changer.py`. Put the program outside the directory
    `sound_conversion`. Refer to the program:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的代码都写好了，在`sound_conversion`目录中创建一个空文件`__init__.py`。`__init__.py`文件可以是一个空文件，也可以用来导入模块。现在我们的包已经准备好了；让我们导入它。我们将编写一个新的程序`voice_changer.py`。将程序放在`sound_conversion`目录外。参考以下程序：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: While executing the preceding file, the interpreter might give an error because
    the Python interpreter doesn't know the `sound_conversion` path as shown.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行前面的文件时，解释器可能会给出错误，因为Python解释器不知道`sound_conversion`的路径，如下所示。
- en: 'Set the `PYTHONPATH` as shown here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将`PYTHONPATH`设置如下：
- en: '![](img/package1.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![包1](img/package1.jpg)'
- en: 'The preceding screenshot also shows that the code is running. If you want to
    create `voice_changer.py` in another directory say `F:/`, let''s copy and paste
    the code of `voice_changer.py` in `F:/` and run it. You might get an error if
    the interpreter is not able to find the package as shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图也显示代码正在运行。如果你想在其他目录（例如`F:/`）中创建`voice_changer.py`，让我们将`voice_changer.py`在`F:/`中的代码复制粘贴并运行。如果解释器无法找到包，你可能会得到如下错误：
- en: '![](img/packagerror.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![包错误](img/packagerror.jpg)'
- en: An output showing error
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 显示错误的输出
- en: 'In the preceding code, we are getting the error `No module named sound_conversion`,
    which means the interpreter did not get the package or module. Let''s edit the
    code. Refer to the code shown here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们遇到了错误 `No module named sound_conversion`，这意味着解释器没有获取到该包或模块。让我们编辑代码。参考以下代码：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `voice_changer1.py` program, we edit the `sys.path` for the program
    using `syntax sys.path.append("F:project_7daysmodulepackprograms")` . Let''s see
    the output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`voice_changer1.py`程序中，我们使用`syntax sys.path.append("F:project_7daysmodulepackprograms")`编辑了程序中的`sys.path`。让我们看看输出：
- en: '![](img/pythonpaackgetlast.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Python包获取最后](img/pythonpaackgetlast.jpg)'
- en: Output of the voice_chnager1.py program
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: voice_chnager1.py程序的输出
- en: The preceding screenshot shows that the code is running successfully. In this
    way, you can load the package and modules.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示代码正在成功运行。这样，你可以加载包和模块。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In the *Module* section, you have learned how to make modules and how to import
    them. By using the `dir()` function, you can check the involved function in the
    modules. The Python package is a collection of modules: generally a Python package
    is a directory. You have learned how Python searches the modules and packages.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在*模块*部分，你已经学习了如何创建模块以及如何导入它们。通过使用`dir()`函数，你可以检查模块中涉及到的函数。Python包是模块的集合：通常一个Python包是一个目录。你已经学习了Python如何搜索模块和包。
