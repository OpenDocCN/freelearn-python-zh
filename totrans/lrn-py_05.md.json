["```py\ndef square1(n):\n    return n ** 2  # squaring through the power operator\n\ndef square2(n):\n    return n * n  # squaring through multiplication\n```", "```py\n>>> map(lambda *a: a, range(3))  # without wrapping in list...\n<map object at 0x7f563513b518>  # we get the iterator object\n>>> list(map(lambda *a: a, range(3)))  # wrapping in list...\n[(0,), (1,), (2,)]  # we get a list with its elements\n>>> list(map(lambda *a: a, range(3), 'abc'))  # 2 iterables\n[(0, 'a'), (1, 'b'), (2, 'c')]\n>>> list(map(lambda *a: a, range(3), 'abc', range(4, 7)))  # 3\n[(0, 'a', 4), (1, 'b', 5), (2, 'c', 6)]\n>>> # map stops at the shortest iterator\n>>> list(map(lambda *a: a, (), 'abc'))  # empty tuple is shortest\n[]\n>>> list(map(lambda *a: a, (1, 2), 'abc'))  # (1, 2) shortest\n[(1, 'a'), (2, 'b')]\n>>> list(map(lambda *a: a, (1, 2, 3, 4), 'abc'))  # 'abc' shortest\n[(1, 'a'), (2, 'b'), (3, 'c')]\n\n```", "```py\nstudents = [\n    dict(id=0, credits=dict(math=9, physics=6, history=7)),\n    dict(id=1, credits=dict(math=6, physics=7, latin=10)),\n    dict(id=2, credits=dict(history=8, physics=9, chemistry=10)),\n    dict(id=3, credits=dict(math=5, physics=5, geography=7)),\n]\n\ndef decorate(student):\n    # create a 2-tuple (sum of credits, student) from student dict\n    return (sum(student['credits'].values()), student)\n\ndef undecorate(decorated_student):\n    # discard sum of credits, return original student dict\n    return decorated_student[1]\n\nstudents = sorted(map(decorate, students), reverse=True)\nstudents = list(map(undecorate, students))\n```", "```py\n$ python decorate.sort.undecorate.py\n[{'credits': {'chemistry': 10, 'history': 8, 'physics': 9}, 'id': 2},\n {'credits': {'latin': 10, 'math': 6, 'physics': 7}, 'id': 1},\n {'credits': {'history': 7, 'math': 9, 'physics': 6}, 'id': 0},\n {'credits': {'geography': 7, 'math': 5, 'physics': 5}, 'id': 3}]\n\n```", "```py\n>>> grades = [18, 23, 30, 27, 15, 9, 22]\n>>> avgs = [22, 21, 29, 24, 18, 18, 24]\n>>> list(zip(avgs, grades))\n[(22, 18), (21, 23), (29, 30), (24, 27), (18, 15), (18, 9), (24, 22)]\n>>> list(map(lambda *a: a, avgs, grades))  # equivalent to zip\n[(22, 18), (21, 23), (29, 30), (24, 27), (18, 15), (18, 9), (24, 22)]\n\n```", "```py\n>>> a = [5, 9, 2, 4, 7]\n>>> b = [3, 7, 1, 9, 2]\n>>> c = [6, 8, 0, 5, 3]\n>>> maxs = map(lambda n: max(*n), zip(a, b, c))\n>>> list(maxs)\n[6, 9, 2, 9, 7]\n\n```", "```py\n>>> test = [2, 5, 8, 0, 0, 1, 0]\n>>> list(filter(None, test))\n[2, 5, 8, 1]\n>>> list(filter(lambda x: x, test))  # equivalent to previous one\n[2, 5, 8, 1]\n>>> list(filter(lambda x: x > 4, test))  # keep only items > 4\n[5, 8]\n\n```", "```py\n# If you code like this you are not a Python guy! ;)\n>>> squares = []\n>>> for n in range(10):\n...     squares.append(n ** 2)\n...\n>>> list(squares)\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n# This is better, one line, nice and readable\n>>> squares = map(lambda n: n**2, range(10))\n>>> list(squares)\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n```", "```py\n>>> [n ** 2 for n in range(10)]\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n```", "```py\n# using map and filter\nsq1 = list(\n    filter(lambda n: not n % 2, map(lambda n: n ** 2, range(10)))\n)\n# equivalent, but using list comprehensions\nsq2 = [n ** 2 for n in range(10) if not n % 2]\n\nprint(sq1, sq1 == sq2)  # prints: [0, 4, 16, 36, 64] True\n```", "```py\nitems = 'ABCDE'\npairs = []\nfor a in range(len(items)):\n    for b in range(a, len(items)):\n        pairs.append((items[a], items[b]))\n```", "```py\n[('A', 'A'), ('A', 'B'), ('A', 'C'), ('A', 'D'), ('A', 'E'), ('B', 'B'), ('B', 'C'), ('B', 'D'), ('B', 'E'), ('C', 'C'), ('C', 'D'), ('C', 'E'), ('D', 'D'), ('D', 'E'), ('E', 'E')]\n\n```", "```py\nitems = 'ABCDE'\npairs = [(items[a], items[b])\n    for a in range(len(items)) for b in range(a, len(items))]\n```", "```py\nfrom math import sqrt\n# this will generate all possible pairs\nmx = 10\nlegs = [(a, b, sqrt(a**2 + b**2))\n    for a in range(1, mx) for b in range(a, mx)]\n# this will filter out all non pythagorean triples\nlegs = list(\n    filter(lambda triple: triple[2].is_integer(), legs))\nprint(legs)  # prints: [(3, 4, 5.0), (6, 8, 10.0)]\n```", "```py\nfrom math import sqrt\nmx = 10\nlegs = [(a, b, sqrt(a**2 + b**2))\n    for a in range(1, mx) for b in range(a, mx)]\nlegs = filter(lambda triple: triple[2].is_integer(), legs)\n# this will make the third number in the tuples integer\nlegs = list(\n    map(lambda triple: triple[:2] + (int(triple[2]), ), legs))\nprint(legs)  # prints: [(3, 4, 5), (6, 8, 10)]\n```", "```py\nfrom math import sqrt\n# this step is the same as before\nmx = 10\nlegs = [(a, b, sqrt(a**2 + b**2))\n    for a in range(1, mx) for b in range(a, mx)]\n# here we combine filter and map in one CLEAN list comprehension\nlegs = [(a, b, int(c)) for a, b, c in legs if c.is_integer()]\nprint(legs)  # prints: [(3, 4, 5), (6, 8, 10)]\n```", "```py\nfrom string import ascii_lowercase\nlettermap = dict((c, k) for k, c in enumerate(ascii_lowercase, 1))\n```", "```py\n{'a': 1,\n 'b': 2,\n 'c': 3,\n ... omitted results ...\n 'x': 24,\n 'y': 25,\n 'z': 26}\n\n```", "```py\nlettermap = {c: k for k, c in enumerate(ascii_lowercase, 1)}\n```", "```py\nword = 'Hello'\nswaps = {c: c.swapcase() for c in word}\nprint(swaps)  # prints: {'o': 'O', 'l': 'L', 'e': 'E', 'H': 'h'}\n```", "```py\nword = 'Hello'\npositions = {c: k for k, c in enumerate(word)}\nprint(positions)  # prints: {'l': 3, 'o': 4, 'e': 1, 'H': 0}\n```", "```py\nword = 'Hello'\nletters1 = set(c for c in word)\nletters2 = {c for c in word}\nprint(letters1)  # prints: {'l', 'o', 'H', 'e'}\nprint(letters1 == letters2)  # prints: True\n```", "```py\ndef get_squares(n):  # classic function approach\n    return [x ** 2 for x in range(n)]\nprint(get_squares(10))\n\ndef get_squares_gen(n):  # generator approach\n    for x in range(n):\n        yield x ** 2  # we yield, we don't return\nprint(list(get_squares_gen(10)))\n```", "```py\ndef get_squares_gen(n):\n    for x in range(n):\n        yield x ** 2\n\nsquares = get_squares_gen(4)  # this creates a generator object\nprint(squares)  # <generator object get_squares_gen at 0x7f158...>\nprint(next(squares))  # prints: 0\nprint(next(squares))  # prints: 1\nprint(next(squares))  # prints: 4\nprint(next(squares))  # prints: 9\n# the following raises StopIteration, the generator is exhausted,\n# any further call to next will keep raising StopIteration\nprint(next(squares))\n```", "```py\ndef geometric_progression(a, q):\n    k = 0\n    while True:\n        result = a * q**k\n        if result <= 100000:\n            yield result\n        else:\n            return\n        k += 1\n\nfor n in geometric_progression(2, 5):\n    print(n)\n```", "```py\n$ python gen.yield.return.py\n2\n10\n50\n250\n1250\n6250\n31250\n\n```", "```py\ndef get_squares_gen(n):\n    for x in range(n):\n        yield x ** 2\n\nsquares = get_squares_gen(3)\nprint(squares.__next__())  # prints: 0\nprint(squares.__next__())  # prints: 1\nprint(squares.__next__())  # prints: 4\n# the following raises StopIteration, the generator is exhausted,\n# any further call to next will keep raising StopIteration\nprint(squares.__next__())\n```", "```py\ndef counter(start=0):\n    n = start\n    while True:\n        yield n\n        n += 1\n\nc = counter()\nprint(next(c))  # prints: 0\nprint(next(c))  # prints: 1\nprint(next(c))  # prints: 2\n```", "```py\nstop = False\ndef counter(start=0):\n    n = start\n    while not stop:\n        yield n\n        n += 1\n\nc = counter()\nprint(next(c))  # prints: 0\nprint(next(c))  # prints: 1\nstop = True\nprint(next(c))  # raises StopIteration\n```", "```py\ndef counter(start=0):\n    n = start\n    while True:\n        result = yield n             # A\n        print(type(result), result)  # B\n        if result == 'Q':\n break\n        n += 1\n\nc = counter()\nprint(next(c))         # C\nprint(c.send('Wow!'))  # D\nprint(next(c))         # E\nprint(c.send('Q'))     # F\n```", "```py\n$ python gen.send.py\n0\n<class 'str'> Wow!\n1\n<class 'NoneType'> None\n2\n<class 'str'> Q\nTraceback (most recent call last):\n File \"gen.send.py\", line 14, in <module>\n print(c.send('Q'))     # F\nStopIteration\n\n```", "```py\ndef print_squares(start, end):\n    for n in range(start, end):\n yield n ** 2\n\nfor n in print_squares(2, 5):\n    print(n)\n```", "```py\ndef print_squares(start, end):\n    yield from (n ** 2 for n in range(start, end))\n\nfor n in print_squares(2, 5):\n    print(n)\n```", "```py\n>>> cubes = [k**3 for k in range(10)]  # regular list\n>>> cubes\n[0, 1, 8, 27, 64, 125, 216, 343, 512, 729]\n>>> type(cubes)\n<class 'list'>\n>>> cubes_gen = (k**3 for k in range(10))  # create as generator\n>>> cubes_gen\n<generator object <genexpr> at 0x7ff26b5db990>\n>>> type(cubes_gen)\n<class 'generator'>\n>>> list(cubes_gen)  # this will exhaust the generator\n[0, 1, 8, 27, 64, 125, 216, 343, 512, 729]\n>>> list(cubes_gen)  # nothing more to give\n[]\n\n```", "```py\ndef adder(*n):\n    return sum(n)\ns1 = sum(map(lambda n: adder(*n), zip(range(100), range(1, 101))))\ns2 = sum(adder(*n) for n in zip(range(100), range(1, 101)))\n```", "```py\ncubes = [x**3 for x in range(10)]\nodd_cubes1 = filter(lambda cube: cube % 2, cubes)\nodd_cubes2 = (cube for cube in cubes if cube % 2)\n```", "```py\nN = 20\ncubes1 = map(\n    lambda n: (n, n**3),\n    filter(lambda n: n % 3 == 0 or n % 5 == 0, range(N))\n)\ncubes2 = (\n    (n, n**3) for n in range(N) if n % 3 == 0 or n % 5 == 0)\n```", "```py\ns1 = sum([n**2 for n in range(10**6)])\ns2 = sum((n**2 for n in range(10**6)))\ns3 = sum(n**2 for n in range(10**6))\n```", "```py\ns = sum([n**2 for n in range(10**8)])  # this is killed\n# s = sum(n**2 for n in range(10**8))  # this succeeds\nprint(s)\n```", "```py\n$ python sum.example.2.py\nKilled\n\n```", "```py\n$ python sum.example.2.py\n333333328333333350000000\n\n```", "```py\nfrom time import time\nmx = 5500  # this is the max I could reach with my computer...\n\nt = time()  # start time for the for loop\ndmloop = []\nfor a in range(1, mx):\n    for b in range(a, mx):\n        dmloop.append(divmod(a, b))\nprint('for loop: {:.4f} s'.format(time() - t))  # elapsed time\n\nt = time()  # start time for the list comprehension\ndmlist = [\n    divmod(a, b) for a in range(1, mx) for b in range(a, mx)]\nprint('list comprehension: {:.4f} s'.format(time() - t))\n\nt = time()  # start time for the generator expression\ndmgen = list(\n    divmod(a, b) for a in range(1, mx) for b in range(a, mx))\nprint('generator expression: {:.4f} s'.format(time() - t))\n\n# verify correctness of results and number of items in each list\nprint(dmloop == dmlist == dmgen, len(dmloop))\n```", "```py\n$ python performances.py\nfor loop: 4.3433 s\nlist comprehension: 2.7238 s\ngenerator expression: 3.1380 s\nTrue 15122250\n\n```", "```py\nfrom time import time\nmx = 2 * 10 ** 7\n\nt = time()\nabsloop = []\nfor n in range(mx):\n    absloop.append(abs(n))\nprint('for loop: {:.4f} s'.format(time() - t))\n\nt = time()\nabslist = [abs(n) for n in range(mx)]\nprint('list comprehension: {:.4f} s'.format(time() - t))\n\nt = time()\nabsmap = list(map(abs, range(mx)))\nprint('map: {:.4f} s'.format(time() - t))\n\nprint(absloop == abslist == absmap)\n```", "```py\n$ python performances.map.py\nfor loop: 3.1283 s\nlist comprehension: 1.3966 s\nmap: 1.2319 s\nTrue\n\n```", "```py\n>>> import this\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.  #\nSimple is better than complex.  #\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.  #\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.  #\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n\n```", "```py\ndef gcd(a, b):\n    \"\"\"Calculate the Greatest Common Divisor of (a, b). \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a\n```", "```py\nfrom functions import gcd\nN = 50\n\ntriples = sorted(                                      # 1\n    ((a, b, c) for a, b, c in (                        # 2\n        ((m**2 - n**2), (2 * m * n), (m**2 + n**2))    # 3\n        for m in range(1, int(N**.5) + 1)              # 4\n        for n in range(1, m)                           # 5\n        if (m - n) % 2 and gcd(m, n) == 1              # 6\n    ) if c <= N), key=lambda *triple: sum(*triple)     # 7\n)\n\nprint(triples)\n```", "```py\nfrom functions import gcd\n\ndef gen_triples(N):\n    for m in range(1, int(N**.5) + 1):            # 1\n        for n in range(1, m):                     # 2\n            if (m - n) % 2 and gcd(m, n) == 1:    # 3\n                c = m**2 + n**2                   # 4\n                if c <= N:                        # 5\n                    a = m**2 - n**2               # 6\n                    b = 2 * m * n                 # 7\n                    yield (a, b, c)               # 8\n\ntriples = sorted(\n    gen_triples(50), key=lambda *triple: sum(*triple))  # 9\nprint(triples)\n```", "```py\n$ python pythagorean.triple.generation.py\n[(3, 4, 5), (5, 12, 13), (15, 8, 17), (7, 24, 25), (21, 20, 29), (35, 12, 37), (9, 40, 41)]\n\n```", "```py\nA = 100\nex1 = [A for A in range(5)]\nprint(A)  # prints: 100\n\nex2 = list(A for A in range(5))\nprint(A)  # prints: 100\n\nex3 = dict((A, 2 * A) for A in range(5))\nprint(A)  # prints: 100\n\nex4 = set(A for A in range(5))\nprint(A)  # prints: 100\n\ns = 0\nfor A in range(5):\n    s += A\nprint(A)  # prints: 4\n```", "```py\nex1 = [A for A in range(5)]\nprint(A)  # breaks: NameError: name 'A' is not defined\n```", "```py\ns = 0\nfor A in range(5):\n    s += A\nprint(A)  # prints: 4\nprint(globals())\n```", "```py\n$ python scopes.for.py\n4\n{'__spec__': None, '__name__': '__main__', 's': 10, 'A': 4, '__doc__': None, '__cached__': None, '__package__': None, '__file__': 'scopes.for.py', '__loader__': <_frozen_importlib.SourceFileLoader object at 0x7f05a5a183c8>, '__builtins__': <module 'builtins' (built-in)>}\n\n```", "```py\ndef fibonacci(N):\n    \"\"\"Return all fibonacci numbers up to N. \"\"\"\n    result = [0]\n    next_n = 1\n    while next_n <= N:\n        result.append(next_n)\n        next_n = sum(result[-2:])\n    return result\n\nprint(fibonacci(0))  # [0]\nprint(fibonacci(1))  # [0, 1, 1]\nprint(fibonacci(50))  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n```", "```py\ndef fibonacci(N):\n    \"\"\"Return all fibonacci numbers up to N. \"\"\"\n    yield 0\n    if N == 0:\n        return\n    a = 0\n    b = 1\n    while b <= N:\n        yield b\n        a, b = b, a + b\n\nprint(list(fibonacci(0)))  # [0]\nprint(list(fibonacci(1)))  # [0, 1, 1]\nprint(list(fibonacci(50))) # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n```", "```py\ndef fibonacci(N):\n    \"\"\"Return all fibonacci numbers up to N. \"\"\"\n    a, b = 0, 1\n    while a <= N:\n        yield a\n        a, b = b, a + b\n```"]