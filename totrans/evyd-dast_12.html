<html><head></head><body>
<div class="book" title="Chapter&#xA0;12.&#xA0;Sorting: Bringing Order Out Of Chaos"><div class="book" id="21PMQ2-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12" class="calibre1"/>Chapter 12. Sorting: Bringing Order Out Of Chaos</h1></div></div></div><p class="calibre7">Being able to build the right data structure or collection class for a particular application is only half the battle. Unless the data sets in your problem domain are very small, any collection of your data will benefit from a little organization. Organizing the elements in your list or collection by a particular value or set of values is known as <span class="strong"><strong class="calibre16">sorting</strong></span>.</p><p class="calibre7">Sorting your data is not strictly necessary, but doing so makes searching or lookup operations much more efficient. Likewise, when you need to merge multiple collections of data together, having the various collections sorted in advance of the merge can greatly improve the efficiency of the merge operation.</p><p class="calibre7">If your data is a collection of numeric values, then sorting can be something as simple as arranging it in ascending or descending order. However, if your data consists of complex objects, you can sort the collection by a particular value. In this case, the field or property by which the data is sorted is referred to as a <span class="strong"><strong class="calibre16">key</strong></span>. For example, if you have a collection of car objects and you want to sort them by their make, such as Ford, Chevrolet or Dodge, then the make is the key. However, if you wanted to sort by multiple keys, say the make and model, then the make becomes the <span class="strong"><em class="calibre20">primary key</em></span>, while the model becomes the <span class="strong"><em class="calibre20">secondary key</em></span>. Further extensions of this pattern would result in <span class="strong"><em class="calibre20">tertiary keys</em></span>, <span class="strong"><em class="calibre20">Quaternary keys</em></span>, and so on.</p><p class="calibre7">Sorting algorithms come in many shapes and sizes, and many of them are specifically suited to particular types of data structures. Although an exhaustive examination of known or even just popular sorting algorithms is beyond the scope of this book, in this chapter, we will focus on those algorithms that are either fairly common or are well suited to some of the data structures we have already examined. In each case, we will review examples in each of the four languages we have been looking at and discuss the complexity cost.
 In this chapter, we will cover the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Selection sort</li><li class="listitem">Insertion sort</li><li class="listitem">Bubble sort</li><li class="listitem">Quick sort</li><li class="listitem">Merge sort</li><li class="listitem">Bucket sort</li><li class="listitem">Counting sort</li></ul></div></div>

<div class="book" title="Chapter&#xA0;12.&#xA0;Sorting: Bringing Order Out Of Chaos">
<div class="book" title="Selection sort"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch12lvl1sec61" class="calibre1"/>Selection sort</h1></div></div></div><p class="calibre7">A selection sort can be described as an in-place comparison. This algorithm divides a collection or list of objects into two parts. The first is a subset of objects that have already been sorted, ranging from <span class="strong"><em class="calibre20">0</em></span> to <span class="strong"><em class="calibre20">i,</em></span> where <span class="strong"><em class="calibre20">i</em></span> is the next object to be sorted. The second is a subset of objects that have not been sorted, ranging from <span class="strong"><em class="calibre20">i</em></span> to <span class="strong"><em class="calibre20">n,</em></span> where <span class="strong"><em class="calibre20">n</em></span> is the length of the collection.</p><p class="calibre7">The selection sort algorithm works by taking the smallest or largest value in a collection and placing it at the beginning of the unsorted subarray by swapping it with the object at the current index. For example, consider ordering a collection in ascending order. At the outset, the sorted subarray will consist of 0 members, while the unsorted subarray will consist of all the members in the set. The selection sort algorithm will find the smallest member in the unsorted subarray and place it at the beginning of the unsorted subarray.</p><p class="calibre7">At this point, the sorted subarray consists of one member, while the unsorted subarray consists of all the remaining members in the original set. This process will repeat until all members of the unsorted subarray have been placed in the sorted subarray.</p><p class="calibre7">Given the following set of values:</p><p class="calibre7"><span class="strong"><em class="calibre20">S = {50, 25, 73, 21, 3}</em></span></p><p class="calibre7">Our algorithm will find the smallest value in <span class="strong"><em class="calibre20">S[0...4]</em></span>, which in this case is <span class="strong"><em class="calibre20">3</em></span>, and place it at the beginning of <span class="strong"><em class="calibre20">S[0...4]:</em></span></p><p class="calibre7"><span class="strong"><em class="calibre20">S = {3, 25, 73, 21, 50}</em></span></p><p class="calibre7">The process is repeated for <span class="strong"><em class="calibre20">S[1...4]</em></span>, which returns the value 21:</p><p class="calibre7"><span class="strong"><em class="calibre20">S = {3, 21, 73, 25, 50}</em></span></p><p class="calibre7">The next evaluation at <span class="strong"><em class="calibre20">S[2...4]</em></span> returns a value of 25:</p><p class="calibre7"><span class="strong"><em class="calibre20">S = {3, 21, 25, 73, 50}</em></span></p><p class="calibre7">Finally, the function repeats again for <span class="strong"><em class="calibre20">S[3...4]</em></span> which returns the smallest value of 50:</p><p class="calibre7"><span class="strong"><em class="calibre20">S = {3, 21, 25, 50, 73}</em></span></p><p class="calibre7">There is no need to examine the last object in the collection because it, by necessity, is already the largest remaining value. This is a small consolation, however, because the selection sort algorithm still has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n<sup class="calibre21">2</sup></em></span>) complexity cost. Moreover, this worst-case complexity score doesn't tell the whole tale in this particular case. The selection sort is always an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n<sup class="calibre21">2</sup></em></span>) complexity, even under the best of circumstances. Therefore, the selection sort is quite possibly the slowest and most inefficient sorting algorithm you may encounter.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note42" class="calibre1"/>Note</h3><p class="calibre7">Each of the code examples in this chapter will examine algorithms in the form of those methods most essential to the operation, with these being detached from their parent classes. Additionally, in each case the collection of objects being sorted will be defined at the class level, outside of the example code shown here. Likewise, the subsequent object instantiation and population of those collections will be defined outside the example code. To see the full class examples, please use the code examples accompanying this text.</p></div><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><pre class="programlisting">    public void SelectionSort(int[] values) 
    { 
        if (values.Length &lt;= 1) 
        return; 
   
        int j, minIndex; 
        for (int i = 0; i &lt; values.Length - 1; i++) 
        { 
            minIndex = i; 
            for (j = i + 1; j &lt; values.Length; j++) 
            { 
                if (values[j] &lt; values[minIndex]) 
                { 
                    minIndex = j; 
                } 
            } 
            Swap(ref values[minIndex], ref values[i]); 
        } 
    } 
 
    void Swap(ref int x, ref int y) 
    { 
        int t = x; 
        x = y; 
        y = t; 
    } 
</pre><p class="calibre7">Each of our implementations of the <code class="literal">SelectionSort</code> method begins by confirming that the <code class="literal">values</code> array has at least two members. If not, the method returns as there are not enough members to sort. Otherwise, we create two nested loops. The outer <code class="literal">for</code> loop moves the boundary of the unsorted array one index at a time, while the inner <code class="literal">for</code> loop is used to find the minimum value within the unsorted boundary. Once we have a minimum value, the method swaps the member at <code class="literal">i</code> with the member identified as the current minimum. Since C# does not support passing primitives by reference by default we must explicitly invoke the <code class="literal">ref</code> keyword on both the <code class="literal">swap(ref int x, ref int y)</code> method signature as well as the called parameter. Although it may seem like more work to create a separate <code class="literal">swap</code> method for this purpose, the swap functionality is common to several popular sorting algorithms and having this code in a separate method saves us some keystrokes later on.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="tip43" class="calibre1"/>Tip</h3><p class="calibre7"><span class="strong"><strong class="calibre16">Nested for loops</strong></span></p><p class="calibre7">Remember that nested loops will automatically increase the complexity of an algorithm exponentially. Any algorithm with a <code class="literal">for</code> loop has a complexity cost of <span class="strong"><strong class="calibre16">O</strong></span>(n), but once you nest another <code class="literal">for</code> loop within the first the complexity cost increases to <span class="strong"><strong class="calibre16">O</strong></span>(n<sup class="calibre21">2</sup>). Nesting another <code class="literal">for</code> loop within the second makes the cost <span class="strong"><strong class="calibre16">O</strong></span>(n<sup class="calibre21">3</sup>), and so on.</p><p class="calibre7">Also note that nesting <code class="literal">for</code> loops in any implementation will be a red flag to an observant reviewer and you should always be ready to justify such a design. Only nest for loops when you absolutely must.</p></div><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><pre class="programlisting">    public void selectionSort(int[] values) 
    { 
        if (values.length &lt;= 1) 
            return; 
 
        int j, minIndex; 
        for (int i = 0; i &lt; values.length - 1; i++) 
        { 
            minIndex = i; 
            for (j = i + 1; j &lt; values.length; j++) 
            { 
                if (values[j] &lt; values[minIndex]) 
                { 
                    minIndex = j; 
                } 
            } 
 
            int temp = values[minIndex]; 
            values[minIndex] = values[i]; 
            values[i] = temp; 
        } 
    } 
</pre><p class="calibre7">The Java implementation is nearly identical in design to the C# implementation, except for the name of the array <code class="literal">length</code> function. However, Java does not support passing primitives by reference at all. Although it is possible to emulate this behavior by passing the primitive to an instance of a mutable wrapper class, most developers agree that this is a bad idea. Instead, our Java implementation performs the swap directly inside the <code class="literal">for</code> loop.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><pre class="programlisting">    -(void)selectionSort:(NSMutableArray&lt;NSNumber*&gt;*)values 
    { 
        if ([values count] &lt;= 1) 
            return; 
     
        NSInteger j, minIndex; 
        for (int i = 0; i &lt; [values count] - 1; i++) 
        { 
            minIndex = i; 
            for (j = i + 1; j &lt; [values count]; j++) 
            { 
                if ([values[j] intValue] &lt; [values[minIndex] intValue]) 
                { 
                    minIndex = j; 
                } 
            } 
         
            NSNumber *temp = (NSNumber*)values[minIndex]; 
            values[minIndex] = values[i]; 
            values[i] = temp; 
        } 
    } 
</pre><p class="calibre7">Since <code class="literal">NSArray</code> can only store objects, we need to cast our values to <code class="literal">NSNumber</code>, and when we evaluate the members we need to explicitly examine the <code class="literal">intValue</code> object. Like Java, we opt to not create a separate swap method and pass the values by reference. Otherwise, implementations.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><pre class="programlisting">    open func selectionSort( values: inout [Int]) 
    { 
        if (values.count &lt;= 1) 
        { 
            return 
        } 
     
        var minIndex: Int 
        for i in 0..&lt;values.count 
        { 
            minIndex = i 
            for j in i+1..&lt;values.count 
            { 
                if (values[j] &lt; values[minIndex]) 
                { 
                    minIndex = j 
                } 
            } 
     
            swap(x: &amp;values[minIndex], y: &amp;values[i]) 
        } 
    } 

    open func swap( x: inout Int, y: inout Int) 
    { 
        let t: Int = x 
        x = y 
        y = t 
    } 
</pre><p class="calibre7">Swift does not permit C-style <code class="literal">for</code> loops so our method must use the Swift 3.0 equivalent. Also, since Swift considers arrays to be <code class="literal">struct</code> implementations instead of class implementations, the <code class="literal">values</code> parameter cannot be simply passed by reference. Therefore, our Swift implementation includes the <code class="literal">inout</code> decorator on the <code class="literal">values</code> parameter. Otherwise, the functionality is fundamentally the same as its predecessors. This rule also applies in our <code class="literal">swap( x: inout Int, y: inout Int)</code> method, which is used to swap the values during the sort.</p></div></div>
<div class="book" title="Insertion sort"><div class="book" id="22O7C2-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec62" class="calibre1"/>Insertion sort</h1></div></div></div><p class="calibre7">An <span class="strong"><strong class="calibre16">insertion sort</strong></span> is a very simple algorithm that looks at an object in a collection and compares its key to the keys prior to itself. You can visualize this process as how many of us order a hand of playing cards, individually removing and inserting cards from left to right in ascending order.</p><p class="calibre7">For example, consider the case of ordering a collection in ascending order. An insertion sort algorithm will examine an object at index <span class="strong"><em class="calibre20">i</em></span> and determine if it's key is lower in value or priority than the object at index <span class="strong"><em class="calibre20">i - 1</em></span>. If so, the object at <span class="strong"><em class="calibre20">i</em></span> is removed and inserted at <span class="strong"><em class="calibre20">i - 1</em></span>. At this point, the function will repeat and continue to loop in this manner until the object key at <span class="strong"><em class="calibre20">i - 1</em></span> is not lower than the object key at <span class="strong"><em class="calibre20">i</em></span>.</p><p class="calibre7">Given the following set of values:</p><p class="calibre7"><span class="strong"><em class="calibre20">S = {50, 25, 73, 21, 3}</em></span></p><p class="calibre7">Our algorithm will begin examining the list at <span class="strong"><em class="calibre20">i = 1</em></span>. We do this because at <span class="strong"><em class="calibre20">i = 0</em></span>, <span class="strong"><em class="calibre20">i - 1</em></span> is a non-existent value and would require special handling.</p><p class="calibre7">Since 25 is less than 50, it is removed and reinserted at <span class="strong"><em class="calibre20">i = 0</em></span>. Since we're at index 0, there is nothing left to examine to the left of 25, so this iteration is complete:</p><p class="calibre7"><span class="strong"><em class="calibre20">S = {25, 50, 73, 21, 3}</em></span></p><p class="calibre7">Next we examine <span class="strong"><em class="calibre20">i = 2</em></span>. Because 73 is not less than 50, this value doesn't need to move. Since we have already sorted everything to the left of <span class="strong"><em class="calibre20">i = 2</em></span>, this iteration is immediately completed. At <span class="strong"><em class="calibre20">i = 3</em></span>, the value 21 is less than 73 and so it is removed and reinserted at <span class="strong"><em class="calibre20">i = 2</em></span>. Checking again, 21 is less than 50, so the value 21 is removed and reinserted at index 1. Finally, 21 is less than 25, so the value 21 is removed and reinserted at <span class="strong"><em class="calibre20">i = 0</em></span>. Since we're now at index 0, there is nothing left to examine to the left of 21, so this iteration are complete:</p><p class="calibre7"><span class="strong"><em class="calibre20">S = {21, 25, 50, 73, 3}</em></span></p><p class="calibre7">Finally, we come to <span class="strong"><em class="calibre20">i = 4</em></span>, the end of the list. Since 3 is less than 21, the value 3 is removed and reinserted at <span class="strong"><em class="calibre20">i = 3</em></span>. Next, 3 is less than 73, so the value 3 is removed and reinserted at <span class="strong"><em class="calibre20">i = 2</em></span>. At <span class="strong"><em class="calibre20">i = 2</em></span>, 3 is less than 50 so the value 3 is removed and reinserted at <span class="strong"><em class="calibre20">i = 1</em></span>. At <span class="strong"><em class="calibre20">i = 1</em></span>, 3 is less than 25 so the value 3 is removed and reinserted at <span class="strong"><em class="calibre20">i = 0</em></span>. Since we're now at index 0, there is nothing left to examine to the left of 3 so this iteration, and our sorting function, are complete:</p><p class="calibre7"><span class="strong"><em class="calibre20">S = {3, 21, 25, 50, 73}</em></span></p><p class="calibre7">As you can see this algorithm is simple but also potentially expensive for larger lists of objects or values. The insertion sort has a worst-case and even an <span class="strong"><em class="calibre20">average-</em></span>case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n<sup class="calibre21">2</sup></em></span>). However, unlike selection sort, insertion sort has improved efficiency when sorting lists that were previously sorted. As a result, it enjoys a best-case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>), making this algorithm a slightly better choice than selection sort.</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><pre class="programlisting">    public void InsertionSort(int[] values) 
    { 
      if (values.Length &lt;= 1) 
        return; 
   
      int j, value; 
      for (int i = 1; i &lt; values.Length; i++) 
      { 
        value = values[i]; 
        j = i - 1; 
 
        while (j &gt;= 0 &amp;&amp; values[j] &gt; value) 
        { 
          values[j + 1] = values[j]; 
          j = j - 1; 
        } 
        values[j + 1] = value; 
      }   
    } 
</pre><p class="calibre7">Each of our implementations of the <code class="literal">InsertionSort</code> method begins by confirming that the <code class="literal">values</code> array has at least two members. If not, the method returns as there are not enough members to sort. Otherwise, two integer variables are declared named <code class="literal">j</code> and <code class="literal">value</code>. Next a <code class="literal">for</code> loop is created that iterates through the members of the collection. The index <code class="literal">i</code> is used to track the position of the last sorted member. Within this for loop, <code class="literal">value</code> is assigned to the last sorted member while <code class="literal">j</code> is used to track the position in the current iteration through the unsorted members. Our <code class="literal">while</code> loop continues until <code class="literal">j</code> is equal to <code class="literal">0</code> and the value at index <code class="literal">j</code> is greater than the value at index <code class="literal">i</code>. In every iteration of the <code class="literal">while</code> loop, we swap the member at position <code class="literal">j</code> with the member at position <code class="literal">j + 1</code>, then the loop decrements the value of <code class="literal">j</code> by 1 to move back through the collection. Finally, the last step is to set the member stored in <code class="literal">value</code> at position <code class="literal">j + 1</code>.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><pre class="programlisting">    public void insertionSort(int[] values) 
    { 
        if (values.length &lt;= 1) 
            return; 
 
        int j, value; 
        for (int i = 1; i &lt; values.length; i++) 
        { 
            value = values[i]; 
            j = i - 1; 
 
            while (j &gt;= 0 &amp;&amp; values[j] &gt; value) 
            { 
                values[j + 1] = values[j]; 
                j = j - 1; 
            } 
            values[j + 1] = value; 
        }   
    } 
</pre><p class="calibre7">The Java implementation is nearly identical in design to the C# implementation, except for the name of the array <code class="literal">length</code> function.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><pre class="programlisting">    -(void)insertionSort:(NSMutableArray&lt;NSNumber*&gt;*)values 
    { 
        if ([values count] &lt;= 1) 
            return; 
     
        NSInteger j, value; 
        for (int i = 1; i &lt; [values count]; i++) 
        { 
            value = [values[i] intValue]; 
            j = i - 1; 
         
            while (j &gt;= 0 &amp;&amp; [values[j] intValue] &gt; value) 
            { 
                values[j + 1] = values[j]; 
                j = j - 1; 
            } 
            values[j + 1] = [NSNumber numberWithInteger:value]; 
        } 
    } 
</pre><p class="calibre7">Since <code class="literal">NSArray</code> can only store objects, we need to cast our values to the <code class="literal">NSNumber</code> variable, and when we evaluate the members we need to explicitly examine the <code class="literal">intValue</code> variable. Otherwise, this implementation is fundamentally the same as the C# or Java implementations.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><pre class="programlisting">    open func insertionSort( values: inout [Int]) 
    { 
        if (values.count &lt;= 1) 
        { 
            return 
        } 
     
        var j, value: Int 
        for i in 1..&lt;values.count 
        { 
            value = values[i]; 
            j = i - 1; 
 
            while (j &gt;= 0 &amp;&amp; values[j] &gt; value) 
            { 
                values[j + 1] = values[j]; 
                j = j - 1; 
            } 
            values[j + 1] = value; 
        } 
    } 
</pre><p class="calibre7">Swift does not permit C-style <code class="literal">for</code> loops, so our method must use the Swift 3.0 equivalent. Also, since Swift considers arrays to be struct implementations instead of class implementations, the <code class="literal">values</code> parameter cannot be simply passed by reference. Therefore, our Swift implementation includes the <code class="literal">inout</code> decorator on the <code class="literal">values</code> parameter. Otherwise, the functionality is fundamentally the same as its predecessors.</p></div>
<div class="book" title="Bubble sort"><div class="book" id="23MNU2-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec63" class="calibre1"/>Bubble sort</h1></div></div></div><p class="calibre7"><span class="strong"><strong class="calibre16">Bubble sort</strong></span> is another simple algorithm that steps through the list of values or objects to be sorted and compares adjacent items or their keys to determine if they are in the wrong order. The name comes from the way that unordered items seem to bubble to the top of the list. However, some developers sometimes refer to this as a <span class="strong"><strong class="calibre16">sinking sort</strong></span>, as objects could just as easily appear to be dropping down through the list.</p><p class="calibre7">Overall, the bubble sort is just another inefficient comparison sort. However, it does have one distinct advantage over other comparison sorts, in that: inherently determine whether or not the list has been sorted. Bubble sort accomplishes this by not performing comparisons on objects that were sorted in previous iterations and by stopping once the collection proves ordered.</p><p class="calibre7">For example, consider the case of ordering a collection in ascending order. A bubble sort algorithm will examine an object at index <span class="strong"><em class="calibre20">i</em></span> and determine if its key is lower in value or priority than the object at index <span class="strong"><em class="calibre20">i + 1,</em></span> in which case the two objects are swapped.</p><p class="calibre7">Given the following set of values:</p><p class="calibre7"><span class="strong"><em class="calibre20">S = {50, 25, 73, 21, 3}</em></span></p><p class="calibre7">The bubble sort algorithm will compare <span class="strong"><em class="calibre20">{i = 0, i = 1}</em></span>. Since 50 is greater than 25, the two are swapped. Next the method compares <span class="strong"><em class="calibre20">{i = 1, i = 2}</em></span>. In this case 50 is less than 73, so nothing changes. At <span class="strong"><em class="calibre20">{i = 2, i = 3},</em></span> 73 is greater than 21 so they are swapped. Finally, at <span class="strong"><em class="calibre20">{i = 3, i = 4}</em></span>, 73 is greater than 3, so they are swapped as well. After our first iteration, our set now looks like this:</p><p class="calibre7"><span class="strong"><em class="calibre20">S = {25, 50, 21, 3, 73}</em></span></p><p class="calibre7">Let's examine another iteration. In this iteration, our algorithm will begin by comparing <span class="strong"><em class="calibre20">{i = 0, i = 1}</em></span>, and since 25 is less than 50 nothing changes. Next we examine <span class="strong"><em class="calibre20">{i = 1, i = 2}</em></span>. Since 50 is greater than 21 the two are swapped. At <span class="strong"><em class="calibre20">{i = 2, i = 3}</em></span>, 50 is greater than 3 so the two are swapped. Since <span class="strong"><em class="calibre20">i = 4</em></span> was sorted in the previous iteration, the loop halts and resets to position <span class="strong"><em class="calibre20">i = 0</em></span> for the next iteration. After the second iteration our set looks like this:</p><p class="calibre7"><span class="strong"><em class="calibre20">S = {25, 21, 3, 50, 73}</em></span></p><p class="calibre7">This shows us that iterations through the set consist of <span class="strong"><em class="calibre20">n - j</em></span> comparisons, where <span class="strong"><em class="calibre20">n</em></span> is the number of items in the set and <span class="strong"><em class="calibre20">j</em></span> is the current iteration count. Therefore, after each iteration the bubble sort becomes <span class="strong"><em class="calibre20">slightly</em></span> more efficient. Plus, once the set proves to be sorted the iterations stop altogether. Although bubble sort has a worst case and an average case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n<sup class="calibre21">2</sup></em></span>), the ability to limit the sorting to objects that have not been sorted provides the algorithm with a best case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>), making this approach slightly better than selection sort but about equal to insertion sort. In certain circumstances where the list is already sorted, the bubble sort is also slightly more efficient than <span class="strong"><strong class="calibre16">quick sort</strong></span>, which we will discuss later. However, bubble sort is still a terribly inefficient algorithm that is unsuitable for all but small collections of objects.</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><pre class="programlisting">    public void BubbleSort(int[] values) 
    { 
      bool swapped; 
      for (int i = 0; i &lt; values.Length - 1; i++) 
      { 
        swapped = false; 
        for (int j = values.Length - 1; j &gt; i; j--) 
        { 
          if (values[j] &lt; values[j - 1]) 
          { 
            Swap(ref values[j], ref values[j - 1]); 
            swapped = true; 
          } 
        } 
 
        if (swapped == false) 
          break; 
      } 
    } 
</pre><p class="calibre7">Each of our implementations of the <code class="literal">BubbleSort</code> method begins by declaring a Boolean value named <code class="literal">swapped</code>. This value is critical to the optimized bubble sort method as it is used to track whether any objects were swapped during the current iteration. If <code class="literal">true</code>, there is no guarantee that the list is guaranteed so at least one more iteration is required. If <code class="literal">false</code>, no objects were swapped meaning that the list is ordered and the algorithm can stop now.</p><p class="calibre7">Next we create a <code class="literal">for</code> loop that iterates through the members of the collection. This loop effectively tracks our current iteration. Inside this loop, we immediately set <code class="literal">swapped</code> variable to <code class="literal">false</code> and then create another inner loop, which moves backward through the collection performing comparisons on the pair of objects. If the pair of objects is determined to be out of order, the <code class="literal">BubbleSort()</code> method calls the same <code class="literal">swap()</code> method examined in the selection sort discussion and then changes swapped to true. Otherwise, the execution continues to the next iteration of <code class="literal">j</code>. Once the inner loop is completed, the method checks the <code class="literal">swapped</code> variable to determine if any objects were ordered. If false, the execution continues to the next iteration of <code class="literal">i</code>. Otherwise, the method breaks out of the outer loop and the execution is finished.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><pre class="programlisting">    public void bubbleSort(int[] values) 
    { 
        boolean swapped; 
        for (int i = 0; i &lt; values.length - 1; i++) 
        { 
            swapped = false; 
            for (int j = values.length -1; j &gt; i; j--) 
            { 
                if (values[j] &lt; values[j - 1]) 
                { 
                    int temp = values[j]; 
                    values[j] = values[j - 1]; 
                    values[j - 1] = temp; 
                    swapped = true; 
                } 
            } 
 
            if (swapped == false) 
                break; 
        } 
    } 
</pre><p class="calibre7">The Java implementation is nearly identical in design to the C# implementation, except for the name of the array <code class="literal">length</code> function. However, Java does not support passing primitives by reference at all. Although it is possible to emulate this behavior by passing the primitive to an instance of a mutable wrapper class, most developers agree that this is a bad idea. Instead, our Java implementation performs the swap directly inside the <code class="literal">for</code> loop.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><pre class="programlisting">    -(void)bubbleSortArray:(NSMutableArray&lt;NSNumber*&gt;*)values 
    { 
        bool swapped; 
        for (NSInteger i = 0; i &lt; [values count] - 1; i++) 
        { 
            swapped = false; 
            for (NSInteger j = [values count] - 1; j &gt; i; j--) 
            { 
                if (values[j] &lt; values[j - 1]) 
                { 
                    NSInteger temp = [values[j] intValue]; 
                    values[j] = values[j - 1]; 
                    values[j - 1] = [NSNumber numberWithInteger:temp]; 
                    swapped = true; 
                } 
            } 
         
            if (swapped == false) 
                break; 
        } 
    } 
</pre><p class="calibre7">Since the <code class="literal">NSArray</code> variable can only store objects, we need to cast our values to <code class="literal">NSNumber</code>, and when we evaluate the members we need to explicitly examine the <code class="literal">intValue</code>. Like Java, we opt to not create a separate swap method, and pass the values by reference. Otherwise, this implementation is fundamentally the same as the C# or Java implementations.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><pre class="programlisting">    open func bubbleSort( values: inout [Int]) 
    { 
        var swapped: Bool     
        for i in 0..&lt;values.count - 1 
        { 
            swapped = false 
            for j in ((i + 1)..&lt;values.count).reversed() 
            { 
                if (values[j] &lt; values[j - 1]) 
                { 
                    swap(x: &amp;values[j], y: &amp;values[j - 1]) 
                    swapped = true 
                }  
            } 
     
            if (swapped == false) 
            { 
                break 
            } 
        } 
    } 
</pre><p class="calibre7">Swift does not permit C-style <code class="literal">for</code> loops so our method must use the Swift 3.0 equivalent. Also, since Swift considers arrays to be struct implementations instead of class implementations, the <code class="literal">values</code> parameter cannot be simply passed by reference. Therefore, our Swift implementation includes the <code class="literal">inout</code> decorator on the <code class="literal">values</code> parameter. Otherwise, the functionality is fundamentally the same as its predecessors. This rule also applies in our <code class="literal">swap( x: inout Int, y: inout Int)</code> method, which is used to swap the values during the sort.</p></div>
<div class="book" title="Quick sort"><div class="book" id="24L8G2-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec64" class="calibre1"/>Quick sort</h1></div></div></div><p class="calibre7">The quick sort is one of a set of algorithms known as <span class="strong"><strong class="calibre16">divide-and-conquer</strong></span>. Divide and conquer algorithms work by recursively breaking down a set of objects into two or more sub sets until each sub set becomes simple enough to solve directly. In the case of quick sort, the algorithm picks an element called a <span class="strong"><strong class="calibre16">pivot</strong></span>, and then sorts by moving all smaller items prior to it and greater items after it. Moving elements before and after the pivot is the primary component of a quick sort algorithm and is referred to as a <span class="strong"><strong class="calibre16">partition</strong></span>. The partition is recursively repeated on smaller and smaller sub sets until each sub set contains the 0 or 1 element, at which point the set is ordered.</p><p class="calibre7">Choosing the correct pivot point is critical in maintaining quick sort's improved performance. For example, choosing the smallest or largest element in the list will result in <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n<sup class="calibre21">2</sup></em></span>) complexity. Although there is no bulletproof approach for choosing the best pivot, there are fundamentally four approaches your design can take:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Always pick the <span class="strong"><em class="calibre20">first</em></span> object in the collection.</li><li class="listitem">Always pick the <span class="strong"><em class="calibre20">median</em></span> object in the collection.</li><li class="listitem">Always pick the <span class="strong"><em class="calibre20">last</em></span> object in the collection.</li><li class="listitem">Choose an object at <span class="strong"><em class="calibre20">random</em></span> from the collection.</li></ul></div><p class="calibre7">In the following examples, we will take the third approach and choose the last object in the collection as the pivot.</p><p class="calibre7">Although the quick sort algorithm has a worst case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n<sup class="calibre21">2</sup></em></span>) like other sorts we have examined thus far, it has a much improved average- and best-case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span> log(<span class="strong"><em class="calibre20">n</em></span>)), cost making it, on average, better than the selection, insertion and bubble sort approaches.</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><pre class="programlisting">    public void QuickSort(int[] values, int low, int high) 
    { 
      if (low &lt; high) 
      { 
        int index = Partition(values, low, high); 
 
        QuickSort(values, low, index -1); 
        QuickSort(values, index +1, high); 
      } 
    } 
 
    int Partition(int[] values, int low, int high) 
    { 
      int pivot = values[high]; 
      int i = (low - 1); 
      for (int j = low; j &lt;= high -1; j++) 
      { 
        if (values[j] &lt;= pivot) 
        { 
          i++; 
 
          Swap(ref values[i], ref values[j]); 
        } 
      } 
   
    i++; 
      Swap(ref values[i], ref values[high]); 
      return i; 
    } 
</pre><p class="calibre7">Each of our implementations of the <code class="literal">QuickSort</code> method begins by checking if the low index is less than the high index. If <code class="literal">false</code>, the sub set is empty or has one item so it is ordered by definition and the method returns. If <code class="literal">true</code>, the method first determines the <code class="literal">index</code> of the next division of sub sets by calling the <code class="literal">Partition(int[] values, int low, int high)</code> method. Next, the <code class="literal">QuickSort(int[] values, int low, int high)</code> method is called recursively on the lower and upper sub sets, which are defined based on <code class="literal">index</code>.</p><p class="calibre7">The real magic in this algorithm occurs in the <code class="literal">Partition(int[] values, int low, int high)</code> method. Here, an <code class="literal">index</code> variable is defined for the pivot, which in our case is the last object in the collection. Next, <code class="literal">i</code> is defined as the <code class="literal">low</code> index <code class="literal">-1</code>. Our algorithm then loops through the list from <code class="literal">low</code> to <code class="literal">high -1</code>. Within the loop, if the value at <code class="literal">i</code> is less than or equal to the pivot, we increment <code class="literal">i</code>, so we have the index of the first unsorted object in the collection, then we swap that unsorted object with the object at <code class="literal">j</code> which is less than the pivot.</p><p class="calibre7">Once the loop is completed we increment <code class="literal">i</code> one more time because <span class="strong"><em class="calibre20">i + 1</em></span> is the first object in the collection that is greater than the pivot while every object prior to <span class="strong"><em class="calibre20">i + 1</em></span> is less than the pivot. Our method swaps the value at <span class="strong"><em class="calibre20">i</em></span> and the pivot object at index <code class="literal">high</code> so the pivot is also properly ordered. Finally, the method returns <code class="literal">i</code>, which is the index of the next break point for the <code class="literal">QuickSort(int[] values, int low, int high)</code> method.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><pre class="programlisting">    public void quickSort(int[] values, int low, int high) 
    { 
        if (low &lt; high) 
        { 
            int index = partition(values, low, high); 
 
            quickSort(values, low, index - 1); 
            quickSort(values, index + 1, high); 
        } 
    } 
 
    int partition(int[] values, int low, int high) 
    { 
        int pivot = values[high]; 
        int i = (low - 1); 
        for (int j = low; j &lt;= high - 1; j++) 
        { 
            if (values[j] &lt;= pivot) 
            { 
                i++; 
 
                int temp = values[i]; 
                values[i] = values[j]; 
                values[j] = temp; 
            } 
        } 
 
        i++; 
        int temp = values[i]; 
        values[i] = values[high]; 
        values[high] = temp; 
 
        return i;  
    } 
</pre><p class="calibre7">The Java implementation is nearly identical in design to the C# implementation, except for the name of the array <code class="literal">length</code> function. However, Java does not support passing primitives by reference at all. Although it is possible to emulate this behavior by passing the primitive to an instance of a mutable wrapper class, most developers agree that this is a bad idea. Instead, our Java implementation performs the swap directly inside the <code class="literal">for</code> loop and the method itself.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><pre class="programlisting">    -(void)quickSortArray:(NSMutableArray&lt;NSNumber*&gt;*)values forLowIndex:(NSInteger)low andHighIndex:(NSInteger)high 
    { 
        if (low &lt; high) 
        { 
            NSInteger index = [self partitionArray:values forLowIndex:low andHighIndex:high]; 
            [self quickSortArray:values forLowIndex:low andHighIndex:index - 1]; 
            [self quickSortArray:values forLowIndex:index + 1 andHighIndex:high]; 
        } 
    } 
 
    -(NSInteger)partitionArray:(NSMutableArray&lt;NSNumber*&gt;*)values forLowIndex:(NSInteger)low andHighIndex:(NSInteger)high 
    { 
        NSInteger pivot = [values[high] intValue]; 
        NSInteger i = (low - 1); 
        for (NSInteger j = low; j &lt;= high - 1; j++) 
        { 
            if ([values[j] intValue] &lt;= pivot) 
            { 
                i++; 
             
                NSInteger temp = [values[i] intValue]; 
                values[i] = values[j]; 
                values[j] = [NSNumber numberWithInteger:temp]; 
            } 
        } 
     
        i++; 
        NSInteger temp = [values[i] intValue]; 
        values[i] = values[high]; 
        values[high] = [NSNumber numberWithInteger:temp]; 
     
        return i; 
    } 
</pre><p class="calibre7">Since the <code class="literal">NSArray</code> variable can only store objects, we need to cast our values to <code class="literal">NSNumber</code>, and when we evaluate the members we need to explicitly examine the <code class="literal">intValue</code>. Like Java, we opt to not create a separate swap method and pass the values by reference. Otherwise, this implementation is fundamentally the same as the C# or Java implementations.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><pre class="programlisting">    open func quickSort( values: inout [Int], low: Int, high: Int) 
    { 
        if (low &lt; high) 
        { 
            let index: Int = partition( values: &amp;values, low: low, high: high) 
         
            quickSort( values: &amp;values, low: low, high: index - 1) 
            quickSort( values: &amp;values, low: index + 1, high: high) 
        } 
    } 
 
    func partition( values: inout [Int], low: Int, high: Int) -&gt; Int 
    { 
        let pivot: Int = values[high] 
        var i: Int = (low - 1) 
        var j: Int = low 
     
        while j &lt;= (high - 1) 
        { 
            if (values[j] &lt;= pivot) 
            { 
                i += 1 
                swap(x: &amp;values[i], y: &amp;values[j]) 
            } 
         
            j += 1 
        } 
     
        i += 1 
        swap(x: &amp;values[i], y: &amp;values[high]) 
     
        return i; 
    } 
</pre><p class="calibre7">Swift does not permit C-style <code class="literal">for</code> loops so our Swift 3.0 version of the <code class="literal">mergeSort:</code> method is somewhat limited in this case. Therefore, our <code class="literal">for</code> loop will be replaced by a <code class="literal">while</code> loop. As such, we are define <code class="literal">j</code> as the <code class="literal">low</code> index value and increment <code class="literal">j</code> explicitly within each iteration of the <code class="literal">while</code> loop. Also, since Swift considers arrays to be struct implementations instead of class implementations, the <code class="literal">values</code> parameter cannot be simply passed by reference. Therefore, our Swift implementation includes the <code class="literal">inout</code> decorator on the <code class="literal">values</code> parameter. Otherwise, the functionality is fundamentally the same as its predecessors. This rule also applies in our <code class="literal">swap(x: inout Int, y: inout Int)</code> method, which is used to swap the values during the sort.</p></div>
<div class="book" title="Merge sort"><div class="book" id="25JP22-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec65" class="calibre1"/>Merge sort</h1></div></div></div><p class="calibre7"><span class="strong"><strong class="calibre16">Merge sort</strong></span> is another popular version of the divide and conquer algorithm. It is a very efficient, general-purpose sort algorithm. The algorithm gets is named from the fact that it divides the collection in half, recursively sorts each half, and then merges the two sorted halves back together. Each half of the collection is repeatedly halved until there is only one object in the half, at which point it is sorted by definition. As each sorted half is merged, the algorithm compares the objects to determine where to place each sub set.</p><p class="calibre7">As far as divide and conquer algorithms are concerned, merge sort is one of the most efficient algorithms. The algorithm has a worst-, average- and best- case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span> log(<span class="strong"><em class="calibre20">n</em></span>)), making it an improvement over quick sort even in the worst circumstances.</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><pre class="programlisting">    public void MergeSort(int[] values, int left, int right) 
    { 
      if (left == right) 
        return; 
 
      if (left &lt; right) 
      { 
        int middle = (left + right) / 2; 
 
        MergeSort(values, left, middle); 
        MergeSort(values, middle + 1, right); 
 
        int[] temp = new int[values.Length]; 
        for (int n = left; n &lt;= right; n++) 
        { 
          temp[n] = values[n]; 
        } 
 
        int index1 = left;  
        int index2 = middle + 1; 
        for (int n = left; n &lt;= right; n++) 
        { 
          if (index1 == middle + 1) 
          { 
            values[n] = temp[index2++]; 
          } 
          else if (index2 &gt; right) 
          { 
            values[n] = temp[index1++]; 
          } 
          else if (temp[index1] &lt; temp[index2]) 
          { 
            values[n] = temp[index1++]; 
          } 
          else 
          { 
            values[n] = temp[index2++]; 
          } 
        } 
      }     
    } 
</pre><p class="calibre7">In each of our implementations of the <code class="literal">MergeSort</code> method, the <code class="literal">left</code> and <code class="literal">right</code> parameters define the beginning and end of a collection within the overall <code class="literal">values</code> array. When the method is initially called, the <code class="literal">left</code> parameter should be 0 and the <code class="literal">right</code> parameter should be the index of the final object in the <code class="literal">values</code> collection.</p><p class="calibre7">The method begins by checking whether the <code class="literal">left</code> index is equal to the <code class="literal">right</code> index. If <code class="literal">true</code>, the sub set is empty or has one item so it is ordered by definition and the method returns. Otherwise, the method checks whether the <code class="literal">left</code> index is less than the <code class="literal">right</code> index. If <code class="literal">false</code>, the method returns as this sub set is already ordered.</p><p class="calibre7">If <code class="literal">true</code>, the method execution begins in earnest. First, the method determines the mid point of the current sub set as this will be needed to divide the sub set into two new halves. The <code class="literal">middle</code> variable is declared and defined by adding <code class="literal">left</code> and <code class="literal">right</code> and dividing the sum by 2. Next, the <code class="literal">MergeSort(int[] values, int left, int right)</code> method is called recursively on each of the two halves by passing the values array and using <code class="literal">left</code>, <code class="literal">right</code>, and <code class="literal">middle</code> as guidelines. Following this, the method creates a new array called <code class="literal">temp</code> of the same size as <code class="literal">values</code>, and populates only the indices that correlate to the current sub set. Once the <code class="literal">temp</code> array is populated, the method creates two <code class="literal">int</code> variables called <code class="literal">index1</code> and <code class="literal">index2</code>, which represent the starting points of the two halves in the current sub set.</p><p class="calibre7">Finally, we get to the <code class="literal">for</code> loop, which iterates through the sub set from start to finish (<code class="literal">left</code> to <code class="literal">right</code>) and orders the values found there. The logic in each of these <code class="literal">if</code> statement is self-explanatory, but it helps to understand the reasoning behind these particular comparisons:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The first comparison is only <code class="literal">true</code> when the left sub set has been exhausted of values, at which time the <code class="literal">values[n]</code> array is set to the value at <code class="literal">temp[index2]</code>. Following this, using the post-increment operator, the <code class="literal">index2</code> variable is incremented by 1 to move the pointer within the right sub set one index to the right.</li><li class="listitem">The second comparison is only <code class="literal">true</code> when the right sub set has been exhausted of values, at which time the <code class="literal">values[n]</code> array is set to the value at <code class="literal">temp[index1]</code>. Following this, using the post-increment operator, <code class="literal">index1</code> variable is incremented by 1 to move the pointer within the left sub set one index to the right.</li><li class="listitem">The third and final comparison is only evaluated when there are values in both the left and right subsets that have not yet been ordered. This comparison is <code class="literal">true</code> when the value at the <code class="literal">temp[index1]</code> array is less than the value at <code class="literal">temp[index2]</code>, at which time the <code class="literal">values[n]</code> array is set to <code class="literal">temp[index1]</code>. Again, following this, using the post-increment operator, the <code class="literal">index1</code> variable is incremented by 1 to move the pointer within the left sub set one index to the right.</li><li class="listitem">Finally, when all other logical options are false, the default behavior assumes that the value at <code class="literal">temp[index1]</code> array is greater than the value at <code class="literal">temp[index2]</code>, so the else block sets the value at the <code class="literal">values[n]</code> array to <code class="literal">temp[index2]</code>. Following this, using the post-increment operator, the <code class="literal">index2</code> variable is incremented by 1 to move the pointer within the right sub set one index to the right.</li></ul></div><span class="strong"><strong class="calibre16">Java</strong></span><pre class="programlisting">    public void mergeSort(int[] values, int left, int right) 
    { 
        if (left == right) 
            return; 
 
        if (left &lt; right) 
        { 
            int middle = (left + right) / 2; 
 
            mergeSort(values, left, middle); 
            mergeSort(values, middle + 1, right); 
     
            int[] temp = new int[values.length]; 
            for (int n = left; n &lt;= right; n++) 
            { 
                temp[n] = values[n]; 
            } 
 
            int index1 = left; 
            int index2 = middle + 1; 
            for (int n = left; n &lt;= right; n++) 
            { 
                if (index1 == middle + 1) 
                { 
                    values[n] = temp[index2++]; 
                } 
                else if (index2 &gt; right) 
                { 
                    values[n] = temp[index1++]; 
                } 
                else if (temp[index1] &lt; temp[index2]) 
                { 
                    values[n] = temp[index1++]; 
                } 
                else 
                { 
                    values[n] = temp[index2++]; 
                } 
            } 
        } 
    } 
</pre><p class="calibre7">The Java implementation is nearly identical in design to the C# implementation, except for the name of the array <code class="literal">length</code> function.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><pre class="programlisting">    -(void)mergeSort:(NSMutableArray*)values withLeftIndex:(NSInteger)left andRightIndex:(NSInteger)right 
    { 
        if (left == right) 
            return; 
     
        if (left &lt; right) 
        { 
            NSInteger middle = (left + right) / 2; 
         
            [self mergeSort:values withLeftIndex:left andRightIndex:middle]; 
            [self mergeSort:values withLeftIndex:middle + 1 andRightIndex:right]; 
            NSMutableArray *temp = [NSMutableArray arrayWithArray:values]; 
            NSInteger index1 = left; 
            NSInteger index2 = middle + 1; 
            for (NSInteger n = left; n &lt;= right; n++) 
            { 
                if (index1 == middle + 1) 
                { 
                    values[n] = temp[index2++]; 
                } 
                else if (index2 &gt; right) 
                { 
                    values[n] = temp[index1++]; 
                } 
                else if (temp[index1] &lt; temp[index2]) 
                { 
                    values[n] = temp[index1++]; 
                } 
                else 
                { 
                    values[n] = temp[index2++]; 
                } 
            } 
        } 
    } 
</pre><p class="calibre7">The Objective-C implementation of <code class="literal">mergeSort:withLeftIndex:andRightIndex:</code> is fundamentally identical to the C# and Java implementations.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><pre class="programlisting">    open func mergeSort( values: inout [Int], left: Int, right: Int) 
    { 
        if (values.count &lt;= 1) 
        { 
            return 
        } 
 
        if (left == right) 
        { 
            return 
        } 
     
        if (left &lt; right) 
        { 
            let middle: Int = (left + right) / 2 
         
            mergeSort(values: &amp;values, left: left, right: middle) 
            mergeSort(values: &amp;values, left: middle + 1, right: right) 
         
            var temp = values 
         
            var index1: Int = left 
            var index2: Int = middle + 1 
            for n in left...right 
            { 
                if (index1 == middle + 1) 
                { 
                    values[n] = temp[index2] 
                    index2 += 1 
                } 
                else if (index2 &gt; right) 
                { 
                    values[n] = temp[index1] 
                    index1 += 1 
                } 
                else if (temp[index1] &lt; temp[index2]) 
                { 
                    values[n] = temp[index1] 
                    index1 += 1 
                } 
                else 
                { 
                    values[n] = temp[index2] 
                    index2 += 1 
                } 
            } 
        } 
    } 
</pre><p class="calibre7">Swift does not permit C-style <code class="literal">for</code> loops so our method but the Swift 3.0 equivalent is somewhat limited for this case. Since Swift considers arrays to be struct implementations instead of class implementations, the <code class="literal">values</code> parameter cannot be simply passed by reference. This is not necessarily a problem for this merge sort implementation because whenever the method is called recursively the entire <code class="literal">values</code> array is passed as a parameter. However, to make the method more consistent with other algorithms being discussed here, and to avoid the need to declare a return type, this implementation still includes the <code class="literal">inout</code> decorator on the <code class="literal">values</code> parameter. Otherwise, the functionality is fundamentally the same as its predecessors.</p></div>
<div class="book" title="Bucket sort" id="26I9K1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec66" class="calibre1"/>Bucket sort</h1></div></div></div><p class="calibre7"><span class="strong"><strong class="calibre16">Bucket sort</strong></span>, also known as <span class="strong"><strong class="calibre16">bin sort</strong></span>, is a type of distribution sorting algorithm. Distribution sorts are algorithms that scatter the original values into any sort of intermediate structures that are then ordered, gathered, and merged into the final output structure. It is important to note that, although bucket sort is considered a distribution sort, most implementations typically leverage a comparison sort to order the contents of the buckets.
This algorithm sorts values by distributing them throughout an array of arrays that are called <span class="strong"><strong class="calibre16">buckets</strong></span>. Elements are distributed based on their value and the range of values assigned to each bucket. For example, if one bucket inclusively accepts a range of values from 5 to 10, and the original set consists of 3, 5, 7, 9, and 11, the values 5, 7, and 9 would be placed in this hypothetical bucket.</p><p class="calibre7">Once all of the values have been distributed to their respective buckets, the buckets themselves are then ordered by recursively calling the bucket sort algorithm again. Eventually, each of the buckets is sorted and then the sorted results are concatenated into a complete sorted collection.</p><p class="calibre7">Bucket sort can be much faster than other sorting algorithms because of how elements are assigned to the buckets, typically using an array for each bucket where the value represents the index. Although the algorithm still suffers from a worst case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n<sup class="calibre21">2</sup></em></span>), the average an best case complexity is a mere <span class="strong"><em class="calibre20">O(n + k)</em></span>, where <span class="strong"><em class="calibre20">n</em></span> is the number of elements in the original array, and <span class="strong"><em class="calibre20">k</em></span> is the total number of buckets used to sort the collection.</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><pre class="programlisting">    public void BucketSort(int[] values, int maxVal) 
    { 
      int[] bucket = new int[maxVal + 1]; 
      int num = values.Length; 
      int bucketNum = bucket.Length; 
 
      for (int i = 0; i &lt; bucketNum; i++) 
      { 
        bucket[i] = 0; 
      } 
 
      for (int i = 0; i &lt; num; i++) 
      { 
        bucket[values[i]]++; 
      } 
 
      int pos = 0; 
      for (int i = 0; i &lt; bucketNum; i++) 
      { 
        for (int j = 0; j &lt; bucket[i]; j++) 
        { 
          values[pos++] = i; 
        } 
      } 
    } 
</pre><p class="calibre7">Each of our implementations of the <code class="literal">BucketSort</code> method begins by creating the empty buckets based on the total number of elements in the <code class="literal">values</code> array. Next, a <code class="literal">for</code> loop is used to populate the buckets with a base value of <code class="literal">0</code>. This is immediately followed by a second <code class="literal">for</code> loop that distributes the elements from values into the various buckets. Finally, a nested <code class="literal">for</code> loop is used to actually sort the elements in the buckets and in turn the <code class="literal">values</code> array.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><pre class="programlisting">    public void BucketSort(int[] values, int maxVal) 
    { 
        int[] bucket = new int[maxVal + 1]; 
        int num = values.length; 
        int bucketNum = bucket.length; 
 
        for (int i = 0; i &lt; bucketNum; i++) 
        { 
            bucket[i] = 0; 
        } 
 
        for (int i = 0; i &lt; num; i++) 
        { 
            bucket[values[i]]++; 
        } 
 
        int pos = 0; 
        for (int i = 0; i &lt; bucketNum; i++) 
        { 
            for (int j = 0; j &lt; bucket[i]; j++) 
            { 
                values[pos++] = i; 
            } 
        } 
    } 
</pre><p class="calibre7">The Java implementation is nearly identical in design to the C# implementation, except for the name of the array <code class="literal">length</code> function.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><pre class="programlisting">    -(void)bucketSortArray:(NSMutableArray&lt;NSNumber*&gt;*)values withMaxValue:(NSInteger)maxValue 
    { 
        NSMutableArray&lt;NSNumber*&gt;*bucket = [NSMutableArray array]; 
        NSInteger num = [values count]; 
        NSInteger bucketNum = maxValue + 1; 
     
        for (int i = 0; i &lt; bucketNum; i++) 
        { 
            [bucket insertObject:[NSNumber numberWithInteger:0] atIndex:i]; 
        } 
     
        for (int i = 0; i &lt; num; i++) 
        { 
            NSInteger value=[bucket[[values[i] intValue]] intValue]+ 1; 
            bucket[[values[i] intValue]] = [NSNumber numberWithInteger:value]; 
        } 
     
        int pos = 0; 
     
        for (int i = 0; i &lt; bucketNum; i++) 
        { 
            for (int j = 0; j &lt; [bucket[i] intValue]; j++) 
            { 
                values[pos++] = [NSNumber numberWithInteger:i]; 
            } 
        } 
    } 
</pre><p class="calibre7">Since the <code class="literal">NSArray</code> array can only store objects, we need to cast our values to the <code class="literal">NSNumber</code> array, and when we evaluate the members we need to explicitly examine the <code class="literal">intValue</code> variable. Otherwise, this implementation is fundamentally the same as the C# or Java implementations.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><pre class="programlisting">    open func bucketSort( values: inout [Int], maxVal: Int) 
    { 
        var bucket = [Int]() 
        let num: Int = values.count 
        let bucketNum: Int = bucket.count 
     
        for i in 0..&lt;bucketNum 
        { 
            bucket[i] = 0 
        } 
     
        for i in 0..&lt;num 
        { 
            bucket[values[i]] += 1 
        } 
     
        var pos: Int = 0 
        for i in 0..&lt;bucketNum 
        { 
            for _ in 0..&lt;bucket[i] 
            { 
                values[pos] = i 
                pos += 1 
            } 
        } 
    } 
</pre><p class="calibre7">Swift does not permit C-style <code class="literal">for</code> loops so our method must use the Swift 3.0 equivalent. Otherwise, the functionality is fundamentally the same as its predecessors.
</p></div>
<div class="book" title="Summary" id="27GQ61-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch12lvl1sec67" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter we discussed several of the more common sorting algorithms you might encounter in your day-to-day experience. We started with several comparison sorts including selection, insertion, and bubble. We noted that a selection sort is perhaps the most inefficient sorting algorithm you are likely to encounter in the real world, but that's not to say that it is completely academic. Insertion sort somewhat improves on selection, as does the bubble sorting algorithm. Next, we examined two divide and conquer sorting algorithms including quick sort and merge sort. Both of these approaches are much more efficient than comparison sorts. Finally, we explored a common and highly efficient distribution sort called the counting sort. The counting sort is the most efficient algorithm we examined, but it is not necessarily the best fit for every situation.</p></div></body></html>