["```py\nThis project is a personal scheduling system intended to keep track of\na single person's schedule and activities. The system will store and\ndisplay two kinds of schedule information: activities and statuses.\nActivities and statuses both support a protocol which allows them to\nbe checked for overlap with another object supporting the protocol.\n\n>>> from planner.data import Activity, Status\n>>> from datetime import datetime\n\nActivities and statuses are stored in schedules, to which they can be\nadded and removed.\n\n>>> from planner.data import Schedule\n>>> activity = Activity('test activity',\n..                      datetime(year = 2014, month = 6, day = 1,\n..                               hour = 10, minute = 15),\n..                      datetime(year = 2014, month = 6, day = 1,\n..                               hour = 12, minute = 30))\n>>> duplicate_activity = Activity('test activity',\n..                      datetime(year = 2014, month = 6, day = 1,\n..                               hour = 10, minute = 15),\n..                      datetime(year = 2014, month = 6, day = 1,\n..                               hour = 12, minute = 30))\n>>> status = Status('test status',\n...                 datetime(year = 2014, month = 7, day = 1,\n...                          hour = 10, minute = 15),\n...                 datetime(year = 2014, month = 7, day = 1,\n...                          hour = 12, minute = 30))\n>>> schedule = Schedule()\n>>> schedule.add(activity)\n>>> schedule.add(status)\n>>> status in schedule\nTrue\n>>> activity in schedule\nTrue\n>>> duplicate_activity in schedule\nTrue\n>>> schedule.remove(activity)\n>>> schedule.remove(status)\n>>> status in schedule\nFalse\n>>> activity in schedule\nFalse\n\nActivities represent tasks that the person must actively engage in,\nand they are therefore mutually exclusive: no person can have two\nactivities that overlap the same period of time.\n\n>>> activity1 = Activity('test activity 1',\n...                      datetime(year = 2014, month = 6, day = 1,\n...                               hour = 9, minute = 5),\n...                      datetime(year = 2014, month = 6, day = 1,\n...                               hour = 12, minute = 30))\n>>> activity2 = Activity('test activity 2',\n...                      datetime(year = 2014, month = 6, day = 1,\n...                               hour = 10, minute = 15),\n...                      datetime(year = 2014, month = 6, day = 1,\n...                               hour = 13, minute = 30))\n>>> schedule = Schedule()\n>>> schedule.add(activity1)\n>>> schedule.add(activity2)\nTraceback (most recent call last):\nScheduleError: \"test activity 2\" overlaps with \"test activity 1\"\n\nStatuses represent tasks that a person engages in passively, and so\ncan overlap with each other and with activities.\n\n>>> activity1 = Activity('test activity 1',\n...                      datetime(year = 2014, month = 6, day = 1,\n...                               hour = 9, minute = 5),\n...                      datetime(year = 2014, month = 6, day = 1,\n...                               hour = 12, minute = 30))\n>>> status1 = Status('test status 1',\n...                  datetime(year = 2014, month = 6, day = 1,\n...                           hour = 10, minute = 15),\n...                  datetime(year = 2014, month = 6, day = 1,\n...                           hour = 13, minute = 30))\n>>> status2 = Status('test status 2',\n...                  datetime(year = 2014, month = 6, day = 1,\n...                           hour = 8, minute = 45),\n...                  datetime(year = 2014, month = 6, day = 1,\n...                           hour = 15, minute = 30))\n>>> schedule = Schedule()\n>>> schedule.add(activity1)\n>>> schedule.add(status1)\n>>> schedule.add(status2)\n>>> activity1 in schedule\nTrue\n>>> status1 in schedule\nTrue\n>>> status2 in schedule\nTrue\n\nSchedules can be saved to a sqlite database, and they can be reloaded\nfrom that stored state.\n\n>>> from planner.persistence import file\n>>> storage = File(':memory:')\n>>> schedule.store(storage)\n>>> newsched = Schedule.load(storage)\n>>> schedule == newsched\nTrue\n```", "```py\nThis project is a personal scheduling system intended to keep track of\na single person's schedule and activities. The system will store and\ndisplay two kinds of schedule information: activities and statuses.\nActivities and statuses both support a protocol which allows them to\nbe checked for overlap with another object supporting the protocol.\n\n>>> from planner.data import Activity, Status\n>>> from datetime import datetime\n```", "```py\nActivities and statuses are stored in schedules, to which they can be\nadded and removed.\n\n>>> from planner.data import Schedule\n>>> activity = Activity('test activity',\n..                      datetime(year = 2014, month = 6, day = 1,\n..                               hour = 10, minute = 15),\n..                      datetime(year = 2014, month = 6, day = 1,\n..                               hour = 12, minute = 30))\n>>> duplicate_activity = Activity('test activity',\n..                      datetime(year = 2014, month = 6, day = 1,\n..                               hour = 10, minute = 15),\n..                      datetime(year = 2014, month = 6, day = 1,\n..                               hour = 12, minute = 30))\n>>> status = Status('test status',\n...                 datetime(year = 2014, month = 7, day = 1,\n...                          hour = 10, minute = 15),\n...                 datetime(year = 2014, month = 7, day = 1,\n...                          hour = 12, minute = 30))\n>>> schedule = Schedule()\n>>> schedule.add(activity)\n>>> schedule.add(status)\n>>> status in schedule\nTrue\n>>> activity in schedule\nTrue\n>>> duplicate_activity in schedule\nTrue\n>>> schedule.remove(activity)\n>>> schedule.remove(status)\n>>> status in schedule\nFalse\n>>> activity in schedule\nFalse\n```", "```py\nActivities represent tasks that the person must actively engage in,\nand they are therefore mutually exclusive: no person can have two\nactivities that overlap the same period of time.\n\n>>> activity1 = Activity('test activity 1',\n...                      datetime(year = 2014, month = 6, day = 1,\n...                               hour = 9, minute = 5),\n...                      datetime(year = 2014, month = 6, day = 1,\n...                               hour = 12, minute = 30))\n>>> activity2 = Activity('test activity 2',\n...                      datetime(year = 2014, month = 6, day = 1,\n...                               hour = 10, minute = 15),\n...                      datetime(year = 2014, month = 6, day = 1,\n...                               hour = 13, minute = 30))\n>>> schedule = Schedule()\n>>> schedule.add(activity1)\n>>> schedule.add(activity2)\nTraceback (most recent call last):\nScheduleError: \"test activity 2\" overlaps with \"test activity 1\"\n```", "```py\nStatuses represent tasks that a person engages in passively, and so\ncan overlap with each other and with activities.\n\n>>> activity1 = Activity('test activity 1',\n...                      datetime(year = 2014, month = 6, day = 1,\n...                               hour = 9, minute = 5),\n...                      datetime(year = 2014, month = 6, day = 1,\n...                               hour = 12, minute = 30))\n>>> status1 = Status('test status 1',\n...                  datetime(year = 2014, month = 6, day = 1,\n...                           hour = 10, minute = 15),\n...                  datetime(year = 2014, month = 6, day = 1,\n...                           hour = 13, minute = 30))\n>>> status2 = Status('test status 2',\n...                  datetime(year = 2014, month = 6, day = 1,\n...                           hour = 8, minute = 45),\n...                  datetime(year = 2014, month = 6, day = 1,\n...                           hour = 15, minute = 30))\n>>> schedule = Schedule()\n>>> schedule.add(activity1)\n>>> schedule.add(status1)\n>>> schedule.add(status2)\n>>> activity1 in schedule\nTrue\n>>> status1 in schedule\nTrue\n>>> status2 in schedule\nTrue\n```", "```py\nSchedules can be saved to a sqlite database, and they can be reloaded\nfrom that stored state.\n\n>>> from planner.persistence import file\n>>> storage = File(':memory:')\n>>> schedule.store(storage)\n>>> newsched = Schedule.load(storage)\n>>> schedule == newsched\nTrue\n```", "```py\nfrom unittest import TestCase\nfrom unittest.mock import patch, Mock\nfrom planner.data import Activity, TaskError\nfrom datetime import datetime\n\nclass constructor_tests(TestCase):\n    def test_valid(self):\n        activity = Activity('activity name',\n                           datetime(year = 2012, month = 9, day = 11),\n                           datetime(year = 2013, month = 4, day = 27))\n\n        self.assertEqual(activity.name, 'activity name')\n        self.assertEqual(activity.begins,\n                         datetime(year = 2012, month = 9, day = 11))\n        self.assertEqual(activity.ends,\n                         datetime(year = 2013, month = 4, day = 27))\n\n    def test_backwards_times(self):\n        self.assertRaises(TaskError,\n                          Activity,\n                          'activity name',\n                          datetime(year = 2013, month = 4, day = 27),\n                          datetime(year = 2012, month = 9, day = 11))\n\n    def test_too_short(self):\n        self.assertRaises(TaskError,\n                          Activity,\n                          'activity name',\n                          datetime(year = 2013, month = 4, day = 27,\n                                   hour = 7, minute = 15),\n                          datetime(year = 2013, month = 4, day = 27,\n                                   hour = 7, minute = 15))\n\nclass utility_tests(TestCase):\n    def test_repr(self):\n        activity = Activity('activity name',\n                           datetime(year = 2012, month = 9, day = 11),\n                           datetime(year = 2013, month = 4, day = 27))\n\n        expected = \"<activity name 2012-09-11T00:00:00 2013-04-27T00:00:00>\"\n\n        self.assertEqual(repr(activity), expected)\n\nclass exclusivity_tests(TestCase):\n    def test_excludes(self):\n        activity = Mock()\n\n        other = Activity('activity name',\n                         datetime(year = 2012, month = 9, day = 11),\n                         datetime(year = 2012, month = 10, day = 6))\n\n        # Any activity should exclude any activity\n        self.assertTrue(Activity.excludes(activity, other))\n\n        # Anything not known to be excluded should be included\n        self.assertFalse(Activity.excludes(activity, None))\n\nclass overlap_tests(TestCase):\n    def test_overlap_before(self):\n        activity = Mock(begins = datetime(year = 2012, month = 9, day = 11),\n                        ends = datetime(year = 2012, month = 10, day = 6))\n\n        other = Mock(begins = datetime(year = 2012, month = 10, day = 7),\n                     ends = datetime(year = 2013, month = 2, day = 5))\n\n        self.assertFalse(Activity.overlaps(activity, other))\n\n    def test_overlap_begin(self):\n        activity = Mock(begins = datetime(year = 2012, month = 8, day = 11),\n                        ends = datetime(year = 2012, month = 11, day = 27))\n\n        other = Mock(begins = datetime(year = 2012, month = 10, day = 7),\n                     ends = datetime(year = 2013, month = 2, day = 5))\n\n        self.assertTrue(Activity.overlaps(activity, other))\n\n    def test_overlap_end(self):\n        activity = Mock(begins = datetime(year = 2013, month = 1, day = 11),\n                        ends = datetime(year = 2013, month = 4, day = 16))\n\n        other = Mock(begins = datetime(year = 2012, month = 10, day = 7),\n                     ends = datetime(year = 2013, month = 2, day = 5))\n\n        self.assertTrue(Activity.overlaps(activity, other))\n\n    def test_overlap_inner(self):\n        activity = Mock(begins = datetime(year = 2012, month = 10, day = 11),\n                        ends = datetime(year = 2013, month = 1, day = 27))\n\n        other = Mock(begins = datetime(year = 2012, month = 10, day = 7),\n                     ends = datetime(year = 2013, month = 2, day = 5))\n\n        self.assertTrue(Activity.overlaps(activity, other))\n\n    def test_overlap_outer(self):\n        activity = Mock(begins = datetime(year = 2012, month = 8, day = 12),\n                        ends = datetime(year = 2013, month = 3, day = 15))\n\n        other = Mock(begins = datetime(year = 2012, month = 10, day = 7),\n                     ends = datetime(year = 2013, month = 2, day = 5))\n\n        self.assertTrue(Activity.overlaps(activity, other))\n\n    def test_overlap_after(self):\n        activity = Mock(begins = datetime(year = 2013, month = 2, day = 6),\n                        ends = datetime(year = 2013, month = 4, day = 27))\n\n        other = Mock(begins = datetime(year = 2012, month = 10, day = 7),\n                     ends = datetime(year = 2013, month = 2, day = 5))\n\n        self.assertFalse(Activity.overlaps(activity, other))\n```", "```py\n    def test_valid(self):\n        activity = Activity('activity name',\n                            datetime(year = 2012, month = 9, day = 11),\n                            datetime(year = 2013, month = 4, day = 27))\n\n        self.assertEqual(activity.name, 'activity name')\n        self.assertEqual(activity.begins,\n                         datetime(year = 2012, month = 9, day = 11))\n        self.assertEqual(activity.ends,\n                         datetime(year = 2013, month = 4, day = 27))\n```", "```py\n    def test_backwards_times(self):\n        self.assertRaises(TaskError,\n                          Activity,\n                          'activity name',\n                          datetime(year = 2013, month = 4, day = 27),\n                          datetime(year = 2012, month = 9, day = 11))\n```", "```py\n    def test_too_short(self):\n        self.assertRaises(TaskError,\n                          Activity,\n                          'activity name',\n                          datetime(year = 2013, month = 4, day = 27,\n                                   hour = 7, minute = 15),\n                          datetime(year = 2013, month = 4, day = 27,\n                                   hour = 7, minute = 15))\n```", "```py\nclass utility_tests(TestCase):\n    def test_repr(self):\n        activity = Activity('activity name',\n                            datetime(year = 2012, month = 9, day = 11),\n                            datetime(year = 2013, month = 4, day = 27))\n\n        expected = \"<activity name 2012-09-11T00:00:00 2013-04-27T00:00:00>\"\n\n        self.assertEqual(repr(activity), expected)\n```", "```py\n>>> from decimal import Decimal\n>>> x = Decimal('123.45678')\n>>> str(x)\n'123.45678'\n>>> repr(x)\n\"Decimal('123.45678')\"\n```", "```py\nclass exclusivity_tests(TestCase):\n    def test_excludes(self):\n        activity = Mock()\n\n        other = Activity('activity name',\n                         datetime(year = 2012, month = 9, day = 11),\n                         datetime(year = 2012, month = 10, day = 6))\n\n        # Any activity should exclude any activity\n        self.assertTrue(Activity.excludes(activity, other))\n\n        # Anything not known to be excluded should be included\n        self.assertFalse(Activity.excludes(activity, None))\n```", "```py\nclass overlap_tests(TestCase):\n    def test_overlap_before(self):\n        activity = Mock(begins = datetime(year = 2012, month = 9, day = 11),\n                        ends = datetime(year = 2012, month = 10, day = 6))\n\n        other = Mock(begins = datetime(year = 2012, month = 10, day = 7),\n                     ends = datetime(year = 2013, month = 2, day = 5))\n\n        self.assertFalse(Activity.overlaps(activity, other))\n\n    def test_overlap_begin(self):\n        activity = Mock(begins = datetime(year = 2012, month = 8, day = 11),\n                        ends = datetime(year = 2012, month = 11, day = 27))\n\n        other = Mock(begins = datetime(year = 2012, month = 10, day = 7),\n                     ends = datetime(year = 2013, month = 2, day = 5))\n\n        self.assertTrue(Activity.overlaps(activity, other))\n\n    def test_overlap_end(self):\n        activity = Mock(begins = datetime(year = 2013, month = 1, day = 11),\n                        ends = datetime(year = 2013, month = 4, day = 16))\n\n        other = Mock(begins = datetime(year = 2012, month = 10, day = 7),\n                     ends = datetime(year = 2013, month = 2, day = 5))\n\n        self.assertTrue(Activity.overlaps(activity, other))\n\n    def test_overlap_inner(self):         activity = Mock(begins = datetime(year = 2012, month = 10, day = 11),\n                        ends = datetime(year = 2013, month = 1, day = 27))\n\n        other = Mock(begins = datetime(year = 2012, month = 10, day = 7),\n                     ends = datetime(year = 2013, month = 2, day = 5))\n\n        self.assertTrue(Activity.overlaps(activity, other))\n\n    def test_overlap_outer(self):\n        activity = Mock(begins = datetime(year = 2012, month = 8, day = 12),\n                        ends = datetime(year = 2013, month = 3, day = 15))\n\n        other = Mock(begins = datetime(year = 2012, month = 10, day = 7),\n                     ends = datetime(year = 2013, month = 2, day = 5))\n\n        self.assertTrue(Activity.overlaps(activity, other))\n\n    def test_overlap_after(self):\n        activity = Mock(begins = datetime(year = 2013, month = 2, day = 6),\n                        ends = datetime(year = 2013, month = 4, day = 27))\n\n        other = Mock(begins = datetime(year = 2012, month = 10, day = 7),\n                     ends = datetime(year = 2013, month = 2, day = 5))\n\n        self.assertFalse(Activity.overlaps(activity, other))\n```", "```py\n    def test_excludes(self):\n        status = Mock()\n\n        other = Status('status name',\n                       datetime(year = 2012, month = 9, day = 11),\n                       datetime(year = 2012, month = 10, day = 6))\n\n        # A status shouldn't exclude anything\n        self.assertFalse(Status.excludes(status, other))\n        self.assertFalse(Status.excludes(status, None))\n```", "```py\nfrom unittest import TestCase\nfrom unittest.mock import patch, Mock\nfrom planner.data import Schedule, ScheduleError\nfrom datetime import datetime\n\nclass add_tests(TestCase):\n    overlap_exclude = Mock()\n    overlap_exclude.overlaps = Mock(return_value = True)\n    overlap_exclude.excludes = Mock(return_value = True)\n\n    overlap_include = Mock()\n    overlap_include.overlaps = Mock(return_value = True)\n    overlap_include.excludes = Mock(return_value = False)\n\n    distinct_exclude = Mock()\n    distinct_exclude.overlaps = Mock(return_value = False)\n    distinct_exclude.excludes = Mock(return_value = True)\n\n    distinct_include = Mock()\n    distinct_include.overlaps = Mock(return_value = False)\n    distinct_include.excludes = Mock(return_value = False)\n\n    def test_add_overlap_exclude(self):\n        schedule = Schedule()\n        schedule.add(self.distinct_include)\n        self.assertRaises(ScheduleError,\n                          schedule.add,\n                          self.overlap_exclude)\n\n    def test_add_overlap_include(self):\n        schedule = Schedule()\n        schedule.add(self.distinct_include)\n        schedule.add(self.overlap_include)\n\n    def test_add_distinct_exclude(self):\n        schedule = Schedule()\n        schedule.add(self.distinct_include)\n        schedule.add(self.distinct_exclude)\n\n    def test_add_distinct_include(self):\n        schedule = Schedule()\n        schedule.add(self.distinct_include)\n        schedule.add(self.distinct_include)\n\n    def test_add_over_overlap_exclude(self):\n        schedule = Schedule()\n        schedule.add(self.overlap_exclude)\n        self.assertRaises(ScheduleError,\n                          schedule.add,\n                          self.overlap_include)\n\n    def test_add_over_distinct_exclude(self):\n        schedule = Schedule()\n        schedule.add(self.distinct_exclude)\n        self.assertRaises(ScheduleError,\n                          schedule.add,\n                          self.overlap_include)\n\n    def test_add_over_overlap_include(self):\n        schedule = Schedule()\n        schedule.add(self.overlap_include)\n        schedule.add(self.overlap_include)\n\n    def test_add_over_distinct_include(self):\n        schedule = Schedule()\n        schedule.add(self.distinct_include)\n        schedule.add(self.overlap_include)\n\nclass in_tests(TestCase):\n    fake = Mock()\n    fake.overlaps = Mock(return_value = True)\n    fake.excludes = Mock(return_value = True)\n\n    def test_in_before_add(self):\n        schedule = Schedule()\n        self.assertFalse(self.fake in schedule)\n\n    def test_in_after_add(self):\n        schedule = Schedule()\n        schedule.add(self.fake)\n        self.assertTrue(self.fake in schedule)\n```", "```py\n    overlap_exclude = Mock()\n    overlap_exclude.overlaps = Mock(return_value = True)\n    overlap_exclude.excludes = Mock(return_value = True)\n\n    overlap_include = Mock()\n    overlap_include.overlaps = Mock(return_value = True)\n    overlap_include.excludes = Mock(return_value = False)\n\n    distinct_exclude = Mock()\n    distinct_exclude.overlaps = Mock(return_value = False)\n    distinct_exclude.excludes = Mock(return_value = True)\n\n    distinct_include = Mock()\n    distinct_include.overlaps = Mock(return_value = False)\n    distinct_include.excludes = Mock(return_value = False)\n```", "```py\n    def test_add_overlap_exclude(self):\n        schedule = Schedule()\n        schedule.add(self.distinct_include)\n        self.assertRaises(ScheduleError,\n                          schedule.add,\n                          self.overlap_exclude)\n\n    def test_add_overlap_include(self):\n        schedule = Schedule()\n        schedule.add(self.distinct_include)\n        schedule.add(self.overlap_include)\n\n    def test_add_distinct_exclude(self):\n        schedule = Schedule()\n        schedule.add(self.distinct_include)\n        schedule.add(self.distinct_exclude)\n\n    def test_add_distinct_include(self):\n        schedule = Schedule()\n        schedule.add(self.distinct_include)\n        schedule.add(self.distinct_include)\n```", "```py\n    def test_add_over_overlap_exclude(self):\n        schedule = Schedule()\n        schedule.add(self.overlap_exclude)\n        self.assertRaises(ScheduleError,\n                          schedule.add,\n                          self.overlap_include)\n```", "```py\n    def test_add_over_distinct_exclude(self):\n        schedule = Schedule()\n        schedule.add(self.distinct_exclude)\n        self.assertRaises(ScheduleError,\n                          schedule.add,\n                          self.overlap_include)\n```", "```py\n    def test_add_over_overlap_include(self):\n        schedule = Schedule()\n        schedule.add(self.overlap_include)\n        schedule.add(self.overlap_include)\n\n    def test_add_over_distinct_include(self):\n        schedule = Schedule()\n        schedule.add(self.distinct_include)\n        schedule.add(self.overlap_include)\n```", "```py\nclass in_tests(TestCase):\n    fake = Mock()\n    fake.overlaps = Mock(return_value = True)\n    fake.excludes = Mock(return_value = True)\n\n    def test_in_before_add(self):\n        schedule = Schedule()\n        self.assertFalse(self.fake in schedule)\n\n    def test_in_after_add(self):\n        schedule = Schedule()\n        schedule.add(self.fake)\n        self.assertTrue(self.fake in schedule)\n```", "```py\nfrom datetime import timedelta\n\nclass TaskError(Exception):\n    pass\n\nclass ScheduleError(Exception):\n    pass\n\nclass Task:\n    def __init__(self, name, begins, ends):\n        if ends < begins:\n            raise TaskError('The begin time must precede the end time')\n        if ends - begins < timedelta(minutes = 5):\n            raise TaskError('The minimum duration is 5 minutes')\n\n        self.name = name\n        self.begins = begins\n        self.ends = ends\n\n    def excludes(self, other):\n        return NotImplemented\n\n    def overlaps(self, other):\n        if other.begins < self.begins:\n            return other.ends > self.begins\n        elif other.ends > self.ends:\n            return other.begins < self.ends\n        else:\n            return True\n\n    def __repr__(self):\n        return '<{} {} {}>'.format(self.name,\n                                   self.begins.isoformat(),\n                                   self.ends.isoformat())\n\nclass Activity(Task):\n    def excludes(self, other):\n        return isinstance(other, Activity)\n\nclass Status(Task):\n    def excludes(self, other):\n        return False\n\nclass Schedule:\n    def __init__(self):\n        self.tasks = []\n\n    def add(self, task):\n        for contained in self.tasks:\n            if task.overlaps(contained):\n                if task.exclude(contained) or contained.exclude(task):\n                    raise ScheduleError(task, containeed)\n\n        self.tasks.append(task)\n\n    def remove(self, task):\n        try:\n            self.tasks.remove(task)\n        except ValueError:\n            pass\n\n    def __contains__(self, task):\n        return task in self.tasks\n```", "```py\nAttributeError: 'Activity' object has no attribute 'exclude'\n```", "```py\nif task.exclude(contained) or contained.exclude(task):\n```", "```py\nif task.excludes(contained) or contained.excludes(task):\n```", "```py\nNameError: name 'containeed' is not defined\n```", "```py\nSyntaxError: unexpected EOF while parsing\n```", "```py\nFile \"docs/outline.txt\", line 36, in outline.txt\nFailed example:\n duplicate_activity in schedule\nExpected:\n True\nGot:\n False\n```", "```py\n    def __eq__(self, other):\n        return (self.name == other.name and\n                self.begins == other.begins and\n                self.ends == other.ends)\n\n    def __ne__(self, other):\n        return (self.name != other.name or\n                self.begins != other.begins or\n                self.ends != other.ends)\n```", "```py\nFile \"docs/outline.txt\", line 61, in outline.txt\nFailed example:\n schedule.add(activity2)\nExpected:\n Traceback (most recent call last):\n ScheduleError: \"test activity 2\" overlaps with \"test activity 1\"\nGot:\n Traceback (most recent call last):\n File \"/usr/lib64/python3.4/doctest.py\", line 1324, in __run\n compileflags, 1), test.globs)\n File \"<doctest outline.txt[20]>\", line 1, in <module>\n schedule.add(activity2)\n File \"planner/data.py\", line 62, in add\n raise ScheduleError(task, contained)\n planner.data.ScheduleError: (<test activity 2 2014-06-01T10:15:00 2014-06-01T13:30:00>, <test activity 1 2014-06-01T09:05:00 2014-06-01T12:30:00>)\n```", "```py\nraise ScheduleError('\"{}\" overlaps with \"{}\"'.format(task.name, contained.name))\n```", "```py\n    $ python3 -m nose\n    ```", "```py\nfrom unittest import TestCase\nfrom planner.persistence import File\n\nclass test_file(TestCase):\n    def test_basic(self):\n        storage = File(':memory:')\n        storage.store_object('tag1', ('some object',))\n        self.assertEqual(tuple(storage.load_objects('tag1')),\n                         (('some object',),))\n\n    def test_multiple_tags(self):\n        storage = File(':memory:')\n\n        storage.store_object('tag1', 'A')\n        storage.store_object('tag2', 'B')\n        storage.store_object('tag1', 'C')\n        storage.store_object('tag1', 'D')\n        storage.store_object('tag3', 'E')\n        storage.store_object('tag3', 'F')\n\n        self.assertEqual(set(storage.load_objects('tag1')),\n                         set(['A', 'C', 'D']))\n\n        self.assertEqual(set(storage.load_objects('tag2')),\n                         set(['B']))\n\n        self.assertEqual(set(storage.load_objects('tag3')),\n                         set(['E', 'F']))\n```", "```py\n    def test_basic(self):\n        storage = File(':memory:')\n        storage.store_object('tag1', ('some object',))\n        self.assertEqual(tuple(storage.load_objects('tag1')),\n                         (('some object',),))\n```", "```py\n    def test_multiple_tags(self):\n        storage = File(':memory:')\n\n        storage.store_object('tag1', 'A')\n        storage.store_object('tag2', 'B')\n        storage.store_object('tag1', 'C')\n        storage.store_object('tag1', 'D')\n        storage.store_object('tag3', 'E')\n        storage.store_object('tag3', 'F')\n\n        self.assertEqual(set(storage.load_objects('tag1')),\n                         set(['A', 'C', 'D']))\n\n        self.assertEqual(set(storage.load_objects('tag2')),\n                         set(['B']))\n\n        self.assertEqual(set(storage.load_objects('tag3')),\n                         set(['E', 'F']))\n```", "```py\nimport sqlite3\nfrom pickle import loads, dumps\n\nclass File:\n    def __init__(self, path):\n        self.connection = sqlite3.connect(path)\n\n        try:\n            self.connection.execute(\"\"\"\n                create table objects (tag, pickle)\n            \"\"\")\n        except sqlite3.OperationalError:\n            pass\n\n    def store_object(self, tag, object):\n        self.connection.execute('insert into objects values (?, ?)',\n                                (tag, dumps(object)))\n\n    def load_objects(self, tag):\n        cursor = self.connection.execute(\"\"\"\n                     select pickle from objects where tag like ?\n                 \"\"\", (tag,))\n        return [loads(row['pickle']) for row in cursor]\n```", "```py\nERROR: test_multiple_tags (test_persistence.test_file)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n File \"tests/test_persistence.py\", line 21, in test_multiple_tags\n self.assertEqual(set(storage.load_objects('tag1')),\n File \"planner/persistence.py\", line 23, in load_objects\n return [loads(row['pickle']) for row in cursor]\n File \"planner/persistence.py\", line 23, in <listcomp>\n return [loads(row['pickle']) for row in cursor]\nTypeError: tuple indices must be integers, not str\n```", "```py\nself.connection.row_factory = sqlite3.Row\n```", "```py\nclass store_load_tests(TestCase):\n    def setUp(self):\n        fake_tasks = []\n        for i in range(50):\n            fake_task = Mock()\n            fake_task.overlaps = Mock(return_value = False)\n            fake_task.name = 'fake {}'.format(i)\n\n        self.tasks = fake_tasks\n\n    def tearDown(self):\n        del self.tasks\n\n    def test_store(self):\n        fake_file = Mock()\n\n        schedule = Schedule('test_schedule')\n\n        for task in self.tasks:\n            schedule.add(task)\n\n        schedule.store(fake_file)\n\n        for task in self.tasks:\n            fake_file.store_object.assert_any_call('test_schedule', task)\n\n    def test_load(self):\n        fake_file = Mock()\n\n        fake_file.load_objects = Mock(return_value = self.tasks)\n\n        schedule = Schedule.load(fake_file, 'test_schedule')\n\n        fake_file.load_objects.assert_called_once_with('test_schedule')\n\n        self.assertEqual(set(schedule.tasks),\n                         set(self.tasks))\n```", "```py\n    def store(self, storage):\n        for task in self.tasks:\n            storage.store_object(self.name, task)\n\n    @staticmethod\n    def load(storage, name = 'schedule'):\n        value = Schedule(name)\n\n        for task in storage.load_objects(name):\n            value.add(task)\n\n        return value\n```", "```py\n    def __init__(self, name = 'schedule'):\n        self.tasks = []\n        self.name = name\n```", "```py\nFile \"docs/outline.txt\", line 101, in outline.txt\nFailed example:\n schedule == newsched\nExpected:\n True\nGot:\n False\n```", "```py\n    def __eq__(self, other):\n        return self.tasks == other.tasks\n```"]