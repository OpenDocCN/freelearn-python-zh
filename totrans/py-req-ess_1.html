<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Interacting with the Web Using Requests"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Interacting with the Web Using Requests</h1></div></div></div><p>Reading data and obtaining information from web services tends to be a crucial task in these modern days. Everyone knows how an <a class="indexterm" id="id0"/>
<span class="strong"><strong>Application Programming Interface</strong></span> (<span class="strong"><strong>API</strong></span>) allowed Facebook to spread the use of the Like button all over the Web and dominated the field of social communication. It has got its own flair to influence the business development, product development and supply chain management. At this stage, learning an efficient way to deal with the API's and opening the web URLs is the need of the hour. This will greatly affect many processes of web development.</p><div class="section" title="Introduction to HTTP request"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Introduction to HTTP request</h1></div></div></div><p>Whenever our Web browser tries communicating with a Web server, it is done by using the <span class="strong"><strong>Hypertext Transfer Protocol</strong></span> (<span class="strong"><strong>HTTP</strong></span>) which functions as a request-response protocol. In this process of <a class="indexterm" id="id1"/>communication, we send a request to the web server and expect a response in return. Take an example of downloading a PDF from a website. We send a request saying "Get me this specific file", and we get a response from the Web server with "Here is the file followed by the file itself". The HTTP request we are sending possibly has much interesting information. Let us dig inside it.</p><p>Here is the raw information of the HTTP request, that I have sent through my device. We can grasp the important parts of the request after looking at the following example:</p><div class="informalexample"><pre class="programlisting">* Connected to google.com (74.125.236.35) port 80 (#0)
&gt; GET / HTTP/1.1
&gt; User-Agent: curl/7.35.0
&gt; Host: google.com
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 302 Found
&lt; Cache-Control: private
&lt; Content-Type: text/html; charset=UTF-8
&lt; Location: http://www.google.co.in/?gfe_rd=cr&amp;ei=_qMUVKLCIa3M8gewuoCYBQ
&lt; Content-Length: 261
&lt; Date: Sat, 13 Sep 2014 20:07:26 GMT
* Server GFE/2.0 is not blacklisted
&lt; Server: GFE/2.0
&lt; Alternate-Protocol: 80:quic,p=0.002</pre></div><p>Now, we will send a<a class="indexterm" id="id2"/> request to the server. Let us make use of these parts of the HTTP request:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Method</strong></span>: The <code class="literal">GET / http /1.1</code> in the preceding example, is the HTTP method which is case sensitive. Here are some of the HTTP request methods:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GET</code>: This fetches information<a class="indexterm" id="id3"/> from the given server using the given URI.</li><li class="listitem" style="list-style-type: disc"><code class="literal">HEAD</code>: The functionality of this is similar to GET but the difference is, it delivers only the status line and header section.</li><li class="listitem" style="list-style-type: disc"><code class="literal">POST</code>: This can submit data to the server that we wish to process.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PUT</code>: This creates or overwrites all the current representations of the target resource, when we intend to create a new URL.</li><li class="listitem" style="list-style-type: disc"><code class="literal">DELETE</code>: This removes all the resources that are described by the given <code class="literal">Request-URI</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">OPTIONS</code>: This specifies the communication options for a request/response cycle. It lets the client to mention different options associated with the resource.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Request URI</strong></span>: Uniform Resource Identifier (URI) has the ability to recognize the name of the<a class="indexterm" id="id4"/> resource. In the previous example, the hostname is the <code class="literal">Request-URI</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Request Header fields</strong></span>: If we<a class="indexterm" id="id5"/> want to add more information about the request, we can use the requests header fields. They are colon-separated key value pairs. Some of the <code class="literal">request-headers</code> values are:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Accept-Charset</code>: This is used to indicate the character sets that are acceptable for the response.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Authorization</code>: This contains the value of the credentials which has the authentication information of the user agent.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Host</code>: This identifies the Internet host and port number of the resource that has been requested, using the original URI given by the user.</li><li class="listitem" style="list-style-type: disc"><code class="literal">User-agent</code>: It accommodates<a class="indexterm" id="id6"/> information about the user agent that originates the request. This can be used for statistical purposes such as tracing the protocol violations.</li></ul></div></li></ul></div></div></div>
<div class="section" title="Python modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Python modules</h1></div></div></div><p>There are some extensively used Python modules which help in opening URLs. Let us have a look at them:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">httplib2</code>: This is a comprehensive<a class="indexterm" id="id7"/> HTTP client library. It supports many features that are left out of other HTTP libraries. It supports features like caching, keep-alive, compression, redirects and many kinds of authentication.</li><li class="listitem" style="list-style-type: disc"><code class="literal">urllib2</code>: This is an <a class="indexterm" id="id8"/>extensively used module for fetching HTTP URLs in a complex world. It defines functions and classes that help with URL actions such as basic and digest authentication, redirections, cookies, and so on.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Requests</code>: This is an Apache2 licensed<a class="indexterm" id="id9"/> HTTP library which is written in Python, gifted with many capabilities to result in productivity.</li></ul></div></div>
<div class="section" title="Requests versus urllib2"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Requests versus urllib2</h1></div></div></div><p>Let's compare <code class="literal">urllib2</code> and <code class="literal">Requests</code>; <code class="literal">urllib2.urlopen()</code>, which can be used to open a URL (which can be a string or a request object), but there are many other things that can be a burden while interacting <a class="indexterm" id="id10"/>with the web. At this point, a simple HTTP library which has the capabilities to make interaction with the web smooth is the need of the hour, and Requests is one<a class="indexterm" id="id11"/> of its kind.</p><p>The following is an example for fetching the data from a web service with <code class="literal">urllib2</code> and <code class="literal">Requests</code> gives us a clear picture of how easy it is to work with <code class="literal">Requests</code>:</p><p>The following code gives an example of <code class="literal">urllib2</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>#!/usr/bin/env python</strong></span>
<span class="strong"><strong># -*- coding: utf-8 -*-</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>import urllib2</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>gh_url = 'https://api.github.com'</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>req = urllib2.Request(gh_url)</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>password_manager = urllib2.HTTPPasswordMgrWithDefaultRealm()</strong></span>
<span class="strong"><strong>password_manager.add_password(None, gh_url, 'user', 'pass')</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>auth_manager = urllib2.HTTPBasicAuthHandler(password_manager)</strong></span>
<span class="strong"><strong>opener = urllib2.build_opener(auth_manager)</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>urllib2.install_opener(opener)</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>handler = urllib2.urlopen(req)</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>print handler.getcode()</strong></span>
<span class="strong"><strong>print handler.headers.getheader('content-type')</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong># ------</strong></span>
<span class="strong"><strong># 200</strong></span>
<span class="strong"><strong># 'application/json'</strong></span>
</pre></div><p>The same example implemented with <code class="literal">Requests</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>#!/usr/bin/env python</strong></span>
<span class="strong"><strong># -*- coding: utf-8 -*-</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>import requests</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>r = requests.get('https://api.github.com', auth=('user', 'pass'))</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>print r.status_code</strong></span>
<span class="strong"><strong>print r.headers['content-type']</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong># ------</strong></span>
<span class="strong"><strong># 200</strong></span>
<span class="strong"><strong># 'application/json'</strong></span>
</pre></div><p>These examples<a class="indexterm" id="id12"/> can be found at <a class="ulink" href="https://gist.github.com/kennethreitz/973705">https://gist.github.com/kennethreitz/973705</a>.</p><p>At this initial stage, the example may look much complicated. Don't go deep into the details of the example. Just <a class="indexterm" id="id13"/>see the beauty of <code class="literal">requests</code> that allowed us to login to GitHub with very few lines of code. The code with <code class="literal">requests</code> seems much simpler and efficient than the <code class="literal">urllib2</code> example. This would help us increase the productivity in all sorts of things.</p></div>
<div class="section" title="Essence of Requests"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Essence of Requests</h1></div></div></div><p>As with <code class="literal">HTTP/1.0</code>, <code class="literal">HTTP/1.1</code> has a lot of perks and added features like reusing a connection multiple times which decreases the considerable overhead, keep-alive mechanism, and so on. And fortunately, <code class="literal">requests</code> is built from it, giving us the benefits of interacting with the web smoothly and seamlessly. There is no need to manually add query strings to <a class="indexterm" id="id14"/>our URLs, or to encode our POST data. Keep-alive and HTTP connection pooling are 100 percent automatic, powered by <code class="literal">urllib3</code>, which is embedded within <code class="literal">requests</code>. With <code class="literal">requests</code> we are gifted with a means to forget about encoding parameters again and again, irrespective of whether it is GET/POST.</p><p>There is no requirement for manually adding query strings to the URLs, and also to the features such as connection pooling keep-alive, sessions with cookie persistence, Basic/Digest Authentication, Browser-style SSL Verification, Connection Timeouts, Multipart File Uploads, and so on.</p></div>
<div class="section" title="Making a simple request"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Making a simple request</h1></div></div></div><p>Now let us create our first<a class="indexterm" id="id15"/> request for getting a web page, which is very simple. The process includes importing the <code class="literal">requests</code> module, and then getting the web page with the <code class="literal">get</code> method. Let us look into an example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import requests</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r =  requests.get('http://google.com')</strong></span>
</pre></div><p>Voila! We are done.</p><p>In the preceding example, we get the <code class="literal">google</code> webpage, using <code class="literal">requests.get</code> and saving it in the variable <code class="literal">r,</code> which turns out to be the <code class="literal">response</code> object. The <code class="literal">response</code> object <code class="literal">r</code> contains a lot of information about the response, such as header information, content, type of encoding, status code, URL information and many more sophisticated details.</p><p>In the same way, we can use all the HTTP request methods like GET, POST, PUT, DELETE, HEAD with <code class="literal">requests</code>.</p><p>Now let us learn how to pass the parameters in URLs. We can add the parameters to a request using using the <code class="literal">params</code> keyword.</p><p>The following is the syntax used for passing parameters:</p><div class="informalexample"><pre class="programlisting">parameters = {'key1': 'value1', 'key2': 'value2'}
r = requests.get('url', params=parameters)</pre></div><p>For getting a clear picture on this, let us get a GitHub user details by logging into GitHub, using <code class="literal">requests</code> as shown in the following code:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; r = requests.get('https://api.github.com/user', auth=('myemailid.mail.com', 'password'))</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.status_code</strong></span>
<span class="strong"><strong>200</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.url</strong></span>
<span class="strong"><strong>u'https://api.github.com/user'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.request</strong></span>
<span class="strong"><strong>&lt;PreparedRequest [GET]&gt;</strong></span>
</pre></div><p>We have used the <code class="literal">auth</code> tuple which enables Basic/Digest/Custom Authentication to login to GitHub and get the user details. The <code class="literal">r.status_code</code> result indicates that we have successfully got the <a class="indexterm" id="id16"/>user details, and also that we have accessed the URL, and the type of request.</p></div>
<div class="section" title="Response content"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Response content</h1></div></div></div><p>Response content is the information about the server's response that is delivered back to our console when we send a request.</p><p>While interacting with<a class="indexterm" id="id17"/> the web, it's necessary to decode the response of the server. While working on an application, there are many cases in which we may have to deal with the raw, or JSON, or even binary response. For this, <code class="literal">requests</code> has the capability to automatically decode the content from the server. Requests can smoothly decode many of the Unicode charsets. To add to that, Requests makes informed guesses about the encoding of the response. This basically happens taking the headers into consideration.</p><p>If we access the value of <code class="literal">r.content</code>, it results us the response content in a raw string format. And if we access <code class="literal">r.text</code>, the Requests library encodes the response (<code class="literal">r.content</code> value) using <code class="literal">r.encoding</code> and returns a new encoding string. In case, if the value of <code class="literal">r.encoding</code> is <code class="literal">None</code>, Requests assumes the encoding type using <code class="literal">r.apparent_encoding</code>, which is provided by the <code class="literal">chardet</code> library.</p><p>We can access the server's response content in the following way:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import requests</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r = requests.get('https://google.com')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.content</strong></span>
<span class="strong"><strong>'&lt;!doctype html&gt;&lt;html itemscope="" itemtype="http://schema.org/WebPage" …..'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; type(r.content)</strong></span>
<span class="strong"><strong>&lt;type 'str'&gt;</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.text</strong></span>
<span class="strong"><strong>u'&lt;!doctype html&gt;&lt;html itemscope=""\ itemtype="http://schema.org/WebPage" lang="en-IN"&gt;&lt;head&gt;&lt;meta content="........</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; type(r.text)</strong></span>
<span class="strong"><strong>&lt;type 'unicode'&gt;</strong></span>
</pre></div><p>In the preceding lines, we try to get the <code class="literal">google</code> homepage, using <code class="literal">requests.get()</code> and assigning it to a variable <code class="literal">r</code>. The <code class="literal">r</code> variable turns out to be a request object here, and we can access the raw content using <code class="literal">r.content</code> and the encoded response content with <code class="literal">r.text</code>.</p><p>If we wish to find what encoding Requests is using, or if we desire to change the encoding, we can<a class="indexterm" id="id18"/> use the property <code class="literal">r.encoding</code> as shown in the following example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; r.encoding</strong></span>
<span class="strong"><strong>'ISO-8859-1'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.encoding = 'utf-8'</strong></span>
</pre></div><p>In the first line of the code, we are trying to access the type of encoding that is being followed by Requests. It resulted in <code class="literal">'ISO-8859-1'</code>. In the next line, I wished to change the encoding to <code class="literal">'utf-8'</code>. So I assigned the type of encoding to <code class="literal">r.encoding</code>. If we change the encoding like we did in the second line, Requests tends to use the latest value of <code class="literal">r.encoding</code> that has been assigned. So from that point in time, it uses the same encoding whenever we call <code class="literal">r.text</code>.</p><p>For an instance, if the value of <code class="literal">r.encoding</code> is <code class="literal">None</code>, Requests tend to use the value of <code class="literal">r.apparent_encoding</code>. The following example explains the case:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; r.encoding = None</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.apparent_encoding</strong></span>
<span class="strong"><strong>'ascii'</strong></span>
</pre></div><p>Generally, the value of apparent encoding is specified by the <code class="literal">chardet</code> library. With more enthusiasm, if we attempt to set a new encoding type to <code class="literal">r.apparent_encoding</code>, Requests raises an <code class="literal">AttributeError</code> as its value can't be altered.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; r.apparent_encoding = 'ISO-8859-1'</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong></span>
<span class="strong"><strong>AttributeError: can't set attribute</strong></span>
</pre></div><p>Requests are efficient enough to use custom encodings. Take a case in which we have created an encoding of our own, and got it registered with the module of <code class="literal">codecs</code>. We can use our custom codec with ease; this is because the values of <code class="literal">r.encoding</code> and Requests will take care of the decoding.</p></div>
<div class="section" title="Different types of request contents"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Different types of request contents</h1></div></div></div><p>Requests has the facility to deal <a class="indexterm" id="id19"/>with different types of Request contents<a class="indexterm" id="id20"/> like binary response content, JSON response content, and raw response content. To give a clear picture on different types of response content, we listed the details. The examples used here are developed using Python 2.7.x.</p><div class="section" title="Custom headers"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Custom headers</h2></div></div></div><p>We can send custom headers with a request. For that, we just need to create a dictionary with our headers and pass the headers parameter in the <code class="literal">get</code>, or <code class="literal">post</code> method. In the dictionary, key is the name of the<a class="indexterm" id="id21"/> header and the value is, well, the value of the pair. Let us pass an HTTP header to a request:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import json</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; url = 'https://api.github.com/some/endpoint'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;  payload = {'some': 'data'}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; headers = {'Content-Type': 'application/json'}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r = requests.post(url, data=json.dumps(payload), headers=headers)</strong></span>
</pre></div><p>This example has been<a class="indexterm" id="id22"/> taken from the Request documents found at <a class="ulink" href="http://docs.python-requests.org/en/latest/user/quickstart/#custom-headers">http://docs.python-requests.org/en/latest/user/quickstart/#custom-headers</a>.</p><p>In this example, we have sent a header <code class="literal">content-type</code> with a value <code class="literal">application/json</code>, as a parameter to the request.</p><p>In the same way, we can send a request with a custom header. Say we have a necessity to send a request with an authorization header with a value as some token. We can create a dictionary with a key <code class="literal">'Authorization'</code> and value as a token which would look like the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; url = 'some url'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;  header = {'Authorization' : 'some token'}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.request.post(url, headers=headers)</strong></span>
</pre></div></div><div class="section" title="Sending form-encoded data"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Sending form-encoded data</h2></div></div></div><p>We can send form-encoded data like an HTML form using Requests. A simple dictionary to the data argument<a class="indexterm" id="id23"/> gets this done. The dictionary of data will turn as form-encoded automatically, when a request is made.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; payload = {'key1': 'value1', 'key2': 'value2'}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r = request.post("some_url/post", data=payload)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print(r.text)</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>   …</strong></span>
<span class="strong"><strong>   "form": {</strong></span>
<span class="strong"><strong>       "key2": "value2",</strong></span>
<span class="strong"><strong>     "key1": "value1"</strong></span>
<span class="strong"><strong>   },</strong></span>
<span class="strong"><strong>   …</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>In the preceding example, we tried sending data that is form-encoded. While dealing with data that is<a class="indexterm" id="id24"/> not form-encoded, we should send a string in the place of a dictionary.</p></div><div class="section" title="Posting multipart encoded files"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Posting multipart encoded files</h2></div></div></div><p>We tend to<a class="indexterm" id="id25"/> upload multipart data like images or files through POST. We can achieve this in <code class="literal">requests</code> using <code class="literal">files</code> which is a dictionary of <code class="literal">'name'</code> and value of <code class="literal">file-like-objects</code>. And also we can specify it as <code class="literal">'name'</code>, and value could be <code class="literal">'filename'</code>, <code class="literal">fileobj</code> just like in the following way:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>{'name' : file-like-objects} or</strong></span>
<span class="strong"><strong>{'name': ('filename',  fileobj)}</strong></span>
</pre></div><p>The example is as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; url = 'some api endpoint'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; files = {'file': open('plan.csv', 'rb')}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r = requests.post(url, files=files)</strong></span>

<span class="strong"><strong>We can access the response using 'r.text'.</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;  r.text</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>   …</strong></span>
<span class="strong"><strong>   "files": {</strong></span>
<span class="strong"><strong>       "file": "&lt; some data … &gt;"</strong></span>
<span class="strong"><strong>       },</strong></span>
<span class="strong"><strong>   ….</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>In the former example, we didn't specify the content-type or headers. To add to that, we have the capability to set the name for the file we are uploading:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; url = 'some url'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; files = {'file': ('plan.csv', open('plan.csv', 'rb'), 'application/csv', {'Expires': '0'})}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r = requests.post(url, files)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.text</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>   …</strong></span>
<span class="strong"><strong>   "files"</strong></span>
<span class="strong"><strong>       "file": "&lt; data...&gt;"</strong></span>
<span class="strong"><strong>       },</strong></span>
<span class="strong"><strong>   …</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>We can also send strings to be received as files in the following way:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; url = 'some url'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; files = {'file' : ('plan.csv', 'some, strings, to, send')}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.text</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>   …</strong></span>
<span class="strong"><strong>   "files": {</strong></span>
<span class="strong"><strong>       "file": "some, strings, to, send"</strong></span>
<span class="strong"><strong>    },</strong></span>
<span class="strong"><strong>   …</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div></div></div>
<div class="section" title="Looking up built-in response status codes"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Looking up built-in response status codes</h1></div></div></div><p>Status codes are helpful in letting us know the result, once a request is sent. To know about this, we can use <code class="literal">status_code</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; r = requests.get('http://google.com')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.status_code</strong></span>
<span class="strong"><strong>200</strong></span>
</pre></div><p>To make it much <a class="indexterm" id="id26"/>easier to deal with <code class="literal">status_codes</code>, Requests has got a built-in status code lookup object which serves as an easy reference. We must compare the <code class="literal">requests.codes.ok</code> with <code class="literal">r.status_code</code> to achieve this. If the result turns out to be <code class="literal">True</code>, then it's <code class="literal">200</code> status code, and if it's <code class="literal">False</code>, it's not. We can also compare the <code class="literal">r.status.code</code> with <code class="literal">requests.codes.ok</code>, <code class="literal">requests.code.all_good</code> to get the lookup work.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; r = requests.get('http://google.com')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.status_code == requests.codes.ok</strong></span>
<span class="strong"><strong>True</strong></span>
</pre></div><p>Now, let's try checking with a URL that is non-existent.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; r = requests.get('http://google.com/404')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.status_code == requests.codes.ok</strong></span>
<span class="strong"><strong>False</strong></span>
</pre></div><p>We have got the facility to deal with the bad <code class="literal">requests</code> like 4XX and 5XX type of errors, by notifying with the error codes. This can be accomplished by using <code class="literal">Response.raise_for_status()</code>.</p><p>Let us try this by sending a bad request first:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; bad_request = requests.get('http://google.com/404')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; bad_request.status_code</strong></span>
<span class="strong"><strong>404</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;bad_request.raise_for_status()</strong></span>
<span class="strong"><strong>---------------------------------------------------------------------------</strong></span>
<span class="strong"><strong>HTTPError                              Traceback (most recent call last)</strong></span>
<span class="strong"><strong>----&gt; bad_request..raise_for_status()</strong></span>

<span class="strong"><strong>File "requests/models.py",  in raise_for_status(self)</strong></span>
<span class="strong"><strong>   771</strong></span>
<span class="strong"><strong>   772         if http_error_msg:</strong></span>
<span class="strong"><strong>--&gt; 773             raise HTTPError(http_error_msg, response=self)</strong></span>
<span class="strong"><strong>   774</strong></span>
<span class="strong"><strong>   775     def close(self):</strong></span>

<span class="strong"><strong>HTTPError: 404 Client Error: Not Found</strong></span>
</pre></div><p>Now if we try a working URL, we get nothing in response, which is a sign of success:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; bad_request = requests.get('http://google.com')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; bad_request.status_code</strong></span>
<span class="strong"><strong>200</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; bad_request.raise_for_status()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;</strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div>
<div class="section" title="Viewing response headers"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Viewing response headers</h1></div></div></div><p>The server response header<a class="indexterm" id="id27"/> helps us to know about the software used by the origin server to handle the request. We can access the server response headers using <code class="literal">r.headers</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; r = requests.get('http://google.com')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.headers</strong></span>
<span class="strong"><strong>CaseInsensitiveDict({'alternate-protocol': '80:quic', 'x-xss-protection': '1; mode=block', 'transfer-encoding': 'chunked', 'set-cookie': 'PREF=ID=3c5de2786273fce1:FF=0:TM=1410378309:LM=1410378309:S=DirRRD4dRAxp2Q_3; …..</strong></span>
</pre></div><p>
<span class="strong"><strong>Requests for Comments</strong></span> (<span class="strong"><strong>RFC</strong></span>) <a class="indexterm" id="id28"/>7230 says that HTTP header names are not case-sensitive. This gives us a capability to access the headers with both capital and lower-case letters.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; r.headers['Content-Type']</strong></span>
<span class="strong"><strong>'text/html; charset=ISO-8859-1'</strong></span>

<span class="strong"><strong>&gt;&gt;&gt;  r.headers.get('content-type')</strong></span>
<span class="strong"><strong>'text/html; charset=ISO-8859-1'</strong></span>
</pre></div></div>
<div class="section" title="Accessing cookies with Requests"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Accessing cookies with Requests</h1></div></div></div><p>We can access <a class="indexterm" id="id29"/>cookies from the response, if they <a class="indexterm" id="id30"/>exist:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; url = 'http://somewebsite/some/cookie/setting/url'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r = requests.get(url)</strong></span>

<span class="strong"><strong>&gt;&gt;&gt; r.cookies['some_cookie_name']</strong></span>
<span class="strong"><strong>'some_cookie_value'</strong></span>
</pre></div><p>We can send our own cookies, as shown in the following example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; url = 'http://httpbin.org/cookies'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; cookies = dict(cookies_are='working')</strong></span>

<span class="strong"><strong>&gt;&gt;&gt; r = requests.get(url, cookies=cookies)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.text</strong></span>
<span class="strong"><strong>'{"cookies": {"cookies_are": "working"}}'</strong></span>
</pre></div></div>
<div class="section" title="Tracking redirection of the request using request history"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Tracking redirection of the request using request history</h1></div></div></div><p>Sometimes the URL that we are accessing may have been moved or it might get redirected to some other location. We can track them using Requests. The response object's history property <a class="indexterm" id="id31"/>can be used to track the redirection. Requests can accomplish location redirection with every verb except with HEAD. The <code class="literal">Response.history</code> list contains the objects of the Requests that were generated in order to complete the request.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; r = requests.get('http:google.com')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.url</strong></span>
<span class="strong"><strong>u'http://www.google.co.in/?gfe_rd=cr&amp;ei=rgMSVOjiFKnV8ge37YGgCA'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.status_code</strong></span>
<span class="strong"><strong>200</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.history</strong></span>
<span class="strong"><strong>(&lt;Response [302]&gt;,)</strong></span>
</pre></div><p>In the preceding example, when we tried sending a request to <code class="literal">'www.google.com',</code> we got the <code class="literal">r.history</code> value as <code class="literal">302</code> which means the URL has been redirected to some other location. The <code class="literal">r.url</code> shows us the proof here, with the redirection URL.</p><p>If we don't want Requests to handle redirections, or if we are using POST, GET, PUT, PATCH, OPTIONS, or DELETE, we can set the value of <code class="literal">allow_redirects=False,</code> so that redirection<a class="indexterm" id="id32"/> handling gets disabled.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; r = requests.get('http://google.com', allow_redirects=False)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.url</strong></span>
<span class="strong"><strong>u'http://google.com/'</strong></span>
<span class="strong"><strong>&gt;&gt; r.status_code</strong></span>
<span class="strong"><strong>302</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.history</strong></span>
<span class="strong"><strong>[ ]</strong></span>
</pre></div><p>In the preceding example, we used the parameter <code class="literal">allow_redirects=False,</code> which resulted the <code class="literal">r.url</code> without any redirection in the URL and the <code class="literal">r.history</code> as empty.</p><p>If we are using the head to access the URL, we can facilitate redirection.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; r = requests.head('http://google.com', allow_redirects=True)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.url</strong></span>
<span class="strong"><strong>u'http://www.google.co.in/?gfe_rd=cr&amp;ei=RggSVMbIKajV8gfxzID4Ag'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r.history</strong></span>
<span class="strong"><strong>(&lt;Response [302]&gt;,)</strong></span>
</pre></div><p>In this example, we tried accessing the URL with head and the parameter <code class="literal">allow_redirects</code> enabled which resulted us the URL redirected.</p></div>
<div class="section" title="Using timeout to keep productive usage in check"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec19"/>Using timeout to keep productive usage in check</h1></div></div></div><p>Take a case in which we are trying to access a response which is taking too much time. If we don't want to get the process moving forward and give out an exception if it exceeds a specific amount of time, we can use the parameter <code class="literal">timeout</code>.</p><p>When we use the <code class="literal">timeout</code> parameter, we<a class="indexterm" id="id33"/> are telling Requests not to wait for a response after some specific time period. If we use <code class="literal">timeout</code>, it's not equivalent to defining a time limit on the whole response download. It's a good <a class="indexterm" id="id34"/>practice to raise an exception if no bytes have been acknowledged on the underlying socket for the stated <code class="literal">timeout</code> in seconds.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; requests.get('http://google.com', timeout=0.03)</strong></span>
<span class="strong"><strong>---------------------------------------------------------------------------</strong></span>
<span class="strong"><strong>Timeout                                   Traceback (most recent call last)</strong></span>
<span class="strong"><strong>…….</strong></span>
<span class="strong"><strong>……..</strong></span>
<span class="strong"><strong>Timeout: HTTPConnectionPool(host='google.com', port=80): Read timed\ out. (read timeout=0.03)</strong></span>
</pre></div><p>In this example we have specified the <code class="literal">timeout</code> value as <code class="literal">0.03</code> in which the timeout has been exceeded to bring us the response and so it resulted us the <code class="literal">timeout</code> exception. The timeout may occur in two<a class="indexterm" id="id35"/> different cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The request <a class="indexterm" id="id36"/>getting timed out while attempting to connect to the server that is in a remote place.</li><li class="listitem" style="list-style-type: disc">The request getting timed out if the server did not send the whole response in the allocated time period.</li></ul></div></div>
<div class="section" title="Errors and exceptions"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec20"/>Errors and exceptions</h1></div></div></div><p>Different types of errors and exceptions will be raised when something goes wrong in the process of sending a request and getting back a response. Some of them are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">HTTPError</code>: When there<a class="indexterm" id="id37"/> are invalid HTTP responses, Requests will raise an <code class="literal">HTTPError</code> exception</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConnectionError</code>: If there<a class="indexterm" id="id38"/> is a network problem, such as refused connection and DNS failure, Requests will raise a <code class="literal">ConnectionError</code> exception</li><li class="listitem" style="list-style-type: disc"><code class="literal">Timeout</code>: If the request gets<a class="indexterm" id="id39"/> timed out, this exception will be raised</li><li class="listitem" style="list-style-type: disc"><code class="literal">TooManyRedirects</code>: If the request<a class="indexterm" id="id40"/> surpasses the configured number of maximum redirections, this type of exception is raised</li></ul></div><p>Other types of exception that come in to the picture are <code class="literal">Missing schema Exception</code>, <code class="literal">InvalidURL</code>, <code class="literal">ChunkedEncodingError</code>, and <code class="literal">ContentDecodingError</code> and so on.</p><p>This example has been taken from <a class="indexterm" id="id41"/>Request documents available at <a class="ulink" href="http://docs.python-requests.org/en/latest/user/quickstart/#errors-and-exceptions">http://docs.python-requests.org/en/latest/user/quickstart/#errors-and-exceptions</a>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec21"/>Summary</h1></div></div></div><p>In this chapter, we covered a few basic topics. We learned why Requests is better than <code class="literal">urllib2</code>, how to make a simple request, different types of response contents, adding custom headers to our Requests, dealing with form encoded data, using the status code lookups, locating request redirection location and about timeouts.</p><p>In the next chapter, we will learn the advanced concepts in Requests, in depth, which will help us to use the Requests library flexibly, according to the requirements.</p></div></body></html>