<html><head></head><body><div><div><div><h1 class="chapterNumber"><a id="_idTextAnchor040"/>2</h1>
    <h1 id="_idParaDest-38" class="chapterTitle"><a id="_idTextAnchor041"/>SOLID Foundations: Building Robust Python Applications</h1>
    <p class="normal">In the previous chapter, we explored Clean Architecture, a powerful approach to building maintainable, flexible, and scalable Python applications. We learned how it separates concerns into distinct layers, from core business logic to external interfaces, promoting independence and testability. Now, we’ll dive deeper into a set of principles that form the foundation of Clean Architecture. These are known<a id="_idIndexMarker057"/> as the <strong class="keyWord">SOLID</strong> principles.</p>
    <p class="normal">The acronym SOLID (<a href="https://en.wikipedia.org/wiki/SOLID">https://en.wikipedia.org/wiki/SOLID</a>) represents five key principles of object-oriented programming and design. These principles, when applied correctly, help developers create software structures that are more understandable, flexible, and maintainable. In this chapter, we’ll explore each of these principles in depth, focusing on their application in Python and how they support the goals of Clean Architecture we discussed earlier.</p>
    <p class="normal">By the end of this chapter, you’ll have a clear understanding of the following aspects:</p>
    <ul>
      <li class="bulletList">The <strong class="keyWord">Single Responsibility Principle</strong> (<strong class="keyWord">SRP</strong>) and its<a id="_idIndexMarker058"/> role in creating focused, maintainable code</li>
      <li class="bulletList">The <strong class="keyWord">Open–Closed Principle</strong> (<strong class="keyWord">OCP</strong>) and<a id="_idIndexMarker059"/> how it enables building extensible systems</li>
      <li class="bulletList">The <strong class="keyWord">Interface Segregation Principle</strong> (<strong class="keyWord">ISP</strong>) and its application in Python’s duck-typed</li>
      <li class="bulletList">environment</li>
      <li class="bulletList">The <strong class="keyWord">Liskov Substitution Principle</strong> (<strong class="keyWord">LSP</strong>) and its importance in designing robust abstractions</li>
      <li class="bulletList">The <strong class="keyWord">Dependency Inversion Principle</strong> (<strong class="keyWord">DIP</strong>) and its <a id="_idIndexMarker060"/>crucial role in supporting the Dependency Rule of Clean Architecture</li>
    </ul>
    <p class="normal">We’ll examine each principle through the lens of Python development, providing practical examples and best practices. You’ll learn how to apply these principles so that you can write cleaner, more maintainable Python code, setting a strong foundation for implementing Clean Architecture in your projects.</p>
    <h1 id="_idParaDest-39" class="heading-1"><a id="_idTextAnchor042"/>Technical requirements</h1>
    <p class="normal">The code examples presented in this chapter and throughout the rest of the book are tested with Python 3.13. For brevity, code examples in the chapter may be partially implemented. Complete versions of all examples can be found in the book’s accompanying GitHub repository at <a href="https://github.com/PacktPublishing/Clean-Architecture-with-Python">https://github.com/PacktPublishing/Clean-Architecture-with-Python</a>.</p>
    <div><p class="normal"><strong class="keyWord">A note about the order in which we’ll cover the SOLID principles</strong></p>
      <p class="normal">While the SOLID principles are traditionally presented in the order of their acronyms, this book adopts a more strategic sequence. We’ll cover SRP, OCP, then ISP, followed by LSP, and finally DIP. The start of each section will detail the relationship between its topic and the ones before.  This order creates a natural progression from writing clean, modular code to designing flexible, maintainable systems, directly supporting the goals of Clean Architecture.</p>
    </div>
    <h1 id="_idParaDest-40" class="heading-1"><a id="_idTextAnchor043"/>Crafting focused, maintainable code: the power of single responsibility</h1>
    <p class="normal">In the hierarchy of software <a id="_idIndexMarker061"/>design, we have high-level architecture at the top, followed by components, modules, classes, and, finally, functions. The SOLID principles primarily operate at the module level, providing guidelines for creating well-structured, maintainable code. These module-level practices form the foundation for good architecture in general, including Clean Architecture. By applying SOLID principles, we can create loosely coupled, highly cohesive components that are easier to test, modify, and extend. These qualities are fundamental attributes of Clean Architecture.</p>
    <h2 id="_idParaDest-41" class="heading-2"><a id="_idTextAnchor044"/>Understanding single responsibility</h2>
    <p class="normal">The Single Responsibility Principle (SRP) states that each software module should have one and only one<a id="_idIndexMarker062"/> reason to change (<a href="https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html">https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html</a>).</p>
    <p class="normal">At first glance, the concept of <em class="italic">single responsibility</em> might seem straightforward. However, in practice, it can be challenging to define and implement. Let’s consider a simple example to illustrate this principle.</p>
    <p class="normal">Let’s consider a <code class="inlineCode">User</code> class intended to serve as an entity in a social media application. Recall that entities in Clean Architecture should represent core business objects with the most general rules:</p>
    <pre class="programlisting code"><code class="hljs-code">class User:
    def __init__(self, user_id: str, username: str, email: str):
        self.user_id = user_id
        self.username = username
        self.email = email
        self.posts = []
    def create_post(self, content: str) -&gt; dict:
        post = {
            "id": len(self.posts) + 1,
            "content": content,
            "likes": 0         }
        self.posts.append(post)
        return post
    def get_timeline(self) -&gt; list:
        # Fetch and return the user's timeline
        # This might involve complex logic to fetch and
        # sort posts from followed users
        pass
    def update_profile(self, new_username: str = None,
                       new_email: str = None):
        if new_username:
            self.username = new_username
        if new_email:
            self.email = new_email
</code></pre>
    <p class="normal">Initially, this <code class="inlineCode">User</code> class might seem reasonable. It encapsulates user data and provides methods for common user actions in a social media application. However, while intended to be an entity, it deviates significantly from the Clean Architecture concept introduced in <a href="Chapter_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>. Remember, entities should represent core business objects that encapsulate the most general and high-level rules, independent of specific application behaviors or external concerns. Our current <code class="inlineCode">User</code> class violates these principles by taking on too many responsibilities:</p>
    <ul>
      <li class="bulletList">User data management (handling <code class="inlineCode">user_id</code>, <code class="inlineCode">username</code>, and <code class="inlineCode">email</code>)</li>
      <li class="bulletList">Post-creation and management</li>
      <li class="bulletList">Timeline generation</li>
      <li class="bulletList">Profile updates</li>
    </ul>
    <p class="normal">This structure combines core user data with application-specific behaviors, violating both SRP and the entity concept. As the product grows, this class could become a bottleneck, leading to<a id="_idIndexMarker063"/> development challenges, merge conflicts, and unintended side effects.</p>
    <p class="normal">When identifying and separating responsibilities, consider these tips:</p>
    <ul>
      <li class="bulletList">Look for groups of methods operating on different subsets of the class’s data</li>
      <li class="bulletList">Consider which aspects would be affected by different types of changes or requirements</li>
      <li class="bulletList">Use the <em class="italic">reason to change</em> heuristic: if you can think of more than one reason for the class to change, consider splitting it</li>
    </ul>
    <p class="normal">Let’s refactor our <code class="inlineCode">User</code> class so that it adheres to SRP and the entity concept:</p>
    <pre class="programlisting code"><code class="hljs-code">class User:
    def __init__(self, user_id: str, username: str, email: str):
        self.user_id = user_id
        self.username = username
        self.email = email
class PostManager:
    def create_post(self, user: User, content: str):
        post = {
            "id": self.generate_post_id(),
            "user_id": user.user_id,
            "content": content,
            "likes": 0
        }
        # Logic to save the post
        return post
    def generate_post_id(self):
        # Logic to generate a unique post ID
        pass
class TimelineService:
    def get_timeline(self, user: User) -&gt; list:
        # Fetch and return the user's timeline
        # This might involve complex logic to fetch and
        # sort posts from followed users
        pass
class ProfileManager:
    def update_profile(self, user: User, new_username: str = None,
                       new_email: str = None):
        if new_username:
            user.username = new_username
        if new_email:
            user.email = new_email
        # Additional logic for profile updates,
        # like triggering email verification
</code></pre>
    <p class="normal">This refactored version not only adheres more closely to SRP but also aligns with the concept of entities in <a id="_idIndexMarker064"/>Clean Architecture. Let’s break down the changes and their implications:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">User</code>: Now stripped down to its essence, the User class truly embodies an entity. It encapsulates the most general and high-level rules, independent of specific application behaviors. It has a single responsibility: managing core user data.</li>
      <li class="bulletList"><code class="inlineCode">PostManager</code>: This takes on the focused responsibility of creating and managing posts.</li>
      <li class="bulletList"><code class="inlineCode">TimelineService</code>: This handles timeline generation logic independently.</li>
      <li class="bulletList"><code class="inlineCode">ProfileManager</code>: This manages profile updates, further reducing the <code class="inlineCode">User</code> class’s responsibilities.</li>
    </ul>
    <p class="normal">Each of these classes now has a clear, focused role that adheres to SRP and promotes separation of concerns. This refactoring brings several benefits:</p>
    <ul>
      <li class="bulletList"><strong class="screenText">Improved maintainability and testability</strong>: Each class has a single, well-defined purpose, making it easier to understand, modify, and test independently</li>
      <li class="bulletList"><strong class="screenText">Greater flexibility and reduced coupling</strong>: We can extend or modify one aspect of the system without affecting others, making our codebase more resilient to change</li>
    </ul>
    <p class="normal">This modular and flexible design aligns well with Clean Architecture principles, creating clear boundaries between different components of our system. While it might seem like overkill for a small application, it sets a foundation for a more maintainable and scalable system as it grows.</p>
    <p class="normal">Remember, most of us work on applications we intend to be successful. With success come feature<a id="_idIndexMarker065"/> requests, pivots, and scaling challenges. Preparing for this growth from the start by applying SRP judiciously can save significant refactoring effort later, creating a structure that’s both flexible and comprehensible as your system evolves.</p>
    <h2 id="_idParaDest-42" class="heading-2"><a id="_idTextAnchor045"/>SRP and testing</h2>
    <p class="normal">Classes with <a id="_idIndexMarker066"/>a single responsibility are generally easier to test as they have fewer dependencies and edge cases. This facilitates the creation of testable systems, a key tenet of Clean Architecture. For example, testing <code class="inlineCode">PostManager</code> becomes straightforward:</p>
    <pre class="programlisting code"><code class="hljs-code">import unittest
from post_manager import PostManager
from user import User
class TestPostManager(unittest.TestCase):
    def test_create_post(self):
        user = User("123", "testuser", "test@example.com")
        post_manager = PostManager()
        post = post_manager.create_post(user, "Hello, world!")
      
        self.assertEqual(post["user_id"], "123")
        self.assertEqual(post["content"], "Hello, world!")
        self.assertEqual(post["likes"], 0)
        self.assertIn("id", post)
</code></pre>
    <p class="normal">This test case showcases the clarity SRP brings to unit testing. Here, <code class="inlineCode">PostManager</code>, with its single responsibility, is easily tested in isolation without complex setup or mocking. We can verify all essential aspects of post-creation straightforwardly. This simplicity in testing is a direct benefit of SRP and aligns with Clean Architecture principles. As systems become more complex, the ability to test individual responsibilities in isolation becomes crucial. It allows us to maintain high code quality, catch issues early, and evolve our test suite alongside the system, ensuring the correctness of each <a id="_idIndexMarker067"/>focused component without the need to resort to complex integration tests.</p>
    <h2 id="_idParaDest-43" class="heading-2"><a id="_idTextAnchor046"/>Balancing the SRP</h2>
    <p class="normal">While SRP is a <a id="_idIndexMarker068"/>powerful principle, it’s important not to take it to extremes. Over-applying SRP can lead to an explosion of tiny classes and functions, which can make the overall system harder to understand and navigate. Misinterpreting SRP <em class="italic">as a class or module that should do only one thing</em> can lead to the creation of too many tiny classes. The principle is about single reasons to change, not strictly about single actions performed.</p>
    <p class="normal">The key is to find a balance, where each unit of code (be it a class, function, or module) has a clear, cohesive purpose, without becoming so granular that the overall structure becomes fragmented. Remember, the goal of SRP is to make your code more maintainable and understandable. If splitting a class or function makes the overall system harder to understand, it might not be the right move. Use your judgment and always consider the context of your specific application.</p>
    <p class="normal">In summary, SRP provides a powerful foundation for creating maintainable and flexible code. By ensuring each module or class has a single, well-defined purpose, we can set the stage for systems that are easier to understand, modify, and extend. As we’ve seen, the key is finding the right balance for your specific context to avoid the extremes of overly complex classes or an explosion of tiny, fragmented components. </p>
    <p class="normal">This principle of balanced application extends throughout Clean Architecture. Each pattern and abstraction layer we explore offers specific benefits like improved testability, easier maintenance, and enhanced flexibility, but also adds complexity. As you progress through this book, consider each pattern through the lens of your specific needs. A startup building an MVP might defer some abstractions until growth demands them, while an enterprise system might benefit from the full architectural approach from day one. With SRP as our starting point, we’re now ready to explore how OCP builds upon this foundation.</p>
    <h1 id="_idParaDest-44" class="heading-1"><a id="_idTextAnchor047"/>Building extensible systems: embracing open–closed design in Python</h1>
    <p class="normal">Having <a id="_idIndexMarker069"/>explored SRP and its role in<a id="_idIndexMarker070"/> creating focused, maintainable classes, we’ll turn our attention to another crucial aspect of robust software design: extensibility. The Open–Closed Principle (OCP), introduced by Bertrand Meyer in 1988 (<a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle</a>), builds upon the foundation laid by SRP. It guides us in creating systems that are said to be <em class="italic">open for extension but closed for modification</em>. This means that we should be able to add new functionality without changing existing code, essentially extending our system’s behavior through new code rather than modifying what’s already in place.</p>
    <p class="normal">OCP is a powerful tool in our SOLID principles toolkit as it works in harmony with SRP to create modular, flexible code. It addresses a common challenge in software development: how to add new features or behaviors without altering existing, tested code. By adhering to OCP, we can design our Python classes and modules so that they can be easily extended, reducing the risk of introducing bugs when adding new functionality.</p>
    <p class="normal">In the context of Clean Architecture, OCP plays a vital role in creating systems that can accommodate change over time. It supports the creation of stable, core business logic that remains untouched as we add new features or adapt to new technologies. As we explore OCP in Python, we’ll see how it contributes to building maintainable, scalable applications that align with Clean Architecture principles.</p>
    <p class="normal">Let’s explore this principle using a practical example of an area calculator for different shapes. Consider the following initial implementation:</p>
    <pre class="programlisting code"><code class="hljs-code">class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
class Circle:
    def __init__(self, radius):
        self.radius = radius
class AreaCalculator:
    def calculate_area(self, shape):
        if isinstance(shape, Rectangle):
            return shape.width * shape.height
        elif isinstance(shape, Circle):
            return 3.14 * shape.radius ** 2
        else:
            raise ValueError("Unsupported shape")
# Usage
rectangle = Rectangle(5, 4)
circle = Circle(3)
calculator = AreaCalculator()
print(f"Rectangle area: {calculator.calculate_area(rectangle)}")
print(f"Circle area: {calculator.calculate_area(circle)}")
</code></pre>
    <p class="normal">Here, we<a id="_idIndexMarker071"/> have a simple <code class="inlineCode">AreaCalculator</code> class<a id="_idIndexMarker072"/> that can calculate the area of rectangles and circles. However, this design violates OCP. If we want to add support for a new shape, such as a triangle, we’d need to modify the <code class="inlineCode">calculate_area</code> method of the <code class="inlineCode">AreaCalculator</code> class. This modification could potentially introduce bugs in the existing working code.</p>
    <p class="normal">To adhere to OCP, we need to restructure our code so that we can add new shapes without modifying the existing <code class="inlineCode">AreaCalculator</code> class. Here’s how we can refactor this code so <a id="_idIndexMarker073"/>that it embraces<a id="_idIndexMarker074"/> OCP:</p>
    <pre class="programlisting code"><code class="hljs-code">from abc import ABC, abstractmethod
import math
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
  
    def area(self):
        return self.width * self.height
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
  
    def area(self):
        return math.pi * self.radius ** 2
class AreaCalculator:
    def calculate_area(self, shape: Shape):
        return shape.area()
# Usage
rectangle = Rectangle(5, 4)
circle = Circle(3)
calculator = AreaCalculator()
print(f"Rectangle area: {calculator.calculate_area(rectangle)}")
print(f"Circle area: {calculator.calculate_area(circle)}")
# Adding a new shape without modifying AreaCalculator
class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height
  
    def area(self):
        return 0.5 * self.base * self.height
triangle = Triangle(6, 4)
print(f"Triangle area: {calculator.calculate_area(triangle)}")
</code></pre>
    <p class="normal">In this refactored version, we’ve made several key changes to adhere to the concept of OCP:</p>
    <ul>
      <li class="bulletList">We introduced an abstract <code class="inlineCode">Shape</code> class with an <code class="inlineCode">area</code> method. This serves as the interface that all shapes must implement.</li>
      <li class="bulletList">Each concrete shape (<code class="inlineCode">Rectangle</code>, <code class="inlineCode">Circle</code>, and now <code class="inlineCode">Triangle</code>) inherits from <code class="inlineCode">Shape</code> and implements its own <code class="inlineCode">area</code> method.</li>
      <li class="bulletList">The <code class="inlineCode">AreaCalculator</code> class now depends on the abstract <code class="inlineCode">Shape</code> class rather than concrete implementations. It calls the <code class="inlineCode">area</code> method on any shape object it receives, without needing to know the specific type of shape.</li>
      <li class="bulletList">We can now add new shapes (such as <code class="inlineCode">Triangle</code>) without modifying the <code class="inlineCode">AreaCalculator</code> class. The system is open for extension but closed for modification.</li>
    </ul>
    <p class="normal">This refactored <a id="_idIndexMarker075"/>design exemplifies OCP in <a id="_idIndexMarker076"/>action, while also maintaining adherence to SRP. Let’s examine the key aspects:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Open for extension</strong>: We can add new shapes (such as <code class="inlineCode">Triangle</code>) without modifying existing code. Each shape class has the single responsibility of defining its properties and calculating its own area.</li>
      <li class="bulletList"><strong class="keyWord">Closed for modification</strong>: The core <code class="inlineCode">AreaCalculator</code> class remains unchanged when adding new shapes, demonstrating closure to modification.</li>
      <li class="bulletList"><strong class="keyWord">Polymorphism</strong>: By using an abstract <code class="inlineCode">Shape</code> class, we can treat different shape objects uniformly. This allows <code class="inlineCode">AreaCalculator</code> to work with any shape through a common interface, without knowing specific implementations.</li>
    </ul>
    <p class="normal">This design aligns perfectly with Clean Architecture’s goals:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Extensibility</strong>: New requirements (such as adding shapes) can be met without disturbing existing, tested code</li>
      <li class="bulletList"><strong class="keyWord">Isolation of core logic</strong>: Each shape’s area calculation is protected from external changes</li>
      <li class="bulletList"><strong class="screenText">Testability</strong>: The clear separation of responsibilities facilitates straightforward unit testing</li>
    </ul>
    <p class="normal">By combining OCP and SRP, we’ve created a foundation for building larger, more complex systems that can evolve without becoming brittle. This example, though small, demonstrates<a id="_idIndexMarker077"/> how Clean Architecture<a id="_idIndexMarker078"/> principles can be applied effectively in Python to create systems that are well-organized, maintainable, and adaptable to changing requirements.</p>
    <h1 id="_idParaDest-45" class="heading-1"><a id="_idTextAnchor048"/>ISP: tailoring interfaces to clients</h1>
    <p class="normal">As we delve <a id="_idIndexMarker079"/>deeper into the SOLID principles, we’ve seen how SRP promotes focused classes and OCP enables extensibility. Now, we’ll turn our attention to the interfaces these classes expose to the world. The Interface Segregation Principle (ISP) (<a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">https://en.wikipedia.org/wiki/Interface_segregation_principle</a>) guides us in creating lean, purpose-specific interfaces that cater to the exact needs of their clients. This principle is crucial for developing flexible, modular Python code that’s easy to understand and maintain.</p>
    <p class="normal">ISP not only builds upon the concept of single responsibility introduced by SRP but also applies it at the interface level. It advocates for designing interfaces that are narrowly focused on specific tasks, rather than interfaces that attempt to encompass too many responsibilities. This approach leads to more flexible and maintainable systems as clients only depend on the methods they actually use.</p>
    <p class="normal">To illustrate the importance of ISP and how it relates to classes doing too much, let’s consider an example of a multimedia player system:</p>
    <pre class="programlisting code"><code class="hljs-code">from abc import ABC, abstractmethod
class MultimediaPlayer(ABC):
    @abstractmethod
    def play_media(self, file: str) -&gt; None:
        pass
    @abstractmethod
    def stop_media(self) -&gt; None:
        pass
    @abstractmethod
    def display_lyrics(self, file: str) -&gt; None:
        pass
    @abstractmethod
    def apply_video_filter(self, filter: str) -&gt; None:
        pass
class MusicPlayer(MultimediaPlayer):
    def play_media(self, file: str) -&gt; None:
        # Implementation for playing music
        print(f"Playing music: {file}")
    def stop_media(self) -&gt; None:
        # Implementation for stopping music
        print("Stopping music")
    def display_lyrics(self, file: str) -&gt; None:
        # Implementation for displaying lyrics
        print(f"Displaying lyrics for: {file}")
    def apply_video_filter(self, filter: str) -&gt; None:
        # This method doesn't make sense for a MusicPlayer
        raise NotImplementedError(
            "MusicPlayer does not support video filters")
class VideoPlayer(MultimediaPlayer):
    # Implementation for video player
    ...
</code></pre>
    <p class="normal">This design <a id="_idIndexMarker080"/>violates ISP by trying to do too much (excess of methods). Let’s examine the issues that arise from this approach:</p>
    <ul>
      <li class="bulletList"><strong class="screenText">Unnecessary methods and a confusing API</strong>: Here, <code class="inlineCode">MusicPlayer</code> is forced to implement <code class="inlineCode">apply_video_filter</code>, which doesn’t make sense for an audio-only player. This leads to awkward implementations and potential runtime errors. Moreover, users of the <code class="inlineCode">MusicPlayer</code> class see methods such as <code class="inlineCode">apply_video_filter</code> in the interface, which can lead to confusion about what the class can actually do. This lack of clarity makes the class harder to use correctly and increases the risk of misuse.</li>
      <li class="bulletList"><strong class="screenText">Lack of modularity</strong>: The interface doesn’t allow for easy creation of specialized players. For instance, we can’t easily create a lyrics-only display without also implementing media playback methods. This rigid structure limits extensibility and reuse, making it difficult to adapt the system to new requirements or use cases.</li>
      <li class="bulletList"><strong class="screenText">Increased maintenance burden</strong>: If we want to add more video-specific features to the <code class="inlineCode">MultimediaPlayer</code> interface later, we’ll need to update all implementing classes each time, even though these features aren’t relevant to some of them. This makes the system more difficult to evolve and increases the risk of introducing bugs when making changes.</li>
    </ul>
    <p class="normal">These issues<a id="_idIndexMarker081"/> demonstrate how violating ISP can lead to inflexible, confusing, and hard-to-maintain code. By addressing these problems, we can create a more modular, flexible, and easy-to-use design.</p>
    <p class="normal">Let’s refactor this design so that it adheres to ISP:</p>
    <pre class="programlisting code"><code class="hljs-code">from abc import ABC, abstractmethod
class MediaPlayable(ABC):
    @abstractmethod
    def play_media(self, file: str) -&gt; None:
        pass
    @abstractmethod
    def stop_media(self) -&gt; None:
        pass
class LyricsDisplayable(ABC):
    @abstractmethod
    def display_lyrics(self, file: str) -&gt; None:
        pass
class VideoFilterable(ABC):
    @abstractmethod
    def apply_video_filter(self, filter: str) -&gt; None:
        pass
class MusicPlayer(MediaPlayable, LyricsDisplayable):
    def play_media(self, file: str) -&gt; None:
        print(f"Playing music: {file}")
    def stop_media(self) -&gt; None:
        print("Stopping music")
    def display_lyrics(self, file: str) -&gt; None:
        print(f"Displaying lyrics for: {file}")
class VideoPlayer(MediaPlayable, VideoFilterable):
    def play_media(self, file: str) -&gt; None:
        print(f"Playing video: {file}")
    def stop_media(self) -&gt; None:
        print("Stopping video")
    def apply_video_filter(self, filter: str) -&gt; None:
        print(f"Applying video filter: {filter}")
class BasicAudioPlayer(MediaPlayable):
    def play_media(self, file: str) -&gt; None:
        print(f"Playing audio: {file}")
    def stop_media(self) -&gt; None:
        print("Stopping audio")
</code></pre>
    <p class="normal">In this refactored design, we’ve leveraged <a id="_idIndexMarker082"/>Python’s <strong class="screenText">abstract base classes</strong> (<strong class="screenText">ABCs</strong>) to create a set of focused interfaces. This approach allows us to define clear contracts for different functionalities without forcing classes to implement methods they don’t need. By breaking <a id="_idIndexMarker083"/>down the original monolithic interface into smaller, more specific ones, we’ve created a flexible structure that adheres to ISP. Let’s examine the key components of this refactored design:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">MediaPlayable</code>: This interface focuses solely on playing and stopping media, a core functionality shared by all media players</li>
      <li class="bulletList"><code class="inlineCode">LyricsDisplayable</code>: By separating the lyrics display into its own interface, we’ve ensured that classes that don’t support lyrics (such as <code class="inlineCode">VideoPlayer</code>) aren’t forced to implement unnecessary methods</li>
      <li class="bulletList"><code class="inlineCode">VideoFilterable</code>: This interface isolates video-specific functionality, preventing audio-only players from implementing irrelevant methods</li>
    </ul>
    <p class="normal">The concrete classes (<code class="inlineCode">MusicPlayer</code>, <code class="inlineCode">VideoPlayer</code>, and <code class="inlineCode">BasicAudioPlayer</code>) now implement only the interfaces relevant to their functionality. This design allows for easy creation and use of different types of media player. For example, <code class="inlineCode">MusicPlayer</code> can play media and display lyrics, while <code class="inlineCode">BasicAudioPlayer</code> only needs to implement media playback. This flexibility makes it simple to create new types of player by combining the relevant interfaces, without the burden of implementing unnecessary methods.</p>
    <p class="normal">Let’s summarize the overall benefits of ISP:</p>
    <ul>
      <li class="bulletList"><strong class="screenText">Reduced coupling</strong>: Classes <a id="_idIndexMarker084"/>depend only on the methods they actually use</li>
      <li class="bulletList"><strong class="screenText">Improved maintainability</strong>: Changes to one aspect (for example, video filtering) don’t affect unrelated classes</li>
      <li class="bulletList"><strong class="screenText">Enhanced flexibility</strong>: We can easily create new types of player by combining relevant interfaces</li>
      <li class="bulletList"><strong class="screenText">Better testability</strong>: We can mock interfaces more easily by focusing tests on specific functionalities</li>
    </ul>
    <p class="normal">This ISP-driven design supports Clean Architecture by creating clear, focused interfaces that align with specific use cases. Recall from <a href="Chapter_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a> that use cases in Clean Architecture represent application-specific business rules, describing how and when the system uses entities to achieve its goals. ISP facilitates this by allowing us to define precise interfaces for each use case. For instance, the <code class="inlineCode">LyricsDisplayable</code> interface directly supports a <em class="italic">display lyrics</em> use case without burdening other player types. This approach allows for a more modular system where components can evolve independently, making it easier to implement new use cases or modify existing ones without affecting unrelated parts of the system. As a result, our application can adapt more readily to changing requirements while maintaining the integrity of its core business logic.</p>
    <p class="normal">In conclusion, ISP guides us in creating more flexible, maintainable systems by encouraging the design of focused, specific interfaces. By applying ISP alongside SRP and OCP, we can create Python code that’s easier to understand, test, and extend. ISP helps us avoid the pitfall <a id="_idIndexMarker085"/>of classes trying to <em class="italic">do too much</em>, just as OCP helps us avoid classes trying to <em class="italic">be too many things</em>. Together, these principles support Clean Architecture’s goals, helping us create systems that can adapt to changing requirements while maintaining a clear, modular structure.</p>
    <h1 id="_idParaDest-46" class="heading-1"><a id="_idTextAnchor049"/>From rigid to flexible: rethinking inheritance and interfaces in Python</h1>
    <p class="normal">As we’ve explored<a id="_idIndexMarker086"/> the Single Responsibility, Open–Closed, and Interface Segregation Principles, we’ve built a foundation for creating modular, extensible, and focused code. These principles guide us in structuring our classes and interfaces to be more maintainable and adaptable. Now, we turn our attention to the Liskov Substitution Principle (LSP), which complements and reinforces the principles we’ve discussed.</p>
    <p class="normal">While SRP guides us in creating focused, cohesive classes, OCP allows us to extend our code without modifying existing components, and ISP promotes the creation of specific, client-tailored interfaces. LSP ensures that our abstractions are well-formed, and our components are truly interchangeable. This principle is crucial for creating robust, flexible systems by ensuring that our inheritance hierarchies behave predictably.</p>
    <p class="normal">In the context of Clean Architecture, LSP plays a vital role in supporting the flexibility promised by OCP and the focused design encouraged by SRP and ISP. As we delve into LSP, we’ll see how it works in concert with the other SOLID principles to create a system that’s not just modular, but also reliable and intuitive to use and extend.</p>
    <h2 id="_idParaDest-47" class="heading-2"><a id="_idTextAnchor050"/>Understanding LSP</h2>
    <p class="normal">The Liskov Substitution Principle (LSP), introduced by Barbara Liskov in 1987 (<a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">https://en.wikipedia.org/wiki/Liskov_substitution_principle</a>), provides a guideline for creating inheritance<a id="_idIndexMarker087"/> hierarchies that behave predictably and intuitively. At its core, LSP is about maintaining the integrity of a base class’s contract throughout its inheritance hierarchy.</p>
    <p class="normal">Here’s what LSP tells us:</p>
    <ul>
      <li class="bulletList">A base class defines a contract that users of the class can rely on. This contract consists of a set of behaviors and properties.</li>
      <li class="bulletList">Subclasses shouldn’t alter or be destructive to this contract. They must honor the promises made by the base class.</li>
      <li class="bulletList">Subclasses can extend or refine the contract, making it more specific to themselves, but they can’t reduce or violate the original contract.</li>
    </ul>
    <p class="normal">In other words, if we have a base class, any of its subclasses should be able to stand in for that base class without breaking the program or violating the expectations set by the base class.</p>
    <p class="normal">This principle is crucial for several reasons:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Predictability</strong>: When LSP is followed, users of a base class can trust that all derived classes will behave in a way that’s consistent with the base class. This makes the system more predictable and easier to reason about.</li>
      <li class="bulletList"><strong class="keyWord">Flexibility</strong>: LSP allows us to use polymorphism effectively. We can write code that works with the base class and trust that it will work correctly with any of its subclasses.</li>
      <li class="bulletList"><strong class="screenText">Extensibility</strong>: By ensuring that subclasses respect the base class contract, we create a system that’s easier to extend. New subclasses can be added without fear of breaking existing code that relies on the base class.</li>
    </ul>
    <p class="normal">However, adhering to <a id="_idIndexMarker088"/>LSP isn’t always straightforward. It requires careful thought about how we model our objects and their relationships. Let’s look at an example to see how violating LSP can lead to problems, and how we can refactor our code to follow this principle.</p>
    <h2 id="_idParaDest-48" class="heading-2"><a id="_idTextAnchor051"/>The pitfalls of rigid hierarchies</h2>
    <p class="normal">Consider a system<a id="_idIndexMarker089"/> for managing different vehicle types and their fuel consumption:</p>
    <pre class="programlisting code"><code class="hljs-code">class Vehicle:
    def __init__(self, fuel_capacity: float):
        self._fuel_capacity = fuel_capacity
        self._fuel_level = fuel_capacity
    def fuel_level(self) -&gt; float:
        return self._fuel_level
    def consume_fuel(self, distance: float) -&gt; None:
        # Assume 10 km per liter for simplicity:
        fuel_consumed = distance / 10
        if self._fuel_level - fuel_consumed &lt; 0:
            raise ValueError("Not enough fuel to cover the distance")
        self._fuel_level -= fuel_consumed
</code></pre>
    <p class="normal">This <code class="inlineCode">Vehicle</code> class represents a typical fuel-based vehicle. Now, let’s introduce an <code class="inlineCode">ElectricCar</code> class that inherits from <code class="inlineCode">Vehicle</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">class ElectricCar(Vehicle):
    def __init__(self, battery_capacity: float):
        super().__init__(battery_capacity)
    def consume_fuel(self, distance: float) -&gt; None:
        # Assume 5 km per kWh for simplicity:
        energy_consumed = distance / 5
        if self._fuel_level - energy_consumed &lt; 0:
            raise ValueError("Not enough charge to cover the distance")
        self._fuel_level -= energy_consumed
</code></pre>
    <p class="normal">At first glance, this <a id="_idIndexMarker090"/>might seem like a reasonable approach. However, it leads to several issues:</p>
    <ul>
      <li class="bulletList">It violates LSP because <code class="inlineCode">ElectricCar</code> can’t be substituted for <code class="inlineCode">Vehicle</code> without causing incorrect behavior</li>
      <li class="bulletList">The <code class="inlineCode">ElectricCar</code> class changes the meaning of <em class="italic">fuel consumption</em>, violating the contract established by <code class="inlineCode">Vehicle</code></li>
      <li class="bulletList">It creates a fragile design where functions that work with <code class="inlineCode">Vehicle</code> may silently produce incorrect results with <code class="inlineCode">ElectricCar</code></li>
    </ul>
    <p class="normal">To illustrate this, consider the following function:</p>
    <pre class="programlisting code"><code class="hljs-code">def drive_vehicle(vehicle: Vehicle, distance: float) -&gt; None:
    initial_fuel = vehicle.fuel_level()
    vehicle.consume_fuel(distance)
    fuel_consumed = initial_fuel - vehicle.fuel_level()
    print(f"Fuel consumed: {fuel_consumed:.2f} liters")
# Usage
car = Vehicle(50)  # 50 liter tank
drive_vehicle(car, 100)  # Works fine
electric_car = ElectricCar(50)  # 50 kWh battery
drive_vehicle(electric_car, 100) # This prints incorrect fuel consumption
</code></pre>
    <p class="normal">This <code class="inlineCode">drive_vehicle</code> function works correctly for <code class="inlineCode">Vehicle</code> but produces misleading output for <code class="inlineCode">ElectricCar</code>. These problems stem from forcing <code class="inlineCode">ElectricCar</code> into an inheritance <a id="_idIndexMarker091"/>relationship with <code class="inlineCode">Vehicle</code>, even though an electric car’s energy consumption works differently from a fuel-based vehicle. This is a common pitfall when modeling <em class="italic">is-a</em> relationships too literally.</p>
    <h2 id="_idParaDest-49" class="heading-2"><a id="_idTextAnchor052"/>Embracing flexibility with LSP</h2>
    <p class="normal">Let’s refactor this so<a id="_idIndexMarker092"/> that it adheres to LSP. We’ll start by defining an abstract base class for power sources:</p>
    <pre class="programlisting code"><code class="hljs-code">from abc import ABC, abstractmethod
class PowerSource(ABC):
    def __init__(self, capacity: float):
        self._capacity = capacity
        self._level = capacity
    def level(self) -&gt; float:
        return self._level
    @abstractmethod
    def consume(self, distance: float) -&gt; float:
        pass
</code></pre>
    <p class="normal">Now, we can <a id="_idIndexMarker093"/>create specific implementations for different types of power source:</p>
    <pre class="programlisting code"><code class="hljs-code">class FuelTank(PowerSource):
    def consume(self, distance: float) -&gt; float:
        # Assume 10 km per liter for simplicity:
        fuel_consumed = distance / 10
        if self._level - fuel_consumed &lt; 0:
            raise ValueError("Not enough fuel to cover the distance")
        self._level -= fuel_consumed
        return fuel_consumed
class Battery(PowerSource):
    def consume(self, distance: float) -&gt; float:
        # Assume 5 km per kWh for simplicity:
        energy_consumed = distance / 5
        if self._level – energy_consumed &lt; 0:
            raise ValueError("Not enough charge to cover the distance")
        self._level -= energy_consumed
        return energy_consumed
</code></pre>
    <p class="normal">With these power sources defined, we can create a more flexible <code class="inlineCode">Vehicle</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">class Vehicle:
    def __init__(self, power_source: PowerSource):
        self._power_source = power_source
    def power_level(self) -&gt; float:
        return self._power_source.level()
    def drive(self, distance: float) -&gt; float:
        return self._power_source.consume(distance)
</code></pre>
    <p class="normal">Finally, we can<a id="_idIndexMarker094"/> update our <code class="inlineCode">drive_vehicle</code> function so that it works with this new design:</p>
    <pre class="programlisting code"><code class="hljs-code">def drive_vehicle(vehicle: Vehicle, distance: float) -&gt; None:
    try:
        energy_consumed = vehicle.drive(distance)
        print(f"Energy consumed: {energy_consumed:.2f} units")
    except ValueError as e:
        print(f"Unable to complete journey: {e}")
# Usage
fuel_car = Vehicle(FuelTank(50))  # 50 liter tank
drive_vehicle(fuel_car, 100)  # Prints: Energy consumed: 10.00 units
electric_car = Vehicle(Battery(50))  # 50 kWh battery
drive_vehicle(electric_car, 100)  # Prints: Energy consumed: 20.00 units
</code></pre>
    <p class="normal">This refactored design demonstrates LSP in action. The key change is the introduction of abstraction and separation of concerns. We’ve decoupled the concept of a power source from the vehicle itself, allowing for different types of power sources to be used interchangeably. This abstraction is achieved through the <code class="inlineCode">PowerSource</code> base class, which defines a <a id="_idIndexMarker095"/>common interface for all types of energy sources.</p>
    <p class="normal">Let’s break down the key components of this new design:</p>
    <ul>
      <li class="bulletList"><strong class="screenText">The </strong><code class="inlineCode">PowerSource</code><strong class="screenText"> abstract base class</strong>: This defines a contract with the <code class="inlineCode">level</code> and <code class="inlineCode">consume</code> methods that all power sources must fulfill. It establishes a common interface for different types of energy source.</li>
      <li class="bulletList"><strong class="screenText">Concrete implementations (</strong><code class="inlineCode">FuelTank</code> and <code class="inlineCode">Battery</code><strong class="screenText">)</strong>: These classes inherit from <code class="inlineCode">PowerSource</code> and provide specific implementations of the <code class="inlineCode">consume</code> method. Crucially, they maintain the behavioral contract defined by <code class="inlineCode">PowerSource</code>.</li>
      <li class="bulletList"><strong class="screenText">The </strong><code class="inlineCode">Vehicle</code><strong class="screenText"> class</strong>: This class depends on the abstract <code class="inlineCode">PowerSource</code> base class, not on concrete implementations. This adherence to LSP allows any subclass of <code class="inlineCode">PowerSource</code> to be used interchangeably without affecting the behavior of <code class="inlineCode">Vehicle</code>.</li>
      <li class="bulletList"><strong class="screenText">The </strong><code class="inlineCode">drive_vehicle</code><strong class="screenText"> function</strong>: This function demonstrates how LSP enables polymorphism. It can work with any <code class="inlineCode">Vehicle</code> class, regardless of its specific power source, without modification.</li>
    </ul>
    <p class="normal">LSP’s impact on this design is multifaceted. It ensures behavioral consistency, allowing all power sources to be treated uniformly by the <code class="inlineCode">Vehicle</code> class. This polymorphic flexibility enables functions like <code class="inlineCode">drive_vehicle</code> to work with any vehicle type without knowing specific implementation details. The design improves extensibility, as new power sources (like hydrogen fuel cells) can be added by implementing the <code class="inlineCode">PowerSource</code> interface without changing existing code. It also enhances testability by allowing us to create mock power sources for testing <code class="inlineCode">Vehicle</code> behavior.</p>
    <p class="normal">By adhering to LSP, we’ve created a flexible system where core business logic remains protected from changes in specific power source implementations. This separation is a key aspect of Clean Architecture that promotes long-term stability while enabling easy extension. LSP works harmoniously with other SOLID principles: it builds upon SRP by ensuring interfaces have clear purposes, supports OCP by allowing extension without modification, and complements ISP by promoting focused, substitutable interfaces.</p>
    <p class="normal">This alignment enhances modularity, a cornerstone of Clean Architecture. Components like <code class="inlineCode">FuelTank</code> and <code class="inlineCode">Battery</code> can be swapped without affecting the rest of the system, allowing our application to evolve with minimal disruption. Clear interfaces like <code class="inlineCode">PowerSource</code> make the system easier to understand and navigate, serving as guideposts for developers whether new to the project or returning months later.</p>
    <p class="normal">In conclusion, LSP guides us in creating hierarchies that are both flexible and reliable. By ensuring derived classes can truly substitute for their base classes, we build more robust, extensible Python applications aligned with Clean Architecture goals. As we move forward to<a id="_idIndexMarker096"/> explore DIP, remember how LSP works with the other SOLID principles to form a powerful toolkit for creating enduring applications.</p>
    <h1 id="_idParaDest-50" class="heading-1"><a id="_idTextAnchor053"/>Decoupling for flexibility: inverting dependencies in Python</h1>
    <p class="normal">Upon exploring LSP and its role in creating robust abstractions, we’ve seen how it contributes to the<a id="_idIndexMarker097"/> flexibility and maintainability of our Python code. Now let’s turn our attention to the final piece of the SOLID puzzle: the Dependency Inversion Principle (DIP).</p>
    <p class="normal">DIP serves as a capstone to the SOLID principles, tying together and reinforcing the concepts we explored in the previous principles. It provides a powerful mechanism for structuring the relationships between different components of our system, further enhancing the flexibility and maintainability we’ve been building throughout our journey through SOLID.</p>
    <p class="normal">While LSP ensures that our abstractions are well-formed and substitutable, DIP focuses on how these abstractions should relate to one another. It guides us in creating a structure where high-level modules aren’t dependent on low-level modules, but both depend on abstractions. This inversion of traditional dependency structures is crucial for implementing Clean Architecture in Python as it allows us to create systems that are truly decoupled and adaptable to change.</p>
    <p class="normal">As we delve into DIP, we’ll see how it provides a practical approach to implementing the Dependency Rule, a cornerstone of Clean Architecture that we introduced in <a href="Chapter_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>. Recall that the Dependency Rule states that source code dependencies should only point inwards, with inner circles containing high-level policies and outer circles containing implementation details. DIP offers a concrete strategy for adhering to this rule, allowing us to structure our code so that high-level modules are independent of low-level modules. Let’s explore how we can invert our dependencies to create more flexible, maintainable <a id="_idIndexMarker098"/>Python systems that truly embody the principles of Clean Architecture and respect the Dependency Rule.</p>
    <h2 id="_idParaDest-51" class="heading-2"><a id="_idTextAnchor054"/>Understanding DIP</h2>
    <p class="normal">Before we dive into the<a id="_idIndexMarker099"/> intricacies of DIP, let’s clarify what we mean by <em class="italic">depends on</em> in the context of software design. Consider this simple code example:</p>
    <pre class="programlisting code"><code class="hljs-code">class A:
    def __init__(self):
        self.b = B()
class B:
    def __init__(self):
        pass
</code></pre>
    <p class="normal">In this case, we say that <code class="inlineCode">A</code> depends on <code class="inlineCode">B</code>. This dependency manifests because <code class="inlineCode">A</code> knows about <code class="inlineCode">B</code>. This is evident in the line that creates an instance of <code class="inlineCode">B</code>: <code class="inlineCode">self.b = B()</code>. However, <code class="inlineCode">B</code> knows nothing about <code class="inlineCode">A</code>. We typically represent this dependency with an arrow pointing from <code class="inlineCode">A</code> to <code class="inlineCode">B</code>, as shown in <em class="italic">Figure 2.1</em>:</p>
    <figure class="mediaobject"><img src="img/B31577_02_1.png" alt="Figure 2.1: A depends on B" width="397" height="163"/></figure>
    <p class="packt_figref">Figure 2.1: A depends on B</p>
    <p class="normal">This simple example sets the stage for understanding the problem that DIP aims to solve. In many software systems, high-level modules (which contain the core business logic) often depend on low-level modules (which handle specific details or implementations). This can lead to inflexible designs that are difficult to modify and maintain.</p>
    <p class="normal">To illustrate this, let’s<a id="_idIndexMarker100"/> consider a more concrete example involving a <code class="inlineCode">UserEntity</code> class that relies on a low-level detail:</p>
    <pre class="programlisting code"><code class="hljs-code">class UserEntity:
    def __init__(self, user_id: str):
        self.user_id = user_id
        # Direct dependency on a low-level module:
        self.database = MySQLDatabase()
    def save(self):
        self.database.insert("users", {"id": self.user_id})
class MySQLDatabase:
    def insert(self, table: str, data: dict):
        print(f"Inserting {data} into {table} table in MySQL")
</code></pre>
    <p class="normal">In this example, <code class="inlineCode">UserEntity</code> directly depends on <code class="inlineCode">MySQLDatabase</code>, a low-level module. Now, imagine that we receive a feature request to support multiple database systems. With the current design, we’d need to modify <code class="inlineCode">UserEntity</code> so that it can accommodate this change, violating OCP and potentially introducing bugs into our core business logic. The following are some additional problems with this design:</p>
    <ul>
      <li class="bulletList">The <code class="inlineCode">UserEntity</code> class is tightly coupled to <code class="inlineCode">MySQLDatabase</code>, making it difficult to change the database system in the future</li>
      <li class="bulletList">Testing <code class="inlineCode">UserEntity</code> becomes challenging because we can’t easily substitute a mock database for testing purposes</li>
      <li class="bulletList">The core <a id="_idIndexMarker101"/>business logic (<code class="inlineCode">UserEntity</code>) is polluted with infrastructure concerns (database operations)</li>
    </ul>
    <h2 id="_idParaDest-52" class="heading-2"><a id="_idTextAnchor055"/>Fixing the design with DIP</h2>
    <p class="normal">DIP, introduced<a id="_idIndexMarker102"/> by Robert C. Martin (<a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">https://en.wikipedia.org/wiki/Dependency_inversion_principle</a>), proposes a solution to the problems seen in the preceding example. It states the following:</p>
    <ul>
      <li class="bulletList">High-level modules shouldn’t depend on low-level modules. Both should depend on abstractions.</li>
      <li class="bulletList">Abstractions shouldn’t depend on details. Details should depend on abstractions.</li>
    </ul>
    <p class="normal">These two points fundamentally change how we structure our code. Instead of having direct dependencies between high-level and low-level modules, we introduce abstractions that both depend on. However, the key insight of DIP lies in what’s actually <em class="italic">inverted</em>:</p>
    <ul>
      <li class="bulletList">Traditionally, low-level modules define abstractions that high-level modules use</li>
      <li class="bulletList">With DIP, high-level modules define abstractions that low-level modules implement</li>
    </ul>
    <p class="normal">This inversion of abstraction ownership is what gives DIP its name, not a simple reversal of dependency direction between modules. The high-level module now controls the abstraction, while low-level modules conform to it. This shift in control allows high-level modules to remain independent of low-level implementation details, promoting flexibility and maintainability in our system design.</p>
    <p class="normal">Let’s look at how this changes our dependency diagram:</p>
    <figure class="mediaobject"><img src="img/B31577_02_2.png" alt="Figure 2.2: A and B depend on an interface" width="1210" height="330"/></figure>
    <p class="packt_figref">Figure 2.2: A and B depend on an interface</p>
    <p class="normal">As shown in <em class="italic">Figure 2.2</em>, the dependencies now point toward the abstraction, inverting the traditional flow. The high-level module (<code class="inlineCode">A</code>) and the low-level module (<code class="inlineCode">B</code>) both depend on an abstraction (Interface), rather than on each other directly. This change is profound: <code class="inlineCode">A</code> no longer <em class="italic">knows of</em> <code class="inlineCode">B</code>; rather, it knows of a contract that a <em class="italic">thing like</em> <code class="inlineCode">B</code> will adhere to.</p>
    <p class="normal">This shift from<a id="_idIndexMarker103"/> concrete knowledge to abstract contract has far-reaching implications:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Decoupling</strong><strong class="screenText"> and flexibility</strong>: Now, <code class="inlineCode">A</code> is decoupled from the specifics of <code class="inlineCode">B</code>, only knowing the contract it must fulfill. This allows us to easily swap or upgrade components without affecting the rest of the system, making it more adaptable to future requirements.</li>
      <li class="bulletList"><strong class="screenText">Improved testability</strong>: We can create mock objects that implement the interface for testing purposes, allowing us to test components in isolation without a complex setup.</li>
      <li class="bulletList"><strong class="screenText">Clarity and </strong><strong class="keyWord">encapsulation</strong>: The interface clearly defines component interactions, making the code more self-documenting. Changes in implementation are contained, reducing ripple effects across the system.</li>
      <li class="bulletList"><strong class="keyWord">Design by contract</strong>: This approach encourages thinking in terms of interfaces rather than concrete implementations, promoting better-designed, more modular systems that are easier to understand and maintain.</li>
    </ul>
    <p class="normal">By adhering to DIP, we’re not just changing the direction of dependencies; we’re fundamentally altering how different parts of our system interact. This creates a more loosely coupled, flexible, and maintainable architecture that can better withstand the test of time and changing requirements.</p>
    <p class="normal">To align our <code class="inlineCode">UserEntity</code> code with DIP, we need to introduce an abstraction that both the high-level and low-level modules can depend on. This abstraction typically takes the form of <a id="_idIndexMarker104"/>an interface. Let’s refactor our code so that it adheres to DIP:</p>
    <pre class="programlisting code"><code class="hljs-code">from abc import ABC, abstractmethod
class DatabaseInterface(ABC):
    @abstractmethod
    def insert(self, table: str, data: dict):
        pass
class UserEntity:
    def __init__(self, user_id: str, database: DatabaseInterface):
        self.user_id = user_id
        self.database = database
    def save(self):
        self.database.insert("users", {"id": self.user_id})
class MySQLDatabase(DatabaseInterface):
    def insert(self, table: str, data: dict):
        print(f"Inserting {data} into {table} table in MySQL")
class PostgreSQLDatabase(DatabaseInterface):
    def insert(self, table: str, data: dict):
        print(f"Inserting {data} into {table} table in PostgreSQL")
# Usage
mysql_db = MySQLDatabase()
user = UserEntity("123", mysql_db)
user.save()
postgres_db = PostgreSQLDatabase()
another_user = UserEntity("456", postgres_db)
another_user.save()
</code></pre>
    <p class="normal">In this refactored version, we did the following:</p>
    <ul>
      <li class="bulletList">We introduced an abstraction (<code class="inlineCode">DatabaseInterface</code>) that both high-level (<code class="inlineCode">UserEntity</code>) and low-level (<code class="inlineCode">MySQLDatabase</code>, <code class="inlineCode">PostgreSQLDatabase</code>) modules depend on.</li>
      <li class="bulletList">The <code class="inlineCode">UserEntity</code> class no longer creates its database dependency, instead receiving it through its constructor. This technique is known as dependency injection, which is a key practice in implementing DIP.</li>
      <li class="bulletList">We can easily add support for new database systems by creating new classes that implement <code class="inlineCode">DatabaseInterface</code>.</li>
    </ul>
    <p class="normal"><em class="italic">Figure 2.3</em> represents the<a id="_idIndexMarker105"/> new state of relationships between these components:</p>
    <figure class="mediaobject"><img src="img/B31577_02_3.png" alt="Figure 2.3: UserEntity is decoupled from the concrete storage classes" width="941" height="718"/></figure>
    <p class="packt_figref">Figure 2.3: UserEntity is decoupled from the concrete storage classes</p>
    <p class="normal">This diagram’s significance lies in several key aspects:</p>
    <ul>
      <li class="bulletList"><strong class="screenText">Inverted dependency and abstraction as a contract</strong>: The <code class="inlineCode">UserEntity</code> class depends on the <code class="inlineCode">DatabaseInterface</code> abstraction, not concrete implementations. This interface serves as a contract for any database implementation.</li>
      <li class="bulletList"><strong class="screenText">Separation of concerns</strong>: The <code class="inlineCode">UserEntity</code> class is decoupled from specific database operations, knowing only about the abstract operations defined in <code class="inlineCode">DatabaseInterface</code>.</li>
      <li class="bulletList"><strong class="screenText">Extensibility and flexibility</strong>: The design allows us to easily add new database implementations and swap between them without affecting <code class="inlineCode">UserEntity</code>.</li>
    </ul>
    <p class="normal">By applying DIP, we’ve created a flexible, maintainable system where our core business logic (<code class="inlineCode">UserEntity</code>) is protected from changes in external details (database implementations). This separation is a cornerstone of Clean Architecture that promotes long-term system stability and adaptability. The preceding diagram shows how multiple implementations (<code class="inlineCode">MySQLDatabase</code> and <code class="inlineCode">PostgreSQLDatabase</code>) can coexist, demonstrating<a id="_idIndexMarker106"/> the power of this abstraction-based approach. We could easily add more implementations, such as <code class="inlineCode">OracleDatabase</code> or <code class="inlineCode">MongoDBAdapter</code>, without modifying <code class="inlineCode">UserEntity</code>, further illustrating the extensibility benefits of DIP.</p>
    <h2 id="_idParaDest-53" class="heading-2"><a id="_idTextAnchor056"/>DIP’s effect on testing</h2>
    <p class="normal">As we’ve seen with<a id="_idIndexMarker107"/> other SOLID principles, the use of dependency injection significantly aids in testing. We can now easily create a mock database for testing <code class="inlineCode">UserEntity</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">class MockDatabase(DatabaseInterface):
    def __init__(self):
        self.inserted_data = []
    def insert(self, table: str, data: dict):
        self.inserted_data.append((table, data))
# In a test
mock_db = MockDatabase()
user = UserEntity("test_user", mock_db)
user.save()
assert mock_db.inserted_data == [("users", {"id": "test_user"})]
</code></pre>
    <p class="normal">This ability to easily substitute dependencies makes our code much more testable, allowing us to verify <a id="_idIndexMarker108"/>the behavior of <code class="inlineCode">UserEntity</code> in isolation from any actual database implementation.</p>
    <h2 id="_idParaDest-54" class="heading-2"><a id="_idTextAnchor057"/>DIP in the context of SOLID and Clean Architecture</h2>
    <p class="normal">DIP serves as a<a id="_idIndexMarker109"/> cornerstone <a id="_idIndexMarker110"/>in both SOLID principles and Clean Architecture. It complements other SOLID principles by enabling the separation of interface definitions from implementations and supporting the easy extension of system behavior. In Clean Architecture, DIP is crucial for implementing the Dependency Rule, allowing inner layers to define interfaces that outer layers must adhere to. This inversion separates business logic from implementation details, creating more flexible, maintainable, and testable systems that align perfectly with Clean Architecture goals.</p>
    <h1 id="_idParaDest-55" class="heading-1"><a id="_idTextAnchor058"/>Summary</h1>
    <p class="normal">In this chapter, we explored the SOLID principles and their application in Python to create clean, maintainable, and flexible architectures. We learned how each principle contributes to robust software design:</p>
    <ul>
      <li class="bulletList">SRP for creating focused, cohesive classes</li>
      <li class="bulletList">OCP for extending behavior without modification</li>
      <li class="bulletList">LSP for ensuring well-formed, substitutable abstractions</li>
      <li class="bulletList">ISP for designing targeted, client-specific interfaces</li>
      <li class="bulletList">DIP for structuring dependencies to maximize flexibility</li>
    </ul>
    <p class="normal">These principles are crucial for developing Python applications that can evolve with changing requirements, resist software entropy, and remain clear as systems grow in complexity. They form the foundation of Clean Architecture, enabling us to create more modular, testable, and adaptable code.</p>
    <p class="normal">In the next chapter, we’ll explore how to leverage Python’s type system to further enhance the robustness and clarity of our Clean Architecture designs. You’ll see how type hints can strengthen several SOLID principles we’ve just covered: creating more explicit interfaces for ISP, defining clearer contracts for DIP, and making substitutability more apparent for LSP. These typing capabilities will help us create even more maintainable and self-documenting code while maintaining Python’s flexibility.</p>
    <h1 id="_idParaDest-56" class="heading-1"><a id="_idTextAnchor059"/>Further reading</h1>
    <ul>
      <li class="bulletList"><em class="italic">SOLID Principles</em> (<a href="https://realpython.com/solid-principles-python/">https://realpython.com/solid-principles-python/</a>). This is a comprehensive tutorial that walks through each SOLID principle with Python-specific examples.</li>
      <li class="bulletList"><em class="italic">Agile Software Development, Principles, Patterns, and Practices</em> by Robert C. Martin.</li>
      <li class="bulletList"><em class="italic">Python Design Patterns</em> by Brandon Rhodes (<a href="https://python-patterns.guide/">https://python-patterns.guide/</a>). While not exclusively about SOLID, this resource covers many design patterns that complement SOLID principles in Python.</li>
      <li class="bulletList"><em class="italic">SOLID: The First Five Principles of Object-Oriented Design</em> (<a href="https://www.digitalocean.com/community/conceptual-articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design">https://www.digitalocean.com/community/conceptual-articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design</a>). This comprehensive article provides a clear explanation of each SOLID principle with practical code examples. While the examples are in PHP, the concepts are universally applicable and can be easily translated into Python, making it a valuable resource for deepening your understanding of SOLID principles in object-oriented design.</li>
    </ul>
  </div>
</div></div></body></html>