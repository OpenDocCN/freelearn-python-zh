- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an IoT Information Display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build an IoT information display using a Raspberry
    Pi-branded 7-inch touchscreen. We will use this information display to show real-time
    weather information and local traffic information.
  prefs: []
  type: TYPE_NORMAL
- en: We will start the chapter by exploring screens compatible for use with our Raspberry
    Pi. We will look at small **Organic Light-Emitting Diode** (**OLED**) screens,
    dot-matrix displays, seven-segment displays, and small LCD monitors for the Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: For our project, we will build an IoT information display with Raspberry Pi’s
    7-inch touchscreen. This *dashboard* will not only show weather details but will
    also feature a map depicting local traffic conditions.
  prefs: []
  type: TYPE_NORMAL
- en: The insights gained in this chapter will equip us with a versatile toolkit,
    fostering creativity and innovation in future Raspberry Pi and IoT projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Investigating displays compatible with our Raspberry Pi and exploring screen
    types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an IoT information display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the requirements for completing this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate knowledge of Python programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A late-model Raspberry Pi, preferably a Raspberry Pi 5 with at least 4 GB of
    RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Raspberry Pi branded 7-inch touchscreen with a compatible case (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter may be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter4](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter4%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: Investigating displays compatible with our Raspberry Pi and exploring screen
    types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Raspberry Pi offers the flexibility to interface with various external screens,
    catering to different applications and requirements. In *Figure 4**.1*, we see
    examples of small screens that we may hook up to our Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Small displays that may be used with the Raspberry Pi](img/B21282_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Small displays that may be used with the Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.1* shows different small screens tailored for various uses: OLED
    screens (*B*, *C*, *D*) for fine detail; a 16 x 2 LCD (*F*) for concise text;
    and dot-matrix (*A*) and segment-style displays (*E*) for clear numbers and characters.
    These options offer a versatile range of visual representations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several larger screen options for the Raspberry Pi, including standard
    4K computer monitors, as well as smaller monitor-style screens, as we see in *Figure
    4**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Encased Raspberry Pi’s 7-inch touchscreen (A) and 3.5-inch LCD
    screen (B)](img/B21282_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Encased Raspberry Pi’s 7-inch touchscreen (A) and 3.5-inch LCD
    screen (B)
  prefs: []
  type: TYPE_NORMAL
- en: The screen in *Figure 4**.2* *A* is the Raspberry Pi branded 7-inch touchscreen.
    It is shown here in a case specifically designed to house it. In *Figure 4**.2*
    *B*, we see a 3.5-inch LCD screen that connects to the GPIO port of the Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at each type of screen to understand their unique characteristics
    and applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each screen shown in *Figure 4**.1* and *Figure 4**.2* offers unique advantages
    for specific applications, and understanding these can enhance our Raspberry Pi
    projects. The following are descriptions of each screen/display:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Small OLED screens**: OLED screens (see *B*, *C*, and *D* in *Figure 4**.1*)
    are known for their crisp detail and energy efficiency. Small OLED screens (0\.
    to 1.3 inches) are commonly used in projects that require minimal space and low
    power consumption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OLED screens are used to display system status or in small gadgets such as fitness
    trackers. Ideal for showing limited information such as icons, temperature, or
    time, their compact size and energy efficiency make them a perfect choice for
    clear, concise displays without using much power or space.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**16 x 2 LCD screens**: 16 x 2 LCD screens (see *F* in *Figure 4**.1*) consist
    of 16 columns and 2 rows of characters. They offer a simple interface for text-based
    information and are ideal for applications where concise textual data needs to
    be displayed, such as in industrial settings where they may be used to present
    vital information such as error messages or production counts. Additionally, these
    screens are often found in 3D printers and are used to display control information
    to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**8 x 8 dot-matrix display**: An 8 x 8 dot-matrix display (see *A* in *Figure
    4**.1*), consisting of 64 individual LEDs arranged in an 8x8 grid. This grid enables
    the creation of simple images, characters, or animations by controlling each LED
    independently. Large versions of these displays are frequently found in public
    information boards for scrolling text messages. Of note, this type of display
    is featured on the Raspberry Pi Sense HAT, a device we used in *Chapters 1* and
    *2*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**7-segment display**: A 7-segment display (see *E* in *Figure 4**.1*) consists
    of 7 or sometimes 8 individual segments (including a decimal point). This display
    can form the digit shapes for numbers and some letters by controlling which segments
    are illuminated. First invented in the early 20th century, 7-segment displays
    initially found use in devices such as calculators and digital clocks, and their
    application has since expanded with enhanced features such as improved brightness
    and energy efficiency, making them still relevant in modern digital clocks and
    industrial counters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Raspberry Pi 7-inch Touch Display** (see *A* in *Figure 4**.2*) is a
    versatile accessory for Raspberry Pi projects. This touchscreen seamlessly connects
    through the **DSI** (short for **Digital Serial Interface**) port, requiring no
    extra drivers for touch functionality, and has an 800 x 480-pixel resolution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3.5-inch** LCD screens (see *B* in *Figure 4**.2*) connect to the Raspberry
    Pi via the GPIO port. With a resolution of 320 x 480 pixels, this compact display
    offers solutions for handheld devices and IoT projects. These screens also come
    in 5-inch sizes, often connecting to the HDMI and GPIO ports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we understand the various screens we may use with the Raspberry Pi,
    it is time to focus on this chapter’s project: creating an IoT information display
    using the 7-inch Raspberry Pi touchscreen (see A in *Figure 4**.2*).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an IoT information display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As outlined at the beginning of this chapter, our IoT information display will
    display real-time weather forecasts and a traffic map.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will develop our IoT information display using the Raspberry Pi branded
    7-inch touchscreen installed in a compatible case with a mouse and keyboard connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Raspberry Pi development environment using a 7-inch touchscreen](img/B21282_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Raspberry Pi development environment using a 7-inch touchscreen
  prefs: []
  type: TYPE_NORMAL
- en: The key benefit of the Raspberry Pi branded 7-inch screen is its connection
    to the **MIPI** (short for **Mobile Industry Processor Interface**) port on the
    Raspberry Pi 5 and not the GPIO or HDMI ports. This ensures seamless integration,
    eliminating the need to download and install additional drivers for touch functionality.
    We will not be using the touch feature for this project.
  prefs: []
  type: TYPE_NORMAL
- en: Using our standard monitor
  prefs: []
  type: TYPE_NORMAL
- en: While the Raspberry Pi-branded 7-inch monitor offers impressive features, it
    is not essential for creating our IoT information display. We can utilize a standard
    monitor already connected to our Raspberry Pi. However, using a standard monitor
    may result in a large border around the display, as the positions of components
    in our code will be hardcoded.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.4* outlines the software architecture we will follow to create
    our IoT information display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Software architecture for the IoT information display](img/B21282_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Software architecture for the IoT information display
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `WeatherData` class to pull weather information from the `OpenWeatherMap`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: The `Dashboard` class centralizes display information for our application, and
    we will leverage the **Kivy** library to create the GUI. By displaying our GUI
    in fullscreen mode, we create a kiosk-like effect.
  prefs: []
  type: TYPE_NORMAL
- en: Just as we use the `WeatherData` class to make calls to the `OpenWeatherMap`
    API, we use the `TrafficMap` class to call the MapQuest Traffic API for traffic
    data. Unlike the `WeatherData` class, the `TrafficMap` class generates an image
    file representing traffic conditions using GPS coordinates. This visual depiction
    of traffic not only adds value to the information being presented but also serves
    as the focal point of our IoT information display.
  prefs: []
  type: TYPE_NORMAL
- en: We will start our coding by setting up our development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our development environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use a Python virtual environment for our development. As there are
    libraries that only work with the root installation of Python, we will use system
    packages in our Python virtual environment. To do so, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: On our Raspberry Pi 5, we open a Terminal application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To store our project files, we create a new directory with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then navigate to the new directory with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We require a subfolder for our project. We create this folder with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a new Python virtual environment for our project with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With our new Python virtual environment created, we source into it with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 4.5 – Terminal using dashboard-env environment](img/B21282_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Terminal using dashboard-env environment
  prefs: []
  type: TYPE_NORMAL
- en: 'We install the Python packages required for our code with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: exit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are now ready to load up Thonny. We do so by clicking on the **Menu** icon
    in the Raspberry Pi taskbar, navigating to the **Programming** category, and selecting
    **Thonny**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, Thonny uses the Raspberry Pi’s built-in version of Python. For our
    project, we will use the Python virtual environment we just created. To start,
    we need to view the project files by clicking on **View** and selecting **Files**
    if it is not already selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Files` section, we locate the `ch4-env` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then right-click on the folder and select the **Activate virtual** **environment**
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Activating a Python virtual environment in Thonny](img/B21282_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Activating a Python virtual environment in Thonny
  prefs: []
  type: TYPE_NORMAL
- en: With our project folder created, our Python virtual environment set up and activated,
    and the packages we need for our project installed, we may now start writing code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a WeatherData class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use a `WeatherData` class to encapsulate calls to the `OpenWeatherMap` API.
    In addition to temperature and weather conditions, the weather portion of our
    IoT information display shows a weather conditions icon as well as an attire image.
    In *Figure 4**.7*, we see images used for attire:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Attire images used in our IoT information display](img/B21282_04_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Attire images used in our IoT information display
  prefs: []
  type: TYPE_NORMAL
- en: The attire images should look familiar to us as we used the same ones when we
    created our weather indicator in [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048).
    With our IoT information display these graphics will be presented based on a factor
    determined by a calculation of temperature and wind speed.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll cover the `WeatherData` class code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: In Thonny, we create a new tab by selecting **File** and then **New** or by
    hitting *Ctrl* + *N* on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our code, we start by entering our imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then define our class name, `WeatherData`, and our class variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From here, we define our initialization method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then define the `get_temperature()` and `get_conditions()` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To accommodate the addition of a weather conditions icon, we add a method called
    `get_weather_conditions_icon()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method constructs and returns a URL using an f-string, a feature in Python
    that allows for embedded expressions inside string literals. By appending the
    value of `self.icon` to the base URL from OpenWeatherMap, (`f"http://openweathermap.org/img/wn/{self.icon}.png"`),
    it forms a complete URL that leads to a PNG image representing the current weather
    conditions, such as sunny, cloudy, or rainy. This will allow us to embed an icon
    representing the current weather conditions into our IoT information display.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To determine the attire image to display, we require two additional methods.
    The first method uses wind speed and temperature to return a factor appropriately
    called `wind_temp_factor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method calculates a wind temperature factor by first constraining the `self.temperature`
    value between `0` and `30` (assigning it to `temp_factor`), then dividing the
    wind speed by `20` (assigning it to `wind_factor`), and finally subtracting `wind_factor`
    from `temp_factor`, returning the resulting value as `wind_temp_factor`. These
    values are all arbitrary and may be changed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final method in our `WeatherData` class returns the image path for the
    attire image based on `wind_temp_factor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final part of our code sits outside the `WeatherMap` class and allows us
    to test the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We save our code as `WeatherData.py` inside the `IoTInformationDisplay` project
    subfolder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now prepared to construct a `TrafficMap` class, which will encapsulate
    the code used to create a map of local traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a TrafficMap class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We utilize a `TrafficMap` class to interface with the MapQuest API, enabling
    the generation of a traffic map for our application. To make the connection to
    the MapQuest API, we must first create an account and generate an API key.
  prefs: []
  type: TYPE_NORMAL
- en: Generating an API key for our application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MapQuest Developer offers various tools and services that enable developers
    to access maps, routing information, and more. For our project, we will need to
    obtain an API key from MapQuest to access their web services, particularly traffic
    map data. Here’s how to set up a free account and get the API key:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by navigating to the MapQuest Developer site ([https://developer.mapquest.com/plans](https://developer.mapquest.com/plans))
    to access the developer’s portal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For our application, the **MapQuestGo** plan will be sufficient. This plan will
    give us 15,000 starter transactions. To create a plan, we click on the **Subscribe**
    button and follow the steps outlined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once our profile is created, we may generate a new API key by going to the
    following URL: [https://developer.mapquest.com/user/me/apps](https://developer.mapquest.com/user/me/apps).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We click on the **Create a New Key** button and enter an app name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Creating a new API key in MapQuest Developer](img/B21282_04_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Creating a new API key in MapQuest Developer
  prefs: []
  type: TYPE_NORMAL
- en: 'A new API key will be generated, and it can be viewed under the **Managed**
    **Keys** section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Viewing API keys in MaqQuest Developer](img/B21282_04_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Viewing API keys in MaqQuest Developer
  prefs: []
  type: TYPE_NORMAL
- en: We will be using this key to call the MapQuest Traffic API. It is a good idea
    to copy and paste the API key into a text document that can be accessed later.
    With the API key generated, we may now create our `TrafficMap` class.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the TrafficMap class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We use Thonny to code our `TrafficMap` class:'
  prefs: []
  type: TYPE_NORMAL
- en: We launch Thonny by clicking on the **Menu** icon in the Raspberry Pi taskbar.
    Then, we navigate to the **Programming** category and select **Thonny**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once inside Thonny, we activate the `ch4-env` virtual environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a new tab by selecting **File** and then **New** or by hitting *Ctrl*
    + *N* on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our code, we start by entering our imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For our `TrafficMap` class, we only need to import the `requests` package.
    We define our class name, `TrafficMap`, and our initialization method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s look at what we just added:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`self.latitude`: Specifies the latitude of the location on the map, used to
    center the map at that latitude.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.longitude`: Specifies the longitude of the location on the map, used
    to center the map at that longitude.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.zoom`: Sets the zoom level for the map, controlling how much of the map
    is visible (for example, higher values might show a closer, more detailed view).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.size`: Sets a fixed size for the map, defining the width and height in
    pixels. The size is set as a string with dimensions of `"500,325"`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.api_key`: Stores a hardcoded API key, which is required to authenticate
    requests to the API.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the heart of our `TrafficMap` class is the `get_traffic_map()` method. We
    use this method to make the call to the MapQuest Traffic web service and use the
    response to create our traffic map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s look at what we just added:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`base_url`: The URL endpoint for the MapQuest static map API.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params`: We use this dictionary containing the necessary parameters for the
    API request:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.api_key`: Specifies the API key for authentication with the MapQuest
    static map API'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`center` – `f"{self.latitude},{self.longitude}"`: Defines the center of the
    map using the `latitude` and `longitude` attributes of the object'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.zoom`: Specifies the zoom level for the map, controlling the scale or
    detail visible on the map'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.size`: Sets the size of the map, using the previously defined size attribute
    of the object, likely defining the width and height in pixels'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`traffic: ''flow|cons|inc''`: Specifies the traffic information to be included
    on the map, representing different types of traffic data such as flow, congestion,
    and incidents'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response = requests.get(base_url, params=params)`: Sends a `GET` request to
    the URL stored in `base_url` with the parameters defined in `params` and stores
    the response in the `response` variable.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the request is successful (`response.status_code == 200`), the following
    happens:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An image file (`traffic_map.png`) is created or overwritten in the `images`
    directory.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The content of the response (which is image data) is written to the file.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The method returns the path to the saved image: `"images/traffic_map.png"`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the request is not successful, the method returns the path to a predefined
    `error.png` image in the `images` directory. This image contains an `Error loading
    traffic` `map` message.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The main takeaway from this method is that, unlike many API responses that require
    a JSON library to parse, the response from the `GET` request to the MapQuest Traffic
    API directly contains image data for the traffic map, so it can be saved as an
    image file without needing to parse JSON.
  prefs: []
  type: TYPE_NORMAL
- en: We save our code as `TrafficMap.py` inside the `IoTWeatherDisplay` project subfolder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the creation of the `WeatherData` and `TrafficMap` classes complete, we
    can now proceed to write a `Dashboard` class that will handle the display of information
    retrieved from these web services.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Dashboard and MyApp classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the `Dashboard` class, we use the Kivy library. Kivy is an open source Python
    framework designed for developing multitouch applications that can run on various
    platforms, including Windows, macOS, Linux, iOS, and Android.
  prefs: []
  type: TYPE_NORMAL
- en: In the same Python file where we define the Dashboard class, we will add a Kivy
    App class we call MyApp. The MyApp class in this code is a subclass of Kivy’s
    App class, defining the main entry point for the application by creating an instance
    of the Dashboard class in its build() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We launch Thonny by clicking on the **Menu** icon in the Raspberry Pi taskbar.
    Then, we navigate to the **Programming** category and select **Thonny**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once inside Thonny, we activate the `ch4-env` virtual environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a new tab by selecting **File** and then **New** or by hitting *Ctrl*
    + *N* on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We start our code by configuring Kivy to run in fullscreen and borderless mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Why do we configure our Kivy application before adding other imports?
  prefs: []
  type: TYPE_NORMAL
- en: We configure our application before importing other packages in Kivy to ensure
    that the settings are applied at the beginning of the application’s life cycle.
    If configuration were done after importing the packages, some settings might not
    be applied or could lead to unexpected behavior, as Kivy components might be initialized
    with the default configurations before the custom settings are set.
  prefs: []
  type: TYPE_NORMAL
- en: 'After configuration, we import the other packages we require for our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s look at what we just added:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`from kivy.app import App`: Imports the main application class from the Kivy
    framework, which is necessary for building and running the app.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from kivy.uix.floatlayout import FloatLayout`: Imports the `FloatLayout` class
    from Kivy, which allows for positioning and resizing of widgets in a free-form
    manner. We do this so that we may position our GUI components in exact locations
    on our screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from kivy.uix.label import Label`: Imports the `Label` class from Kivy, which
    is used to display text on the screen.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from kivy.uix.image import Image, AsyncImage`: Imports the `Image` and `AsyncImage`
    classes from Kivy, allowing for the display of both static and asynchronous images
    within the application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from kivy.clock import Clock`: Imports the `Clock` class from Kivy, enabling
    the scheduling of periodic functions within the app. We will be using this class
    to update our dashboard every 30 minutes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from WeatherData import WeatherData`: Imports our custom `WeatherData` class,
    which is used to handle weather-related information.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from TrafficMap import TrafficMap`: Imports the custom `TrafficMap` class,
    used to manage traffic map data and images.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After our imports, we define our `Dashboard` class and its initialization method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s look at what we just added:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our `Dashboard` class inherits from Kivy’s `FloatLayout` class, allowing positioning
    and layout features.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We initialize our class with specific parameters (`city`, `latitude`, `longitude`,
    and `zoom`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We call the `__init__()` method of the `FloatLayout` superclass through `super(Dashboard,
    self).__init__()`, ensuring proper initialization and inheriting behaviors from
    the parent class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then set up the traffic map with the given `latitude`, `longitude`, and `zoom`
    parameters.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We utilize Kivy’s `Clock` class to schedule regular updates every `1800` seconds
    (`30` minutes).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We call the `self.init_widgets()` method to create and position widgets inside
    the layout.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then call `self.update_status(0)` once during initialization to set the initial
    state of the dashboard. If this method was not called, the initial state of the
    dashboard might not be set, possibly leading to a delay in displaying the initial
    content until the scheduled update occurs, which is set to happen every `1800`
    seconds or `30` minutes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the initialization of the class in place, we initialize the state of the
    widgets. We start with the `Temperature`, `Conditions`, and `Attire` widgets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then add a `city` field, weather conditions, and a traffic map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `init_widgets()` method is responsible for initializing and adding both
    static and dynamic widgets to the `Dashboard` layout, which is a subclass of Kivy’s
    `FloatLayout` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Static widgets are components that remain the same throughout the life cycle
    of the application and don’t need to be updated dynamically. This includes adding
    labels displaying Temperature, Conditions, and Attire text at specified positions
    with specific colors, font sizes, and fonts. It also includes three image widgets
    displaying an image located at ‘images/box.png’, placed at different positions
    on the layout.
  prefs: []
  type: TYPE_NORMAL
- en: '`AsyncImage` widget to display a weather conditions icon, a label for displaying
    weather conditions text, another `AsyncImage` widget to display a traffic map,
    and an image widget to display appropriate attire for the current weather conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: The `init_widgets()` method leverages the `add_widget()` method provided by
    Kivy’s `FloatLayout` classto add each widget to the layout. The dynamic widgets
    are also stored as attributes of the `Dashboard` class so that they can be easily
    accessed and updated later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `update_status()` method of the `Dashboard` class to provide new
    values for our screen every `30` minutes (as set in the initialization method):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `update_status()` method within the `Dashboard` class plays a major role
    in updating the dynamic widgets to reflect current data. Initially, it creates
    an instance of the `WeatherData` class using the current city. The method then
    proceeds to update the source of the `traffic_map_image` widget with a new traffic
    map image reflecting current conditions, obtained from the `get_traffic_map()`
    method of the `TrafficMap` class. It also changes the source of the `attire_image`
    widget to represent suitable clothing for the current weather, utilizing the `get_attire_image()`
    method of the `WeatherData` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The temperature label’s text is updated with the current temperature from the
    `WeatherData` class, appending the degree symbol and the letter *C* to represent
    Celsius. The text of the `weather_conditions_label` widget is modified to provide
    a description of the present weather conditions, also obtained from the `WeatherData`
    class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, the source of the `conditions_image` widget is updated with an icon
    that symbolizes the current weather conditions, using the `get_weather_conditions_icon()`
    method from the `WeatherData` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Having completed our `Dashboard` class, we’ll next develop the `MyApp` class.
    This class will serve as the entry point for our Kivy application, handling both
    the initialization and management of the dashboard interface. We’ll create this
    class immediately following the `Dashboard` class in the same file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `MyApp` class is inherited from Kivy’s `App` class and is responsible for
    initializing and running the main application. Within the `build()` method of
    `MyApp`, the city of `Toronto`, along with its corresponding latitude and longitude
    coordinates (`43.6426` and `-79.3871`), and zoom level are specified. These GPS
    coordinates point to the location in Toronto (downtown Toronto near the CN Tower).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A `Dashboard` object is then created and returned with these parameters. The
    `if __name__ == '__main__':` line ensures that the code following it is only executed
    if the script is being run directly (not imported as a module in another script).
    When run directly, it creates an instance of the `MyApp` class and calls its `run()`
    method, starting the Kivy application and displaying the initialized dashboard
    with specified details related to Toronto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We save our code as `Dashboard.py` inside the `IoTWeatherDisplay` project subfolder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With all this code written, it is time to run it on our 7-inch screen.
  prefs: []
  type: TYPE_NORMAL
- en: Running the IoT information display application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute our IoT information display through the `Dashboard.py` script, we
    use Thonny. We can either click on the green run button and hit *F5* on the keyboard
    or click on the **Run** menu option at the top and then **Run** **current script**.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all the aforementioned code entered without errors (or cloned from the
    GitHub repository at [https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter4](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter4)),
    we should see our IoT information display run full screen on our 7-inch monitor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – IoT information display showing weather and traffic for Toronto,
    Canada](img/B21282_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – IoT information display showing weather and traffic for Toronto,
    Canada
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, it is a relatively warm day in Toronto. In terms of traffic flow,
    there is construction and other areas to avoid. The weather is clear, and it is
    suggested we wear short-sleeved shirts today. If we were to run this on a standard
    computer monitor, we may see a large black border around our display.
  prefs: []
  type: TYPE_NORMAL
- en: In a specific application such as creating an IoT information display, the mouse
    and keyboard can be removed from the Raspberry Pi, allowing the device to be used
    as a kiosk with a 7-inch touchscreen.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored various small screens compatible with the Raspberry
    Pi. We then used Raspberry Pi’s 7-inch touchscreen to create a versatile IoT information
    display that included weather forecasts and traffic maps for a specific city.
  prefs: []
  type: TYPE_NORMAL
- en: By utilizing and optimizing web service data, we demonstrated the flexibility
    of Raspberry Pi in handling complex information display tasks. The principles
    and code developed in this chapter can be adapted for other uses, such as home
    automation dashboards, public information kiosks, or industrial monitoring systems
    for manufacturing processes.
  prefs: []
  type: TYPE_NORMAL
- en: We have focused primarily on displaying information – in particular, weather
    information via web services – over the last few chapters. In the next chapter,
    we will start exploring sensory information with our Raspberry Pi as we work toward
    building an IoT security application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Building an IoT Home Security Dashboard'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Part 2*, we explore the general-purpose input/output (GPIO) ports on the
    Raspberry Pi and Raspberry Pi Pico, build an IoT alarm module with a Raspberry
    Pi Pico W and a PIR motion sensor, create an IoT button using the M5Stack ATOM
    Matrix and Raspberry Pi Pico W, and develop an IoT alarm dashboard on a Raspberry
    Pi 5 with a 7-inch touchscreen for control and monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B21282_05.xhtml#_idTextAnchor080), *Exploring the GPIO*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21282_06.xhtml#_idTextAnchor091), *Building an IoT Alarm Module*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21282_07.xhtml#_idTextAnchor107), *Building an IoT Button*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21282_08.xhtml#_idTextAnchor125), *Creating an IoT Alarm Dashboard*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
