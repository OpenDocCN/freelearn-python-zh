- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Building an IoT Information Display
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建物联网信息显示屏
- en: In this chapter, we will build an IoT information display using a Raspberry
    Pi-branded 7-inch touchscreen. We will use this information display to show real-time
    weather information and local traffic information.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用带有树莓派品牌7英寸触摸屏的设备构建一个物联网信息显示屏。我们将使用这个信息显示屏来显示实时天气信息和当地交通信息。
- en: We will start the chapter by exploring screens compatible for use with our Raspberry
    Pi. We will look at small **Organic Light-Emitting Diode** (**OLED**) screens,
    dot-matrix displays, seven-segment displays, and small LCD monitors for the Raspberry
    Pi.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从探索与我们的树莓派兼容的屏幕开始本章。我们将查看小型**有机发光二极管**（**OLED**）屏幕、点阵显示器、七段显示器和树莓派的小型LCD显示器。
- en: For our project, we will build an IoT information display with Raspberry Pi’s
    7-inch touchscreen. This *dashboard* will not only show weather details but will
    also feature a map depicting local traffic conditions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们将使用树莓派的7英寸触摸屏构建一个物联网信息显示屏。这个*仪表盘*不仅会显示天气详情，还会展示描绘当地交通状况的地图。
- en: The insights gained in this chapter will equip us with a versatile toolkit,
    fostering creativity and innovation in future Raspberry Pi and IoT projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中获得的知识将为我们提供一套多功能工具箱，促进未来树莓派和物联网项目中的创造力和创新。
- en: 'The following are the topics we will cover:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Investigating displays compatible with our Raspberry Pi and exploring screen
    types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调研与我们的树莓派兼容的显示屏，并探索屏幕类型
- en: Creating an IoT information display
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个物联网信息显示屏
- en: Let’s begin!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the requirements for completing this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章所需的以下要求：
- en: Intermediate knowledge of Python programming
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具备中级Python编程知识
- en: A late-model Raspberry Pi, preferably a Raspberry Pi 5 with at least 4 GB of
    RAM
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台较新的树莓派，最好是带有至少4GB RAM的树莓派5
- en: A Raspberry Pi branded 7-inch touchscreen with a compatible case (optional)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有兼容壳体的树莓派品牌7英寸触摸屏（可选）
- en: 'The code for this chapter may be found here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到：
- en: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter4](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter4%0D)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter4](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter4%0D)'
- en: Investigating displays compatible with our Raspberry Pi and exploring screen
    types
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调研与我们的树莓派兼容的显示屏，并探索屏幕类型
- en: 'Raspberry Pi offers the flexibility to interface with various external screens,
    catering to different applications and requirements. In *Figure 4**.1*, we see
    examples of small screens that we may hook up to our Raspberry Pi:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派提供了与各种外部屏幕接口的灵活性，满足不同的应用和需求。在图4.1中，我们看到我们可以连接到树莓派的小型显示屏示例：
- en: '![Figure 4.1 – Small displays that may be used with the Raspberry Pi](img/B21282_04_1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 可与树莓派一起使用的小型显示屏](img/B21282_04_1.jpg)'
- en: Figure 4.1 – Small displays that may be used with the Raspberry Pi
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 可与树莓派一起使用的小型显示屏
- en: '*Figure 4**.1* shows different small screens tailored for various uses: OLED
    screens (*B*, *C*, *D*) for fine detail; a 16 x 2 LCD (*F*) for concise text;
    and dot-matrix (*A*) and segment-style displays (*E*) for clear numbers and characters.
    These options offer a versatile range of visual representations.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.1*展示了针对不同用途定制的小型显示屏：用于精细细节的OLED屏幕（*B*、*C*、*D*）；用于简洁文本的16 x 2 LCD（*F*）；以及用于清晰数字和字符的点阵（*A*）和段式显示（*E*）。这些选项提供了一系列灵活的视觉表示。'
- en: 'There are several larger screen options for the Raspberry Pi, including standard
    4K computer monitors, as well as smaller monitor-style screens, as we see in *Figure
    4**.2*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派有几种更大的屏幕选项，包括标准的4K计算机显示器，以及我们图4.2-2中看到的小型显示器：
- en: '![Figure 4.2 – Encased Raspberry Pi’s 7-inch touchscreen (A) and 3.5-inch LCD
    screen (B)](img/B21282_04_2.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 封装的树莓派7英寸触摸屏（A）和3.5英寸LCD屏幕（B）](img/B21282_04_2.jpg)'
- en: Figure 4.2 – Encased Raspberry Pi’s 7-inch touchscreen (A) and 3.5-inch LCD
    screen (B)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 封装的树莓派7英寸触摸屏（A）和3.5英寸LCD屏幕（B）
- en: The screen in *Figure 4**.2* *A* is the Raspberry Pi branded 7-inch touchscreen.
    It is shown here in a case specifically designed to house it. In *Figure 4**.2*
    *B*, we see a 3.5-inch LCD screen that connects to the GPIO port of the Raspberry
    Pi.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2-1*中的屏幕是树莓派品牌的7英寸触摸屏。它在这里展示在一个专门为其设计的壳体中。在图4.2-2*中，我们看到一个3.5英寸的LCD屏幕，它连接到树莓派的GPIO端口。
- en: Let’s take a closer look at each type of screen to understand their unique characteristics
    and applications.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看每种类型的屏幕，以了解它们的独特特性和应用。
- en: 'Each screen shown in *Figure 4**.1* and *Figure 4**.2* offers unique advantages
    for specific applications, and understanding these can enhance our Raspberry Pi
    projects. The following are descriptions of each screen/display:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图4.1*和*图4.2*中展示的每个屏幕都为特定应用提供了独特的优势，理解这些优势可以增强我们的树莓派项目。以下是对每个屏幕/显示器的描述：
- en: '**Small OLED screens**: OLED screens (see *B*, *C*, and *D* in *Figure 4**.1*)
    are known for their crisp detail and energy efficiency. Small OLED screens (0\.
    to 1.3 inches) are commonly used in projects that require minimal space and low
    power consumption.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小型OLED屏幕**：OLED屏幕（见*图4.1*中的*B*、*C*和*D*）以其清晰的细节和能效著称。小型OLED屏幕（0.到1.3英寸）常用于需要最小空间和低功耗的项目。'
- en: OLED screens are used to display system status or in small gadgets such as fitness
    trackers. Ideal for showing limited information such as icons, temperature, or
    time, their compact size and energy efficiency make them a perfect choice for
    clear, concise displays without using much power or space.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: OLED屏幕用于显示系统状态或在小型设备如健身追踪器中。它们非常适合显示有限的信息，如图标、温度或时间，其紧凑的尺寸和能效使它们成为在无需过多功耗或空间的情况下进行清晰、简洁显示的理想选择。
- en: '**16 x 2 LCD screens**: 16 x 2 LCD screens (see *F* in *Figure 4**.1*) consist
    of 16 columns and 2 rows of characters. They offer a simple interface for text-based
    information and are ideal for applications where concise textual data needs to
    be displayed, such as in industrial settings where they may be used to present
    vital information such as error messages or production counts. Additionally, these
    screens are often found in 3D printers and are used to display control information
    to the user.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**16 x 2液晶显示屏**：16 x 2液晶显示屏（见*图4.1*中的*F*）由16列和2行的字符组成。它们提供了一个简单的界面来显示基于文本的信息，非常适合需要显示简洁文本数据的应用，例如在工业环境中，它们可能用于显示错误信息或生产计数等关键信息。此外，这些屏幕也常用于3D打印机，用于向用户显示控制信息。'
- en: '**8 x 8 dot-matrix display**: An 8 x 8 dot-matrix display (see *A* in *Figure
    4**.1*), consisting of 64 individual LEDs arranged in an 8x8 grid. This grid enables
    the creation of simple images, characters, or animations by controlling each LED
    independently. Large versions of these displays are frequently found in public
    information boards for scrolling text messages. Of note, this type of display
    is featured on the Raspberry Pi Sense HAT, a device we used in *Chapters 1* and
    *2*.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**8 x 8点阵显示器**：8 x 8点阵显示器（见*图4.1*中的*A*），由64个独立LED组成，排列成8x8的网格。通过独立控制每个LED，这个网格可以创建简单的图像、字符或动画。这种显示器的较大版本常用于公共信息板上的滚动文字。值得注意的是，这种类型的显示器出现在我们第1章和第2章中使用的树莓派Sense
    HAT设备上。'
- en: '**7-segment display**: A 7-segment display (see *E* in *Figure 4**.1*) consists
    of 7 or sometimes 8 individual segments (including a decimal point). This display
    can form the digit shapes for numbers and some letters by controlling which segments
    are illuminated. First invented in the early 20th century, 7-segment displays
    initially found use in devices such as calculators and digital clocks, and their
    application has since expanded with enhanced features such as improved brightness
    and energy efficiency, making them still relevant in modern digital clocks and
    industrial counters.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**七段显示器**：七段显示器（见*图4.1*中的*E*）由7个或有时8个单独的段（包括小数点）组成。通过控制哪些段被点亮，这种显示器可以形成数字和某些字母的形状。这种显示器最早在20世纪初发明，最初用于计算器、数字时钟等设备，随着亮度、能效等功能的提升，其应用范围也得以扩大，使得它们在现代数字时钟和工业计数器中仍然具有相关性。'
- en: '**The Raspberry Pi 7-inch Touch Display** (see *A* in *Figure 4**.2*) is a
    versatile accessory for Raspberry Pi projects. This touchscreen seamlessly connects
    through the **DSI** (short for **Digital Serial Interface**) port, requiring no
    extra drivers for touch functionality, and has an 800 x 480-pixel resolution.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树莓派7英寸触摸显示屏**（见*图4.2*中的*A*）是树莓派项目的多功能附件。这款触摸屏通过**DSI**（即**数字串行接口**）端口无缝连接，无需额外的驱动程序即可实现触摸功能，分辨率为800
    x 480像素。'
- en: '**3.5-inch** LCD screens (see *B* in *Figure 4**.2*) connect to the Raspberry
    Pi via the GPIO port. With a resolution of 320 x 480 pixels, this compact display
    offers solutions for handheld devices and IoT projects. These screens also come
    in 5-inch sizes, often connecting to the HDMI and GPIO ports.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3.5英寸**液晶显示屏（见*图4.2*中的B）通过GPIO端口连接到树莓派。分辨率为320 x 480像素，这款紧凑型显示屏为手持设备和物联网项目提供了解决方案。这些屏幕也提供5英寸尺寸，通常连接到HDMI和GPIO端口。'
- en: 'Now that we understand the various screens we may use with the Raspberry Pi,
    it is time to focus on this chapter’s project: creating an IoT information display
    using the 7-inch Raspberry Pi touchscreen (see A in *Figure 4**.2*).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了可以与树莓派一起使用的各种屏幕，是时候专注于本章的项目了：使用7英寸树莓派触摸屏（见*图4.2*中的A）创建物联网信息显示。
- en: Creating an IoT information display
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建物联网信息显示
- en: As outlined at the beginning of this chapter, our IoT information display will
    display real-time weather forecasts and a traffic map.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，我们的物联网信息显示将显示实时天气预报和交通地图。
- en: 'We will develop our IoT information display using the Raspberry Pi branded
    7-inch touchscreen installed in a compatible case with a mouse and keyboard connected:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用安装在兼容外壳中的带有鼠标和键盘的树莓派品牌7英寸触摸屏来开发我们的物联网信息显示：
- en: '![Figure 4.3 – Raspberry Pi development environment using a 7-inch touchscreen](img/B21282_04_3.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 使用7英寸触摸屏的树莓派开发环境](img/B21282_04_3.jpg)'
- en: Figure 4.3 – Raspberry Pi development environment using a 7-inch touchscreen
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 使用7英寸触摸屏的树莓派开发环境
- en: The key benefit of the Raspberry Pi branded 7-inch screen is its connection
    to the **MIPI** (short for **Mobile Industry Processor Interface**) port on the
    Raspberry Pi 5 and not the GPIO or HDMI ports. This ensures seamless integration,
    eliminating the need to download and install additional drivers for touch functionality.
    We will not be using the touch feature for this project.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派品牌7英寸屏幕的关键优势是它与树莓派5上的**MIPI**（即**移动行业处理器接口**）端口相连，而不是GPIO或HDMI端口。这确保了无缝集成，消除了下载和安装用于触摸功能的额外驱动程序的需求。我们不会在这个项目中使用触摸功能。
- en: Using our standard monitor
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的标准显示器
- en: While the Raspberry Pi-branded 7-inch monitor offers impressive features, it
    is not essential for creating our IoT information display. We can utilize a standard
    monitor already connected to our Raspberry Pi. However, using a standard monitor
    may result in a large border around the display, as the positions of components
    in our code will be hardcoded.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这款带有树莓派品牌的7英寸显示器提供了令人印象深刻的特性，但它对于创建我们的物联网信息显示并非必需。我们可以利用已经连接到我们的树莓派的普通显示器。然而，使用普通显示器可能会导致显示周围出现大边框，因为我们的代码中组件的位置是硬编码的。
- en: '*Figure 4**.4* outlines the software architecture we will follow to create
    our IoT information display:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.4*概述了我们创建物联网信息显示时将遵循的软件架构：'
- en: '![Figure 4.4 – Software architecture for the IoT information display](img/B21282_04_4.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 物联网信息显示的软件架构](img/B21282_04_4.jpg)'
- en: Figure 4.4 – Software architecture for the IoT information display
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 物联网信息显示的软件架构
- en: We will use the `WeatherData` class to pull weather information from the `OpenWeatherMap`
    API.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`WeatherData`类从`OpenWeatherMap` API中提取天气信息。
- en: The `Dashboard` class centralizes display information for our application, and
    we will leverage the **Kivy** library to create the GUI. By displaying our GUI
    in fullscreen mode, we create a kiosk-like effect.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dashboard`类集中了应用程序的显示信息，我们将利用**Kivy**库来创建GUI。通过全屏模式显示我们的GUI，我们创建了一个类似信息亭的效果。'
- en: Just as we use the `WeatherData` class to make calls to the `OpenWeatherMap`
    API, we use the `TrafficMap` class to call the MapQuest Traffic API for traffic
    data. Unlike the `WeatherData` class, the `TrafficMap` class generates an image
    file representing traffic conditions using GPS coordinates. This visual depiction
    of traffic not only adds value to the information being presented but also serves
    as the focal point of our IoT information display.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们使用`WeatherData`类调用`OpenWeatherMap` API一样，我们使用`TrafficMap`类调用MapQuest Traffic
    API以获取交通数据。与`WeatherData`类不同，`TrafficMap`类使用GPS坐标生成表示交通状况的图像文件。这种交通的视觉表示不仅增加了所提供信息的价值，而且也成为了我们物联网信息显示的焦点。
- en: We will start our coding by setting up our development environment.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置我们的开发环境来开始编码。
- en: Setting up our development environment
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的开发环境
- en: 'We will use a Python virtual environment for our development. As there are
    libraries that only work with the root installation of Python, we will use system
    packages in our Python virtual environment. To do so, we do the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的开发使用Python虚拟环境。由于有些库只与Python的根安装兼容，我们将在Python虚拟环境中使用系统包。为此，我们需要执行以下操作：
- en: On our Raspberry Pi 5, we open a Terminal application.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Raspberry Pi 5上，我们打开一个终端应用程序。
- en: 'To store our project files, we create a new directory with the following command:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了存储我们的项目文件，我们使用以下命令创建一个新的目录：
- en: '[PRE0]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then navigate to the new directory with the following command:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后使用以下命令导航到新目录：
- en: '[PRE1]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We require a subfolder for our project. We create this folder with the following
    command:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个子目录来存放我们的项目。我们使用以下命令创建此文件夹：
- en: '[PRE2]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We create a new Python virtual environment for our project with the following
    command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下命令为我们的项目创建一个新的Python虚拟环境：
- en: '[PRE3]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With our new Python virtual environment created, we source into it with the
    following command:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们创建新的Python虚拟环境后，我们使用以下命令将其源代码导入：
- en: '[PRE4]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Figure 4.5 – Terminal using dashboard-env environment](img/B21282_04_5.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 使用dashboard-env环境的终端](img/B21282_04_5.jpg)'
- en: Figure 4.5 – Terminal using dashboard-env environment
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 使用dashboard-env环境的终端
- en: 'We install the Python packages required for our code with the following command:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下命令安装代码所需的Python包：
- en: '[PRE5]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: exit
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 退出
- en: '[PRE6]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are now ready to load up Thonny. We do so by clicking on the **Menu** icon
    in the Raspberry Pi taskbar, navigating to the **Programming** category, and selecting
    **Thonny**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备好加载Thonny。我们通过点击树莓派任务栏中的**菜单**图标，导航到**编程**类别，并选择**Thonny**来完成。
- en: By default, Thonny uses the Raspberry Pi’s built-in version of Python. For our
    project, we will use the Python virtual environment we just created. To start,
    we need to view the project files by clicking on **View** and selecting **Files**
    if it is not already selected.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Thonny使用树莓派内置的Python版本。对于我们的项目，我们将使用我们刚刚创建的Python虚拟环境。首先，我们需要通过点击**查看**并选择**文件**（如果尚未选择）来查看项目文件。
- en: In the `Files` section, we locate the `ch4-env` directory.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“文件”部分，我们定位到`ch4-env`目录。
- en: 'We then right-click on the folder and select the **Activate virtual** **environment**
    option:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们右键单击文件夹并选择**激活虚拟环境**选项：
- en: '![Figure 4.6 – Activating a Python virtual environment in Thonny](img/B21282_04_6.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 在Thonny中激活Python虚拟环境](img/B21282_04_6.jpg)'
- en: Figure 4.6 – Activating a Python virtual environment in Thonny
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 在Thonny中激活Python虚拟环境
- en: With our project folder created, our Python virtual environment set up and activated,
    and the packages we need for our project installed, we may now start writing code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目文件夹创建、Python虚拟环境设置并激活，以及安装了项目所需的包之后，我们现在可以开始编写代码。
- en: Creating a WeatherData class
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个WeatherData类
- en: 'We use a `WeatherData` class to encapsulate calls to the `OpenWeatherMap` API.
    In addition to temperature and weather conditions, the weather portion of our
    IoT information display shows a weather conditions icon as well as an attire image.
    In *Figure 4**.7*, we see images used for attire:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个`WeatherData`类来封装对`OpenWeatherMap` API的调用。除了温度和天气状况，我们物联网信息显示的天气部分还显示天气状况图标以及着装图像。在*图4**.7中，我们看到用于着装的图像：
- en: '![Figure 4.7 – Attire images used in our IoT information display](img/B21282_04_7.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 我们物联网信息显示中使用的着装图像](img/B21282_04_7.jpg)'
- en: Figure 4.7 – Attire images used in our IoT information display
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 我们物联网信息显示中使用的着装图像
- en: The attire images should look familiar to us as we used the same ones when we
    created our weather indicator in [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048).
    With our IoT information display these graphics will be presented based on a factor
    determined by a calculation of temperature and wind speed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 着装图像应该对我们很熟悉，因为我们创建天气指示器时使用了相同的图像。[*第3章*](B21282_03.xhtml#_idTextAnchor048)。在我们的物联网信息显示中，这些图形将根据温度和风速的计算结果确定的因子来展示。
- en: In this section, we’ll cover the `WeatherData` class code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍`WeatherData`类的代码。
- en: 'So, let’s get started:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧：
- en: In Thonny, we create a new tab by selecting **File** and then **New** or by
    hitting *Ctrl* + *N* on the keyboard.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Thonny中，我们通过选择**文件**然后**新建**或按键盘上的*Ctrl* + *N*来创建一个新的标签页。
- en: 'In our code, we start by entering our imports:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们首先输入我们的导入语句：
- en: '[PRE7]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then define our class name, `WeatherData`, and our class variables:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后定义我们的类名，`WeatherData`，以及我们的类变量：
- en: '[PRE8]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'From here, we define our initialization method:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，我们定义我们的初始化方法：
- en: '[PRE9]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then define the `get_temperature()` and `get_conditions()` methods:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后定义 `get_temperature()` 和 `get_conditions()` 方法：
- en: '[PRE10]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To accommodate the addition of a weather conditions icon, we add a method called
    `get_weather_conditions_icon()`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了适应添加天气状况图标，我们添加了一个名为 `get_weather_conditions_icon()` 的方法：
- en: '[PRE11]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This method constructs and returns a URL using an f-string, a feature in Python
    that allows for embedded expressions inside string literals. By appending the
    value of `self.icon` to the base URL from OpenWeatherMap, (`f"http://openweathermap.org/img/wn/{self.icon}.png"`),
    it forms a complete URL that leads to a PNG image representing the current weather
    conditions, such as sunny, cloudy, or rainy. This will allow us to embed an icon
    representing the current weather conditions into our IoT information display.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法使用 f-string 构建并返回一个 URL，这是 Python 中的一种特性，允许在字符串字面量中嵌入表达式。通过将 `self.icon`
    的值附加到 OpenWeatherMap 的基本 URL（`f"http://openweathermap.org/img/wn/{self.icon}.png"`），它形成了一个完整的
    URL，该 URL 领向一个代表当前天气状况（如晴朗、多云或雨天）的 PNG 图像。这将使我们能够将代表当前天气状况的图标嵌入到我们的物联网信息显示中。
- en: 'To determine the attire image to display, we require two additional methods.
    The first method uses wind speed and temperature to return a factor appropriately
    called `wind_temp_factor`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确定要显示的服装图像，我们需要两个额外的函数。第一个函数使用风速和温度返回一个适当称为 `wind_temp_factor` 的因子：
- en: '[PRE12]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This method calculates a wind temperature factor by first constraining the `self.temperature`
    value between `0` and `30` (assigning it to `temp_factor`), then dividing the
    wind speed by `20` (assigning it to `wind_factor`), and finally subtracting `wind_factor`
    from `temp_factor`, returning the resulting value as `wind_temp_factor`. These
    values are all arbitrary and may be changed.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法首先将 `self.temperature` 值限制在 `0` 到 `30` 之间（将其分配给 `temp_factor`），然后除以风速 `20`（将其分配给
    `wind_factor`），最后从 `temp_factor` 中减去 `wind_factor`，将结果值作为 `wind_temp_factor` 返回。这些值都是任意的，可能需要更改。
- en: 'The final method in our `WeatherData` class returns the image path for the
    attire image based on `wind_temp_factor`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们 `WeatherData` 类中的最后一个方法根据 `wind_temp_factor` 返回服装图像的路径：
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The final part of our code sits outside the `WeatherMap` class and allows us
    to test the class:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们代码的最后一部分位于 `WeatherMap` 类外部，使我们能够测试该类：
- en: '[PRE14]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We save our code as `WeatherData.py` inside the `IoTInformationDisplay` project
    subfolder.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将代码保存为 `WeatherData.py`，位于 `IoTInformationDisplay` 项目子文件夹中。
- en: We are now prepared to construct a `TrafficMap` class, which will encapsulate
    the code used to create a map of local traffic.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备构建一个 `TrafficMap` 类，该类将封装创建本地交通地图的代码。
- en: Creating a TrafficMap class
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 `TrafficMap` 类
- en: We utilize a `TrafficMap` class to interface with the MapQuest API, enabling
    the generation of a traffic map for our application. To make the connection to
    the MapQuest API, we must first create an account and generate an API key.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `TrafficMap` 类与 MapQuest API 进行接口，使我们的应用程序能够生成交通地图。为了连接到 MapQuest API，我们首先需要创建一个账户并生成一个
    API 密钥。
- en: Generating an API key for our application
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为我们的应用程序生成 API 密钥
- en: 'MapQuest Developer offers various tools and services that enable developers
    to access maps, routing information, and more. For our project, we will need to
    obtain an API key from MapQuest to access their web services, particularly traffic
    map data. Here’s how to set up a free account and get the API key:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: MapQuest 开发者提供各种工具和服务，使开发者能够访问地图、路线信息等。对于我们项目，我们需要从 MapQuest 获取一个 API 密钥以访问他们的网络服务，特别是交通地图数据。以下是设置免费账户和获取
    API 密钥的步骤：
- en: We start by navigating to the MapQuest Developer site ([https://developer.mapquest.com/plans](https://developer.mapquest.com/plans))
    to access the developer’s portal.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导航到 MapQuest 开发者网站 ([https://developer.mapquest.com/plans](https://developer.mapquest.com/plans))
    以访问开发者门户。
- en: For our application, the **MapQuestGo** plan will be sufficient. This plan will
    give us 15,000 starter transactions. To create a plan, we click on the **Subscribe**
    button and follow the steps outlined.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，**MapQuestGo** 计划就足够了。此计划将为我们提供 15,000 个起始交易。要创建一个计划，我们点击 **订阅** 按钮，并按照概述的步骤进行。
- en: 'Once our profile is created, we may generate a new API key by going to the
    following URL: [https://developer.mapquest.com/user/me/apps](https://developer.mapquest.com/user/me/apps).'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们的个人资料创建完成，我们可以通过访问以下 URL 生成一个新的 API 密钥：[https://developer.mapquest.com/user/me/apps](https://developer.mapquest.com/user/me/apps)。
- en: 'We click on the **Create a New Key** button and enter an app name:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们点击 **创建新密钥** 按钮，并输入应用程序名称：
- en: '![Figure 4.8 – Creating a new API key in MapQuest Developer](img/B21282_04_8.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 在 MapQuest 开发者中创建新的 API 密钥](img/B21282_04_8.jpg)'
- en: Figure 4.8 – Creating a new API key in MapQuest Developer
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 在 MapQuest 开发者中创建新的 API 密钥
- en: 'A new API key will be generated, and it can be viewed under the **Managed**
    **Keys** section:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成一个新的 API 密钥，可以在 **管理** **密钥** 部分查看：
- en: '![Figure 4.9 – Viewing API keys in MaqQuest Developer](img/B21282_04_9.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 在 MaqQuest 开发者中查看 API 密钥](img/B21282_04_9.jpg)'
- en: Figure 4.9 – Viewing API keys in MaqQuest Developer
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 在 MaqQuest 开发者中查看 API 密钥
- en: We will be using this key to call the MapQuest Traffic API. It is a good idea
    to copy and paste the API key into a text document that can be accessed later.
    With the API key generated, we may now create our `TrafficMap` class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用此密钥调用 MapQuest 交通 API。将 API 密钥复制并粘贴到可以稍后访问的文本文档中是个好主意。生成 API 密钥后，我们现在可以创建我们的
    `TrafficMap` 类。
- en: Coding the TrafficMap class
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 TrafficMap 类
- en: 'We use Thonny to code our `TrafficMap` class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Thonny 编写 `TrafficMap` 类：
- en: We launch Thonny by clicking on the **Menu** icon in the Raspberry Pi taskbar.
    Then, we navigate to the **Programming** category and select **Thonny**.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过点击树莓派任务栏中的 **菜单** 图标来启动 Thonny。然后，我们导航到 **编程** 类别并选择 **Thonny**。
- en: Once inside Thonny, we activate the `ch4-env` virtual environment.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入 Thonny，我们激活 `ch4-env` 虚拟环境。
- en: We create a new tab by selecting **File** and then **New** or by hitting *Ctrl*
    + *N* on the keyboard.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过选择 **文件** 然后选择 **新建** 或按键盘上的 *Ctrl* + *N* 创建一个新的标签页。
- en: 'In our code, we start by entering our imports:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们首先输入我们的导入：
- en: '[PRE15]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For our `TrafficMap` class, we only need to import the `requests` package.
    We define our class name, `TrafficMap`, and our initialization method:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的 `TrafficMap` 类，我们只需要导入 `requests` 包。我们定义我们的类名 `TrafficMap` 和我们的初始化方法：
- en: '[PRE16]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s look at what we just added:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看我们刚刚添加的内容：
- en: '`self.latitude`: Specifies the latitude of the location on the map, used to
    center the map at that latitude.'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.latitude`: 指定地图上位置的纬度，用于将地图中心定位在该纬度。'
- en: '`self.longitude`: Specifies the longitude of the location on the map, used
    to center the map at that longitude.'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.longitude`: 指定地图上位置的经度，用于将地图中心定位在该经度。'
- en: '`self.zoom`: Sets the zoom level for the map, controlling how much of the map
    is visible (for example, higher values might show a closer, more detailed view).'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.zoom`: 设置地图的缩放级别，控制地图上可见的区域大小（例如，较高的值可能显示更近、更详细的视图）。'
- en: '`self.size`: Sets a fixed size for the map, defining the width and height in
    pixels. The size is set as a string with dimensions of `"500,325"`.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.size`: 设置地图的固定大小，定义像素宽度和高度。大小设置为 `"500,325"` 的字符串。'
- en: '`self.api_key`: Stores a hardcoded API key, which is required to authenticate
    requests to the API.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.api_key`: 存储硬编码的 API 密钥，这是对 API 进行身份验证所必需的。'
- en: 'At the heart of our `TrafficMap` class is the `get_traffic_map()` method. We
    use this method to make the call to the MapQuest Traffic web service and use the
    response to create our traffic map:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们 `TrafficMap` 类的核心是 `get_traffic_map()` 方法。我们使用此方法调用 MapQuest 交通网络服务，并使用响应创建我们的交通地图：
- en: '[PRE17]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s look at what we just added:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看我们刚刚添加的内容：
- en: '`base_url`: The URL endpoint for the MapQuest static map API.'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base_url`: MapQuest 静态地图 API 的 URL 端点。'
- en: '`params`: We use this dictionary containing the necessary parameters for the
    API request:'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params`: 我们使用这个包含 API 请求必要参数的字典：'
- en: '`self.api_key`: Specifies the API key for authentication with the MapQuest
    static map API'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.api_key`: 指定与 MapQuest 静态地图 API 进行身份验证的 API 密钥。'
- en: '`center` – `f"{self.latitude},{self.longitude}"`: Defines the center of the
    map using the `latitude` and `longitude` attributes of the object'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center` – `f"{self.latitude},{self.longitude}"`: 使用对象的 `latitude` 和 `longitude`
    属性定义地图的中心。'
- en: '`self.zoom`: Specifies the zoom level for the map, controlling the scale or
    detail visible on the map'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.zoom`: 指定地图的缩放级别，控制地图上可见的缩放或细节。'
- en: '`self.size`: Sets the size of the map, using the previously defined size attribute
    of the object, likely defining the width and height in pixels'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.size`: 使用对象先前定义的大小属性设置地图的大小，可能定义像素宽度和高度。'
- en: '`traffic: ''flow|cons|inc''`: Specifies the traffic information to be included
    on the map, representing different types of traffic data such as flow, congestion,
    and incidents'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traffic: ''flow|cons|inc''`: 指定要在地图上包含的交通信息，表示不同类型的交通数据，如流量、拥堵和事件。'
- en: '`response = requests.get(base_url, params=params)`: Sends a `GET` request to
    the URL stored in `base_url` with the parameters defined in `params` and stores
    the response in the `response` variable.'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response = requests.get(base_url, params=params)`: 向存储在`base_url`中的URL发送一个带有在`params`中定义的参数的`GET`请求，并将响应存储在`response`变量中。'
- en: 'If the request is successful (`response.status_code == 200`), the following
    happens:'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求成功（`response.status_code == 200`），则发生以下情况：
- en: An image file (`traffic_map.png`) is created or overwritten in the `images`
    directory.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`images`目录中创建或覆盖了一个图像文件（`traffic_map.png`）。
- en: The content of the response (which is image data) is written to the file.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应的内容（即图像数据）被写入到文件中。
- en: 'The method returns the path to the saved image: `"images/traffic_map.png"`'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法返回保存图像的路径：`"images/traffic_map.png"`
- en: If the request is not successful, the method returns the path to a predefined
    `error.png` image in the `images` directory. This image contains an `Error loading
    traffic` `map` message.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求不成功，该方法返回`images`目录中预定义的`error.png`图像的路径。此图像包含`Error loading traffic map`消息。
- en: Important note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The main takeaway from this method is that, unlike many API responses that require
    a JSON library to parse, the response from the `GET` request to the MapQuest Traffic
    API directly contains image data for the traffic map, so it can be saved as an
    image file without needing to parse JSON.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个方法中我们可以得到的主要启示是，与许多需要JSON库来解析的API响应不同，对MapQuest Traffic API的`GET`请求的响应直接包含交通地图的图像数据，因此它可以保存为图像文件，无需解析JSON。
- en: We save our code as `TrafficMap.py` inside the `IoTWeatherDisplay` project subfolder.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将代码保存为`TrafficMap.py`在`IoTWeatherDisplay`项目子文件夹中。
- en: With the creation of the `WeatherData` and `TrafficMap` classes complete, we
    can now proceed to write a `Dashboard` class that will handle the display of information
    retrieved from these web services.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 随着`WeatherData`和`TrafficMap`类的创建完成，我们现在可以继续编写一个`Dashboard`类，该类将处理从这些网络服务检索到的信息显示。
- en: Adding Dashboard and MyApp classes
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加Dashboard和MyApp类
- en: For the `Dashboard` class, we use the Kivy library. Kivy is an open source Python
    framework designed for developing multitouch applications that can run on various
    platforms, including Windows, macOS, Linux, iOS, and Android.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Dashboard`类，我们使用Kivy库。Kivy是一个开源的Python框架，旨在开发可在各种平台上运行的多点触控应用程序，包括Windows、macOS、Linux、iOS和Android。
- en: In the same Python file where we define the Dashboard class, we will add a Kivy
    App class we call MyApp. The MyApp class in this code is a subclass of Kivy’s
    App class, defining the main entry point for the application by creating an instance
    of the Dashboard class in its build() method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义Dashboard类的同一Python文件中，我们将添加一个名为MyApp的Kivy App类。在这个代码中，MyApp类是Kivy的App类的子类，通过在其build()方法中创建Dashboard类的实例来定义应用程序的主要入口点。
- en: 'To do this, we do the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们执行以下操作：
- en: We launch Thonny by clicking on the **Menu** icon in the Raspberry Pi taskbar.
    Then, we navigate to the **Programming** category and select **Thonny**.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过点击树莓派任务栏中的**菜单**图标来启动Thonny。然后，我们导航到**编程**类别并选择**Thonny**。
- en: Once inside Thonny, we activate the `ch4-env` virtual environment.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入Thonny，我们将激活`ch4-env`虚拟环境。
- en: We create a new tab by selecting **File** and then **New** or by hitting *Ctrl*
    + *N* on the keyboard.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过选择**文件**然后**新建**，或者在键盘上按*Ctrl* + *N*来创建一个新的标签页。
- en: 'We start our code by configuring Kivy to run in fullscreen and borderless mode:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过配置Kivy以全屏和无边框模式运行来开始我们的代码：
- en: '[PRE18]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Why do we configure our Kivy application before adding other imports?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们在添加其他导入之前要配置我们的Kivy应用程序？
- en: We configure our application before importing other packages in Kivy to ensure
    that the settings are applied at the beginning of the application’s life cycle.
    If configuration were done after importing the packages, some settings might not
    be applied or could lead to unexpected behavior, as Kivy components might be initialized
    with the default configurations before the custom settings are set.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kivy中导入其他包之前，我们配置我们的应用程序以确保设置在应用程序的生命周期开始时应用。如果配置在导入包之后完成，某些设置可能不会应用，或者可能导致意外的行为，因为Kivy组件可能在自定义设置设置之前就已经使用默认配置初始化了。
- en: 'After configuration, we import the other packages we require for our application:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置完成后，我们导入我们应用程序所需的其它包：
- en: '[PRE19]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s look at what we just added:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看我们刚刚添加了什么：
- en: '`from kivy.app import App`: Imports the main application class from the Kivy
    framework, which is necessary for building and running the app.'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from kivy.app import App`: 从 Kivy 框架中导入主应用程序类，这是构建和运行应用程序所必需的。'
- en: '`from kivy.uix.floatlayout import FloatLayout`: Imports the `FloatLayout` class
    from Kivy, which allows for positioning and resizing of widgets in a free-form
    manner. We do this so that we may position our GUI components in exact locations
    on our screen.'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from kivy.uix.floatlayout import FloatLayout`: 从 Kivy 中导入 `FloatLayout` 类，允许以自由形式定位和调整小部件的大小。我们这样做是为了能够在屏幕上的确切位置定位我们的
    GUI 组件。'
- en: '`from kivy.uix.label import Label`: Imports the `Label` class from Kivy, which
    is used to display text on the screen.'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from kivy.uix.label import Label`: 从 Kivy 中导入 `Label` 类，用于在屏幕上显示文本。'
- en: '`from kivy.uix.image import Image, AsyncImage`: Imports the `Image` and `AsyncImage`
    classes from Kivy, allowing for the display of both static and asynchronous images
    within the application.'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from kivy.uix.image import Image, AsyncImage`: 从 Kivy 中导入 `Image` 和 `AsyncImage`
    类，允许在应用程序中显示静态和异步图像。'
- en: '`from kivy.clock import Clock`: Imports the `Clock` class from Kivy, enabling
    the scheduling of periodic functions within the app. We will be using this class
    to update our dashboard every 30 minutes.'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from kivy.clock import Clock`: 从 Kivy 中导入 `Clock` 类，使应用程序内周期性函数的安排成为可能。我们将使用此类每
    30 分钟更新我们的仪表板。'
- en: '`from WeatherData import WeatherData`: Imports our custom `WeatherData` class,
    which is used to handle weather-related information.'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from WeatherData import WeatherData`: 导入我们自定义的 `WeatherData` 类，用于处理与天气相关的信息。'
- en: '`from TrafficMap import TrafficMap`: Imports the custom `TrafficMap` class,
    used to manage traffic map data and images.'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from TrafficMap import TrafficMap`: 导入自定义的 `TrafficMap` 类，用于管理交通地图数据和图像。'
- en: 'After our imports, we define our `Dashboard` class and its initialization method:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入之后，我们定义我们的 `Dashboard` 类及其初始化方法：
- en: '[PRE20]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s look at what we just added:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看我们刚刚添加的内容：
- en: Our `Dashboard` class inherits from Kivy’s `FloatLayout` class, allowing positioning
    and layout features.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `Dashboard` 类继承自 Kivy 的 `FloatLayout` 类，允许定位和布局功能。
- en: We initialize our class with specific parameters (`city`, `latitude`, `longitude`,
    and `zoom`).
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用特定的参数（`city`、`latitude`、`longitude` 和 `zoom`）初始化我们的类。
- en: We call the `__init__()` method of the `FloatLayout` superclass through `super(Dashboard,
    self).__init__()`, ensuring proper initialization and inheriting behaviors from
    the parent class.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `super(Dashboard, self).__init__()` 调用 `FloatLayout` 超类的 `__init__()` 方法，确保适当的初始化并从父类继承行为。
- en: We then set up the traffic map with the given `latitude`, `longitude`, and `zoom`
    parameters.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用给定的 `latitude`、`longitude` 和 `zoom` 参数设置交通地图。
- en: We utilize Kivy’s `Clock` class to schedule regular updates every `1800` seconds
    (`30` minutes).
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 Kivy 的 `Clock` 类来安排每 `1800` 秒（`30` 分钟）的定期更新。
- en: We call the `self.init_widgets()` method to create and position widgets inside
    the layout.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用 `self.init_widgets()` 方法来创建和定位布局内部的小部件。
- en: We then call `self.update_status(0)` once during initialization to set the initial
    state of the dashboard. If this method was not called, the initial state of the
    dashboard might not be set, possibly leading to a delay in displaying the initial
    content until the scheduled update occurs, which is set to happen every `1800`
    seconds or `30` minutes.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化过程中，我们调用一次 `self.update_status(0)` 来设置仪表板的初始状态。如果未调用此方法，仪表板的初始状态可能未设置，可能导致在预定更新发生之前显示初始内容出现延迟，预定更新设置为每
    `1800` 秒或 `30` 分钟发生一次。
- en: 'With the initialization of the class in place, we initialize the state of the
    widgets. We start with the `Temperature`, `Conditions`, and `Attire` widgets:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类初始化到位后，我们初始化小部件的状态。我们首先从 `Temperature`、`Conditions` 和 `Attire` 小部件开始：
- en: '[PRE21]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We then add a `city` field, weather conditions, and a traffic map:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个 `city` 字段、天气状况和交通地图：
- en: '[PRE22]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `init_widgets()` method is responsible for initializing and adding both
    static and dynamic widgets to the `Dashboard` layout, which is a subclass of Kivy’s
    `FloatLayout` class.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`init_widgets()` 方法负责初始化并添加静态和动态小部件到 `Dashboard` 布局中，`Dashboard` 是 Kivy 的 `FloatLayout`
    类的子类。'
- en: Important note
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Static widgets are components that remain the same throughout the life cycle
    of the application and don’t need to be updated dynamically. This includes adding
    labels displaying Temperature, Conditions, and Attire text at specified positions
    with specific colors, font sizes, and fonts. It also includes three image widgets
    displaying an image located at ‘images/box.png’, placed at different positions
    on the layout.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 静态小部件是那些在整个应用程序生命周期中保持不变且不需要动态更新的组件。这包括在指定位置添加显示温度、状况和着装文本的标签，并使用特定的颜色、字体大小和字体。还包括三个图像小部件，显示位于‘images/box.png’的图像，放置在布局的不同位置。
- en: '`AsyncImage` widget to display a weather conditions icon, a label for displaying
    weather conditions text, another `AsyncImage` widget to display a traffic map,
    and an image widget to display appropriate attire for the current weather conditions.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncImage`小部件用于显示天气状况图标，一个用于显示天气状况文本的标签，另一个`AsyncImage`小部件用于显示交通地图，以及一个图像小部件用于显示当前天气状况的适当着装。'
- en: The `init_widgets()` method leverages the `add_widget()` method provided by
    Kivy’s `FloatLayout` classto add each widget to the layout. The dynamic widgets
    are also stored as attributes of the `Dashboard` class so that they can be easily
    accessed and updated later.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`init_widgets()`方法利用Kivy的`FloatLayout`类提供的`add_widget()`方法将每个小部件添加到布局中。动态小部件也存储为`Dashboard`类的属性，以便以后可以轻松访问和更新。'
- en: 'We use the `update_status()` method of the `Dashboard` class to provide new
    values for our screen every `30` minutes (as set in the initialization method):'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`Dashboard`类的`update_status()`方法，每隔`30`分钟（如初始化方法中设置）为我们的屏幕提供新的值：
- en: '[PRE23]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `update_status()` method within the `Dashboard` class plays a major role
    in updating the dynamic widgets to reflect current data. Initially, it creates
    an instance of the `WeatherData` class using the current city. The method then
    proceeds to update the source of the `traffic_map_image` widget with a new traffic
    map image reflecting current conditions, obtained from the `get_traffic_map()`
    method of the `TrafficMap` class. It also changes the source of the `attire_image`
    widget to represent suitable clothing for the current weather, utilizing the `get_attire_image()`
    method of the `WeatherData` class.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Dashboard`类中的`update_status()`方法在更新动态小部件以反映当前数据方面发挥着重要作用。最初，它使用当前城市创建`WeatherData`类的一个实例。然后，该方法继续更新`traffic_map_image`小部件的源，以一个新的交通地图图像反映当前状况，该图像是通过`TrafficMap`类的`get_traffic_map()`方法获得的。它还更改`attire_image`小部件的源，以表示适合当前天气的服装，利用`WeatherData`类的`get_attire_image()`方法。'
- en: The temperature label’s text is updated with the current temperature from the
    `WeatherData` class, appending the degree symbol and the letter *C* to represent
    Celsius. The text of the `weather_conditions_label` widget is modified to provide
    a description of the present weather conditions, also obtained from the `WeatherData`
    class.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 温度标签的文本通过从`WeatherData`类获取当前温度来更新，并在后面附加度符号和字母*C*来表示摄氏度。`weather_conditions_label`小部件的文本被修改，以提供对当前天气状况的描述，这也来自`WeatherData`类。
- en: Finally, the source of the `conditions_image` widget is updated with an icon
    that symbolizes the current weather conditions, using the `get_weather_conditions_icon()`
    method from the `WeatherData` class.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，`conditions_image`小部件的来源被更新为一个代表当前天气状况的图标，这是通过使用`WeatherData`类中的`get_weather_conditions_icon()`方法实现的。
- en: 'Having completed our `Dashboard` class, we’ll next develop the `MyApp` class.
    This class will serve as the entry point for our Kivy application, handling both
    the initialization and management of the dashboard interface. We’ll create this
    class immediately following the `Dashboard` class in the same file:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成我们的`Dashboard`类后，我们将接下来开发`MyApp`类。这个类将作为我们的Kivy应用程序的入口点，处理仪表盘界面的初始化和管理。我们将在同一文件中紧随`Dashboard`类之后立即创建这个类：
- en: '[PRE24]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `MyApp` class is inherited from Kivy’s `App` class and is responsible for
    initializing and running the main application. Within the `build()` method of
    `MyApp`, the city of `Toronto`, along with its corresponding latitude and longitude
    coordinates (`43.6426` and `-79.3871`), and zoom level are specified. These GPS
    coordinates point to the location in Toronto (downtown Toronto near the CN Tower).
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`MyApp`类继承自Kivy的`App`类，负责初始化和运行主应用程序。在`MyApp`的`build()`方法中，指定了城市多伦多及其相应的纬度和经度坐标（`43.6426`和`-79.3871`），以及缩放级别。这些GPS坐标指向多伦多的位置（多伦多市中心靠近CN塔）。'
- en: A `Dashboard` object is then created and returned with these parameters. The
    `if __name__ == '__main__':` line ensures that the code following it is only executed
    if the script is being run directly (not imported as a module in another script).
    When run directly, it creates an instance of the `MyApp` class and calls its `run()`
    method, starting the Kivy application and displaying the initialized dashboard
    with specified details related to Toronto.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后创建并返回一个 `Dashboard` 对象，并带有这些参数。`if __name__ == '__main__':` 这一行确保只有当脚本直接运行时（不是作为另一个脚本中的模块导入时）才会执行其后的代码。直接运行时，它创建
    `MyApp` 类的一个实例并调用其 `run()` 方法，启动 Kivy 应用程序并显示与多伦多相关的指定细节的初始化仪表板。
- en: We save our code as `Dashboard.py` inside the `IoTWeatherDisplay` project subfolder.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将代码保存为 `Dashboard.py` 在 `IoTWeatherDisplay` 项目子文件夹中。
- en: With all this code written, it is time to run it on our 7-inch screen.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写了所有这些代码之后，是时候在我们的 7 英寸屏幕上运行它了。
- en: Running the IoT information display application
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行物联网信息显示应用程序
- en: To execute our IoT information display through the `Dashboard.py` script, we
    use Thonny. We can either click on the green run button and hit *F5* on the keyboard
    or click on the **Run** menu option at the top and then **Run** **current script**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 `Dashboard.py` 脚本执行我们的物联网信息显示，我们使用 Thonny。我们可以点击绿色的运行按钮并在键盘上按 *F5*，或者点击顶部的
    **运行** 菜单选项，然后选择 **运行** **当前脚本**。
- en: 'With all the aforementioned code entered without errors (or cloned from the
    GitHub repository at [https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter4](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter4)),
    we should see our IoT information display run full screen on our 7-inch monitor:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有错误输入（或从 GitHub 仓库 [https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter4](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter4)
    复制）所有上述代码的情况下，我们应该在我们的 7 英寸显示器上看到物联网信息显示全屏运行：
- en: '![Figure 4.10 – IoT information display showing weather and traffic for Toronto,
    Canada](img/B21282_04_10.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 显示加拿大多伦多天气和交通信息的物联网信息显示](img/B21282_04_10.jpg)'
- en: Figure 4.10 – IoT information display showing weather and traffic for Toronto,
    Canada
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 显示加拿大多伦多天气和交通信息的物联网信息显示
- en: As we can see, it is a relatively warm day in Toronto. In terms of traffic flow,
    there is construction and other areas to avoid. The weather is clear, and it is
    suggested we wear short-sleeved shirts today. If we were to run this on a standard
    computer monitor, we may see a large black border around our display.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，今天在多伦多是相对温暖的一天。在交通流量方面，有施工和其他需要避免的区域。天气晴朗，建议今天穿短袖衬衫。如果我们在一个标准计算机显示器上运行它，我们可能会看到显示周围有一个大黑边。
- en: In a specific application such as creating an IoT information display, the mouse
    and keyboard can be removed from the Raspberry Pi, allowing the device to be used
    as a kiosk with a 7-inch touchscreen.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建物联网信息显示等特定应用中，可以从 Raspberry Pi 中移除鼠标和键盘，使设备可以作为带有 7 英寸触摸屏的亭子使用。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored various small screens compatible with the Raspberry
    Pi. We then used Raspberry Pi’s 7-inch touchscreen to create a versatile IoT information
    display that included weather forecasts and traffic maps for a specific city.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了与 Raspberry Pi 兼容的各种小型屏幕。然后我们使用 Raspberry Pi 的 7 英寸触摸屏创建了一个多功能的物联网信息显示，其中包括特定城市的天气预报和交通地图。
- en: By utilizing and optimizing web service data, we demonstrated the flexibility
    of Raspberry Pi in handling complex information display tasks. The principles
    and code developed in this chapter can be adapted for other uses, such as home
    automation dashboards, public information kiosks, or industrial monitoring systems
    for manufacturing processes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用和优化网络服务数据，我们展示了 Raspberry Pi 在处理复杂信息显示任务方面的灵活性。本章开发的原则和代码可以适应其他用途，例如家庭自动化仪表板、公共信息亭或制造过程的工业监控系统。
- en: We have focused primarily on displaying information – in particular, weather
    information via web services – over the last few chapters. In the next chapter,
    we will start exploring sensory information with our Raspberry Pi as we work toward
    building an IoT security application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们主要关注显示信息——特别是通过网络服务提供的天气信息。在下一章中，我们将开始探索使用 Raspberry Pi 的感官信息，我们致力于构建物联网安全应用程序。
- en: 'Part 2: Building an IoT Home Security Dashboard'
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：构建物联网家庭安全仪表板
- en: In *Part 2*, we explore the general-purpose input/output (GPIO) ports on the
    Raspberry Pi and Raspberry Pi Pico, build an IoT alarm module with a Raspberry
    Pi Pico W and a PIR motion sensor, create an IoT button using the M5Stack ATOM
    Matrix and Raspberry Pi Pico W, and develop an IoT alarm dashboard on a Raspberry
    Pi 5 with a 7-inch touchscreen for control and monitoring.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第二部分*中，我们探讨了树莓派和树莓派Pico上的通用输入/输出（GPIO）端口，使用树莓派Pico W和PIR运动传感器构建了一个物联网警报模块，利用M5Stack
    ATOM Matrix和树莓派Pico W创建了一个物联网按钮，并在带有7英寸触摸屏的树莓派5上开发了一个物联网警报仪表板，用于控制和监控。
- en: 'This part has the following chapters:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B21282_05.xhtml#_idTextAnchor080), *Exploring the GPIO*'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第五章*](B21282_05.xhtml#_idTextAnchor080), *探索GPIO*'
- en: '[*Chapter 6*](B21282_06.xhtml#_idTextAnchor091), *Building an IoT Alarm Module*'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第六章*](B21282_06.xhtml#_idTextAnchor091), *构建物联网警报模块*'
- en: '[*Chapter 7*](B21282_07.xhtml#_idTextAnchor107), *Building an IoT Button*'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第七章*](B21282_07.xhtml#_idTextAnchor107), *构建物联网按钮*'
- en: '[*Chapter 8*](B21282_08.xhtml#_idTextAnchor125), *Creating an IoT Alarm Dashboard*'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第八章*](B21282_08.xhtml#_idTextAnchor125), *创建一个物联网警报仪表板*'
