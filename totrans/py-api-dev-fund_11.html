<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-210"><a id="_idTextAnchor476"/>Appendix</h1>
		</div>
		<div><h2>About</h2>
			<p>This section is included to assist the students to perform the activities in the book. It includes detailed steps that are to be performed by the students to achieve the objectives of the activities.</p>
		</div>
		<div><h2 id="_idParaDest-211">1: Your First Step</h2>
			<h3 id="_idParaDest-212"><a id="_idTextAnchor477"/>Activity 1: Sending Requests to Our APIs Using Postman</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li>First, we will get all of the recipes. Select <code>GET</code> as our <code>HTTP</code> method in the drop-down list.</li>
				<li>Enter the request URL <code>http://localhost:5000/recipes</code>.</li>
				<li>Click the <strong class="bold">Send</strong> button. The result<a id="_idTextAnchor478"/> can be seen in the following screenshot:<div><img src="img/C15309_01_14.jpg" alt="Figure 1.14: Getting all the recipes&#13;&#10;"/></div><h6>Figure 1.14: Getting all the recipes</h6><p>In the HTTP response, you will see the HTTP status <strong class="bold">200 OK</strong> in the top-right corner of the response panel. That means the request has been successful. The time next to it shows <strong class="bold">7ms</strong>, which is the time spent on the request. And the size of the response, including the header and body, is <strong class="bold">322</strong> bytes. The details of the recipes, in JSON format, are shown in the Body panel. </p></li>
				<li>Next, we are going to use the POST method to create a recipe. We will send an HTTP <code>http://localhost:5000/recipes</code>.</li>
				<li>Create a new tab next to the Get Request Tab by clicking on the <code>http://localhost:5000/recipes</code> as the request URL.</li>
				<li>Select the Body Tab. Also, select the <strong class="bold">raw</strong> radio button.</li>
				<li>Choose <strong class="bold">JSON (application/json)</strong> in the right drop-down menu. Type the following data in JSON format in the <strong class="bold">Body</strong> content area. Click the <strong class="bold">Send</strong> button:<pre>{
     "name": "Cheese Pizza",
     "description": "This is a lovely cheese pizza"
}</pre><p>The result can be seen in the following screenshot:</p><div><img src="img/C15309_01_15.jpg" alt="Figure 1.15: Creating a recipe&#13;&#10;"/></div><h6>Figure 1.15: Creating a recipe</h6><p>You should see the following information in the HTTP response in the Postman interface, Status <strong class="bold">201 </strong>OK, meaning the creation has been successful and we can see our new recipe in JSON format. You will also notice that the ID assigned to the recipe is <strong class="bold">3</strong>.</p></li>
				<li>Now, get all the recipes from the server application again. We want to see if we have three recipes there now. In the history panel, select our previous request that gets all recipes, clicks on it, and resends.<p>In response, we can see that there are three recipes. They are shown in the following screenshot:</p><div><img src="img/C15309_01_16.jpg" alt="Figure 1.16: Getting all the recipes from the server application&#13;&#10;"/></div><h6>Figure 1.16: Getting all the recipes from the server application</h6></li>
				<li>Then, modify the recipe that we have just created. To do this, create a new tab next to the <strong class="bold">Get</strong> Request Tab by clicking on the <strong class="bold">+</strong> button. Select <strong class="bold">PUT</strong> as the HTTP method.</li>
				<li>Type in <code>http://localhost:5000/recipes/3</code> as the request URL.</li>
				<li>Select the <strong class="bold">Body</strong> Tab and then select the <strong class="bold">raw</strong> radio button.</li>
				<li>Choose <code>JSON (application/json)</code> in the right drop-down menu. Type the following data in JSON format in the <strong class="bold">Body</strong> content area. Click <strong class="bold">Send</strong>:<pre>{
"name": "Lovely Cheese Pizza",
"description": "This is a lovely cheese pizza recipe."
}</pre><p>The result is shown in the following screenshot:</p><div><img src="img/C15309_01_17.jpg" alt="Figure 1.17: Modifying the recipe&#13;&#10;"/></div><h6>Figure 1.17: Modifying the recipe</h6><p>In the HTTP response, you will see the <strong class="bold">200 OK</strong> HTTP status, meaning the update has been successful. You can also see the time spent on the request in milliseconds. You should also see the size of the response (header and body). The content of the response is in JSON format. We can see our updated recipe here in JSON format. </p></li>
				<li>Next, we will see if we can look for a recipe using its ID. We only want to see the recipe with ID <strong class="bold">3</strong> in the response. To do this, create a new tab next to the <strong class="bold">Get Request</strong> Tab by clicking on the <strong class="bold">+</strong> button.</li>
				<li>Select <code>http://localhost:5000/recipes/3</code> as the request URL.</li>
				<li>Click <strong class="bold">Send</strong>. The result is shown in the following screenshot:<div><img src="img/C15309_01_18.jpg" alt="Figure 1.18: Looking for the recipe with ID&#13;&#10;"/></div><h6>Figure 1.18: Looking for the recipe with ID</h6><p>We can see in the response that only the recipe with ID <strong class="bold">3</strong> is returned. It has the modified details that we just set as well.</p></li>
				<li>When we search for a recipe that doesn't exist, we will see the following response, with a message <code>http://localhost:5000/recipes/101</code> endpoint. The result is shown in the following screenshot:<div><img src="img/C15309_01_19.jpg" alt="Figure 1.19: Response showing &quot;recipe not found&quot;&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 1.19: Response showing "recipe not found"</h6>
			<h3 id="_idParaDest-213"><a id="_idTextAnchor479"/>Activity 2: Implement and Test the delete_recipe Function</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">The <code>delete_recipe</code> function removes a recipe from the memory. Use <code>recipe = next((recipe for recipe in recipes if recipe['id'] == recipe_id), None)</code> to get the recipe with the specific ID:<pre>@app.route('/recipes/&lt;int:recipe_id&gt;', methods=['DELETE'])
def delete_recipe(recipe_id):
    recipe = next((recipe for recipe in recipes if recipe['id'] == recipe_id), None)
    if not recipe:
        return jsonify({'message': 'recipe not found'}), HTTPStatus.NOT_FOUND
    recipes.remove(recipe)
    return '', HTTPStatus.NO_CONTENT</pre></li>
				<li>Similar to the <code>update_recipe</code> function shown in earlier, if you can't find the recipe, then return "<code>recipe not found</code>" together with HTTP status <code>NOT_FOUND</code>. Otherwise, we will go ahead and remove the recipe with the given ID from our recipe collection with HTTP status  <code>204 No Content</code></li>
				<li>Once the code is done, <em class="italics">right-click</em> on the <code>app.py</code> file and click <code>run</code> to start the application. The Flask server will start up, and our application is ready to be tested.</li>
				<li>Use httpie or curl to delete the recipe with <code>ID = 1</code>:<pre>http DELETE localhost:5000/recipes/1</pre><p>Following is the <code>curl</code> version of the command which does the same thing.</p><pre>curl -i -X DELETE localhost:5000/recipes/1</pre><p>The <code>@app.route('/recipes/&lt;int:recipe_id&gt;', methods=['DELETE'])</code> route will catch the client request and invoke the <code>delete_recipe(recipe_id)</code> function. The function will look for recipes with the <code>recipe_id</code> ID and, if it finds one, it will delete it. In response, we can see that the deletion has been successful. And we see that the HTTP status is <code>204 NO CONTENT</code>:</p><pre>HTTP/1.0 204 NO CONTENT
Content-Type: text/html; charset=utf-8
Date: Fri, 06 Sep 2019 05:57:50 GMT
Server: Werkzeug/0.15.6 Python/3.7.0</pre></li>
				<li>Lastly, use Postman to delete the recipe with <code>ID = 2</code>. For that, create a new tab next to the <strong class="bold">Get Request</strong> Tab by clicking on the <strong class="bold">+</strong> button.</li>
				<li>Select <code>HTTP</code> method. Type in <code>http://localhost:5000/recipes/2</code> as the request URL.</li>
				<li>Click <strong class="bold">Send</strong>. The result is shown in the following screenshot:<div><img src="img/C15309_01_20.jpg" alt="Figure 1.20: Deleting the recipe&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 1.20: Deleting the recipe</h6>
			<p>And then we can see the response with the HTTP status <strong class="bold">204 NO CONTENT</strong>. That means the recipe was successfully removed.</p>
			<h2 id="_idParaDest-214">2: Starting to Build Our Project</h2>
			<h3 id="_idParaDest-215"><a id="_idTextAnchor480"/>Activity 3: Testing the APIs Using Postman</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">First, build a client request that asks for a new recipe. Then, make use of the collection function in Postman to make the testing more efficient. </li>
				<li>Click on the <strong class="bold">Collection</strong> tab and then create a new collection by clicking on <strong class="bold">+</strong>.</li>
				<li>Type in <strong class="bold">Smilecook</strong> as the name and click <strong class="bold">Create</strong>.</li>
				<li><em class="italics">Right-click</em> on <strong class="bold">...</strong> next to <strong class="bold">Smilecook</strong>, create a new folder under <strong class="bold">Smilecook</strong>, and type <strong class="bold">Recipe</strong> in the name field.</li>
				<li><em class="italics">Right-click</em> on <strong class="bold">Recipe</strong> to create a new request. Then, set the name to <strong class="bold">RecipeList</strong> and save it under the <strong class="bold">Recipe</strong> collection.</li>
				<li>Select <code>http://localhost:5000/recipes</code> in the request URL field.</li>
				<li>Now, go to the <code>body</code> field:<pre>{
    "name": "Cheese Pizza",
    "description": "This is a lovely cheese pizza",
    "num_of_servings": 2,
    "cook_time": 30,
    "directions": "This is how you make it" 
}</pre></li>
				<li><strong class="bold">Save</strong> and send the recipe. The result is shown in the following screenshot:<div><img src="img/C15309_02_10.jpg" alt="Figure 2.10: Creating our first recipe by sending the details in JSON format&#13;&#10;"/></div><h6>Figure 2.10: Creating our first recipe by sending the details in JSON format</h6><p>In the HTTP response, you will see the HTTP status <strong class="bold">201 Created</strong>, meaning that the request was successful, and, in the body, you should see the same recipe that we just created. The ID of the recipe should be 1.</p></li>
				<li>Create t<a id="_idTextAnchor481"/>he second recipe by sending over a client request. Next, we will create our second recipe by sending the following details in JSON format:<pre>{ 
    "name": "Tomato Pasta",
    "description": "This is a lovely tomato pasta recipe",
    "num_of_servings": 3,
    "cook_time": 20,
    "directions": "This is how you make it" 
}</pre></li>
				<li>Click <strong class="bold">Send</strong>. The result is shown in the following screenshot:<div><img src="img/C15309_02_11.jpg" alt="Figure 2.11: Creating our second recipe by sending the details in JSON format&#13;&#10;"/></div><h6>Figure 2.11: Creating our second recipe by sending the details in JSON format</h6><p>In the HTTP response, you will see the HTTP status <strong class="bold">201 Created</strong>, meaning that the request was successful, and, in the body, you should see the same recipe that we just created. The ID of the recipe should be 2.</p><p>So far, we have created two recipes. Let's retrieve these recipes using Postman and confirm whether the two recipes are in the application memory.</p></li>
				<li>Create a new request under the <strong class="bold">Recipe</strong> folder, name it <strong class="bold">RecipeList</strong>, and then save it.</li>
				<li>Select the <strong class="bold">RecipeList</strong> that we just created (the one with the HTTP method set to GET).</li>
				<li>Type <code>http://localhost:5000/recipes</code> in the request URL. Then, click <code>ID = 1</code> to published.</p></li>
				<li>Create a n<a id="_idTextAnchor483"/>ew request under the <strong class="bold">Recipe</strong> folder, and name it <strong class="bold">RecipePublish</strong>, and then save it.</li>
				<li>Click on <a id="_idTextAnchor484"/>t<a id="_idTextAnchor485"/>he <strong class="bold">RecipePublish</strong> request that we just created (the one with the HTTP method set to GET).</li>
				<li>Select <code>http://localhost:5000/recipes/1/publish</code> in the request URL. Then, click <strong class="bold">Save</strong> and send the request. The result is shown in the following screenshot:<div><img src="img/C15309_02_13.jpg" alt="Figure 2.13: Retrieving the published recipe&#13;&#10;"/></div><h6>Figure <a id="_idTextAnchor487"/><a id="_idTextAnchor488"/>2.13: Retrieving the published recipe</h6><p>In the HTTP response, you will see the HTTP status <strong class="bold">204 NO CONTENT</strong>, meaning that the request has been successfully published and that no data has been returned in the response body.</p></li>
				<li>Retrieve all the recipes using Postman again. Select <code>RecipeList</code> (<code>GET</code>) from the left-hand panel and send the request. The result is shown in the following screenshot:<div><img src="img/C15309_02_14.jpg" alt="Figure 2.14: Retrieving all the recipes using Postman&#13;&#10;"/></div><h6>Figure 2<a id="_idTextAnchor489"/><a id="_idTextAnchor490"/>.14: Retrieving all the recipes using Postman</h6><p>In the HTTP response, you will see the HTTP status <code>localhost:5000/recipes/1</code>.</p></li>
				<li>Create a new<a id="_idTextAnchor491"/> request under the <code>http://localhost:5000/recipes/1</code> in the request URL.</li>
				<li>Now, go to <a id="_idTextAnchor492"/><a id="_idTextAnchor493"/><a id="_idTextAnchor494"/>t<a id="_idTextAnchor495"/>he <strong class="bold">Body</strong> tab and select raw, choose <strong class="bold">JSON (application/json)</strong> from the drop-down menu, and insert the following code into the body field. This is the modified recipe:<pre>{
    "name<a id="_idTextAnchor496"/>": "Lovely Cheese Pizza",
    "description": "This is a lovely cheese pizza recipe",
    "num_of_servings": 3,
    "cook_time": 60,
    "directions": "This is how you make it"
}</pre></li>
				<li><strong class="bold">Save</strong> and send it. The result is shown in the following screenshot:<div><img src="img/C15309_02_15.jpg" alt="Figure 2.15: Modifying the recipe with ID 1&#13;&#10;"/></div><h6>Figure 2.15: Modifying the recipe with ID 1</h6><p>In the HTTP response, you will see the HTTP status <strong class="bold">200 OK</strong>, meaning that the modification was successful. The body should contain the updated details of recipe 1 in JSON format. We will retrieve the recipe with ID 1.</p></li>
				<li>Create a new <a id="_idTextAnchor497"/>request under the <code>http://localhost:5000/recipes/1</code> in the request URL.</li>
				<li><strong class="bold">Save</strong> and sen<a id="_idTextAnchor498"/><a id="_idTextAnchor499"/><a id="_idTextAnchor500"/>d<a id="_idTextAnchor501"/> it. The result is shown in the following screenshot:<div><img src="img/C15309_02_16.jpg" alt="Figure 2.16: Retrieving the recipe with ID 1&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 2.16: Retrieving the recipe with ID 1</h6>
			<p>In the HTTP response, you will see the HTTP status <code>recipe 1</code> in JSON format.</p>
			<h3 id="_idParaDest-216"><a id="_idTextAnchor502"/>Activity 4: Implementing the Delete Recipe Function</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Add the <code>delete</code> function to <code>RecipeResource</code>. Implement the <code>delete</code> method by following the sample code:<pre>    def delete(self, recipe_id):
        recipe = next((recipe for recipe in recipe_list if recipe.id == recipe_id), None)
        if recipe is None:
            return {'message': 'recipe not found'}, HTTPStatus.NOT_FOUND
        recipe_list.remove(recipe)
        return {}, HTTPStatus.NO_CONTENT</pre><p>The third method we built here has been deleted. We do this by locating the recipe with the respective recipe ID and then remove it from the recipe list. Finally, we return the HTTP status <strong class="bold">204 NO CONTENT</strong>.</p></li>
				<li><em class="italics">Right-click</em> on the <code>app.py</code> file and click <strong class="bold">run</strong> to start the application. The Flask server will start up and our application will be ready for testing. Now, create the first recipe using Postman. We will build a client request that asks for a new recipe.</li>
				<li>First, select the <strong class="bold">RecipeList POST</strong> request. Now, send the request by clicking the <strong class="bold">Send</strong> button, as shown in the following screenshot:<div><img src="img/C15309_02_17.jpg" alt="Figure 2.17: Creating the first recipe using Postman&#13;&#10;"/></div><h6>Figure 2.17: Creating the first recipe using Postman</h6></li>
				<li>Now, we will delete a recipe using Postman. To do that, delete the recipe with ID 1.</li>
				<li>Create a new request under the <strong class="bold">Recipe</strong> folder. Then, set the <strong class="bold">Request Name</strong> to <strong class="bold">Recipe</strong> and <strong class="bold">save</strong> it.</li>
				<li>Change the <code>HTTP</code> method to <code>DELETE</code> and type <code>http://localhost:5000/recipes/1</code> in the request URL. Then, save and send the request. The result is shown in the following screenshot:<div><img src="img/C15309_02_18.jpg" alt="Figure 2.18: Deleting a recipe using Postman&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 2.18: Deleting a recipe using Postman</h6>
			<p>In the HTTP response, you will see the HTTP status <code>RecipeResource</code> class in this activity:</p>
			<div><div><img src="img/C15309_02_19.jpg" alt="Figure 2.19: The method that we built for the RecipeResource class&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 2.19: The method that we built for the RecipeResource class</h6>
			<h2 id="_idParaDest-217">3: Manipulating a Database with SQLAlchemy</h2>
			<h3 id="_idParaDest-218"><a id="_idTextAnchor503"/>Activity 5: Creating a User and a Recipe</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Open the Python console at the bottom of PyCharm and type in the following code to import the necessary modules and classes:<pre>from app import *
from models.user import User
from models.recipe import Recipe
app = create_app()</pre></li>
				<li>Create a <code>user</code> object and save that to the database by typing in the following code in the Python console:<pre>user = User(username='peter', email='peter@gmail.com', password='WkQa')
db.session.add(user)
db.session.commit()</pre></li>
				<li>Next, we will create two recipes using the following code. One thing to note is the fact that the <code>user_id</code> attribute of the recipe is set to <code>user.id</code>. This is to indicate that the recipe was created by the user <code>Peter</code>:<pre>carbonara = Recipe(name='Carbonara', description='This is a lovely carbonara recipe', num_of_servings=4, cook_time=50, directions='This is how you make it', user_id=user.id)
db.session.add(carbonara)
db.session.commit()
risotto = Recipe(name='Risotto', description='This is a lovely risotto recipe', num_of_servings=5, cook_time=40, directions='This is how you make it', user_id=user.id)
db.session.add(risotto)
db.session.commit()</pre></li>
				<li>We can see a new record there in the <code>user</code> table:<div><img src="img/C15309_03_18.jpg" alt="Figure 3.18: New record in the user table&#13;&#10;"/></div><h6>Figure 3.18: New record in the user table</h6></li>
				<li>We will then check whether the two recipes have been created in the database<div><img src="img/C15309_03_19.jpg" alt="Figure 3.19: Checking whether the two recipes have been created&#13;&#10;"/></div><p>:</p></li>
			</ol>
			<h6>Figure 3.19: Checking whether the two recipes have been created</h6>
			<h3 id="_idParaDest-219"><a id="_idTextAnchor504"/>Activity 6: Upgrading and Downgrading a Database</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Add a new attribute to the <code>user</code> class:<pre>bio= db.Column(db.String())</pre></li>
				<li>Now, run the <code>flask db migrate</code> command to create the database and tables:<pre>flask db migrate</pre><p>Flask-Migrate detected the new column and created a script for that:</p><pre>INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.ddl.postgresql] Detected sequence named 'user_id_seq' as owned by integer column 'user(id)', assuming SERIAL and omitting
INFO  [alembic.ddl.postgresql] Detected sequence named 'recipe_id_seq' as owned by integer column 'recipe(id)', assuming SERIAL and omitting
INFO  [alembic.autogenerate.compare] Detected added column 'user.bio'
  Generating /Python-API-Development-Fundamentals/smilecook/migrations/versions/6971bd62ec60_.py ... done</pre></li>
				<li>Now, check <code>/migrations/versions/6971bd62ec60_.py</code> under the <code>versions</code> folder. This file is created by Flask-Migrate. Note that you may get a different revision ID here. Please review the file before you run the <code>flask db upgrade</code> command. That's because, sometimes, it may not detect every change you make to your models:<pre>"""empty message
 
Revision ID: 6971bd62ec60
Revises: 1b69a78087e5
Create Date: 2019-10-08 12:11:47.370082
 
"""
from alembic import op
import sqlalchemy as sa
 
 
# revision identifiers, used by Alembic.
revision = '6971bd62ec60'
down_revision = '1b69a78087e5'
branch_labels = None
depends_on = None
 
 
def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('user', sa.Column('bio', sa.String(), nullable=True))
    # ### end Alembic commands ###
 
 
def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('user', 'bio')
    # ### end Alembic commands ###</pre><p>There are two functions in this autogenerated file; one is upgraded, and this is to add the new recipe and user to the table, while the other is downgraded, which is to go back to the previous version.</p></li>
				<li>We will then execute the <code>flask db upgrade</code> command, which will upgrade our database to conform with the latest specification in our models:<pre>flask db upgrade</pre><p>This command will invoke <code>upgrade()</code> to upgrade the database:</p><pre>INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade a6d248ab7b23 -&gt; 6971bd62ec60, empty message</pre></li>
				<li>Check whether the new field is created in the database. Go to <strong class="bold">smilecook</strong> &gt;&gt; <strong class="bold">Schemas</strong> &gt;&gt; <strong class="bold">Tables</strong> &gt;&gt; <strong class="bold">user</strong> &gt;&gt; <strong class="bold">Properties to verify</strong>:<div><img src="img/C15309_03_20.jpg" alt="Figure 3.20: Checking whether the new field has been created in the database&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 3.20: Checking whether the new field has been created in the database</h6>
			<p>Run the <code>downgrade</code> command to remove the new field:</p>
			<pre>flask db downgrade</pre>
			<p>This command will invoke <code>downgrade()</code> to downgrade the database:</p>
			<pre>INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.runtime.migration] Running downgrade 6971bd62ec60 -&gt; a6d248ab7b23, empty message</pre>
			<p>Check whether the field has been removed. Go to <strong class="bold">smilecook</strong> → <strong class="bold">Schemas</strong> → <strong class="bold">Tables</strong> → <strong class="bold">user</strong> → <strong class="bold">Properties to verify</strong>:</p>
			<div><div><img src="img/C15309_03_21.jpg" alt="Figure 3.21: Checking whether the field has been removed from the database&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 3.21: Checking whether the field has been removed from the database</h6>
			<h2 id="_idParaDest-220">4: Authenticated Services and Security with JWTs</h2>
			<h3 id="_idParaDest-221"><a id="_idTextAnchor505"/>Activity 7: Implementing Access Control on the publish/unpublish Recipe Function</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Modify the <code>put</code> method in <code>RecipePublishResource</code> to restrict access to only authenticated users. In <code>resources/token.py</code>, add the <code>@jwt_required</code> decorator on top of the <code>RecipePublishResource.put</code> method. Use the <code>get_jwt_identity()</code> function to identify whether the authenticated user is the owner of the recipe:<pre>    @jwt_required
    def put(self, recipe_id):
        recipe = Recipe.get_by_id(recipe_id=recipe_id)
        if recipe is None:
            return {'message': 'Recipe not found'}, HTTPStatus.NOT_FOUND
        current_user = get_jwt_identity()
        if current_user != recipe.user_id:
            return {'message': 'Access is not allowed'}, HTTPStatus.FORBIDDEN
        recipe.is_publish = True
        recipe.save()
        return {}, HTTPStatus.NO_CONTENT</pre><p>This is to publish the recipe. Only users who have logged in can publish their own recipes. The method will perform various checks to make sure the user has published privileges. It will return <strong class="bold">204 NO_CONTENT</strong> once the recipe is published.</p></li>
				<li>Modify the <code>delete</code> method in <code>RecipePublishResource</code>. Only an authenticated user can unpublish the recipe:<pre>@jwt_required    
def delete(self, recipe_id):
        recipe = Recipe.get_by_id(recipe_id=recipe_id)
        if recipe is None:
            return {'message': 'Recipe not found'}, HTTPStatus.NOT_FOUND
        current_user = get_jwt_identity()
        if current_user != recipe.user_id:
            return {'message': 'Access is not allowed'}, HTTPStatus.FORBIDDEN
        recipe.is_publish = False
        recipe.save()
        return {}, HTTPStatus.NO_CONTENT</pre><p>This unpublishes the recipe. Similar to the previous code, only a user who has logged in can unpublish their own recipe. It will return the <strong class="bold">status</strong> code <strong class="bold">204 NO_CONTENT</strong> once the recipe is published.</p></li>
				<li>Log in to the user account and get the access token. Select the <strong class="bold">POST</strong> token request that we created previously. </li>
				<li>Check the <strong class="bold">raw</strong> radio button and select <strong class="bold">JSON (application/json)</strong> from the drop-down menu. Type in the following JSON content in the <strong class="bold">Body</strong> field:<pre>{
    "email": "james@gmail.com",
    "password": "WkQad19"
}</pre></li>
				<li>Click <strong class="bold">Send</strong> to log in to the account. The result is shown in the following screenshot:<div><img src="img/C15309_04_20.jpg" alt="Figure 4.20: Log in to the user account&#13;&#10;"/></div><h6>Figure 4.20: Log in to the user account</h6><p>You will see the HTTP <strong class="bold">status</strong> code <strong class="bold">200 OK</strong>, meaning the login is successful. And we can see the <strong class="bold">access token</strong> and <strong class="bold">refresh token</strong> in the response body.</p></li>
				<li>Publish the recipe with <code>id = 3</code> in the state that the user has logged in. Select <strong class="bold">PUT RecipePublish</strong>.</li>
				<li>Go to the <code>Bearer {token}</code> in the <strong class="bold">VALUE</strong> field, where token is the JWT token we got in our previous step.</li>
				<li>Click <strong class="bold">Send</strong> to publish the recipe. The result is shown in the following screenshot:<div><img src="img/C15309_04_21.jpg" alt="Figure 4.21: Publishing the recipe&#13;&#10;"/></div><h6>Figure 4.21: Publishing the recipe</h6><p>You will then see the response, the HTTP <strong class="bold">status</strong> code <strong class="bold">204</strong> meaning the recipe has been published successfully.</p><p>Finally, try to get all published recipes. Select <strong class="bold">GET RecipeList</strong> request, then click <strong class="bold">Send</strong> to get all published recipe details. The result is shown in the following screenshot:</p><div><img src="img/C15309_04_22.jpg" alt="Figure 4.22: Retrieving all published recipes&#13;&#10;"/></div><h6>Figure 4.22: Retrieving all published recipes</h6><p>You will then see the response, the HTTP <strong class="bold">status</strong> code <strong class="bold">200</strong> meaning the request is successfully, and you can see there is one published recipe that we created is returned.</p></li>
				<li>Unpublish the recipe with <code>id = 3</code> in the state that the user has logged in. Create a new request under the <strong class="bold">Recipe</strong> folder, and name it <strong class="bold">RecipePublish</strong>, and then save it.</li>
				<li>Click on the <strong class="bold">RecipePublish</strong> request that we just created (the one with the HTTP method set to <strong class="bold">GET</strong>).</li>
				<li>Select <code>http://localhost:5000/recipes/3/publish</code> in the request URL.</li>
				<li>Go to the <code>Bearer {token}</code> in the <strong class="bold">VALUE</strong> field, where token is the JWT token we got in <em class="italics">step 5</em>.</li>
				<li><strong class="bold">Save</strong> and <strong class="bold">Send</strong> the request to unpublish. The result is shown in the following screenshot:<div><img src="img/C15309_04_23.jpg" alt="Figure 4.23: Unpublishing the recipe&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.23: Unpublishing the recipe</h6>
			<h2 id="_idParaDest-222">5: Valida<a id="_idTextAnchor506"/>ting APIs Using marshmallow</h2>
			<h3 id="_idParaDest-223"><a id="_idTextAnchor507"/>Activity 8: Serializing the recipe Object Using marshmallow</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Modify the recipe schema to include all attributes except for <code>email</code>. In <code>schemas/recipe.py</code>, modify <code>only=['id', 'username'] to exclude=('email', )</code>. This way, we will be showing everything except for the user's email address. Besides, if we have a new attribute for the <code>recipe</code> object in the future (for example, a <code>user avatar</code> URL), we won't need to modify the schema again because it will show everything: <pre>     author = fields.Nested(UserSchema, attribute='user', dump_only=True, exclude=('email', ))</pre></li>
				<li>Modify the <code>get</code> method in <code>RecipeResource</code> to serialize the <code>recipe</code> object into JSON format using the recipe schema:<pre>        return recipe_schema.dump(recipe).data, HTTPStatus.OK</pre><p>This is mainly to modify the code to use <code>recipe_schema.dump(recipe).data</code> to return the recipe details by using the recipe schema.</p></li>
				<li>Right-click on it to run the application. Flask will then be started up and run on the localhost (<code>127.0.0.1</code>) at port <code>5000</code>:<div><img src="img/C15309_05_18.jpg" alt="Figure 5.18: Run Flask on the localhost&#13;&#10;"/></div><h6>Figure 5.18: Run Flask on the localhost</h6></li>
				<li>Test the implementation by getting one specific published recipe in Postman. Select the <code>http://localhost:5000/recipes/4</code> in <strong class="bold">Enter request URL</strong>. Click <strong class="bold">Send</strong> to get specific recipe details. The result is shown in the following screenshot:<div><img src="img/C15309_05_19.jpg" alt="Figure 5.19: Select the GET Recipe request and send the request&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 5.19: Select the GET Recipe request and send the request</h6>
			<p>You will then see the return response. The HTTP status code <code>created_at</code>.</p>
			<h2 id="_idParaDest-224">6: Email Confirmations</h2>
			<h3 id="_idParaDest-225"><a id="_idTextAnchor508"/>Activity 9: Testing the Complete User Registration and Activation Workflow</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">We will first register a new user through Postman. Click on the <strong class="bold">Collections</strong> tab and choose the <strong class="bold">POST UserList</strong> request.</li>
				<li>Select the <strong class="bold">Body</strong> tab and then select the <strong class="bold">raw</strong> radio button and choose <strong class="bold">JSON (application/json)</strong> from the drop-down list.</li>
				<li>Put in the following user details (in JSON format) in the <strong class="bold">Body</strong> field. Change the username and password to the appropriate one:<pre>{
    "username": "john",
    "email": "smilecook.api@gmail.com",
    "password": "Kwq2z5"
}</pre></li>
				<li>Send the request. You should see the following output:<div><img src="img/C15309_06_10.jpg" alt="Figure 6.10: Registering a user through Postman&#13;&#10;"/></div><h6>Figure 6.10: Registering a user through Postman</h6><p>You should see the new user details (<strong class="bold">ID = 4</strong>) in the response, with <strong class="bold">HTTP status 201 OK</strong>. That means the new user was created successfully in the backend. </p></li>
				<li>Log in through the API and click on the <strong class="bold">Collections</strong> tab. Then, select the <strong class="bold">POST Token</strong> request we created before.</li>
				<li>Now, click on the <strong class="bold">Body</strong> tab. Check the <strong class="bold">raw</strong> radio button and select <strong class="bold">JSON(application/json)</strong> from the drop-down menu.</li>
				<li>Type in the following JSON content (email and password) in the <strong class="bold">Body</strong> field:<pre>{
    "email": "smilecook.api@gmail.com",
    "password": "Kwq2z5"
}</pre></li>
				<li>Send the request. You should see the following output:<div><img src="img/C15309_06_11.jpg" alt="Figure 6.11: Sending the request using JSON&#13;&#10;"/></div><h6>Figure 6.11: Sending the request using JSON</h6><p>You should get a message saying the user account is not activated yet, with <strong class="bold">HTTP status 403 Forbidden</strong>. This is expected behavior because our application would require the user to activate the account first. </p></li>
				<li>Please check your mailbox for the activation email. There should be a link there for you to activate the user's account. Click on that link to activate the account. It should look as follows:<div><img src="img/C15309_06_12.jpg" alt="Figure 6.12: Activation mail&#13;&#10;"/></div><h6>Figure 6.12: Activation mail</h6></li>
				<li>Log in again after the account is activated. Click on the <strong class="bold">Collections</strong> tab.</li>
				<li>Select the <strong class="bold">POST Token</strong> request that we created earlier and send the request. You'll see the following:<div><img src="img/C15309_06_13.jpg" alt="Figure 6.13: After activating the account, select the POST Token request&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 6.13: After activating the account, select the POST Token request</h6>
			<p>You should see the access token and the refresh token in the response, with HTTP status <strong class="bold">200 OK</strong>. That means the login was successful.</p>
			<h3 id="_idParaDest-226"><a id="_idTextAnchor509"/>Activity 10: Creating the HTML Format User Account Activation Email</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Click <code>Mailgun</code> dashboard, then add the email of our new user to the authorized recipient list on the right. <code>Mailgun</code> will then send a confirmation email to that email address:<div><img src="img/C15309_06_14.jpg" alt="Figure 6.14: Sending a confirmation email to our new user&#13;&#10;"/></div><h6>Figure 6.14: Sending a confirmation email to our new user</h6><h4>Note</h4><p class="callout">Since we are using the sandbox version of <code>Mailgun</code>, there is a limitation on sending out emails to external email addresses. These emails have to be added to the authorized recipient list first.</p></li>
				<li>Check the mailbox of the new user, and click <strong class="bold">I Agree</strong>. This will be as shown in the following screenshot:<div><img src="img/C15309_06_15.jpg" alt="Figure 6.15: The mailbox of a new user with an email from Mailgun&#13;&#10;"/></div><h6>Figure 6.15:<a id="_idTextAnchor510"/> The mailbox of a new user with an email from Mailgun</h6></li>
				<li>On the confirmation page, click <strong class="bold">yes</strong> to activate the account. The screen will appear as follows:<div><img src="img/C15309_06_16.jpg" alt="Figure 6.16: Activation complete message&#13;&#10;"/></div><h6>Figure 6.16: Activation complete message</h6></li>
				<li>HTML template cod<a id="_idTextAnchor511"/>e is provided by <code>Mailgun</code> out of the box. We can find it under <strong class="bold">Sending &gt; Templates</strong>. There, click <strong class="bold">Create Message Template</strong> and select <strong class="bold">Action template</strong>. We will find a template for a confirmation email and preview it:<p> </p><div><img src="img/C15309_06_17.jpg" alt="Figure 6.17: Previewing the confirm email address template&#13;&#10;"/></div><h6>Figure 6.17: Previewing the confirm email address template</h6></li>
				<li>Then, create a <strong class="bold">te<a id="_idTextAnchor512"/>m<a id="_idTextAnchor513"/>plates</strong> folder under our project. We will put all the HTML templates in this folder going forward. Inside the <strong class="bold">templates</strong> folder, create a subfolder, <strong class="bold">email</strong>, for email-related HTML templates.</li>
				<li>Now, create a template file, <code>confirmation.html</code>, and paste the sample HTML code from <code>Mailgun</code> in <em class="italics">step 4</em>. Take a look at the sample HTML code from <code>Mailgun</code> that follows:<div><img src="img/C15309_06_18.jpg" alt="Figure 6.18: Sample HTML code from Mailgun&#13;&#10;"/></div><h6>Figure 6.18: Sample HTML code from Mailgun</h6><h4>Note</h4><p class="callout">Please note that we need to change the <a href="http://www.mailgun.com">http://www.mailgun.com</a> link to <code>{{link}}</code>. This placeholder will be replaced programmatically with the account activation link.</p></li>
				<li>Import the <code>render_t<a id="_idTextAnchor514"/>emplate</code> function from Flask by entering the following line of code in <code>resources/user.py</code>:<pre>from flask import request, url_for, render_template</pre></li>
				<li>In the <code>send_mail</code> method. The HTML code can be rendered using the <code>render_template</code> function. You can see that the <code>link = link</code> parameter here is to replace the <code>{{link}}</code> placeholder in the HTML template with the actual account validation link:<pre>mailgun.send_email(to=user.email,
                                 subject=subject,
                                 text=text,
                                 html=render_template('email/confirmation.html', link=link))</pre></li>
				<li>Register a new acco<a id="_idTextAnchor516"/>unt using Postman:<pre>{
    "username": "emily",
    "email": "smilecook.user@gmail.com",
    "password": "Wqb6g2"
}</pre><h4>Note</h4><p class="callout">Please note that the email address was validated in <code>Mailgun</code> beforehand. </p><p>The output will be as follows:</p><div><img src="img/C15309_06_19.jpg" alt="Figure 6.19: Registering a new account using Postman&#13;&#10;"/></div><h6>Figure 6.19: Registe<a id="_idTextAnchor517"/>ring a new account using Postman</h6></li>
				<li>The account activati<a id="_idTextAnchor518"/>on email will then be received in HTML format. The output is shown in the following screenshot:<div><img src="img/C15309_06_20.jpg" alt="Figure 6.20: Account confirmation email&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 6.20: Account confirmation email</h6>
			<h2 id="_idParaDest-227">7: Working with Images</h2>
			<h3 id="_idParaDest-228"><a id="_idTextAnchor519"/>Activity 11: Implementing the Recipe Cover Image Upload Function</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Add the <code>cover_image</code> attribute to the User model in <code>models/recipe.py</code>:<pre>cover_image = db.Column(db.String(100), default=None)</pre><p>The <code>cover_image</code> attribute will contain the image filename as a string, with a maximum length of 100 characters.</p></li>
				<li>Use the flask db migrate command to generate a database table update script:<pre>flask db migrate</pre><p>You will see that a new column, <code>'recipe.cover_image'</code>, has been detected:</p><pre>INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added column 'recipe.cover_image'
  Generating /TrainingByPackt/Python-API-Development-Fundamentals/Lesson07/smilecook/migrations/versions/91c7dc71b826_.py ... done</pre></li>
				<li>Check the script at <code>/migrations/versions/xxxxxxxxxx_.py</code>:<pre>"""empty message
Revision ID: 91c7dc71b826
Revises: 7aafe51af016
Create Date: 2019-09-22 12:06:36.061632
"""
from alembic import op
import sqlalchemy as sa
# revision identifiers, used by Alembic.
revision = '91c7dc71b826'
down_revision = '7aafe51af016'
branch_labels = None
depends_on = None
def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('recipe', sa.Column('cover_image', sa.String(length=100), nullable=True))
    # ### end Alembic commands ###
def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('recipe', 'cover_image')
    # ### end Alembic commands ###</pre><p>From its content, we can see that two functions have been generated in the script. The <code>upgrade</code> function is used to add the new <code>cover_image</code> column to the database table, while the <code>downgrade</code> function is used to remove the <code>cover_image</code> column so that it goes back to its original state.</p></li>
				<li>Run the <code>flask db upgrade</code> command to update the database and reflect the change in the <strong class="bold">User</strong> model:<pre>flask db upgrade</pre><p>After running the preceding command, we should see the following output:</p><pre>INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade 7aafe51af016 -&gt; 91c7dc71b826, empty message</pre></li>
				<li>Check the new <code>cover_image</code> column in pgAdmin:<div><img src="img/C15309_07_10.jpg" alt="Figure 7.10: The cover_image column in pgAdmin&#13;&#10;"/></div><h6>Figure 7.10: The cover_image column in pgAdmin</h6><p>This confirms that the new <code>cover_image</code> column has been added to the recipe table.</p></li>
				<li>In <code>schemas/recipe.py</code>, <a id="_idTextAnchor520"/>import the <code>url_for</code> package and add the <code>cover_url</code> attribute and the <code>dump_cover_url</code> method:<pre>from flask import url_for
    cover_url = fields.Method(serialize='dump_cover_url')
    def dump_cover_url(self, recipe):
        if recipe.cover_image:
            return url_for('static', filename='images/recipes/{}'.format(recipe.cover_image), _external=True)
        else:
            return url_for('static', filename='images/assets/default-recipe-cover.jpg', _external=True)</pre><p>Add the <code>default-recipe-cover.jpg</code> image to <code>static/images</code>:</p><div><img src="img/C15309_07_11.jpg" alt="Figure 7.11: Folder structure after adding default-recipe-cover.jpg&#13;&#10;"/></div><h6>Figure 7.11: Folder structure after adding default-recipe-cover.jpg</h6></li>
				<li>In <code>resources/recipe.py</code>,<a id="_idTextAnchor521"/> add the import <code>os</code>, <code>image_set</code>, and <code>save_image</code> functions:<pre>import os
from extensions import image_set
from utils import save_image
In resources/recipe.py,<a id="_idTextAnchor522"/><a id="_idTextAnchor523"/> add recipe_cover_schema, which just shows the cover_url column:
recipe_cover_schema = RecipeSchema(only=('cover_url', ))</pre></li>
				<li>In <code>resources/recipe.py<a id="_idTextAnchor524"/></code>,<a id="_idTextAnchor525"/> add the <code>RecipeCoverUpload</code> resource to upload the recipe cover to the recipes folder:<pre>    class RecipeCoverUploadResource(Resource):
        @jwt_required
        def put(self, recipe_id):
            file = request.files.get('cover')
            if not file:
                return {'message': 'Not a valid image'}, HTTPStatus.BAD_REQUEST
            if not image_set.file_allowed(file, file.filename):
                return {'message': 'File type not allowed'}, HTTPStatus.BAD_REQUEST</pre><p>The <code>@jwt_required</code> decorator before the <code>PUT</code> method states that the method can only be called after the user logs in. In the <code>PUT</code> method, we are trying to get the cover image file in <code>request.files</code>. Then, we are trying to verify whether it exists and whether the file extension is permitted.</p></li>
				<li>After that, we retrieved the recipe object using <code>recipe_id</code>. First, we check whether a user has the right to modify the recipe. If the user has the right to, we will go ahead and modify the cover image of the recipe:<pre>            recipe = Recipe.get_by_id(recipe_id=recipe_id)
            if recipe is None:
                return {'message': 'Recipe not found'}, HTTPStatus.NOT_FOUND
            current_user = get_jwt_identity()
            if current_user != recipe.user_id:
                return {'message': 'Access is not allowed'}, HTTPStatus.FORBIDDEN
            if recipe.cover_image:
                cover_path = image_set.path(folder='recipes', filename=recipe.cover_image)
                if os.path.exists(cover_path):
                    os.remove(cover_path)</pre></li>
				<li>Then, we use the <code>save_image</code> function to save the uploaded image and set the <code>recipe.cover_image = filename</code>. Finally, we save the recipe using <code>recipe.save()</code> and return the image URL with an HTTP status code of <strong class="bold">200</strong>:<pre>            filename = save_image(image=file, folder='recipes')
            recipe.cover_image = filename
            recipe.save()
            return recipe_cover_schema.dump(recipe).data, HTTPStatus.OK</pre></li>
				<li>In <code>app.py</code>, import Recip<a id="_idTextAnchor526"/>eCoverUploadResource:<pre>from resources.recipe import RecipeListResource, RecipeResource, RecipePublishResource, RecipeCoverUploadResource</pre></li>
				<li>In <code>app.py</code>, link <code>Recipe<a id="_idTextAnchor527"/>C<a id="_idTextAnchor528"/>overUploadResource</code> to the route, that is, <code>/recipes/&lt;int:recipe_id&gt;/cover</code>:<pre>api.add_resource(RecipeCoverUploadResource, '/recipes/&lt;int:recipe_id&gt;/cover')</pre></li>
			</ol>
			<p>Now, we have created the function for uploading the recipe cover image. Let's move on and test it.</p>
			<h3 id="_idParaDest-229"><a id="_idTextAnchor529"/>Activity 12: Testing the Image Upload Function</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Log in to the user account using Postman. Click on the <strong class="bold">Collections</strong> tab and select the <strong class="bold">POST Token</strong> request. Then, click the <strong class="bold">Send</strong> button. The result can be seen in the following screenshot:<div><img src="img/C15309_07_12.jpg" alt="Figure 7.12: Sending a POST Token request&#13;&#10;"/></div><h6>Figure 7.12: Sending a POST Token request</h6></li>
				<li>Send a client request to<a id="_idTextAnchor530"/> our API to create a recipe and click on the <strong class="bold">Collections</strong> tab.</li>
				<li>Select the <code>Authorization</code> in the <code>Bearer {token}</code> in the <strong class="bold">VALUE</strong> field, where the token is the access token we retrieved in the previous step. Then, click the <strong class="bold">Send</strong> button. The result can be seen in the following screenshot:<div><img src="img/C15309_07_13.jpg" alt="Figure 7.13: Sending a client request to our API to create a recipe&#13;&#10;"/></div><h6>Figure 7.13: Sending a client request to our API to create a recipe</h6></li>
				<li>Upload the recipe images. Click on the <code>Recipe</code> folder to create a new request.</li>
				<li>Set the <code>RecipeCoverUpload</code> and save it in the <code>Recipe</code> folder.</li>
				<li>Select <code>PUT</code> as the HTTP method and type in <code>http://localhost:5000/recipes/&lt;recipe_id&gt;/cover</code> as the request URL (replace <code>&lt;recipe_id&gt;</code> with the recipe ID we got from the previous step).</li>
				<li>Select the <code>Authorization</code> in the <code>Bearer {token}</code> in the <strong class="bold">VALUE</strong> field, where the token is the access token we retrieved in the previous step.</li>
				<li>Select the <strong class="bold">Body</strong> tab. Then, select the form-data radio button and type cover into <strong class="bold">KEY</strong>.</li>
				<li>Choose <strong class="bold">File</strong> in the drop-down menu next to <strong class="bold">KEY</strong> and select the image file to upload.</li>
				<li>Click the <strong class="bold">Save</strong> button and then the <strong class="bold">Send</strong> button. The result can be seen in the following screenshot:<div><img src="img/C15309_07_14.jpg" alt="Figure 7.14: Uploading a recipe image&#13;&#10;"/></div><h6>Figure 7.14: Uploading a recipe image</h6></li>
				<li>Check whether the image has been compressed in PyCharm. We can see from the application log in PyCharm that the file size has been reduced by <code>97%</code>:<div><img src="img/C15309_07_15.jpg" alt="Figure 7.15: Checking whether the images are compressed in PyCharm&#13;&#10;"/></div><h6>Figure 7.15: Checking whether the images are compressed in PyCharm</h6></li>
				<li>Check the uploaded image in <code>static/images/recipes</code>:<div><img src="img/C15309_07_16.jpg" alt="Figure 7.16: Checking the uploaded image in the path&#13;&#10;"/></div><h6>Figure 7.16: Checking th<a id="_idTextAnchor531"/>e uploaded image in the path</h6></li>
				<li>Get the recipe back and confirm that the <code>cover_url</code> attribute is populated. Now, click on the <code>http://localhost:5000/recipes/5</code> into the <strong class="bold">URL</strong> field. You may replace the recipe ID, that is, 5, with any ID that is appropriate. Then, click the <strong class="bold">Send</strong> button. The result can be seen in the following screenshot:<div><img src="img/C15309_07_17.jpg" alt="Figure 7.17: Getting the recipe back and confirming that the cover_url attribute is populated&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 7.17: Getting the recipe back and confirming that the cover_url attribute is populated</h6>
			<p>Congratulations! We have tested the recipe cover image upload function. It works great!</p>
			<h2 id="_idParaDest-230">8: Pagination, Searching, and Ordering</h2>
			<h3 id="_idParaDest-231"><a id="_idTextAnchor532"/>Activity 13: Implementing Pagination on the User-Specific Recipe Retrieval API</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Modify the code in the <code>get_all_by_user</code> method under <code>models/recipe.py</code>, as follows:<pre>    @classmethod
    def get_all_by_user(cls, user_id, page, per_page, visibility='public'):
        query = cls.query.filter_by(user_id=user_id)
        if visibility == 'public':
            query = cls.query.filter_by(user_id=user_id, is_publish=True)
        elif visibility == 'private':
            query = cls.query.filter_by(user_id=user_id, is_publish=False)
        return query.order_by(desc(cls.created_at)).paginate(page=page, per_page=per_page)</pre></li>
				<li>Import <code>RecipePaginationSchema</code> into <code>resources/user.py</code>:<pre>from schemas.recipe import RecipeSchema, RecipePaginationSchema</pre></li>
				<li>Declare the <code>recipe_pagination_schema</code> attribute in <code>resources/user.py</code>:<pre>recipe_pagination_schema = RecipePaginationSchema()</pre></li>
				<li>Here, we've added the <code>@user_kwargs</code> decorator to <code>UserRecipeListResource.get</code>. It takes a few parameters, including <code>page</code>, <code>per_page</code>, and <code>visibility</code>:<pre>class UserRecipeListResource(Resource):
    @jwt_optional
    @use_kwargs({'page': fields.Int(missing=1),
                 'per_page': fields.Int(missing=10),
                 'visibility': fields.Str(missing='public')})</pre></li>
				<li>Modify the <code>UserRecipeListReso<a id="_idTextAnchor533"/>urce.get</code> method in <code>resources/user.py</code>:<pre>    def get(self, username, page, per_page, visibility):
        user = User.get_by_username(username=username)
        if user is None:
            return {'message': 'User not found'}, HTTPStatus.NOT_FOUND
        current_user = get_jwt_identity()
        if current_user == user.id and visibility in ['all', 'private']:
            pass
        else:
            visibility = 'public'
        paginated_recipes = Recipe.get_all_by_user(user_id=user.id, page=page, per_page=per_page, visibility=visibility)
        return recipe_pagination_schema.dump(paginated_recipes).data, HTTPStatus.OK</pre><p>The <code>Recipe.get_all_by_user</code> method gets the paginated recipes by a particular author, and then lets <code>recipe_pagination_schema</code> serialize the paginated object and return it.</p></li>
			</ol>
			<h3 id="_idParaDest-232"><a id="_idTextAnchor534"/>Activity 14: Testing Pagination on the User-Specific Recipe Retrieval API</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Get all the recipes under John using Postman, page by page, with a page size of two. First, click on the <code>UserRecipeList</code> request.</li>
				<li>Type <code>http://localhost:5000/{username}/recipes</code> into the <code>{username}</code> here should be the same as the one we inserted in the previous exercise. In our case, it will be <code>john</code>.</li>
				<li>Select the <code>per_page</code>, <code>2</code>).</li>
				<li>Send the request. The result is shown in the following screenshot:<div><img src="img/C15309_08_09.jpg" alt="Figure 8.9: Getting all the recipes under John using Postman&#13;&#10;"/></div><h6>Figure 8.9: Getting all the recipes under John using Postman</h6><p>In the details of the recipe, we can see that there are links with the URLs of the <code>first</code>, <code>last</code>, and <code>next</code> pages. We can't see the <strong class="bold">prev</strong> page here because we are on the first page. There is a total of four pages, and we have two records per page. We can also see the sorted recipe details in the HTTP response.</p></li>
				<li>Click the next URL in links to query for the next two records in Postman with the request URL populated (<code>http://localhost:5000/users/john/recipes?per_page=2&amp;page=2</code>). Then, we just need to click on <strong class="bold">Send</strong> to send the request. The result is shown in the following screenshot:<div><img src="img/C15309_08_10.jpg" alt="Figure 8.10: Querying for the next two records in Postman with the request URL populated&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 8.10: Querying for the next two records in Postman with the request URL populated</h6>
			<p>From the result, we can see that there are links to the <code>first</code>, <code>last</code>, <code>next</code>, and <code>prev</code> pages. We can also see that we are currently on page two. All the recipe data is there as well.</p>
			<h3 id="_idParaDest-233"><a id="_idTextAnchor535"/>Activity 15: Searching for Recipes with Specific Ingredients</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">First, in <code>models/recipe.py</code>, add the <code>ingredients</code> attribute to the <code>Recipe</code> model:<pre>    ingredients = db.Column(db.String(1000))</pre></li>
				<li>Run the following command to generate a database migration script:<pre>flask db migrate</pre><p>You will see that a new column called <code>recipe.ingredients</code> has been detected:</p><pre>INFO  [alembic.autogenerate.compare] Detected added column 'recipe.ingredients'
  Generating /TrainingByPackt/Python-API-Development-Fundamentals/smilecook/migrations/versions/0876058ed87e_.py ... done</pre></li>
				<li>Check the content in <code>/migrations/versions/0876058ed87e_.py</code>, which is the database migration script that was generated in the previous step:<pre>"""empty message
 
Revision ID: 0876058ed87e
Revises: 91c7dc71b826
Create Date: 2019-10-24 15:05:10.936752
 
"""
from alembic import op
import sqlalchemy as sa
 
# revision identifiers, used by Alembic.
revision = '0876058ed87e'
down_revision = '91c7dc71b826'
branch_labels = None
depends_on = None
 
def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('recipe', sa.Column('ingredients', sa.String(length=1000), nullable=True))
    # ### end Alembic commands ###
 
def downgrade():
    # ### commands auto-generated by Alembic - please adjust! ###
    op.drop_column('recipe', 'ingredients')
    # ### end Alembic commands ###</pre><p>Here, we can see that two functions have been generated in the script. The <code>upgrade</code> function is used to add the new column, <code>ingredients</code>, to the recipe table, whereas the <code>downgrade</code> function is used to remove the <code>ingredients</code> column so that it goes back to its original state.</p></li>
				<li>Run the following <code>flask db upgrade</code> command to update the database schema:<pre>flask db upgrade</pre><p>You will see the following output:</p><pre>INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade 91c7dc71b826 -&gt; 0876058ed87e, empty message</pre></li>
				<li>In <code>schemas/recipe.py</code>, add the <code>ingredients</code> attribute to <code>RecipeSchema</code>:<pre>        ingredients = fields.String(validate=[validate.Length(max=1000)])</pre></li>
				<li>Modify the <code>RecipeResource.patch</code> method in <code>resources/recipe.py</code> to be able to update <code>ingredients</code>:<pre>recipe.ingredients = data.get('ingredients') or recipe.ingredients</pre></li>
				<li>Modify the <code>Recipe.get_all_published</code> method in <code>models/recipe.py</code> so that it gets all the published recipes that it can through the ingredients:<pre>return cls.query.filter(or_(cls.name.ilike(keyword),
                   cls.description.ilike(keyword),
                   cls.ingredients.ilike(keyword)),
                 cls.is_publish.is_(True)).\
  order_by(sort_logic).paginate(page=page, per_page=per_page)</pre></li>
				<li><code>Right-click</code> on it to run the application. Flask will then start up and run on <code>localhost</code> (<code>127.0.0.1</code>) at port <code>5000</code>:<div><img src="img/C15309_03_07.jpg" alt="Figure 8.11: Running Flask on the localhost&#13;&#10;"/></div><h6>Figure 8.11: Running Flask on the localhost</h6></li>
				<li>Log in to a user account and create two recipes by running the following <code>httpie</code> command in the PyCharm console. The <code>{token}</code> placeholder should be replaced with the access token:<pre>http POST localhost:5000/recipes "Authorization: Bearer <code>{token}</code>" name="Sweet Potato Casserole" description="This is a lovely Sweet Potato Casserole" num_of_servings=12 cook_time=60 ingredients="4 cups sweet potato, 1/2 cup white sugar, 2 eggs, 1/2 cup milk" directions="This is how you make it"
http POST localhost:5000/recipes "Authorization: Bearer <code>{token}</code>" name="Pesto Pizza" description="This is a lovely Pesto Pizza" num_of_servings=6 cook_time=20 ingredients="1 pre-baked pizza crust, 1/2 cup pesto, 1 ripe tomato" directions="This is how you make it"</pre></li>
				<li>Publish these two recipes by using the following <code>httpie</code> command:<pre>http PUT localhost:5000/recipes/14/publish "Authorization: Bearer <code>{token}</code>"
http PUT localhost:5000/recipes/15/publish "Authorization: Bearer <code>{token}</code>"</pre></li>
				<li>Search for recipes that contain the <code>eggs</code> string in the name, description, or ingredients. Click on the <code>RecipeList</code> request and select the <code>q</code>, <code>eggs</code>) and send the request. The result is shown in the following screenshot:<div><img src="img/C15309_08_12.jpg" alt="Figure 8.12: Searching for the eggs ingredient by sending a request&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 8.12: Searching for the eggs ingredient by sending a request</h6>
			<p>From the preceding search result, we can see that there is a recipe with eggs in the ingredients.</p>
			<h2 id="_idParaDest-234">9: Building More Features</h2>
			<h3 id="_idParaDest-235">Activity <a id="_idTextAnchor536"/>16: Getting Cache Data after Updating Recipe Details</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Get all the recipe data back, click on <code>RecipeList</code> and send the request. The result is shown in the following screenshot:<div><img src="img/C15309_09_15.jpg" alt="Figure 9.15: Get the recipe data back and send the request&#13;&#10;"/></div><h6>Figure 9.15: Get the recipe data back and send the request</h6></li>
				<li>Log in to your account, click on the <strong class="bold">Collections</strong> tab and select the <strong class="bold">POST</strong> <strong class="bold">Token</strong> request. Then, send the request. The result is shown in the following screenshot:<div><img src="img/C15309_09_16.jpg" alt="Figure 9.16: Select the POST Token request and send it&#13;&#10;"/></div><h6>Figure 9.16: Select the POST Token request and send it</h6></li>
				<li>Modify a recipe record using the <code>PATCH</code> method. First, select the <code>PATCH Recipe</code> request.</li>
				<li>Now select the <code>Bearer {token}</code>; the token should be the access token.</li>
				<li>Select the <code>num_of_servings</code> to <code>5</code>, and <code>cook_time</code> to <code>50</code>:<pre>{ 
    "num_of_servings": 5, 
    "cook_time": 50 
} </pre></li>
				<li>Send the request. The result is shown in the following screenshot:<div><img src="img/C15309_09_17.jpg" alt="Figure 9.17: Modifying a recipe record using the PATCH method&#13;&#10;"/></div><h6>Figure 9.17: Modifying a recipe record using the PATCH method</h6></li>
				<li>Get all the recipe data back again, click on <code>RecipeList</code>.</li>
				<li>Send the request. The result is shown in the following screenshot:<div><img src="img/C15309_09_18.jpg" alt="Figure 9.18: Get all the recipe data back again&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 9.18: Get all the recipe data back again</h6>
			<p>We can see that when we get all the recipe details again, the details are not updated, which will cause the user to see the wrong information.</p>
			<h3 id="_idParaDest-236"><a id="_idTextAnchor537"/>Activity 17: Adding Multiple Rate-Limit Restrictions</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">In <code>resources/user.py</code>, import <code>limiter</code> from <code>extensions</code>:<pre>from extensions import image_set, limiter</pre></li>
				<li>In <code>UserRecipeListResource</code>, put the <code>limiter.limit</code> function in the <code>decorators</code> attribute:<pre>class UserRecipeListResource (Resource):
    decorators = [limiter.limit('3/minute;30/hour;300/day', methods=['GET'], error_message='Too Many Requests')]</pre></li>
				<li>Comment out the whitelist in <code>app.py</code>:<pre>#  @limiter.request_filter
#   def ip_whitelist():
#      return request.remote_addr == '127.0.0.1'</pre><p>In PyCharm, to comment out a line of code, if you are using Mac, you can use <em class="italics">Command + /</em>, and if you are using Windows, you can use <em class="italics">Ctrl + /</em>.</p></li>
				<li>When we are done, click <strong class="bold">Run</strong> to start the Flask application; then, we are ready to test it:<div><img src="img/C15309_09_19.jpg" alt="Figure 9.19: Starting the Flask application&#13;&#10;"/></div><h6>Figure 9.19: Starting the Flask application</h6></li>
				<li>Get all the recipes for a user and check the rate limit information in the response header. First, click on <code>UserRecipeList</code> and send the request.</li>
				<li>Then, select the <strong class="bold">Header</strong> tab in <strong class="bold">Response</strong>. The result is shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/C15309_09_20.jpg" alt="Figure 9.20: Checking the rate limit information in the response header&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 9.20: Checking the rate limit information in the response header</h6>
			<p>In the HTTP response, we can see that the rate limit for this endpoint is three, while we only have two remaining request quotas. The limit is going to be reset in 60 seconds.</p>
			<h2 id="_idParaDest-237">10: Deployment</h2>
			<h3 id="_idParaDest-238">Activity 18: Changing access_token to <a id="_idTextAnchor538"/>a Variable in Postman</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Perform user login and get the access t<a id="_idTextAnchor539"/>oken. Use the <strong class="bold">POST Token</strong> request to get the access token. You should see the following output:<div><img src="img/C15309_10_29.jpg" alt="Figure 10.26: Performing user login to get an access token&#13;&#10;"/></div><h6>Figure 10.29: Performing user login to get an access token</h6></li>
				<li>Click <code>access_token</code> variable. The value is the access token we obtained in the previous step. Then, click <strong class="bold">Update</strong>:<div><img src="img/C15309_10_30.jpg" alt="Figure 10.27: Adding more environment variables in Postman&#13;&#10;"/></div><h6>Figure 10.30: Adding more environment v<a id="_idTextAnchor541"/>ariables in Postman</h6></li>
				<li>Select the <code>Bearer {{access_token}}</code>, which is the environment variable we added in the previous step, and then send the request. You should see the following output:<div><img src="img/C15309_10_31.jpg" alt="Figure 10.28: Using more environment variables in Postman"/></div></li>
			</ol>
			<h6>Figure 10.31: Using more environment variables in Postman</h6>
		</div>
	</body></html>