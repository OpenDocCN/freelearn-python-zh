<html><head></head><body>
		<div>
			<div id="_idContainer195" class="Content">
			</div>
		</div>
		<div id="_idContainer196" class="Content">
			<h1 id="_idParaDest-210"><a id="_idTextAnchor476"/>Appendix</h1>
		</div>
		<div id="_idContainer197" class="Content">
			<h2>About</h2>
			<p>This section is included to assist the students to perform the activities in the book. It includes detailed steps that are to be performed by the students to achieve the objectives of the activities.</p>
		</div>
		<div id="_idContainer257" class="Content">
			<h2 id="_idParaDest-211">1: Your First Step</h2>
			<h3 id="_idParaDest-212"><a id="_idTextAnchor477"/>Activity 1: Sending Requests to Our APIs Using Postman</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li>First, we will get all of the recipes. Select <strong class="inline">GET</strong> as our <strong class="inline">HTTP</strong> method in the drop-down list.</li>
				<li>Enter the request URL <strong class="inline">http://localhost:5000/recipes</strong>.</li>
				<li>Click the <strong class="bold">Send</strong> button. The result<a id="_idTextAnchor478"/> can be seen in the following screenshot:<div id="_idContainer198" class="IMG---Figure"><img src="image/C15309_01_14.jpg" alt="Figure 1.14: Getting all the recipes&#13;&#10;"/></div><h6>Figure 1.14: Getting all the recipes</h6><p>In the HTTP response, you will see the HTTP status <strong class="bold">200 OK</strong> in the top-right corner of the response panel. That means the request has been successful. The time next to it shows <strong class="bold">7ms</strong>, which is the time spent on the request. And the size of the response, including the header and body, is <strong class="bold">322</strong> bytes. The details of the recipes, in JSON format, are shown in the Body panel. </p></li>
				<li>Next, we are going to use the POST method to create a recipe. We will send an HTTP <strong class="bold">POST</strong> request to <strong class="inline">http://localhost:5000/recipes</strong>.</li>
				<li>Create a new tab next to the Get Request Tab by clicking on the <strong class="bold">+</strong> button. Select <strong class="bold">POST</strong> as the HTTP method. Type in <strong class="inline">http://localhost:5000/recipes</strong> as the request URL.</li>
				<li>Select the Body Tab. Also, select the <strong class="bold">raw</strong> radio button.</li>
				<li>Choose <strong class="bold">JSON (application/json)</strong> in the right drop-down menu. Type the following data in JSON format in the <strong class="bold">Body</strong> content area. Click the <strong class="bold">Send</strong> button:<p class="snippet">{</p><p class="snippet">     "name": "Cheese Pizza",</p><p class="snippet">     "description": "This is a lovely cheese pizza"</p><p class="snippet">}</p><p>The result can be seen in the following screenshot:</p><div id="_idContainer199" class="IMG---Figure"><img src="image/C15309_01_15.jpg" alt="Figure 1.15: Creating a recipe&#13;&#10;"/></div><h6>Figure 1.15: Creating a recipe</h6><p>You should see the following information in the HTTP response in the Postman interface, Status <strong class="bold">201 </strong>OK, meaning the creation has been successful and we can see our new recipe in JSON format. You will also notice that the ID assigned to the recipe is <strong class="bold">3</strong>.</p></li>
				<li>Now, get all the recipes from the server application again. We want to see if we have three recipes there now. In the history panel, select our previous request that gets all recipes, clicks on it, and resends.<p>In response, we can see that there are three recipes. They are shown in the following screenshot:</p><div id="_idContainer200" class="IMG---Figure"><img src="image/C15309_01_16.jpg" alt="Figure 1.16: Getting all the recipes from the server application&#13;&#10;"/></div><h6>Figure 1.16: Getting all the recipes from the server application</h6></li>
				<li>Then, modify the recipe that we have just created. To do this, create a new tab next to the <strong class="bold">Get</strong> Request Tab by clicking on the <strong class="bold">+</strong> button. Select <strong class="bold">PUT</strong> as the HTTP method.</li>
				<li>Type in <strong class="inline">http://localhost:5000/recipes/3</strong> as the request URL.</li>
				<li>Select the <strong class="bold">Body</strong> Tab and then select the <strong class="bold">raw</strong> radio button.</li>
				<li>Choose <strong class="inline">JSON (application/json)</strong> in the right drop-down menu. Type the following data in JSON format in the <strong class="bold">Body</strong> content area. Click <strong class="bold">Send</strong>:<p class="snippet">{</p><p class="snippet">"name": "Lovely Cheese Pizza",</p><p class="snippet">"description": "This is a lovely cheese pizza recipe."</p><p class="snippet">}</p><p>The result is shown in the following screenshot:</p><div id="_idContainer201" class="IMG---Figure"><img src="image/C15309_01_17.jpg" alt="Figure 1.17: Modifying the recipe&#13;&#10;"/></div><h6>Figure 1.17: Modifying the recipe</h6><p>In the HTTP response, you will see the <strong class="bold">200 OK</strong> HTTP status, meaning the update has been successful. You can also see the time spent on the request in milliseconds. You should also see the size of the response (header and body). The content of the response is in JSON format. We can see our updated recipe here in JSON format. </p></li>
				<li>Next, we will see if we can look for a recipe using its ID. We only want to see the recipe with ID <strong class="bold">3</strong> in the response. To do this, create a new tab next to the <strong class="bold">Get Request</strong> Tab by clicking on the <strong class="bold">+</strong> button.</li>
				<li>Select <strong class="bold">GET</strong> as the HTTP method. Type in <strong class="inline">http://localhost:5000/recipes/3</strong> as the request URL.</li>
				<li>Click <strong class="bold">Send</strong>. The result is shown in the following screenshot:<div id="_idContainer202" class="IMG---Figure"><img src="image/C15309_01_18.jpg" alt="Figure 1.18: Looking for the recipe with ID&#13;&#10;"/></div><h6>Figure 1.18: Looking for the recipe with ID</h6><p>We can see in the response that only the recipe with ID <strong class="bold">3</strong> is returned. It has the modified details that we just set as well.</p></li>
				<li>When we search for a recipe that doesn't exist, we will see the following response, with a message <strong class="bold">recipe not found</strong>. Search by using the <strong class="inline">http://localhost:5000/recipes/101</strong> endpoint. The result is shown in the following screenshot:<div id="_idContainer203" class="IMG---Figure"><img src="image/C15309_01_19.jpg" alt="Figure 1.19: Response showing &quot;recipe not found&quot;&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 1.19: Response showing "recipe not found"</h6>
			<h3 id="_idParaDest-213"><a id="_idTextAnchor479"/>Activity 2: Implement and Test the delete_recipe Function</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">The <strong class="inline">delete_recipe</strong> function removes a recipe from the memory. Use <strong class="inline">recipe = next((recipe for recipe in recipes if recipe['id'] == recipe_id), None)</strong> to get the recipe with the specific ID:<p class="snippet">@app.route('/recipes/&lt;int:recipe_id&gt;', methods=['DELETE'])</p><p class="snippet">def delete_recipe(recipe_id):</p><p class="snippet">    recipe = next((recipe for recipe in recipes if recipe['id'] == recipe_id), None)</p><p class="snippet">    if not recipe:</p><p class="snippet">        return jsonify({'message': 'recipe not found'}), HTTPStatus.NOT_FOUND</p><p class="snippet">    recipes.remove(recipe)</p><p class="snippet">    return '', HTTPStatus.NO_CONTENT</p></li>
				<li>Similar to the <strong class="inline">update_recipe</strong> function shown in earlier, if you can't find the recipe, then return "<strong class="inline">recipe not found</strong>" together with HTTP status <strong class="inline">NOT_FOUND</strong>. Otherwise, we will go ahead and remove the recipe with the given ID from our recipe collection with HTTP status  <strong class="inline">204 No Content</strong></li>
				<li>Once the code is done, <em class="italics">right-click</em> on the <strong class="inline">app.py</strong> file and click <strong class="inline">run</strong> to start the application. The Flask server will start up, and our application is ready to be tested.</li>
				<li>Use httpie or curl to delete the recipe with <strong class="inline">ID = 1</strong>:<p class="snippet">http DELETE localhost:5000/recipes/1</p><p>Following is the <strong class="inline">curl</strong> version of the command which does the same thing.</p><p class="snippet">curl -i -X DELETE localhost:5000/recipes/1</p><p>The <strong class="inline">@app.route('/recipes/&lt;int:recipe_id&gt;', methods=['DELETE'])</strong> route will catch the client request and invoke the <strong class="inline">delete_recipe(recipe_id)</strong> function. The function will look for recipes with the <strong class="inline">recipe_id</strong> ID and, if it finds one, it will delete it. In response, we can see that the deletion has been successful. And we see that the HTTP status is <strong class="inline">204 NO CONTENT</strong>:</p><p class="snippet">HTTP/1.0 204 NO CONTENT</p><p class="snippet">Content-Type: text/html; charset=utf-8</p><p class="snippet">Date: Fri, 06 Sep 2019 05:57:50 GMT</p><p class="snippet">Server: Werkzeug/0.15.6 Python/3.7.0</p></li>
				<li>Lastly, use Postman to delete the recipe with <strong class="inline">ID = 2</strong>. For that, create a new tab next to the <strong class="bold">Get Request</strong> Tab by clicking on the <strong class="bold">+</strong> button.</li>
				<li>Select <strong class="bold">DELETE</strong> as the <strong class="inline">HTTP</strong> method. Type in <strong class="inline">http://localhost:5000/recipes/2</strong> as the request URL.</li>
				<li>Click <strong class="bold">Send</strong>. The result is shown in the following screenshot:<div id="_idContainer204" class="IMG---Figure"><img src="image/C15309_01_20.jpg" alt="Figure 1.20: Deleting the recipe&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 1.20: Deleting the recipe</h6>
			<p>And then we can see the response with the HTTP status <strong class="bold">204 NO CONTENT</strong>. That means the recipe was successfully removed.</p>
			<h2 id="_idParaDest-214">2: Starting to Build Our Project</h2>
			<h3 id="_idParaDest-215"><a id="_idTextAnchor480"/>Activity 3: Testing the APIs Using Postman</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">First, build a client request that asks for a new recipe. Then, make use of the collection function in Postman to make the testing more efficient. </li>
				<li>Click on the <strong class="bold">Collection</strong> tab and then create a new collection by clicking on <strong class="bold">+</strong>.</li>
				<li>Type in <strong class="bold">Smilecook</strong> as the name and click <strong class="bold">Create</strong>.</li>
				<li><em class="italics">Right-click</em> on <strong class="bold">...</strong> next to <strong class="bold">Smilecook</strong>, create a new folder under <strong class="bold">Smilecook</strong>, and type <strong class="bold">Recipe</strong> in the name field.</li>
				<li><em class="italics">Right-click</em> on <strong class="bold">Recipe</strong> to create a new request. Then, set the name to <strong class="bold">RecipeList</strong> and save it under the <strong class="bold">Recipe</strong> collection.</li>
				<li>Select <strong class="bold">POST</strong> in the drop-down list as the HTTP method and type <strong class="inline">http://localhost:5000/recipes</strong> in the request URL field.</li>
				<li>Now, go to the <strong class="bold">Body</strong> tab and select <strong class="bold">raw</strong>. Then, choose <strong class="bold">JSON (application/json)</strong> in the drop-down menu and type the following code into the <strong class="inline">body</strong> field:<p class="snippet">{</p><p class="snippet">    "name": "Cheese Pizza",</p><p class="snippet">    "description": "This is a lovely cheese pizza",</p><p class="snippet">    "num_of_servings": 2,</p><p class="snippet">    "cook_time": 30,</p><p class="snippet">    "directions": "This is how you make it" </p><p class="snippet">}</p></li>
				<li><strong class="bold">Save</strong> and send the recipe. The result is shown in the following screenshot:<div id="_idContainer205" class="IMG---Figure"><img src="image/C15309_02_10.jpg" alt="Figure 2.10: Creating our first recipe by sending the details in JSON format&#13;&#10;"/></div><h6>Figure 2.10: Creating our first recipe by sending the details in JSON format</h6><p>In the HTTP response, you will see the HTTP status <strong class="bold">201 Created</strong>, meaning that the request was successful, and, in the body, you should see the same recipe that we just created. The ID of the recipe should be 1.</p></li>
				<li>Create t<a id="_idTextAnchor481"/>he second recipe by sending over a client request. Next, we will create our second recipe by sending the following details in JSON format:<p class="snippet">{ </p><p class="snippet">    "name": "Tomato Pasta",</p><p class="snippet">    "description": "This is a lovely tomato pasta recipe",</p><p class="snippet">    "num_of_servings": 3,</p><p class="snippet">    "cook_time": 20,</p><p class="snippet">    "directions": "This is how you make it" </p><p class="snippet">}</p></li>
				<li>Click <strong class="bold">Send</strong>. The result is shown in the following screenshot:<div id="_idContainer206" class="IMG---Figure"><img src="image/C15309_02_11.jpg" alt="Figure 2.11: Creating our second recipe by sending the details in JSON format&#13;&#10;"/></div><h6>Figure 2.11: Creating our second recipe by sending the details in JSON format</h6><p>In the HTTP response, you will see the HTTP status <strong class="bold">201 Created</strong>, meaning that the request was successful, and, in the body, you should see the same recipe that we just created. The ID of the recipe should be 2.</p><p>So far, we have created two recipes. Let's retrieve these recipes using Postman and confirm whether the two recipes are in the application memory.</p></li>
				<li>Create a new request under the <strong class="bold">Recipe</strong> folder, name it <strong class="bold">RecipeList</strong>, and then save it.</li>
				<li>Select the <strong class="bold">RecipeList</strong> that we just created (the one with the HTTP method set to GET).</li>
				<li>Type <strong class="inline">http://localhost:5000/recipes</strong> in the request URL. Then, click <strong class="bold">Save</strong> and send the request. The result is shown in the following screenshot:<div id="_idContainer207" class="IMG---Figure"><img src="image/C15309_02_12.jpg" alt="Figure 2.12: Retrieving all the recipes using Postman and confirming whether they are in the application's memory&#13;&#10;"/></div><h6>Figure<a id="_idTextAnchor482"/> 2.12: Retrieving all the recipes using Postman and confirming whether they are in the application's memory</h6><p>In the HTTP response, you will see the HTTP status <strong class="bold">200 OK</strong>, meaning that the request was successful, and, in the body, you should see no data because the two recipes that we have created haven't been set to published yet. Now, we know that we can only retrieve published recipes. Let's set the recipe with <strong class="inline">ID = 1</strong> to published.</p></li>
				<li>Create a n<a id="_idTextAnchor483"/>ew request under the <strong class="bold">Recipe</strong> folder, and name it <strong class="bold">RecipePublish</strong>, and then save it.</li>
				<li>Click on <a id="_idTextAnchor484"/>t<a id="_idTextAnchor485"/>he <strong class="bold">RecipePublish</strong> request that we just created (the one with the HTTP method set to GET).</li>
				<li>Select <strong class="bold">PUT<a id="_idTextAnchor486"/></strong> as the HTTP method in the drop-down list and type <strong class="inline">http://localhost:5000/recipes/1/publish</strong> in the request URL. Then, click <strong class="bold">Save</strong> and send the request. The result is shown in the following screenshot:<div id="_idContainer208" class="IMG---Figure"><img src="image/C15309_02_13.jpg" alt="Figure 2.13: Retrieving the published recipe&#13;&#10;"/></div><h6>Figure <a id="_idTextAnchor487"/><a id="_idTextAnchor488"/>2.13: Retrieving the published recipe</h6><p>In the HTTP response, you will see the HTTP status <strong class="bold">204 NO CONTENT</strong>, meaning that the request has been successfully published and that no data has been returned in the response body.</p></li>
				<li>Retrieve all the recipes using Postman again. Select <strong class="inline">RecipeList</strong> (<strong class="inline">GET</strong>) from the left-hand panel and send the request. The result is shown in the following screenshot:<div id="_idContainer209" class="IMG---Figure"><img src="image/C15309_02_14.jpg" alt="Figure 2.14: Retrieving all the recipes using Postman&#13;&#10;"/></div><h6>Figure 2<a id="_idTextAnchor489"/><a id="_idTextAnchor490"/>.14: Retrieving all the recipes using Postman</h6><p>In the HTTP response, you will see the HTTP status <strong class="bold">200 OK</strong>, meaning that the request was successful. The body should contain a published recipe. It should be the same recipe that we set to published previously.</p><p>We will modify the recipe with ID 1 by using the PUT method to send the modified recipe data to the URL route, that is, <strong class="inline">localhost:5000/recipes/1</strong>.</p></li>
				<li>Create a new<a id="_idTextAnchor491"/> request under the <strong class="bold">Recipe</strong> folder, set the <strong class="bold">Request Name</strong> to <strong class="bold">Recipe</strong>, and save it. Then, change the HTTP method to <strong class="bold">PUT</strong> and type <strong class="inline">http://localhost:5000/recipes/1</strong> in the request URL.</li>
				<li>Now, go to <a id="_idTextAnchor492"/><a id="_idTextAnchor493"/><a id="_idTextAnchor494"/>t<a id="_idTextAnchor495"/>he <strong class="bold">Body</strong> tab and select raw, choose <strong class="bold">JSON (application/json)</strong> from the drop-down menu, and insert the following code into the body field. This is the modified recipe:<p class="snippet">{</p><p class="snippet">    "name<a id="_idTextAnchor496"/>": "Lovely Cheese Pizza",</p><p class="snippet">    "description": "This is a lovely cheese pizza recipe",</p><p class="snippet">    "num_of_servings": 3,</p><p class="snippet">    "cook_time": 60,</p><p class="snippet">    "directions": "This is how you make it"</p><p class="snippet">}</p></li>
				<li><strong class="bold">Save</strong> and send it. The result is shown in the following screenshot:<div id="_idContainer210" class="IMG---Figure"><img src="image/C15309_02_15.jpg" alt="Figure 2.15: Modifying the recipe with ID 1&#13;&#10;"/></div><h6>Figure 2.15: Modifying the recipe with ID 1</h6><p>In the HTTP response, you will see the HTTP status <strong class="bold">200 OK</strong>, meaning that the modification was successful. The body should contain the updated details of recipe 1 in JSON format. We will retrieve the recipe with ID 1.</p></li>
				<li>Create a new <a id="_idTextAnchor497"/>request under the <strong class="bold">Recipe</strong> folder, set the <strong class="bold">Request Name</strong> to <strong class="bold">Recipe</strong>, and save it. Then, change the HTTP method to <strong class="bold">GET</strong> and type <strong class="inline">http://localhost:5000/recipes/1</strong> in the request URL.</li>
				<li><strong class="bold">Save</strong> and sen<a id="_idTextAnchor498"/><a id="_idTextAnchor499"/><a id="_idTextAnchor500"/>d<a id="_idTextAnchor501"/> it. The result is shown in the following screenshot:<div id="_idContainer211" class="IMG---Figure"><img src="image/C15309_02_16.jpg" alt="Figure 2.16: Retrieving the recipe with ID 1&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 2.16: Retrieving the recipe with ID 1</h6>
			<p>In the HTTP response, you will see the HTTP status <strong class="bold">200 OK</strong>, meaning that the request is successful. The body should contain the details of <strong class="inline">recipe 1</strong> in JSON format.</p>
			<h3 id="_idParaDest-216"><a id="_idTextAnchor502"/>Activity 4: Implementing the Delete Recipe Function</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Add the <strong class="inline">delete</strong> function to <strong class="inline">RecipeResource</strong>. Implement the <strong class="inline">delete</strong> method by following the sample code:<p class="snippet">    def delete(self, recipe_id):</p><p class="snippet">        recipe = next((recipe for recipe in recipe_list if recipe.id == recipe_id), None)</p><p class="snippet">        if recipe is None:</p><p class="snippet">            return {'message': 'recipe not found'}, HTTPStatus.NOT_FOUND</p><p class="snippet">        recipe_list.remove(recipe)</p><p class="snippet">        return {}, HTTPStatus.NO_CONTENT</p><p>The third method we built here has been deleted. We do this by locating the recipe with the respective recipe ID and then remove it from the recipe list. Finally, we return the HTTP status <strong class="bold">204 NO CONTENT</strong>.</p></li>
				<li><em class="italics">Right-click</em> on the <strong class="inline">app.py</strong> file and click <strong class="bold">run</strong> to start the application. The Flask server will start up and our application will be ready for testing. Now, create the first recipe using Postman. We will build a client request that asks for a new recipe.</li>
				<li>First, select the <strong class="bold">RecipeList POST</strong> request. Now, send the request by clicking the <strong class="bold">Send</strong> button, as shown in the following screenshot:<div id="_idContainer212" class="IMG---Figure"><img src="image/C15309_02_17.jpg" alt="Figure 2.17: Creating the first recipe using Postman&#13;&#10;"/></div><h6>Figure 2.17: Creating the first recipe using Postman</h6></li>
				<li>Now, we will delete a recipe using Postman. To do that, delete the recipe with ID 1.</li>
				<li>Create a new request under the <strong class="bold">Recipe</strong> folder. Then, set the <strong class="bold">Request Name</strong> to <strong class="bold">Recipe</strong> and <strong class="bold">save</strong> it.</li>
				<li>Change the <strong class="inline">HTTP</strong> method to <strong class="inline">DELETE</strong> and type <strong class="inline">http://localhost:5000/recipes/1</strong> in the request URL. Then, save and send the request. The result is shown in the following screenshot:<div id="_idContainer213" class="IMG---Figure"><img src="image/C15309_02_18.jpg" alt="Figure 2.18: Deleting a recipe using Postman&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 2.18: Deleting a recipe using Postman</h6>
			<p>In the HTTP response, you will see the HTTP status <strong class="bold">204 NO CONTENT</strong>, meaning that the delete is successful with empty body content. The following table shows the methods that we have built for the <strong class="inline">RecipeResource</strong> class in this activity:</p>
			<div>
				<div id="_idContainer214" class="IMG---Figure">
					<img src="image/C15309_02_19.jpg" alt="Figure 2.19: The method that we built for the RecipeResource class&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 2.19: The method that we built for the RecipeResource class</h6>
			<h2 id="_idParaDest-217">3: Manipulating a Database with SQLAlchemy</h2>
			<h3 id="_idParaDest-218"><a id="_idTextAnchor503"/>Activity 5: Creating a User and a Recipe</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Open the Python console at the bottom of PyCharm and type in the following code to import the necessary modules and classes:<p class="snippet">from app import *</p><p class="snippet">from models.user import User</p><p class="snippet">from models.recipe import Recipe</p><p class="snippet">app = create_app()</p></li>
				<li>Create a <strong class="inline">user</strong> object and save that to the database by typing in the following code in the Python console:<p class="snippet">user = User(username='peter', email='peter@gmail.com', password='WkQa')</p><p class="snippet">db.session.add(user)</p><p class="snippet">db.session.commit()</p></li>
				<li>Next, we will create two recipes using the following code. One thing to note is the fact that the <strong class="inline">user_id</strong> attribute of the recipe is set to <strong class="inline">user.id</strong>. This is to indicate that the recipe was created by the user <strong class="inline">Peter</strong>:<p class="snippet">carbonara = Recipe(name='Carbonara', description='This is a lovely carbonara recipe', num_of_servings=4, cook_time=50, directions='This is how you make it', user_id=user.id)</p><p class="snippet">db.session.add(carbonara)</p><p class="snippet">db.session.commit()</p><p class="snippet">risotto = Recipe(name='Risotto', description='This is a lovely risotto recipe', num_of_servings=5, cook_time=40, directions='This is how you make it', user_id=user.id)</p><p class="snippet">db.session.add(risotto)</p><p class="snippet">db.session.commit()</p></li>
				<li>We can see a new record there in the <strong class="inline">user</strong> table:<div id="_idContainer215" class="IMG---Figure"><img src="image/C15309_03_18.jpg" alt="Figure 3.18: New record in the user table&#13;&#10;"/></div><h6>Figure 3.18: New record in the user table</h6></li>
				<li>We will then check whether the two recipes have been created in the database<div id="_idContainer216" class="IMG---Figure"><img src="image/C15309_03_19.jpg" alt="Figure 3.19: Checking whether the two recipes have been created&#13;&#10;"/></div><p>:</p></li>
			</ol>
			<h6>Figure 3.19: Checking whether the two recipes have been created</h6>
			<h3 id="_idParaDest-219"><a id="_idTextAnchor504"/>Activity 6: Upgrading and Downgrading a Database</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Add a new attribute to the <strong class="inline">user</strong> class:<p class="snippet">bio= db.Column(db.String())</p></li>
				<li>Now, run the <strong class="inline">flask db migrate</strong> command to create the database and tables:<p class="snippet">flask db migrate</p><p>Flask-Migrate detected the new column and created a script for that:</p><p class="snippet">INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.</p><p class="snippet">INFO  [alembic.runtime.migration] Will assume transactional DDL.</p><p class="snippet">INFO  [alembic.ddl.postgresql] Detected sequence named 'user_id_seq' as owned by integer column 'user(id)', assuming SERIAL and omitting</p><p class="snippet">INFO  [alembic.ddl.postgresql] Detected sequence named 'recipe_id_seq' as owned by integer column 'recipe(id)', assuming SERIAL and omitting</p><p class="snippet">INFO  [alembic.autogenerate.compare] Detected added column 'user.bio'</p><p class="snippet">  Generating /Python-API-Development-Fundamentals/smilecook/migrations/versions/6971bd62ec60_.py ... done</p></li>
				<li>Now, check <strong class="inline">/migrations/versions/6971bd62ec60_.py</strong> under the <strong class="inline">versions</strong> folder. This file is created by Flask-Migrate. Note that you may get a different revision ID here. Please review the file before you run the <strong class="inline">flask db upgrade</strong> command. That's because, sometimes, it may not detect every change you make to your models:<p class="snippet">"""empty message</p><p class="snippet"> </p><p class="snippet">Revision ID: 6971bd62ec60</p><p class="snippet">Revises: 1b69a78087e5</p><p class="snippet">Create Date: 2019-10-08 12:11:47.370082</p><p class="snippet"> </p><p class="snippet">"""</p><p class="snippet">from alembic import op</p><p class="snippet">import sqlalchemy as sa</p><p class="snippet"> </p><p class="snippet"> </p><p class="snippet"># revision identifiers, used by Alembic.</p><p class="snippet">revision = '6971bd62ec60'</p><p class="snippet">down_revision = '1b69a78087e5'</p><p class="snippet">branch_labels = None</p><p class="snippet">depends_on = None</p><p class="snippet"> </p><p class="snippet"> </p><p class="snippet">def upgrade():</p><p class="snippet">    # ### commands auto generated by Alembic - please adjust! ###</p><p class="snippet">    op.add_column('user', sa.Column('bio', sa.String(), nullable=True))</p><p class="snippet">    # ### end Alembic commands ###</p><p class="snippet"> </p><p class="snippet"> </p><p class="snippet">def downgrade():</p><p class="snippet">    # ### commands auto generated by Alembic - please adjust! ###</p><p class="snippet">    op.drop_column('user', 'bio')</p><p class="snippet">    # ### end Alembic commands ###</p><p>There are two functions in this autogenerated file; one is upgraded, and this is to add the new recipe and user to the table, while the other is downgraded, which is to go back to the previous version.</p></li>
				<li>We will then execute the <strong class="inline">flask db upgrade</strong> command, which will upgrade our database to conform with the latest specification in our models:<p class="snippet">flask db upgrade</p><p>This command will invoke <strong class="inline">upgrade()</strong> to upgrade the database:</p><p class="snippet">INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.</p><p class="snippet">INFO  [alembic.runtime.migration] Will assume transactional DDL.</p><p class="snippet">INFO  [alembic.runtime.migration] Running upgrade a6d248ab7b23 -&gt; 6971bd62ec60, empty message</p></li>
				<li>Check whether the new field is created in the database. Go to <strong class="bold">smilecook</strong> &gt;&gt; <strong class="bold">Schemas</strong> &gt;&gt; <strong class="bold">Tables</strong> &gt;&gt; <strong class="bold">user</strong> &gt;&gt; <strong class="bold">Properties to verify</strong>:<div id="_idContainer217" class="IMG---Figure"><img src="image/C15309_03_20.jpg" alt="Figure 3.20: Checking whether the new field has been created in the database&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 3.20: Checking whether the new field has been created in the database</h6>
			<p>Run the <strong class="inline">downgrade</strong> command to remove the new field:</p>
			<p class="snippet">flask db downgrade</p>
			<p>This command will invoke <strong class="inline">downgrade()</strong> to downgrade the database:</p>
			<p class="snippet">INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.</p>
			<p class="snippet">INFO  [alembic.runtime.migration] Will assume transactional DDL.</p>
			<p class="snippet">INFO  [alembic.runtime.migration] Running downgrade 6971bd62ec60 -&gt; a6d248ab7b23, empty message</p>
			<p>Check whether the field has been removed. Go to <strong class="bold">smilecook</strong> → <strong class="bold">Schemas</strong> → <strong class="bold">Tables</strong> → <strong class="bold">user</strong> → <strong class="bold">Properties to verify</strong>:</p>
			<div>
				<div id="_idContainer218" class="IMG---Figure">
					<img src="image/C15309_03_21.jpg" alt="Figure 3.21: Checking whether the field has been removed from the database&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 3.21: Checking whether the field has been removed from the database</h6>
			<h2 id="_idParaDest-220">4: Authenticated Services and Security with JWTs</h2>
			<h3 id="_idParaDest-221"><a id="_idTextAnchor505"/>Activity 7: Implementing Access Control on the publish/unpublish Recipe Function</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Modify the <strong class="inline">put</strong> method in <strong class="inline">RecipePublishResource</strong> to restrict access to only authenticated users. In <strong class="inline">resources/token.py</strong>, add the <strong class="inline">@jwt_required</strong> decorator on top of the <strong class="inline">RecipePublishResource.put</strong> method. Use the <strong class="inline">get_jwt_identity()</strong> function to identify whether the authenticated user is the owner of the recipe:<p class="snippet">    @jwt_required</p><p class="snippet">    def put(self, recipe_id):</p><p class="snippet">        recipe = Recipe.get_by_id(recipe_id=recipe_id)</p><p class="snippet">        if recipe is None:</p><p class="snippet">            return {'message': 'Recipe not found'}, HTTPStatus.NOT_FOUND</p><p class="snippet">        current_user = get_jwt_identity()</p><p class="snippet">        if current_user != recipe.user_id:</p><p class="snippet">            return {'message': 'Access is not allowed'}, HTTPStatus.FORBIDDEN</p><p class="snippet">        recipe.is_publish = True</p><p class="snippet">        recipe.save()</p><p class="snippet">        return {}, HTTPStatus.NO_CONTENT</p><p>This is to publish the recipe. Only users who have logged in can publish their own recipes. The method will perform various checks to make sure the user has published privileges. It will return <strong class="bold">204 NO_CONTENT</strong> once the recipe is published.</p></li>
				<li>Modify the <strong class="inline">delete</strong> method in <strong class="inline">RecipePublishResource</strong>. Only an authenticated user can unpublish the recipe:<p class="snippet">@jwt_required    </p><p class="snippet">def delete(self, recipe_id):</p><p class="snippet">        recipe = Recipe.get_by_id(recipe_id=recipe_id)</p><p class="snippet">        if recipe is None:</p><p class="snippet">            return {'message': 'Recipe not found'}, HTTPStatus.NOT_FOUND</p><p class="snippet">        current_user = get_jwt_identity()</p><p class="snippet">        if current_user != recipe.user_id:</p><p class="snippet">            return {'message': 'Access is not allowed'}, HTTPStatus.FORBIDDEN</p><p class="snippet">        recipe.is_publish = False</p><p class="snippet">        recipe.save()</p><p class="snippet">        return {}, HTTPStatus.NO_CONTENT</p><p>This unpublishes the recipe. Similar to the previous code, only a user who has logged in can unpublish their own recipe. It will return the <strong class="bold">status</strong> code <strong class="bold">204 NO_CONTENT</strong> once the recipe is published.</p></li>
				<li>Log in to the user account and get the access token. Select the <strong class="bold">POST</strong> token request that we created previously. </li>
				<li>Check the <strong class="bold">raw</strong> radio button and select <strong class="bold">JSON (application/json)</strong> from the drop-down menu. Type in the following JSON content in the <strong class="bold">Body</strong> field:<p class="snippet">{</p><p class="snippet">    "email": "james@gmail.com",</p><p class="snippet">    "password": "WkQad19"</p><p class="snippet">}</p></li>
				<li>Click <strong class="bold">Send</strong> to log in to the account. The result is shown in the following screenshot:<div id="_idContainer219" class="IMG---Figure"><img src="image/C15309_04_20.jpg" alt="Figure 4.20: Log in to the user account&#13;&#10;"/></div><h6>Figure 4.20: Log in to the user account</h6><p>You will see the HTTP <strong class="bold">status</strong> code <strong class="bold">200 OK</strong>, meaning the login is successful. And we can see the <strong class="bold">access token</strong> and <strong class="bold">refresh token</strong> in the response body.</p></li>
				<li>Publish the recipe with <strong class="inline">id = 3</strong> in the state that the user has logged in. Select <strong class="bold">PUT RecipePublish</strong>.</li>
				<li>Go to the <strong class="bold">Headers</strong> tab and put <strong class="bold">Authorization</strong> in the KEY field and <strong class="inline">Bearer {token}</strong> in the <strong class="bold">VALUE</strong> field, where token is the JWT token we got in our previous step.</li>
				<li>Click <strong class="bold">Send</strong> to publish the recipe. The result is shown in the following screenshot:<div id="_idContainer220" class="IMG---Figure"><img src="image/C15309_04_21.jpg" alt="Figure 4.21: Publishing the recipe&#13;&#10;"/></div><h6>Figure 4.21: Publishing the recipe</h6><p>You will then see the response, the HTTP <strong class="bold">status</strong> code <strong class="bold">204</strong> meaning the recipe has been published successfully.</p><p>Finally, try to get all published recipes. Select <strong class="bold">GET RecipeList</strong> request, then click <strong class="bold">Send</strong> to get all published recipe details. The result is shown in the following screenshot:</p><div id="_idContainer221" class="IMG---Figure"><img src="image/C15309_04_22.jpg" alt="Figure 4.22: Retrieving all published recipes&#13;&#10;"/></div><h6>Figure 4.22: Retrieving all published recipes</h6><p>You will then see the response, the HTTP <strong class="bold">status</strong> code <strong class="bold">200</strong> meaning the request is successfully, and you can see there is one published recipe that we created is returned.</p></li>
				<li>Unpublish the recipe with <strong class="inline">id = 3</strong> in the state that the user has logged in. Create a new request under the <strong class="bold">Recipe</strong> folder, and name it <strong class="bold">RecipePublish</strong>, and then save it.</li>
				<li>Click on the <strong class="bold">RecipePublish</strong> request that we just created (the one with the HTTP method set to <strong class="bold">GET</strong>).</li>
				<li>Select <strong class="bold">DELETE</strong> as the HTTP method in the dropdown list and type in <strong class="inline">http://localhost:5000/recipes/3/publish</strong> in the request URL.</li>
				<li>Go to the <strong class="bold">Headers</strong> tab and put <strong class="bold">Authorization</strong> in the KEY field and <strong class="inline">Bearer {token}</strong> in the <strong class="bold">VALUE</strong> field, where token is the JWT token we got in <em class="italics">step 5</em>.</li>
				<li><strong class="bold">Save</strong> and <strong class="bold">Send</strong> the request to unpublish. The result is shown in the following screenshot:<div id="_idContainer222" class="IMG---Figure"><img src="image/C15309_04_23.jpg" alt="Figure 4.23: Unpublishing the recipe&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.23: Unpublishing the recipe</h6>
			<h2 id="_idParaDest-222">5: Valida<a id="_idTextAnchor506"/>ting APIs Using marshmallow</h2>
			<h3 id="_idParaDest-223"><a id="_idTextAnchor507"/>Activity 8: Serializing the recipe Object Using marshmallow</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Modify the recipe schema to include all attributes except for <strong class="inline">email</strong>. In <strong class="inline">schemas/recipe.py</strong>, modify <strong class="inline">only=['id', 'username'] to exclude=('email', )</strong>. This way, we will be showing everything except for the user's email address. Besides, if we have a new attribute for the <strong class="inline">recipe</strong> object in the future (for example, a <strong class="inline">user avatar</strong> URL), we won't need to modify the schema again because it will show everything: <p class="snippet">     author = fields.Nested(UserSchema, attribute='user', dump_only=True, exclude=('email', ))</p></li>
				<li>Modify the <strong class="inline">get</strong> method in <strong class="inline">RecipeResource</strong> to serialize the <strong class="inline">recipe</strong> object into JSON format using the recipe schema:<p class="snippet">        return recipe_schema.dump(recipe).data, HTTPStatus.OK</p><p>This is mainly to modify the code to use <strong class="inline">recipe_schema.dump(recipe).data</strong> to return the recipe details by using the recipe schema.</p></li>
				<li>Right-click on it to run the application. Flask will then be started up and run on the localhost (<strong class="inline">127.0.0.1</strong>) at port <strong class="inline">5000</strong>:<div id="_idContainer223" class="IMG---Figure"><img src="image/C15309_05_18.jpg" alt="Figure 5.18: Run Flask on the localhost&#13;&#10;"/></div><h6>Figure 5.18: Run Flask on the localhost</h6></li>
				<li>Test the implementation by getting one specific published recipe in Postman. Select the <strong class="bold">GET Recipe</strong> request. Enter <strong class="inline">http://localhost:5000/recipes/4</strong> in <strong class="bold">Enter request URL</strong>. Click <strong class="bold">Send</strong> to get specific recipe details. The result is shown in the following screenshot:<div id="_idContainer224" class="IMG---Figure"><img src="image/C15309_05_19.jpg" alt="Figure 5.19: Select the GET Recipe request and send the request&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 5.19: Select the GET Recipe request and send the request</h6>
			<p>You will then see the return response. The HTTP status code <strong class="bold">200 OK</strong> here indicates that the request has succeeded. In the response body, we can get the recipe details with ID 4, and as you can see, you can also see the user's registration time, which is <strong class="inline">created_at</strong>.</p>
			<h2 id="_idParaDest-224">6: Email Confirmations</h2>
			<h3 id="_idParaDest-225"><a id="_idTextAnchor508"/>Activity 9: Testing the Complete User Registration and Activation Workflow</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">We will first register a new user through Postman. Click on the <strong class="bold">Collections</strong> tab and choose the <strong class="bold">POST UserList</strong> request.</li>
				<li>Select the <strong class="bold">Body</strong> tab and then select the <strong class="bold">raw</strong> radio button and choose <strong class="bold">JSON (application/json)</strong> from the drop-down list.</li>
				<li>Put in the following user details (in JSON format) in the <strong class="bold">Body</strong> field. Change the username and password to the appropriate one:<p class="snippet">{</p><p class="snippet">    "username": "john",</p><p class="snippet">    "email": "smilecook.api@gmail.com",</p><p class="snippet">    "password": "Kwq2z5"</p><p class="snippet">}</p></li>
				<li>Send the request. You should see the following output:<div id="_idContainer225" class="IMG---Figure"><img src="image/C15309_06_10.jpg" alt="Figure 6.10: Registering a user through Postman&#13;&#10;"/></div><h6>Figure 6.10: Registering a user through Postman</h6><p>You should see the new user details (<strong class="bold">ID = 4</strong>) in the response, with <strong class="bold">HTTP status 201 OK</strong>. That means the new user was created successfully in the backend. </p></li>
				<li>Log in through the API and click on the <strong class="bold">Collections</strong> tab. Then, select the <strong class="bold">POST Token</strong> request we created before.</li>
				<li>Now, click on the <strong class="bold">Body</strong> tab. Check the <strong class="bold">raw</strong> radio button and select <strong class="bold">JSON(application/json)</strong> from the drop-down menu.</li>
				<li>Type in the following JSON content (email and password) in the <strong class="bold">Body</strong> field:<p class="snippet">{</p><p class="snippet">    "email": "smilecook.api@gmail.com",</p><p class="snippet">    "password": "Kwq2z5"</p><p class="snippet">}</p></li>
				<li>Send the request. You should see the following output:<div id="_idContainer226" class="IMG---Figure"><img src="image/C15309_06_11.jpg" alt="Figure 6.11: Sending the request using JSON&#13;&#10;"/></div><h6>Figure 6.11: Sending the request using JSON</h6><p>You should get a message saying the user account is not activated yet, with <strong class="bold">HTTP status 403 Forbidden</strong>. This is expected behavior because our application would require the user to activate the account first. </p></li>
				<li>Please check your mailbox for the activation email. There should be a link there for you to activate the user's account. Click on that link to activate the account. It should look as follows:<div id="_idContainer227" class="IMG---Figure"><img src="image/C15309_06_12.jpg" alt="Figure 6.12: Activation mail&#13;&#10;"/></div><h6>Figure 6.12: Activation mail</h6></li>
				<li>Log in again after the account is activated. Click on the <strong class="bold">Collections</strong> tab.</li>
				<li>Select the <strong class="bold">POST Token</strong> request that we created earlier and send the request. You'll see the following:<div id="_idContainer228" class="IMG---Figure"><img src="image/C15309_06_13.jpg" alt="Figure 6.13: After activating the account, select the POST Token request&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 6.13: After activating the account, select the POST Token request</h6>
			<p>You should see the access token and the refresh token in the response, with HTTP status <strong class="bold">200 OK</strong>. That means the login was successful.</p>
			<h3 id="_idParaDest-226"><a id="_idTextAnchor509"/>Activity 10: Creating the HTML Format User Account Activation Email</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Click <strong class="bold">Sending</strong> &gt;&gt; <strong class="bold">Overview</strong> on the <strong class="inline">Mailgun</strong> dashboard, then add the email of our new user to the authorized recipient list on the right. <strong class="inline">Mailgun</strong> will then send a confirmation email to that email address:<div id="_idContainer229" class="IMG---Figure"><img src="image/C15309_06_14.jpg" alt="Figure 6.14: Sending a confirmation email to our new user&#13;&#10;"/></div><h6>Figure 6.14: Sending a confirmation email to our new user</h6><h4>Note</h4><p class="callout">Since we are using the sandbox version of <strong class="inline">Mailgun</strong>, there is a limitation on sending out emails to external email addresses. These emails have to be added to the authorized recipient list first.</p></li>
				<li>Check the mailbox of the new user, and click <strong class="bold">I Agree</strong>. This will be as shown in the following screenshot:<div id="_idContainer230" class="IMG---Figure"><img src="image/C15309_06_15.jpg" alt="Figure 6.15: The mailbox of a new user with an email from Mailgun&#13;&#10;"/></div><h6>Figure 6.15:<a id="_idTextAnchor510"/> The mailbox of a new user with an email from Mailgun</h6></li>
				<li>On the confirmation page, click <strong class="bold">yes</strong> to activate the account. The screen will appear as follows:<div id="_idContainer231" class="IMG---Figure"><img src="image/C15309_06_16.jpg" alt="Figure 6.16: Activation complete message&#13;&#10;"/></div><h6>Figure 6.16: Activation complete message</h6></li>
				<li>HTML template cod<a id="_idTextAnchor511"/>e is provided by <strong class="inline">Mailgun</strong> out of the box. We can find it under <strong class="bold">Sending &gt; Templates</strong>. There, click <strong class="bold">Create Message Template</strong> and select <strong class="bold">Action template</strong>. We will find a template for a confirmation email and preview it:<p> </p><div id="_idContainer232" class="IMG---Figure"><img src="image/C15309_06_17.jpg" alt="Figure 6.17: Previewing the confirm email address template&#13;&#10;"/></div><h6>Figure 6.17: Previewing the confirm email address template</h6></li>
				<li>Then, create a <strong class="bold">te<a id="_idTextAnchor512"/>m<a id="_idTextAnchor513"/>plates</strong> folder under our project. We will put all the HTML templates in this folder going forward. Inside the <strong class="bold">templates</strong> folder, create a subfolder, <strong class="bold">email</strong>, for email-related HTML templates.</li>
				<li>Now, create a template file, <strong class="inline">confirmation.html</strong>, and paste the sample HTML code from <strong class="inline">Mailgun</strong> in <em class="italics">step 4</em>. Take a look at the sample HTML code from <strong class="inline">Mailgun</strong> that follows:<div id="_idContainer233" class="IMG---Figure"><img src="image/C15309_06_18.jpg" alt="Figure 6.18: Sample HTML code from Mailgun&#13;&#10;"/></div><h6>Figure 6.18: Sample HTML code from Mailgun</h6><h4>Note</h4><p class="callout">Please note that we need to change the <a href="http://www.mailgun.com">http://www.mailgun.com</a> link to <strong class="inline">{{link}}</strong>. This placeholder will be replaced programmatically with the account activation link.</p></li>
				<li>Import the <strong class="inline">render_t<a id="_idTextAnchor514"/>emplate</strong> function from Flask by entering the following line of code in <strong class="inline">resources/user.py</strong>:<p class="snippet">from flask import request, url_for, render_template</p></li>
				<li>In the <strong class="bold">POST</strong> method <a id="_idTextAnchor515"/>under <strong class="bold">UserListResource</strong>, we will pass in the HTML code as a parameter to the <strong class="inline">send_mail</strong> method. The HTML code can be rendered using the <strong class="inline">render_template</strong> function. You can see that the <strong class="inline">link = link</strong> parameter here is to replace the <strong class="inline">{{link}}</strong> placeholder in the HTML template with the actual account validation link:<p class="snippet">mailgun.send_email(to=user.email,</p><p class="snippet">                                 subject=subject,</p><p class="snippet">                                 text=text,</p><p class="snippet">                                 html=render_template('email/confirmation.html', link=link))</p></li>
				<li>Register a new acco<a id="_idTextAnchor516"/>unt using Postman:<p class="snippet">{</p><p class="snippet">    "username": "emily",</p><p class="snippet">    "email": "smilecook.user@gmail.com",</p><p class="snippet">    "password": "Wqb6g2"</p><p class="snippet">}</p><h4>Note</h4><p class="callout">Please note that the email address was validated in <strong class="inline">Mailgun</strong> beforehand. </p><p>The output will be as follows:</p><div id="_idContainer234" class="IMG---Figure"><img src="image/C15309_06_19.jpg" alt="Figure 6.19: Registering a new account using Postman&#13;&#10;"/></div><h6>Figure 6.19: Registe<a id="_idTextAnchor517"/>ring a new account using Postman</h6></li>
				<li>The account activati<a id="_idTextAnchor518"/>on email will then be received in HTML format. The output is shown in the following screenshot:<div id="_idContainer235" class="IMG---Figure"><img src="image/C15309_06_20.jpg" alt="Figure 6.20: Account confirmation email&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 6.20: Account confirmation email</h6>
			<h2 id="_idParaDest-227">7: Working with Images</h2>
			<h3 id="_idParaDest-228"><a id="_idTextAnchor519"/>Activity 11: Implementing the Recipe Cover Image Upload Function</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Add the <strong class="inline">cover_image</strong> attribute to the User model in <strong class="inline">models/recipe.py</strong>:<p class="snippet">cover_image = db.Column(db.String(100), default=None)</p><p>The <strong class="inline">cover_image</strong> attribute will contain the image filename as a string, with a maximum length of 100 characters.</p></li>
				<li>Use the flask db migrate command to generate a database table update script:<p class="snippet">flask db migrate</p><p>You will see that a new column, <strong class="inline">'recipe.cover_image'</strong>, has been detected:</p><p class="snippet">INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.</p><p class="snippet">INFO  [alembic.runtime.migration] Will assume transactional DDL.</p><p class="snippet">INFO  [alembic.autogenerate.compare] Detected added column 'recipe.cover_image'</p><p class="snippet">  Generating /TrainingByPackt/Python-API-Development-Fundamentals/Lesson07/smilecook/migrations/versions/91c7dc71b826_.py ... done</p></li>
				<li>Check the script at <strong class="inline">/migrations/versions/xxxxxxxxxx_.py</strong>:<p class="snippet">"""empty message</p><p class="snippet">Revision ID: 91c7dc71b826</p><p class="snippet">Revises: 7aafe51af016</p><p class="snippet">Create Date: 2019-09-22 12:06:36.061632</p><p class="snippet">"""</p><p class="snippet">from alembic import op</p><p class="snippet">import sqlalchemy as sa</p><p class="snippet"># revision identifiers, used by Alembic.</p><p class="snippet">revision = '91c7dc71b826'</p><p class="snippet">down_revision = '7aafe51af016'</p><p class="snippet">branch_labels = None</p><p class="snippet">depends_on = None</p><p class="snippet">def upgrade():</p><p class="snippet">    # ### commands auto generated by Alembic - please adjust! ###</p><p class="snippet">    op.add_column('recipe', sa.Column('cover_image', sa.String(length=100), nullable=True))</p><p class="snippet">    # ### end Alembic commands ###</p><p class="snippet">def downgrade():</p><p class="snippet">    # ### commands auto generated by Alembic - please adjust! ###</p><p class="snippet">    op.drop_column('recipe', 'cover_image')</p><p class="snippet">    # ### end Alembic commands ###</p><p>From its content, we can see that two functions have been generated in the script. The <strong class="inline">upgrade</strong> function is used to add the new <strong class="inline">cover_image</strong> column to the database table, while the <strong class="inline">downgrade</strong> function is used to remove the <strong class="inline">cover_image</strong> column so that it goes back to its original state.</p></li>
				<li>Run the <strong class="inline">flask db upgrade</strong> command to update the database and reflect the change in the <strong class="bold">User</strong> model:<p class="snippet">flask db upgrade</p><p>After running the preceding command, we should see the following output:</p><p class="snippet">INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.</p><p class="snippet">INFO  [alembic.runtime.migration] Will assume transactional DDL.</p><p class="snippet">INFO  [alembic.runtime.migration] Running upgrade 7aafe51af016 -&gt; 91c7dc71b826, empty message</p></li>
				<li>Check the new <strong class="inline">cover_image</strong> column in pgAdmin:<div id="_idContainer236" class="IMG---Figure"><img src="image/C15309_07_10.jpg" alt="Figure 7.10: The cover_image column in pgAdmin&#13;&#10;"/></div><h6>Figure 7.10: The cover_image column in pgAdmin</h6><p>This confirms that the new <strong class="inline">cover_image</strong> column has been added to the recipe table.</p></li>
				<li>In <strong class="inline">schemas/recipe.py</strong>, <a id="_idTextAnchor520"/>import the <strong class="inline">url_for</strong> package and add the <strong class="inline">cover_url</strong> attribute and the <strong class="inline">dump_cover_url</strong> method:<p class="snippet">from flask import url_for</p><p class="snippet"><span class="None">    cover_url = fields.Method(serialize='dump_cover_url')</span></p><p class="snippet"><span class="None">    def dump_cover_url(self, recipe):</span></p><p class="snippet"><span class="None">        if recipe.cover_image:</span></p><p class="snippet">            return url_for('static', filename='images/recipes/{}'.format(recipe.cover_image), _external=True)</p><p class="snippet">        else:</p><p class="snippet">            return url_for('static', filename='images/assets/default-recipe-cover.jpg', _external=True)</p><p>Add the <strong class="inline">default-recipe-cover.jpg</strong> image to <strong class="inline">static/images</strong>:</p><div id="_idContainer237" class="IMG---Figure"><img src="image/C15309_07_11.jpg" alt="Figure 7.11: Folder structure after adding default-recipe-cover.jpg&#13;&#10;"/></div><h6>Figure 7.11: Folder structure after adding default-recipe-cover.jpg</h6></li>
				<li>In <strong class="inline">resources/recipe.py</strong>,<a id="_idTextAnchor521"/> add the import <strong class="inline">os</strong>, <strong class="inline">image_set</strong>, and <strong class="inline">save_image</strong> functions:<p class="snippet">import os</p><p class="snippet">from extensions import image_set</p><p class="snippet">from utils import save_image</p><p class="snippet">In resources/recipe.py,<a id="_idTextAnchor522"/><a id="_idTextAnchor523"/> add recipe_cover_schema, which just shows the cover_url column:</p><p class="snippet">recipe_cover_schema = RecipeSchema(only=('cover_url', ))</p></li>
				<li>In <strong class="inline">resources/recipe.py<a id="_idTextAnchor524"/></strong>,<a id="_idTextAnchor525"/> add the <strong class="inline">RecipeCoverUpload</strong> resource to upload the recipe cover to the recipes folder:<p class="snippet">    class RecipeCoverUploadResource(Resource):</p><p class="snippet">        @jwt_required</p><p class="snippet">        def put(self, recipe_id):</p><p class="snippet">            file = request.files.get('cover')</p><p class="snippet">            if not file:</p><p class="snippet">                return {'message': 'Not a valid image'}, HTTPStatus.BAD_REQUEST</p><p class="snippet">            if not image_set.file_allowed(file, file.filename):</p><p class="snippet">                return {'message': 'File type not allowed'}, HTTPStatus.BAD_REQUEST</p><p>The <strong class="inline">@jwt_required</strong> decorator before the <strong class="inline">PUT</strong> method states that the method can only be called after the user logs in. In the <strong class="inline">PUT</strong> method, we are trying to get the cover image file in <strong class="inline">request.files</strong>. Then, we are trying to verify whether it exists and whether the file extension is permitted.</p></li>
				<li>After that, we retrieved the recipe object using <strong class="inline">recipe_id</strong>. First, we check whether a user has the right to modify the recipe. If the user has the right to, we will go ahead and modify the cover image of the recipe:<p class="snippet">            recipe = Recipe.get_by_id(recipe_id=recipe_id)</p><p class="snippet">            if recipe is None:</p><p class="snippet">                return {'message': 'Recipe not found'}, HTTPStatus.NOT_FOUND</p><p class="snippet">            current_user = get_jwt_identity()</p><p class="snippet">            if current_user != recipe.user_id:</p><p class="snippet">                return {'message': 'Access is not allowed'}, HTTPStatus.FORBIDDEN</p><p class="snippet">            if recipe.cover_image:</p><p class="snippet">                cover_path = image_set.path(folder='recipes', filename=recipe.cover_image)</p><p class="snippet">                if os.path.exists(cover_path):</p><p class="snippet">                    os.remove(cover_path)</p></li>
				<li>Then, we use the <strong class="inline">save_image</strong> function to save the uploaded image and set the <strong class="inline">recipe.cover_image = filename</strong>. Finally, we save the recipe using <strong class="inline">recipe.save()</strong> and return the image URL with an HTTP status code of <strong class="bold">200</strong>:<p class="snippet">            filename = save_image(image=file, folder='recipes')</p><p class="snippet">            recipe.cover_image = filename</p><p class="snippet">            recipe.save()</p><p class="snippet">            return recipe_cover_schema.dump(recipe).data, HTTPStatus.OK</p></li>
				<li>In <strong class="inline">app.py</strong>, import Recip<a id="_idTextAnchor526"/>eCoverUploadResource:<p class="snippet">from resources.recipe import RecipeListResource, RecipeResource, RecipePublishResource, RecipeCoverUploadResource</p></li>
				<li>In <strong class="inline">app.py</strong>, link <strong class="inline">Recipe<a id="_idTextAnchor527"/>C<a id="_idTextAnchor528"/>overUploadResource</strong> to the route, that is, <strong class="inline">/recipes/&lt;int:recipe_id&gt;/cover</strong>:<p class="snippet">api.add_resource(RecipeCoverUploadResource, '/recipes/&lt;int:recipe_id&gt;/cover')</p></li>
			</ol>
			<p>Now, we have created the function for uploading the recipe cover image. Let's move on and test it.</p>
			<h3 id="_idParaDest-229"><a id="_idTextAnchor529"/>Activity 12: Testing the Image Upload Function</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Log in to the user account using Postman. Click on the <strong class="bold">Collections</strong> tab and select the <strong class="bold">POST Token</strong> request. Then, click the <strong class="bold">Send</strong> button. The result can be seen in the following screenshot:<div id="_idContainer238" class="IMG---Figure"><img src="image/C15309_07_12.jpg" alt="Figure 7.12: Sending a POST Token request&#13;&#10;"/></div><h6>Figure 7.12: Sending a POST Token request</h6></li>
				<li>Send a client request to<a id="_idTextAnchor530"/> our API to create a recipe and click on the <strong class="bold">Collections</strong> tab.</li>
				<li>Select the <strong class="bold">POST RecipeList</strong> request and put <strong class="inline">Authorization</strong> in the <strong class="bold">KEY</strong> field and <strong class="inline">Bearer {token}</strong> in the <strong class="bold">VALUE</strong> field, where the token is the access token we retrieved in the previous step. Then, click the <strong class="bold">Send</strong> button. The result can be seen in the following screenshot:<div id="_idContainer239" class="IMG---Figure"><img src="image/C15309_07_13.jpg" alt="Figure 7.13: Sending a client request to our API to create a recipe&#13;&#10;"/></div><h6>Figure 7.13: Sending a client request to our API to create a recipe</h6></li>
				<li>Upload the recipe images. Click on the <strong class="bold">Collections</strong> tab and right-click on <strong class="bold">...</strong> next to the <strong class="inline">Recipe</strong> folder to create a new request.</li>
				<li>Set the <strong class="bold">Request Name</strong> to <strong class="inline">RecipeCoverUpload</strong> and save it in the <strong class="inline">Recipe</strong> folder.</li>
				<li>Select <strong class="inline">PUT</strong> as the HTTP method and type in <strong class="inline">http://localhost:5000/recipes/&lt;recipe_id&gt;/cover</strong> as the request URL (replace <strong class="inline">&lt;recipe_id&gt;</strong> with the recipe ID we got from the previous step).</li>
				<li>Select the <strong class="bold">Headers</strong> tab and put <strong class="inline">Authorization</strong> in the <strong class="bold">KEY</strong> field and <strong class="inline">Bearer {token}</strong> in the <strong class="bold">VALUE</strong> field, where the token is the access token we retrieved in the previous step.</li>
				<li>Select the <strong class="bold">Body</strong> tab. Then, select the form-data radio button and type cover into <strong class="bold">KEY</strong>.</li>
				<li>Choose <strong class="bold">File</strong> in the drop-down menu next to <strong class="bold">KEY</strong> and select the image file to upload.</li>
				<li>Click the <strong class="bold">Save</strong> button and then the <strong class="bold">Send</strong> button. The result can be seen in the following screenshot:<div id="_idContainer240" class="IMG---Figure"><img src="image/C15309_07_14.jpg" alt="Figure 7.14: Uploading a recipe image&#13;&#10;"/></div><h6>Figure 7.14: Uploading a recipe image</h6></li>
				<li>Check whether the image has been compressed in PyCharm. We can see from the application log in PyCharm that the file size has been reduced by <strong class="inline">97%</strong>:<div id="_idContainer241" class="IMG---Figure"><img src="image/C15309_07_15.jpg" alt="Figure 7.15: Checking whether the images are compressed in PyCharm&#13;&#10;"/></div><h6>Figure 7.15: Checking whether the images are compressed in PyCharm</h6></li>
				<li>Check the uploaded image in <strong class="inline">static/images/recipes</strong>:<div id="_idContainer242" class="IMG---Figure"><img src="image/C15309_07_16.jpg" alt="Figure 7.16: Checking the uploaded image in the path&#13;&#10;"/></div><h6>Figure 7.16: Checking th<a id="_idTextAnchor531"/>e uploaded image in the path</h6></li>
				<li>Get the recipe back and confirm that the <strong class="inline">cover_url</strong> attribute is populated. Now, click on the <strong class="bold">Collections</strong> tab and select the <strong class="bold">GET Recipe</strong> request. Then, type <strong class="inline">http://localhost:5000/recipes/5</strong> into the <strong class="bold">URL</strong> field. You may replace the recipe ID, that is, 5, with any ID that is appropriate. Then, click the <strong class="bold">Send</strong> button. The result can be seen in the following screenshot:<div id="_idContainer243" class="IMG---Figure"><img src="image/C15309_07_17.jpg" alt="Figure 7.17: Getting the recipe back and confirming that the cover_url attribute is populated&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 7.17: Getting the recipe back and confirming that the cover_url attribute is populated</h6>
			<p>Congratulations! We have tested the recipe cover image upload function. It works great!</p>
			<h2 id="_idParaDest-230">8: Pagination, Searching, and Ordering</h2>
			<h3 id="_idParaDest-231"><a id="_idTextAnchor532"/>Activity 13: Implementing Pagination on the User-Specific Recipe Retrieval API</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Modify the code in the <strong class="inline">get_all_by_user</strong> method under <strong class="inline">models/recipe.py</strong>, as follows:<p class="snippet">    @classmethod</p><p class="snippet">    def get_all_by_user(cls, user_id, page, per_page, visibility='public'):</p><p class="snippet">        query = cls.query.filter_by(user_id=user_id)</p><p class="snippet">        if visibility == 'public':</p><p class="snippet">            query = cls.query.filter_by(user_id=user_id, is_publish=True)</p><p class="snippet">        elif visibility == 'private':</p><p class="snippet">            query = cls.query.filter_by(user_id=user_id, is_publish=False)</p><p class="snippet">        return query.order_by(desc(cls.created_at)).paginate(page=page, per_page=per_page)</p></li>
				<li>Import <strong class="inline">RecipePaginationSchema</strong> into <strong class="inline">resources/user.py</strong>:<p class="snippet">from schemas.recipe import RecipeSchema, RecipePaginationSchema</p></li>
				<li>Declare the <strong class="inline">recipe_pagination_schema</strong> attribute in <strong class="inline">resources/user.py</strong>:<p class="snippet">recipe_pagination_schema = RecipePaginationSchema()</p></li>
				<li>Here, we've added the <strong class="inline">@user_kwargs</strong> decorator to <strong class="inline">UserRecipeListResource.get</strong>. It takes a few parameters, including <strong class="inline">page</strong>, <strong class="inline">per_page</strong>, and <strong class="inline">visibility</strong>:<p class="snippet">class UserRecipeListResource(Resource):</p><p class="snippet">    @jwt_optional</p><p class="snippet">    @use_kwargs({'page': fields.Int(missing=1),</p><p class="snippet">                 'per_page': fields.Int(missing=10),</p><p class="snippet">                 'visibility': fields.Str(missing='public')})</p></li>
				<li>Modify the <strong class="inline">UserRecipeListReso<a id="_idTextAnchor533"/>urce.get</strong> method in <strong class="inline">resources/user.py</strong>:<p class="snippet">    def get(self, username, page, per_page, visibility):</p><p class="snippet">        user = User.get_by_username(username=username)</p><p class="snippet">        if user is None:</p><p class="snippet">            return {'message': 'User not found'}, HTTPStatus.NOT_FOUND</p><p class="snippet">        current_user = get_jwt_identity()</p><p class="snippet">        if current_user == user.id and visibility in ['all', 'private']:</p><p class="snippet">            pass</p><p class="snippet">        else:</p><p class="snippet">            visibility = 'public'</p><p class="snippet">        paginated_recipes = Recipe.get_all_by_user(user_id=user.id, page=page, per_page=per_page, visibility=visibility)</p><p class="snippet">        return recipe_pagination_schema.dump(paginated_recipes).data, HTTPStatus.OK</p><p>The <strong class="inline">Recipe.get_all_by_user</strong> method gets the paginated recipes by a particular author, and then lets <strong class="inline">recipe_pagination_schema</strong> serialize the paginated object and return it.</p></li>
			</ol>
			<h3 id="_idParaDest-232"><a id="_idTextAnchor534"/>Activity 14: Testing Pagination on the User-Specific Recipe Retrieval API</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Get all the recipes under John using Postman, page by page, with a page size of two. First, click on the <strong class="inline">UserRecipeList</strong> request.</li>
				<li>Type <strong class="inline">http://localhost:5000/{username}/recipes</strong> into the <strong class="bold">Request </strong>URL. The <strong class="inline">{username}</strong> here should be the same as the one we inserted in the previous exercise. In our case, it will be <strong class="inline">john</strong>.</li>
				<li>Select the <strong class="bold">Params</strong> tab and put in the key-value pair (<strong class="inline">per_page</strong>, <strong class="inline">2</strong>).</li>
				<li>Send the request. The result is shown in the following screenshot:<div id="_idContainer244" class="IMG---Figure"><img src="image/C15309_08_09.jpg" alt="Figure 8.9: Getting all the recipes under John using Postman&#13;&#10;"/></div><h6>Figure 8.9: Getting all the recipes under John using Postman</h6><p>In the details of the recipe, we can see that there are links with the URLs of the <strong class="inline">first</strong>, <strong class="inline">last</strong>, and <strong class="inline">next</strong> pages. We can't see the <strong class="bold">prev</strong> page here because we are on the first page. There is a total of four pages, and we have two records per page. We can also see the sorted recipe details in the HTTP response.</p></li>
				<li>Click the next URL in links to query for the next two records in Postman with the request URL populated (<strong class="inline">http://localhost:5000/users/john/recipes?per_page=2&amp;page=2</strong>). Then, we just need to click on <strong class="bold">Send</strong> to send the request. The result is shown in the following screenshot:<div id="_idContainer245" class="IMG---Figure"><img src="image/C15309_08_10.jpg" alt="Figure 8.10: Querying for the next two records in Postman with the request URL populated&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 8.10: Querying for the next two records in Postman with the request URL populated</h6>
			<p>From the result, we can see that there are links to the <strong class="inline">first</strong>, <strong class="inline">last</strong>, <strong class="inline">next</strong>, and <strong class="inline">prev</strong> pages. We can also see that we are currently on page two. All the recipe data is there as well.</p>
			<h3 id="_idParaDest-233"><a id="_idTextAnchor535"/>Activity 15: Searching for Recipes with Specific Ingredients</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">First, in <strong class="inline">models/recipe.py</strong>, add the <strong class="inline">ingredients</strong> attribute to the <strong class="inline">Recipe</strong> model:<p class="snippet">    ingredients = db.Column(db.String(1000))</p></li>
				<li>Run the following command to generate a database migration script:<p class="snippet">flask db migrate</p><p>You will see that a new column called <strong class="inline">recipe.ingredients</strong> has been detected:</p><p class="snippet">INFO  [alembic.autogenerate.compare] Detected added column 'recipe.ingredients'</p><p class="snippet">  Generating /TrainingByPackt/Python-API-Development-Fundamentals/smilecook/migrations/versions/0876058ed87e_.py ... done</p></li>
				<li>Check the content in <strong class="inline">/migrations/versions/0876058ed87e_.py</strong>, which is the database migration script that was generated in the previous step:<p class="snippet">"""empty message</p><p class="snippet"> </p><p class="snippet">Revision ID: 0876058ed87e</p><p class="snippet">Revises: 91c7dc71b826</p><p class="snippet">Create Date: 2019-10-24 15:05:10.936752</p><p class="snippet"> </p><p class="snippet">"""</p><p class="snippet">from alembic import op</p><p class="snippet">import sqlalchemy as sa</p><p class="snippet"> </p><p class="snippet"># revision identifiers, used by Alembic.</p><p class="snippet">revision = '0876058ed87e'</p><p class="snippet">down_revision = '91c7dc71b826'</p><p class="snippet">branch_labels = None</p><p class="snippet">depends_on = None</p><p class="snippet"> </p><p class="snippet">def upgrade():</p><p class="snippet">    # ### commands auto generated by Alembic - please adjust! ###</p><p class="snippet">    op.add_column('recipe', sa.Column('ingredients', sa.String(length=1000), nullable=True))</p><p class="snippet">    # ### end Alembic commands ###</p><p class="snippet"> </p><p class="snippet">def downgrade():</p><p class="snippet">    # ### commands auto-generated by Alembic - please adjust! ###</p><p class="snippet">    op.drop_column('recipe', 'ingredients')</p><p class="snippet">    # ### end Alembic commands ###</p><p>Here, we can see that two functions have been generated in the script. The <strong class="inline">upgrade</strong> function is used to add the new column, <strong class="inline">ingredients</strong>, to the recipe table, whereas the <strong class="inline">downgrade</strong> function is used to remove the <strong class="inline">ingredients</strong> column so that it goes back to its original state.</p></li>
				<li>Run the following <strong class="inline">flask db upgrade</strong> command to update the database schema:<p class="snippet">flask db upgrade</p><p>You will see the following output:</p><p class="snippet">INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.</p><p class="snippet">INFO  [alembic.runtime.migration] Will assume transactional DDL.</p><p class="snippet">INFO  [alembic.runtime.migration] Running upgrade 91c7dc71b826 -&gt; 0876058ed87e, empty message</p></li>
				<li>In <strong class="inline">schemas/recipe.py</strong>, add the <strong class="inline">ingredients</strong> attribute to <strong class="inline">RecipeSchema</strong>:<p class="snippet">        ingredients = fields.String(validate=[validate.Length(max=1000)])</p></li>
				<li>Modify the <strong class="inline">RecipeResource.patch</strong> method in <strong class="inline">resources/recipe.py</strong> to be able to update <strong class="inline">ingredients</strong>:<p class="snippet">recipe.ingredients = data.get('ingredients') or recipe.ingredients</p></li>
				<li>Modify the <strong class="inline">Recipe.get_all_published</strong> method in <strong class="inline">models/recipe.py</strong> so that it gets all the published recipes that it can through the ingredients:<p class="snippet">return cls.query.filter(or_(cls.name.ilike(keyword),</p><p class="snippet">                   cls.description.ilike(keyword),</p><p class="snippet">                   cls.ingredients.ilike(keyword)),</p><p class="snippet">                 cls.is_publish.is_(True)).\</p><p class="snippet">  order_by(sort_logic).paginate(page=page, per_page=per_page)</p></li>
				<li><strong class="inline">Right-click</strong> on it to run the application. Flask will then start up and run on <strong class="inline">localhost</strong> (<strong class="inline">127.0.0.1</strong>) at port <strong class="inline">5000</strong>:<div id="_idContainer246" class="IMG---Figure"><img src="image/C15309_03_07.jpg" alt="Figure 8.11: Running Flask on the localhost&#13;&#10;"/></div><h6>Figure 8.11: Running Flask on the localhost</h6></li>
				<li>Log in to a user account and create two recipes by running the following <strong class="inline">httpie</strong> command in the PyCharm console. The <strong class="inline">{token}</strong> placeholder should be replaced with the access token:<p class="snippet">http POST localhost:5000/recipes "Authorization: Bearer <strong class="inline">{token}</strong>" name="Sweet Potato Casserole" description="This is a lovely Sweet Potato Casserole" num_of_servings=12 cook_time=60 ingredients="4 cups sweet potato, 1/2 cup white sugar, 2 eggs, 1/2 cup milk" directions="This is how you make it"</p><p class="snippet">http POST localhost:5000/recipes "Authorization: Bearer <strong class="inline">{token}</strong>" name="Pesto Pizza" description="This is a lovely Pesto Pizza" num_of_servings=6 cook_time=20 ingredients="1 pre-baked pizza crust, 1/2 cup pesto, 1 ripe tomato" directions="This is how you make it"</p></li>
				<li>Publish these two recipes by using the following <strong class="inline">httpie</strong> command:<p class="snippet">http PUT localhost:5000/recipes/14/publish "Authorization: Bearer <strong class="inline">{token}</strong>"</p><p class="snippet">http PUT localhost:5000/recipes/15/publish "Authorization: Bearer <strong class="inline">{token}</strong>"</p></li>
				<li>Search for recipes that contain the <strong class="inline">eggs</strong> string in the name, description, or ingredients. Click on the <strong class="inline">RecipeList</strong> request and select the <strong class="bold">Params</strong> tab. Then, insert the first key-value pair (<strong class="inline">q</strong>, <strong class="inline">eggs</strong>) and send the request. The result is shown in the following screenshot:<div id="_idContainer247" class="IMG---Figure"><img src="image/C15309_08_12.jpg" alt="Figure 8.12: Searching for the eggs ingredient by sending a request&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 8.12: Searching for the eggs ingredient by sending a request</h6>
			<p>From the preceding search result, we can see that there is a recipe with eggs in the ingredients.</p>
			<h2 id="_idParaDest-234">9: Building More Features</h2>
			<h3 id="_idParaDest-235">Activity <a id="_idTextAnchor536"/>16: Getting Cache Data after Updating Recipe Details</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Get all the recipe data back, click on <strong class="inline">RecipeList</strong> and send the request. The result is shown in the following screenshot:<div id="_idContainer248" class="IMG---Figure"><img src="image/C15309_09_15.jpg" alt="Figure 9.15: Get the recipe data back and send the request&#13;&#10;"/></div><h6>Figure 9.15: Get the recipe data back and send the request</h6></li>
				<li>Log in to your account, click on the <strong class="bold">Collections</strong> tab and select the <strong class="bold">POST</strong> <strong class="bold">Token</strong> request. Then, send the request. The result is shown in the following screenshot:<div id="_idContainer249" class="IMG---Figure"><img src="image/C15309_09_16.jpg" alt="Figure 9.16: Select the POST Token request and send it&#13;&#10;"/></div><h6>Figure 9.16: Select the POST Token request and send it</h6></li>
				<li>Modify a recipe record using the <strong class="inline">PATCH</strong> method. First, select the <strong class="inline">PATCH Recipe</strong> request.</li>
				<li>Now select the <strong class="bold">Headers</strong> tab and modify <strong class="inline">Bearer {token}</strong>; the token should be the access token.</li>
				<li>Select the <strong class="bold">Body</strong> tab and modify <strong class="inline">num_of_servings</strong> to <strong class="inline">5</strong>, and <strong class="inline">cook_time</strong> to <strong class="inline">50</strong>:<p class="snippet">{ </p><p class="snippet">    "num_of_servings": 5, </p><p class="snippet">    "cook_time": 50 </p><p class="snippet">} </p></li>
				<li>Send the request. The result is shown in the following screenshot:<div id="_idContainer250" class="IMG---Figure"><img src="image/C15309_09_17.jpg" alt="Figure 9.17: Modifying a recipe record using the PATCH method&#13;&#10;"/></div><h6>Figure 9.17: Modifying a recipe record using the PATCH method</h6></li>
				<li>Get all the recipe data back again, click on <strong class="inline">RecipeList</strong>.</li>
				<li>Send the request. The result is shown in the following screenshot:<div id="_idContainer251" class="IMG---Figure"><img src="image/C15309_09_18.jpg" alt="Figure 9.18: Get all the recipe data back again&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 9.18: Get all the recipe data back again</h6>
			<p>We can see that when we get all the recipe details again, the details are not updated, which will cause the user to see the wrong information.</p>
			<h3 id="_idParaDest-236"><a id="_idTextAnchor537"/>Activity 17: Adding Multiple Rate-Limit Restrictions</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">In <strong class="inline">resources/user.py</strong>, import <strong class="inline">limiter</strong> from <strong class="inline">extensions</strong>:<p class="snippet">from extensions import image_set, limiter</p></li>
				<li>In <strong class="inline">UserRecipeListResource</strong>, put the <strong class="inline">limiter.limit</strong> function in the <strong class="inline">decorators</strong> attribute:<p class="snippet">class UserRecipeListResource (Resource):</p><p class="snippet">    decorators = [limiter.limit('3/minute;30/hour;300/day', methods=['GET'], error_message='Too Many Requests')]</p></li>
				<li>Comment out the whitelist in <strong class="inline">app.py</strong>:<p class="snippet">#  @limiter.request_filter</p><p class="snippet">#   def ip_whitelist():</p><p class="snippet">#      return request.remote_addr == '127.0.0.1'</p><p>In PyCharm, to comment out a line of code, if you are using Mac, you can use <em class="italics">Command + /</em>, and if you are using Windows, you can use <em class="italics">Ctrl + /</em>.</p></li>
				<li>When we are done, click <strong class="bold">Run</strong> to start the Flask application; then, we are ready to test it:<div id="_idContainer252" class="IMG---Figure"><img src="image/C15309_09_19.jpg" alt="Figure 9.19: Starting the Flask application&#13;&#10;"/></div><h6>Figure 9.19: Starting the Flask application</h6></li>
				<li>Get all the recipes for a user and check the rate limit information in the response header. First, click on <strong class="inline">UserRecipeList</strong> and send the request.</li>
				<li>Then, select the <strong class="bold">Header</strong> tab in <strong class="bold">Response</strong>. The result is shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer253" class="IMG---Figure">
					<img src="image/C15309_09_20.jpg" alt="Figure 9.20: Checking the rate limit information in the response header&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 9.20: Checking the rate limit information in the response header</h6>
			<p>In the HTTP response, we can see that the rate limit for this endpoint is three, while we only have two remaining request quotas. The limit is going to be reset in 60 seconds.</p>
			<h2 id="_idParaDest-237">10: Deployment</h2>
			<h3 id="_idParaDest-238">Activity 18: Changing access_token to <a id="_idTextAnchor538"/>a Variable in Postman</h3>
			<p><strong class="bold">Solution</strong></p>
			<ol>
				<li value="1">Perform user login and get the access t<a id="_idTextAnchor539"/>oken. Use the <strong class="bold">POST Token</strong> request to get the access token. You should see the following output:<div id="_idContainer254" class="IMG---Figure"><img src="image/C15309_10_29.jpg" alt="Figure 10.26: Performing user login to get an access token&#13;&#10;"/></div><h6>Figure 10.29: Performing user login to get an access token</h6></li>
				<li>Click <strong class="bold">Manage environments</strong> in the top rig<a id="_idTextAnchor540"/>ht-hand corner in Postman. Create the <strong class="inline">access_token</strong> variable. The value is the access token we obtained in the previous step. Then, click <strong class="bold">Update</strong>:<div id="_idContainer255" class="IMG---Figure"><img src="image/C15309_10_30.jpg" alt="Figure 10.27: Adding more environment variables in Postman&#13;&#10;"/></div><h6>Figure 10.30: Adding more environment v<a id="_idTextAnchor541"/>ariables in Postman</h6></li>
				<li>Select the <strong class="bold">GET</strong> <strong class="bold">User</strong> request. In the <strong class="bold">Headers</strong> tab, change the <strong class="bold">Authorization</strong> value to <strong class="inline">Bearer {{access_token}}</strong>, which is the environment variable we added in the previous step, and then send the request. You should see the following output:<div id="_idContainer256" class="IMG---Figure"><img src="image/C15309_10_31.jpg" alt="Figure 10.28: Using more environment variables in Postman"/></div></li>
			</ol>
			<h6>Figure 10.31: Using more environment variables in Postman</h6>
		</div>
	</body></html>