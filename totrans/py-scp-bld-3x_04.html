<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer087">
<h1 class="chapter-number" id="_idParaDest-73"><a id="_idTextAnchor075"/>4</h1>
<h1 id="_idParaDest-74"><a id="_idTextAnchor076"/>Exploring Object Transformations</h1>
<p>The ability to change an object’s location, rotation, and dimension in a space is a tenet of any <span class="No-Break">animation software.</span></p>
<p>Artists are used to changing the values of transform channels to carry out these operations. More technical users are aware of the geometric implications of <span class="No-Break">such actions.</span></p>
<p>In this chapter, we will learn how Object Transformations work and how to implement them in our script. We will also learn how to add object constraints programmatically and how Blender can carry out the more difficult operations <span class="No-Break">for us.</span></p>
<p>Finally, we will implement a new command that affects the transformation of more objects at once and accepts <span class="No-Break">user input.</span></p>
<p>This chapter will cover the following <span class="No-Break">key topics:</span></p>
<ul>
<li>Transforming objects, using coordinate notations, and <span class="No-Break">avoiding pitfalls</span></li>
<li>Applying object constraints <span class="No-Break">and hierarchies</span></li>
<li>Using <span class="No-Break">matrix representation</span></li>
<li>Adding interactive operators to <span class="No-Break">our add-ons</span></li>
</ul>
<h1 id="_idParaDest-75"><a id="_idTextAnchor077"/>Technical requirements</h1>
<p>We will use Blender and <strong class="bold">Visual Studio Code</strong> (<span class="No-Break"><strong class="bold">VS Code</strong></span><span class="No-Break">).</span></p>
<p>The examples created in this chapter can be found at the following <span class="No-Break">URL: </span><a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch4"><span class="No-Break">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch4</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor078"/>Moving objects in space</h1>
<p>Three-dimensional objects <a id="_idIndexMarker222"/>can be moved, rotated, and scaled. Since they do not change the geometry of an object, location and rotation are considered <strong class="bold">rigid transformations</strong>. Technically, changing the size of an object using its scale value <a id="_idIndexMarker223"/>applies a non-rigid transformation, but since the vertex geometry doesn’t change, scale is considered <a id="_idIndexMarker224"/>an object-level transformation and is displayed alongside location <span class="No-Break">and rotation.</span></p>
<p>In this section, we will use Python to transform objects <span class="No-Break">in Blender.</span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor079"/>Transforming objects</h2>
<p>An object is transformed <a id="_idIndexMarker225"/>by changing the values of its Location, Rotation, and Scale channels. Location and scale coordinates are immediately associated with the X, Y, and Z of the Cartesian space; rotations have more options as they come with <span class="No-Break">some implications.</span></p>
<h3>Affecting an object’s location</h3>
<p>We have already <a id="_idIndexMarker226"/>met the <strong class="source-inline">location</strong> attribute in <a href="B18375_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a> and <a href="B18375_02.xhtml#_idTextAnchor033"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>. If we have an active object, such as the cube from Blender’s default scene, the following lines will move it to the location with <em class="italic">x</em>, <em class="italic">y</em>, <em class="italic">z</em> coordinates <strong class="source-inline">1.0</strong>, <strong class="source-inline">2.0</strong>, and <strong class="source-inline">3.0</strong>. These lines <a id="_idIndexMarker227"/>use <strong class="bold">tuple assignment</strong> to set all three coordinates <span class="No-Break">at once:</span></p>
<pre class="source-code">
import bpy
bpy.context.object.location = 1.0, 2.0, 3.0</pre>
<p>Since Blender coordinates can also be assigned through letters, that expression is equivalent to <span class="No-Break">the following:</span></p>
<pre class="source-code">
import bpy
bpy.context.object.location.xyz = 1.0, 2.0, 3.0</pre>
<p>Coordinates are <a id="_idIndexMarker228"/>stored inside <strong class="bold">Vectors</strong>. Vector components can be <span class="No-Break">accessed separately:</span></p>
<pre class="source-code">
import bpy
bpy.context.object.location[0] = 1.0
bpy.context.object.location[1] = 2.0
bpy.context.object.location[2] = 3.0</pre>
<p>Alternatively, they can be accessed <span class="No-Break">as follows:</span></p>
<pre class="source-code">
import bpy
bpy.context.object.location.x = 1.0
bpy.context.object.location.y = 2.0
bpy.context.object.location.z = 3.0</pre>
<p>Location and <a id="_idIndexMarker229"/>Scale are both stored <span class="No-Break">as Vectors.</span></p>
<h3>Affecting object scale</h3>
<p>Like with location, the <a id="_idIndexMarker230"/>three dimensions of scale are accessed through the <span class="No-Break"><strong class="source-inline">Vector</strong></span><span class="No-Break"> coordinates:</span></p>
<pre class="source-code">
&gt;&gt;&gt; bpy.context.object.scale
Vector((1.0, 1.0, 1.0))</pre>
<p>We can assign a non-uniform scale to an object, such as a different value for <span class="No-Break">each axis:</span></p>
<pre class="source-code">
import bpy
bpy.context.object.scale.xyz = 3.0, 2.0, 1.0</pre>
<p>The scale of an object is more often uniform, meaning it is the same on each axis. Blender Vectors provide a convenient way for assigning <span class="No-Break">uniform values:</span></p>
<pre class="source-code">
import bpy
bpy.context.object.scale.xyz = 3.0</pre>
<p>Like with <strong class="source-inline">location</strong>, <strong class="source-inline">scale</strong> coordinates can be set individually or together. The rest values are different, by the way: the scale at rest is <strong class="source-inline">[1.0, 1.0, 1.0]</strong> rather than <strong class="source-inline">[0.0, 0.0, 0.0]</strong>. That reflects how scaling is a multiplicative operation while location <span class="No-Break">is additive.</span></p>
<p>Rotations are less immediate to combine. We will see that there are different ways to represent rotations in the <span class="No-Break">first place.</span></p>
<h3>Affecting object rotations</h3>
<p>Using rotations, we <a id="_idIndexMarker231"/>can orient an object around the <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> axes. Doing that will give objects an orientation of their own, with their own <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> <span class="No-Break">local axes.</span></p>
<p>We refer to these new axes, aligned with the object, as <strong class="bold">Local Orientation</strong>. Blender lets the user <a id="_idIndexMarker232"/>choose between different axes for transforming objects. The axes <a id="_idIndexMarker233"/>aligned with the <a id="_idIndexMarker234"/>viewport grid are the <strong class="bold">Global Orientation</strong> or <span class="No-Break"><strong class="bold">World Axes</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<img alt="Figure 4.1: Rotation rings and axes of an object at rest and after a rotation" height="181" src="image/Figure_4.01_B18375.jpg" width="528"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1: Rotation rings and axes of an object at rest and after a rotation</p>
<p>Even if an object was rotated, we can still change <strong class="bold">Rotation Mode</strong> in the viewport top bar and use <span class="No-Break"><em class="italic">Global Orientation</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<img alt="Figure 4.2: A rotated airplane still using Global Orientation" height="563" src="image/Figure_4.02_B18375.jpg" width="853"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2: A rotated airplane still using Global Orientation</p>
<p>Rotations are more <a id="_idIndexMarker235"/>complex than translation and scale: by definition, a rotation involves a pivot and a constant distance. For that reason, rotations are affected by some minor issues that require <span class="No-Break">extra consideration.</span></p>
<h4>Issues related to rotations</h4>
<p>Because of their composite <a id="_idIndexMarker236"/>nature, rotations around one axis can change the rotation value on another. To sum that up, rotation is described as a three-dimensional property with only two <strong class="bold">degrees of freedom</strong>, as no more than two channels have the chance to <span class="No-Break">change freely.</span></p>
<p>Also, the order in which rotations are stacked together changes the result. To visualize a rotated object correctly, we need to know which axes were rotated first, that is, the <span class="No-Break"><strong class="bold">rotation order</strong></span><span class="No-Break">.</span></p>
<p>We could just stick with one rotation order, say <em class="italic">x</em>, then <em class="italic">y</em>, and then <em class="italic">z</em>, but that would limit our options against another potential shortcoming: three-dimensional rotations that overlap one axis <a id="_idIndexMarker237"/>with another end up making one coordinate useless, a well-known problem known as <span class="No-Break"><strong class="bold">gimbal lock</strong></span><span class="No-Break">.</span></p>
<p>Since different rotation orders lock at different angles, changing the order helps cope with <span class="No-Break">the issue.</span></p>
<p>These problems aren't specific to Blender or any other animation software; they are inherent properties of three-dimensional spaces, up to and including the one that <span class="No-Break">we inhabit.</span></p>
<p>To work around them, rotations provide a wider range of options. In addition to different orders for combining the three angles, there are also abstract representations such as quaternions. This terminology might sound scary at first, but it will become more familiar as we proceed with <span class="No-Break">the chapter.</span></p>
<h4>Changing rotation mode</h4>
<p>The <strong class="bold">Rotation Mode</strong> box <a id="_idIndexMarker238"/>in <strong class="bold">Transform Properties</strong> displays the available options for <span class="No-Break">rotating objects:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<img alt="Figure 4.3: Rotation modes" height="471" src="image/Figure_4.03_B18375.jpg" width="279"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3: Rotation modes</p>
<p>We do not need to <a id="_idIndexMarker239"/>cover this topic in full here, but essentially the following provides a <span class="No-Break">brief introduction:</span></p>
<ul>
<li><strong class="bold">Quaternions</strong>: These are mathematic <a id="_idIndexMarker240"/>notations that use four coefficients: in Blender, <strong class="bold">W</strong>, <strong class="bold">X</strong>, <strong class="bold">Y</strong>, and <strong class="bold">Z</strong>. Quaternions do not suffer from <span class="No-Break">gimbal lock.</span></li>
<li><strong class="bold">Euler angles</strong>: These list the angles on three rotation axes. It’s the common acceptance of rotation <a id="_idIndexMarker241"/>and comes with two caveats: the result depends on the axis order, and one axis might end up overlapping another. To mitigate the perils of losing a channel to gimbal lock, more combinations of <strong class="bold">X</strong>, <strong class="bold">Y</strong>, and <strong class="bold">Z</strong> <span class="No-Break">are allowed.</span></li>
<li><strong class="bold">Axis Angle</strong>: This uses <strong class="bold">X</strong>, <strong class="bold">Y,</strong> and <strong class="bold">Z</strong> to define a point as the rotation axis. The <strong class="bold">W</strong> attribute is the <a id="_idIndexMarker242"/>twisting angle in <span class="No-Break">said direction.</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer078">
<img alt="Figure 4.4: Rotation attributes for the Quaternion, Euler, and Axis Angle modes" height="253" src="image/Figure_4.04_B18375.jpg" width="1120"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4: Rotation attributes for the Quaternion, Euler, and Axis Angle modes</p>
<p>Changing this property in the interface changes the displayed channels. In Python, we need to use different attributes depending on the <span class="No-Break">current mode.</span></p>
<h4>Accessing rotations in Python</h4>
<p>The <strong class="source-inline">rotation_mode</strong> attribute <a id="_idIndexMarker243"/>specifies which system is being used to rotate an object. It is an <strong class="bold">enum</strong> attribute, that is, it contains a string that can only belong to a predefined set. Trying to assign an arbitrary string causes <strong class="source-inline">TypeError</strong>. The error message prints out the <span class="No-Break">allowed keywords:</span></p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.context.object.rotation_mode = "this won't work"
TypeError: bpy_struct: item.attr = val: enum "this won't work" not found in ('QUATERNION', 'XYZ', 'XZY', 'YXZ', 'YZX', 'ZXY', 'ZYX', 'AXIS_ANGLE')</pre>
<p>Each mode provides its attributes for <span class="No-Break">setting rotations:</span></p>
<ul>
<li><strong class="source-inline">QUATERNION</strong>: To affect the quaternion coefficients <em class="italic">W</em>, <em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z,</em> we use the <span class="No-Break">following, respectively:</span><ul><li><strong class="source-inline">rotation_quaternion.w</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">rotation_quaternion[0]</strong></span></li><li><strong class="source-inline">rotation_quaternion.x</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">rotation_quaternion[1]</strong></span></li><li><strong class="source-inline">rotation_quaternion.y</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">rotation_quaternion[2]</strong></span></li><li><strong class="source-inline">rotation_quaternion.z</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">rotation_quaternion[3]</strong></span></li></ul></li>
<li><strong class="source-inline">XYZ</strong>, <strong class="source-inline">XZY</strong>, <strong class="source-inline">YXZ</strong>, <strong class="source-inline">YZX</strong>, <strong class="source-inline">ZXY</strong>, and <strong class="source-inline">ZYX</strong> are Euler angles evaluated in different orders. No matter which one we choose, the Euler attributes for these are <span class="No-Break">the following:</span><ul><li><strong class="source-inline">rotation_euler.x</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">rotation_euler[0]</strong></span></li><li><strong class="source-inline">rotation_euler.y</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">rotation_euler[1]</strong></span></li><li><strong class="source-inline">rotation_euler.z</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">rotation_euler[2]</strong></span></li></ul></li>
</ul>
<p>We should set these values in radians.</p>
<ul>
<li><strong class="source-inline">AXIS_ANGLE</strong>: <em class="italic">Axis Angle – Axis Angle (W+XYZ)</em>, defines a rotation around some axis defined by 3D-Vector. We can set the torsion angle in radians via <span class="No-Break">the following:</span><ul><li><span class="No-Break"><strong class="source-inline">rotation_axis_angle[0]</strong></span></li></ul></li>
</ul>
<p>We can set the axis <a id="_idIndexMarker244"/>vector x, y, z coordinates using the following:</p>
<ul>
<li><span class="No-Break"><strong class="source-inline">rotation_axis_angle[1]</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">rotation_axis_angle[2]</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">rotation_axis_angle[3]</strong></span></li>
</ul>
<p>The <strong class="source-inline">math</strong> module provides some help in using radians as <span class="No-Break">angular units.</span></p>
<h4>Using radians and degrees</h4>
<p>Blender’s API describes angles of rotation using radians rather than degrees. Degrees express an angle <a id="_idIndexMarker245"/>using values between 0 and 360, while radians range <a id="_idIndexMarker246"/>between 0 and 2π. The Greek letter π (pi) refers to the ratio between a circle and its diameter. 2π (approximately 6.28) measures the arc of a full circle of <span class="No-Break">radius 1.0.</span></p>
<p>In Python, we can use the <strong class="source-inline">math</strong> module’s functions to convert between the two systems, <strong class="source-inline">radians()</strong> and <strong class="source-inline">degrees()</strong>, and the <strong class="source-inline">pi</strong> variable for quick access to the value <span class="No-Break">of π.</span></p>
<p>Take the <span class="No-Break">following example:</span></p>
<pre class="source-code">
&gt;&gt;&gt; from math import radians, degrees, pi
&gt;&gt;&gt; degrees(2 * pi)
360.0
&gt;&gt;&gt; radians(360)
6.283185307179586</pre>
<p>With that in mind, when we set rotations, we can convert angular units on <span class="No-Break">the fly.</span></p>
<h4>Setting rotation attributes</h4>
<p>Before we set <a id="_idIndexMarker247"/>a rotation in a script, we must ensure that we use the right rotation system. In the following snippet, we set the rotation <span class="No-Break">mode beforehand:</span></p>
<pre class="source-code">
import bpy
ob = bpy.context.object
# apply a 90 degrees on X axis rotation using Quaternions
ob.rotation_mode = 'QUATERNION'
ob.rotation_quaternion.w = 0.707107
ob.rotation_quaternion.x = 0.707107
ob.rotation_quaternion.y = 0.0
ob.rotation_quaternion.z = 0.0
# apply a 90 degrees on X axis rotation using Eulers
ob.rotation_mode = 'XYZ'
ob.rotation_euler.x = radians(90)
ob.rotation_euler.y = 0.0
ob.rotation_euler.z = 0.0
# apply a 90 degrees on X axis rotation using Axis Angle
ob.rotation_mode = 'AXIS_ANGLE'
ob.rotation_axis_angle[0] = radians(90)
ob.rotation_axis_angle[1] = 1
ob.rotation_axis_angle[1] = 0
ob.rotation_axis_angle[1] = 0</pre>
<p>When we change <strong class="source-inline">rotation_mode</strong>, Blender converts the current state to the selected system. That prevents an object from suddenly changing its orientation in space and works for most cases, but there are a few exceptions. For instance, animations have values set for <a id="_idIndexMarker248"/>each keyframe, so switching the rotation type of animated controls ends up changing the visual rotation during playback. In that case, we can use conversion methods in our scripts, as we will see in the next <span class="No-Break">Python snippet.</span></p>
<h4>Converting between rotation systems</h4>
<p>In the following <a id="_idIndexMarker249"/>snippet, we start with a <strong class="source-inline">Euler</strong> rotation and use conversion methods to change the <span class="No-Break">rotation mode:</span></p>
<pre class="source-code">
from mathutils import Euler
# create a 90 degrees rotation Euler
rot_90x_eu = Euler((radians(90), 0, 0))
# convert to quaternion
rot_90x_quat = rot_90x_eu.to_quaternion()
# convert to axis angle
rot_90x_aa = rot_90x_quat.to_axis_angle()</pre>
<p>At the time of writing, the Euler representation doesn’t have a <strong class="source-inline">to_axis_angle()</strong> method, so we <a id="_idIndexMarker250"/>convert to quaternion first. Using quaternions as a crossroad is common, as they are the most generic system for <span class="No-Break">expressing rotations.</span></p>
<p>Rotations can also be written down as a <strong class="bold">matrix</strong>. The matrix form is how all the transforms are stored internally. We will get to that after we have learned more about indirect transforms, that is, moving an object without changing <span class="No-Break">its channels.</span></p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor080"/>Transforming objects indirectly</h1>
<p>We have seen <a id="_idIndexMarker251"/>how to transform an object by altering its channels directly. There are two other ways to influence an object’s position, rotation, and scale. <strong class="bold">Object Constraints</strong> are special utilities that affect the transformation either by limiting certain values or by copying them from <span class="No-Break">another object.</span></p>
<p>Then there is the possibility to arrange more objects in a hierarchy via <strong class="bold">Parenting</strong>, that is, by making <a id="_idIndexMarker252"/>one object belong <span class="No-Break">to another.</span></p>
<p>We will see how these operations are reflected <span class="No-Break">in Python.</span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor081"/>Using Object Constraints</h2>
<p>Constraints can move, rotate, or scale an object without changing its transform properties. Some <a id="_idIndexMarker253"/>of them, such as <strong class="bold">Copy Transforms</strong>, override the object transform completely; others, such as <strong class="bold">Limit Distance</strong>, operate on top <span class="No-Break">of them.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<img alt="Figure 4.5: Blender constraints menu" height="414" src="image/Figure_4.05_B18375.jpg" width="769"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5: Blender constraints menu</p>
<p>Most constraints bind the transforms of more objects together, such as <strong class="bold">Copy Location</strong>, while <a id="_idIndexMarker254"/>others, such as <strong class="bold">Limit Location</strong>, have their own <span class="No-Break">transform attributes.</span></p>
<p>An object can have an unspecified number of constraints. The steps to add them in Python are very similar to how they work in the <span class="No-Break">graphic interface.</span></p>
<h3>Adding constraints in Python</h3>
<p>Constraints are <a id="_idIndexMarker255"/>exposed as a collection property of an object. They can be added by providing a constraint type to the <span class="No-Break"><strong class="source-inline">new(type)</strong></span><span class="No-Break"> method.</span></p>
<p>Much like with rotation mode, providing a wrong keyword will prompt an error and list the <span class="No-Break">available options:</span></p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.context.object.constraints.new("this won't work")
TypeError: ObjectConstraints.new(): error with keyword argument "type" -  enum " this won't work " not found in ('CAMERA_SOLVER', 'FOLLOW_TRACK', 'OBJECT_SOLVER', 'COPY_LOCATION', 'COPY_ROTATION', 'COPY_SCALE', 'COPY_TRANSFORMS', 'LIMIT_DISTANCE', 'LIMIT_LOCATION', ...</pre>
<p>The <strong class="source-inline">new</strong> method <a id="_idIndexMarker256"/>returns the created constraint, so we can easily access <span class="No-Break">its properties.</span></p>
<h3>Setting constraint attributes</h3>
<p>Different types <a id="_idIndexMarker257"/>of constraints have different attributes, but some common patterns exist. Most constraints will contain <span class="No-Break">these properties:</span></p>
<p><span class="No-Break"><strong class="bold">Boolean</strong></span><span class="No-Break"> switches:</span></p>
<ul>
<li><strong class="source-inline">.enabled</strong>: This <a id="_idIndexMarker258"/>enables/disables <span class="No-Break">a constraint</span></li>
<li><strong class="source-inline">.use_x</strong>, <strong class="source-inline">.use_y</strong>, <strong class="source-inline">.use_z</strong>: Use when available to enable/disable only <span class="No-Break">one axis</span></li>
<li><strong class="source-inline">.use_offset</strong>: Use when available to sum the constraint effect to the <span class="No-Break">transform channels</span></li>
</ul>
<ul>
<li>Object: Use <strong class="source-inline">.target</strong>, if available, to set the bind target of <span class="No-Break">the constraint</span></li>
<li>String: Use <strong class="source-inline">.subtarget</strong>, if available, to use only part of the target (e.g., a vertex group) for the <span class="No-Break">actual computation</span></li>
<li><span class="No-Break">Enum switches:</span><ul><li><strong class="source-inline">.target_space</strong>: This makes the constraint act at the <strong class="bold">Local</strong>, <strong class="bold">World</strong>, or <strong class="bold">Custom </strong><span class="No-Break"><strong class="bold">Object</strong></span><span class="No-Break"> level</span></li><li><strong class="source-inline">.owner_space</strong>: This changes the constraint source data to the <strong class="bold">Local</strong>, <strong class="bold">World,</strong> or <strong class="bold">Custom </strong><span class="No-Break"><strong class="bold">Object</strong></span><span class="No-Break"> level</span></li></ul></li>
</ul>
<p>Float number: Use <strong class="source-inline">.influence</strong> to convey only a fraction of <span class="No-Break">the effect</span></p>
<p>Some properties are specific <a id="_idIndexMarker259"/>to each type, such as the <strong class="source-inline">distance</strong> attribute of the <strong class="bold">Distance Constraint</strong>. In that case, their path can be traced by hovering over or right-clicking in the graphic interface (see the <em class="italic">Copying the data path section in</em> <a href="B18375_02.xhtml#_idTextAnchor033"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>) or from the API documentation (see the <em class="italic">Accessing Blender data</em> section in <a href="B18375_02.xhtml#_idTextAnchor033"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><span class="No-Break">).</span></p>
<h3>Limiting an object scale</h3>
<p>The following <a id="_idIndexMarker260"/>snippet adds a <strong class="bold">Limit Scale</strong> constraint that limits the maximum height of the <span class="No-Break">active object:</span></p>
<pre class="source-code">
import bpy
ob = bpy.context.object
limit = ob.constraints.new(type='LIMIT_SCALE')
limit.use_max_z = True  # limit the height only
limit.max_z = 0.5</pre>
<p>If applied to the default cube, it will halve its height as if a scale of <strong class="source-inline">[1.0, 1.0, 0.5]</strong> had been applied, despite its scale values still being <strong class="source-inline">[1.0, </strong><span class="No-Break"><strong class="source-inline">1.0, 1.0]</strong></span><span class="No-Break">.</span></p>
<p>Objects can be part of a hierarchy. In that case, they follow the objects that are higher in their hierarchical tree. We will explore this <span class="No-Break">concept next.</span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor082"/>Using object hierarchies</h2>
<p>Objects in the viewport <a id="_idIndexMarker261"/>can be arranged as <strong class="bold">children</strong> of other objects. In that case, they will be affected by the translation, rotation, and scale of <span class="No-Break">their </span><span class="No-Break"><strong class="bold">parent</strong></span><span class="No-Break">.</span></p>
<p>We can access hierarchical relationships in Python via the <strong class="source-inline">parent</strong>, <strong class="source-inline">children</strong>, and <strong class="source-inline">children_recursive</strong> attributes. Only the parent attribute is writable; the other two are only <span class="No-Break">for listing.</span></p>
<p>The difference between <strong class="source-inline">children</strong> and <strong class="source-inline">children_recursive</strong> is that the latter lists every affected object down the hierarchy, including children of children and all <span class="No-Break">the </span><span class="No-Break"><em class="italic">descendants</em></span><span class="No-Break">.</span></p>
<p>This snippet parents <a id="_idIndexMarker262"/>all the existing objects one under the other, then it prints <span class="No-Break">a report:</span></p>
<pre class="source-code">
import bpy
previous = bpy.data.objects[0]
for ob in bpy.data.objects[1:]:
    # parent each object under its predecessor
    ob.parent = previous
    previous = ob
for ob in bpy.data.objects:
    # now print out the children of each object
    print(ob.name)
    child_names = (c.name for c in ob.children)
    print("\tchildren:", ", ".join(child_names))
    child_names = (c.name for c in ob.children_recursive)
    print("\tchildren recursive:", ", ".join(child_names))
    print("")</pre>
<p>Running that code in the default scene brings the <span class="No-Break">following result:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<img alt="Figure 4.6: Default objects reparented in one hierarchy" height="385" src="image/Figure_4.06_B18375.jpg" width="525"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6: Default objects reparented in one hierarchy</p>
<p>This is reflected in the printout: the <a id="_idIndexMarker263"/>first object lists all the others as <em class="italic">grandchildren</em>, while <strong class="source-inline">children_recursive</strong> and <strong class="source-inline">children</strong> contain the same results for the last two, which have no <span class="No-Break">other descendants:</span></p>
<pre class="source-code">
Camera
        children: Cube
        children recursive: Cube, Light
Cube
        children: Light
        children recursive: Light
Light
        children:
        children recursive:</pre>
<p>If we look at the viewport, we can see that the object positions have changed: parenting an object in Python applies a new reference system instantly. To replicate that behavior, we need to understand the <span class="No-Break">transformation matrix.</span></p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor083"/>Understanding the transform matrix</h1>
<p>Three-dimensional transforms of Location, Rotation, and Scale are stored together inside a <strong class="bold">matrix</strong>. Matrices <a id="_idIndexMarker264"/>are, at large, tables of numbers arranged in rows and columns. Transformation matrices are combined using <strong class="bold">linear algebra</strong>. We will not go into the details <a id="_idIndexMarker265"/>here; we will just have a quick look at what a matrix means and how we can use it in <span class="No-Break">our scripts.</span></p>
<p>Like with other representations, Blender provides a <strong class="source-inline">Matrix</strong> class in the <span class="No-Break"><strong class="source-inline">mathutils</strong></span><span class="No-Break"> module:</span></p>
<pre class="source-code">
&gt;&gt;&gt; from mathutils import Matrix
&gt;&gt;&gt; Matrix()
Matrix(((1.0, 0.0, 0.0, 0.0),
        (0.0, 1.0, 0.0, 0.0),
        (0.0, 0.0, 1.0, 0.0),
        (0.0, 0.0, 0.0, 1.0)))</pre>
<p>A matrix containing these default values, <strong class="source-inline">1.0</strong> in its <em class="italic">diagonal</em> entries and <strong class="source-inline">0.0</strong> everywhere else, represents the <em class="italic">rest</em> state. In other words, an object associated with this matrix was not moved, rotated, <a id="_idIndexMarker266"/>or scaled. It is known as an <strong class="bold">identity matrix</strong>, as it leaves an object in its <span class="No-Break"><em class="italic">identical</em></span><span class="No-Break"> state.</span></p>
<p>Whenever an object is moved, rotated, or scaled, the entries of its matrix change to <span class="No-Break">different values.</span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor084"/>Accessing matrices</h2>
<p>Objects contain <a id="_idIndexMarker267"/>more than one matrix. Trying to reach an object matrix via autocompletion shows four <span class="No-Break">different attributes:</span></p>
<pre class="source-code">
&gt;&gt;&gt; bpy.context.object.matrix_
                              basis
                              local
                              parent_inverse
                              world</pre>
<p>Each of them covers a <span class="No-Break">specific aspect:</span></p>
<ul>
<li><strong class="source-inline">matrix_basis</strong>: This contains the local location, rotation, and scale of an object before it is transformed by object constraints. This matrix reflects the channels displayed in the <span class="No-Break">object properties.</span></li>
<li><strong class="source-inline">matrix_local</strong>: This contains the local location, rotation, and scale of an object, omitting the transformation inherited by the parent object but not the one resulting <span class="No-Break">from constraints.</span></li>
<li><strong class="source-inline">matrix_parent_inverse</strong>: Whenever we don’t want an object at rest to match its parent exactly, we add an offset inside <span class="No-Break">this matrix.</span></li>
<li><strong class="source-inline">matrix_world</strong>: This <a id="_idIndexMarker268"/>contains the final location, rotation, and scale in world coordinates, reflecting all the transformations to which an object <span class="No-Break">is subject.</span></li>
</ul>
<p>With that in mind, we can improve the <em class="italic">parent snippet</em> from the previous section and keep the object <span class="No-Break">positions intact.</span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor085"/>Storing object matrices</h2>
<p>Assigning a parent <a id="_idIndexMarker269"/>relationship via Python previously has snapped every object to its <span class="No-Break">parent positions.</span></p>
<p>We want them to maintain their visual transformation after the change in hierarchy. In matrix terms, we are saying that we want to keep their world matrix unchanged. To do that, we will learn how to store a <span class="No-Break">matrix properly.</span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor086"/>Copying matrices</h2>
<p>Python variables <a id="_idIndexMarker270"/>containing single values store their own data. Variables with aggregate values such as lists, dictionaries, and Blender <strong class="source-inline">mathutils</strong> types point to shared references of <span class="No-Break">their values.</span></p>
<p>Let’s look at the following example. The <strong class="source-inline">b</strong> variable has the same value as <strong class="source-inline">a</strong>. After <strong class="source-inline">a</strong> is changed to <strong class="source-inline">5</strong>, <strong class="source-inline">b</strong> is <span class="No-Break">still </span><span class="No-Break"><strong class="source-inline">4</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&gt;&gt;&gt; a = 4
&gt;&gt;&gt; b = a
&gt;&gt;&gt; a += 1
&gt;&gt;&gt; print(b)
4</pre>
<p>The same doesn’t apply to lists, even if they consist of one <span class="No-Break">single element:</span></p>
<pre class="source-code">
&gt;&gt;&gt; a = [4]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; a[0] += 1
&gt;&gt;&gt; print(b)
[5]</pre>
<p>Despite being a different variable, the <strong class="source-inline">b</strong> list points to the same data as the <strong class="source-inline">a</strong> list. To free it from getting <a id="_idIndexMarker271"/>updates from the original, we must state explicitly that it is <span class="No-Break">a copy.</span></p>
<p>Expert Python users know very well how to avert that using Python’s <strong class="source-inline">copy</strong> module. Blender aggregate types provide a <strong class="source-inline">.copy()</strong> method <span class="No-Break">for convenience.</span></p>
<p>In the following snippet, changes to <strong class="source-inline">matrix_a</strong> will also <span class="No-Break">change </span><span class="No-Break"><strong class="source-inline">matrix_b</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
# two variables pointing to the same matrix
matrix_b = matrix_a  # matrix_b ALWAYS equals matrix_a</pre>
<p>The following creates a <strong class="bold">deep copy</strong> of <strong class="source-inline">matrix_a</strong>, that is, all its values <span class="No-Break">are copied:</span></p>
<pre class="source-code">
# deep copy of a matrix
matrix_b = matrix_a<strong class="source-inline">.copy()</strong>  # matrix_b stores its values</pre>
<p>We can now keep the object’s world transformations and restore them after the hierarchy <span class="No-Break">has changed.</span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor087"/>Restoring transformations using the world matrix</h2>
<p>Since <strong class="source-inline">matrix_world</strong> is <a id="_idIndexMarker272"/>writeable, it can be stored and reapplied after setting <span class="No-Break">the parent.</span></p>
<p>To restore <a id="_idIndexMarker273"/>the matrix <em class="italic">as it was</em>, we need to store a copy of its value, like in the <span class="No-Break">following snippet:</span></p>
<pre class="source-code">
import bpy
previous = bpy.data.objects[0]
for ob in bpy.data.objects[1:]:
    # store a copy of the world mat
    w_mat = ob.matrix_world<strong class="source-inline">.copy()</strong>  # .copy() is important!
    # parent each object under its predecessor
    ob.parent = previous
    # restore world position
    ob.matrix_world = w_mat
    # set current object as parent of the next
    previous = ob</pre>
<p>We can see that the objects maintain their position. If we look at the transform channels, we will find that they <span class="No-Break">have changed.</span></p>
<p>Setting the world matrix affects the location/rotation/scale values. In their rest position, the objects <a id="_idIndexMarker274"/>still go back to <a id="_idIndexMarker275"/>their <span class="No-Break">parent center.</span></p>
<p>If that is not what we want to achieve, we can use the <strong class="source-inline">matrix_parent_inverse</strong> attribute to offset the <span class="No-Break">rest position.</span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor088"/>Creating rest offsets with the parent inverse matrix</h2>
<p>The <strong class="source-inline">parent_matrix_inverse</strong> attribute contains a transform that is hidden from the interface. It is used for setting a rest position away <a id="_idIndexMarker276"/>from the <span class="No-Break">parent’s origin.</span></p>
<p>The idea <a id="_idIndexMarker277"/>is to counter the inherited transform, adding its inverse to the transform. For instance, the inverse of moving an object to the <strong class="source-inline">[5.0, 5.0, 5.0]</strong> coordinates is moving it to <strong class="source-inline">[-5.0, -</strong><span class="No-Break"><strong class="source-inline">5.0, -5.0]</strong></span><span class="No-Break">.</span></p>
<p>Inverting a rotation is a little bit more complicated, but in Blender, we can find the inverse of any transform using the <strong class="source-inline">.inverted()</strong> method of <span class="No-Break">its matrix.</span></p>
<p>This is how the following snippet parents the objects in <strong class="source-inline">bpy.data</strong>, while keeping their transform and <span class="No-Break">visual coordinates:</span></p>
<pre class="source-code">
import bpy
previous = bpy.data.objects[0]
for ob in bpy.data.objects[1:]:
    # parent each object under its predecessor
    ob.parent = previous
    # set parent inverse offset
    offset_matrix = previous.matrix_world.inverted()
    ob.matrix_parent_inverse = offset_matrix
    # set current object as parent of the next
    previous = ob</pre>
<p>The matrix <a id="_idIndexMarker278"/>system can be scary, as <a id="_idIndexMarker279"/>many people don’t usually think of transformations in this form. But even this basic understanding of it provides a very powerful tool in our <span class="No-Break">scripting bench.</span></p>
<p>In the next section, we put the skills learned throughout the chapter to use in a single add-on. This add-on changes the positions of many objects as one and can optionally work <span class="No-Break">through constraints.</span></p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor089"/>Writing the Elevator add-on</h1>
<p>Now that we <a id="_idIndexMarker280"/>know how to transform objects in Python, we can write a new add-on that contains a <span class="No-Break">transformation operator.</span></p>
<p>This add-on allows us to move all selected objects above a certain height. It can be useful whenever we want to set a minimum height, that is, a <em class="italic">floor</em>, for our scene. As we did in <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we start with a basic implementation, and we will then proceed to refine it. As usual, we start our work by setting a folder for the code of <span class="No-Break">the chapter.</span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor090"/>Setting the environment</h2>
<p>As we did at <a id="_idIndexMarker281"/>the beginning of <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we create a folder for <a href="B18375_04.xhtml#_idTextAnchor075"><span class="No-Break"><em class="italic">Chapter 4</em></span></a> in our <strong class="bold">VS Code</strong> project; then, from Blender’s menu bar, we can access the Blender <strong class="bold">Preferences</strong> window and then <strong class="bold">File Paths</strong> to set the <strong class="source-inline">ch4</strong> folder as the <span class="No-Break"><strong class="bold">Scripts </strong></span><span class="No-Break">folder:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<img alt="Figure 4.7: System folder for Chapter 4" height="435" src="image/Figure_4.07_B18375.jpg" width="881"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7: System folder for <a href="B18375_04.xhtml#_idTextAnchor075">Chapter 4</a></p>
<p>Now it’s time to add a new file to <span class="No-Break">our project:</span></p>
<ol>
<li>Select <strong class="source-inline">PythonScriptingBlender/ch4/addons</strong> in <span class="No-Break">VS Code.</span></li>
<li>Create a new file by clicking the <strong class="bold">New </strong><span class="No-Break"><strong class="bold">File</strong></span><span class="No-Break"> icon.</span></li>
<li>Name the new <span class="No-Break">file </span><span class="No-Break"><strong class="source-inline">object_elevator.py</strong></span><span class="No-Break">.</span></li>
<li>Open the file by <span class="No-Break">double-clicking it.</span></li>
</ol>
<p>We can now start writing <span class="No-Break">our add-on.</span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor091"/>Writing the first draft</h2>
<p>As we have <a id="_idIndexMarker282"/>seen in the <em class="italic">Add-on requirements</em> section in <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, our add-on needs <span class="No-Break">the following:</span></p>
<ul>
<li>The add-on <em class="italic">information</em> <span class="No-Break"><strong class="source-inline">bl_info</strong></span><span class="No-Break"> dictionary</span></li>
<li>An <em class="italic">operator</em> that performs the <span class="No-Break">desired action</span></li>
<li>The <strong class="source-inline">register</strong>/<strong class="source-inline">unregister</strong> function for <span class="No-Break"><strong class="source-inline">enable</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">disable</strong></span><span class="No-Break"> operations</span></li>
</ul>
<p>Let’s begin writing the first draft by filling in the requirements; we can refine the add-on in the <span class="No-Break">second step:</span></p>
<ol>
<li>We write down the add-on information in the <strong class="source-inline">bl_info</strong> header. That also helps clarify the purpose and functionality of <span class="No-Break">the tool:</span></li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">object_elevator.py</p>
<pre class="source-code">
bl_info = {
    "name": "Elevator",
    "author": "John Doe",
    "version": (1, 0),
    "blender": (3, 00, 0),
    "description": "Move objects up to a minimum height",
    "category": "Object",
}</pre>
<ol>
<li value="2">Now, let’s nail down the main functionality: the add-on contains an operator that moves all the objects up to a given height. We store this height in the static variable<a id="_idTextAnchor092"/> floor, which, for now, is hardcoded and set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">5.0</strong></span><span class="No-Break">:</span><pre class="source-code">
class OBJECT_OT_elevator(bpy.types.Operator):</pre><pre class="source-code">
    """Move Objects up to a given height"""</pre><pre class="source-code">
    bl_idname = "object.pckt_floor_transform"</pre><pre class="source-code">
    bl_label = "Elevate Objects"</pre><pre class="source-code">
    floor = 5.0</pre></li>
<li>Since it affects the selected objects, the condition to check in the <strong class="source-inline">poll()</strong> method is <a id="_idIndexMarker283"/>that the selection is <span class="No-Break">not empty:</span><pre class="source-code">
    @classmethod</pre><pre class="source-code">
    def poll(cls, context):</pre><pre class="source-code">
        return len(bpy.context.selected_objects) &gt; 0</pre></li>
<li>Here’s the bulk of the code: the <strong class="source-inline">execute</strong> function checks for each object that its <strong class="source-inline">Z</strong> location is not less than <strong class="source-inline">self.floor</strong> (at the moment, <strong class="source-inline">self.floor</strong> equals <strong class="source-inline">5.0</strong>). When all the objects have been processed, it returns a <strong class="source-inline">'</strong><span class="No-Break"><strong class="source-inline">FINISHED'</strong></span><span class="No-Break"> status:</span><pre class="source-code">
    def execute(self, context):</pre><pre class="source-code">
        for ob in context.selected_objects:</pre><pre class="source-code">
            if ob.location.z &gt; self.floor:</pre><pre class="source-code">
                continue</pre><pre class="source-code">
            ob.location.z = self.floor</pre><pre class="source-code">
        return {'FINISHED'}</pre></li>
<li>Now, we can add our operator to the object right-click menu; to do that, we need a <span class="No-Break"><strong class="source-inline">drawmenu</strong></span><span class="No-Break"> function:</span><pre class="source-code">
def draw_elevator_item(self, context):</pre><pre class="source-code">
    # Menu draw function</pre><pre class="source-code">
    row = self.layout.row()</pre><pre class="source-code">
    row.operator(OBJECT_OT_elevator.bl_idname)</pre></li>
<li>All the elements of our add-on are ready; all that is left is to add them to the registration <a id="_idIndexMarker284"/>functions. This is how we <span class="No-Break">do it:</span><pre class="source-code">
def register():</pre><pre class="source-code">
    # add operator and menu item</pre><pre class="source-code">
    bpy.utils.register_class(OBJECT_OT_elevator)</pre><pre class="source-code">
    object_menu = bpy.types.VIEW3D_MT_object_context_menu</pre><pre class="source-code">
    object_menu.append(draw_elevator_item)</pre><pre class="source-code">
def unregister():</pre><pre class="source-code">
    # remove operator and menu item</pre><pre class="source-code">
    bpy.utils.unregister_class(OBJECT_OT_elevator)</pre><pre class="source-code">
    object_menu = bpy.types.VIEW3D_MT_object_context_menu</pre><pre class="source-code">
    object_menu.remove(draw_elevator_item)</pre></li>
</ol>
<p>Our add-on is ready for its test drive. We can find it in the <span class="No-Break"><strong class="bold">Add-ons</strong></span><span class="No-Break"> preferences:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer082">
<img alt="Figure 4.8: Object: Elevator enabled in the Add-ons preferences" height="449" src="image/Figure_4.08_B18375.jpg" width="1232"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8: Object: Elevator enabled in the Add-ons preferences</p>
<p>When the add-on <a id="_idIndexMarker285"/>is enabled, a new entry is added to the object’s <span class="No-Break"><em class="italic">right-click</em></span><span class="No-Break"> menu:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<img alt="Figure 4.9: Right-clicking in the viewport shows our new menu entry" height="219" src="image/Figure_4.09_B18375.jpg" width="398"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9: Right-clicking in the viewport shows our new menu entry</p>
<p>If we select some objects and open the context menu via right-clicking them, we will find <strong class="bold">Elevate Objects</strong> as an available action. Clicking on it sets <strong class="source-inline">location.z</strong> to <strong class="source-inline">5.0</strong> unless it already has a <span class="No-Break">higher value.</span></p>
<p>Setting a minimum height for a scene can be useful when it contains a ground level, and we want to ensure that no object ends up below it. The static value of <strong class="source-inline">OBJECT_OT_elevator.floor</strong> doesn’t help here, though, as it only applies to the case when the ground level <span class="No-Break">equals </span><span class="No-Break"><strong class="source-inline">5.0</strong></span><span class="No-Break">.</span></p>
<p>Luckily that was only for testing: the final version of the script makes use of an input <span class="No-Break">parameter instead.</span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor093"/>Using input properties</h2>
<p>Replacing the static <strong class="source-inline">floor</strong> member in our operator with an editable value requires Blender to <a id="_idIndexMarker286"/>channel the user input to our <span class="No-Break">Python script.</span></p>
<p>For that purpose, Blender’s API provides special properties that show up as graphic elements in the interface and can be used as variables in Python scripts. These properties are part of the <span class="No-Break"><strong class="source-inline">bpy.props</strong></span><span class="No-Break"> module.</span></p>
<p>To make <strong class="source-inline">floor</strong> an editable property of <span class="No-Break">our operator:</span></p>
<ol>
<li>As <strong class="source-inline">OBJECT_OT_elevator.floor</strong> is a float number, so we need to <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">FloatProperty</strong></span><span class="No-Break">:</span><pre class="source-code">
import bpy</pre><pre class="source-code">
from bpy.props import FloatProperty</pre></li>
<li>Since we are forcing a specific type, we will use a Python <strong class="bold">annotation</strong> rather than a declaration, so we change <strong class="source-inline">floor = 5.0</strong> to <span class="No-Break"><strong class="source-inline">floor:FloatProperty(name="Floor", default=0)</strong></span><span class="No-Break">.</span></li>
</ol>
<p class="callout-heading">Take note</p>
<p class="callout">Using an annotation in lieu of variables of a determined type is a best practice in Python, but it is required in Blender: the input property will not <span class="No-Break">appear otherwise.</span></p>
<ol>
<li value="3">Then we must keep in mind that, because of how Blender works, operators that accept input values must be aware of the undo system. So, we add the <strong class="source-inline">bl_options = {'REGISTER', '</strong><span class="No-Break"><strong class="source-inline">UNDO'}</strong></span><span class="No-Break"> property.</span></li>
</ol>
<p>Here’s how the header of our operator looks now:</p>
<pre class="source-code">
class OBJECT_OT_elevator(bpy.types.Operator):
    """Move Objects up or down by given offset"""
    bl_idname = "object.pckt_type_collector"
    bl_label = "Create Type Collections"
    <strong class="source-inline">bl_options = {'REGISTER', 'UNDO'}</strong>
    <strong class="source-inline">floor: FloatProperty(name="Floor", default=0)</strong></pre>
<ol>
<li value="4">Refreshing the operators by pressing <em class="italic">F3</em> + <strong class="bold">Reload Scripts</strong> and executing <strong class="bold">Elevate Objects</strong> again displays the input properties inside an expansion popup at the bottom left of <span class="No-Break">the screen:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer084">
<img alt="Figure 4.10: Our editable Floor property" height="123" src="image/Figure_4.10_B18375.jpg" width="561"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10: Our editable Floor property</p>
<p>Changing this property affects the minimum height of all selected objects.</p>
<p>So far, we have <a id="_idIndexMarker287"/>operated on the <strong class="source-inline">location.z</strong> attribute. This might not work if our object has a parent with a different orientation or scale. We can overcome that using the object world <span class="No-Break">matrix instead.</span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor094"/>Setting the height in the world matrix</h2>
<p>Blender stores the <a id="_idIndexMarker288"/>object translation in the matrix’s last column, as seen in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<img alt="Figure 4.11: The entries of a transform matrix" height="354" src="image/Figure_4.11_B18375.jpg" width="601"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11: The entries of a transform matrix</p>
<p>The indices of <strong class="source-inline">Matrix</strong> point to its rows; so, to access location z, we need to get the third row and look for its fourth element. Since the enumeration starts with <strong class="source-inline">0</strong>, the indices we are looking for are, respectively, <strong class="source-inline">[2]</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">[3]</strong></span><span class="No-Break">.</span></p>
<p>Our <strong class="source-inline">execute</strong> function now uses <strong class="source-inline">matrix_world[2][3]</strong> instead of <strong class="source-inline">location.z</strong>. Since matrix values are not automatically updated during script execution, we’ll need to invoke <strong class="source-inline">context.view_layer.update()</strong> after the value <span class="No-Break">is set:</span></p>
<pre class="source-code">
    def execute(self, context):
        selected_objects = context.selected_objects
        for ob in selected_objects:
            matrix_world = ob.matrix_world
            if <strong class="source-inline">matrix_world[2][3]</strong> &gt; self.floor:
                continue
            <strong class="source-inline">matrix_world[2][3]</strong> = self.floor
            # make sure next object matrix will be updated
            context.view_layer.update()
        return {'FINISHED'}</pre>
<p>This version <a id="_idIndexMarker289"/>of the script can handle the objects that inherit a parent transform, but what if the parent is <span class="No-Break">also selected?</span></p>
<p>Moving a parent after a child has already been handled will change the positions of both, thus bringing the child to a <span class="No-Break">wrong height.</span></p>
<p>We need to make sure that parent objects are always <span class="No-Break">moved first.</span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor095"/>Avoiding duplicate transformations</h2>
<p>We need to <a id="_idIndexMarker290"/>reorder our list of objects, but with <strong class="source-inline">context.selected_objects</strong> being read-only, we cannot reorder it directly; we need to copy its content to <span class="No-Break">a list.</span></p>
<h3>Copying selected_objects to an editable list</h3>
<p>We can use the <strong class="source-inline">copy</strong> module to create a <strong class="bold">shallow copy</strong> of that list. It will reference the same <a id="_idIndexMarker291"/>data but allow us to sort them <span class="No-Break">at will:</span></p>
<pre class="source-code">
from copy import copy</pre>
<p>Then, in the <strong class="source-inline">execute</strong> method, locate the <span class="No-Break">following code:</span></p>
<pre class="source-code">
selected_objects = context.selected_objects</pre>
<p>Replace it with <span class="No-Break">this code:</span></p>
<pre class="source-code">
selected_objects = copy(context.selected_objects)</pre>
<p>Now we can order this list in a way that won’t cause the same object to be <span class="No-Break">moved twice.</span></p>
<h3>Ordering by hierarchy</h3>
<p>To sort a list, we need a function that returns each element’s position in a <span class="No-Break">new order.</span></p>
<p>We want to <a id="_idIndexMarker292"/>handle child objects only after their parents are already processed. Reordering the list so that objects with more ancestors are processed later will meet <span class="No-Break">this condition.</span></p>
<p>We need a function that returns the number of ancestors: starting with an object, it checks whether it has a parent, and then whether that parent has a parent, until none is found. The <strong class="source-inline">ancestors_count</strong> function achieves that using a <span class="No-Break"><strong class="source-inline">while</strong></span><span class="No-Break"> loop:</span></p>
<pre class="source-code">
def ancestors_count(ob):
    """Return number of objects up in the hierarchy"""
    ancestors = 0
    while ob.parent:
        ancestors += 1
        ob = ob.parent
    return ancestors</pre>
<p>We add this function to our script and use it as the <strong class="source-inline">key</strong> argument of the <span class="No-Break"><strong class="source-inline">sort</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
    def execute(self, context):
        # sort parent objects first
        selected_objects = copy(context.selected_objects)
        selected_objects<strong class="source-inline">.sort(key=ancestors_count)</strong>
        for ob in selected_objects:
            world_mat = ob.matrix_world
            if world_mat[2][3] &gt; self.floor:
                continue
            # ensure update of next object's matrix
            world_mat[2][3] = self.floor
        return {'FINISHED'}</pre>
<p>Our add-on is <a id="_idIndexMarker293"/>now able to raise all the selected objects to a minimum height and avoids summing the transforms <span class="No-Break">in hierarchies.</span></p>
<p>We could consider it finished, but since we know how to add constraints, we can use them for the <span class="No-Break">same purpose.</span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor096"/>Adding the constraints switch</h2>
<p>We can allow <a id="_idIndexMarker294"/>the user to use constraints and leave the transform channels unaffected. This is how we can <span class="No-Break">do it:</span></p>
<ol>
<li>Since we want to display a checkbox for using constraints, we need to add a Boolean property to our operator. We need to import <strong class="source-inline">BoolProperty</strong> as we did with <span class="No-Break"><strong class="source-inline">FloatProperty</strong></span><span class="No-Break"> earlier:</span><pre class="source-code">
from bpy.props import <strong class="source-inline">BoolProperty</strong></pre></li>
<li>Then we add a <strong class="source-inline">BoolProperty</strong> annotation to <span class="No-Break">our operator:</span><pre class="source-code">
class OBJECT_OT_elevator(bpy.types.Operator):</pre><pre class="source-code">
    """Move Objects up or down by given offset"""</pre><pre class="source-code">
    bl_idname = "object.pckt_type_collector"</pre><pre class="source-code">
    bl_label = "Create Type Collections"</pre><pre class="source-code">
    bl_options = {'REGISTER', 'UNDO'}</pre><pre class="source-code">
    floor: FloatProperty(name="Floor", default=0)</pre><pre class="source-code">
    <strong class="source-inline">constr: BoolProperty</strong>(name="Constraints", default=False)</pre></li>
<li>We will use constraints when the <strong class="source-inline">constr</strong> property is set to <strong class="source-inline">True</strong>. We set it to <strong class="source-inline">False</strong> by default so that a new option doesn’t change the <span class="No-Break">add-on’s behavior.</span></li>
<li>Using <a id="_idIndexMarker295"/>constraints makes our job easier; we don’t need to sort the objects and set their matrices. Our <strong class="source-inline">execute</strong> function now starts <span class="No-Break">like this:</span><pre class="source-code">
def execute(self, context):</pre><pre class="source-code">
    <strong class="source-inline">if self.constr</strong>:</pre><pre class="source-code">
        for ob in context.selected_objects:</pre><pre class="source-code">
            limit = ob.constraints.new('LIMIT_LOCATION')</pre><pre class="source-code">
            limit.use_min_z = True</pre><pre class="source-code">
            limit.min_z = self.floor</pre><pre class="source-code">
        return {'FINISHED'}</pre><pre class="source-code">
    # affect coordinates directly</pre><pre class="source-code">
    # sort parent objects first</pre><pre class="source-code">
    …</pre></li>
</ol>
<p>If we use constraints, we can just exit the function, returning a <strong class="source-inline">{'FINISHED'}</strong> set as soon as we are done setting them. If we don’t, the <strong class="source-inline">execute</strong> function keeps going with the <span class="No-Break">previous code.</span></p>
<p>The visual result is equivalent, but turning <strong class="bold">Constraints</strong> on doesn’t affect the transform channels. There is one last caveat: if the operator is run multiple times on the same objects, a new constraint <span class="No-Break">is added.</span></p>
<p>We will make <strong class="bold">Elevate Objects</strong> reuse an existing constraint when it is found. That avoids creating <a id="_idIndexMarker296"/>too many constraints for the same purpose. It also prevents the effects of previous constraints from interfering. When an object has more than one limit to its location, only the more restrictive one <span class="No-Break">is effective.</span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor097"/>Avoiding duplicate constraints</h2>
<p>If <strong class="bold">Limit Location</strong> is <a id="_idIndexMarker297"/>found on an object, our operator uses it. We make this behavior optional in case the user wants to create new <span class="No-Break">constraints anyway:</span></p>
<ol>
<li>To do that, we add another Boolean property to our <span class="No-Break">operator first:</span><pre class="source-code">
reuse: BoolProperty(name="Reuse Constraints", default=True)</pre></li>
<li>Then, inside our loop, we check for an existing constraint that we can use. If it is not found, our script <span class="No-Break">creates it.</span></li>
</ol>
<p>This behavior can be implemented in a function:</p>
<pre class="source-code">
def get_constraint(ob, constr_type, reuse=True):
    """Return first constraint of given type.
    If not found, a new one is created"""
    if reuse:
        for constr in ob.constraints:
            if constr.type == constr_type:
                return constr
    return ob.constraints.new(constr_type)</pre>
<ol>
<li value="3">That has made our <strong class="source-inline">execute</strong> method <span class="No-Break">much cleaner:</span><pre class="source-code">
def execute(self, context):</pre><pre class="source-code">
    if self.constr:</pre><pre class="source-code">
        for ob in context.selected_objects:</pre><pre class="source-code">
            <strong class="source-inline">limit = get_constraint</strong>(ob,</pre><pre class="source-code">
                                  'LIMIT_LOCATION',</pre><pre class="source-code">
                                   self.reuse)</pre><pre class="source-code">
            limit.use_min_z = True</pre><pre class="source-code">
            limit.min_z = self.floor</pre><pre class="source-code">
        return {'FINISHED'}</pre><pre class="source-code">
    …</pre></li>
</ol>
<p>If we reload <a id="_idIndexMarker298"/>the scripts and run the operator, we will see all its properties in the <span class="No-Break">execution panel:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer086">
<img alt="Figure 4.12: All the Elevate Objects options" height="211" src="image/Figure_4.12_B18375.jpg" width="561"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12: All the Elevate Objects options</p>
<p>Ideally, the <strong class="bold">Reuse</strong> property should be displayed only when <strong class="bold">Constraints</strong> is enabled, as it has no <span class="No-Break">effect otherwise.</span></p>
<p>This is possible if we take care of drawing the user interface of our tools, which will be introduced in the <span class="No-Break">next chapter.</span></p>
<p>For now, we have added a good deal of flexibility to a script that started as a very simple tool. This brings us to the end of the chapter, as we have covered most of the topics about writing <span class="No-Break">custom tools.</span></p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor098"/>Summary</h1>
<p>In this chapter, we learned how to use <strong class="source-inline">Vector</strong>, <strong class="source-inline">Quaternion</strong>, and <strong class="source-inline">Matrix</strong> entities to our advantage, not to mention the different <em class="italic">rotation modes</em>. That gives us the elements for understanding and mastering the transformations in space and moving the objects in <span class="No-Break">the scene.</span></p>
<p>We also learned how to create constraints in Python, which is very important in all <span class="No-Break">set-up scripts.</span></p>
<p>Lastly, we learned how our operators can get user input and display their parameters inside the Blender user interface during <span class="No-Break">their execution.</span></p>
<p>In <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, we will learn how to code our own panels for the graphic interface and make its options aware of <span class="No-Break">the context.</span></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor099"/>Questions</h1>
<ol>
<li>What is a <span class="No-Break">rigid transformation?</span></li>
<li>Can we convert coordinates between different <span class="No-Break">rotation systems?</span></li>
<li>Can we convert coordinates between different <span class="No-Break">rotation orders?</span></li>
<li>Why are quaternions useful <span class="No-Break">for conversion?</span></li>
<li>In which form are transformations <span class="No-Break">stored internally?</span></li>
<li>Are objects associated with only one <span class="No-Break">transformation matrix?</span></li>
</ol>
</div>
</div></body></html>