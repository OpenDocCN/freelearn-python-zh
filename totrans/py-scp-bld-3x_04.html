<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-73"><a id="_idTextAnchor075"/>4</h1>
<h1 id="_idParaDest-74"><a id="_idTextAnchor076"/>Exploring Object Transformations</h1>
<p>The ability to change an object’s location, rotation, and dimension in a space is a tenet of any animation software.</p>
<p>Artists are used to changing the values of transform channels to carry out these operations. More technical users are aware of the geometric implications of such actions.</p>
<p>In this chapter, we will learn how Object Transformations work and how to implement them in our script. We will also learn how to add object constraints programmatically and how Blender can carry out the more difficult operations for us.</p>
<p>Finally, we will implement a new command that affects the transformation of more objects at once and accepts user input.</p>
<p>This chapter will cover the following key topics:</p>
<ul>
<li>Transforming objects, using coordinate notations, and avoiding pitfalls</li>
<li>Applying object constraints and hierarchies</li>
<li>Using matrix representation</li>
<li>Adding interactive operators to our add-ons</li>
</ul>
<h1 id="_idParaDest-75"><a id="_idTextAnchor077"/>Technical requirements</h1>
<p>We will use Blender and <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>).</p>
<p>The examples created in this chapter can be found at the following URL: <a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch4">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch4</a>.</p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor078"/>Moving objects in space</h1>
<p>Three-dimensional objects <a id="_idIndexMarker222"/>can be moved, rotated, and scaled. Since they do not change the geometry of an object, location and rotation are considered <strong class="bold">rigid transformations</strong>. Technically, changing the size of an object using its scale value <a id="_idIndexMarker223"/>applies a non-rigid transformation, but since the vertex geometry doesn’t change, scale is considered <a id="_idIndexMarker224"/>an object-level transformation and is displayed alongside location and rotation.</p>
<p>In this section, we will use Python to transform objects in Blender.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor079"/>Transforming objects</h2>
<p>An object is transformed <a id="_idIndexMarker225"/>by changing the values of its Location, Rotation, and Scale channels. Location and scale coordinates are immediately associated with the X, Y, and Z of the Cartesian space; rotations have more options as they come with some implications.</p>
<h3>Affecting an object’s location</h3>
<p>We have already <a id="_idIndexMarker226"/>met the <code>location</code> attribute in <a href="B18375_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a> and <a href="B18375_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>. If we have an active object, such as the cube from Blender’s default scene, the following lines will move it to the location with <em class="italic">x</em>, <em class="italic">y</em>, <em class="italic">z</em> coordinates <code>1.0</code>, <code>2.0</code>, and <code>3.0</code>. These lines <a id="_idIndexMarker227"/>use <strong class="bold">tuple assignment</strong> to set all three coordinates at once:</p>
<pre class="source-code">
import bpy
bpy.context.object.location = 1.0, 2.0, 3.0</pre>
<p>Since Blender coordinates can also be assigned through letters, that expression is equivalent to the following:</p>
<pre class="source-code">
import bpy
bpy.context.object.location.xyz = 1.0, 2.0, 3.0</pre>
<p>Coordinates are <a id="_idIndexMarker228"/>stored inside <strong class="bold">Vectors</strong>. Vector components can be accessed separately:</p>
<pre class="source-code">
import bpy
bpy.context.object.location[0] = 1.0
bpy.context.object.location[1] = 2.0
bpy.context.object.location[2] = 3.0</pre>
<p>Alternatively, they can be accessed as follows:</p>
<pre class="source-code">
import bpy
bpy.context.object.location.x = 1.0
bpy.context.object.location.y = 2.0
bpy.context.object.location.z = 3.0</pre>
<p>Location and <a id="_idIndexMarker229"/>Scale are both stored as Vectors.</p>
<h3>Affecting object scale</h3>
<p>Like with location, the <a id="_idIndexMarker230"/>three dimensions of scale are accessed through the <code>Vector</code> coordinates:</p>
<pre class="source-code">
&gt;&gt;&gt; bpy.context.object.scale
Vector((1.0, 1.0, 1.0))</pre>
<p>We can assign a non-uniform scale to an object, such as a different value for each axis:</p>
<pre class="source-code">
import bpy
bpy.context.object.scale.xyz = 3.0, 2.0, 1.0</pre>
<p>The scale of an object is more often uniform, meaning it is the same on each axis. Blender Vectors provide a convenient way for assigning uniform values:</p>
<pre class="source-code">
import bpy
bpy.context.object.scale.xyz = 3.0</pre>
<p>Like with <code>location</code>, <code>scale</code> coordinates can be set individually or together. The rest values are different, by the way: the scale at rest is <code>[1.0, 1.0, 1.0]</code> rather than <code>[0.0, 0.0, 0.0]</code>. That reflects how scaling is a multiplicative operation while location is additive.</p>
<p>Rotations are less immediate to combine. We will see that there are different ways to represent rotations in the first place.</p>
<h3>Affecting object rotations</h3>
<p>Using rotations, we <a id="_idIndexMarker231"/>can orient an object around the <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> axes. Doing that will give objects an orientation of their own, with their own <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> local axes.</p>
<p>We refer to these new axes, aligned with the object, as <strong class="bold">Local Orientation</strong>. Blender lets the user <a id="_idIndexMarker232"/>choose between different axes for transforming objects. The axes <a id="_idIndexMarker233"/>aligned with the <a id="_idIndexMarker234"/>viewport grid are the <strong class="bold">Global Orientation</strong> or <strong class="bold">World Axes</strong>:</p>
<div><div><img alt="Figure 4.1: Rotation rings and axes of an object at rest and after a rotation" height="181" src="img/Figure_4.01_B18375.jpg" width="528"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1: Rotation rings and axes of an object at rest and after a rotation</p>
<p>Even if an object was rotated, we can still change <strong class="bold">Rotation Mode</strong> in the viewport top bar and use <em class="italic">Global Orientation</em>:</p>
<div><div><img alt="Figure 4.2: A rotated airplane still using Global Orientation" height="563" src="img/Figure_4.02_B18375.jpg" width="853"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2: A rotated airplane still using Global Orientation</p>
<p>Rotations are more <a id="_idIndexMarker235"/>complex than translation and scale: by definition, a rotation involves a pivot and a constant distance. For that reason, rotations are affected by some minor issues that require extra consideration.</p>
<h4>Issues related to rotations</h4>
<p>Because of their composite <a id="_idIndexMarker236"/>nature, rotations around one axis can change the rotation value on another. To sum that up, rotation is described as a three-dimensional property with only two <strong class="bold">degrees of freedom</strong>, as no more than two channels have the chance to change freely.</p>
<p>Also, the order in which rotations are stacked together changes the result. To visualize a rotated object correctly, we need to know which axes were rotated first, that is, the <strong class="bold">rotation order</strong>.</p>
<p>We could just stick with one rotation order, say <em class="italic">x</em>, then <em class="italic">y</em>, and then <em class="italic">z</em>, but that would limit our options against another potential shortcoming: three-dimensional rotations that overlap one axis <a id="_idIndexMarker237"/>with another end up making one coordinate useless, a well-known problem known as <strong class="bold">gimbal lock</strong>.</p>
<p>Since different rotation orders lock at different angles, changing the order helps cope with the issue.</p>
<p>These problems aren't specific to Blender or any other animation software; they are inherent properties of three-dimensional spaces, up to and including the one that we inhabit.</p>
<p>To work around them, rotations provide a wider range of options. In addition to different orders for combining the three angles, there are also abstract representations such as quaternions. This terminology might sound scary at first, but it will become more familiar as we proceed with the chapter.</p>
<h4>Changing rotation mode</h4>
<p>The <strong class="bold">Rotation Mode</strong> box <a id="_idIndexMarker238"/>in <strong class="bold">Transform Properties</strong> displays the available options for rotating objects:</p>
<div><div><img alt="Figure 4.3: Rotation modes" height="471" src="img/Figure_4.03_B18375.jpg" width="279"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3: Rotation modes</p>
<p>We do not need to <a id="_idIndexMarker239"/>cover this topic in full here, but essentially the following provides a brief introduction:</p>
<ul>
<li><strong class="bold">Quaternions</strong>: These are mathematic <a id="_idIndexMarker240"/>notations that use four coefficients: in Blender, <strong class="bold">W</strong>, <strong class="bold">X</strong>, <strong class="bold">Y</strong>, and <strong class="bold">Z</strong>. Quaternions do not suffer from gimbal lock.</li>
<li><strong class="bold">Euler angles</strong>: These list the angles on three rotation axes. It’s the common acceptance of rotation <a id="_idIndexMarker241"/>and comes with two caveats: the result depends on the axis order, and one axis might end up overlapping another. To mitigate the perils of losing a channel to gimbal lock, more combinations of <strong class="bold">X</strong>, <strong class="bold">Y</strong>, and <strong class="bold">Z</strong> are allowed.</li>
<li><strong class="bold">Axis Angle</strong>: This uses <strong class="bold">X</strong>, <strong class="bold">Y,</strong> and <strong class="bold">Z</strong> to define a point as the rotation axis. The <strong class="bold">W</strong> attribute is the <a id="_idIndexMarker242"/>twisting angle in said direction.</li>
</ul>
<div><div><img alt="Figure 4.4: Rotation attributes for the Quaternion, Euler, and Axis Angle modes" height="253" src="img/Figure_4.04_B18375.jpg" width="1120"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4: Rotation attributes for the Quaternion, Euler, and Axis Angle modes</p>
<p>Changing this property in the interface changes the displayed channels. In Python, we need to use different attributes depending on the current mode.</p>
<h4>Accessing rotations in Python</h4>
<p>The <code>rotation_mode</code> attribute <a id="_idIndexMarker243"/>specifies which system is being used to rotate an object. It is an <code>TypeError</code>. The error message prints out the allowed keywords:</p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.context.object.rotation_mode = "this won't work"
TypeError: bpy_struct: item.attr = val: enum "this won't work" not found in ('QUATERNION', 'XYZ', 'XZY', 'YXZ', 'YZX', 'ZXY', 'ZYX', 'AXIS_ANGLE')</pre>
<p>Each mode provides its attributes for setting rotations:</p>
<ul>
<li><code>QUATERNION</code>: To affect the quaternion coefficients <em class="italic">W</em>, <em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z,</em> we use the following, respectively:<ul><li><code>rotation_quaternion.w</code> or <code>rotation_quaternion[0]</code></li><li><code>rotation_quaternion.x</code> or <code>rotation_quaternion[1]</code></li><li><code>rotation_quaternion.y</code> or <code>rotation_quaternion[2]</code></li><li><code>rotation_quaternion.z</code> or <code>rotation_quaternion[3]</code></li></ul></li>
<li><code>XYZ</code>, <code>XZY</code>, <code>YXZ</code>, <code>YZX</code>, <code>ZXY</code>, and <code>ZYX</code> are Euler angles evaluated in different orders. No matter which one we choose, the Euler attributes for these are the following:<ul><li><code>rotation_euler.x</code> or <code>rotation_euler[0]</code></li><li><code>rotation_euler.y</code> or <code>rotation_euler[1]</code></li><li><code>rotation_euler.z</code> or <code>rotation_euler[2]</code></li></ul></li>
</ul>
<p>We should set these values in radians.</p>
<ul>
<li><code>AXIS_ANGLE</code>: <em class="italic">Axis Angle – Axis Angle (W+XYZ)</em>, defines a rotation around some axis defined by 3D-Vector. We can set the torsion angle in radians via the following:<ul><li><code>rotation_axis_angle[0]</code></li></ul></li>
</ul>
<p>We can set the axis <a id="_idIndexMarker244"/>vector x, y, z coordinates using the following:</p>
<ul>
<li><code>rotation_axis_angle[1]</code></li>
<li><code>rotation_axis_angle[2]</code></li>
<li><code>rotation_axis_angle[3]</code></li>
</ul>
<p>The <code>math</code> module provides some help in using radians as angular units.</p>
<h4>Using radians and degrees</h4>
<p>Blender’s API describes angles of rotation using radians rather than degrees. Degrees express an angle <a id="_idIndexMarker245"/>using values between 0 and 360, while radians range <a id="_idIndexMarker246"/>between 0 and 2π. The Greek letter π (pi) refers to the ratio between a circle and its diameter. 2π (approximately 6.28) measures the arc of a full circle of radius 1.0.</p>
<p>In Python, we can use the <code>math</code> module’s functions to convert between the two systems, <code>radians()</code> and <code>degrees()</code>, and the <code>pi</code> variable for quick access to the value of π.</p>
<p>Take the following example:</p>
<pre class="source-code">
&gt;&gt;&gt; from math import radians, degrees, pi
&gt;&gt;&gt; degrees(2 * pi)
360.0
&gt;&gt;&gt; radians(360)
6.283185307179586</pre>
<p>With that in mind, when we set rotations, we can convert angular units on the fly.</p>
<h4>Setting rotation attributes</h4>
<p>Before we set <a id="_idIndexMarker247"/>a rotation in a script, we must ensure that we use the right rotation system. In the following snippet, we set the rotation mode beforehand:</p>
<pre class="source-code">
import bpy
ob = bpy.context.object
# apply a 90 degrees on X axis rotation using Quaternions
ob.rotation_mode = 'QUATERNION'
ob.rotation_quaternion.w = 0.707107
ob.rotation_quaternion.x = 0.707107
ob.rotation_quaternion.y = 0.0
ob.rotation_quaternion.z = 0.0
# apply a 90 degrees on X axis rotation using Eulers
ob.rotation_mode = 'XYZ'
ob.rotation_euler.x = radians(90)
ob.rotation_euler.y = 0.0
ob.rotation_euler.z = 0.0
# apply a 90 degrees on X axis rotation using Axis Angle
ob.rotation_mode = 'AXIS_ANGLE'
ob.rotation_axis_angle[0] = radians(90)
ob.rotation_axis_angle[1] = 1
ob.rotation_axis_angle[1] = 0
ob.rotation_axis_angle[1] = 0</pre>
<p>When we change <code>rotation_mode</code>, Blender converts the current state to the selected system. That prevents an object from suddenly changing its orientation in space and works for most cases, but there are a few exceptions. For instance, animations have values set for <a id="_idIndexMarker248"/>each keyframe, so switching the rotation type of animated controls ends up changing the visual rotation during playback. In that case, we can use conversion methods in our scripts, as we will see in the next Python snippet.</p>
<h4>Converting between rotation systems</h4>
<p>In the following <a id="_idIndexMarker249"/>snippet, we start with a <code>Euler</code> rotation and use conversion methods to change the rotation mode:</p>
<pre class="source-code">
from mathutils import Euler
# create a 90 degrees rotation Euler
rot_90x_eu = Euler((radians(90), 0, 0))
# convert to quaternion
rot_90x_quat = rot_90x_eu.to_quaternion()
# convert to axis angle
rot_90x_aa = rot_90x_quat.to_axis_angle()</pre>
<p>At the time of writing, the Euler representation doesn’t have a <code>to_axis_angle()</code> method, so we <a id="_idIndexMarker250"/>convert to quaternion first. Using quaternions as a crossroad is common, as they are the most generic system for expressing rotations.</p>
<p>Rotations can also be written down as a <strong class="bold">matrix</strong>. The matrix form is how all the transforms are stored internally. We will get to that after we have learned more about indirect transforms, that is, moving an object without changing its channels.</p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor080"/>Transforming objects indirectly</h1>
<p>We have seen <a id="_idIndexMarker251"/>how to transform an object by altering its channels directly. There are two other ways to influence an object’s position, rotation, and scale. <strong class="bold">Object Constraints</strong> are special utilities that affect the transformation either by limiting certain values or by copying them from another object.</p>
<p>Then there is the possibility to arrange more objects in a hierarchy via <strong class="bold">Parenting</strong>, that is, by making <a id="_idIndexMarker252"/>one object belong to another.</p>
<p>We will see how these operations are reflected in Python.</p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor081"/>Using Object Constraints</h2>
<p>Constraints can move, rotate, or scale an object without changing its transform properties. Some <a id="_idIndexMarker253"/>of them, such as <strong class="bold">Copy Transforms</strong>, override the object transform completely; others, such as <strong class="bold">Limit Distance</strong>, operate on top of them.</p>
<div><div><img alt="Figure 4.5: Blender constraints menu" height="414" src="img/Figure_4.05_B18375.jpg" width="769"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5: Blender constraints menu</p>
<p>Most constraints bind the transforms of more objects together, such as <strong class="bold">Copy Location</strong>, while <a id="_idIndexMarker254"/>others, such as <strong class="bold">Limit Location</strong>, have their own transform attributes.</p>
<p>An object can have an unspecified number of constraints. The steps to add them in Python are very similar to how they work in the graphic interface.</p>
<h3>Adding constraints in Python</h3>
<p>Constraints are <a id="_idIndexMarker255"/>exposed as a collection property of an object. They can be added by providing a constraint type to the <code>new(type)</code> method.</p>
<p>Much like with rotation mode, providing a wrong keyword will prompt an error and list the available options:</p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.context.object.constraints.new("this won't work")
TypeError: ObjectConstraints.new(): error with keyword argument "type" -  enum " this won't work " not found in ('CAMERA_SOLVER', 'FOLLOW_TRACK', 'OBJECT_SOLVER', 'COPY_LOCATION', 'COPY_ROTATION', 'COPY_SCALE', 'COPY_TRANSFORMS', 'LIMIT_DISTANCE', 'LIMIT_LOCATION', ...</pre>
<p>The <code>new</code> method <a id="_idIndexMarker256"/>returns the created constraint, so we can easily access its properties.</p>
<h3>Setting constraint attributes</h3>
<p>Different types <a id="_idIndexMarker257"/>of constraints have different attributes, but some common patterns exist. Most constraints will contain these properties:</p>
<p><strong class="bold">Boolean</strong> switches:</p>
<ul>
<li><code>.enabled</code>: This <a id="_idIndexMarker258"/>enables/disables a constraint</li>
<li><code>.use_x</code>, <code>.use_y</code>, <code>.use_z</code>: Use when available to enable/disable only one axis</li>
<li><code>.use_offset</code>: Use when available to sum the constraint effect to the transform channels</li>
</ul>
<ul>
<li>Object: Use <code>.target</code>, if available, to set the bind target of the constraint</li>
<li>String: Use <code>.subtarget</code>, if available, to use only part of the target (e.g., a vertex group) for the actual computation</li>
<li>Enum switches:<ul><li><code>.target_space</code>: This makes the constraint act at the <code>.owner_space</code>: This changes the constraint source data to the <strong class="bold">Local</strong>, <strong class="bold">World,</strong> or <strong class="bold">Custom </strong><strong class="bold">Object</strong> level</li></ul></li>
</ul>
<p>Float number: Use <code>.influence</code> to convey only a fraction of the effect</p>
<p>Some properties are specific <a id="_idIndexMarker259"/>to each type, such as the <code>distance</code> attribute of the <strong class="bold">Distance Constraint</strong>. In that case, their path can be traced by hovering over or right-clicking in the graphic interface (see the <em class="italic">Copying the data path section in</em> <a href="B18375_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>) or from the API documentation (see the <em class="italic">Accessing Blender data</em> section in <a href="B18375_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>).</p>
<h3>Limiting an object scale</h3>
<p>The following <a id="_idIndexMarker260"/>snippet adds a <strong class="bold">Limit Scale</strong> constraint that limits the maximum height of the active object:</p>
<pre class="source-code">
import bpy
ob = bpy.context.object
limit = ob.constraints.new(type='LIMIT_SCALE')
limit.use_max_z = True  # limit the height only
limit.max_z = 0.5</pre>
<p>If applied to the default cube, it will halve its height as if a scale of <code>[1.0, 1.0, 0.5]</code> had been applied, despite its scale values still being <code>[1.0, </code><code>1.0, 1.0]</code>.</p>
<p>Objects can be part of a hierarchy. In that case, they follow the objects that are higher in their hierarchical tree. We will explore this concept next.</p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor082"/>Using object hierarchies</h2>
<p>Objects in the viewport <a id="_idIndexMarker261"/>can be arranged as <strong class="bold">children</strong> of other objects. In that case, they will be affected by the translation, rotation, and scale of their <strong class="bold">parent</strong>.</p>
<p>We can access hierarchical relationships in Python via the <code>parent</code>, <code>children</code>, and <code>children_recursive</code> attributes. Only the parent attribute is writable; the other two are only for listing.</p>
<p>The difference between <code>children</code> and <code>children_recursive</code> is that the latter lists every affected object down the hierarchy, including children of children and all the <em class="italic">descendants</em>.</p>
<p>This snippet parents <a id="_idIndexMarker262"/>all the existing objects one under the other, then it prints a report:</p>
<pre class="source-code">
import bpy
previous = bpy.data.objects[0]
for ob in bpy.data.objects[1:]:
    # parent each object under its predecessor
    ob.parent = previous
    previous = ob
for ob in bpy.data.objects:
    # now print out the children of each object
    print(ob.name)
    child_names = (c.name for c in ob.children)
    print("\tchildren:", ", ".join(child_names))
    child_names = (c.name for c in ob.children_recursive)
    print("\tchildren recursive:", ", ".join(child_names))
    print("")</pre>
<p>Running that code in the default scene brings the following result:</p>
<div><div><img alt="Figure 4.6: Default objects reparented in one hierarchy" height="385" src="img/Figure_4.06_B18375.jpg" width="525"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6: Default objects reparented in one hierarchy</p>
<p>This is reflected in the printout: the <a id="_idIndexMarker263"/>first object lists all the others as <em class="italic">grandchildren</em>, while <code>children_recursive</code> and <code>children</code> contain the same results for the last two, which have no other descendants:</p>
<pre class="source-code">
Camera
        children: Cube
        children recursive: Cube, Light
Cube
        children: Light
        children recursive: Light
Light
        children:
        children recursive:</pre>
<p>If we look at the viewport, we can see that the object positions have changed: parenting an object in Python applies a new reference system instantly. To replicate that behavior, we need to understand the transformation matrix.</p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor083"/>Understanding the transform matrix</h1>
<p>Three-dimensional transforms of Location, Rotation, and Scale are stored together inside a <strong class="bold">matrix</strong>. Matrices <a id="_idIndexMarker264"/>are, at large, tables of numbers arranged in rows and columns. Transformation matrices are combined using <strong class="bold">linear algebra</strong>. We will not go into the details <a id="_idIndexMarker265"/>here; we will just have a quick look at what a matrix means and how we can use it in our scripts.</p>
<p>Like with other representations, Blender provides a <code>Matrix</code> class in the <code>mathutils</code> module:</p>
<pre class="source-code">
&gt;&gt;&gt; from mathutils import Matrix
&gt;&gt;&gt; Matrix()
Matrix(((1.0, 0.0, 0.0, 0.0),
        (0.0, 1.0, 0.0, 0.0),
        (0.0, 0.0, 1.0, 0.0),
        (0.0, 0.0, 0.0, 1.0)))</pre>
<p>A matrix containing these default values, <code>1.0</code> in its <em class="italic">diagonal</em> entries and <code>0.0</code> everywhere else, represents the <em class="italic">rest</em> state. In other words, an object associated with this matrix was not moved, rotated, <a id="_idIndexMarker266"/>or scaled. It is known as an <strong class="bold">identity matrix</strong>, as it leaves an object in its <em class="italic">identical</em> state.</p>
<p>Whenever an object is moved, rotated, or scaled, the entries of its matrix change to different values.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor084"/>Accessing matrices</h2>
<p>Objects contain <a id="_idIndexMarker267"/>more than one matrix. Trying to reach an object matrix via autocompletion shows four different attributes:</p>
<pre class="source-code">
&gt;&gt;&gt; bpy.context.object.matrix_
                              basis
                              local
                              parent_inverse
                              world</pre>
<p>Each of them covers a specific aspect:</p>
<ul>
<li><code>matrix_basis</code>: This contains the local location, rotation, and scale of an object before it is transformed by object constraints. This matrix reflects the channels displayed in the object properties.</li>
<li><code>matrix_local</code>: This contains the local location, rotation, and scale of an object, omitting the transformation inherited by the parent object but not the one resulting from constraints.</li>
<li><code>matrix_parent_inverse</code>: Whenever we don’t want an object at rest to match its parent exactly, we add an offset inside this matrix.</li>
<li><code>matrix_world</code>: This <a id="_idIndexMarker268"/>contains the final location, rotation, and scale in world coordinates, reflecting all the transformations to which an object is subject.</li>
</ul>
<p>With that in mind, we can improve the <em class="italic">parent snippet</em> from the previous section and keep the object positions intact.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor085"/>Storing object matrices</h2>
<p>Assigning a parent <a id="_idIndexMarker269"/>relationship via Python previously has snapped every object to its parent positions.</p>
<p>We want them to maintain their visual transformation after the change in hierarchy. In matrix terms, we are saying that we want to keep their world matrix unchanged. To do that, we will learn how to store a matrix properly.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor086"/>Copying matrices</h2>
<p>Python variables <a id="_idIndexMarker270"/>containing single values store their own data. Variables with aggregate values such as lists, dictionaries, and Blender <code>mathutils</code> types point to shared references of their values.</p>
<p>Let’s look at the following example. The <code>b</code> variable has the same value as <code>a</code>. After <code>a</code> is changed to <code>5</code>, <code>b</code> is still <code>4</code>:</p>
<pre class="source-code">
&gt;&gt;&gt; a = 4
&gt;&gt;&gt; b = a
&gt;&gt;&gt; a += 1
&gt;&gt;&gt; print(b)
4</pre>
<p>The same doesn’t apply to lists, even if they consist of one single element:</p>
<pre class="source-code">
&gt;&gt;&gt; a = [4]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; a[0] += 1
&gt;&gt;&gt; print(b)
[5]</pre>
<p>Despite being a different variable, the <code>b</code> list points to the same data as the <code>a</code> list. To free it from getting <a id="_idIndexMarker271"/>updates from the original, we must state explicitly that it is a copy.</p>
<p>Expert Python users know very well how to avert that using Python’s <code>copy</code> module. Blender aggregate types provide a <code>.copy()</code> method for convenience.</p>
<p>In the following snippet, changes to <code>matrix_a</code> will also change <code>matrix_b</code>:</p>
<pre class="source-code">
# two variables pointing to the same matrix
matrix_b = matrix_a  # matrix_b ALWAYS equals matrix_a</pre>
<p>The following creates a <code>matrix_a</code>, that is, all its values are copied:</p>
<pre class="source-code">
# deep copy of a matrix
matrix_b = matrix_a<code>.copy()</code>  # matrix_b stores its values</pre>
<p>We can now keep the object’s world transformations and restore them after the hierarchy has changed.</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor087"/>Restoring transformations using the world matrix</h2>
<p>Since <code>matrix_world</code> is <a id="_idIndexMarker272"/>writeable, it can be stored and reapplied after setting the parent.</p>
<p>To restore <a id="_idIndexMarker273"/>the matrix <em class="italic">as it was</em>, we need to store a copy of its value, like in the following snippet:</p>
<pre class="source-code">
import bpy
previous = bpy.data.objects[0]
for ob in bpy.data.objects[1:]:
    # store a copy of the world mat
    w_mat = ob.matrix_world<code>.copy()</code>  # .copy() is important!
    # parent each object under its predecessor
    ob.parent = previous
    # restore world position
    ob.matrix_world = w_mat
    # set current object as parent of the next
    previous = ob</pre>
<p>We can see that the objects maintain their position. If we look at the transform channels, we will find that they have changed.</p>
<p>Setting the world matrix affects the location/rotation/scale values. In their rest position, the objects <a id="_idIndexMarker274"/>still go back to <a id="_idIndexMarker275"/>their parent center.</p>
<p>If that is not what we want to achieve, we can use the <code>matrix_parent_inverse</code> attribute to offset the rest position.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor088"/>Creating rest offsets with the parent inverse matrix</h2>
<p>The <code>parent_matrix_inverse</code> attribute contains a transform that is hidden from the interface. It is used for setting a rest position away <a id="_idIndexMarker276"/>from the parent’s origin.</p>
<p>The idea <a id="_idIndexMarker277"/>is to counter the inherited transform, adding its inverse to the transform. For instance, the inverse of moving an object to the <code>[5.0, 5.0, 5.0]</code> coordinates is moving it to <code>[-5.0, -</code><code>5.0, -5.0]</code>.</p>
<p>Inverting a rotation is a little bit more complicated, but in Blender, we can find the inverse of any transform using the <code>.inverted()</code> method of its matrix.</p>
<p>This is how the following snippet parents the objects in <code>bpy.data</code>, while keeping their transform and visual coordinates:</p>
<pre class="source-code">
import bpy
previous = bpy.data.objects[0]
for ob in bpy.data.objects[1:]:
    # parent each object under its predecessor
    ob.parent = previous
    # set parent inverse offset
    offset_matrix = previous.matrix_world.inverted()
    ob.matrix_parent_inverse = offset_matrix
    # set current object as parent of the next
    previous = ob</pre>
<p>The matrix <a id="_idIndexMarker278"/>system can be scary, as <a id="_idIndexMarker279"/>many people don’t usually think of transformations in this form. But even this basic understanding of it provides a very powerful tool in our scripting bench.</p>
<p>In the next section, we put the skills learned throughout the chapter to use in a single add-on. This add-on changes the positions of many objects as one and can optionally work through constraints.</p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor089"/>Writing the Elevator add-on</h1>
<p>Now that we <a id="_idIndexMarker280"/>know how to transform objects in Python, we can write a new add-on that contains a transformation operator.</p>
<p>This add-on allows us to move all selected objects above a certain height. It can be useful whenever we want to set a minimum height, that is, a <em class="italic">floor</em>, for our scene. As we did in <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, we start with a basic implementation, and we will then proceed to refine it. As usual, we start our work by setting a folder for the code of the chapter.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor090"/>Setting the environment</h2>
<p>As we did at <a id="_idIndexMarker281"/>the beginning of <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, we create a folder for <a href="B18375_04.xhtml#_idTextAnchor075"><em class="italic">Chapter 4</em></a> in our <code>ch4</code> folder as the <strong class="bold">Scripts </strong>folder:</p>
<div><div><img alt="Figure 4.7: System folder for Chapter 4" height="435" src="img/Figure_4.07_B18375.jpg" width="881"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7: System folder for <a href="B18375_04.xhtml#_idTextAnchor075">Chapter 4</a></p>
<p>Now it’s time to add a new file to our project:</p>
<ol>
<li>Select <code>PythonScriptingBlender/ch4/addons</code> in VS Code.</li>
<li>Create a new file by clicking the <strong class="bold">New </strong><strong class="bold">File</strong> icon.</li>
<li>Name the new file <code>object_elevator.py</code>.</li>
<li>Open the file by double-clicking it.</li>
</ol>
<p>We can now start writing our add-on.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor091"/>Writing the first draft</h2>
<p>As we have <a id="_idIndexMarker282"/>seen in the <em class="italic">Add-on requirements</em> section in <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, our add-on needs the following:</p>
<ul>
<li>The add-on <em class="italic">information</em> <code>bl_info</code> dictionary</li>
<li>An <em class="italic">operator</em> that performs the desired action</li>
<li>The <code>register</code>/<code>unregister</code> function for <code>enable</code>/<code>disable</code> operations</li>
</ul>
<p>Let’s begin writing the first draft by filling in the requirements; we can refine the add-on in the second step:</p>
<ol>
<li>We write down the add-on information in the <code>bl_info</code> header. That also helps clarify the purpose and functionality of the tool:</li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">object_elevator.py</p>
<pre class="source-code">
bl_info = {
    "name": "Elevator",
    "author": "John Doe",
    "version": (1, 0),
    "blender": (3, 00, 0),
    "description": "Move objects up to a minimum height",
    "category": "Object",
}</pre>
<ol>
<li value="2">Now, let’s nail down the main functionality: the add-on contains an operator that moves all the objects up to a given height. We store this height in the static variable<a id="_idTextAnchor092"/> floor, which, for now, is hardcoded and set to <code>5.0</code>:<pre class="source-code">
class OBJECT_OT_elevator(bpy.types.Operator):</pre><pre class="source-code">
    """Move Objects up to a given height"""</pre><pre class="source-code">
    bl_idname = "object.pckt_floor_transform"</pre><pre class="source-code">
    bl_label = "Elevate Objects"</pre><pre class="source-code">
    floor = 5.0</pre></li>
<li>Since it affects the selected objects, the condition to check in the <code>poll()</code> method is <a id="_idIndexMarker283"/>that the selection is not empty:<pre class="source-code">
    @classmethod</pre><pre class="source-code">
    def poll(cls, context):</pre><pre class="source-code">
        return len(bpy.context.selected_objects) &gt; 0</pre></li>
<li>Here’s the bulk of the code: the <code>execute</code> function checks for each object that its <code>Z</code> location is not less than <code>self.floor</code> (at the moment, <code>self.floor</code> equals <code>5.0</code>). When all the objects have been processed, it returns a <code>'</code><code>FINISHED'</code> status:<pre class="source-code">
    def execute(self, context):</pre><pre class="source-code">
        for ob in context.selected_objects:</pre><pre class="source-code">
            if ob.location.z &gt; self.floor:</pre><pre class="source-code">
                continue</pre><pre class="source-code">
            ob.location.z = self.floor</pre><pre class="source-code">
        return {'FINISHED'}</pre></li>
<li>Now, we can add our operator to the object right-click menu; to do that, we need a <code>drawmenu</code> function:<pre class="source-code">
def draw_elevator_item(self, context):</pre><pre class="source-code">
    # Menu draw function</pre><pre class="source-code">
    row = self.layout.row()</pre><pre class="source-code">
    row.operator(OBJECT_OT_elevator.bl_idname)</pre></li>
<li>All the elements of our add-on are ready; all that is left is to add them to the registration <a id="_idIndexMarker284"/>functions. This is how we do it:<pre class="source-code">
def register():</pre><pre class="source-code">
    # add operator and menu item</pre><pre class="source-code">
    bpy.utils.register_class(OBJECT_OT_elevator)</pre><pre class="source-code">
    object_menu = bpy.types.VIEW3D_MT_object_context_menu</pre><pre class="source-code">
    object_menu.append(draw_elevator_item)</pre><pre class="source-code">
def unregister():</pre><pre class="source-code">
    # remove operator and menu item</pre><pre class="source-code">
    bpy.utils.unregister_class(OBJECT_OT_elevator)</pre><pre class="source-code">
    object_menu = bpy.types.VIEW3D_MT_object_context_menu</pre><pre class="source-code">
    object_menu.remove(draw_elevator_item)</pre></li>
</ol>
<p>Our add-on is ready for its test drive. We can find it in the <strong class="bold">Add-ons</strong> preferences:</p>
<div><div><img alt="Figure 4.8: Object: Elevator enabled in the Add-ons preferences" height="449" src="img/Figure_4.08_B18375.jpg" width="1232"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8: Object: Elevator enabled in the Add-ons preferences</p>
<p>When the add-on <a id="_idIndexMarker285"/>is enabled, a new entry is added to the object’s <em class="italic">right-click</em> menu:</p>
<div><div><img alt="Figure 4.9: Right-clicking in the viewport shows our new menu entry" height="219" src="img/Figure_4.09_B18375.jpg" width="398"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9: Right-clicking in the viewport shows our new menu entry</p>
<p>If we select some objects and open the context menu via right-clicking them, we will find <code>location.z</code> to <code>5.0</code> unless it already has a higher value.</p>
<p>Setting a minimum height for a scene can be useful when it contains a ground level, and we want to ensure that no object ends up below it. The static value of <code>OBJECT_OT_elevator.floor</code> doesn’t help here, though, as it only applies to the case when the ground level equals <code>5.0</code>.</p>
<p>Luckily that was only for testing: the final version of the script makes use of an input parameter instead.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor093"/>Using input properties</h2>
<p>Replacing the static <code>floor</code> member in our operator with an editable value requires Blender to <a id="_idIndexMarker286"/>channel the user input to our Python script.</p>
<p>For that purpose, Blender’s API provides special properties that show up as graphic elements in the interface and can be used as variables in Python scripts. These properties are part of the <code>bpy.props</code> module.</p>
<p>To make <code>floor</code> an editable property of our operator:</p>
<ol>
<li>As <code>OBJECT_OT_elevator.floor</code> is a float number, so we need to use <code>FloatProperty</code>:<pre class="source-code">
import bpy</pre><pre class="source-code">
from bpy.props import FloatProperty</pre></li>
<li>Since we are forcing a specific type, we will use a Python <code>floor = 5.0</code> to <code>floor:FloatProperty(name="Floor", default=0)</code>.</li>
</ol>
<p class="callout-heading">Take note</p>
<p class="callout">Using an annotation in lieu of variables of a determined type is a best practice in Python, but it is required in Blender: the input property will not appear otherwise.</p>
<ol>
<li value="3">Then we must keep in mind that, because of how Blender works, operators that accept input values must be aware of the undo system. So, we add the <code>bl_options = {'REGISTER', '</code><code>UNDO'}</code> property.</li>
</ol>
<p>Here’s how the header of our operator looks now:</p>
<pre class="source-code">
class OBJECT_OT_elevator(bpy.types.Operator):
    """Move Objects up or down by given offset"""
    bl_idname = "object.pckt_type_collector"
    bl_label = "Create Type Collections"
    <code>bl_options = {'REGISTER', 'UNDO'}</code>
    <code>floor: FloatProperty(name="Floor", default=0)</code></pre>
<ol>
<li value="4">Refreshing the operators by pressing <em class="italic">F3</em> + <strong class="bold">Reload Scripts</strong> and executing <strong class="bold">Elevate Objects</strong> again displays the input properties inside an expansion popup at the bottom left of the screen:</li>
</ol>
<div><div><img alt="Figure 4.10: Our editable Floor property" height="123" src="img/Figure_4.10_B18375.jpg" width="561"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10: Our editable Floor property</p>
<p>Changing this property affects the minimum height of all selected objects.</p>
<p>So far, we have <a id="_idIndexMarker287"/>operated on the <code>location.z</code> attribute. This might not work if our object has a parent with a different orientation or scale. We can overcome that using the object world matrix instead.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor094"/>Setting the height in the world matrix</h2>
<p>Blender stores the <a id="_idIndexMarker288"/>object translation in the matrix’s last column, as seen in <em class="italic">Figure 4</em><em class="italic">.11</em>:</p>
<div><div><img alt="Figure 4.11: The entries of a transform matrix" height="354" src="img/Figure_4.11_B18375.jpg" width="601"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11: The entries of a transform matrix</p>
<p>The indices of <code>Matrix</code> point to its rows; so, to access location z, we need to get the third row and look for its fourth element. Since the enumeration starts with <code>0</code>, the indices we are looking for are, respectively, <code>[2]</code> and <code>[3]</code>.</p>
<p>Our <code>execute</code> function now uses <code>matrix_world[2][3]</code> instead of <code>location.z</code>. Since matrix values are not automatically updated during script execution, we’ll need to invoke <code>context.view_layer.update()</code> after the value is set:</p>
<pre class="source-code">
    def execute(self, context):
        selected_objects = context.selected_objects
        for ob in selected_objects:
            matrix_world = ob.matrix_world
            if <code>matrix_world[2][3]</code> &gt; self.floor:
                continue
            <code>matrix_world[2][3]</code> = self.floor
            # make sure next object matrix will be updated
            context.view_layer.update()
        return {'FINISHED'}</pre>
<p>This version <a id="_idIndexMarker289"/>of the script can handle the objects that inherit a parent transform, but what if the parent is also selected?</p>
<p>Moving a parent after a child has already been handled will change the positions of both, thus bringing the child to a wrong height.</p>
<p>We need to make sure that parent objects are always moved first.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor095"/>Avoiding duplicate transformations</h2>
<p>We need to <a id="_idIndexMarker290"/>reorder our list of objects, but with <code>context.selected_objects</code> being read-only, we cannot reorder it directly; we need to copy its content to a list.</p>
<h3>Copying selected_objects to an editable list</h3>
<p>We can use the <code>copy</code> module to create a <strong class="bold">shallow copy</strong> of that list. It will reference the same <a id="_idIndexMarker291"/>data but allow us to sort them at will:</p>
<pre class="source-code">
from copy import copy</pre>
<p>Then, in the <code>execute</code> method, locate the following code:</p>
<pre class="source-code">
selected_objects = context.selected_objects</pre>
<p>Replace it with this code:</p>
<pre class="source-code">
selected_objects = copy(context.selected_objects)</pre>
<p>Now we can order this list in a way that won’t cause the same object to be moved twice.</p>
<h3>Ordering by hierarchy</h3>
<p>To sort a list, we need a function that returns each element’s position in a new order.</p>
<p>We want to <a id="_idIndexMarker292"/>handle child objects only after their parents are already processed. Reordering the list so that objects with more ancestors are processed later will meet this condition.</p>
<p>We need a function that returns the number of ancestors: starting with an object, it checks whether it has a parent, and then whether that parent has a parent, until none is found. The <code>ancestors_count</code> function achieves that using a <code>while</code> loop:</p>
<pre class="source-code">
def ancestors_count(ob):
    """Return number of objects up in the hierarchy"""
    ancestors = 0
    while ob.parent:
        ancestors += 1
        ob = ob.parent
    return ancestors</pre>
<p>We add this function to our script and use it as the <code>key</code> argument of the <code>sort</code> method:</p>
<pre class="source-code">
    def execute(self, context):
        # sort parent objects first
        selected_objects = copy(context.selected_objects)
        selected_objects<code>.sort(key=ancestors_count)</code>
        for ob in selected_objects:
            world_mat = ob.matrix_world
            if world_mat[2][3] &gt; self.floor:
                continue
            # ensure update of next object's matrix
            world_mat[2][3] = self.floor
        return {'FINISHED'}</pre>
<p>Our add-on is <a id="_idIndexMarker293"/>now able to raise all the selected objects to a minimum height and avoids summing the transforms in hierarchies.</p>
<p>We could consider it finished, but since we know how to add constraints, we can use them for the same purpose.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor096"/>Adding the constraints switch</h2>
<p>We can allow <a id="_idIndexMarker294"/>the user to use constraints and leave the transform channels unaffected. This is how we can do it:</p>
<ol>
<li>Since we want to display a checkbox for using constraints, we need to add a Boolean property to our operator. We need to import <code>BoolProperty</code> as we did with <code>FloatProperty</code> earlier:<pre class="source-code">
from bpy.props import <code>BoolProperty</code></pre></li>
<li>Then we add a <code>BoolProperty</code> annotation to our operator:<pre class="source-code">
class OBJECT_OT_elevator(bpy.types.Operator):</pre><pre class="source-code">
    """Move Objects up or down by given offset"""</pre><pre class="source-code">
    bl_idname = "object.pckt_type_collector"</pre><pre class="source-code">
    bl_label = "Create Type Collections"</pre><pre class="source-code">
    bl_options = {'REGISTER', 'UNDO'}</pre><pre class="source-code">
    floor: FloatProperty(name="Floor", default=0)</pre><pre class="source-code">
    <code>constr: BoolProperty</code>(name="Constraints", default=False)</pre></li>
<li>We will use constraints when the <code>constr</code> property is set to <code>True</code>. We set it to <code>False</code> by default so that a new option doesn’t change the add-on’s behavior.</li>
<li>Using <a id="_idIndexMarker295"/>constraints makes our job easier; we don’t need to sort the objects and set their matrices. Our <code>execute</code> function now starts like this:<pre class="source-code">
def execute(self, context):</pre><pre class="source-code">
    <code>if self.constr</code>:</pre><pre class="source-code">
        for ob in context.selected_objects:</pre><pre class="source-code">
            limit = ob.constraints.new('LIMIT_LOCATION')</pre><pre class="source-code">
            limit.use_min_z = True</pre><pre class="source-code">
            limit.min_z = self.floor</pre><pre class="source-code">
        return {'FINISHED'}</pre><pre class="source-code">
    # affect coordinates directly</pre><pre class="source-code">
    # sort parent objects first</pre><pre class="source-code">
    …</pre></li>
</ol>
<p>If we use constraints, we can just exit the function, returning a <code>{'FINISHED'}</code> set as soon as we are done setting them. If we don’t, the <code>execute</code> function keeps going with the previous code.</p>
<p>The visual result is equivalent, but turning <strong class="bold">Constraints</strong> on doesn’t affect the transform channels. There is one last caveat: if the operator is run multiple times on the same objects, a new constraint is added.</p>
<p>We will make <strong class="bold">Elevate Objects</strong> reuse an existing constraint when it is found. That avoids creating <a id="_idIndexMarker296"/>too many constraints for the same purpose. It also prevents the effects of previous constraints from interfering. When an object has more than one limit to its location, only the more restrictive one is effective.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor097"/>Avoiding duplicate constraints</h2>
<p>If <strong class="bold">Limit Location</strong> is <a id="_idIndexMarker297"/>found on an object, our operator uses it. We make this behavior optional in case the user wants to create new constraints anyway:</p>
<ol>
<li>To do that, we add another Boolean property to our operator first:<pre class="source-code">
reuse: BoolProperty(name="Reuse Constraints", default=True)</pre></li>
<li>Then, inside our loop, we check for an existing constraint that we can use. If it is not found, our script creates it.</li>
</ol>
<p>This behavior can be implemented in a function:</p>
<pre class="source-code">
def get_constraint(ob, constr_type, reuse=True):
    """Return first constraint of given type.
    If not found, a new one is created"""
    if reuse:
        for constr in ob.constraints:
            if constr.type == constr_type:
                return constr
    return ob.constraints.new(constr_type)</pre>
<ol>
<li value="3">That has made our <code>execute</code> method much cleaner:<pre class="source-code">
def execute(self, context):</pre><pre class="source-code">
    if self.constr:</pre><pre class="source-code">
        for ob in context.selected_objects:</pre><pre class="source-code">
            <code>limit = get_constraint</code>(ob,</pre><pre class="source-code">
                                  'LIMIT_LOCATION',</pre><pre class="source-code">
                                   self.reuse)</pre><pre class="source-code">
            limit.use_min_z = True</pre><pre class="source-code">
            limit.min_z = self.floor</pre><pre class="source-code">
        return {'FINISHED'}</pre><pre class="source-code">
    …</pre></li>
</ol>
<p>If we reload <a id="_idIndexMarker298"/>the scripts and run the operator, we will see all its properties in the execution panel:</p>
<div><div><img alt="Figure 4.12: All the Elevate Objects options" height="211" src="img/Figure_4.12_B18375.jpg" width="561"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12: All the Elevate Objects options</p>
<p>Ideally, the <strong class="bold">Reuse</strong> property should be displayed only when <strong class="bold">Constraints</strong> is enabled, as it has no effect otherwise.</p>
<p>This is possible if we take care of drawing the user interface of our tools, which will be introduced in the next chapter.</p>
<p>For now, we have added a good deal of flexibility to a script that started as a very simple tool. This brings us to the end of the chapter, as we have covered most of the topics about writing custom tools.</p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor098"/>Summary</h1>
<p>In this chapter, we learned how to use <code>Vector</code>, <code>Quaternion</code>, and <code>Matrix</code> entities to our advantage, not to mention the different <em class="italic">rotation modes</em>. That gives us the elements for understanding and mastering the transformations in space and moving the objects in the scene.</p>
<p>We also learned how to create constraints in Python, which is very important in all set-up scripts.</p>
<p>Lastly, we learned how our operators can get user input and display their parameters inside the Blender user interface during their execution.</p>
<p>In <a href="B18375_05.xhtml#_idTextAnchor100"><em class="italic">Chapter 5</em></a>, we will learn how to code our own panels for the graphic interface and make its options aware of the context.</p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor099"/>Questions</h1>
<ol>
<li>What is a rigid transformation?</li>
<li>Can we convert coordinates between different rotation systems?</li>
<li>Can we convert coordinates between different rotation orders?</li>
<li>Why are quaternions useful for conversion?</li>
<li>In which form are transformations stored internally?</li>
<li>Are objects associated with only one transformation matrix?</li>
</ol>
</div>
</div></body></html>