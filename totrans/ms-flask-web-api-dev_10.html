<html><head></head><body>
		<div id="_idContainer113">
			<h1 id="_idParaDest-274" class="chapter-number"><a id="_idTextAnchor281"/><st c="0">10</st></h1>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor282"/><st c="3">Creating Test Cases for Flask</st></h1>
			<p><st c="33">After building the components of Flask, it is essential to create test cases to ensure their correctness and to fix their bugs. </st><st c="162">Among the types </st><a id="_idIndexMarker906"/><st c="178">of testing, </st><strong class="bold"><st c="190">unit testing</st></strong><st c="202"> focuses on testing the effectiveness and performance of components independent of other modules or tasks. </st><st c="309">On the other hand, </st><strong class="bold"><st c="328">integration testing</st></strong><st c="347"> ensures the correctness of a Flask</st><a id="_idIndexMarker907"/><st c="382"> component’s functionality and reliability with all its dependencies together </st><span class="No-Break"><st c="460">at runtime.</st></span></p>
			<p><st c="471">To implement these test cases, Python has a built-in module called </st><strong class="source-inline"><st c="539">unittest</st></strong><st c="547"> that can provide a </st><strong class="source-inline"><st c="567">TestCase</st></strong><st c="575"> superclass and the </st><strong class="source-inline"><st c="595">setUp()</st></strong><st c="602"> and </st><strong class="source-inline"><st c="607">tearDown()</st></strong><st c="617"> methods that build variations of test cases and test suites. </st><st c="679">There is also a third-party module called </st><strong class="source-inline"><st c="721">pytest</st></strong><st c="727">, which is simple, easy to use, and non-boilerplate and can provide reusable fixtures for setting up a test environment. </st><st c="848">In this chapter, we will highlight how to implement test cases using </st><strong class="source-inline"><st c="917">pytest</st></strong><st c="923"> for some selected functionalities from our projects in </st><em class="italic"><st c="979">Chapters 1</st></em> <span class="No-Break"><st c="989">to </st></span><span class="No-Break"><em class="italic"><st c="993">9</st></em></span><span class="No-Break"><st c="994">.</st></span></p>
			<p><st c="995">The main goal of this chapter is to provide Flask projects with the necessary test environments where we can run, study, scrutinize, analyze, and improve the Flask components without deploying the application. </st><st c="1206">Another goal of this chapter is to gain the mindset that testing, at least unit testing, is an essential part of any enterprise-grade </st><span class="No-Break"><st c="1340">application development.</st></span></p>
			<p><st c="1364">Here are the topics covered in </st><span class="No-Break"><st c="1396">this chapter:</st></span></p>
			<ul>
				<li><st c="1409">Creating test cases for web views, repository classes, and </st><span class="No-Break"><st c="1469">native services</st></span></li>
				<li><st c="1484">Creating test cases for components in application factory </st><span class="No-Break"><st c="1543">and Blueprints</st></span></li>
				<li><st c="1557">Creating test cases for </st><span class="No-Break"><st c="1582">asynchronous components</st></span></li>
				<li><st c="1605">Creating test cases for secured API and </st><span class="No-Break"><st c="1646">web components</st></span></li>
				<li><st c="1660">Creating test cases for </st><span class="No-Break"><st c="1685">MongoDB transactions</st></span></li>
				<li><st c="1705">Creating test cases </st><span class="No-Break"><st c="1726">for WebSockets</st></span></li>
			</ul>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor283"/><st c="1740">Technical requirements</st></h1>
			<p><st c="1763">All test cases will be from different applications created from </st><em class="italic"><st c="1828">Chapters 1</st></em><st c="1838"> to </st><em class="italic"><st c="1842">9</st></em><st c="1843">. All these applications are in this GitHub </st><span class="No-Break"><st c="1887">repositpry: </st></span><a href="https://github.com/PacktPublishing/Mastering-Flask-Web-Development"><span class="No-Break"><st c="1899">https://github.com/PacktPublishing/Mastering-Flask-Web-Development</st></span></a><span class="No-Break"><st c="1965">.</st></span></p>
			<h1 id="_idParaDest-277"><a id="_idTextAnchor284"/><st c="1966">Creating test cases for web views, repository classes, and native services</st></h1>
			<p><st c="2041">The </st><strong class="source-inline"><st c="2046">pytest</st></strong><st c="2052"> module supports unit </st><a id="_idIndexMarker908"/><st c="2074">and integration or functional testing. </st><st c="2113">It requires simple syntax to build test cases, which makes it very easy to use, and it has a</st><a id="_idIndexMarker909"/><st c="2205"> platform that can automatically run all test files. </st><st c="2258">Moreover, </st><strong class="source-inline"><st c="2268">pytest</st></strong><st c="2274"> is a free and open-source module, so install it </st><a id="_idIndexMarker910"/><st c="2323">using the following </st><span class="No-Break"><strong class="source-inline"><st c="2343">pip</st></strong></span><span class="No-Break"><st c="2346"> command:</st></span></p>
			<pre class="console"><st c="2355">
pip install pytest</st></pre>			<p><st c="2374">However, </st><strong class="source-inline"><st c="2384">pytest</st></strong><st c="2390"> will only work with Flask projects with directory structures managed by Blueprints and </st><em class="italic"><st c="2478">application factories</st></em><st c="2499">. Our </st><em class="italic"><st c="2505">Online Personal Counselling System</st></em><st c="2539"> in </st><a href="B19383_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><st c="2543">Chapter 1</st></em></span></a><st c="2552"> does not follow the Flask standards on directory structure. </st><st c="2613">All view modules import the </st><strong class="source-inline"><st c="2641">app</st></strong><st c="2644"> instance through </st><strong class="source-inline"><st c="2662">__main__</st></strong><st c="2670">, which becomes the </st><strong class="source-inline"><st c="2690">pytest</st></strong><st c="2696"> module and not the </st><strong class="source-inline"><st c="2716">main.py</st></strong><st c="2723"> module during testing. </st><st c="2747">Thus, testing our </st><strong class="source-inline"><st c="2765">ch01</st></strong><st c="2769"> project gives us the following runtime </st><span class="No-Break"><st c="2809">error message:</st></span></p>
			<pre class="console"><st c="2823">
ImportError cannot import name 'app' from '__main__'</st></pre>			<p><st c="2876">The error means there is no </st><strong class="source-inline"><st c="2905">app</st></strong><st c="2908"> object to import in the </st><strong class="source-inline"><st c="2933">pytest</st></strong><st c="2939"> module. </st><st c="2948">So, a testable and new version of the </st><em class="italic"><st c="2986">Online Personal Counselling System</st></em><st c="3020"> is in the </st><strong class="source-inline"><st c="3031">ch01-testing</st></strong><st c="3043"> project, which places all the view functions inside Python functions that the </st><strong class="source-inline"><st c="3122">main.py</st></strong><st c="3129"> module will access to pass the </st><strong class="source-inline"><st c="3161">app</st></strong><st c="3164"> instance. </st><st c="3175">The following </st><strong class="source-inline"><st c="3189">main.py</st></strong><st c="3196"> snippet shows these function calls replacing the view’s </st><span class="No-Break"><st c="3253">import statements:</st></span></p>
			<pre class="source-code"><st c="3271">
app = Flask(__name__, template_folder='pages')
… … … … … …
create_index_routes(app)
create_signup_routes(app)
create_examination_routes(app)
create_reports_routes(app)
create_admin_routes(app)
create_login_routes(app)
create_profile_routes(app)
create_certificates_routes(app)</st></pre>			<p><st c="3548">The view functions enclosed in each function will</st><a id="_idIndexMarker911"/><st c="3598"> utilize the </st><strong class="source-inline"><st c="3611">app</st></strong><st c="3614"> instance to implement the </st><strong class="source-inline"><st c="3641">GET</st></strong><st c="3644"> and </st><strong class="source-inline"><st c="3649">POST</st></strong><st c="3653"> routes. </st><st c="3662">Moreover, to</st><a id="_idIndexMarker912"/><st c="3674"> provide a testing environment from Flask, set the </st><strong class="source-inline"><st c="3725">Testing</st></strong><st c="3732"> environment to </st><strong class="source-inline"><st c="3748">true</st></strong><st c="3752"> in the </st><a id="_idIndexMarker913"/><span class="No-Break"><st c="3760">configuration file.</st></span></p>
			<p><st c="3779">Now, create a </st><strong class="source-inline"><st c="3794">tests</st></strong><st c="3799"> folder in the main folder of the accurately structured and circular-import-free Flask project directory adjacent to </st><strong class="source-inline"><st c="3916">main.py</st></strong><st c="3923">. In this folder, implement the test cases in module files with filenames prefixed with the </st><strong class="source-inline"><st c="4015">test_</st></strong><st c="4020"> keyword. </st><st c="4030">If the number of test cases increases, sub-folders can further organize these files according to functionality (e.g., views, repository, services, API, etc.) or type of testing (e.g., unit, integration). </st><span class="No-Break"><em class="italic"><st c="4234">Figure 10</st></em></span><em class="italic"><st c="4243">.1</st></em><st c="4245"> shows the final directory structure of the </st><strong class="source-inline"><st c="4289">ch01-testing</st></strong><st c="4301"> project with the </st><span class="No-Break"><strong class="source-inline"><st c="4319">tests</st></strong></span><span class="No-Break"><st c="4324"> folder.</st></span></p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B19383_10_001.jpg" alt="Figure 10.1 – The tests folder"/><st c="4332"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="4557">Figure 10.1 – The tests folder</st></p>
			<p><st c="4587">Now, run the </st><strong class="source-inline"><st c="4601">pytest</st></strong><st c="4607"> command as a module (</st><strong class="source-inline"><st c="4629">python -m pytest</st></strong><st c="4646">) to execute all the test methods, and run each</st><a id="_idIndexMarker914"/><st c="4694"> test file through the </st><span class="No-Break"><st c="4717">following command:</st></span></p>
			<pre class="console"><st c="4735">
python -m pytest tests/xxxx/test_xxxxxx.py</st></pre>			<p><st c="4778">Or, run an individual test function using the</st><a id="_idIndexMarker915"/> <span class="No-Break"><st c="4824">following command:</st></span></p>
			<pre class="console"><st c="4843">
python -m pytest tests/xxxx/test_xxxxxx.py::test_xxxxxxx</st></pre>			<p><st c="4900">Let us now explore </st><strong class="source-inline"><st c="4920">pytest</st></strong><st c="4926"> by creating</st><a id="_idIndexMarker916"/><st c="4938"> test cases for </st><strong class="source-inline"><st c="4954">ch01-testing</st></strong><st c="4966">’s model classes, repository transactions, native services, and </st><span class="No-Break"><st c="5031">view functions.</st></span></p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor285"/><st c="5046">Testing the model classes</st></h2>
			<p><st c="5072">One of the test files</st><a id="_idIndexMarker917"/><st c="5094"> that showcases unit testing is </st><strong class="source-inline"><st c="5126">test_models.py</st></strong><st c="5140">, which contains the </st><span class="No-Break"><st c="5161">following implementation:</st></span></p>
			<pre class="source-code"><st c="5186">
import pytest
from model.candidates import AdminUser
</st><strong class="bold"><st c="5240">@pytest.fixture(scope='module', autouse=True)</st></strong><st c="5285">
def admin_details(</st><strong class="bold"><st c="5304">scope="module"</st></strong><st c="5319">):
    data = {"id": 101, "position": "Supervisor","age": 45, "emp_date": "1980-02-16", "emp_status": "regular", "username": "pedro", "password": "pedro", "utype": 0, "firstname": "Pedro", "lastname" :"Cruz"}
    yield data
    data = None
def </st><strong class="bold"><st c="5552">test_admin_user_model</st></strong><st c="5573">(</st><strong class="bold"><st c="5575">admin_details</st></strong><st c="5588">):
    admin = AdminUser(**admin_details)
    </st><strong class="bold"><st c="5627">assert admin.firstname == "Pedro"</st></strong><strong class="bold"><st c="5660">assert admin.lastname == "Cruz"</st></strong><strong class="bold"><st c="5692">assert admin.age == 45</st></strong></pre>			<p><st c="5715">Unlike in </st><strong class="source-inline"><st c="5726">unittest</st></strong><st c="5734">, test cases in </st><strong class="source-inline"><st c="5750">pytest</st></strong><st c="5756"> are in the form of </st><em class="italic"><st c="5776">test functions</st></em><st c="5790">. The test function’s name is unique, descriptive</st><a id="_idIndexMarker918"/><st c="5839"> of its purpose, and must start with the </st><strong class="source-inline"><st c="5880">_test</st></strong><st c="5885"> keyword like its test file. </st><st c="5914">Its code structure follows the </st><strong class="bold"><st c="5945">Given-When-Then</st></strong><st c="5960"> (</st><strong class="bold"><st c="5962">GWT</st></strong><st c="5965">) format, where </st><strong class="bold"><st c="5982">Given</st></strong><st c="5987"> establishes the initial setup of the testing environment, </st><strong class="bold"><st c="6046">When</st></strong><st c="6050"> runs the</st><a id="_idIndexMarker919"/><st c="6059"> components that need testing, and </st><strong class="bold"><st c="6094">Then</st></strong><st c="6098"> scrutinizes the expected response for each test execution. </st><st c="6158">In the given </st><strong class="source-inline"><st c="6171">test_models.py</st></strong><st c="6185">, the </st><em class="italic"><st c="6191">Given</st></em><st c="6196"> part is the creating of </st><strong class="source-inline"><st c="6221">admin_details</st></strong><st c="6234"> fixture, the </st><em class="italic"><st c="6248">When</st></em><st c="6252"> is the instantiation of the </st><strong class="source-inline"><st c="6281">AdminUser</st></strong><st c="6290"> class, and the </st><em class="italic"><st c="6306">Then</st></em><st c="6310"> depicts the series of asserts that validates if the extracted </st><strong class="source-inline"><st c="6373">firstname</st></strong><st c="6382">, </st><strong class="source-inline"><st c="6384">lastname</st></strong><st c="6392">, and </st><strong class="source-inline"><st c="6398">age</st></strong><st c="6401"> response details are precisely the same as the inputs. </st><st c="6457">Unlike the </st><strong class="source-inline"><st c="6468">unittest</st></strong><st c="6476">, </st><strong class="source-inline"><st c="6478">pytest</st></strong><st c="6484"> only uses the </st><strong class="source-inline"><st c="6499">assert</st></strong><st c="6505"> statement and the needed conditional expression to </st><span class="No-Break"><st c="6557">perform assertion.</st></span></p>
			<p><st c="6575">The input to the </st><strong class="source-inline"><st c="6593">test_admin_user_model()</st></strong><st c="6616"> test case is an injectable and reusable admin record created through </st><strong class="source-inline"><st c="6686">pytest</st></strong><st c="6692">’s </st><strong class="source-inline"><st c="6696">fixture()</st></strong><st c="6705">. The </st><strong class="source-inline"><st c="6711">pytest</st></strong><st c="6717"> module has a decorator function called </st><strong class="source-inline"><st c="6757">fixture()</st></strong><st c="6766"> that defines functions as injectable resources. </st><st c="6815">Like in </st><strong class="source-inline"><st c="6823">unittest</st></strong><st c="6831">, </st><strong class="source-inline"><st c="6833">pytest</st></strong><st c="6839">’s fixture performs </st><strong class="source-inline"><st c="6860">setUp()</st></strong><st c="6867"> before the call to </st><strong class="source-inline"><st c="6887">yield</st></strong><st c="6892"> and </st><strong class="source-inline"><st c="6897">tearDown()</st></strong><st c="6907"> after the yielding of the resource. </st><st c="6944">In the given </st><strong class="source-inline"><st c="6957">test_models.py</st></strong><st c="6971">, the fixture sets up the </st><a id="_idIndexMarker920"/><st c="6997">admin details in JSON format, and garbage collects the JSON object data after the </st><strong class="source-inline"><st c="7079">yield</st></strong><st c="7084"> statement. </st><st c="7096">But how do test methods utilize </st><span class="No-Break"><st c="7128">these fixtures?</st></span></p>
			<p><st c="7143">A fixture function has </st><span class="No-Break"><st c="7167">four scopes:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="7179">function</st></strong><st c="7188">: This fixture runs</st><a id="_idIndexMarker921"/><st c="7208"> only once exclusively on some selected test methods in a </st><span class="No-Break"><st c="7266">test file.</st></span></li>
				<li><strong class="source-inline"><st c="7276">class</st></strong><st c="7282">: This fixture runs only once on a test class containing test methods that require </st><span class="No-Break"><st c="7366">the resource.</st></span></li>
				<li><strong class="source-inline"><st c="7379">module</st></strong><st c="7386">: This fixture runs only once on a test file containing the test methods that require </st><span class="No-Break"><st c="7473">the resource.</st></span></li>
				<li><strong class="source-inline"><st c="7486">package</st></strong><st c="7494">: This fixture runs only once on a package level containing the test methods that require </st><span class="No-Break"><st c="7585">the resource.</st></span></li>
				<li><strong class="source-inline"><st c="7598">session</st></strong><st c="7606">: This fixture runs only once to be distributed across all test methods that require the resource in </st><span class="No-Break"><st c="7708">a session.</st></span></li>
			</ul>
			<p><st c="7718">To utilize the fixture during its scoped execution, inject the resource function to test the method’s parameter list. </st><st c="7837">Our </st><strong class="source-inline"><st c="7841">admin_details()</st></strong><st c="7856"> fixture executes at the module level and is injected into </st><strong class="source-inline"><st c="7915">test_admin_user_model()</st></strong><st c="7938"> through the parameter list. </st><st c="7967">On the other hand, </st><strong class="source-inline"><st c="7986">fixture()</st></strong><st c="7995">’s </st><strong class="source-inline"><st c="7999">autouse</st></strong><st c="8006"> forces all test methods to request the resource </st><span class="No-Break"><st c="8055">during testing.</st></span></p>
			<p><st c="8070">To run our test file, execute the </st><strong class="source-inline"><st c="8105">python -m pytest tests/repository/test_models.py</st></strong><st c="8153"> command. </st><st c="8163">If the testing is successful, the console output will be similar to </st><span class="No-Break"><em class="italic"><st c="8231">Figure 10</st></em></span><span class="No-Break"><em class="italic"><st c="8240">.2</st></em></span><span class="No-Break"><st c="8242">:</st></span></p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B19383_10_002.jpg" alt="Figure 10.2 – The pytest result when a test succeeded"/><st c="8244"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="8801">Figure 10.2 – The pytest result when a test succeeded</st></p>
			<p><st c="8854">The </st><strong class="source-inline"><st c="8859">pytest</st></strong><st c="8865"> result includes the </st><strong class="source-inline"><st c="8886">pytest</st></strong><st c="8892"> plugin installed and its configuration details, a testing directory, and a horizontal </st><a id="_idIndexMarker922"/><st c="8979">green marker indicating the number of successful tests executed. </st><st c="9044">On the other hand, the console output will be similar to </st><span class="No-Break"><em class="italic"><st c="9101">Figure 10</st></em></span><em class="italic"><st c="9110">.2</st></em><st c="9112"> if a test </st><span class="No-Break"><st c="9123">case fails:</st></span></p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B19383_10_003.jpg" alt="Figure 10.3 – The pytest result when a test failed"/><st c="9134"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="9628">Figure 10.3 – The pytest result when a test failed</st></p>
			<p><st c="9678">The console will show the assertion statement that fails and a short description of </st><strong class="source-inline"><st c="9763">AssertionError</st></strong><st c="9777">. Now, test cases must only catch </st><strong class="source-inline"><st c="9811">AssertionError</st></strong><st c="9825"> due to failed assertions and nothing else because it is understood that codes under testing have already handled all </st><strong class="source-inline"><st c="9943">RuntimeError</st></strong><st c="9955"> internally using </st><strong class="source-inline"><st c="9973">try-except</st></strong> <span class="No-Break"><st c="9983">before testing.</st></span></p>
			<p><st c="9999">A few components in </st><strong class="source-inline"><st c="10020">ch01-testing</st></strong><st c="10032"> need unit testing. </st><st c="10052">Almost all components are connected to build functionality crucial to the application, such as database connection and </st><span class="No-Break"><st c="10171">repository transactions.</st></span></p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor286"/><st c="10195">Testing the repository classes</st></h2>
			<p><st c="10226">At this point, we will start highlighting functional or integration test cases for our application. </st><st c="10327">Our </st><strong class="source-inline"><st c="10331">ch01-testing</st></strong><st c="10343"> project uses </st><strong class="source-inline"><st c="10357">psycopgy2</st></strong><st c="10366">’s cursor methods to implement the database transactions. </st><st c="10425">To</st><a id="_idIndexMarker923"/><st c="10427"> impose a clean approach, a custom decorator </st><strong class="source-inline"><st c="10472">connect_db()</st></strong><st c="10484"> decorates all repository transactions to provide the connection object for the </st><strong class="source-inline"><st c="10564">execute()</st></strong><st c="10573"> and </st><strong class="source-inline"><st c="10578">fetchall()</st></strong><st c="10588"> cursor methods. </st><st c="10605">But first, it is always a standard practice to check whether all database connection details, such as </st><strong class="source-inline"><st c="10707">DB_USER</st></strong><st c="10714">, </st><strong class="source-inline"><st c="10716">DB_PASSWORD</st></strong><st c="10727">, </st><strong class="source-inline"><st c="10729">DB_PORT</st></strong><st c="10736">, </st><strong class="source-inline"><st c="10738">DB_HOST</st></strong><st c="10745">, and </st><strong class="source-inline"><st c="10751">DB_NAME</st></strong><st c="10758">, are all registered as environment variables in the configuration file. </st><st c="10831">The following test case implementation showcases how to test custom decorators that provide database connection to </st><span class="No-Break"><st c="10946">repository transactions:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="10970">from config.db import connect_db</st></strong><st c="11003">
def test_connection():
    </st><strong class="bold"><st c="11027">@connect_db</st></strong><st c="11038">
    def create_connection(conn):
        </st><strong class="bold"><st c="11068">assert conn is not None</st></strong><st c="11091">
    create_connection()</st></pre>			<p><st c="11111">The local </st><strong class="source-inline"><st c="11122">create_connection()</st></strong><st c="11141"> method will capture the </st><strong class="source-inline"><st c="11166">conn</st></strong><st c="11170"> object from the </st><strong class="source-inline"><st c="11187">db_connect()</st></strong><st c="11199"> decorator. </st><st c="11211">Its purpose as a dummy transaction is to assert whether the </st><strong class="source-inline"><st c="11271">conn</st></strong><st c="11275"> object created by </st><strong class="source-inline"><st c="11294">psycopgy2</st></strong><st c="11303"> with the database details is valid and ready for CRUD operations. </st><st c="11370">This approach will also apply to other test cases implemented to check the validity and correctness of custom decorator functions, database-oriented or not. </st><st c="11527">Now, run the </st><strong class="source-inline"><st c="11540">python -m pytest tests/repository/test_db_connect.py</st></strong><st c="11592"> command to check whether the database </st><span class="No-Break"><st c="11631">configurations work.</st></span></p>
			<p><st c="11651">Let us now concentrate on testing repository transactions with database connection and test data generated </st><span class="No-Break"><st c="11759">by </st></span><span class="No-Break"><strong class="source-inline"><st c="11762">pytest</st></strong></span><span class="No-Break"><st c="11768">.</st></span></p>
			<h3><st c="11769">Passing test data to test functions</st></h3>
			<p><st c="11805">If testing the database connection is successful, the next test cases must check and refine the repository classes and their CRUD transactions. </st><st c="11950">The following test function of </st><strong class="source-inline"><st c="11981">test_repo_admin.py</st></strong><st c="11999"> showcases </st><a id="_idIndexMarker924"/><st c="12010">how to test an </st><strong class="source-inline"><st c="12025">INSERT</st></strong><st c="12031"> admin detail transaction using </st><strong class="source-inline"><st c="12063">cursor()</st></strong> <span class="No-Break"><st c="12071">from </st></span><span class="No-Break"><strong class="source-inline"><st c="12077">psycopg2</st></strong></span><span class="No-Break"><st c="12085">:</st></span></p>
			<pre class="source-code"><st c="12087">
import pytest
from repository.admin import insert_admin
</st><strong class="bold"><st c="12144">@pytest.mark.parametrize(("id", "fname", "lname", "age", "position", "date_employed", "status"),</st></strong><st c="12240">
  (("8999", "Juan", "Luna", 76, "Manager", "2010-10-10", "active"),
   ("9999", "Maria", "Clara", 45, "Developer", "2015-08-15", "inactive")
))
def test_insert_admin(</st><strong class="bold"><st c="12402">id,</st></strong> <strong class="bold"><st c="12406">fname, lname, age, position, date_employed, status</st></strong><st c="12457">):
    result = insert_admin(</st><strong class="bold"><st c="12483">id, fname, lname, age, position, date_employed, status</st></strong><st c="12538">)
    assert result is True</st></pre>			<p><strong class="bold"><st c="12562">Pytest markers</st></strong><st c="12577"> or the </st><strong class="source-inline"><st c="12585">pytest.mark</st></strong><st c="12596"> attribute provides additional metadata to test functions by adding built-in markers, such</st><a id="_idIndexMarker925"/><st c="12686"> as the </st><strong class="source-inline"><st c="12694">userfixtures()</st></strong><st c="12708">, </st><strong class="source-inline"><st c="12710">skip()</st></strong><st c="12716">, </st><strong class="source-inline"><st c="12718">xfail()</st></strong><st c="12725">, </st><strong class="source-inline"><st c="12727">filterwarnings()</st></strong><st c="12743">, and </st><strong class="source-inline"><st c="12749">parametrize()</st></strong><st c="12762"> decorators. </st><st c="12775">With </st><strong class="bold"><st c="12780">parameterized testing</st></strong><st c="12801">, the </st><strong class="source-inline"><st c="12807">parametrize()</st></strong><st c="12820"> marker generates and provides a set of test data </st><a id="_idIndexMarker926"/><st c="12870">to test functions using the local parameter list. </st><st c="12920">The test functions will utilize these multiple inputs to produce varying </st><span class="No-Break"><st c="12993">assert results.</st></span></p>
			<p><strong class="source-inline"><st c="13008">test_insert_admin()</st></strong><st c="13028"> has local parameters corresponding to the parameter names indicated in the </st><strong class="source-inline"><st c="13104">parametrize()</st></strong><st c="13117"> marker. </st><st c="13126">The marker will pass all these inputs to their respective local parameters in the test function to make the testing happen. </st><st c="13250">It will also seem to iterate all the tuples of inputs in the decorator until the test function consumes all the inputs. </st><st c="13370">Running </st><strong class="source-inline"><st c="13378">test_insert_admin()</st></strong><st c="13397"> gave me </st><span class="No-Break"><em class="italic"><st c="13406">Figure 10</st></em></span><em class="italic"><st c="13415">.4</st></em><st c="13417">, proof that </st><strong class="source-inline"><st c="13430">@pytest.mark.parametrize()</st></strong><st c="13456"> iterates all its </st><span class="No-Break"><st c="13474">test inputs.</st></span></p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B19383_10_004.jpg" alt="Figure 10.4 – Result of parameterized testing"/><st c="13486"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="13786">Figure 10.4 – Result of parameterized testing</st></p>
			<p><st c="13831">But how about if there</st><a id="_idIndexMarker927"/><st c="13854"> is a need to control the behaviors of some external components connected to the functionality</st><a id="_idIndexMarker928"/><st c="13948"> under testing? </st><st c="13964">Let us now </st><span class="No-Break"><st c="13975">discuss </st></span><span class="No-Break"><strong class="bold"><st c="13983">mocking</st></strong></span><span class="No-Break"><st c="13990">.</st></span></p>
			<h3><st c="13991">Mocking other functionality during testing</st></h3>
			<p><st c="14034">Now, there are times in integration or functionality testing when applying control to other dependencies or systems </st><a id="_idIndexMarker929"/><st c="14151">connected to a feature is necessary to test and analyze that specific feature. </st><st c="14230">Controlling other connected parts requires the process of </st><strong class="bold"><st c="14288">mocking</st></strong><st c="14295">, which is another type of unit testing that focuses on one functionality while controlling the behavior of its external dependencies using their equivalent mock objects or fake functions. </st><st c="14484">To employ mocking in </st><strong class="source-inline"><st c="14505">pytest</st></strong><st c="14511">, install </st><strong class="source-inline"><st c="14521">pytest-mock</st></strong><st c="14532"> first using the following </st><span class="No-Break"><strong class="source-inline"><st c="14559">pip</st></strong></span><span class="No-Break"><st c="14562"> command:</st></span></p>
			<pre class="console"><st c="14571">
pip install pytest-mock</st></pre>			<p><st c="14595">The </st><strong class="source-inline"><st c="14600">pytest-mock</st></strong><st c="14611"> plugin derives its mocking capability from the </st><strong class="source-inline"><st c="14659">unittest.mock</st></strong><st c="14672"> but provides a cleaner and simpler approach. </st><st c="14718">Because of that, using some helper classes and methods, such as the </st><strong class="source-inline"><st c="14786">patch()</st></strong><st c="14793"> decorator, from </st><strong class="source-inline"><st c="14810">unittest.mock</st></strong><st c="14823"> will work with the </st><strong class="source-inline"><st c="14843">pytest-mock</st></strong><st c="14854"> module. </st><st c="14863">Another option is to install and use the </st><strong class="source-inline"><st c="14904">mock</st></strong><st c="14908"> extension module, which is an acceptable replacement </st><span class="No-Break"><st c="14962">for </st></span><span class="No-Break"><strong class="source-inline"><st c="14966">unittest.mock</st></strong></span><span class="No-Break"><st c="14979">.</st></span></p>
			<p><st c="14980">The following </st><strong class="source-inline"><st c="14995">test_mock_insert_admin()</st></strong><st c="15019"> mocks the </st><strong class="source-inline"><st c="15030">psycopg2</st></strong><st c="15038"> connection to focus the testing solely on the correctness and performance of the </st><strong class="source-inline"><st c="15120">INSERT</st></strong><st c="15126"> admin profile </st><span class="No-Break"><st c="15141">details process:</st></span></p>
			<pre class="source-code"><st c="15157">
import pytest
</st><strong class="bold"><st c="15172">from unittest.mock import patch</st></strong><st c="15203">
from repository.admin import insert_admin
@pytest.mark.parametrize(("id", "fname", "lname", "age", "position", "date_employed", "status"),
 (("8999", "Juan", "Luna", 76, "Manager", "2010-10-10", "active"),
  ("9999", "Maria", "Clara", 45, "Developer", "2015-08-15", "inactive")
))
</st><strong class="bold"><st c="15482">@patch("psycopg2.connect")</st></strong><st c="15508">
def test_mock_insert_admin(</st><strong class="bold"><st c="15536">mock_connect</st></strong><st c="15549">, id, fname, lname, age, position, date_employed, status):
    </st><strong class="bold"><st c="15608">mocked_conn = mock_connect.return_value</st></strong><strong class="bold"><st c="15647">mock_cur = mocked_conn.cursor.return_value</st></strong><st c="15690">
    result = insert_admin(id, fname, lname, age, position, date_employed, status)
    </st><strong class="bold"><st c="15769">mock_cur.execute.assert_called_once()</st></strong><strong class="bold"><st c="15806">mocked_conn.commit.assert_called_once()</st></strong><st c="15846">
    assert result is True</st></pre>			<p><st c="15868">Instead of using the database connection, </st><strong class="source-inline"><st c="15911">test_mock_insert_admin()</st></strong><st c="15935"> mocks </st><strong class="source-inline"><st c="15942">psycopgy2.connect()</st></strong><st c="15961">and replaces it with a </st><strong class="source-inline"><st c="15985">mock_connect</st></strong><st c="15997"> mock object through the </st><strong class="source-inline"><st c="16022">patch()</st></strong><st c="16029"> decorator of </st><strong class="source-inline"><st c="16043">unittest.mock</st></strong><st c="16056">. The </st><strong class="source-inline"><st c="16062">patch()</st></strong><st c="16069"> decorator or context manager makes mocking easier by decorating the test functions in a test class or module. </st><st c="16180">The first decorator passes the mock object to the first parameter of the test function, followed by other mock </st><a id="_idIndexMarker930"/><st c="16291">objects, if there are any, in the same order as their corresponding </st><strong class="source-inline"><st c="16359">@patch()</st></strong><st c="16367"> decorator in the layer of decorators. </st><st c="16406">The </st><strong class="source-inline"><st c="16410">pytest</st></strong><st c="16416"> module will restore to their original state all mocked objects </st><span class="No-Break"><st c="16480">after testing.</st></span></p>
			<p><st c="16494">A mocked object emits a </st><strong class="source-inline"><st c="16519">return_value</st></strong><st c="16531"> attribute to set its value when invoked or to call the mocked object’s properties or methods. </st><st c="16626">In the given </st><strong class="source-inline"><st c="16639">test_mock_insert_admin()</st></strong><st c="16663">, the </st><strong class="source-inline"><st c="16669">mocked_conn</st></strong><st c="16680"> and </st><strong class="source-inline"><st c="16685">mock_curr</st></strong><st c="16694"> objects were derived from calling </st><strong class="source-inline"><st c="16729">return_value</st></strong><st c="16741"> of the mocked database connection (</st><strong class="source-inline"><st c="16777">mock_connect</st></strong><st c="16790">) and the mocked </st><span class="No-Break"><strong class="source-inline"><st c="16808">cursor()</st></strong></span><span class="No-Break"><st c="16816"> method.</st></span></p>
			<p><st c="16824">Moreover, mocked objects also emit assert methods such as </st><strong class="source-inline"><st c="16883">assert_called()</st></strong><st c="16898">, </st><strong class="source-inline"><st c="16900">assert_not_called()</st></strong><st c="16919">, </st><strong class="source-inline"><st c="16921">assert_called_once()</st></strong><st c="16941">, </st><strong class="source-inline"><st c="16943">assert_called_once_with()</st></strong><st c="16968">, and </st><strong class="source-inline"><st c="16974">assert_called_with()</st></strong><st c="16994"> to verify the invocation of these mocked objects during testing. </st><st c="17060">The </st><strong class="source-inline"><st c="17064">assert_called_once_with()</st></strong><st c="17089"> and </st><strong class="source-inline"><st c="17094">assert_called_with()</st></strong><st c="17114"> methods verify the call of the mocked objects based on specific constraints or arguments. </st><st c="17205">Our example verifies the execution of the mocked </st><strong class="source-inline"><st c="17254">cursor()</st></strong><st c="17262"> and </st><strong class="source-inline"><st c="17267">commit()</st></strong><st c="17275"> methods in the </st><strong class="source-inline"><st c="17291">INSERT</st></strong><st c="17297"> transaction </st><span class="No-Break"><st c="17310">under testing.</st></span></p>
			<p><st c="17324">Another use of </st><strong class="source-inline"><st c="17340">return_value</st></strong><st c="17352"> is to </st><a id="_idIndexMarker931"/><st c="17359">mock the result of the function under test to focus on testing the performance or algorithm of the transaction. </st><st c="17471">The following test case implementation shows mocking the return value of the </st><span class="No-Break"><strong class="source-inline"><st c="17548">select_all_user()</st></strong></span><span class="No-Break"><st c="17565"> transaction:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="17578">@patch("psycopg2.connect")</st></strong><st c="17605">
def test_mock_select_users(</st><strong class="bold"><st c="17633">mock_connect</st></strong><st c="17646">):
    expected_rec = [(222, "sjctrags", "sjctrags", "2023-02-26"), ( 567, "owen", "owen", "2023-10-22")]
    </st><strong class="bold"><st c="17749">mocked_conn = mock_connect.return_value</st></strong><strong class="bold"><st c="17788">mock_cur = mocked_conn.cursor.return_value</st></strong><strong class="bold"><st c="17831">mock_cur.fetchall.return_value = expected_rec</st></strong><st c="17877">
    result = select_all_user()
    assert result is expect_rec</st></pre>			<p><st c="17932">The purpose of setting </st><strong class="source-inline"><st c="17956">expected_rec</st></strong><st c="17968"> to </st><strong class="source-inline"><st c="17972">return_value</st></strong><st c="17984"> of the mocked </st><strong class="source-inline"><st c="17999">fetchall()</st></strong><st c="18009"> method of </st><strong class="source-inline"><st c="18020">mock_cur</st></strong><st c="18028"> is to establish an assertion that will complete the GWT process of the test case. </st><st c="18111">The goal is to run and scrutinize the performance and correctness of the algorithms in </st><strong class="source-inline"><st c="18198">select_all_user()</st></strong><st c="18215"> with the mocked </st><strong class="source-inline"><st c="18232">cursor()</st></strong><st c="18240"> and </st><span class="No-Break"><strong class="source-inline"><st c="18245">fetchall()</st></strong></span><span class="No-Break"><st c="18255"> methods.</st></span></p>
			<p><st c="18264">Aside from repository methods, native services also need thorough testing to examine their impact on </st><span class="No-Break"><st c="18366">the application.</st></span></p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor287"/><st c="18382">Testing the native services</st></h2>
			<p><st c="18410">Native services or transactions in the service layer build the business processes and logic of the Flask application. </st><st c="18529">The following test</st><a id="_idIndexMarker932"/><st c="18547"> case implementation performs testing on </st><strong class="source-inline"><st c="18588">record_patient_exam()</st></strong><st c="18609">, which stores the patient’s counseling exams in the database and computes the average score given </st><span class="No-Break"><st c="18708">the data:</st></span></p>
			<pre class="source-code"><st c="18717">
import pytest
from services.patient_monitoring import record_patient_exam
@pytest.fixture
def exam_details():
     params = dict()
     params['pid'] = 1111
     params['qid'] = 568
     params['score'] = 87
     params['total'] = 100
     yield params
def test_record_patient_exam(exam_details):
    result = record_patient_exam(exam_details)
    assert result is True</st></pre>			<p><st c="19049">The function-scoped fixture generated the test data for the test function. </st><st c="19125">The result of testing </st><strong class="source-inline"><st c="19147">record_patient_exam()</st></strong><st c="19168"> will depend on the </st><strong class="source-inline"><st c="19188">insert_patient_score()</st></strong><st c="19210"> repository transaction with the actual </st><span class="No-Break"><st c="19250">database connection.</st></span></p>
			<p><st c="19270">The next things to test are the view functions. </st><st c="19319">What are the aspects of a view function that require testing? </st><st c="19381">Is it feasible to test views without </st><span class="No-Break"><st c="19418">using browsers?</st></span></p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor288"/><st c="19433">Testing the view functions</st></h2>
			<p><st c="19460">The Flask </st><strong class="source-inline"><st c="19471">app</st></strong><st c="19474"> instance has a </st><strong class="source-inline"><st c="19490">test_client()</st></strong><st c="19503"> utility </st><a id="_idIndexMarker933"/><st c="19512">to handle </st><strong class="source-inline"><st c="19522">GET</st></strong><st c="19525"> and </st><strong class="source-inline"><st c="19530">POST</st></strong><st c="19534"> routes. </st><st c="19543">This method generates an object of the </st><strong class="source-inline"><st c="19582">Client</st></strong><st c="19588"> type, a built-in class to Werkzeug. </st><st c="19625">A test file should have a fixture to set up the </st><strong class="source-inline"><st c="19673">test_client()</st></strong><st c="19686"> context and yield the </st><strong class="source-inline"><st c="19709">Client</st></strong><st c="19715"> instance to each test function for views. </st><st c="19758">The following test case implementation focuses on testing </st><strong class="source-inline"><st c="19816">GET</st></strong><st c="19819"> routes with a fixture that yields the </st><strong class="source-inline"><st c="19858">Client</st></strong>  <span class="No-Break"><st c="19864">instance:</st></span></p>
			<pre class="source-code"><st c="19874">
import pytest
from main import app as flask_app
</st><strong class="bold"><st c="19923">@pytest.fixture(autouse=True)</st></strong><st c="19952">
def client():
   </st><strong class="bold"><st c="19967">with flask_app.test_client() as client:</st></strong><strong class="bold"><st c="20006">yield client</st></strong><st c="20019">
def test_default_page(client):
    </st><strong class="bold"><st c="20051">res = client.get("/")</st></strong><strong class="bold"><st c="20072">assert "OPCS" in res.data.decode()</st></strong></pre>			<p><st c="20107">This </st><strong class="source-inline"><st c="20113">test_default_page()</st></strong><st c="20132"> runs the root page using the </st><strong class="source-inline"><st c="20162">Client</st></strong><st c="20168"> instance and checks whether the rendered Jinja template contains the </st><strong class="source-inline"><st c="20238">"OPCS"</st></strong><st c="20244"> substring. </st><strong class="source-inline"><st c="20256">res.data</st></strong><st c="20264"> is always in bytes, so decoding it will give us the </st><span class="No-Break"><st c="20317">string equivalent:</st></span></p>
			<pre class="source-code"><st c="20335">
def test_home_page(client):
    </st><strong class="bold"><st c="20364">res = client.get("/home")</st></strong><st c="20389">
    assert "Welcome" in res.data.decode()
    assert res.request.path == "/home"</st></pre>			<p><st c="20462">On the other hand, </st><strong class="source-inline"><st c="20482">test_home_page()</st></strong><st c="20498"> runs the </st><strong class="source-inline"><st c="20508">/home GET</st></strong><st c="20517"> route and verifies whether there is a </st><strong class="source-inline"><st c="20556">"Welcome"</st></strong><st c="20565"> word on its template page. </st><st c="20593">Also, it checks whether the path of the rendered page is still the </st><strong class="source-inline"><st c="20660">/home</st></strong> <span class="No-Break"><st c="20665">URL path:</st></span></p>
			<pre class="source-code"><st c="20675">
def test_exam_page(client):
    </st><strong class="bold"><st c="20704">res = client.get("/exam/assign")</st></strong><st c="20736">
    assert res.status_code == 200</st></pre>			<p><st c="20766">It is also ideal to verify the status code of the </st><strong class="source-inline"><st c="20817">client.get()</st></strong><st c="20829">’s response. </st><st c="20843">The given </st><strong class="source-inline"><st c="20853">test_exam_page()</st></strong><st c="20869"> checks </st><a id="_idIndexMarker934"/><st c="20877">whether running the </st><strong class="source-inline"><st c="20897">/exam/assign</st></strong><st c="20909"> URL will result in an HTTP Status </st><span class="No-Break"><st c="20944">Code 200.</st></span></p>
			<p><st c="20953">On the other hand, the </st><strong class="source-inline"><st c="20977">Client</st></strong><st c="20983"> instance has a </st><strong class="source-inline"><st c="20999">post()</st></strong><st c="21005"> method to test and run </st><strong class="source-inline"><st c="21029">POST</st></strong><st c="21033"> routes. </st><st c="21042">The following implementation shows how to simulate </st><span class="No-Break"><st c="21093">form-handling transactions:</st></span></p>
			<pre class="source-code"><st c="21120">
import pytest
from main import app as flask_app
@pytest.fixture(autouse=True)
def client():
   with flask_app.test_client() as client:
       yield client
@pytest.fixture(autouse=True)
def form_data():
    params = dict()
    params["username"] = "jean"
    params["password"] = "jean"
    … … … … … …
    yield params
    params = None
def test_signup_post(client, form_data):
    </st><strong class="bold"><st c="21465">response = client.post("/signup/submit",</st></strong> <strong class="bold"><st c="21505">data=form_data)</st></strong><st c="21521">
    assert response.status_code == 200</st></pre>			<p><st c="21556">Since form parameters are ideally in a hashtable format, fixtures must yield these form parameters with their corresponding values inside a dictionary collection, like in our </st><strong class="source-inline"><st c="21732">form_data()</st></strong><st c="21743"> fixture. </st><st c="21753">Then, we pass this yielded form data to the data parameter of the </st><strong class="source-inline"><st c="21819">client.post()</st></strong><st c="21832"> method. </st><st c="21841">Afterward, we perform the necessary assertions to verify the correctness of the view procedure and </st><span class="No-Break"><st c="21940">its response.</st></span></p>
			<p><st c="21953">Aside from checking the</st><a id="_idIndexMarker935"/><st c="21977"> rendered URL path, content, and status code of a </st><strong class="source-inline"><st c="22027">GET</st></strong><st c="22030"> route, it is also feasible to test redirections in a view using </st><strong class="source-inline"><st c="22095">pytest</st></strong><st c="22101">. The following implementation showcases how to test whether a </st><strong class="source-inline"><st c="22164">POST</st></strong><st c="22168"> transaction redirected a user to another </st><span class="No-Break"><st c="22210">view page:</st></span></p>
			<pre class="source-code"><st c="22220">
def test_assign_exam_redirect(client, form_data):
    res = client.post('/exam/assign', data=form_data, </st><strong class="bold"><st c="22321">follow_redirects=True</st></strong><st c="22342">)
    </st><strong class="bold"><st c="22345">assert res.status == '200 OK'</st></strong><strong class="bold"><st c="22374">assert res.request.path ==</st></strong> <strong class="bold"><st c="22401">url_for('redirect_success_exam')</st></strong></pre>			<p><st c="22434">The goal of </st><strong class="source-inline"><st c="22447">test_assign_exam_redirect()</st></strong><st c="22474"> is to test the </st><strong class="source-inline"><st c="22490">/exam/assign</st></strong> <strong class="source-inline"><st c="22502">POST</st></strong><st c="22507"> transaction and see whether it can successfully persist the score details (</st><strong class="source-inline"><st c="22583">form_data</st></strong><st c="22593">) from the counseling exam and compute the rating based on the total number of exam items. </st><st c="22685">The </st><strong class="source-inline"><st c="22689">client.post()</st></strong><st c="22702"> method has a </st><strong class="source-inline"><st c="22716">follow_redirects</st></strong><st c="22732"> parameter that can enforce redirection during testing when set to </st><strong class="source-inline"><st c="22799">True</st></strong><st c="22803">. In our case, </st><strong class="source-inline"><st c="22818">client.post()</st></strong><st c="22831"> will run the </st><strong class="source-inline"><st c="22845">/exam/assign</st></strong> <strong class="source-inline"><st c="22857">POST</st></strong><st c="22862"> transaction with redirection. </st><st c="22893">If the view performs redirection during testing, its resulting </st><strong class="source-inline"><st c="22956">status</st></strong><st c="22962"> must be </st><strong class="source-inline"><st c="22971">"200 OK"</st></strong><st c="22979"> or its </st><strong class="source-inline"><st c="22987">status_code</st></strong><st c="22998"> is </st><strong class="source-inline"><st c="23002">200</st></strong><st c="23005"> and not </st><strong class="source-inline"><st c="23014">"302 FOUND"</st></strong><st c="23025"> or </st><strong class="source-inline"><st c="23029">302</st></strong><st c="23032"> because </st><strong class="source-inline"><st c="23041">follow_redirects</st></strong><st c="23057"> ensures that redirection or the HTTP Status Code 302 will happen. </st><st c="23124">So, the assertion will be there is redirection (</st><strong class="source-inline"><st c="23172">200</st></strong><st c="23176">) </st><span class="No-Break"><st c="23179">or none.</st></span></p>
			<p><st c="23187">Another option to verify redirection is to set </st><strong class="source-inline"><st c="23235">follow_redirects</st></strong><st c="23251"> to </st><strong class="source-inline"><st c="23255">False</st></strong><st c="23260"> and then assert whether the </st><strong class="source-inline"><st c="23289">status_code</st></strong><st c="23300"> is </st><strong class="source-inline"><st c="23304">302</st></strong><st c="23307">. The following test method shows this kind of </st><span class="No-Break"><st c="23354">testing approach:</st></span></p>
			<pre class="source-code"><st c="23371">
def test_assign_exam_redirect_302(client, form_data):
    res = client.post('/exam/assign', data=form_data)
    </st><strong class="bold"><st c="23476">assert res.status_code == 302</st></strong><strong class="bold"><st c="23505">assert res.location.split('?')[0] ==</st></strong> <strong class="bold"><st c="23542">url_for('redirect_success_exam')</st></strong></pre>			<p><st c="23575">In this approach, the expected status code is </st><strong class="source-inline"><st c="23622">302</st></strong><st c="23625"> because there is no </st><strong class="source-inline"><st c="23646">follow_redirects</st></strong><st c="23662"> parameter set in </st><strong class="source-inline"><st c="23680">client.post()</st></strong><st c="23693">. Also, </st><strong class="source-inline"><st c="23701">res.location</st></strong><st c="23713"> is the appropriate attribute to extract</st><a id="_idIndexMarker936"/><st c="23753"> the URL path because </st><strong class="source-inline"><st c="23775">res.request.path</st></strong><st c="23791"> will give the URL path of the </st><strong class="source-inline"><st c="23822">POST</st></strong> <span class="No-Break"><st c="23826">transaction instead.</st></span></p>
			<p><st c="23847">Aside from asserting </st><strong class="source-inline"><st c="23869">status_code</st></strong><st c="23880">, verifying the correctness of the redirection includes checking the correct redirected path and the content type. </st><st c="23995">Mocking can also be an additional strategy to closely examine the internals of the </st><strong class="source-inline"><st c="24078">POST</st></strong><st c="24082"> transactions and their redirections if there are any. </st><strong class="bold"><st c="24137">Monkey patching</st></strong><st c="24152"> can help refine the view processes </st><span class="No-Break"><st c="24188">through testing.</st></span></p>
			<p><st c="24204">Let’s now learn how to use monkey patching in testing </st><span class="No-Break"><st c="24259">view functions.</st></span></p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor289"/><st c="24274">Applying the monkey patching</st></h2>
			<p><strong class="bold"><st c="24303">Monkey patching</st></strong><st c="24319"> is a </st><strong class="source-inline"><st c="24325">pytest</st></strong><st c="24331"> feature that involves intercepting a function in a view transaction and replacing it with a custom-implemented mock function that returns our desired result. </st><st c="24490">The mock function must </st><a id="_idIndexMarker937"/><st c="24513">have the same parameter list and return type as the original one. </st><st c="24579">Otherwise, monkey patching will not work. </st><st c="24621">The following is a test case for redirection that uses </st><span class="No-Break"><st c="24676">monkey patching:</st></span></p>
			<pre class="source-code"><st c="24692">
@connect_db
def insert_question_details(conn, id:int, cid:str, pid:int, exam_date:date, duration:int):
        return True
</st><strong class="bold"><st c="24808">@pytest.fixture</st></strong>
<strong class="bold"><st c="24823">def insert_question_patched(monkeypatch):</st></strong><strong class="bold"><st c="24865">monkeypatch.setattr</st></strong><st c="24885">( </st><strong class="bold"><st c="24888">"views.examination.insert_question_details", insert_question_details)</st></strong><st c="24957">
def test_assign_mock_exam(</st><strong class="bold"><st c="24984">insert_question_patched</st></strong><st c="25008">, client, form_data):
    res = client.post('/exam/assign', data=form_data, follow_redirects=True)
    assert res.status == '200 OK'
    assert res.request.path == url_for('redirect_success_exam')</st></pre>			<p><strong class="source-inline"><st c="25192">monkeypatch</st></strong><st c="25204"> is an object injected into </st><a id="_idIndexMarker938"/><st c="25232">the fixture function. </st><st c="25254">It can emit a variety of methods for faking attributes and functions of other objects in a package and modules. </st><st c="25366">In the given example, the objective is to test the </st><strong class="source-inline"><st c="25417">/exam/assign</st></strong><st c="25429"> form transaction with a mocked </st><strong class="source-inline"><st c="25461">insert_question_details()</st></strong><st c="25486">. Instead of using the </st><strong class="source-inline"><st c="25509">patch()</st></strong><st c="25516"> decorator, the </st><strong class="source-inline"><st c="25532">monkeypatch</st></strong><st c="25543"> object of the fixture replaces the original function with a dummy </st><strong class="source-inline"><st c="25610">insert_question_details()</st></strong><st c="25635"> using its </st><strong class="source-inline"><st c="25646">setattr()</st></strong><st c="25655"> method. </st><st c="25664">The dummy method needs to return a </st><strong class="source-inline"><st c="25699">True</st></strong><st c="25703"> value because the test needs to examine the behavior of the view function whenever the </st><strong class="source-inline"><st c="25791">INSERT</st></strong><st c="25797"> transaction is successful. </st><st c="25825">Now, to enable monkey patching, you must inject the fixture containing the </st><strong class="source-inline"><st c="25900">monkeypatch</st></strong><st c="25911"> objects into the test functions like a typical fixture that </st><span class="No-Break"><st c="25972">yields resources.</st></span></p>
			<p><st c="25989">Monkey patching does not replace the actual code of the mocked function. </st><st c="26063">In the given </st><strong class="source-inline"><st c="26076">setattr()</st></strong><st c="26085">, the </st><strong class="source-inline"><st c="26091">views.examination.insert_question_details</st></strong><st c="26132"> expression indicates the repository method in the </st><strong class="source-inline"><st c="26183">/exam/assign</st></strong><st c="26195"> route and not in its actual repository class. </st><st c="26242">So, this is just replacing the state of the method call in the view function and not modifying the method’s </st><span class="No-Break"><st c="26350">actual implementation.</st></span></p>
			<p><st c="26372">Testing the repository, service, and view layers requires integration testing with or without mocking and </st><strong class="source-inline"><st c="26479">parametrize()</st></strong><st c="26492"> markers to find all the bugs and inconsistencies in the algorithms. </st><st c="26561">Regardless, it is easier to set up test classes and files in organized applications that utilize application factories and Blueprints because those projects do not need directory restructuring, such as the one imposed on the </st><span class="No-Break"><strong class="source-inline"><st c="26786">ch01</st></strong></span><span class="No-Break"><st c="26790"> application.</st></span></p>
			<p><st c="26803">Let us discuss now the benefit of using </st><strong class="source-inline"><st c="26844">create_app()</st></strong><st c="26856"> and Blueprints in testing </st><span class="No-Break"><st c="26883">Flask components.</st></span></p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor290"/><st c="26900">Creating test cases for components in application factory and Blueprints</st></h1>
			<p><st c="26973">Application factory functions and Blueprints help solve circular import problems by managing the context loading and allowing the Flask </st><strong class="source-inline"><st c="27110">app</st></strong><st c="27113"> instance to be accessible across the application</st><a id="_idIndexMarker939"/><st c="27162"> without tapping the </st><strong class="source-inline"><st c="27183">__main__</st></strong><st c="27191"> top-level module. </st><st c="27210">Since every component and layer is in its proper place, it is easier to set up the </st><span class="No-Break"><st c="27293">testing environment.</st></span></p>
			<p><st c="27313">Our applications in </st><em class="italic"><st c="27334">Chapters 2</st></em><st c="27344"> and </st><em class="italic"><st c="27349">3</st></em><st c="27350"> have essential Flask components that need testing, such as the repository transaction built by the SQLAlchemy, exceptions, and standard API functions. </st><st c="27502">All these components are built by the </st><strong class="source-inline"><st c="27540">create_app()</st></strong><st c="27552"> factory </st><span class="No-Break"><st c="27561">and Blueprints.</st></span></p>
			<p><st c="27576">Let us start formulating test cases for SQLAlchemy </st><span class="No-Break"><st c="27628">repository transactions.</st></span></p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor291"/><st c="27652">Testing ORM transactions</st></h2>
			<p><st c="27677">The </st><em class="italic"><st c="27682">Online Shipping</st></em><st c="27697"> app in </st><a href="B19383_02.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><st c="27705">Chapter 2</st></em></span></a><st c="27714"> uses the standard SQLAlchemy ORM to implement the CRUD transactions. </st><st c="27784">Integration</st><a id="_idIndexMarker940"/><st c="27795"> testing can help test the repository layer of our application. </st><st c="27859">Let us examine the following test case implementation that runs the </st><strong class="source-inline"><st c="27927">insert()</st></strong><st c="27935"> transaction </st><span class="No-Break"><st c="27948">of </st></span><span class="No-Break"><strong class="source-inline"><st c="27951">ProductRepository</st></strong></span><span class="No-Break"><st c="27968">:</st></span></p>
			<pre class="source-code"><st c="27970">
import pytest
from mock import patch
from main import app as flask_app
</st><strong class="bold"><st c="28042">from modules.product.repository.product import</st></strong> <strong class="bold"><st c="28088">ProductRepository</st></strong>
<strong class="bold"><st c="28106">from modules.model.db import Products</st></strong><st c="28144">
@pytest.fixture(autouse=True)
def form_data():
    params = dict()
    params["name"] = "eraser"
    params["code"] = "SCH-8977"
    params["price"] = "125.00"
    yield params
    params = None
</st><strong class="bold"><st c="28316">@patch("modules.model.config.db_session")</st></strong><st c="28357">
def test_mock_add_products(</st><strong class="source-inline"><st c="28385">mocked_sess</st></strong><st c="28397">, form_data):
    </st><strong class="bold"><st c="28411">db_sess = mocked_sess.return_value</st></strong><strong class="bold"><st c="28445">with flask_app.app_context() as context:</st></strong><st c="28486">
        repo = ProductRepository(db_sess)
        prod = Products(price=form_data["price"], code=form_data["code"], name=form_data["name"])
        </st><strong class="source-inline"><st c="28611">res = repo.insert(prod)</st></strong><strong class="bold"><st c="28634">db_sess.add.assert_called_once()</st></strong><strong class="bold"><st c="28667">db_sess.commit.assert_called_once()</st></strong><st c="28703">
        assert res is True</st></pre>			<p><strong class="source-inline"><st c="28722">test_mock_add_products()</st></strong><st c="28747"> focuses on examining the flow of the </st><strong class="source-inline"><st c="28785">INSERT</st></strong><st c="28791"> transaction in adding a new product line to the database. </st><st c="28850">It mocks the </st><strong class="source-inline"><st c="28863">db_session</st></strong><st c="28873"> from SQLAlchemy’s </st><strong class="source-inline"><st c="28892">scoped_session</st></strong><st c="28906"> because the test is on the lines of codes and not with the </st><strong class="source-inline"><st c="28966">db_session</st></strong><st c="28976">’s </st><strong class="source-inline"><st c="28980">add()</st></strong><st c="28985"> method. </st><strong class="source-inline"><st c="28994">assert_called_once()</st></strong><st c="29014"> of mocked </st><strong class="source-inline"><st c="29025">add()</st></strong><st c="29030"> and </st><strong class="source-inline"><st c="29035">commit()</st></strong><st c="29043"> will verify the execution of these methods during </st><span class="No-Break"><st c="29094">the test.</st></span></p>
			<p><st c="29103">Now, the </st><strong class="source-inline"><st c="29113">ch02-blueprint</st></strong><st c="29127"> project </st><a id="_idIndexMarker941"/><st c="29136">uses the </st><strong class="source-inline"><st c="29145">before_request()</st></strong><st c="29161"> and </st><strong class="source-inline"><st c="29166">after_request()</st></strong><st c="29181"> events to track down the requests of every view and the user who accesses the views. </st><st c="29267">These two application-level events become the core implementation of the application’s custom authentication mechanism. </st><st c="29387">All view pages in the project happen to be secured. </st><st c="29439">So, running and testing the </st><strong class="source-inline"><st c="29467">/ch02/products/add</st></strong><st c="29485"> view, for instance, without logging in as a valid user, will lead to a redirection to the login page, as verified by the following </st><span class="No-Break"><st c="29617">test case:</st></span></p>
			<pre class="source-code"><st c="29627">
def test_add_product_no_login(form_data, client):
    res = client.post("/ch02/products/add", data=form_data)
    </st><strong class="bold"><st c="29734">assert res.status_code == 302</st></strong><strong class="bold"><st c="29763">assert res.status == "302 FOUND"</st></strong><strong class="bold"><st c="29796">assert res.location.split('?')[0] == "/ch02/login/auth"</st></strong></pre>			<p><st c="29852">Running the </st><strong class="source-inline"><st c="29865">add_product()</st></strong><st c="29878"> view directly will redirect us to </st><strong class="source-inline"><st c="29913">login_db_auth()</st></strong><st c="29928"> from the </st><strong class="source-inline"><st c="29938">login_bp</st></strong><st c="29946"> Blueprint, thus </st><a id="_idIndexMarker942"/><st c="29963">the HTTP Status Code 302. </st><st c="29989">To prove that login authentication is required for the user to access the </st><strong class="source-inline"><st c="30063">add_product()</st></strong><st c="30076"> view, create a test case that will include the </st><strong class="source-inline"><st c="30124">/ch02/login/auth</st></strong><st c="30140"> access, like in the following </st><span class="No-Break"><st c="30171">test case:</st></span></p>
			<pre class="source-code"><st c="30181">
def test_add_product_with_login(form_data, login_data, client):
     </st><strong class="bold"><st c="30246">res_login = client.post("/ch02/login/auth",</st></strong> <strong class="bold"><st c="30289">data=login_data)</st></strong><strong class="bold"><st c="30306">with client.session_transaction() as session:</st></strong><strong class="bold"><st c="30352">assert 'admin' == session["username"]</st></strong><st c="30390">
       assert res_login.location.split('?')[0] == url_for('home_bp.menu')
       res = client.post("/ch02/products/add", data=form_data)
       assert res.status_code == 200</st></pre>			<p><st c="30543">Testing and running </st><strong class="source-inline"><st c="30564">/ch02/login/auth</st></strong><st c="30580"> must be the initial goal before running </st><strong class="source-inline"><st c="30621">/ch02/products/add</st></strong><st c="30639">. The </st><strong class="source-inline"><st c="30645">login_data()</st></strong><st c="30657"> fixture must provide a valid user detail for authentication. </st><st c="30719">Since Flask’s built-in </st><strong class="source-inline"><st c="30742">session</st></strong><st c="30749"> is responsible for storing </st><strong class="source-inline"><st c="30777">username</st></strong><st c="30785">, you can open a session in the test using </st><strong class="source-inline"><st c="30828">session_transaction()</st></strong><st c="30849"> of the test </st><strong class="source-inline"><st c="30862">Client</st></strong><st c="30868"> and the </st><strong class="source-inline"><st c="30877">with</st></strong><st c="30881"> context manager. </st><st c="30899">Within the context of the simulated session, check and confirm whether </st><strong class="source-inline"><st c="30970">/ch02/login/auth</st></strong><st c="30986"> saved </st><strong class="source-inline"><st c="30993">username</st></strong><st c="31001"> in the </st><strong class="source-inline"><st c="31009">session</st></strong><st c="31016"> object. </st><st c="31025">Also, assert whether the aftermath of a successful authentication will redirect the user to the </st><strong class="source-inline"><st c="31121">home_bp.menu</st></strong><st c="31133"> page. </st><st c="31140">If all these verifications are </st><strong class="source-inline"><st c="31171">True</st></strong><st c="31175">, run and test now the </st><strong class="source-inline"><st c="31198">add_product()</st></strong><st c="31211"> view and </st><a id="_idIndexMarker943"/><st c="31221">perform the proper </st><span class="No-Break"><st c="31240">verifications afterward.</st></span></p>
			<p><st c="31264">Next, we will test Flask API functions </st><span class="No-Break"><st c="31304">with </st></span><span class="No-Break"><strong class="source-inline"><st c="31309">pytest</st></strong></span><span class="No-Break"><st c="31315">.</st></span></p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor292"/><st c="31316">Testing API functions</st></h2>
			<p><a href="B19383_03.xhtml#_idTextAnchor076"><span class="No-Break"><em class="italic"><st c="31338">Chapter 3</st></em></span></a><st c="31348"> introduced and used Flask API endpoint functions in building our </st><em class="italic"><st c="31414">Online Pizza Ordering System</st></em><st c="31442">. Testing these API functions is not the same as consuming them. </st><st c="31507">A test </st><strong class="source-inline"><st c="31514">Client</st></strong><st c="31520"> provides the</st><a id="_idIndexMarker944"/><st c="31533"> utility methods, such as </st><strong class="source-inline"><st c="31559">get()</st></strong><st c="31564">, </st><strong class="source-inline"><st c="31566">post()</st></strong><st c="31572">, </st><strong class="source-inline"><st c="31574">put()</st></strong><st c="31579">, </st><strong class="source-inline"><st c="31581">delete()</st></strong><st c="31589">, and </st><strong class="source-inline"><st c="31595">patch()</st></strong><st c="31602">, to run the API and consume its resources, while extension modules such as </st><strong class="source-inline"><st c="31678">requests</st></strong><st c="31686"> build client applications to access and consume </st><span class="No-Break"><st c="31735">the APIs.</st></span></p>
			<p><st c="31744">Like in testing view pages, it is still the test </st><strong class="source-inline"><st c="31794">Client</st></strong><st c="31800"> class that can run, test, and mock our Flask API functions. </st><st c="31861">The following test cases show how to examine, scrutinize, and analyze the performance and responses of the APIs in the </st><strong class="source-inline"><st c="31980">ch03</st></strong><st c="31984"> project </st><span class="No-Break"><st c="31993">using </st></span><span class="No-Break"><strong class="source-inline"><st c="31999">pytest</st></strong></span><span class="No-Break"><st c="32005">:</st></span></p>
			<pre class="source-code"><st c="32007">
import pytest
from mock import patch, MagicMock
from main import app as flask_app
import json
@pytest.fixture
def client():
   with flask_app.test_client() as client:
       yield client
def test_index(client):
    </st><strong class="bold"><st c="32209">res = client.get('/index')</st></strong><strong class="bold"><st c="32235">data = json.loads(res.get_data(as_text=True))</st></strong><st c="32281">
    assert data["message"] == "This is an Online Pizza Ordering System."</st></pre>			<p><st c="32350">The given </st><strong class="source-inline"><st c="32361">test_index()</st></strong><st c="32373"> is part of the </st><strong class="source-inline"><st c="32389">test_http_get_api.py</st></strong><st c="32409"> test file and has the task of scrutinizing</st><a id="_idIndexMarker945"/><st c="32452"> if calling </st><strong class="source-inline"><st c="32464">/index</st></strong><st c="32470"> will have a response of </st><strong class="source-inline"><st c="32495">{"message": "This is an Online Pizza Ordering System."}</st></strong><st c="32550">. Like in the views, the response will always give data in </st><strong class="source-inline"><st c="32609">bytes</st></strong><st c="32614">. However, by using </st><strong class="source-inline"><st c="32634">get_data(as_text=True)</st></strong><st c="32656"> with the </st><strong class="source-inline"><st c="32666">json.loads()</st></strong><st c="32678"> utility, the </st><strong class="source-inline"><st c="32692">data</st></strong><st c="32696"> response will become a </st><span class="No-Break"><st c="32720">JSON object.</st></span></p>
			<p><st c="32732">Now, the following is a test case that performs adding new order details to the </st><span class="No-Break"><st c="32813">existing database:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="32831">@pytest.fixture</st></strong>
<strong class="bold"><st c="32847">def order_data():</st></strong><st c="32865">
    order_details = {"date_ordered": "2020-12-10", "empid": "EMP-101" , "cid": "CUST-101", "oid": "ORD-910"}
    </st><strong class="bold"><st c="32971">yield order_details</st></strong><st c="32990">
    order_details = None
def test_add_order(client, </st><strong class="bold"><st c="33039">order_data</st></strong><st c="33049">):
    </st><strong class="bold"><st c="33053">res = client.post("/order/add", json=order_data)</st></strong><st c="33101">
    assert res.status_code == 201
    assert res.content_type == 'application/json'</st></pre>			<p><st c="33177">Like in views, the </st><strong class="source-inline"><st c="33197">client.post()</st></strong><st c="33210"> method consumes the POST API transactions, but with input details passed to its </st><strong class="source-inline"><st c="33291">json</st></strong><st c="33295"> parameter and not </st><strong class="source-inline"><st c="33314">data</st></strong><st c="33318">. The given </st><strong class="source-inline"><st c="33330">test_add_order()</st></strong><st c="33346"> performs and asserts the </st><strong class="source-inline"><st c="33372">/order/add</st></strong><st c="33382"> API to verify whether SQLAlchemy’s </st><strong class="source-inline"><st c="33418">add()</st></strong><st c="33423"> function works successfully given the configured </st><strong class="source-inline"><st c="33473">db_session</st></strong><st c="33483">. The test expects </st><strong class="source-inline"><st c="33502">content_type</st></strong><st c="33514"> of </st><strong class="source-inline"><st c="33518">application/json</st></strong><st c="33534"> in </st><span class="No-Break"><st c="33538">its response.</st></span></p>
			<p><st c="33551">Aside from </st><strong class="source-inline"><st c="33563">get()</st></strong><st c="33568"> and </st><strong class="source-inline"><st c="33573">post()</st></strong><st c="33579">, the test </st><strong class="source-inline"><st c="33590">Client</st></strong><st c="33596"> has a </st><strong class="source-inline"><st c="33603">delete()</st></strong><st c="33611"> method to run </st><strong class="source-inline"><st c="33626">HTTP DELETE</st></strong><st c="33637"> API transactions. </st><st c="33656">The following test function runs </st><strong class="source-inline"><st c="33689">/order/delete</st></strong><st c="33702"> with a path variable </st><span class="No-Break"><st c="33724">of </st></span><span class="No-Break"><strong class="source-inline"><st c="33727">ORD-910</st></strong></span><span class="No-Break"><st c="33734">:</st></span></p>
			<pre class="source-code"><st c="33736">
def test_delete_order(client):
    </st><strong class="bold"><st c="33768">res = client.delete("/order/delete/ORD-910")</st></strong><st c="33812">
    assert res.status_code == 201</st></pre>			<p><st c="33842">The given test class studies</st><a id="_idIndexMarker946"/><st c="33871"> the deletion of an order with </st><strong class="source-inline"><st c="33902">ORD-910</st></strong><st c="33909"> as the order ID will not throw runtime errors even if the order does </st><span class="No-Break"><st c="33979">not exist.</st></span></p>
			<p><st c="33989">Now, the test </st><strong class="source-inline"><st c="34004">Client</st></strong><st c="34010"> also has a </st><strong class="source-inline"><st c="34022">patch()</st></strong><st c="34029"> method to run </st><strong class="source-inline"><st c="34044">PATCH API</st></strong><st c="34053"> transactions and a </st><strong class="source-inline"><st c="34073">put()</st></strong><st c="34078"> method for </st><span class="No-Break"><strong class="source-inline"><st c="34090">PUT API</st></strong></span><span class="No-Break"><st c="34097">.</st></span></p>
			<p><st c="34098">Determining what exception a repository, service, API, or view under test will throw is a testing mechanism </st><a id="_idIndexMarker947"/><st c="34207">called </st><strong class="bold"><st c="34214">exception testing</st></strong><st c="34231">. This type of testing is essential in verifying whether the Flask application can handle the major, if not all, possibilities that might cause runtime problems. </st><st c="34393">But how does </st><strong class="source-inline"><st c="34406">pytest</st></strong><st c="34412"> implement </st><span class="No-Break"><st c="34423">exception testing?</st></span></p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor293"/><st c="34441">Implementing exception testing</st></h2>
			<p><st c="34472">There are many variations of implementing exception testing in </st><strong class="source-inline"><st c="34536">pytest</st></strong><st c="34542">, but the most common is to use the </st><strong class="source-inline"><st c="34578">raises()</st></strong><st c="34586"> function and the </st><strong class="source-inline"><st c="34604">xfail()</st></strong><st c="34611"> marker </st><span class="No-Break"><st c="34619">of </st></span><span class="No-Break"><strong class="source-inline"><st c="34622">pytest</st></strong></span><span class="No-Break"><st c="34628">.</st></span></p>
			<p><st c="34629">The </st><strong class="source-inline"><st c="34634">raises()</st></strong><st c="34642"> utility applies to</st><a id="_idIndexMarker948"/><st c="34661"> testing features that explicitly call </st><strong class="source-inline"><st c="34700">abort()</st></strong><st c="34707"> or </st><strong class="source-inline"><st c="34711">raise()</st></strong><st c="34718"> methods to throw specific built-in or custom </st><strong class="source-inline"><st c="34764">HTTPException</st></strong><st c="34777"> classes. </st><st c="34787">Its goal is to verify whether the functionality under test is throwing the exact exception class. </st><st c="34885">For instance, the following test case checks whether the </st><strong class="source-inline"><st c="34942">/ch03/employee/add</st></strong><st c="34960"> API raises </st><strong class="source-inline"><st c="34972">DuplicateRecordException</st></strong><st c="34996"> during duplicate </st><span class="No-Break"><st c="35014">record insert:</st></span></p>
			<pre class="source-code"><st c="35028">
import pytest
from main import app as flask_app
</st><strong class="bold"><st c="35077">from app.exceptions.db import DuplicateRecordException</st></strong><st c="35131">
@pytest.fixture
def client():
   with flask_app.test_client() as client:
       yield client
@pytest.fixture
def employee_data():
    order_details = {"empid": "EMP-101", "fname": "Sherwin John" , "mname": "Calleja", "lname": "Tragura", "age": 45 , "role": "clerk", "date_employed": "2011-08-11", "status": "active", "salary": 60000.99}
    yield order_details
    order_details = None
def test_add_employee(client, employee_data):
    </st><strong class="bold"><st c="35542">with pytest.raises(DuplicateRecordException) as ex:</st></strong><st c="35593">
        res = client.post('/employee/add', json=employee_data)
        assert res.status_code == 200
    assert str(ex.value) == "insert employee record encountered a problem"</st></pre>			<p><st c="35749">The </st><strong class="source-inline"><st c="35754">add_employee()</st></strong><st c="35768"> endpoint function raises </st><strong class="source-inline"><st c="35794">DuplicateRecordException</st></strong><st c="35818"> if the return value of </st><strong class="source-inline"><st c="35842">EmployeeRepository</st></strong><st c="35860">’s </st><strong class="source-inline"><st c="35864">insert()</st></strong><st c="35872"> is </st><strong class="source-inline"><st c="35876">False</st></strong><st c="35881">. </st><strong class="source-inline"><st c="35883">test_add_employee()</st></strong><st c="35902"> checks </st><a id="_idIndexMarker949"/><st c="35910">whether the endpoint raises the exception given an </st><strong class="source-inline"><st c="35961">order_details()</st></strong><st c="35976"> fixture that yields an existing employee record. </st><st c="36026">If </st><strong class="source-inline"><st c="36029">status_code</st></strong><st c="36040"> is not </st><strong class="source-inline"><st c="36048">200</st></strong><st c="36051">, then there is a glitch in </st><span class="No-Break"><st c="36079">the code.</st></span></p>
			<p><st c="36088">On the other hand, the </st><strong class="source-inline"><st c="36112">xfail()</st></strong><st c="36119"> marker applies to testing components with overlooked and unhandled risky lines of code that have a considerable chance of messing up the application anytime </st><a id="_idIndexMarker950"/><st c="36277">at runtime. </st><st c="36289">But </st><strong class="source-inline"><st c="36293">xFail()</st></strong><st c="36300"> can also apply to test classes that verify known custom exceptions, like in the </st><span class="No-Break"><st c="36381">following snippet:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="36399">@pytest.mark.xfail(strict=True, raises=NoRecordException, reason=”No existing record.”)</st></strong><st c="36487">
def test_update_employee(client, employee_data):
    </st><strong class="bold"><st c="36537">res = client.patch(f'/employee/update/</st></strong> <strong class="bold"><st c="36575">{employee_data["empid"]}', json=employee_data)</st></strong><st c="36622">
    assert res.status_code == 201</st></pre>			<p><strong class="source-inline"><st c="36652">test_update_employee()</st></strong><st c="36675"> runs </st><strong class="source-inline"><st c="36681">PATCH API</st></strong><st c="36690">, the </st><strong class="source-inline"><st c="36696">/ch03/employee/update</st></strong><st c="36717">, and verifies whether the </st><strong class="source-inline"><st c="36744">employee_data()</st></strong><st c="36759"> fixture provides new details for an existing employee record. </st><st c="36822">If the employee, determined by </st><strong class="source-inline"><st c="36853">empid</st></strong><st c="36858">, is not in the database record throwing </st><strong class="source-inline"><st c="36899">NoRecordException</st></strong><st c="36916">, </st><strong class="source-inline"><st c="36918">pytest</st></strong><st c="36924"> will trigger the </st><strong class="source-inline"><st c="36942">xFail()</st></strong><st c="36949"> marker and render the marker’s </st><em class="italic"><st c="36981">“No existing </st></em><span class="No-Break"><em class="italic"><st c="36994">record.”</st></em></span><span class="No-Break"><st c="37002"> reason.</st></span></p>
			<p><st c="37010">Because of the organized directory structures that applications in </st><a href="B19383_02.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><st c="37078">Chapter 2</st></em></span></a><st c="37087"> and </st><a href="B19383_03.xhtml#_idTextAnchor076"><span class="No-Break"><em class="italic"><st c="37092">Chapter 3</st></em></span></a><st c="37101"> follow, testing becomes clear-cut, isolated, reproducible, and categorized based on functionality. </st><st c="37201">Using the application factories and Blueprints will not only give benefits to the development side but also to the </st><span class="No-Break"><st c="37316">testing environment.</st></span></p>
			<p><st c="37336">Let us try using </st><strong class="source-inline"><st c="37354">pytest</st></strong><st c="37360"> to test asynchronous transactions in Flask. </st><st c="37405">Do we need to install additional modules to work out the kind </st><span class="No-Break"><st c="37467">of testing?</st></span></p>
			<h1 id="_idParaDest-287"><a id="_idTextAnchor294"/><st c="37478">Creating test cases for asynchronous components</st></h1>
			<p><st c="37526">Flask 3.x supports </st><a id="_idIndexMarker951"/><st c="37546">asynchronous transactions with the </st><strong class="source-inline"><st c="37581">asyncio</st></strong><st c="37588"> platform. </st><a href="B19383_05.xhtml#_idTextAnchor111"><span class="No-Break"><em class="italic"><st c="37599">Chapter 5</st></em></span></a><st c="37608"> introduced creating asynchronous API </st><a id="_idIndexMarker952"/><st c="37646">endpoint functions, web views, background tasks and services, and repository transactions using the </st><strong class="source-inline"><st c="37746">async</st></strong><st c="37751">/</st><strong class="source-inline"><st c="37753">await</st></strong><st c="37758"> features. </st><st c="37769">The test </st><strong class="source-inline"><st c="37778">Client</st></strong><st c="37784"> class of Flask 3.x is part of the </st><strong class="source-inline"><st c="37819">Flask[async]</st></strong><st c="37831"> core libraries, so there will be no problem running the </st><strong class="source-inline"><st c="37888">async</st></strong><st c="37893"> components</st><a id="_idIndexMarker953"/> <span class="No-Break"><st c="37904">with </st></span><span class="No-Break"><strong class="source-inline"><st c="37910">pytest</st></strong></span><span class="No-Break"><st c="37916">.</st></span></p>
			<p><st c="37917">The following test cases on the asynchronous repository layer, Celery tasks, and API endpoints will provide proof on </st><strong class="source-inline"><st c="38035">pytest</st></strong><st c="38041"> supporting Flask 3.x </st><span class="No-Break"><st c="38063">asynchronous platform.</st></span></p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor295"/><st c="38085">Testing asynchronous views and API endpoint function</st></h2>
			<p><st c="38138">The test </st><strong class="source-inline"><st c="38148">Client</st></strong><st c="38154"> can run and test this </st><strong class="source-inline"><st c="38177">async</st></strong><st c="38182"> route function similar to running standard Flask routes using its </st><strong class="source-inline"><st c="38249">get()</st></strong><st c="38254">, </st><strong class="source-inline"><st c="38256">post()</st></strong><st c="38262">, </st><strong class="source-inline"><st c="38264">delete()</st></strong><st c="38272">, </st><strong class="source-inline"><st c="38274">patch()</st></strong><st c="38281">, and </st><strong class="source-inline"><st c="38287">put()</st></strong><st c="38292"> methods. </st><st c="38302">In other</st><a id="_idIndexMarker954"/><st c="38310"> words, the same testing</st><a id="_idIndexMarker955"/><st c="38334"> rules apply to testing asynchronous view functions, as shown in the following </st><span class="No-Break"><st c="38413">test case:</st></span></p>
			<pre class="source-code"><st c="38423">
import pytest
from main import app as flask_app
@pytest.fixture(scope="module", autouse=True)
def client():
    with flask_app.test_client() as app:
        yield app
def test_add_vote_ws_client(client):
    </st><strong class="bold"><st c="38616">res = client.get('/ch05/votecount/add')</st></strong><strong class="bold"><st c="38655">assert res.status_code == 200</st></strong></pre>			<p><st c="38685">In our </st><em class="italic"><st c="38693">Online Voting</st></em><st c="38706"> application, the </st><strong class="source-inline"><st c="38724">ch05-web</st></strong><st c="38732"> project has an </st><strong class="source-inline"><st c="38748">async</st></strong><st c="38753"> WebSocket client, the </st><strong class="source-inline"><st c="38776">add_vote_count_client()</st></strong><st c="38799"> view function. </st><st c="38815">The given </st><strong class="source-inline"><st c="38825">test_add_vote_ws_client()</st></strong><st c="38850"> runs and tests the </st><strong class="source-inline"><st c="38870">HTTP GET</st></strong><st c="38878"> request transaction using </st><strong class="source-inline"><st c="38905">client.get()</st></strong><st c="38917">. So, this is the same when running a standard view function using the test </st><strong class="source-inline"><st c="38993">Client</st></strong><st c="38999"> class and also with an asynchronous API endpoint function, as shown by the following test </st><span class="No-Break"><st c="39090">case implementation:</st></span></p>
			<pre class="source-code"><st c="39110">
@pytest.fixture(autouse=True, scope="module")
def login_details():
    data = {"username": "sjctrags", "password":"sjctrags"}
    yield data
    data = None
</st><strong class="bold"><st c="39256">@pytest.xfail(reason="An exception is encountered")</st></strong><st c="39307">
def test_add_login(client, login_details):
    </st><strong class="bold"><st c="39351">res = client.post("/ch05/login/add",</st></strong> <strong class="bold"><st c="39387">json=login_details)</st></strong><st c="39407">
    assert res.status_code == 201</st></pre>			<p><st c="39437">The </st><strong class="source-inline"><st c="39442">add_login()</st></strong><st c="39453"> API with the </st><strong class="source-inline"><st c="39467">/ch05/login/add</st></strong><st c="39482"> URL pattern is an </st><strong class="source-inline"><st c="39501">async</st></strong><st c="39506"> API endpoint function that adds new login details to the database. </st><strong class="source-inline"><st c="39574">test_add_login()</st></strong><st c="39590"> performs exception testing on the </st><a id="_idIndexMarker956"/><st c="39625">API to check whether adding existing records will throw an error. </st><st c="39691">So, the</st><a id="_idIndexMarker957"/><st c="39698"> process and formulation of the test cases are the same as testing their standard counterparts. </st><st c="39794">But what if the transactions under testing are asynchronous such that test functions need to await to execute them? </st><st c="39910">How can </st><strong class="source-inline"><st c="39918">pytest</st></strong><st c="39924"> directly call an async method? </st><st c="39956">Let us take a look at testing asynchronous </st><span class="No-Break"><st c="39999">SQLAlchemy transactions.</st></span></p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor296"/><st c="40023">Testing the asynchronous repository layer</st></h2>
			<p><st c="40065">The ORM used in </st><strong class="source-inline"><st c="40082">ch05-web</st></strong><st c="40090"> and </st><strong class="source-inline"><st c="40095">ch05-api</st></strong><st c="40103"> projects is the asynchronous SQLAlchemy. </st><st c="40145">In an </st><strong class="source-inline"><st c="40151">async</st></strong><st c="40156"> ORM, all CRUD operations run as </st><a id="_idIndexMarker958"/><st c="40189">coroutines that need the </st><strong class="source-inline"><st c="40214">await</st></strong><st c="40219"> keyword to execute them. </st><st c="40245">Likewise, test functions need to </st><strong class="source-inline"><st c="40278">await</st></strong><st c="40283"> these asynchronous components </st><a id="_idIndexMarker959"/><st c="40314">under test to execute them as coroutines. </st><st c="40356">However, </st><strong class="source-inline"><st c="40365">pytest</st></strong><st c="40371"> requires an extension module called </st><strong class="source-inline"><st c="40408">pytest-asyncio</st></strong><st c="40422"> to add support for implementing asynchronous test functions. </st><st c="40484">So, install the </st><strong class="source-inline"><st c="40500">pytest-asyncio</st></strong><st c="40514"> module using the following </st><strong class="source-inline"><st c="40542">pip</st></strong><st c="40545"> command before implementing the </st><span class="No-Break"><st c="40578">test case:</st></span></p>
			<pre class="console"><st c="40588">
pip install pytest-asyncio</st></pre>			<p><st c="40615">The implementation is the same as the previous ones except for the </st><strong class="source-inline"><st c="40683">pytest_plugins</st></strong><st c="40697"> component, which imports the necessary </st><strong class="source-inline"><st c="40737">pytest</st></strong><st c="40743"> extension, such as </st><strong class="source-inline"><st c="40763">pytest-asyncio</st></strong><st c="40777">. The </st><strong class="source-inline"><st c="40783">pytest_plugins</st></strong><st c="40797"> component imports the installed </st><strong class="source-inline"><st c="40830">pytest</st></strong><st c="40836"> extensions and adds features to the testing </st><a id="_idIndexMarker960"/><st c="40881">environment that </st><strong class="source-inline"><st c="40898">pytest</st></strong><st c="40904"> alone cannot perform. </st><st c="40927">With </st><strong class="source-inline"><st c="40932">pytest-asyncio</st></strong><st c="40946">, testing</st><a id="_idIndexMarker961"/><st c="40955"> transactions run by coroutines, like in the following snippet, is </st><span class="No-Break"><st c="41022">now feasible:</st></span></p>
			<pre class="source-code"><st c="41035">
import pytest
from app.model.config import db_session
from app.model.db import Login
from app.repository.login import LoginRepository
</st><strong class="bold"><st c="41170">pytest_plugins = ('pytest_asyncio',)</st></strong><st c="41206">
@pytest.fixture
def login_details():
    login_details = {"username": "user-1908", "password": "pass9087" }
    login_model = Login(**login_details)
    return login_model
</st><strong class="bold"><st c="41367">@pytest.mark.asyncio</st></strong>
<strong class="bold"><st c="41387">async def test_add_login(login_details):</st></strong><st c="41428">
     async with db_session() as sess:
        async with sess.begin():
            repo = LoginRepository(sess)
            </st><strong class="bold"><st c="41516">res = await repo.insert_login(login_details)</st></strong><st c="41560">
            assert res is True</st></pre>			<p><st c="41579">Calling an asynchronous method for testing always requires a test function to be </st><strong class="source-inline"><st c="41661">async</st></strong><st c="41666"> because it needs to await the function under test. </st><st c="41718">The given </st><strong class="source-inline"><st c="41728">test_add_login()</st></strong><st c="41744"> is an </st><strong class="source-inline"><st c="41751">async</st></strong><st c="41756"> method because it needs to call and await an asynchronous </st><strong class="source-inline"><st c="41815">insert_login()</st></strong><st c="41829"> transaction. </st><st c="41843">However, for </st><strong class="source-inline"><st c="41856">pytest</st></strong><st c="41862"> to run an </st><strong class="source-inline"><st c="41873">async</st></strong><st c="41878"> test function, it will require the test functions to be </st><a id="_idIndexMarker962"/><st c="41935">decorated by </st><strong class="source-inline"><st c="41948">@pytest.mark.asyncio()</st></strong><st c="41970"> provided by the </st><strong class="source-inline"><st c="41987">pytest-asyncio</st></strong><st c="42001"> library. </st><st c="42011">But </st><a id="_idIndexMarker963"/><st c="42015">what will be the case when Celery background tasks will </st><span class="No-Break"><st c="42071">undergo testing?</st></span></p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor297"/><st c="42087">Testing Celery tasks</st></h2>
			<p><strong class="source-inline"><st c="42108">Pytest</st></strong><st c="42115"> needs the </st><strong class="source-inline"><st c="42126">pytest-celery</st></strong><st c="42139"> extension module to run Celery tasks under testing. </st><st c="42192">Thus, the test file needs to </st><a id="_idIndexMarker964"/><st c="42221">include </st><strong class="source-inline"><st c="42229">pytest_celery</st></strong><st c="42242"> in its </st><strong class="source-inline"><st c="42250">pytest_plugins</st></strong><st c="42264">. The following test function</st><a id="_idIndexMarker965"/><st c="42293"> runs the </st><strong class="source-inline"><st c="42303">add_vote_task_wrapper()</st></strong><st c="42326"> task to add a candidate’s votes to </st><span class="No-Break"><st c="42362">the database:</st></span></p>
			<pre class="source-code"><st c="42375">
import pytest
</st><strong class="bold"><st c="42390">from app.services.vote_tasks import add_vote_task_wrapper</st></strong><st c="42447">
import json
</st><strong class="bold"><st c="42460">from main import app as flask_app</st></strong>
<strong class="bold"><st c="42493">pytest_plugins = ('pytest_celery',)</st></strong><st c="42529">
@pytest.fixture(scope='session')
</st><strong class="bold"><st c="42563">def celery_config():</st></strong><st c="42583">
    yield {
        'broker_url': 'redis://localhost:6379/1',
        'result_backend': 'redis://localhost:6379/1'
    }
@pytest.fixture
def vote():
    login_details = {"voter_id": "BCH-111-789", "election_id": 1, "cand_id": "PHL-102" , "vote_time": "09:11:19" }
    login_str = json.dumps(login_details)
    return login_str
def test_add_votes(vote):
    with flask_app.app_context() as context:
        </st><strong class="bold"><st c="42942">login_task = add_vote_task_wrapper.apply_async(</st></strong> <strong class="bold"><st c="42989">args=[vote])</st></strong><strong class="bold"><st c="43002">result = login_task.get()</st></strong><strong class="bold"><st c="43028">assert bool(result) is True</st></strong></pre>			<p><st c="43056">Before writing the test cases for Celery tasks, import the </st><strong class="source-inline"><st c="43116">python_celery</st></strong><st c="43129"> library in </st><strong class="source-inline"><st c="43141">pytest_plugins</st></strong><st c="43155">. Then, create a test function, such as </st><strong class="source-inline"><st c="43195">test_add_votes()</st></strong><st c="43211">, run the Celery task the usual way with</st><a id="_idIndexMarker966"/><st c="43251"> the app’s context, and perform the needed verifications. </st><st c="43309">By the way, running the</st><a id="_idIndexMarker967"/><st c="43332"> Celery task with the application’s context means that testing will utilize the configured Redis broker. </st><st c="43437">However, if testing decides not to use the configured Redis configurations (e.g., </st><strong class="source-inline"><st c="43519">broker_url</st></strong><st c="43529">, </st><strong class="source-inline"><st c="43531">result_backend</st></strong><st c="43545">) of </st><strong class="source-inline"><st c="43551">app</st></strong><st c="43554">, </st><strong class="source-inline"><st c="43556">pytest_celery</st></strong><st c="43569"> can allow </st><strong class="source-inline"><st c="43580">pytest</st></strong><st c="43586"> to inject dummy Redis configurations into its test functions through the fixture, like the given </st><strong class="source-inline"><st c="43684">celery_config()</st></strong><st c="43699">, or override the built-in configuration through </st><strong class="source-inline"><st c="43748">@pytest.mark.celery(result_backend='xxxxx')</st></strong><st c="43791">. Running the task without the default Redis details will lead to a </st><strong class="source-inline"><st c="43859">kombu.connection:connection.py:669 no hostname was </st></strong><span class="No-Break"><strong class="source-inline"><st c="43910">supplied</st></strong></span><span class="No-Break"><st c="43918"> error.</st></span></p>
			<p><st c="43925">Can </st><strong class="source-inline"><st c="43930">pytest</st></strong><st c="43936"> create a test case for asynchronous file upload for some </st><span class="No-Break"><st c="43994">web-based applications?</st></span></p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor298"/><st c="44017">Testing asynchronous file upload</st></h2>
			<p><a href="B19383_06.xhtml#_idTextAnchor143"><span class="No-Break"><em class="italic"><st c="44050">Chapter 6</st></em></span></a><st c="44060"> showcases an </st><em class="italic"><st c="44074">Online Housing Pricing Prediction and Analysis</st></em><st c="44120"> application, which highlights creating</st><a id="_idIndexMarker968"/><st c="44159"> views that capture data from uploaded </st><em class="italic"><st c="44198">XLSX</st></em><st c="44202"> files for data analysis and graphical plotting. </st><st c="44251">The project also has </st><strong class="source-inline"><st c="44272">pytest</st></strong><st c="44278"> test files that analyze the file uploading </st><a id="_idIndexMarker969"/><st c="44322">process of some form views and verify the rendition types of their </st><span class="No-Break"><st c="44389">Flask responses.</st></span></p>
			<p><strong class="source-inline"><st c="44405">Pytest</st></strong><st c="44412"> supports running and testing web views that involve uploading files of any mime type and converting them to </st><strong class="source-inline"><st c="44521">FileStorage</st></strong><st c="44532"> objects for content processing. </st><st c="44565">Uploading a </st><em class="italic"><st c="44577">multipart</st></em><st c="44586"> file requires the </st><strong class="source-inline"><st c="44605">client.post()</st></strong><st c="44618"> function to have the </st><strong class="source-inline"><st c="44640">content_type</st></strong><st c="44652"> parameter set to </st><strong class="source-inline"><st c="44670">multipart/form-data</st></strong><st c="44689">, the </st><strong class="source-inline"><st c="44695">buffered</st></strong><st c="44703"> parameter to </st><strong class="source-inline"><st c="44717">True</st></strong><st c="44721">, and its </st><strong class="source-inline"><st c="44731">data</st></strong><st c="44735"> parameter to a </st><em class="italic"><st c="44751">dictionary</st></em><st c="44761"> consisting of the form parameter name of the file-type form component as the key, and the file object opened as a binary file for reading as its value. </st><st c="44914">The following test case verifies whether </st><strong class="source-inline"><st c="44955">/ch06/upload/xlsx/analysis</st></strong><st c="44981"> can upload an XLSX file, extract some columns, and render them on </st><span class="No-Break"><st c="45048">HTML tables:</st></span></p>
			<pre class="source-code"><st c="45060">
import os
def test_upload_file(client):
    test_file = os.getcwd() + "/tests/files/2011Q2.xlsx"
    </st><strong class="bold"><st c="45154">data = {</st></strong>
<strong class="bold"><st c="45162">        'data_file': (open(test_file, 'rb'), test_file)</st></strong>
<strong class="bold"><st c="45210">    }</st></strong><st c="45212">
    response = client.post("/ch06/upload/xlsx/analysis", </st><strong class="bold"><st c="45266">buffered=True, content_type='multipart/form-data', data=data</st></strong><st c="45326">)
    assert response.status_code == 200
    assert response.mimetype == "text/html"</st></pre>			<p><strong class="source-inline"><st c="45403">test_upload_file()</st></strong><st c="45422"> fetches some XLSX sample files within the project and opens these as binary files for reading. </st><st c="45518">The object extracted from the </st><strong class="source-inline"><st c="45548">open()</st></strong><st c="45554"> file becomes the value of the </st><strong class="source-inline"><st c="45585">data_file</st></strong><st c="45594"> form parameter of the Jinja template. </st><strong class="source-inline"><st c="45633">client.post()</st></strong><st c="45646"> will run </st><strong class="source-inline"><st c="45656">/ch06/upload/xlsx/analysis</st></strong><st c="45682"> and use the file object as input. </st><st c="45717">If the </st><strong class="source-inline"><st c="45724">pytest</st></strong><st c="45730"> execution has no uploading-related exceptions, the response should emit </st><strong class="source-inline"><st c="45803">status_code</st></strong><st c="45814"> of </st><strong class="source-inline"><st c="45818">200</st></strong><st c="45821"> with the </st><strong class="source-inline"><st c="45831">content-type</st></strong><st c="45843"> header </st><span class="No-Break"><st c="45851">of </st></span><span class="No-Break"><strong class="source-inline"><st c="45854">text/html</st></strong></span><span class="No-Break"><st c="45863">.</st></span></p>
			<p><st c="45864">After testing unsecured </st><a id="_idIndexMarker970"/><st c="45889">components, let us now</st><a id="_idIndexMarker971"/><st c="45911"> deal with test cases that run views or APIs that require authentication </st><span class="No-Break"><st c="45984">and authorization.</st></span></p>
			<h1 id="_idParaDest-292"><a id="_idTextAnchor299"/><st c="46002">Creating test cases for secured API and web components</st></h1>
			<p><st c="46057">All applications in </st><a href="B19383_09.xhtml#_idTextAnchor256"><span class="No-Break"><em class="italic"><st c="46078">Chapter 9</st></em></span></a><st c="46087"> implement the authentication methods essential to small-, middle-, or large-scale Flask applications. </st><strong class="source-inline"><st c="46190">pytest</st></strong><st c="46196"> can test secured components, both standard and asynchronous ones. </st><st c="46263">This </st><a id="_idIndexMarker972"/><st c="46268">chapter will cover testing Cross-Site Request Forgery- or CSRF-protected views running on an HTTPS with </st><strong class="source-inline"><st c="46372">flask-session</st></strong><st c="46385"> managing the user session, HTTP basic authenticated views, and web views secured by the </st><strong class="source-inline"><st c="46474">flask-login</st></strong> <span class="No-Break"><st c="46485">extension module.</st></span></p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor300"/><st c="46503">Testing secured API functions</st></h2>
			<p><a href="B19383_09.xhtml#_idTextAnchor256"><span class="No-Break"><em class="italic"><st c="46533">Chapter 9</st></em></span></a><st c="46543"> showcases a </st><em class="italic"><st c="46556">Vaccine Reporting and Management</st></em><st c="46588"> system with web-based and API-based versions. </st><st c="46635">The </st><strong class="source-inline"><st c="46639">ch09-web-passphrase</st></strong><st c="46658"> project is a web version of the prototype with views </st><a id="_idIndexMarker973"/><st c="46712">protected by a custom authentication mechanism using the </st><strong class="source-inline"><st c="46769">flask-session</st></strong><st c="46782"> module, web forms that are CSRF-protected, and all components running on an </st><span class="No-Break"><st c="46859">HTTPS protocol.</st></span></p>
			<p><st c="46874">The </st><strong class="source-inline"><st c="46879">/ch09/login/auth</st></strong><st c="46895"> route is the entry point to the application, where users must log in using their </st><strong class="source-inline"><st c="46977">username</st></strong><st c="46985"> and </st><strong class="source-inline"><st c="46990">password</st></strong><st c="46998"> credentials. </st><st c="47012">To test the secured view routes, the </st><strong class="source-inline"><st c="47049">/ch09/login/auth</st></strong><st c="47065"> route must have the first execution in the test function to allow access to other views. </st><st c="47155">The following test case runs the </st><strong class="source-inline"><st c="47188">/ch09/patient/profile/add</st></strong><st c="47213"> view without </st><span class="No-Break"><st c="47227">user authentication:</st></span></p>
			<pre class="source-code"><st c="47247">
import pytest
from flask import url_for
from main import app as flask_app
@pytest.fixture
def client():
    </st><strong class="bold"><st c="47352">flask_app.config["WTF_CSRF_ENABLED"] = False</st></strong><st c="47396">
    with flask_app.test_client() as app:
        yield app
@pytest.fixture(scope="module")
def user_credentials():
    params = dict()
    params["username"] = "sjctrags"
    params["password"] = "sjctrags"
    return params
def test_patient_profile_add_invalid_access(client):
    </st><strong class="bold"><st c="47647">res = client.get("/ch09/patient/profile/add",</st></strong> <strong class="bold"><st c="47692">base_url='https://localhost')</st></strong><st c="47722">
    assert res.status_code == 302
    </st><strong class="bold"><st c="47753">assert res.location.split('?')[0] ==</st></strong> <strong class="bold"><st c="47789">url_for('login_user')</st></strong></pre>			<p><st c="47811">For </st><strong class="source-inline"><st c="47816">pytest</st></strong><st c="47822"> to access and run </st><strong class="source-inline"><st c="47841">/ch09/patient/profile/add</st></strong><st c="47866">, which is a form view, you must first disable the CSRF protection of the </st><strong class="source-inline"><st c="47940">flask_wtf.csrf</st></strong><st c="47954"> module using its </st><strong class="source-inline"><st c="47972">WTF_CSRF_ENABLED</st></strong><st c="47988"> built-in</st><a id="_idIndexMarker974"/><st c="47997"> environment variable before extracting the test </st><strong class="source-inline"><st c="48046">Client</st></strong><st c="48052"> instance in the </st><strong class="source-inline"><st c="48069">client()</st></strong><st c="48077"> fixture. </st><st c="48087">Running the given test function with the correct user credentials will show a successful result since the access is unauthenticated, causing a redirection to the </st><strong class="source-inline"><st c="48249">/ch09/login/auth</st></strong><st c="48265"> view. </st><st c="48272">So far, the application uses custom authentication but with a database-encrypted username managed by the </st><strong class="source-inline"><st c="48377">flask-session</st></strong> <span class="No-Break"><st c="48390">extension module.</st></span></p>
			<p><st c="48408">This test proves that accessing any view from our </st><em class="italic"><st c="48459">Online Vaccine Registration</st></em><st c="48486"> application requires user authentication from its </st><strong class="source-inline"><st c="48537">/ch09/login/auth</st></strong><st c="48553"> view page. </st><st c="48565">Any unauthenticated attempt to its </st><a id="_idIndexMarker975"/><st c="48600">view will redirect the user to the login page. </st><st c="48647">The following snippet builds the proper access flow to our application’s views with </st><span class="No-Break"><st c="48731">user authentication:</st></span></p>
			<pre class="source-code"><st c="48751">
def test_patient_profile_add_valid_access(client, user_credentials):
        </st><strong class="bold"><st c="48821">res_login = client.post('/ch09/login/auth',</st></strong> <strong class="bold"><st c="48864">data=user_credentials,</st></strong> <strong class="bold"><st c="48887">base_url='https://localhost')</st></strong><st c="48917">
        assert res_login.status_code == 302
        assert res_login.location.split('?')[0] == url_for('view_signup')
        </st><strong class="bold"><st c="49020">res = client.get("/patient/profile/add",</st></strong> <strong class="bold"><st c="49060">base_url='https://localhost:5000')</st></strong><st c="49095">
        assert res.status_code == 200
        </st><strong class="bold"><st c="49126">with client.session_transaction() as session:</st></strong><strong class="bold"><st c="49171">assert session["user"] == "sjctrags"</st></strong></pre>			<p><strong class="source-inline"><st c="49208">test_patient_profile_add_valid_access()</st></strong><st c="49248"> has the same test flow as in the </st><strong class="source-inline"><st c="49282">ch02-blueprint</st></strong><st c="49296"> project. </st><st c="49306">The only difference is the presence of the </st><strong class="source-inline"><st c="49349">base_url</st></strong><st c="49357"> parameter in </st><strong class="source-inline"><st c="49371">client.post()</st></strong><st c="49384"> since the view runs on an HTTPS platform. </st><st c="49427">The goal of the test is to run </st><strong class="source-inline"><st c="49458">/ch09/profile/add</st></strong><st c="49475"> successfully after logging into </st><strong class="source-inline"><st c="49508">/ch09/login/auth</st></strong><st c="49524"> with the correct login details. </st><st c="49557">Also, this test function verifies whether the </st><strong class="source-inline"><st c="49603">flask-session</st></strong><st c="49616"> module is working on saving the user data in the </st><span class="No-Break"><strong class="source-inline"><st c="49666">session</st></strong></span><span class="No-Break"><st c="49673"> object.</st></span></p>
			<p><st c="49681">How about testing APIs secured by HTTP-based authentication mechanisms that use the </st><strong class="source-inline"><st c="49766">Authorization</st></strong><st c="49779"> header? </st><st c="49788">How does </st><strong class="source-inline"><st c="49797">pytest</st></strong><st c="49803"> run these types of secured API </st><span class="No-Break"><st c="49835">endpoint functions?</st></span></p>
			<h2 id="_idParaDest-294"><a id="_idTextAnchor301"/><st c="49854">Testing HTTP Basic authentication</st></h2>
			<p><st c="49888">The </st><strong class="source-inline"><st c="49893">ch09-api-auth-basic</st></strong><st c="49912"> project, an API-based version of the </st><em class="italic"><st c="49950">Online Vaccine Registration</st></em><st c="49977"> application, uses the HTTP basic authentication scheme to secure all API endpoint access. </st><st c="50068">An </st><strong class="source-inline"><st c="50071">Authorization</st></strong><st c="50084"> header with the </st><strong class="source-inline"><st c="50101">base64</st></strong><st c="50107">-encoded </st><strong class="source-inline"><st c="50117">username:password</st></strong><st c="50134"> credential </st><a id="_idIndexMarker976"/><st c="50146">must be part of the request headers to access an API. </st><st c="50200">Moreover, the access is also</st><a id="_idIndexMarker977"/><st c="50228"> restricted by the </st><strong class="source-inline"><st c="50247">flask-cors</st></strong><st c="50257"> extension module. </st><st c="50276">The following test case accesses </st><strong class="source-inline"><st c="50309">/ch09/vaccine/add</st></strong> <span class="No-Break"><st c="50326">without authentication:</st></span></p>
			<pre class="source-code"><st c="50350">
import pytest
from main import app as flask_app
</st><strong class="bold"><st c="50399">import base64</st></strong><st c="50412">
@pytest.fixture
def client():
    with flask_app.test_client() as app:
        yield app
@pytest.fixture
def vaccine():
    vacc = {"vacid": "VAC-899", "vacname": "Narvas", "vacdesc": "For Hypertension", "qty": 5000, "price": 1200.5, "status": True}
    return vacc
def test_add_vaccine_unauth(client, vaccine):
    res = client.post("/ch09/vaccine/add", json=vaccine, </st><strong class="bold"><st c="50758">headers={'Access-Control-Allow-Origin': "http://localhost:5000"}</st></strong><st c="50822">)
    assert res.status_code == 201</st></pre>			<p><st c="50854">The test </st><strong class="source-inline"><st c="50864">Client</st></strong><st c="50870"> methods have </st><strong class="source-inline"><st c="50884">header</st></strong><st c="50890"> parameters that can contain a dictionary of request headers, such as </st><strong class="source-inline"><st c="50960">Access-Control-Allow-Headers</st></strong><st c="50988">, </st><strong class="source-inline"><st c="50990">Access-Control-Allow-Methods</st></strong><st c="51018">, </st><strong class="source-inline"><st c="51020">Access-Control-Allow-Credentials</st></strong><st c="51052">, and </st><strong class="source-inline"><st c="51058">Access-Control-Allow-Origin</st></strong><st c="51085"> for managing the</st><a id="_idIndexMarker978"/><st c="51102"> application’s </st><strong class="bold"><st c="51117">cross-origin resource sharing</st></strong><st c="51146"> (</st><strong class="bold"><st c="51148">CORS</st></strong><st c="51152">) header details. </st><st c="51171">However, the given test will still return an HTTP Status Code 403 even with the CORS</st><a id="_idIndexMarker979"/><st c="51255"> headers because no </st><strong class="source-inline"><st c="51275">Authorization</st></strong><st c="51288"> header is present with the </st><strong class="source-inline"><st c="51316">Basic</st></strong><st c="51321"> credential. </st><st c="51334">The</st><a id="_idIndexMarker980"/><st c="51337"> following snippet is the correct test case for successful access to the API endpoint secured by the </st><span class="No-Break"><st c="51438">basic scheme:</st></span></p>
			<pre class="source-code"><st c="51451">
@pytest.fixture
</st><strong class="bold"><st c="51468">def auth_header():</st></strong><strong class="bold"><st c="51486">credentials = base64.b64encode(b'sjctrags:sjctrags') .decode('utf-8')</st></strong><st c="51556">
    return credentials
def test_add_vaccine_auth(client, vaccine, </st><strong class="bold"><st c="51619">auth_header</st></strong><st c="51630">):
    res = client.post("/vaccine/add", json=vaccine, </st><strong class="bold"><st c="51682">headers={'Authorization': 'Basic ' + auth_header, 'Access-Control-Allow-Origin': "http://localhost:5000"}</st></strong><st c="51787">)
    assert res.status_code == 201</st></pre>			<p><st c="51819">The preceding test case will show a successful result given the correct </st><strong class="source-inline"><st c="51892">base64</st></strong><st c="51898">-encoded credentials. </st><st c="51921">The inclusion of the </st><strong class="source-inline"><st c="51942">Authorization</st></strong><st c="51955"> header with the </st><strong class="source-inline"><st c="51972">Basic</st></strong><st c="51977"> and </st><strong class="source-inline"><st c="51982">base64</st></strong><st c="51988">-encoded credentials from the </st><strong class="source-inline"><st c="52019">auth_header()</st></strong><st c="52032"> fixture in the </st><strong class="source-inline"><st c="52048">header</st></strong><st c="52054"> parameter of </st><strong class="source-inline"><st c="52068">client.post()</st></strong><st c="52081"> will fix the HTTP Status Code </st><span class="No-Break"><st c="52112">403 error.</st></span></p>
			<p><st c="52122">The </st><strong class="source-inline"><st c="52127">Authorization</st></strong><st c="52140"> header must be in the </st><strong class="source-inline"><st c="52163">header</st></strong><st c="52169"> parameter of any </st><strong class="source-inline"><st c="52187">Client</st></strong><st c="52193"> method when testing and running the API endpoint secured by HTTP basic, digest, and bearer-token authentication schemes. </st><st c="52315">In the </st><strong class="source-inline"><st c="52322">Authorization Digest</st></strong><st c="52342"> header, the </st><em class="italic"><st c="52355">nonce</st></em><st c="52360">, </st><em class="italic"><st c="52362">opaque</st></em><st c="52368">, and </st><em class="italic"><st c="52374">nonce count</st></em><st c="52385"> must be</st><a id="_idIndexMarker981"/><st c="52393"> part of the header details. </st><st c="52422">On the other hand, the token-based scheme needs a secure </st><strong class="bold"><st c="52479">JSON Web Token</st></strong><st c="52493"> (</st><strong class="bold"><st c="52495">JWT</st></strong><st c="52498">) token in the </st><strong class="source-inline"><st c="52514">Authorization Bearer</st></strong><st c="52534"> header or with the </st><strong class="source-inline"><st c="52554">token_auth</st></strong><st c="52564"> parameter of the test </st><span class="No-Break"><strong class="source-inline"><st c="52587">Client</st></strong></span><span class="No-Break"><st c="52593"> methods.</st></span></p>
			<p><st c="52602">But how does </st><strong class="source-inline"><st c="52616">pytest</st></strong><st c="52622"> scrutinize</st><a id="_idIndexMarker982"/><st c="52633"> the view routes secured by the </st><strong class="source-inline"><st c="52665">flask-login</st></strong><st c="52676"> extension? </st><st c="52688">Is there an</st><a id="_idIndexMarker983"/><st c="52699"> added behavior that </st><strong class="source-inline"><st c="52720">pytest</st></strong><st c="52726"> should adopt when testing views secured </st><span class="No-Break"><st c="52767">by </st></span><span class="No-Break"><strong class="source-inline"><st c="52770">flask-login</st></strong></span><span class="No-Break"><st c="52781">?</st></span></p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor302"/><st c="52782">Testing web logins</st></h2>
			<p><st c="52800">The </st><strong class="source-inline"><st c="52805">ch09-web-login</st></strong><st c="52819"> application is </st><a id="_idIndexMarker984"/><st c="52835">another version of the </st><em class="italic"><st c="52858">Online Vaccine Registration</st></em><st c="52885"> application that uses the </st><strong class="source-inline"><st c="52912">flask-login</st></strong><st c="52923"> module as its source for security. </st><st c="52959">It uses the </st><strong class="source-inline"><st c="52971">flask-session</st></strong><st c="52984"> module to store the user session in the file system instead of the browser. </st><st c="53061">Like in the </st><strong class="source-inline"><st c="53073">ch09-web-passphrase</st></strong><st c="53092"> and </st><strong class="source-inline"><st c="53097">ch02-blueprint</st></strong><st c="53111"> projects, users </st><a id="_idIndexMarker985"/><st c="53128">must log into the application before accessing any views. </st><st c="53186">Otherwise, the application will redirect them to the login page. </st><st c="53251">The following test case is similar to the previous test files where the test accesses </st><strong class="source-inline"><st c="53337">/ch09/login/auth</st></strong><st c="53353"> first before accessing any views </st><span class="No-Break"><st c="53387">or APIs:</st></span></p>
			<pre class="source-code"><st c="53395">
import pytest
from flask_login import current_user
from main import app as flask_app
def test_add_admin_profile(client, admin_details, user_credentials):
    </st><strong class="bold"><st c="53550">res_login = client.post('/ch09/login/auth',</st></strong> <strong class="bold"><st c="53593">data=user_credentials)</st></strong><strong class="bold"><st c="53616">assert res_login.status_code == 200</st></strong><strong class="bold"><st c="53652">with client.session_transaction() as session:</st></strong><strong class="bold"><st c="53698">assert current_user.username == "sjctrags"</st></strong><strong class="bold"><st c="53741">res = client.post("/ch09/admin/profile/add", data=admin_details)</st></strong><st c="53806">
       assert res.status_code == 200</st></pre>			<p><st c="53836">The given </st><strong class="source-inline"><st c="53847">test_admin_admin_profile()</st></strong><st c="53873"> will run the </st><strong class="source-inline"><st c="53887">/ch09/admin/profile/add</st></strong><st c="53910"> route with a successful result given the valid </st><strong class="source-inline"><st c="53958">user_credentials()</st></strong><st c="53976"> fixture. </st><st c="53986">One advantage of using the </st><strong class="source-inline"><st c="54013">flask-login</st></strong><st c="54024"> module compared to custom session-handling is the </st><strong class="source-inline"><st c="54075">current_user</st></strong><st c="54087"> object it has that can give proof if the user login transaction created a session, if a user depicted in the </st><strong class="source-inline"><st c="54197">user_credentials()</st></strong><st c="54215"> fixture is the one</st><a id="_idIndexMarker986"/><st c="54234"> stored in its session, or if the authentication was done using the </st><em class="italic"><st c="54302">remember me</st></em><st c="54313"> feature. </st><st c="54323">The given test function verifies whether </st><strong class="source-inline"><st c="54364">username</st></strong><st c="54372"> indicated in the </st><strong class="source-inline"><st c="54390">user_credentials()</st></strong><st c="54408"> fixture is the one saved in the </st><span class="No-Break"><strong class="source-inline"><st c="54441">flask-login</st></strong></span><span class="No-Break"><st c="54452"> session.</st></span></p>
			<p><st c="54461">Another feature of </st><strong class="source-inline"><st c="54481">flask-login</st></strong><st c="54492"> that is </st><a id="_idIndexMarker987"/><st c="54501">beneficial to </st><strong class="source-inline"><st c="54515">pytest</st></strong><st c="54521"> is its capability to turn off all the authentication mechanisms during testing. </st><st c="54602">The following test class runs the same </st><strong class="source-inline"><st c="54641">/ch09/admin/profile/add</st></strong><st c="54664"> route successfully without </st><span class="No-Break"><st c="54692">logging in:</st></span></p>
			<pre class="source-code"><st c="54703">
@pytest.fixture
def client():
    </st><strong class="bold"><st c="54734">flask_app.config["LOGIN_DISABLED"] = True</st></strong><st c="54775">
    with flask_app.test_client() as app:
        yield app
def test_add_admin_profile(client, admin_details):
    res = client.post("/admin/profile/add", data=admin_details)
    assert res.status_code == 200</st></pre>			<p><st c="54963">Disabling authentication in </st><strong class="source-inline"><st c="54992">flask-login</st></strong><st c="55003"> requires setting its built-in </st><strong class="source-inline"><st c="55034">LOGIN_DISABLED</st></strong><st c="55048"> environment variable to </st><strong class="source-inline"><st c="55073">True</st></strong><st c="55077"> at the configuration level. </st><st c="55106">The setup should be part of the </st><strong class="source-inline"><st c="55138">client()</st></strong><st c="55146"> fixture before extracting the test </st><strong class="source-inline"><st c="55182">Client</st></strong><st c="55188"> object from the Flask’s </st><span class="No-Break"><strong class="source-inline"><st c="55213">app</st></strong></span><span class="No-Break"><st c="55216"> instance.</st></span></p>
			<p><st c="55226">Pytest and its add-ons can test all authentication schemes and authorization rules applied to Flask 3.x apps. </st><st c="55337">Using the</st><a id="_idIndexMarker988"/><st c="55346"> same GWT unit testing strategy and behavioral testing mechanisms, such as mocking and monkey patching, </st><strong class="source-inline"><st c="55450">pytest</st></strong><st c="55456"> is a complete and adequate testing library to run and verify secured APIs and </st><span class="No-Break"><st c="55535">view routes.</st></span></p>
			<p><st c="55547">How can </st><strong class="source-inline"><st c="55556">pytest</st></strong><st c="55562"> mock a</st><a id="_idIndexMarker989"/><st c="55569"> MongoDB connection when running and testing routes? </st><st c="55622">Let’s </st><span class="No-Break"><st c="55628">learn how.</st></span></p>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor303"/><st c="55638">Creating test cases for MongoDB transactions</st></h1>
			<p><st c="55683">The formulation of the test files, classes, and functions is the same when testing components with the Flask application </st><a id="_idIndexMarker990"/><st c="55805">running on MongoDB. </st><st c="55825">The</st><a id="_idIndexMarker991"/><st c="55828"> only difference is how </st><strong class="source-inline"><st c="55852">pytest</st></strong><st c="55858"> will mock the MongoDB connection to </st><span class="No-Break"><st c="55895">pursue testing.</st></span></p>
			<p><st c="55910">This chapter showcases the </st><strong class="source-inline"><st c="55938">mongomock</st></strong><st c="55947"> module and its </st><strong class="source-inline"><st c="55963">MongoClient</st></strong><st c="55974"> mock object that can replace a configured MongoDB connection. </st><st c="56037">So, install the </st><strong class="source-inline"><st c="56053">mongomock</st></strong><st c="56062"> module using the following </st><strong class="source-inline"><st c="56090">pip</st></strong><st c="56093"> command before creating the </st><span class="No-Break"><st c="56122">test file:</st></span></p>
			<pre class="console"><st c="56132">
pip install mongomock</st></pre>			<p><a href="B19383_07.xhtml#_idTextAnchor177"><span class="No-Break"><em class="italic"><st c="56154">Chapter 7</st></em></span></a><st c="56164"> has a </st><em class="italic"><st c="56171">Tutor Finder</st></em><st c="56183"> application with components running on NoSQL databases such as MongoDB. </st><st c="56256">The application uses the </st><strong class="source-inline"><st c="56281">connect()</st></strong><st c="56290"> method of the </st><strong class="source-inline"><st c="56305">mongoengine</st></strong><st c="56316"> module to establish a MongoDB connection for a few of the APIs. </st><st c="56381">Instead of using the configured connection in the Flask’s </st><strong class="source-inline"><st c="56439">app</st></strong><st c="56442"> context, a </st><strong class="source-inline"><st c="56454">MongoClient </st></strong><st c="56466">object from </st><strong class="source-inline"><st c="56478">mongomock</st></strong><st c="56487"> can replace the </st><strong class="source-inline"><st c="56504">mongoengine</st></strong><st c="56515">’s </st><strong class="source-inline"><st c="56519">connect()</st></strong><st c="56528"> method with a fake one. </st><st c="56553">The following snippet of the </st><strong class="source-inline"><st c="56582">test_tutor_login.py</st></strong><st c="56601"> file mocks the MongoDB connection to run </st><strong class="source-inline"><st c="56643">insert_login()</st></strong> <span class="No-Break"><st c="56657">of </st></span><span class="No-Break"><strong class="source-inline"><st c="56661">LoginRepository</st></strong></span><span class="No-Break"><st c="56676">:</st></span></p>
			<pre class="source-code"><st c="56678">
import pytest
</st><strong class="bold"><st c="56693">import mongomock</st></strong>
<strong class="bold"><st c="56709">from mongoengine import connect, get_connection, disconnect</st></strong><st c="56769">
from main import app as flask_app
from modules.repository.mongo.tutor_login import TutorLoginRepository
from bcrypt import hashpw, gensalt
@pytest.fixture
def login_details():
    login = dict()
    login["username"] = "sjctrags"
    login["password"] = "sjctrags"
    login["encpass"] = hashpw(str(login['username']) .encode(), gensalt())
    return login
@pytest.fixture
def client():
   disconnect()
   with flask_app.test_client() as client:
       yield client
</st><strong class="bold"><st c="57203">@pytest.fixture</st></strong>
<strong class="bold"><st c="57218">def connect_db():</st></strong><strong class="bold"><st c="57236">connect</st></strong><st c="57244">(host='localhost', port=27017, db='tfs_test', uuidRepresentation='standard', </st><strong class="bold"><st c="57322">mongo_client_class=mongomock.MongoClient</st></strong><st c="57362">)
    </st><strong class="bold"><st c="57365">conn = get_connection()</st></strong><st c="57388">
    return conn</st></pre>			<p><st c="57400">The given </st><strong class="source-inline"><st c="57411">connect_db()</st></strong><st c="57423"> recreates the </st><strong class="source-inline"><st c="57438">MongoClient</st></strong><st c="57449"> object using the same </st><strong class="source-inline"><st c="57472">mongoengine</st></strong><st c="57483">’s </st><strong class="source-inline"><st c="57487">connect()</st></strong><st c="57496"> method but now with the fake </st><strong class="source-inline"><st c="57526">MongoClient</st></strong><st c="57537">. However, the parameter values of </st><strong class="source-inline"><st c="57572">connect()</st></strong><st c="57581">, like the values of </st><strong class="source-inline"><st c="57602">db</st></strong><st c="57604">, </st><strong class="source-inline"><st c="57606">host</st></strong><st c="57610">, and </st><strong class="source-inline"><st c="57616">port</st></strong><st c="57620">, must be part of the testing environment setup. </st><st c="57669">Also, the </st><strong class="source-inline"><st c="57679">uuidRepresentation</st></strong><st c="57697"> parameter must </st><a id="_idIndexMarker992"/><st c="57713">be present in </st><span class="No-Break"><st c="57727">the mocking.</st></span></p>
			<p><st c="57739">After the mocked </st><strong class="source-inline"><st c="57757">connect()</st></strong><st c="57766"> setup, it</st><a id="_idIndexMarker993"/><st c="57776"> needs to call the </st><strong class="source-inline"><st c="57795">mongoengine</st></strong><st c="57806">’s </st><strong class="source-inline"><st c="57810">get_connection()</st></strong><st c="57826"> and yield it to the test function. </st><st c="57862">So, the connection created from a mocked </st><strong class="source-inline"><st c="57903">MongoClient</st></strong><st c="57914"> is fake but with the existing database </st><span class="No-Break"><st c="57954">configuration details.</st></span></p>
			<p><st c="57976">Now, before injecting the </st><strong class="source-inline"><st c="58003">connect_db()</st></strong><st c="58015"> fixture to the test functions, call the </st><strong class="source-inline"><st c="58056">disconnect()</st></strong><st c="58068"> method to kill an existing connection in the Flask </st><strong class="source-inline"><st c="58120">app</st></strong><st c="58123"> context and avoid multiple connections running in the background, which will cause an error. </st><st c="58217">The following test function has the injected mocked MongoDB connection for testing the </st><strong class="source-inline"><st c="58304">insert_login()</st></strong><st c="58318"> MongoDB </st><span class="No-Break"><st c="58327">repository transaction:</st></span></p>
			<pre class="source-code"><st c="58350">
def test_add_login(client, </st><strong class="bold"><st c="58378">connect_db</st></strong><st c="58388">, login_details):
    repo = TutorLoginRepository()
    res = repo.insert_login(login_details)
    assert res is True</st></pre>			<p><st c="58493">Aside from </st><strong class="source-inline"><st c="58505">mongomock</st></strong><st c="58514">, the </st><strong class="source-inline"><st c="58520">pytest-mongo</st></strong><st c="58532"> and </st><strong class="source-inline"><st c="58537">pytest-mongodb</st></strong><st c="58551"> modules allow mocking </st><strong class="source-inline"><st c="58574">mongoengine</st></strong><st c="58585"> models and collections by using the actual MongoDB </st><span class="No-Break"><st c="58637">database configuration.</st></span></p>
			<p><st c="58660">Can </st><strong class="source-inline"><st c="58665">pytest</st></strong><st c="58671"> run and test WebSocket endpoints created by </st><strong class="source-inline"><st c="58716">flask-sock</st></strong><st c="58726">? Let us implement a test case that will </st><span class="No-Break"><st c="58767">analyze WebSockets.</st></span></p>
			<h1 id="_idParaDest-297"><a id="_idTextAnchor304"/><st c="58786">Creating test cases for WebSockets</st></h1>
			<p><st c="58821">WebSockets are components of our </st><strong class="source-inline"><st c="58855">ch05-web</st></strong><st c="58863"> and </st><strong class="source-inline"><st c="58868">ch05-api</st></strong><st c="58876"> projects. </st><st c="58887">The applications use </st><strong class="source-inline"><st c="58908">flask-sock</st></strong><st c="58918"> to implement the</st><a id="_idIndexMarker994"/><st c="58935"> WebSocket endpoints. </st><st c="58957">So far, </st><strong class="source-inline"><st c="58965">pytest</st></strong><st c="58971"> can only provide the testing</st><a id="_idIndexMarker995"/><st c="59000"> environment for WebSockets. </st><st c="59029">However, it needs the </st><strong class="source-inline"><st c="59051">websockets</st></strong><st c="59061"> module to run, test, and assert the response of our WebSocket endpoints. </st><st c="59135">So, install this module using the following </st><span class="No-Break"><strong class="source-inline"><st c="59179">pip</st></strong></span><span class="No-Break"><st c="59182"> command:</st></span></p>
			<pre class="console"><st c="59191">
pip install websockets</st></pre>			<p><st c="59214">There are three components that the </st><strong class="source-inline"><st c="59251">websockets</st></strong><st c="59261"> module can provide </st><span class="No-Break"><st c="59281">to </st></span><span class="No-Break"><strong class="source-inline"><st c="59284">pytest</st></strong></span><span class="No-Break"><st c="59290">:</st></span></p>
			<ul>
				<li><st c="59292">The simulated route that will receive the message from </st><span class="No-Break"><st c="59347">the client</st></span></li>
				<li><st c="59357">The </st><span class="No-Break"><st c="59362">mock server</st></span></li>
				<li><st c="59373">The test function that will serve as </st><span class="No-Break"><st c="59411">the client</st></span></li>
			</ul>
			<p><st c="59421">All these components must</st><a id="_idIndexMarker996"/><st c="59447"> be </st><strong class="source-inline"><st c="59451">async</st></strong><st c="59456"> because running WebSockets requires the </st><strong class="source-inline"><st c="59497">asyncio</st></strong><st c="59504"> platform. </st><st c="59515">So, also</st><a id="_idIndexMarker997"/><st c="59523"> install the </st><strong class="source-inline"><st c="59536">pytest-asyncio</st></strong><st c="59550"> module to give asynchronous support to these </st><span class="No-Break"><st c="59596">three components:</st></span></p>
			<pre class="console"><st c="59613">
Pip install pytest-asyncio</st></pre>			<p><st c="59640">Then, start implementing the simulated or mocked view similar to the following implementation to receive and process the messages sent by </st><span class="No-Break"><st c="59779">a WebSocket:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="59791">import websockets</st></strong><st c="59809">
import pytest
import json
</st><strong class="bold"><st c="59836">import pytest_asyncio</st></strong>
<strong class="bold"><st c="59857">pytest_plugins = ('pytest_asyncio',)</st></strong>
<strong class="bold"><st c="59894">async</st></strong><st c="59900"> def simulated_add_votecount_view(</st><strong class="bold"><st c="59934">websocket</st></strong><st c="59944">):
    </st><strong class="bold"><st c="59948">async for message in websocket:</st></strong><st c="59979">
        print("received: ",message)
        # Place here the VoteCount repo transactions
        </st><strong class="bold"><st c="60053">await websocket.send("data added")</st></strong></pre>			<p><strong class="source-inline"><st c="60087">simulated_add_votecount_view()</st></strong><st c="60118"> will serve as the mocked WebSocket endpoint function, which receives and saves the tallied votes into </st><span class="No-Break"><st c="60221">the database.</st></span></p>
			<p><st c="60234">Next, create a mock server using the </st><strong class="source-inline"><st c="60272">websockets.serve()</st></strong><st c="60290"> method to run the simulated route</st><a id="_idIndexMarker998"/><st c="60324"> in an </st><strong class="bold"><st c="60331">event loop</st></strong><st c="60341">. This method </st><a id="_idIndexMarker999"/><st c="60355">needs </st><strong class="source-inline"><st c="60361">host</st></strong><st c="60365">, </st><strong class="source-inline"><st c="60367">port</st></strong><st c="60371">, and the simulated view name, such as </st><strong class="source-inline"><st c="60410">simulated_add_votecount_view</st></strong><st c="60438">, to operate. </st><st c="60452">The following is our WebSocket server, which </st><a id="_idIndexMarker1000"/><st c="60497">will run at the </st><span class="No-Break"><strong class="source-inline"><st c="60513">ws://localhost:5001</st></strong></span><span class="No-Break"><st c="60532"> address:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="60541">@pytest_asyncio.fixture</st></strong>
<strong class="bold"><st c="60565">async</st></strong><st c="60571"> def create_ws_server():
    </st><strong class="bold"><st c="60596">async with websockets.serve(</st></strong> <strong class="bold"><st c="60624">simulated_add_votecount_view,  "localhost", 5001</st></strong><st c="60672">) as server:
        yield server</st></pre>			<p><st c="60698">Since </st><strong class="source-inline"><st c="60705">create_ws_server()</st></strong><st c="60723"> must be </st><strong class="source-inline"><st c="60732">async</st></strong><st c="60737">, decorating it with </st><strong class="source-inline"><st c="60758">@pytest.fixture</st></strong><st c="60773"> will cause an error. </st><st c="60795">So, use </st><strong class="source-inline"><st c="60803">@pytest_asyncio.fixture</st></strong><st c="60826"> to declare the asynchronous fixtures </st><span class="No-Break"><st c="60864">for </st></span><span class="No-Break"><strong class="source-inline"><st c="60868">pytest</st></strong></span><span class="No-Break"><st c="60874">.</st></span></p>
			<p><st c="60875">Finally, we start our test function implementation with the context manager that opens the </st><strong class="source-inline"><st c="60967">websockets</st></strong><st c="60977"> client object for WebSocket endpoint execution and closes it afterward. </st><st c="61050">The following implementation shows a test function for the </st><strong class="source-inline"><st c="61109">add_vote_count_server()</st></strong><st c="61132"> WebSocket with the </st><strong class="source-inline"><st c="61152">ws://localhost:5001/ch05/vote/save/ws</st></strong> <span class="No-Break"><st c="61189">URL address:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="61202">@pytest.mark.asyncio</st></strong>
<strong class="bold"><st c="61223">async</st></strong><st c="61229"> def test_votecount_ws(</st><strong class="bold"><st c="61252">create_ws_server</st></strong><st c="61269">, vote_tally_details):
        </st><strong class="bold"><st c="61292">async with websockets.connect(</st></strong> <strong class="bold"><st c="61322">"ws://localhost:5001/ch05/vote/save/ws"</st></strong><st c="61362">) as websocket:
            </st><strong class="bold"><st c="61379">await websocket.send(json.dumps( vote_tally_details))</st></strong><strong class="bold"><st c="61432">response = await websocket.recv()</st></strong><strong class="bold"><st c="61466">assert response == "data added"</st></strong></pre>			<p><st c="61498">A successful connection to the mock server will create a client object through the </st><strong class="source-inline"><st c="61582">websockets.connect()</st></strong><st c="61602"> method with the URI of the WebSocket as its parameter argument. </st><st c="61667">The client object can send a string </st><a id="_idIndexMarker1001"/><st c="61703">or numeric message to the simulated route and receive a string or numeric</st><a id="_idIndexMarker1002"/><st c="61776"> response from that server. </st><st c="61804">This send-and-receive process will only happen once per execution of the test function. </st><st c="61892">Since the </st><strong class="source-inline"><st c="61902">with</st></strong><st c="61906">-</st><strong class="source-inline"><st c="61908">context</st></strong><st c="61915"> manager, </st><strong class="source-inline"><st c="61925">send()</st></strong><st c="61931">, and </st><strong class="source-inline"><st c="61937">recv()</st></strong><st c="61943"> are all awaited, the test function must be </st><strong class="source-inline"><st c="61987">async</st></strong><st c="61992">. Now, use the </st><strong class="source-inline"><st c="62007">assert</st></strong><st c="62013"> statement to verify whether our client receives the proper message from </st><span class="No-Break"><st c="62086">the server.</st></span></p>
			<p><st c="62097">Another way to test the WebSocket endpoint is to use the actual development environment, for instance, running our </st><strong class="source-inline"><st c="62213">ch05-web</st></strong><st c="62221"> project with the PostgreSQL database, Redis, and the </st><strong class="bold"><st c="62275">Web Server Gateway Interface</st></strong><st c="62303"> (</st><strong class="bold"><st c="62305">WSGI</st></strong><st c="62309">) server operating altogether. </st><st c="62341">The following </st><strong class="source-inline"><st c="62355">test_websocket_actual()</st></strong><st c="62378"> method runs the same WebSocket server </st><a id="_idIndexMarker1003"/><st c="62417">without monkey patching or a </st><span class="No-Break"><st c="62446">mocked server:</st></span></p>
			<pre class="source-code"><st c="62460">
import pytest
import websockets
import json
pytest_plugins = ('pytest_asyncio',)
@pytest.fixture(scope="module", autouse=True)
def vote_tally_details():
    tally = {"election_id":"1", "precinct": "111-C", "final_tally": "6000", "approved_date": "2024-10-10"}
    yield tally
    tally = None
@pytest.mark.asyncio
async def test_websocket_actual(vote_tally_details):
     </st><strong class="bold"><st c="62816">async with</st></strong> <strong class="bold"><st c="62826">websockets.connect("ws://localhost:5001/ch05/ vote/save/ws") as websocket</st></strong><st c="62900">:
            await websocket.send(json.dumps( vote_tally_details))
            response = await websocket.recv()
            assert response == "data not added"</st></pre>			<p><st c="63026">The test method adds a new vote tally to the database. </st><st c="63082">If the voting precinct number of the record is not yet in the table, then the WebSocket will return the </st><strong class="source-inline"><st c="63186">"data added" </st></strong><st c="63199">message to the client. </st><st c="63222">Otherwise, it will return the </st><strong class="source-inline"><st c="63252">"data not added"</st></strong><st c="63268"> message. </st><st c="63278">This approach also tests the correct configuration details of the Redis and PostgreSQL servers used by the WebSocket endpoint. </st><st c="63405">Others may mock the Redis connectivity and PostgreSQL database connection</st><a id="_idIndexMarker1004"/><st c="63478"> to focus on the WebSocket implementation and refine its </st><span class="No-Break"><st c="63535">client response.</st></span></p>
			<p><st c="63551">Testing Flask components</st><a id="_idIndexMarker1005"/><st c="63576"> should focus on different perspectives to refine the application’s performance and quality. </st><st c="63669">Unit testing components using monkey patching or mocking is an effective way of refining, streamlining, and scrutinizing the inputs and results. </st><st c="63814">However, most often, the integration testing with the servers, internal modules, and external dependencies included can help identify and resolve major technical issues, such as compatibility and versioning problems, bandwidth and connection overhead, and </st><span class="No-Break"><st c="64070">performance issues.</st></span></p>
			<h1 id="_idParaDest-298"><a id="_idTextAnchor305"/><st c="64089">Summary</st></h1>
			<p><st c="64097">There are many strategies and approaches in testing Flask applications, but this chapter focuses on the components found in our applications from </st><em class="italic"><st c="64244">Chapters 1</st></em><st c="64254"> to </st><em class="italic"><st c="64258">9</st></em><st c="64259">. Also, the goal is to build test cases using the straightforward syntax of the </st><span class="No-Break"><strong class="source-inline"><st c="64339">pytest</st></strong></span><span class="No-Break"><st c="64345"> module.</st></span></p>
			<p><st c="64353">This chapter started with testing the standard Flask components with the web views, API functions, repository transactions, and native services. </st><st c="64499">Aside from simply running the components and verifying their response details using the </st><strong class="source-inline"><st c="64587">assert</st></strong><st c="64593"> statement, mocking becomes an essential ingredient in many test cases of this chapter. </st><st c="64681">The </st><strong class="source-inline"><st c="64685">patch()</st></strong><st c="64692"> decorator from the </st><strong class="source-inline"><st c="64712">unittest</st></strong><st c="64720"> module mocks the </st><strong class="source-inline"><st c="64738">psycopg2</st></strong><st c="64746"> connections, repository transactions in views and services, and the SQLAlchemy utility methods. </st><st c="64843">This chapter also discussed monkey patching, which replaces a function with a mock one, and exception testing, which determines raised exceptions and </st><span class="No-Break"><st c="64993">undetected bugs.</st></span></p>
			<p><st c="65009">This chapter also established proof that it is easier to test asynchronous </st><strong class="source-inline"><st c="65085">Flask[async]</st></strong><st c="65097"> components, such as asynchronous SQLAlchemy transactions, services, views, and API endpoints, using </st><strong class="source-inline"><st c="65198">pytest</st></strong><st c="65204"> and its </st><strong class="source-inline"><st c="65213">pytest-asyncio</st></strong><st c="65227"> module. </st><st c="65236">On the other hand, another module called </st><strong class="source-inline"><st c="65277">pytest-celery</st></strong><st c="65290"> helps </st><strong class="source-inline"><st c="65297">pytest</st></strong><st c="65303"> examine and verify the </st><span class="No-Break"><st c="65327">Celery tasks.</st></span></p>
			<p><st c="65340">However, the most challenging part is how this chapter uses </st><strong class="source-inline"><st c="65401">pytest</st></strong><st c="65407"> to examine components from secured applications, run repository transactions that connect to MongoDB, and analyze and </st><span class="No-Break"><st c="65526">build WebSockets.</st></span></p>
			<p><st c="65543">It is always recommended to apply testing on Flask components during development to study the process flows, runtime performance, and the feasibility of </st><span class="No-Break"><st c="65697">the implementations.</st></span></p>
			<p><st c="65717">The next chapter will discuss the different deployment strategies of our </st><span class="No-Break"><st c="65791">Flask applications.</st></span></p>
		</div>
	<div id="charCountTotal" value="65810"/></body></html>