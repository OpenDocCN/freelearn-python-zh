- en: Making a Package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how to install Python and third-party packages
    of code that we can use with Python. In this chapter, we'll see how packages are
    represented on the computer's filesystem. We'll take a look at how to add code
    modules inside the package, how to make those code modules interact with each
    other within the package, and how to access data from non-code files that are
    incorporated into our package.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have a pretty good idea about how to create
    your own packages of Python code. Packages will form the basis for programs and
    help you to make your code modular.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an empty package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding modules to the package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing code from other modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding static data files to the package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an empty package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first section of this chapter deals with creating a simple empty package,
    which won't do anything yet, but by the time we're done, we'll be able to import
    the empty package into the Python shell.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Python projects may consist of a single code module, but normally there
    are multiple modules combined together into a package. A package can contain as
    many modules as we need it to. Packages start their lives as folders on the filesystem,
    which means we can make them just as we would make any other folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to use your operating system''s file browser to make folders,
    that''s fine, but I usually use the command line. For example let''s run a demo
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is shown as the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93df4e38-10cc-4c9e-adce-7fb163f047f7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Turning a regular folder into a package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two things that turn a regular folder into a package. These are explained
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is *where is it* that is, the location of the folder. Python only
    looks in certain places for packages and if your folder isn't in the right place,
    Python won't notice it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sys.path` variable contains the list of all the places Python will look
    for packages. The `sys.path` variable is fairly sparse, but user configuration
    can make it much more extensive as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15a9435e-92b9-44d6-82b1-35dfd6501e41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the first entry in the list is an empty string. This stands for
    the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: For those who are using the command line, the current working directory is just
    the folder we're currently in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change the current working directory with the `cd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `cd..` command in the preceding code means go back to the previous directory
    or the parent directory. So, in this case, I went in and out of `demopackage`.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the current working directory is in the path is convenient during
    development; it means that we could just set the current working directory to
    the place where we're doing our development and all of our packages become available,
    at least, as long as we also use the command line to launch Python.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing that turns a regular folder into a package is the presence
    of `__init__.py` file, though not strictly necessary since Python 3.3 and beyond.
    An `init` file marks the folder as a package, which makes it load more efficiently
    and also gives us a place to put information and code relevant to the interface
    of the package as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: While it's quite common that the `__init__.py` file is completely empty and
    serves only as a marker, there's one language feature that won't be supported
    unless we add a little code to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature is the ability to import all the package''s modules using the
    `import*` syntax, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ba7b4dd-eeed-4b97-8974-0f7776d10eb7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Importing all package modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want Python to be able to import all the package's modules using `import*`
    syntax, we have to tell it the names of all those modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we add the module names to a list called `__all__` in the `init`
    file as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e260d3ec-8221-427c-9503-f279ae03fe16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t have *emacs* installed on your system, you can install it by
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**sudo apt install emacs24**` In the preceding screenshot, I have used Ubuntu,
    thus the editor is white background, however in case of Windows OS and macOS,
    the background of the editor can be different.'
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why we need to do this manually rather than Python just
    scanning the filesystem for module files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, there are a couple of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: First, Python tries not to make any assumptions about whether filenames are
    case-sensitive or not. On some operating systems, filenames are case-sensitive
    and on other operating systems they are not. Module names are variables, so it's
    better they originate within the source code, rather than depending on something
    external that might change depending on where the code is run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second reason for doing this manually is that importing a module makes code
    execute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine we have a package that plays soundtracks. In addition to the general
    purpose code, we also have a bunch of modules that handle audio output on various
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing our users to do an `import*` to bring their packages' programming interface
    into their module is quite reasonable; however, we don't want all of the output
    modules to load, just the one that's appropriate to the system we're running on.
    Trying to load any of the others would most likely trigger an exception in the
    user's code. The way `__all__` works now, we can exclude the output modules from
    `import*` and get the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, let's make sure that Python is willing to import our demo package before
    we move on to the next part, which is how to add source code modules to a package.
  prefs: []
  type: TYPE_NORMAL
- en: Adding modules to the package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's take look at how to add actual code to the package and look out for
    a couple of pitfalls to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python modules have the same name as objects that they have as filenames, except
    without the `.py` suffix. This means that the filenames need to be valid Python
    variable names  and also that they should use letters and symbols that are reliably
    available across different operating systems. The following screenshot showns
    an example for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e66aaf50-521f-427c-9518-cb0ddacc16cd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, module names should not start with a number because Python variables are
    not allowed to start with numbers. Also, it should not use capital letters because
    some common operating system don't differentiate between filenames containing
    capital letters and filenames that are all lowercase. As long as we stay within
    Python variable name guidelines and remember to use a `.py` suffix, we can name
    our modules anything we please.
  prefs: []
  type: TYPE_NORMAL
- en: So, we just pick a filename and start writing Python code into a file with that
    name in the `package` folder. That simple scenario is also the common case, but
    there's another possibility.
  prefs: []
  type: TYPE_NORMAL
- en: Module loading with namespace packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, starting with Python 3.3, it''s possible to have a `package`
    folder that doesn''t contain an `init` file. Leaving out the `init` file means
    we can''t support `import*` or the other tricks within it that we''ll discover
    as we go along. But, there''s more to it than that. The following screenshot shows
    a code example for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/deaa05f7-42be-4323-a8b8-d9b1eac596b4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the `init` file is missing, the folder becomes part of a `namespace package`
    folder. When Python is importing, it combines all of the `namespace package` folders
    it finds, that share a name, into a single logical package, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/880b45e2-324a-41b9-ad4e-df5b379cca34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This behavior means that while choosing the module filename, Python still follows
    the same rules, we could potentially place that file into one of any number of
    `namespace package` folders instead of into a singular concrete `package` folder.
  prefs: []
  type: TYPE_NORMAL
- en: What do we gain from that? Often nothing!
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned earlier, packages with an `init` load faster, and in many cases,
    the extra abstraction of namespace packages doesn't buy us anything.
  prefs: []
  type: TYPE_NORMAL
- en: There are cases, however, when we want different parts of the same package to
    be distributed or managed separately and when we do, `namespace packages` address
    that need. For example, imagine again that we are working on a package for playing
    soundtracks. If we make a `namespace package` folder for audio codecs, each codec
    could be installed and removed individually using `pip` or the operating system's
    normal package management tools.
  prefs: []
  type: TYPE_NORMAL
- en: On a slightly different topic, now let's talk about the difference between how
    a package is structured and the interface it should present for use by external
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The Package structure and interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the convenience and sanity of ourselves as the package developers, it's
    often best to break up the code in a package into many different modules, all
    of which contain a selection of conceptually related code; this is the package's
    structure. As a rule of thumb, whenever we think we might want to break the code
    up into more modules, we probably should go with that impulse.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, external code calling on our package is best off when it
    can take advantage of our code with just one or two import statements that bring
    in a small number of functions or classes. This is the package''s interface, and
    as a rule of thumb, it should be as minimal as possible, while preserving full
    functionality, as shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Fortunately, we can have our cake and eat it too!
  prefs: []
  type: TYPE_NORMAL
- en: We could divide our code up however we wish and then import the most useful
    elements into our `init` file, which will make them part of the package's route
    namespace. If all that's in an `init` file is `import` statements, we don't need
    the `__all__` variable.
  prefs: []
  type: TYPE_NORMAL
- en: An `import*` statement will grab the contents of the `init` file except for
    variables, starting with an underscore. However, if we define or import anything
    in the `init` file that should not be part of the public interface, we can use
    the `__all__` variable to narrow down and control what we export.
  prefs: []
  type: TYPE_NORMAL
- en: Just remember, if we have an all list, it needs to list everything that is part
    of the package's interface, whether a module, class, function, or variable.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the modules in the package are still available to be explicitly
    imported. We're just making it convenient to access the parts that are most likely
    to be useful outside our own package.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a good idea of how to name our modules, where to put them so that
    they become part of our package, and how to give our package a convenient interface.
    Next, we'll move on to looking at how to make the modules in a package interact
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing code from other modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start off this section by understanding the difference between absolute
    and relative imports, then move on to writing those, and finally, we'll look at
    cyclic dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: When we are importing one of the package's modules from outside the package,
    there's only one sensible way that it could work-we tell Python which package
    and module we want, and it either finds and imports it or raises an exception
    if it can't. Simple!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When we''re already inside a package, the situation is more ambiguous because
    `import name` could just as easily mean "look for `name` within this package"
    or "look for `name` in the Python search path." Python breaks this ambiguity by
    defining `import name` to mean that a package or module called **name** should
    be searched for in Python''s search path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, it also gives us a way to specify a relative `import` if we''d rather
    have it just look within the current package. We can specify a relative `import`
    by putting a dot in front of the name of the module we want to import, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When Python sees this, it will look for a module called `name` in the same package
    as the module our code is running in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, we only need one or two objects from another module and it''s more convenient
    to import those objects directly into our global scope than it would be to import
    the module as a whole and access its contents. Python lets us do that with a slight
    variation on the `import` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, sometimes we want to rename an object within our scope as we import
    it. We could do that by modifying our import with the `as` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, even though the object is called `Foo` in the `name`
    module, in our current module, it's named `Bar`. This trick works for absolute
    imports too by the way.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, let's take note that Python 2 used a different rule for deciding
    where to find imported code. In Python 2, it first tried to find a target of an
    import within the current package. Then, if no matching module was found there,
    it went out and looked for it on the search path. This approach usually did the
    right thing, but occasionally caused problems due to the ambiguous meaning; and
    it meant that we couldn't have some packages, sub-packages, or modules that shared
    the name of anything in the standard library or other installed packages. So,
    this behavior was changed in Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: Importing a cyclic dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is something that might trip us up when we''re importing a module that
    shares the same package. Sometimes, the module we''re importing wants to import
    us as well. This is called a **cyclic dependency**. When we try to import a cyclic
    dependency, we''ll almost always get an attribute error exception, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9cb740b2-3831-4c8d-8375-97be13077540.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That happens because when we ask Python to import the first module, Python immediately
    creates a module object for it and begins executing the code in the module.
  prefs: []
  type: TYPE_NORMAL
- en: That's fine, except that, when Python gets to the `import` statement for the
    next module in this cycle, it pauses running the code in the first module, leaving
    it not fully initialized. Even that isn't normally a problem because Python will
    come back and finish the initialization later.
  prefs: []
  type: TYPE_NORMAL
- en: However, when the second module asks to import the first module, Python just
    hands it the already allocated, and not fully initialized, module object. When
    the second module tries to access the variables stored in the first object, many
    of them will not yet have been created. Hence, an attribute error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving attribute errors raised due to cyclic dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two common ways to address the attribute error. The first one is
    usually considered the best. This method is to break the cycle by taking some
    of the code from one of the modules and moving it into a third module, which both
    the other modules can import without causing a cycle. In the following example,
    if we move the `A` class into its own module, there would be no cycle and all
    would be well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dad5ee64-c51b-489d-935b-13e1ac917d9b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The other way to address this problem is to move the `import` statement that
    causes the cycle, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93ba170e-592f-4227-9b25-3d8f3ebf975f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we move the `import` statement down, as shown in the preceding example, until
    it's below all the variable definitions that are needed by the other modules in
    this cycle, the module will be initialized enough when it's imported by the other
    modules. Python will still come back and finish the initialization later.
  prefs: []
  type: TYPE_NORMAL
- en: Adding static data files to the package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we're going to add static data files to the package, where should we put
    them?
  prefs: []
  type: TYPE_NORMAL
- en: Well we can put them anywhere that's convenient within the `package` folder,
    but it's often a good idea to create a subfolder specifically for holding the
    data files. This keeps data files separate from the source code and generally
    makes them a little easier to work with.
  prefs: []
  type: TYPE_NORMAL
- en: The data files that are part of a package should be assumed to be read-only.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many reasons that might cause the files to not be writable at runtime.
    So, if we want to write data to a file while our code is running, we need to pick
    somewhere else to store it. Only files that do not change are appropriate for
    inclusion in a package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So, that said, all we have to do to include a data file in our package is drop
    it into our package and then access the data with the `get_data` function from
    the `util` package in the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get_data` function takes two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the package we want to get the data from
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relative path of the data file inside the package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using forward slashes to separate path components, we pass it these two pieces
    of information and it returns a byte object to us containing the contents of the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: If we want a text string instead of bytes, that's easily done. We just need
    to apply the proper string decoder to the bytes object and we'll get back a unicode
    text string. This technique will work even if our package has been compressed
    into a ZIP file or otherwise hidden away because it uses the same underlying mechanism
    that Python uses to load module source code.
  prefs: []
  type: TYPE_NORMAL
- en: If Python can find the code, it can find the data file as well. That's all there
    is to working with static data that's packaged up alongside our code. It's simple
    and useful.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create a Python package as a directory on
    the filesystem and how to mark it with an `__init__.py` file, so that importing
    is efficient and we can add package metadata. We looked at adding code modules
    to a package. We saw how code modules within the same package interact.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to put together a Python code package that can be used in a program
    or distributed to other programmers. Soon, we'll see how to turn a package into
    a complete program as well. In the next chapter, we'll step back a little bit
    and talk about some best practices for working with Python code.
  prefs: []
  type: TYPE_NORMAL
