<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Data and Classes</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will save our GUI data into <kbd>tkinter</kbd> variables. We will also start using <strong>object-oriented programming</strong> (<strong>OOP</strong>), writing our own classes in Python. This will lead us to creating reusable OOP components. By the end of this chapter, you will know how to save data from the GUI into local <kbd>tkinter</kbd> variables. You will also learn how to display tooltips over widgets, which give the user additional information. Knowing how to do this makes our GUI more functional and easier to use.</p>
<p>Here is an overview of the Python modules for this chapter:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="Images/781646b9-8cac-45c5-b464-61edcf82442b.png" style="width:21.83em;height:29.92em;" width="266" height="364"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<div class="CDPAlignCenter CDPAlign">
<p><span>In this chapter, we will use data and OOP classes using Python 3.7 and above. We will cover the following recipes:</span></p>
</div>
<ul>
<li>How to use <kbd>StringVar()</kbd></li>
<li>How to get data from a widget</li>
<li>Using module-level global variables</li>
<li>How coding in classes can improve the GUI</li>
<li>Writing callback functions</li>
<li>Creating reusable GUI components</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to use StringVar()</h1>
                </header>
            
            <article>
                
<p>There are built-in programming types in <kbd>tkinter</kbd> that differ slightly from the Python types we are used to programming with. <kbd>StringVar()</kbd> is one such <kbd>tkinter</kbd> type. This recipe will show you how to use the <kbd>StringVar()</kbd> type.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn how to save data from the <kbd>tkinter</kbd> GUI into variables so we can use that data. We can set and get their values, which is very similar to how you would use the Java <kbd>getter</kbd>/<kbd>setter</kbd> methods.</p>
<p>Here are some of the types of code in <kbd>tkinter</kbd>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><kbd>strVar = StringVar()</kbd></td>
<td>Holds a string; the default value is an empty string (<kbd>""</kbd>)</td>
</tr>
<tr>
<td><kbd>intVar = IntVar()</kbd></td>
<td>Holds an integer; the default value is <kbd>0</kbd></td>
</tr>
<tr>
<td><kbd>dbVar = DoubleVar()</kbd></td>
<td>Holds a <kbd>float</kbd>; the default value is <kbd>0.0</kbd></td>
</tr>
<tr>
<td><kbd>blVar = BooleanVar()</kbd></td>
<td>Holds a Boolean, it returns <kbd>0</kbd> for <kbd>False</kbd> and 1 for <kbd>True</kbd></td>
</tr>
</tbody>
</table>
<div class="packt_infobox">Different languages call numbers with decimal points <kbd>float</kbd> or <kbd>double</kbd>. <kbd>tkinter</kbd> calls them <kbd>DoubleVar</kbd>, which is known in Python as the <kbd>float</kbd> data type. Depending on the level of precision, <kbd>float</kbd> and <kbd>double</kbd> data can be different. Here, we are translating <kbd>DoubleVar</kbd> of <span><kbd>tkinter</kbd> </span>into a Python <kbd>float</kbd> type.</div>
<p>This becomes clearer when we add a <kbd>DoubleVar</kbd> with a Python <kbd>float</kbd> and look at the resulting type, which is a Python <kbd>float</kbd> and no longer a <kbd><span>DoubleVar</span></kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>We will create a <kbd>DoubleVar</kbd> of <span><kbd>tkinter</kbd> </span>variable and add a <kbd>float</kbd> number literal to it using the <kbd>+</kbd> operator. After that, we will look at the resulting Python type.</p>
<p>Here are the steps to see the different <kbd>tkinter</kbd> data types:</p>
<ol>
<li>Create a new Python module and name it <kbd><span>GUI_PyDoubleVar_to_Float_Get.py</span></kbd>.</li>
<li><span>At the top of the <kbd>GUI_PyDoubleVar_to_Float_Get.py</kbd></span><span> module, import </span><span><kbd>tkinter</kbd>:</span></li>
</ol>
<pre style="padding-left: 60px">import tkinter as tk</pre>
<ol start="3">
<li>Create an instance of the <kbd>tkinter</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">win = tk.Tk()</pre>
<ol start="4">
<li>Create a <kbd>DoubleVar</kbd> and give it a value:</li>
</ol>
<pre style="padding-left: 60px">doubleData = tk.DoubleVar()<br/>print(doubleData.get())<br/>doubleData.set(2.4)<br/>print(type(doubleData))<br/><br/>add_doubles = 1.222222222222222222222222 + doubleData.get()<br/>print(add_doubles)<br/>print(type(add_doubles))</pre>
<ol start="5">
<li>The following screen<span>shot shows the final <kbd>GUI_PyDoubleVar_to_Float_Get.py</kbd> code and the output after r</span>unning the code:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/6c066496-f89c-4344-bb7d-7313ab6ff01e.png" width="454" height="353"/></div>
<p style="padding-left: 60px">We can do the same with <kbd>tkinter</kbd> with regards to strings.</p>
<p>We will create a new Python module as follows:</p>
<ol>
<li>Create a new Python module and name it <kbd><span>GUI_StringVar.py</span></kbd>.</li>
<li><span>At the top of the <kbd><span>GUI_StringVar.py</span></kbd></span><span> module, import </span><span><kbd>tkinter</kbd>:</span></li>
</ol>
<pre style="padding-left: 60px" class="mce-root">import tkinter as tk</pre>
<ol start="3">
<li>Create an instance of the <kbd>tkinter</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">win = tk.Tk()</pre>
<ol start="4">
<li>Assign a <kbd>StringVar</kbd> of <span><kbd>tkinter</kbd> </span>to the <kbd>strData</kbd> variable:</li>
</ol>
<pre style="padding-left: 60px">strData = tk.StringVar()</pre>
<ol start="5">
<li>
<p>Set the <kbd>strData</kbd> variable:</p>
</li>
</ol>
<pre style="padding-left: 60px">strData.set('Hello StringVar')</pre>
<ol start="6">
<li>Get the value of the <kbd>strData</kbd> variable and save it in <kbd>varData</kbd>:</li>
</ol>
<pre style="padding-left: 60px">varData = strData.get()</pre>
<ol start="7">
<li>Print out the current value of <kbd>strData</kbd>:</li>
</ol>
<pre style="padding-left: 60px">print(varData)</pre>
<ol start="8">
<li>The following screenshot shows the final <kbd>GUI_StringVar.py</kbd> code and the output after running the code: </li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/784fc4b2-11ca-4ab0-b5eb-facc47a2211e.png" width="362" height="342"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Next, we will print the default values of, <kbd>IntVar</kbd>, <kbd>DoubleVar</kbd>, and <kbd>BooleanVar</kbd> types of <kbd><span>tkinter</span></kbd>:</p>
<ol>
<li>Open<span> <kbd>GUI_StringVar.py</kbd></span> and save the module as <kbd><span>GUI_PyVar_defaults.py</span></kbd>.</li>
<li>Add the following lines of code toward the bottom of this module:</li>
</ol>
<pre style="padding-left: 60px">print(tk.IntVar())<br/>print(tk.DoubleVar())<br/>print(tk.BooleanVar())</pre>
<ol start="3">
<li>The following screenshot shows the final <kbd>GUI_PyVar_defaults.py</kbd> code and the output after running the <kbd><span>GUI_PyVar_defaults.py</span></kbd> code file:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/fecfbcdb-e903-4b25-b6af-10329205878b.png" width="378" height="263"/></div>
<p>The steps to print the default <kbd>tkinter</kbd> variable value are as follows:</p>
<ol start="1">
<li>Create a new Python module and name it<span> </span><kbd><span>GUI_PyVar_Get</span><span>.py</span></kbd>.</li>
<li>Type the following code into the module:</li>
</ol>
<pre style="padding-left: 60px">import tkinter as tk<br/># Create instance of tkinter<br/>win = tk.Tk()<br/># Print out the default tkinter variable values<br/>intData = tk.IntVar()<br/>print(intData)<br/>print(intData.get())<br/># Set a breakpoint here to see the values in the debugger<br/>print() </pre>
<ol start="3">
<li>Run the code, optionally setting a breakpoint in your IDE in the final <kbd>print()</kbd> statement:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b99d3c95-461a-4c20-87c0-f127a8011dba.png" width="392" height="421"/></p>
<p class="mce-root"><span>   Let's go behind the scenes to understand the code better.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>In the Eclipse PyDev console, toward the bottom of the screenshot for <kbd><span>GUI_StringVar.py</span></kbd> in <em>step 8</em>, we can see the output printed to the console, which is<span> </span><span class="packt_screen">Hello StringVar</span>. This shows us that we have to call the <kbd>get()</kbd> method to get the data.</p>
<p>As can be seen in the screenshot of <span><kbd>GUI_PyVar_defaults.py</kbd> in</span> <em>step 3</em>, the default values do not get printed, as we would have expected when we are not calling <kbd>get()</kbd>.</p>
<p>The online literature mentions default values, but we won't see those values until we call the <kbd>get</kbd> method on them. Otherwise, we just get a variable name that automatically increments (for example, <kbd>PY_VAR3</kbd>, as can be seen in the preceding screenshot of <kbd><span>GUI_PyVar_defaults.py</span></kbd>).</p>
<div class="packt_tip">Assigning the <kbd>tkinter</kbd> type to a Python variable does not change the outcome. We still do not get the default value until we call <kbd>get()</kbd> on this variable.</div>
<p>The value is <kbd>PY_VAR0</kbd>, not the expected <kbd>0</kbd>, until we call the <kbd>get</kbd> method. Now we can see the default value. We did not call <kbd>set</kbd>, so we see the default value automatically assigned to each <kbd>tkinter</kbd> type once we call the <kbd>get</kbd> method on each type.</p>
<p>Note how the default value of <kbd>0</kbd> gets printed to the console for the <kbd>IntVar</kbd> instance that we saved in the <kbd>intData</kbd> variable. We can also see the values in the Eclipse PyDev debugger window at the top of the screenshot.</p>
<p>First, we import the<span> </span><kbd>tkinter</kbd><span> </span>module and alias it to the name<span> </span><kbd>tk</kbd>. Next, we use this alias to create an instance of the<span> </span><kbd>Tk</kbd><span> </span>class by appending parentheses to<span> </span><kbd>Tk</kbd>, which calls the constructor of the class. This is the same mechanism as calling a function; only here, we create an instance of a class.</p>
<p>Usually, we use this instance assigned to the <kbd>win</kbd><span> </span>variable to start the main event loop later in the code, but here, we are not displaying a GUI; rather, we are demonstrating how to use the <kbd>StringVar</kbd><span> </span>type of <kbd><span>tkinter</span></kbd>.</p>
<div class="packt_infobox">We still have to create an instance of<span> </span><kbd>Tk()</kbd>. If we comment out this line, we will get an error from<span> </span><kbd>tkinter</kbd>, so this call is necessary.</div>
<p>Then, we create an instance of the<span> </span><kbd>StringVar</kbd><span> </span>type<span> <kbd>tkinter</kbd></span> and assign it to our Python<span> </span><kbd>strData</kbd><span> </span>variable. After that, we use our variable to call the<span> </span><kbd>set()</kbd><span> </span>method on<span> </span><kbd>StringVar</kbd><span> </span>and after setting it to a value, we get the value, save it in a new variable named<span> </span><kbd>varData</kbd>, and then print out its value. <span>We've successfully learned how to use <kbd>StringVar()</kbd>. Now let's move on to the next recipe.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to get data from a widget</h1>
                </header>
            
            <article>
                
<p>When the user enters data, we want to do something with it in our code. This recipe shows how to capture data in a variable. In the previous recipe, we created several <kbd>tkinter</kbd> class variables. They were standalone. Now, we are connecting them to our GUI, using the data we get from the GUI, and storing them in Python variables.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will continue using the Python GUI we were building in <a href="ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml" target="_blank">Chapter 3</a>, <em>Look and Feel Customization</em>. We'll reuse and enhance the code from <kbd>GUI_progressbar.py</kbd> from that chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>We will assign a value from our GUI to a Python variable:</p>
<ol>
<li>Open <kbd><span>GUI_progressbar.py</span></kbd> from <a href="ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml" target="_blank">Chapter 3</a><span>, </span><em>Look and Feel Customization</em>, and save the module as <kbd>GUI_data_from_widget.py</kbd>.</li>
<li>Add the following code toward the bottom of our module. Just above the main event loop, add <kbd>strData</kbd>:</li>
</ol>
<pre style="padding-left: 60px">strData = spin.get() <br/>print("Spinbox value: " + strData) </pre>
<ol start="3">
<li>
<p>Add code to place the cursor into the name entry:</p>
</li>
</ol>
<pre style="padding-left: 60px">name_entered.focus()</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="4">
<li>
<p>Start the GUI:</p>
</li>
</ol>
<pre style="padding-left: 60px">win.mainloop() </pre>
<ol start="5">
<li>
<p>Running the code gives us the following result:</p>
</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/3c8942f3-1f96-47ad-b9d0-f62602f76888.png" width="365" height="162"/></div>
<div class="packt_infobox">We placed our code above the GUI main event loop, so the printing happens before the GUI becomes visible. We would have to place the code into a callback function if we wanted to print out the current value after displaying the GUI and changing the value of the <kbd>Spinbox</kbd> control.</div>
<p><span>We will retrieve the current value of the </span><kbd>Spinbox</kbd><span> control:</span></p>
<ol>
<li>We create our <kbd>Spinbox</kbd> widget using the following code, hard-coding the available values into it:</li>
</ol>
<pre style="padding-left: 60px"># Adding a Spinbox widget using a set of values <br/>spin = Spinbox(mighty, values=(1, 2, 4, 42, 100), width=5, bd=8, <br/>command=_spin)  <br/>spin.grid(column=0, row=2) </pre>
<ol start="2">
<li>We can also move the hard-coding of the data out of the creation of the <kbd>Spinbox</kbd> class instance and set it later:</li>
</ol>
<pre style="padding-left: 60px"># Adding a Spinbox widget assigning values after creation <br/>spin = Spinbox(mighty, width=5, bd=8, command=_spin)  <br/>spin['values'] = (1, 2, 4, 42, 100) <br/>spin.grid(column=0, row=2) </pre>
<p style="padding-left: 60px">It does not matter how we create our widget and insert data into it because we can access this data by using the <kbd>get()</kbd> method on the instance of the widget.</p>
<p><span>Let's go behind the scenes to understand the code better.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>In order to get the values out of our GUI written using <kbd>tkinter</kbd>, we use the <kbd>get()</kbd> method of <kbd><span>tkinter</span></kbd> on an instance of the widget we wish to get the value from.</p>
<p>In the preceding example, we used the <kbd>Spinbox</kbd> control, but the principle is the same for all widgets that have a <kbd>get()</kbd> method.</p>
<p>Once we have got the data, we are in a pure Python world, and <kbd>tkinter</kbd> did serve us well in building our GUI. Now that we know how to get the data out of our GUI, we can use this data.</p>
<p><span>We've successfully learned how to get data from a widget. Now let's move on to the next recipe.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using module-level global variables</h1>
                </header>
            
            <article>
                
<p>Encapsulation is a major strength in any programming language, enabling us to program using OOP. Python is both OOP-friendly as well as procedural. We can create <kbd>global</kbd> variables that are localized to the module they reside in. They are <kbd>global</kbd> only to this module, which is one form of encapsulation. Why do we want this? Because as we add more and more functionality to our GUI, we want to avoid naming conflicts that could result in bugs in our code.</p>
<div class="packt_infobox">We do not want naming clashes creating bugs in our code! Namespaces are one way to avoid these bugs, and in Python, we can do this by using Python modules (which are unofficial namespaces).</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We can declare module-level <strong>globals </strong>in any module just above and outside functions.</p>
<p>We then have to use the <kbd>global</kbd> Python keyword to refer to them. If we forget to use <kbd>global</kbd> in functions, we will accidentally create new local variables. This would be a bug and something we really do not want to do.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<div class="packt_infobox">Python is a dynamic, strongly typed language. We will notice bugs such as this (forgetting to scope variables with the <kbd>global</kbd> keyword) only at runtime.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Add the following code to the GUI we used in the previous recipe, <em>How to get data from a widget</em>, creating a module-level global variable. We use the all-uppercase convention for constants:</p>
<div class="packt_infobox">You can find more information in <strong>PEP 8 -- Style Guide for Python Code</strong> at <a href="https://www.python.org/dev/peps/pep-0008/#constants">https://www.python.org/dev/peps/pep-0008/#constants</a>.</div>
<ol>
<li>Open <kbd><span>GUI_data_from_widget.py</span></kbd> and save the module as <kbd><span>GUI_const_42_print.py</span></kbd><span>.</span></li>
<li>Add the constant variable at the top and the <kbd>print</kbd> statement at the bottom of the module:</li>
</ol>
<pre style="padding-left: 60px">GLOBAL_CONST = 42<br/># ...<br/>print(GLOBAL_CONST)</pre>
<ol start="3">
<li class="CDPAlignLeft CDPAlign">Running the code results in a printout of the <kbd>global</kbd>. Note <span class="packt_screen">42</span> being printed to the Eclipse console (<kbd><span>GUI_const_42_print.py</span></kbd>):</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/18585c62-9166-43f4-8f70-eb68ae38d6bb.png" style="width:23.25em;height:15.50em;" width="344" height="229"/></div>
<p class="mce-root">Add the <kbd>usingGlobal</kbd> function toward the bottom of the module:</p>
<ol>
<li>Open<span> </span><kbd><span>GUI_const_42_print.py</span></kbd> and save the module as <kbd><span>GUI_const_42_print_func.py</span></kbd>.</li>
<li>Add the function and then call it:</li>
</ol>
<pre style="padding-left: 60px">def usingGlobal():<br/>    print(GLOBAL_CONST)<br/># call the function<br/>usingGlobal()</pre>
<ol start="3">
<li>The following screens<span>hot shows the final <kbd>GUI_const_42_print_func.py</kbd> code and the output after r</span>unning the code:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ec32da05-1b4b-4505-ac9f-a06e36e7bfc5.png" style="width:19.75em;height:9.25em;" width="371" height="173"/></p>
<p class="mce-root">In the preceding code snippet, we use the module-level<span> </span><kbd>global</kbd>. It is easy to make a mistake by <em>shadowing</em> the <kbd>global</kbd>, as demonstrated in the following code:</p>
<ol>
<li>Open<span> <kbd>GUI_const_42_print_func.py</kbd></span><span> and </span>save the module as <kbd><span>GUI_const_42_777.py</span></kbd>.</li>
<li>Add the declaration of the constant within the function:</li>
</ol>
<pre style="padding-left: 60px">def usingGlobal():<br/>    GLOBAL_CONST = 777<br/>    print(GLOBAL_CONST)</pre>
<ol start="3">
<li class="mce-root">The following screenshot shows the final <span><kbd>GUI_const_42_777.py</kbd> code and the output after r</span>unning the code:<span>  </span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8319b1c4-856b-4f2f-bd19-476603bd1212.png" style="width:19.00em;height:7.75em;" width="332" height="135"/></p>
<p style="padding-left: 60px" class="mce-root">Note how<span> </span><span class="packt_screen">42</span><span> </span>becomes<span> </span><span class="packt_screen">777</span>, even though we are using the same variable name.</p>
<div class="packt_infobox CDPAlignLeft CDPAlign">There is no compiler in Python that warns us if we override<span> </span><kbd>global</kbd><span> </span>variables in a local function. This can lead to difficulties in debugging at runtime.</div>
<p class="mce-root">If we try to print out the value of the global variable, without using the<span> </span><kbd>global</kbd><span> </span><span>keyword</span>, we get an error:</p>
<ol>
<li>Open<span> <kbd>GUI_const_42_777.py</kbd></span><span> and </span>save the module as <kbd>GUI_const_42_777_global_print_error.py</kbd>.</li>
<li>Comment out <kbd>global</kbd> and try to print:</li>
</ol>
<pre style="padding-left: 60px">def usingGlobal():<br/>    # global GLOBAL_CONST<br/>    print(GLOBAL_CONST)<br/>    GLOBAL_CONST = 777<br/>    print(GLOBAL_CONST)</pre>
<ol start="3">
<li>Run the code and observe the output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/7fa827ff-bdd9-4ac9-8734-36731565d8d2.png" style="width:40.42em;height:11.08em;" width="557" height="153"/></div>
<p class="mce-root"/>
<p class="CDPAlignLeft CDPAlign">When we qualify our local variable with the<span> </span><kbd>global</kbd><span> </span>keyword, we can print out the value of the<span> </span><kbd>global</kbd><span> </span>variable and overwrite this value locally:</p>
<ol>
<li>Open<span> <kbd>GUI_const_42_777_global.py</kbd></span><span>.</span></li>
<li>Add the following code:</li>
</ol>
<pre style="padding-left: 60px">def usingGlobal():<br/>    global GLOBAL_CONST<br/>    print(GLOVAL_CONST)<br/>    GLOBAL_CONST = 777<br/>    print(GLOBAL_CONST)</pre>
<ol start="3">
<li class="mce-root">Run the code and observe the output:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ebd144a8-b0dc-489d-a062-9a603ae6fe7b.png" style="width:27.50em;height:17.50em;" width="377" height="241"/></p>
<p class="mce-root">We might believe that the value of the global variable is local to our function.</p>
<ol>
<li>Open<span> </span><span><kbd>GUI_const_42_777_global.py</kbd></span><span> and save </span>as <kbd>GUI_const_42_777_global_shadowing.py</kbd>.</li>
<li>Add<span> </span><kbd>print('GLOBAL_CONST:', GLOBAL_CONS</kbd><kbd>T)</kbd><span> </span>below the function.</li>
</ol>
<ol start="3">
<li>Run the code and observe the output:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7cfb263b-4094-4eb2-9e8d-b97936b723f6.png" style="width:24.83em;height:12.50em;" width="443" height="223"/></p>
<p><span>Let's go behind the scenes to understand the code better.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>We define a <kbd>global</kbd> variable at the top of our module, and we print out its value later, toward the bottom of our module.</p>
<p>That works. We then define a function and print out the value of the <kbd>global</kbd> within the function by using the <kbd>global</kbd> keyword. If we forget to use the <kbd>global</kbd> keyword, we are creating a new, local variable. When we change the value of the global inside the function, this actually changes the global variable. As we can see, even outside of our function the global value has changed.</p>
<p><kbd>global</kbd> variables can be very useful when programming small applications. They can help us make data available across methods and functions within the same Python module and, sometimes, the overhead of OOP is not justified.</p>
<p>As our programs grow in complexity, the benefit we gain from using globals can quickly diminish.</p>
<div class="packt_infobox">It is best to avoid globals and accidentally shadowing variables by using the same name in different scopes. We can use OOP instead of using global variables.</div>
<p>We have played around with <kbd>global</kbd> variables within procedural code and have learned how it can lead to hard-to-debug bugs. In the next recipe, we will move on to OOP, which can eliminate such bugs.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How coding in classes can improve the GUI</h1>
                </header>
            
            <article>
                
<p>So far, we have been coding in a procedural style. This is a quick scripting method we can do in Python. When our code gets larger and larger, we need to advance to coding in OOP.</p>
<p>Why?</p>
<p>Because, among many other benefits, OOP allows us to move code around by using methods. Once we use classes, we no longer have to physically place the code above the code that calls it. This gives us great flexibility in organizing our code. We can write the related code next to the other code and no longer have to worry that the code will not run because the code does not sit above the code that calls it. We can take that to some rather fancy extremes by coding up modules that refer to methods that are not being created within that module. They rely on the runtime state having created those methods during the time the code runs.</p>
<div class="packt_infobox">If the methods we call have not been created by that time, we get a runtime error.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will turn our entire procedural code into OOP very simply. We just turn it into a class, indent all the existing code, and prepend <kbd>self</kbd> to all variables.</p>
<p>It is very easy.</p>
<p>While at first it might feel a little bit annoying having to prepend everything with the <kbd>self</kbd> keyword, making our code more verbose (<q>hey, we are wasting so much paper…</q>), in the end it is worth it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Note that in the Eclipse IDE, the PyDev editor hints at coding problems by highlighting them in red on the right-hand side portion of the code editor.</p>
<ol>
<li>Open<span> <kbd>GUI_const_42_777_global.py</kbd></span><span> and save the module as <kbd>GUI_OOP_classes.py</kbd></span>.</li>
<li>Highlight the entire code below the imports and indent it by four spaces.</li>
<li>Add <kbd>class OOP():</kbd> above the indented code.</li>
<li>Look at all of the red errors in the code editor on the right-hand side:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f853c7d0-376d-419c-9be3-7cda5f228967.png" width="1328" height="608"/></p>
<p style="padding-left: 60px">We have to prepend all the variables with the <kbd>self</kbd> keyword and also bind the functions to the class by using <kbd>self</kbd>, which officially and technically turns the functions into methods.</p>
<p>Let's prefix everything with <kbd>self</kbd> to fix all of the red so we can run our code again:</p>
<ol>
<li>Open <span><kbd>GUI_OOP_classes.py</kbd></span><span> and save the module as <kbd>GUI_OOP_2_classes.py</kbd></span>.</li>
<li>Add the <kbd>self</kbd> keyword wherever it is needed, for example, <kbd>click_me(self)</kbd>.</li>
<li>Run the code and observe it:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/a6a8afb0-489a-487a-bdc8-80a7335a3ad6.png" style="width:31.58em;height:5.00em;" width="486" height="77"/></div>
<p style="padding-left: 60px">Once we do this for all of the errors highlighted in red, we can run our Python code again. The <kbd>click_me</kbd> function is now bound to the class and has officially become a method. We are no longer getting any errors that prevent the code from running.</p>
<p>Now let's add our <kbd>ToolTip</kbd> <span>class </span>from <a href="ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml" target="_blank">Chapter 3</a><span>, </span><em>Look and Feel Customization</em>, into this Python module:</p>
<ol>
<li><span>Open </span><span><kbd>GUI_OOP_2_classes.py</kbd></span>.</li>
<li>Add<span> the <kbd>ToolTip</kbd></span><span> class from </span><kbd>GUI_tooltip.py</kbd> <span>to the top of the following module's <kbd>import</kbd> statements:</span></li>
</ol>
<pre style="padding-left: 60px">class ToolTip(object):<br/>    def __init__(self, widget, tip_text=None):<br/>        self.widget = widget<br/> ...<br/>class OOP():<br/>    def __init__(self): <br/>        self.win = tk.Tk() <br/>        ToolTip(self.win, 'Hello GUI')<br/>        # &lt;-- use the ToolTip class here<br/> ...</pre>
<p><span>Let's go behind the scenes to understand the code better.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>We are translating our procedural code into object-oriented code. First, we indented the entire code and defined the code to be part of a class, which we named <kbd>OOP</kbd>. In order to make this work, we have to use the <kbd>self</kbd> keyword for both variables and methods. Here is a brief comparison of our previous code with the new OOP code using a class:</p>
<pre>########################################<br/># Our procedural code looked like this:<br/>########################################<br/># Button Click Function<br/>def click_me(): <br/>    action.configure(text='Hello ' + name.get() + ' ' + <br/>    number_chosen.get())<br/><br/># Adding a Textbox Entry widget<br/>name = tk.StringVar()<br/>name_entered = ttk.Entry(mighty, width=12, textvariable=name)<br/>name_entered.grid(column=0, row=1, sticky='W') <br/><br/># Adding a Button<br/>action = ttk.Button(mighty, text="Click Me!", command=click_me) <br/>action.grid(column=2, row=1) <br/><br/>ttk.Label(mighty, text="Choose a number:").grid(column=1, row=0)<br/>number = tk.StringVar()<br/>number_chosen = ttk.Combobox(mighty, width=12, <br/>textvariable=number, state='readonly')<br/>number_chosen['values'] = (1, 2, 4, 42, 100)<br/>number_chosen.grid(column=1, row=1)<br/>number_chosen.current(0)<br/># ...<br/><br/>******************************************** <br/>The new OOP code looks like this: <br/>********************************************<br/>class OOP(): <br/>    def __init__(self):                # Initializer method<br/>        # Create instance <br/>        self.win = tk.Tk()             # notice the self keyword<br/>            <br/>        ToolTip(self.win, 'Hello GUI')<br/>        # Add a title        <br/>        self.win.title("Python GUI")       <br/>        self.create_widgets() <br/><br/>    # Button callback <br/>    def click_me(self): <br/>        self.action.configure(text='Hello ' + self.name.get() + ' ' <br/>        +self.number_chosen.get()) <br/>        # ... more callback methods  <br/><br/>    def create_widgets(self):     <br/>        # Create Tab Control <br/>        tabControl = ttk.Notebook(self.win)     <br/>        tab1 = ttk.Frame(tabControl)            # Create a tab  <br/>        tabControl.add(tab1, text='Tab 1')      # Add the tab <br/>        tab2 = ttk.Frame(tabControl)           # Create second tab <br/>        tabControl.add(tab2, text='Tab 2')      # Add second tab <br/>        # Pack to make visible <br/>        tabControl.pack(expand=1, fill="both")  <br/><br/>        # Adding a Textbox Entry widget - using self<br/>        self.name = tk.StringVar()<br/>        name_entered = ttk.Entry(mighty, width=12, <br/>        textvariable=self.name)<br/>        name_entered.grid(column=0, row=1, sticky='W') <br/>        # Adding a Button - using self<br/>        self.action = ttk.Button(mighty, text="Click Me!", <br/>        command=self.click_me) <br/>        self.action.grid(column=2, row=1)<br/>        # ...<br/>#====================== <br/># Start GUI <br/>#====================== <br/>oop = OOP()    # create an instance of the class<br/>               # use instance variable to call mainloop via oop.win<br/>oop.win.mainloop()   </pre>
<p>We moved the callback methods to the top of the module, inside the new <kbd>OOP</kbd> class. We moved all the widget-creation code into one rather long method, <kbd>create_widgets</kbd>, which we call in the initializer of the class. Technically, deep underneath the hood of the low-level code Python does have a constructor, yet Python frees us from any worries about this. It is taken care of for us. Instead, in addition to a real constructor, Python provides us with an initializer, <kbd>__init__(self)</kbd>. We are strongly encouraged to use this initializer. We can use it to pass in arguments to our class, initializing variables we wish to use inside our class instance.</p>
<p>In the end, we added the <kbd>ToolTip</kbd> class to the top of our module just below the <kbd>import</kbd> statements.</p>
<div class="packt_infobox">In Python, several classes can exist within the same Python module and the module name does not have to be the same as the class name.</div>
<p>Here, in this recipe, we can see that more than one class can live in the same Python module.</p>
<p>Cool stuff, indeed! Here are two screenshots of the two classes residing in the same module:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/56dfa16e-0c33-4574-8b94-2c90a679e929.png" width="350" height="155"/></p>
<p>Both the <kbd>ToolTip</kbd> class and the <kbd>OOP</kbd> class reside within the same Python module, <kbd>GUI_OOP_2_classes.py</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/6555f80c-5f89-46ed-a9a4-7241103518ef.png" style="width:22.67em;height:10.83em;" width="429" height="204"/></p>
<p>In this recipe, we advanced our procedural code into OOP code. Python enables us to write code in both a practical and a procedural style, like the C programming language style. At the same time, we have the option to code in an OOP style, like the Java, C#, and C++ style.</p>
<p><span>We've successfully learned how coding in classes can improve the GUI. Now let's move on to the next recipe.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing callback functions</h1>
                </header>
            
            <article>
                
<p>At first, callback functions can seem to be a little bit intimidating. You call the function, passing it some arguments, and then the function tells you that it is really very busy and it will call you back!</p>
<p>You wonder: will this function ever call me back? And how long do I have to wait? In Python, even callback functions are easy and, yes, they usually do call you back. They just have to complete their assigned task first (<q>hey, it was you who coded them in the first place…</q>).</p>
<p>Let's learn a little bit more about what happens when we code callbacks into our GUI. Our GUI is event-driven. After it has been created and displayed onscreen, it typically sits there waiting for an event to happen. It is basically waiting for an event to be sent to it. We can send an event to our GUI by clicking one of its buttons. This creates an event and, in a sense, we called our GUI by sending it a message.</p>
<p>Now, what is supposed to happen after we send a message to our GUI? What happens after clicking the button depends on whether we created an event handler and associated it with this button. If we did not create an event handler, clicking the button will have no effect. The event handler is a callback function (or method, if we use classes). The callback method is also sitting there passively, like our GUI, waiting to be invoked. Once our GUI's button is clicked, it will invoke the callback.</p>
<p>The callback often does some processing and, when done, it returns the result to our GUI.</p>
<div class="packt_infobox">In a sense, we can see that our callback function is calling our GUI back.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>The Python interpreter runs through all the code in a module once, finding any syntax errors and pointing them out. You cannot run your Python code if you do not have the syntax right. This includes indentation (if not resulting in a syntax error, incorrect indentation usually results in a bug).</p>
<p>On the next parsing round, the interpreter interprets our code and runs it.</p>
<p>At runtime, many GUI events can be generated, and it is usually callback functions that add functionality to GUI widgets.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Here is the callback for the <kbd>Spinbox</kbd> widget:</p>
<ol>
<li>Open <kbd><span>GUI_OOP_2_classes.py</span></kbd><span>.</span></li>
<li>Observe the <kbd>_spin(self)</kbd> method in the code:<span> </span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/2e02ce01-c01f-4504-8ada-018d97f271aa.png" width="637" height="152"/></p>
<p><span>Let's go behind the scenes to understand the code better.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>We create a callback method in the <kbd>OOP</kbd> class that gets called when we select a value from the <kbd>Spinbox</kbd> widget because we bind the method to the widget via the <kbd>command</kbd> argument (<kbd>command=self._spin</kbd>). We use a leading underscore to hint at the fact that this method is meant to be respected like a private Java method.</p>
<p>Python intentionally avoids language restrictions, such as private, public, friend, and so on. In Python, we use naming conventions instead. Leading and trailing double underscores surrounding a keyword are expected to be restricted to the Python language, and we are expected not to use them in our own Python code.</p>
<p>However, we can use a leading underscore prefix with a variable name or function to provide a hint that this name is meant to be respected as a private helper.</p>
<p>At the same time, we can postfix a single underscore if we wish to use what otherwise would be built-in Python names. For example, if we wished to abbreviate the length of a list, we could do the following:</p>
<pre>len_ = len(aList) </pre>
<div class="packt_tip">Often, the underscore is hard to read and easy to overlook, so this might not be the best idea in practice.</div>
<p><span>We've successfully learned how </span><span>to write callback functions. Now let's move on to the next recipe.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating reusable GUI components</h1>
                </header>
            
            <article>
                
<p>We will create reusable GUI components using Python. In this recipe, we will keep it simple by moving our <kbd>ToolTip</kbd> class into its own module. Then, we will import and use it to display <span>tooltip</span>s over several widgets of our GUI.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We are building our code from <a href="ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml" target="_blank">Chapter 3</a>, <em>Look and Feel Customization</em>: <kbd>GUI_tooltip.py</kbd>. <span>We will start by breaking out our </span><kbd>ToolTip</kbd><span> class into a separate Python module.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>We will create a new Python module and place the <kbd>ToolTip</kbd> class code into it and then import this module into our primary module:</p>
<ol>
<li>Open <kbd><span>GUI_OOP_2_classes.py</span></kbd><span> and save the module as <kbd>GUI_OOP_class_imported_tooltip.py</kbd></span>.</li>
<li>Break out the <kbd>ToolTip</kbd> code from <kbd><span>GUI_tooltip.py</span></kbd> into a new Python module and name the module <kbd>ToolTip.py</kbd>.</li>
<li>Import the <kbd>ToolTip</kbd> class into <kbd><span>GUI_OOP_class_imported_tooltip.py</span></kbd>:</li>
</ol>
<pre style="padding-left: 60px">from Ch04_Code.ToolTip import ToolTip</pre>
<ol start="4">
<li><span><span>Add </span></span>the following code to <kbd><span>GUI_OOP_class_imported_tooltip.py</span></kbd>:</li>
</ol>
<pre style="padding-left: 60px">ToolTip(self.win, 'Hello GUI')<br/><br/># Add a ToolTip to the Spinbox<br/>ToolTip(self.spin, 'This is a Spinbox control') <br/><br/># Add tooltips to more widgets<br/>ToolTip(self.name_entered, 'This is an Entry control') <br/>ToolTip(self.action, 'This is a Button control') <br/>ToolTip(self.scrol, 'This is a ScrolledText control') <br/><br/># Tab 2<br/>ToolTip(curRad, 'This is a Radiobutton control')</pre>
<ol start="5">
<li>Run the code and hover the mouse over the different widgets:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/57a0d7d6-f7c0-4cf5-9732-470ec6d138bd.png" style="width:19.67em;height:16.92em;" width="316" height="272"/></p>
<p class="mce-root"/>
<p style="padding-left: 60px">This also works on the second tab:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/b764cef7-fe59-4565-978b-f470e2d52261.png" style="width:18.67em;height:20.08em;" width="316" height="340"/></div>
<p><span>Let's go behind the scenes to understand the code better.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>First, we created a new Python module and placed the <kbd>ToolTip</kbd> class into this new module. Then, we imported this <kbd>ToolTip</kbd> class into a different Python module. After that, we created several tooltips using the class.</p>
<p><span>In the preceding screenshots, we can see several</span> <kbd>ToolTip</kbd><span> messages being displayed. The one for the main window might appear a little bit annoying, so it is better not to display a </span><kbd><span>ToolTip</span></kbd><span> for the main window because we really wish to highlight the functionality of the individual widgets. The main window form has a title that explains its purpose; no need for a <kbd>ToolTip</kbd>.</span></p>
<p>Refactoring our common<span> </span><kbd>ToolTip</kbd><span> </span>class code out into its own module helps us reuse this code from other modules. Instead of copy/paste/modify, we use the<span> </span><strong>DRY</strong><span> </span><strong>principle</strong><span> </span>and our common code is located in only one place, so when we modify the code, all modules that import it will automatically get the latest version of our module.</p>
<div class="packt_infobox"><strong>DRY</strong><span> is </span>short for<span> </span><strong>Don't Repeat Yourself</strong>, and we will look at it again in a later chapter. We can do similar things by turning our<span> </span><span class="packt_screen">Tab 3</span><span> </span>image into a reusable component. To keep this recipe's code simple, we removed<span> </span><span class="packt_screen">Tab 3</span>, but you can experiment with the code from the previous chapter. </div>


            </article>

            
        </section>
    </div>



  </body></html>