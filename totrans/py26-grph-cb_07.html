<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Combining Raster and Vector Pictures</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Simple animation of a GIF beach ball</li><li class="listitem" style="list-style-type: disc">The vector walking creature</li><li class="listitem" style="list-style-type: disc">Bird with shoes walking in the karroo</li><li class="listitem" style="list-style-type: disc">Making a partially transparent image with Gimp</li><li class="listitem" style="list-style-type: disc">Diplomat walking at the palace</li><li class="listitem" style="list-style-type: disc">Spider in the forest</li><li class="listitem" style="list-style-type: disc">Moving band of images</li><li class="listitem" style="list-style-type: disc">Continuous band of images</li><li class="listitem" style="list-style-type: disc">Endless background a passing cloudscape</li></ul></div><p>Vector graphics as seen in<a class="link" href="ch02.html" title="Chapter 2. Drawing Fundamental Shapes"> Chapter 2</a>,<em> Drawing Fundamental Shapes</em> and<a class="link" href="ch03.html" title="Chapter 3. Handling Text"> Chapter 3</a>,<em> Handling Text</em> can be shrunk and expanded to any size and in any direction using simple algebra. They can be animated with rotations using basic trigonometry. Raster graphics are limited. They cannot be resized or rotated dynamically while the code is executing. They are more cumbersome. However, we can get tremendous effects when we combine both vector and raster graphics together. The one thing that Python cannot do is to rotate a<code class="literal"> GIF</code> image by itself. There are ways of mimicking rotation reasonably but there are limitations you will appreciate after trying out some of these recipes. PIL can rotate them, but not dynamically on a Tkinter canvas. We explore some possibilities and workarounds here.<a id="id181" class="indexterm"/>
</p><p>Because we are not altering and manipulating the actual properties of the images we do not need the Python Imaging Library (PIL) in this chapter. We need to work exclusively with<code class="literal"> GIF</code> format images because that is what Tkinter deals with.<a id="id182" class="indexterm"/>
</p><p>We will also see how to use "The GIMP" as a tool to prepare images suitable for animation.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec01"/>Simple animation of a GIF beach ball</h1></div></div></div><p>We want to animate a raster image, derived from a photograph.<a id="id183" class="indexterm"/>
</p><p>To keep things simple and clear we are just going to move a photographic image (in<code class="literal"> GIF</code> format) of a beach ball across a black background.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec01"/>Getting ready</h2></div></div></div><p>We need a suitable<code class="literal"> GIF</code> image of an object that we want to animate. An example of one, named<code class="literal"> beachball.gif</code> has been provided.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec02"/>How to do it...</h2></div></div></div><p>Copy a<code class="literal"> .gif</code> file from somewhere and paste it into a directory where you want to keep your work-in-progress pictures.</p><p>Ensure that the path in our computer's file system leads to the image to be used. In the example below the instruction<code class="literal"> ball = PhotoImage(file = "constr/pics2/beachball.gif")</code> says that the image to be used will be found in a directory (folder) called<code class="literal"> pics2</code>, which is a sub-folder of another folder called<code class="literal"> constr</code>.</p><p>Then execute the following code.</p><div><pre class="programlisting"># photoimage_animation_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title("Animating a Photo Beachball")
cycle_period = 100
cw = 320 # canvas width
ch = 120 # canvas height
canvas_1 = Canvas(root, width=cw, height=ch, bg="black")
canvas_1.grid(row=0, column=1)
posn_x = 10
posn_y = 10
shift_x = 2
shift_y = 1
ball = PhotoImage(file = "/constr/pics2/beachball.gif")
for i in range(1,100): # end the program after 100 position # shifts.
posn_x += shift_x
posn_y += shift_y
canvas_1.create_image(posn_x,posn_y,anchor=NW, image=ball)
canvas_1.update() # This refreshes the drawing on the # canvas.
canvas_1.after(cycle_period) # This makes execution pause for # 100 milliseconds.
canvas_1.delete(ALL) # This erases everything on the # canvas.
root.mainloop()
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec03"/>How it works...</h2></div></div></div><p>The image of the beach ball is shifted across a canvas in exactly the same manner that was used in<a class="link" href="ch04.html" title="Chapter 4. Animation Principles"> Chapter 4</a>,<em> Animation Principles</em>. The difference now is that the photo type images always occupy a rectangular area of screen. The size of this box, called the bounding box, is the size of the image. We have used a black background so the black corners on the image of our beach ball cannot be seen.<a id="id184" class="indexterm"/>
</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec02"/>The vector walking creature</h1></div></div></div><p>We make a pair of walking legs using the vector graphics of<a class="link" href="ch02.html" title="Chapter 2. Drawing Fundamental Shapes"> Chapter 2</a>,<em> Drawing Fundamental Shapes</em> and<a class="link" href="ch04.html" title="Chapter 4. Animation Principles"> Chapter 4</a>,<em> Animation Principles, Handling Text</em>. We want to use these legs together with pieces of raster images and see how far we can go in making appealing animations. We import Tkinter, math, and time modules. The math is needed to provide the trigonometry that sustains the geometric relations that move the parts of the leg in relation to each other.<a id="id185" class="indexterm"/>
</p><div><img src="img/3845_07_01.jpg" height="228" alt="The vector walking creature"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec04"/>Getting ready</h2></div></div></div><p>We will be using Tkinter and time modules as was done in<a class="link" href="ch04.html" title="Chapter 4. Animation Principles"> Chapter 4</a>, again to animate the movement of lines and circles. You will see some trigonometry in the code. If you do not like mathematics you can just cut and paste the code without the need to understand exactly how the maths works. However, if you are a friend of mathematics it is fun to watch sine, cosine, and tangent working together to make a child smile.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec05"/>How to do it...</h2></div></div></div><p>Execute the program as shown in the previous image.<a id="id186" class="indexterm"/>
</p><div><pre class="programlisting"># walking_creature_1.py
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
import math
import time
root = Tk()
root.title("The thing that Strides")
cw = 400 # canvas width
ch = 100 # canvas height
#GRAVITY = 4
chart_1 = Canvas(root, width=cw, height=ch, background="white")
chart_1.grid(row=0, column=0)
cycle_period = 100 # time between new positions of the ball # (milliseconds).
base_x = 20
base_y = 100
hip_h = 40
thy = 20
#===============================================
# Hip positions: Nhip = 2 x Nstep, the number of steps per foot per # stride.
hip_x = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 60, 60] #15
hip_y = [0, 8, 12, 16, 12, 8, 0, 0, 0, 8, 12, 16, 12, 8, 0] #15
step_x = [0, 10, 20, 30, 40, 50, 60, 60] # 8 = Nhip
step_y = [0, 35, 45, 50, 43, 32, 10, 0]
# The merging of the separate x and y lists into a single sequence.
#==================================
# Given a line joining two points xy0 and xy1, the base of an # isosceles triangle,
# as well as the length of one side, "thy" . This returns the # coordinates of the apex joining the equal-length sides.
def kneePosition(x0, y0, x1, y1, thy):
theta_1 = math.atan2((y1 - y0), (x1 - x0))
L1 = math.sqrt( (y1 - y0)**2 + (x1 - x0)**2)
if L1/2 &lt; thy:
# The sign of alpha determines which way the knees bend.
alpha = -math.acos(L1/(2*thy)) # Avian
#alpha = math.acos(L1/(2*thy)) # Mammalian
else:
alpha = 0.0
theta_2 = alpha + theta_1
x_knee = x0 + thy * math.cos(theta_2)
y_knee = y0 + thy * math.sin(theta_2)
return x_knee, y_knee
def animdelay():
vector imagespair of walking legs, creatingchart_1.update() # This refreshes the drawing on the # canvas.
chart_1.after(cycle_period) # This makes execution pause for # 100 milliseconds.
chart_1.delete(ALL) # This erases *almost* everything on # the canvas.
# Does not delete the text from # inside a function.
bx_stay = base_x
by_stay = base_y
for j in range(0,11): # Number of steps to be taken - arbitrary.
astep_x = 60*j
bstep_x = astep_x + 30
cstep_x = 60*j + 15
aa = len(step_x) -1
for k in range(0,len(hip_x)-1):
# Motion of the hips in a stride of each foot.
cx0 = base_x + cstep_x + hip_x[k]
cy0 = base_y - hip_h - hip_y[k]
cx1 = base_x + cstep_x + hip_x[k+1]
cy1 = base_y - hip_h - hip_y[k+1]
chart_1.create_line(cx0, cy0 ,cx1 ,cy1)
chart_1.create_oval(cx1-10 ,cy1-10 ,cx1+10 ,cy1+10, \ fill="orange")
if k &gt;= 0 and k &lt;= len(step_x)-2:
# Trajectory of the right foot.
ax0 = base_x + astep_x + step_x[k]
ax1 = base_x + astep_x + step_x[k+1]
ay0 = base_y - step_y[k]
ay1 = base_y - step_y[k+1]
ax_stay = ax1
ay_stay = ay1
if k &gt;= len(step_x)-1 and k &lt;= 2*len(step_x)-2:
# Trajectory of the left foot.
bx0 = base_x + bstep_x + step_x[k-aa]
bx1 = base_x + bstep_x + step_x[k-aa+1]
by0 = base_y - step_y[k-aa]
by1 = base_y - step_y[k-aa+1]
bx_stay = bx1
by_stay = by1
aknee_xy = kneePosition(ax_stay, ay_stay, cx1, cy1, thy)
chart_1.create_line(ax_stay, ay_stay ,aknee_xy[0], \ aknee_xy[1], width = 3, fill="orange")
chart_1.create_line(cx1, cy1 ,aknee_xy[0], aknee_xy[1], \ width = 3, fill="orange")
chart_1.create_oval(ax_stay-5 ,ay1-5 ,ax1+5 ,ay1+5, \ fill="green")
chart_1.create_oval(bx_stay-5 ,by_stay-5 ,bx_stay+5 , \ by_stay+5, fill="blue")
bknee_xy = kneePosition(bx_stay, by_stay, cx1, cy1, thy)
chart_1.create_line(bx_stay, by_stay ,bknee_xy[0], \ bknee_xy[1], width = 3, fill="pink")
chart_1.create_line(cx1, cy1 ,bknee_xy[0], bknee_xy[1], \ width = 3, fill="pink")
animdelay()
root.mainloop()
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec06"/>How it works...</h2></div></div></div><p>Without getting bogged down in detail, the strategy in the program consists of defining the motion of a foot while walking one stride. This motion is defined by eight relative positions given by the two lists<code class="literal"> step_x (horizontal)</code> and<code class="literal"> step_y (vertical)</code>. The motion of the hips is given by a separate pair of x- and y-positions<code class="literal"> hip_x</code> and<code class="literal"> hip_y</code>.<a id="id188" class="indexterm"/>
</p><p>Trigonometry is used to work out the position of the knee on the assumption that the thigh and lower leg are the same length. The calculation is based on the sine rule taught in high school. Yes, we do learn useful things at school!<a id="id189" class="indexterm"/>
</p><p>The<em> time-animation regulation</em> instructions are assembled together as a function<code class="literal"> animdelay()</code>.<a id="id190" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec07"/>There's more...</h2></div></div></div><p>In Python<code class="literal"> math</code> module, two arc-tangent functions are available for calculating angles given the lengths of two adjacent sides.<code class="literal"> atan2(y,x)</code> is the best because it takes care of the crazy things a tangent does on its way around a circle - tangent flicks from minus infinity to plus infinity as it passes through 90 degrees and any multiples thereof.<a id="id191" class="indexterm"/>
</p><p>A mathematical knee is quite happy to bend forward or backward in satisfying its equations. We make the sign of the angle negative for a backward-bending bird knee and positive for a forward bending mammalian knee.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec01"/>More Info Section 1</h3></div></div></div><p>This animated walking hips-and-legs is used in the recipes that follow this to make a bird walk in the desert, a diplomat in palace grounds, and a spider in a forest.</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec03"/>Bird with shoes walking in the Karroo</h1></div></div></div><p>We now coordinate the movement of four<code class="literal"> GIF</code> images and the striding legs to make an Apteryx (a flightless bird like the kiwi) that walks.<a id="id192" class="indexterm"/>
</p><div><img src="img/3845_07_02.jpg" height="117" alt="Bird with shoes walking in the Karroo"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec08"/>Getting ready</h2></div></div></div><p>We need the following<code class="literal"> GIF</code> images:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A background picture of a suitable landscape</li><li class="listitem" style="list-style-type: disc">A bird body without legs</li><li class="listitem" style="list-style-type: disc">A pair of garish-colored shoes to make the viewer smile</li><li class="listitem" style="list-style-type: disc">The walking avian legs of the previous recipe</li></ul></div><p>The images used are<code class="literal"> karroo.gif, apteryx1.gif</code>, and<code class="literal"> shoe1.gif</code>. Note that the images of the bird and the shoe have transparent backgrounds which means there is no rectangular background to be seen surrounding the bird or the shoe. In the recipe following this one, we will see the simplest way to achieve the necessary transparency.<a id="id193" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec09"/>How to do it...</h2></div></div></div><p>Execute the program shown in the usual way.</p><div><pre class="programlisting"># walking_birdy_1.py
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
import math
import time
root = Tk()
root.title("A Walking birdy gif and shoes images")
cw = 800 # canvas width
ch = 200 # canvas height
#GRAVITY = 4
chart_1 = Canvas(root, width=cw, height=ch, background="white")
chart_1.grid(row=0, column=0)
cycle_period = 80 # time between new positions of the bird # (milliseconds).
im_backdrop = "/constr/pics1/karoo.gif"
im_bird = "/constr/pics1/apteryx1.gif"
im_shoe = "/constr/pics1/shoe1.gif"
birdy =PhotoImage(file= im_bird)
shoey =PhotoImage(file= im_shoe)
backdrop = PhotoImage(file= im_backdrop)
chart_1.create_image(0 ,0 ,anchor=NW, image=backdrop)
base_x = 20
base_y = 190
hip_h = 70
thy = 60
#==========================================
# Hip positions: Nhip = 2 x Nstep, the number of steps per foot per # stride.
hip_x = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 60, 60] #15
hip_y = [0, 8, 12, 16, 12, 8, 0, 0, 0, 8, 12, 16, 12, 8, 0] #15
step_x = [0, 10, 20, 30, 40, 50, 60, 60] # 8 = Nhip
step_y = [0, 35, 45, 50, 43, 32, 10, 0]
#=============================================
# Given a line joining two points xy0 and xy1, the base of an # isosceles triangle,
# as well as the length of one side, "thy" this returns the # coordinates of
# the apex joining the equal-length sides.
def kneePosition(x0, y0, x1, y1, thy):
theta_1 = math.atan2(-(y1 - y0), (x1 - x0))
L1 = math.sqrt( (y1 - y0)**2 + (x1 - x0)**2)
alpha = math.atan2(hip_h,L1)
theta_2 = -(theta_1 - alpha)
x_knee = x0 + thy * math.cos(theta_2)
y_knee = y0 + thy * math.sin(theta_2)
return x_knee, y_knee
def animdelay():
Apteryx imageanimatingchart_1.update() # Refresh the drawing on the canvas.
chart_1.after(cycle_period) # Pause execution pause for 80 # milliseconds.
chart_1.delete("walking") # Erases everything on the canvas.
bx_stay = base_x
by_stay = base_y
for j in range(0,13): # Number of steps to be taken - arbitrary.
astep_x = 60*j
bstep_x = astep_x + 30
cstep_x = 60*j + 15
aa = len(step_x) -1
for k in range(0,len(hip_x)-1):
# Motion of the hips in a stride of each foot.
cx0 = base_x + cstep_x + hip_x[k]
cy0 = base_y - hip_h - hip_y[k]
cx1 = base_x + cstep_x + hip_x[k+1]
cy1 = base_y - hip_h - hip_y[k+1]
#chart_1.create_image(cx1-55 ,cy1+20 ,anchor=SW, \ image=birdy, tag="walking")
if k &gt;= 0 and k &lt;= len(step_x)-2:
# Trajectory of the right foot.
ax0 = base_x + astep_x + step_x[k]
ax1 = base_x + astep_x + step_x[k+1]
ay0 = base_y - 10 - step_y[k]
ay1 = base_y - 10 -step_y[k+1]
ax_stay = ax1
ay_stay = ay1
if k &gt;= len(step_x)-1 and k &lt;= 2*len(step_x)-2:
# Trajectory of the left foot.
bx0 = base_x + bstep_x + step_x[k-aa]
bx1 = base_x + bstep_x + step_x[k-aa+1]
by0 = base_y - 10 - step_y[k-aa]
by1 = base_y - 10 - step_y[k-aa+1]
bx_stay = bx1
by_stay = by1
chart_1.create_image(ax_stay-5 ,ay_stay + 10 ,anchor=SW, \ image=shoey, tag="walking")
chart_1.create_image(bx_stay-5 ,by_stay + 10 ,anchor=SW, \ image=shoey, tag="walking")
aknee_xy = kneePosition(ax_stay, ay_stay, cx1, cy1, thy)
chart_1.create_line(ax_stay, ay_stay-15 ,aknee_xy[0], \ aknee_xy[1], width = 5, fill="orange", tag="walking")
chart_1.create_line(cx1, cy1 ,aknee_xy[0], aknee_xy[1], \ width = 5, fill="orange", tag="walking")
Apteryx imageanimatingbknee_xy = kneePosition(bx_stay, by_stay, cx1, cy1, thy)
chart_1.create_line(bx_stay, by_stay-15 ,bknee_xy[0], \ bknee_xy[1], width = 5, fill="pink", tag="walking")
chart_1.create_line(cx1, cy1 ,bknee_xy[0], bknee_xy[1], \ width = 5, fill="pink", tag="walking")
chart_1.create_image(cx1-55 ,cy1+20 ,anchor=SW, image=birdy, \ tag="walking")
animdelay()
root.mainloop()
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec10"/>How it works...</h2></div></div></div><p>The same remarks concerning the trigonometry made in the previous recipe apply here. What we see here now is the ease with which vector objects and raster images can be combined once suitable<code class="literal"> GIF</code> images have been prepared.<a id="id196" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec11"/>There's more...</h2></div></div></div><p>For teachers and their students who want to make lessons on a computer, these techniques offer all kinds of possibilities like history tours and re-enactments, geography tours, and, science experiments. Get the students to do projects telling stories. Animated year books?</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec04"/>Making GIF images with transparent backgrounds using GIMP</h1></div></div></div><p>We make an image with an opaque background into one with a transparent background using the free and open-source GIMP image editor.<a id="id197" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec12"/>Getting ready</h2></div></div></div><p>We can get<strong> GIMP</strong> (<strong>GNU Image Manipulation Program</strong>) at<a class="ulink" href="http://www.gimp.org/"> http://www.gimp.org/</a>. There are versions that can be installed on Windows and Linux. GIMP is an excellent package and well-worth the effort of learning to use. It can be frustrating when you are not used to it so this particular recipe is devoted to describing the steps that will transform a<code class="literal"> .png</code> image with an opaque background into a<code class="literal"> .gif</code> image with a transparent background.<a id="id198" class="indexterm"/>
</p><p>In Windows, you simply go to the website and click the<strong> Download</strong> button and it will install and can be used immediately. With Linux, it is often already installed. With any Debian-based Linux<code class="literal"> sudo apt-get install gimp</code> should get it installed and you are ready to go.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec13"/>How to do it...</h2></div></div></div><p>This recipe does not involve running Python code. Instead, it is a list of actions to perform with your mouse on the Gimp GUI. In the following instructions, click<strong> Select</strong> |<strong> Invert</strong> is the short-form for "Left-click on, select, then left-click on Invert".</p><div><ol class="orderedlist"><li class="listitem">Open GIMP and open the file<code class="literal"> apteryx1.png</code>. This is a cartoon bird that has been drawn.<div><img src="img/3845_07_03.jpg" height="134" alt="How to do it..."/></div></li><li class="listitem">Click<strong> Windows</strong> |<strong> Dockable dialogs</strong> |<strong> Layers</strong>. This will open up a display panel that shows all the layers making up the image we are working on. Watching what is going on with the layers is the secret to using GIMP.</li><li class="listitem">Click<strong> Select</strong> |<strong> By color</strong>, and then place the cursor arrow anywhere on the black portion of the image and click. You will see a shimmering dotted line around the outline of the bird. What we have done is to select for alteration only the black portions of the picture.<a id="id199" class="indexterm"/><div><img src="img/3845_07_04.jpg" width="165" alt="How to do it..."/></div></li><li class="listitem">Click<strong> Select</strong> |<strong> Invert</strong>. What this does is it changes the selection to everything except the black portion.</li><li class="listitem">Click<strong> Edit</strong> |<strong> Copy</strong>. This picks up a copy of the selected portion (everything not black) and places it onto an invisible clipboard.</li><li class="listitem">Click<strong> Edit</strong> |<strong> Paste</strong>. This takes a copy from the clipboard and potentially pastes it onto our existing image. But until you have completed the next step, the pasted image is held in a kind of no-man's land.</li><li class="listitem">Click<strong> Layer</strong> |<strong> New</strong>. This firmly places the pasted portion of the image onto its own separate layer. The layers are like sheets of clear glass with portions of a composite picture on it. When you work on them and change one layer, the others are unaltered.<a id="id200" class="indexterm"/><div><img src="img/3845_07_05.jpg" width="133" alt="How to do it..."/></div></li><li class="listitem">Right-click the<strong> Backdrop layer</strong> as shown, then click<strong> Delete Layer</strong>. This discards the Backdrop layer that consists of the original image. You will see there is only one layer left. It contains the bird image placed on a transparent background.<div><img src="img/3845_07_06.jpg" width="129" alt="How to do it..."/></div></li><li class="listitem">Click<strong> File</strong> |<strong> Save as</strong>. In the save window, type in<code class="literal"> apteryx1.gif</code> for the file name.<div><img src="img/3845_07_07.jpg" height="119" alt="How to do it..."/></div></li><li class="listitem">Close GIMP. You will find your new<code class="literal"> GIF</code> image with a transparent background in whatever folder you sent it to. In Linux systems, transparent areas are shown as a gray checker-board pattern.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec14"/>How it works...</h2></div></div></div><p>All images used in this chapter that have areas which are transparent were prepared using GIMP this way. There are other ways to achieve this but this is possibly the most readily available one. The animations in this chapter consist of a smaller, partially transparent image moving across a larger opaque image.<a id="id201" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec05"/>Diplomat walking at the palace</h1></div></div></div><p>We now animate a dignified man using the same legs as before, appropriately colored. For the human style walk, we need to select the correct mammalian knee-bend angle option chosen in the code prior to interpreting.<a id="id202" class="indexterm"/>
</p><div><img src="img/3845_07_08.jpg" height="135" alt="Diplomat walking at the palace"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec15"/>Getting ready</h2></div></div></div><p>We need the following<code class="literal"> GIF</code> images:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A background picture of a suitable landscape</li><li class="listitem" style="list-style-type: disc">A human body without legs</li><li class="listitem" style="list-style-type: disc">A pair of sober shoes for dignity</li><li class="listitem" style="list-style-type: disc">The walking mammal legs</li></ul></div><p>The images used are<code class="literal"> palace.gif, ambassador.gif</code>, and<code class="literal"> ambassador_shoe1.gif</code>. As before, the images of the man and the shoe have transparent backgrounds.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec16"/>How to do it...</h2></div></div></div><p>Execute the program shown as before.<a id="id203" class="indexterm"/>
</p><div><pre class="programlisting"># walking_toff_1.py
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
import math
import time
root = Tk()
root.title("A Walking Toff in Natural Habitat - gif images")
cw = 800 # canvas width
ch = 200 # canvas height
#GRAVITY = 4
chart_1 = Canvas(root, width=cw, height=ch, background="white")
chart_1.grid(row=0, column=0)
cycle_period = 120 # time between new positions of the man # (milliseconds).
im_backdrop = "/constr/pics1/toff_bg.gif"
im_toff = "/constr/pics1/ambassador.gif"
im_shoe = "/constr/pics1/toff_shoe.gif"
toff =PhotoImage(file= im_toff)
shoey =PhotoImage(file= im_shoe)
backdrop = PhotoImage(file= im_backdrop)
chart_1.create_image(0 ,0 ,anchor=NW, image=backdrop)
base_x = 20
base_y = 190
hip_h = 60
thy = 25
#============================================
# Hip positions: Nhip = 2 x Nstep, the number of steps per foot per # stride.
hip_x = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 60, 60] #15
hip_y = [0, 4, 6, 8, 6, 4, 0, 0, 0, 4, 6, 8, 6, 4, 0] #15
step_x = [0, 10, 20, 30, 40, 50, 60, 60] # 8 = Nhip
step_y = [0, 15, 25, 30, 25, 22, 10, 0]
#============================================
# Given a line joining two points xy0 and xy1, the base of an # isosceles triangle,
# as well as the length of one side, "thy" this returns the # coordinates of
# the apex joining the equal-length sides.
def kneePosition(x0, y0, x1, y1, thy):
theta_1 = math.atan2((y1 - y0), (x1 - x0))
L1 = math.sqrt( (y1 - y0)**2 + (x1 - x0)**2)
if L1/2 &lt; thy:
alpha = math.acos(L1/(2*thy))
else:
alpha = 0.0
theta_2 = alpha + theta_1
x_knee = x0 + thy * math.cos(theta_2)
y_knee = y0 + thy * math.sin(theta_2)
return x_knee, y_knee
def animdelay():
diplomat walking at palace recipechart_1.update() # Refresh the drawing on the canvas.
chart_1.after(cycle_period) # Pause execution for 120 # milliseconds.
chart_1.delete("walking") # Erases everything on the canvas.
bx_stay = base_x
by_stay = base_y
for j in range(0,13): # Number of steps to be taken - # arbitrary.
astep_x = 60*j
bstep_x = astep_x + 30
cstep_x = 60*j + 15
aa = len(step_x) -1
for k in range(0,len(hip_x)-1):
# Motion of the hips in a stride of each foot.
cx0 = base_x + cstep_x + hip_x[k]
cy0 = base_y - hip_h - hip_y[k]
cx1 = base_x + cstep_x + hip_x[k+1]
cy1 = base_y - hip_h - hip_y[k+1]
if k &gt;= 0 and k &lt;= len(step_x)-2:
# Trajectory of the right foot.
ax0 = base_x + astep_x + step_x[k]
ax1 = base_x + astep_x + step_x[k+1]
ay0 = base_y - 10 - step_y[k]
ay1 = base_y - 10 -step_y[k+1]
ax_stay = ax1
ay_stay = ay1
if k &gt;= len(step_x)-1 and k &lt;= 2*len(step_x)-2:
# Trajectory of the left foot.
bx0 = base_x + bstep_x + step_x[k-aa]
bx1 = base_x + bstep_x + step_x[k-aa+1]
by0 = base_y - 10 - step_y[k-aa]
by1 = base_y - 10 - step_y[k-aa+1]
bx_stay = bx1
by_stay = by1
# The shoes
chart_1.create_image(ax_stay-5 ,ay_stay + 10 ,anchor=SW, \ image=shoey, tag="walking")
chart_1.create_image(bx_stay-5 ,by_stay + 10 ,anchor=SW, \ image=shoey, tag="walking")
diplomat walking at palace recipe# Work out knee positions
aknee_xy = kneePosition(ax_stay, ay_stay, cx1, cy1, thy)
bknee_xy = kneePosition(bx_stay, by_stay, cx1, cy1, thy)
# Right calf.
chart_1.create_line(ax_stay, ay_stay-5 ,aknee_xy[0], \ aknee_xy[1], width = 5, fill="black", tag="walking")
# Right thigh.
chart_1.create_line(cx1, cy1 ,aknee_xy[0], aknee_xy[1], \ width = 5, fill="black", tag="walking")
# Left calf.
#bknee_xy = kneePosition(bx_stay, by_stay, cx1, cy1, thy)
chart_1.create_line(bx_stay, by_stay-5 ,bknee_xy[0], \ bknee_xy[1], width = 5, fill="black", tag="walking")
# Left thigh.
chart_1.create_line(cx1, cy1 ,bknee_xy[0], bknee_xy[1], \ width = 5, fill="black", tag="walking")
# Torso
chart_1.create_image(cx1-20 ,cy1+30 ,anchor=SW, \ image=toff, tag="walking")
animdelay() # Animation
root.mainloop()
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec17"/>How it works...</h2></div></div></div><p>The great possibilities offered through the use of image combining using the transparent channel in<code class="literal"> GIF</code> images allows us to create studio-quality cartoon animations. The same remarks concerning the trigonometry made in the previous recipe apply here.<a id="id206" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec06"/>Spider in the forest</h1></div></div></div><p>We now combine both mammal and bird leg motions to create a sinister-looking spider. We also introduce a moving background for the first time. No transparent images are used here as the entire spider is made of animated vector lines and ovals.<a id="id207" class="indexterm"/>
</p><div><img src="img/3845_07_09.jpg" height="93" alt="Spider in the forest"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec18"/>Getting ready</h2></div></div></div><p>Here, we need one long narrow strip image that is substantially wider than the Tkinter canvas provided. This not a problem and aids us in creating the illusion of a spider walking through an endless forest.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec19"/>How to do it...</h2></div></div></div><p>Execute the program shown as before.</p><div><pre class="programlisting"># walker_spider_1.py
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
import math
import time
root = Tk()
root.title("Mr Incy Wincy")
cw = 500 # canvas width
ch = 100 # canvas height
chart_1 = Canvas(root, width=cw, height=ch, background="white")
chart_1.grid(row=0, column=0)
cycle_period = 100 # time between new positions of thespider # (milliseconds).
base_x = 20
base_y = 100
avian = 1
ax = [ base_x, base_x+20, base_x+60 ]
ay = [ base_y, base_y, base_y ]
bx = [ base_x+90, base_x+130, base_x+170]
by = [ base_y, base_y, base_y ]
cx1 = base_x + 80
cy1 = base_y - 20
thy = 50
#=============================================
posn_x = 0
posn_y = 00
spider_backg = PhotoImage(file = "/constr/pics1/jungle_strip_1.gif")
mammal and bird leg motionscombining#===========================================
foot_lift = [10,10,5,-5,-10,-10] # 3 legs per side, each foot in # sequence = 18 moves
foot_stay = [ 0, 0,0, 0, 0, 0]
#========================================
# Given a line joining two points xy0 and xy1, the base of an # isosceles triangle,
# as well as the length of one side, "thy" this returns the # coordinates of
# the apex joining the equal-length sides - the position of the knee.
def kneePosition(x0, y0, x1, y1, thy, avian):
theta_1 = math.atan2((y1 - y0), (x1 - x0))
L1 = math.sqrt( (y1 - y0)**2 + (x1 - x0)**2)
if L1/2 &lt; thy:
# The sign of alpha determines which way the knees bend.
if avian == 1:
alpha = -math.acos(L1/(2*thy)) # Avian
else:
alpha = math.acos(L1/(2*thy)) # Mammalian
else:
alpha = 0.0
theta_2 = alpha + theta_1
x_knee = x0 + thy * math.cos(theta_2)
y_knee = y0 + thy * math.sin(theta_2)
return x_knee, y_knee
def animdelay():
chart_1.update() # This refreshes the drawing on the # canvas.
chart_1.after(cycle_period) # This makes execution pause for 100 # milliseconds.
chart_1.delete(ALL) # This erases *almost* everything on # the canvas.
for j in range(0,11): # Number of steps to be taken - arbitrary.
mammal and bird leg motionscombiningposn_x -= 1
chart_1.create_image(posn_x,posn_y,anchor=NW, image=spider_backg)
for k in range(0,len(foot_lift)*3):
posn_x -= 1
chart_1.create_image(posn_x,posn_y,anchor=NW, \ image=spider_backg)
#cx1 += 3.5
cx1 += 2.6
# Phase 1
if k &gt;= 0 and k &lt;= 5:
ay[0] = base_y - 10 - foot_lift[k]
ax[0] += 8
by[0] = base_y - 10 - foot_lift[k]
bx[0] += 8
# Phase 2
if k &gt; 5 and k &lt;= 11:
ay[1] = base_y - 10 - foot_lift[k-6]
ax[1] += 8
by[1] = base_y - 10 - foot_lift[k-6]
bx[1] += 8
# Phase 3
if k &gt; 11 and k &lt;= 17:
ay[2] = base_y - 10 - foot_lift[k-12]
ax[2] += 8
by[2] = base_y - 10 - foot_lift[k-12]
bx[2] += 8
for i in range(0,3):
aknee_xy = kneePosition(ax[i], ay[i], cx1, cy1, thy, 1) # Mammal knee
bknee_xy = kneePosition(bx[i], by[i], cx1, cy1, thy, 0) # Bird knee
chart_1.create_line(ax[i], ay[i] ,aknee_xy[0], \ aknee_xy[1], width = 3)
chart_1.create_line(cx1, cy1 ,aknee_xy[0], \ aknee_xy[1], width = 3)
chart_1.create_line(bx[i], by[i] ,bknee_xy[0], \ bknee_xy[1], width = 3)
chart_1.create_line(cx1, cy1 ,bknee_xy[0], \ bknee_xy[1], width = 3)
chart_1.create_oval(cx1-15 ,cy1-10 ,cx1+15 , \ cy1+10, fill="black")
animdelay()
root.mainloop()
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec20"/>How it works...</h2></div></div></div><p>The essential art in making the spider walk acceptably is to adjust the length of stride, height of body above the ground, and thigh (leg segment) length to be consistent with each other. With slightly wrong adjustments, the legs roll over or appear made of very stretchy material.<a id="id210" class="indexterm"/>
</p><p>There is also the issue of how the spider's leg movements should be synchronized. In this recipe, we have opted to make the limbs move in paired sequences.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec21"/>There's more...</h2></div></div></div><p>Real spiders have eight legs, not six as in this example. You could try to add the extra pair of legs as a challenge. Real spiders also have an extra pair of segments in each leg. Getting the leg trigonometry to work is an excellent challenge for the mathematically talented ones.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec07"/>Moving band of images</h1></div></div></div><p>We make a moving band of images like a slideshow. This differs from the typical slideshow by showing the images as a continuously moving strip with the images placed end to end.<a id="id211" class="indexterm"/>
</p><div><img src="img/3845_07_10.jpg" height="127" alt="Moving band of images"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec22"/>Getting ready</h2></div></div></div><p>We need a set of four images, all of the same size. If they were not the same size, the program would still work but would not look well designed. The images provided for this code are:<code class="literal"> brass_vase.gif, red_vase.gif, blue_vase.gif</code>, and<code class="literal"> glass_vase.gif</code> and are 200 pixels high and 100 wide.<a id="id212" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec23"/>How to do it...</h2></div></div></div><p>Execute the program shown as before.</p><div><pre class="programlisting"># passing_show_1.py
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
import math
import time
root = Tk()
root.title("Vase Show")
cw = 400 # canvas width
ch = 200 # canvas height
chart_1 = Canvas(root, width=cw, height=ch, background="white")
chart_1.grid(row=0, column=0)
cycle_period = 100 # time between new positions of the ball (milliseconds).
#=======================================================================
posn_x1 = 0
posn_x2 = 100
posn_x3 = 200
posn_x4 = 300
posn_y = 00
im_brass = PhotoImage(file = "/constr/pics1/brass_vase.gif")
im_red = PhotoImage(file = "/constr/pics1/red_vase.gif")
im_blue = PhotoImage(file = "/constr/pics1/blue_vase.gif")
im_glass = PhotoImage(file = "/constr/pics1/glass_vase.gif")
#=======================================================================
def animdelay():
chart_1.update() # This refreshes the drawing on the canvas.
chart_1.after(cycle_period) # This makes execution pause for 100 milliseconds.
chart_1.delete(ALL) # This erases *almost* everything on the canvas.
for j in range(0,400): # Number of steps to be taken - arbitrary.
posn_x1 -= 1
posn_x2 -= 1
posn_x3 -= 1
posn_x4 -= 1
chart_1.create_image(posn_x1,posn_y,anchor=NW, image=im_brass)
chart_1.create_image(posn_x2,posn_y,anchor=NW, image=im_red)
chart_1.create_image(posn_x3,posn_y,anchor=NW, image=im_blue)
chart_1.create_image(posn_x4,posn_y,anchor=NW, image=im_glass)
animdelay()
root.mainloop()
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec24"/>How it works...</h2></div></div></div><p>Each image has its own x position coordinate posn_x1, posn_x2 etc. A 'for' loop adjusts these positions by one pixel each time the loop is executed, causing the images to progressively shift to the left.<a id="id213" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec08"/>Continuous band of images</h1></div></div></div><p>This recipe extends the position-adjusting mechanism used in the previous example to sustain a continuous strip of images.<a id="id214" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec25"/>Getting ready</h2></div></div></div><p>We use the same set of four images that were used in the previous recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec26"/>How to do it...</h2></div></div></div><p>Execute the program shown in exactly the same way as before.<a id="id215" class="indexterm"/>
</p><div><pre class="programlisting"># endless_passing_show_1.py
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
import math
import time
root = Tk()
root.title("Vase Show")
cw = 100 # canvas width
ch = 200 # canvas height
chart_1 = Canvas(root, width=cw, height=ch, background="black")
chart_1.grid(row=0, column=0)
cycle_period = 100 # time between new positions of the images milliseconds).
#==============================================
posn_x1 = 0
posn_x2 = 100
posn_x3 = 200
posn_x4 = 300
posn_y = 00
im_brass = PhotoImage(file = "/constr/pics1/brass_vase.gif")
im_red = PhotoImage(file = "/constr/pics1/red_vase.gif")
im_blue = PhotoImage(file = "/constr/pics1/blue_vase.gif")
im_glass = PhotoImage(file = "/constr/pics1/glass_vase.gif")
#=============================================
def animdelay():
chart_1.update() # This refreshes the drawing on the canvas.
chart_1.after(cycle_period) # This makes execution pause for 100 milliseconds.
chart_1.delete(ALL) # This erases *almost* everything on the canvas.
for j in range(0,600): # Number of steps to be taken - arbitrary.
posn_x1 -= 1
posn_x2 -= 1
posn_x3 -= 1
posn_x4 -= 1
chart_1.create_image(posn_x1,posn_y,anchor=NW, image=im_brass)
chart_1.create_image(posn_x2,posn_y,anchor=NW, image=im_red)
chart_1.create_image(posn_x3,posn_y,anchor=NW, image=im_blue)
chart_1.create_image(posn_x4,posn_y,anchor=NW, image=im_glass)
# The numerical parameters below could be turned into
# a 'for' loop and allow the loop to be compact and interminable.
if j == 100:
posn_x1 = 300
if j == 200:
posn_x2 = 300
if j == 400:
posn_x3 = 300
if j == 400:
posn_x4 = 300
animdelay()
root.mainloop()
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec27"/>How it works...</h2></div></div></div><p>The trick with this program is to reset the x position coordinates,<code class="literal"> posn_1</code>, and so on, which control the position of each image on the canvas after the image has exited the canvas on the left. The position coordinates get reset to a position 200 pixels off to the right of the canvas.<a id="id216" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec09"/>Endless background</h1></div></div></div><p>The next thing to achieve is to create what appears to be one practically infinitely wide panorama. We extend the technique used in the previous example and make a background image that appears to be endless.<a id="id217" class="indexterm"/>
</p><div><img src="img/3845_07_11.jpg" width="235" alt="Endless background"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec28"/>Getting ready</h2></div></div></div><p>We have provided a single image that has been doctored so that the right-hand edge fits exactly onto the left-hand edge to create an endless and continuous image if they are placed side by side. The GIMP image manipulation program was used to do this editing. In a very condensed explanation, we do the following:</p><div><ol class="orderedlist"><li class="listitem">We copy a portion of the image that does not have too much detail vertically where we make the cut.</li><li class="listitem">This is then pasted onto one end so that there is substantial overlap of the two images.</li><li class="listitem">Then the top layer, containing the copy-and-pasted portion, has the eraser tool with a fuzzy edge applied so that we cannot see the transition from one image to the next.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec29"/>How to do it...</h2></div></div></div><p>Execute the following code.<a id="id218" class="indexterm"/>
</p><div><pre class="programlisting"># passing_cloudscape_1.py
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
import time
root = Tk()
root.title("Freedom Flight Cloudscape")
cw = 400 # canvas width
ch = 239 # canvas height
chart_1 = Canvas(root, width=cw, height=ch, background="black")
chart_1.grid(row=0, column=0)
cycle_period = 50 # time between new positions of the background # (milliseconds).
#=============================================
posn_x1 = 0
posn_x2 = 574
posn_plane_x = 60
posn_plane_y = 60
posn_y = 00
# Panorama image size = 574 x 239
im_one = PhotoImage(file = "/constr/pics1/continuous_clouds \ _panorama.gif")
im_two = PhotoImage(file = "/constr/pics1/continuous_clouds \ _panorama.gif")
im_plane = PhotoImage(file = "/constr/pics1/yellow_airplane_2.gif")
#===========================================
def animdelay():
chart_1.update() # This refreshes the drawing on the # canvas.
chart_1.after(cycle_period) # This makes execution pause for 50 # milliseconds.
chart_1.delete(ALL) # This erases *almost* everything on # the canvas.
num_cycles = 10 # Number of total cycles of the # loop.
k = 0
for j in range(0,num_cycles*1148): # Number of steps to be taken # arbitrary.
posn_x1 -= 1
posn_x2 -= 1
k += 1
chart_1.create_image(posn_x1,posn_y,anchor=NW, image=im_one)
chart_1.create_image(posn_x2,posn_y,anchor=NW, image=im_two)
chart_1.create_image(posn_plane_x,posn_plane_y,anchor=NW, \ image=im_plane)
if k == 574:
posn_x1 = 574
if k == 1148:
posn_x2 = 574
k = 0
posn_x1 = 0
animdelay()
root.mainloop()
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec30"/>How it works...</h2></div></div></div><p>We use the same x coordinate position adjustment technique as we did in the previous recipe. This time we choose the position for readjustment to be a multiple of 574 which is the width, in pixels, of the cloudscape image. We also use the image of an airplane, on a transparent background. The airplane is kept stationary.<a id="id219" class="indexterm"/>
</p></div></div></div>
</body></html>