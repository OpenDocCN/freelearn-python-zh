- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Network Configurations and Definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One important point in network automation is how the configuration is organized
    and how we can automate our network in a scalable way. In this chapter, we are
    going to explore how to work with a network configuration and how to define it
    for effective use with network automation. We want to build scalable and future-proof
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we care about configuration and network definition? Why is it important
    which file to use? How can we create a lifelong definition? How can we use this
    to help network automation? Let’s explore answers to these questions in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Describing the configuration problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helping network automation using definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating network definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring different file types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code described in this chapter is stored in the GitHub repository
    at [https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter04](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Describing the configuration problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several production networks out there have their configuration applied to network
    devices without any additional external definition. Some of them have network
    diagrams describing the network, but the majority have outdated or incomplete
    diagrams. Therefore, in most cases, you might need to read running device configurations
    to understand the details of the network operation.
  prefs: []
  type: TYPE_NORMAL
- en: In some network providers, diagrams are used for an initial understanding of
    the network or as an overall overview. Once the engineers have enough confidence
    in their network, the diagrams are just ignored or not used anymore. Some would
    update their diagrams, but for most engineers, this task is not a priority and
    usually is left behind.
  prefs: []
  type: TYPE_NORMAL
- en: It is also common for some engineers to apply configuration fixes directly into
    production devices to solve catastrophic or urgent failures. In other cases, additional
    configuration is applied temporarily for troubleshooting, but never removed. These
    configuration changes are forgotten in some cases that they were applied and the
    network runs with a configuration difference that is not perceived until a software
    update is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss the issues further in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Source of truth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Source of truth** is a term used in computer networks to describe where the
    definition is and what all other systems have to rely on when consulting or using
    the information to create further definitions. The source of truth can be either
    a file, a router configuration, a database, a memory space, or a network diagram.'
  prefs: []
  type: TYPE_NORMAL
- en: We want to have the source of truth as steadily defined as possible; it should
    not change over a short period of time and should be used as a reference for any
    other definition.
  prefs: []
  type: TYPE_NORMAL
- en: The majority of network engineers rely on the router configuration as the source
    of truth, because routers are frequently updated and have the correct definitions
    to run the network; however, this does not help our network automation.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we want the source of the truth to be in a database or files stored
    in a secure and future-proof environment that can be ready to be read by any system
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The startup configuration and the running configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A network device has two configuration states, the **running configuration**
    and the **startup configuration**. The running configuration is the current configuration
    on the device’s memory that is being used to operate at that present moment. The
    startup configuration is used to boot the device from *off* to *on*. The difference
    is that one is volatile and will be deleted once the device is turned off or loses
    power supply, and the other is permanent and will always exist independent of
    whether it has a power supply or not.
  prefs: []
  type: TYPE_NORMAL
- en: The startup configuration is normally stored in a non-volatile memory store
    such as SSD, a flash drive, or a hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: For our automation, we want to have the same running configuration as the startup
    configuration. When they differ, it might cause automation issues if not well
    documented.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration states and history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good network automation design should aim to have multiple configuration states
    and history, which will help to determine how the network is operating now, how
    it should operate in the future, and how it operated in the past.
  prefs: []
  type: TYPE_NORMAL
- en: 'For deployment and automation, it is very useful to separate the configuration
    into at least four stages: **Desired**, **Approved**, **Applied**, and **Running**,
    as shown in *Figure 4.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 4.1 – Configuration stages and control layer](img/B18165_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Configuration stages and control layer
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss each of these in the following sub sections.
  prefs: []
  type: TYPE_NORMAL
- en: Desired-configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **desired-configuration** is used to document the configuration that should
    be applied in the near future. It is used to check for inconsistencies and to
    be applied in a test network (or a network simulation) to evaluate future deployments,
    possible syntax errors, and other functional problems.
  prefs: []
  type: TYPE_NORMAL
- en: Modern networks use the desired-configuration to feed a configuration pipeline
    that will perform a series of tests, including simulation to validate and anticipate
    errors. It is also used to test the deployment sequence, and evaluate which devices
    can be deployed in parallel or which ones need to wait until some have finished
    being deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Approved-configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **approved-configuration** is the configuration that has passed all approval
    stages in the configuration pipeline, whether they are automated approval stages,
    such as syntax checks, or manual stages, done by a human approval.
  prefs: []
  type: TYPE_NORMAL
- en: To enhance confidence, some configuration pipelines will apply the desired-configuration
    in a network simulation for further function testing, and if everything passes,
    the configuration pipeline will approve the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: From all configuration stages, the approval-configuration is the one that takes
    more time to finish as large networks have thousands of routers, and some require
    sequential functional testing instead of parallel testing. After everything is
    completed, the configurations are ready to be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Applied-configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **applied-configuration** is the configuration saved on the device’s non-volatile
    configuration or the startup configuration. At the end of this stage, we confidently
    know that the configuration has been saved in all routers.
  prefs: []
  type: TYPE_NORMAL
- en: This stage also can take a long time because deployment cannot necessarily be
    performed in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Running-configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This stage is used as a safeguard for future deployments and approval processes.
    The **running-configuration** has to be the same as the applied configuration;
    however, it might not be the same configuration, especially after a catastrophic
    event that required configuration intervention.
  prefs: []
  type: TYPE_NORMAL
- en: The running-configuration is constantly updated by trigger points such as privileged
    access to the device, faulty hardware, or any configuration changes.
  prefs: []
  type: TYPE_NORMAL
- en: Using configuration pipelines requires that only the pipeline is able to change
    the startup configuration of the router. That means network engineers are not
    able to save configuration changes on the device to avoid this happening.
  prefs: []
  type: TYPE_NORMAL
- en: For catastrophic scenarios where the configuration has to be changed quickly,
    the configuration pipelines are normally bypassed and the configuration updates
    are done by manual intervention from network engineers. These changes are normally
    applied to running-configuration and are not saved to the device. If a configuration
    audit runs it will show the difference between the running-configuration and the
    applied-configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration history
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is most desirable to have a history of the configuration for each of the
    devices for all configuration stages. The configuration history helps us to understand
    possible failures or improvements by comparing an old setup to a new one. It is
    also used to build an entire network in simulation for troubleshooting a failure
    in deployment during configuration updates. A configuration history might also
    benefit other teams, such as security auditing and capacity planners.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Deployment pipelines** are used on large networks that require fast and reliable
    changes. The pipeline is constructed with modern techniques of simulation and
    testing, which include extensive use of network automation coding.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a network deployment pipeline can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Example of a configuration deployment pipeline ](img/B18165_04_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Example of a configuration deployment pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, we can see how we can use the configuration states
    in our deployment pipeline. The input to the pipeline is the generated desired
    configuration, and the approved configuration will only be updated when the final
    tests have finished. With the use of this workflow, it is possible to automate
    deployment, reduce mistakes, and allow faster parallel deployments. Let’s describe
    each step of the pipeline process:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the configuration syntax is checked automatically. If it passes, go to
    the next steps. If it fails, the pipeline process stops and waits until a valid
    configuration is presented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, the pipeline verifies any differences between the running and applied
    configurations, which in some cases could be due to an urgent configuration fix.
    If the configurations are different, it will require manual approval to go to
    the next steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Third, the pipeline launches a simulation for the routers in the configuration
    change scope and deploys the new configuration to the simulated network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fourth, the pipeline runs functional tests in the simulation that will confirm
    that the new configuration does not break any functions that are already present.
    If it passes, it goes to the next step. If it fails, the pipeline stops and awaits
    rejection or acceptance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fifth, the pipeline applies the new configuration to the network, following
    all parallel dependencies and time restrictions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Network diagrams and automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Network diagrams are graphical, human-friendly, and readable representations
    of the network, but they are not easy for machines to read. Most of the time,
    they are generated by humans from graphical tools such as Visio, Lucid Chart,
    and Draw.io. When generated by humans, the updates on the diagrams, to reflect
    the current state, are normally left behind, causing information on the diagram
    to be outdated.
  prefs: []
  type: TYPE_NORMAL
- en: To have an accurate network diagram, we need to have some sort of diagram generator
    that reads data from either the router configuration or network definition files.
  prefs: []
  type: TYPE_NORMAL
- en: In our previous example of the deployment pipeline, the diagram generator could
    read the configuration from any configuration stage and have a different diagram
    for the running configuration and desired configuration stages.
  prefs: []
  type: TYPE_NORMAL
- en: With automatic diagram generation, an up-to-date diagram can be generated for
    any stage of the pipeline. These diagrams can be used to help network engineers
    to troubleshoot a problem or help network designers to understand how to improve
    the current network functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed how multiple configuration stages can help deploy
    solutions and how problems can occur when the source of truth is not defined or
    updated. Next, we will examine how we can create abstract definitions from a device
    configuration to create a better source of truth.
  prefs: []
  type: TYPE_NORMAL
- en: Using network definitions to aid automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section explored the configuration stages and how we can rely on
    them to build a better network deployment pipeline. On the other hand, we have
    not covered another issue with the router configuration, which is related to router
    software versions and router vendors.
  prefs: []
  type: TYPE_NORMAL
- en: Using a router configuration as a source of truth has advantages if your network
    will not update, grow, or change vendors. If your network is not intended to change,
    you might not need a definition at all. However, as the majority of the network
    will need to upgrade or grow, it is important to think about getting away from
    vendor-specific solutions and create vendor-agnostic definitions of your network.
  prefs: []
  type: TYPE_NORMAL
- en: A router vendor has different configuration defaults, which means some configuration
    lines might not be necessary with one vendor but be required with the other vendor.
    For network automation, we want to avoid traps like that and have a network source
    of truth that explicitly says what is necessary to configure. We then have to
    add a translation layer that will produce a router configuration specifically
    for that vendor.
  prefs: []
  type: TYPE_NORMAL
- en: Another point is some vendors change default configuration between versions
    of the same operational system. One version might have extra lines that are not
    present in the other version. This can also cause problems with our network automation.
    Again, we want to add a translation layer that is vendor- and version-specific,
    therefore generating configurations appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: The router configuration render
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A router configuration render is a software layer that sits between our agnostic
    definitions and the desired configuration in our deployment pipeline described
    earlier. It works like a translator and needs to be aware of the vendor and the
    version of the router to generate an appropriate configuration. The following
    figure shows an example of two different configuration renders, one for Juniper
    and one for Cisco:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Configuration render examples for Cisco and Juniper](img/B18165_04_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Configuration render examples for Cisco and Juniper
  prefs: []
  type: TYPE_NORMAL
- en: A configuration render can be flexible when generating configuration lines for
    the same vendor, but it must be aware of the configuration defaults and difference
    for each vendor and its operating system version. Normally, a render can cover
    a series of versions and platforms from the same vendor.
  prefs: []
  type: TYPE_NORMAL
- en: Using configuration templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An easy way to generate a router configuration is to use **configuration templates**.
    With these, it is easy to construct a generic configuration and then modify by
    adding key text words to the configuration text that has to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the router configuration render will read the definitions from
    a file and then read a configuration template to generate the router configuration
    as described in the following diagram. It shows an example for a Juniper router,
    but it can be used for any other router:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Router configuration render using templates](img/B18165_04_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Router configuration render using templates
  prefs: []
  type: TYPE_NORMAL
- en: Creating a template is not difficult and it requires only a sample of the router
    configuration platform that you want to generate; you simply replace the elements
    you want with a key string. An example using `{{ADDRESS}}` and `{{DESTINATION}}`
    is shown in the preceding figure.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python engine templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Jinja** is a template engine library for Python that is also commonly referred
    to as **Jinja2** to reflect the newest release version. Jinja is used to create
    HTML, XML, and, for us, router configurations. It was created by Armin Ronacher
    and is open source with the BSD license. Jinja is similar to the Django template
    engine, but with the advantage of using Python expressions. It uses a text template
    and, therefore, can be used to generate any text, markup, or even source code,
    and router configurations in our case.'
  prefs: []
  type: TYPE_NORMAL
- en: For router configurations, Jinja is useful because it has a consistent template
    tag syntax and the router template configuration is extracted as an independent
    source, so it can be used as a dependency by other code libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an input Jinja template file for a Cisco router
    (a file called `cisco_template.txt`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the input definition file used to feed the configuration render
    (a file called `router_definitions.yaml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the Python code used to generate the router configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After running the preceding Python script, it will generate three files with
    three different configurations for Sydney, Brisbane, and Adelaide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the content of the `Sydney_router_config.txt` output file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the content of the `Brisbane_router_config.txt` output file,
    just to show the slight differences between the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Like Sydney and Brisbane, the Adelaide file will be created with the required
    fields changed. The preceding example is quite simple and has only three keys
    to be modified: `{{id}}`, `{{name}}`, and `{{to_name}}`. More complex examples
    can be found in the Jinja documentation at [https://jinja.palletsprojects.com/](https://jinja.palletsprojects.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Using Go engine templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Jinja is limited to just Python, **Go** has a native text template engine
    that can be used to generate router configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Different from Python, Go templates are executed by applying a data structure
    to the template text. The template has annotations that refer to the data structure,
    which is normally a field of `Struct` or `Map` in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example using Go, let’s use a similar template for the Cisco configuration
    used for Jinja in the previous example, but with small changes to accommodate
    Go standards. Let’s use the file named `cisco_template_go.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: And for the router definition, the `router_definitions.yaml` file is the same
    as that used in the Python example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the Go code used to generate the same router configurations
    created in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code in Go is similar to Python, but note that in Go, you have to explicitly
    describe all the fields you are going to read from the `router_definitions.yaml`
    file. This is done in the code with the `Router` and `RouterList` types (lines
    11 and 17 in the preceding code).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored how we can improve network automation by having
    router configuration renders. We also explored some very useful libraries in Python
    and Go to be used for router configuration renders. Next, we are going to explore
    the nuances of creating network definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating network definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen so far how template engines are extremely useful to create router
    configurations using network automation. It is also important to define a good
    router definition, so we can have templates that are less specific, allowing the
    router definition file to determine how the router should be configured. Additionally,
    if router definitions are created properly, it will not be necessary to change
    them if a vendor change or a router upgrade is necessary. The only change will
    be to the router configuration templates.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we create a network definition that will last longer and can be
    used as the source of truth for the entire network automation? Let’s explore a
    few points that would help with that.
  prefs: []
  type: TYPE_NORMAL
- en: Nested and hierarchical definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A network definition does not need to be a flat unique file definition but can
    use a group of files in a nested setup. The reason is that some definition files
    can be specific to a particular characteristic present in all devices, such as
    vendor, device type, device rules, ACLs, or device function. Subsequent files
    that follow the hierarchy can have details that are more specific, such as location,
    name, capacity limits, or size.
  prefs: []
  type: TYPE_NORMAL
- en: Using nested or hierarchical network definitions will help to avoid having large
    definition files for each device, and most important of all, avoid the repetition
    of definitions across different files.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, imagine that you want to control a list of IP addresses that are
    allowed to log into all routers in your network. If you don’t use nested definitions,
    you might need to add the list of IPs to all router definitions. But if you have
    nested definitions, you might be able to use only one file definition for that.
  prefs: []
  type: TYPE_NORMAL
- en: To use hierarchy and groups, though, you must create a custom library that compiles
    the final definition of one specific router by looking into all hierarchical definition
    files that belong to that router. The final compiled definition can then be used
    on the router configuration render to complete the router template and output
    the correct router configuration.
  prefs: []
  type: TYPE_NORMAL
- en: IP allocation considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One important point to be observed with definitions is the IP addresses that
    are associated to every interface or protocol on the network devices. The IP addresses
    are normally unique to the network, unless **Network Address Translator** (**NAT**)
    is being used, but the majority of the IP address range is unique per region and
    per device.
  prefs: []
  type: TYPE_NORMAL
- en: To create a more flexible and future-proof solution, the IP allocation has to
    be as unfixed as possible, and rules can be taken for the configuration render
    to allow better use of the IP allocation.
  prefs: []
  type: TYPE_NORMAL
- en: Using an IP allocation engine in combination with nested definitions, it is
    possible to reserve IPs that are essential for device identification, such as
    loopbacks, and leave other IP ranges to be associated to network interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: One enhancement that can be made when IP addresses are not fixed is to have
    a service that translates the IP address to a name associated with the network
    definition files. That can be done using DNS, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy of having less-fixed IPs in the definitions will allow a more flexible
    solution and avoid complications for the network definition files.
  prefs: []
  type: TYPE_NORMAL
- en: Using files for definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating definitions, the best practice is to use plain files, not databases
    or any other storage method. This will allow engineers to have a complete source
    of truth without dependency on any system or application, thus the files can be
    read even after a catastrophic event with multiple system failures.
  prefs: []
  type: TYPE_NORMAL
- en: File format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Network automation should use only one file format across all network definitions.
    The file should be text-based but use a well-known format that enforces, among
    other things, typing. If the structure of the file is standard and easy to read,
    it will help engineers to review it if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever associating names to network definitions, avoid acronyms or any sort
    of abbreviation. Although shortening can help engineers to type faster, it can
    create confusion and raise problems when humans have to investigate. Remember
    that you can always create hotkeys or aliases locally in your environment to type
    device names faster.
  prefs: []
  type: TYPE_NORMAL
- en: Some devices have a limit on string sizes for names, so use names wisely and
    describe as much as possible the device you are naming to avoid economizing space.
  prefs: []
  type: TYPE_NORMAL
- en: This section has shown how important it is to examine some details when creating
    network definitions. We’ll now review the most common data representation types
    in our network definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring different file types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The examples that we have seen in this chapter had network definitions with
    files ending with `.yaml`, which is an indication that they are in YAML format.
    But why? Why not XML or JSON formats? Let’s explore the pros and cons of the most
    used file formats.
  prefs: []
  type: TYPE_NORMAL
- en: For our network definitions, we want to choose a format that is easy to read
    by humans and systems, fast to parse, and small to store. Then we can write a
    large content of definitions in files without worrying about performance, reading
    difficulty, or storage issues.
  prefs: []
  type: TYPE_NORMAL
- en: XML files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Extensible Markup Language** or **XML** is the oldest markup language of
    those described in this section, with the first implementation dated 1996\. Its
    first standard publication was created in 1998 by the World Wide Web Consortium
    as the version 1.0 specification.'
  prefs: []
  type: TYPE_NORMAL
- en: The main goals of the initial XML design were to create a markup language that
    was simple, could cover general cases, and was easy to use across the internet.
    Even though the initial idea was for XML to create documents, the language has
    been used for arbitrary data structures on client and server interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Because of its schema system, XML can use several media types. In 2001, IETF
    published the RFC3023, which described all possible media types, including `application/xml`
    and `text/xml`. In 2014, IETF published RFC7303, which refined the standards for
    media types and rendered RFC3023 obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the example, we only have two data values (the highlighted IP addresses);
    the rest is markup overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the pros and cons:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More flexible for representing general data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slow to process because of its complexity
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lots of overhead from using many repetitive structure markers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Less human-readable
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is prone to redundancies in structure
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation**, or **JSON**, is a newer method for data interchange
    representation compared to XML, with the original specification having been done
    by Douglas Crockford in the early 2000s. In 2004, IETF published an informational
    RFC4627, but only in 2014 did IETF create the RFC7159 standard. Now the latest
    standard is RFC8259.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON, like objects in JavaScript, has primitive types such as string, Boolean,
    number, and null. The structure in JSON consists of a key name and a value surrounded
    by a pair of curly brackets, as in `{"key": <value>}`. The key name is always
    a string. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that JSON carries much less overhead than XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding representation can also be written in one line, but it is not
    easy to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the pros and cons:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simpler and faster than XML
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Better parsing performance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading truncated files is avoided
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not support comments
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not allow aliases
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Carries more overhead than other formats
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is not human-readable, depending on the format
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: YAML files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**YAML** was originally an acronym for **Yet Another Markup Language** because
    it was created after the proliferation of markup languages such as XML and HTML
    in late 1990\. The creator Clark Evans wanted YAML to sound different, so the
    name was changed to **YAML Ain’t Markup Language**, a recursive acronym, to differentiate
    the purpose of YAML from other markup languages. The standard version 1.0 was
    published in 2004 and the latest version, 1.2.2, was published in 2021.'
  prefs: []
  type: TYPE_NORMAL
- en: YAML is intended to be human-readable and its data representation requires the
    use of indentation and new lines, which are used for delimitation and the grouping
    of data; this is different from JSON, which doesn’t actually require newlines
    or indentation.
  prefs: []
  type: TYPE_NORMAL
- en: YAML also supports advanced features that are not supported by other data representation
    languages, such as anchors and references, which are very useful for avoiding
    repetition and data errors. Natively, YAML encodes scalars (such as strings, integers,
    and floats), dictionaries (or maps), and lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, YAML has an even shorter representation and is very easy to
    read. As opposed to JSON, though, it can’t be represented in just one line as
    the format alters the data representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the pros and cons:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simpler and smaller
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to read
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows aliases and anchors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows comments
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not as fast to parse as JSON
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other formats, such as **TOML**, **HOCON**, and **HCL**. Each of them
    has its advantages and disadvantages, but for our network automation and for most
    of our network definitions, YAML is the best option so far. It is also the most
    common one in network definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how network automation and engineers can benefit
    from having a proper configuration and network definition solution. It is not
    easy to grow a network with minimal human interaction and low dependency on network
    vendors and operating system versions.
  prefs: []
  type: TYPE_NORMAL
- en: You are now familiar with network configuration issues and how to tackle them.
    You are able to distinguish the stages of a deployment pipeline. You are also
    able to create a robust network definition to feed an automated router configuration
    render and choose the best file type to represent the network definition.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover network programming by looking at what we should
    and should not do when writing code for networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Network Programming for Automation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second part of the book is focused more on the programming aspects of network
    automation. This includes a description of the popular libraries, runtime performance,
    scaling aspects, error handling, logging, and more. Go and Python are used, and,
    in some cases, there are comparable examples to show how either language can be
    used for better network automation work.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18165_05.xhtml#_idTextAnchor127), *Dos and Don’ts for Network
    Programming*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18165_06.xhtml#_idTextAnchor166), *Using Go and Python for Network
    Programming*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18165_07.xhtml#_idTextAnchor183), *Error Handling and Logging*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18165_08.xhtml#_idTextAnchor195), *Scaling Your Code*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
