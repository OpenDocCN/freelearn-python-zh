- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Working with Network Configurations and Definitions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与网络配置和定义一起工作
- en: One important point in network automation is how the configuration is organized
    and how we can automate our network in a scalable way. In this chapter, we are
    going to explore how to work with a network configuration and how to define it
    for effective use with network automation. We want to build scalable and future-proof
    solutions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络自动化中的一个重要点是配置的组织方式以及我们如何以可扩展的方式自动化我们的网络。在本章中，我们将探讨如何处理网络配置以及如何定义它以有效地用于网络自动化。我们希望构建可扩展且面向未来的解决方案。
- en: Why do we care about configuration and network definition? Why is it important
    which file to use? How can we create a lifelong definition? How can we use this
    to help network automation? Let’s explore answers to these questions in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么关心配置和网络定义？为什么使用哪个文件很重要？我们如何创建终身定义？我们如何利用这一点来帮助网络自动化？让我们在本章中探讨这些问题的答案。
- en: 'We are going to explore the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下内容：
- en: Describing the configuration problem
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述配置问题
- en: Helping network automation using definitions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用定义帮助网络自动化
- en: Creating network definitions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建网络定义
- en: Exploring different file types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索不同的文件类型
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code described in this chapter is stored in the GitHub repository
    at [https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter04](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter04).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中描述的源代码存储在GitHub仓库中，网址为[https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter04](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter04)。
- en: Describing the configuration problem
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述配置问题
- en: Several production networks out there have their configuration applied to network
    devices without any additional external definition. Some of them have network
    diagrams describing the network, but the majority have outdated or incomplete
    diagrams. Therefore, in most cases, you might need to read running device configurations
    to understand the details of the network operation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一些生产网络在将配置应用于网络设备时没有进行任何额外的外部定义。其中一些有网络图描述网络，但大多数都有过时或不完整的图。因此，在大多数情况下，你可能需要阅读运行设备配置来了解网络操作的细节。
- en: In some network providers, diagrams are used for an initial understanding of
    the network or as an overall overview. Once the engineers have enough confidence
    in their network, the diagrams are just ignored or not used anymore. Some would
    update their diagrams, but for most engineers, this task is not a priority and
    usually is left behind.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些网络提供商中，图用于对网络或整体概述的初步理解。一旦工程师对他们的网络有足够的信心，这些图就会被忽略或不再使用。有些人会更新他们的图，但对于大多数工程师来说，这项任务不是优先事项，通常会被推迟。
- en: It is also common for some engineers to apply configuration fixes directly into
    production devices to solve catastrophic or urgent failures. In other cases, additional
    configuration is applied temporarily for troubleshooting, but never removed. These
    configuration changes are forgotten in some cases that they were applied and the
    network runs with a configuration difference that is not perceived until a software
    update is necessary.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些工程师来说，将配置修复直接应用于生产设备以解决灾难性或紧急故障也是常见的。在其他情况下，额外的配置临时应用于故障排除，但从未被移除。在某些情况下，这些配置更改被遗忘，网络运行时配置差异未被察觉，直到需要软件更新。
- en: Let’s discuss the issues further in the following subsections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下子节中进一步讨论这些问题。
- en: Source of truth
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真相来源
- en: '**Source of truth** is a term used in computer networks to describe where the
    definition is and what all other systems have to rely on when consulting or using
    the information to create further definitions. The source of truth can be either
    a file, a router configuration, a database, a memory space, or a network diagram.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**真相来源**是计算机网络中用来描述定义所在位置以及当咨询或使用该信息创建进一步定义时，所有其他系统必须依赖的术语。真相来源可以是文件、路由器配置、数据库、内存空间或网络图。'
- en: We want to have the source of truth as steadily defined as possible; it should
    not change over a short period of time and should be used as a reference for any
    other definition.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将真相来源尽可能稳定地定义；它不应在短时间内发生变化，并且应作为任何其他定义的参考。
- en: The majority of network engineers rely on the router configuration as the source
    of truth, because routers are frequently updated and have the correct definitions
    to run the network; however, this does not help our network automation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络工程师依赖于路由器配置作为真相来源，因为路由器经常更新，并且有正确的定义来运行网络；然而，这并不帮助我们的网络自动化。
- en: Ideally, we want the source of the truth to be in a database or files stored
    in a secure and future-proof environment that can be ready to be read by any system
    quickly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望真相来源位于数据库中或存储在安全且未来可靠的环境中，以便任何系统都可以快速读取。
- en: The startup configuration and the running configuration
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动配置和运行配置
- en: A network device has two configuration states, the **running configuration**
    and the **startup configuration**. The running configuration is the current configuration
    on the device’s memory that is being used to operate at that present moment. The
    startup configuration is used to boot the device from *off* to *on*. The difference
    is that one is volatile and will be deleted once the device is turned off or loses
    power supply, and the other is permanent and will always exist independent of
    whether it has a power supply or not.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 网络设备有两种配置状态，**运行配置**和**启动配置**。运行配置是设备内存中当前正在使用的配置，用于在当前时刻操作。启动配置用于将设备从**关闭**状态启动到**开启**状态。区别在于一个是易失性的，一旦设备关闭或失去电源，就会被删除，而另一个是永久的，无论是否有电源，它都会始终存在。
- en: The startup configuration is normally stored in a non-volatile memory store
    such as SSD, a flash drive, or a hard drive.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 启动配置通常存储在非易失性存储器中，如 SSD、闪存驱动器或硬盘驱动器。
- en: For our automation, we want to have the same running configuration as the startup
    configuration. When they differ, it might cause automation issues if not well
    documented.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的自动化，我们希望运行配置与启动配置相同。当它们不同时，如果没有良好记录，可能会引起自动化问题。
- en: Configuration states and history
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置状态和历史记录
- en: A good network automation design should aim to have multiple configuration states
    and history, which will help to determine how the network is operating now, how
    it should operate in the future, and how it operated in the past.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的网络自动化设计应该旨在拥有多个配置状态和历史记录，这将有助于确定网络当前是如何运行的，未来应该如何运行，以及过去是如何运行的。
- en: 'For deployment and automation, it is very useful to separate the configuration
    into at least four stages: **Desired**, **Approved**, **Applied**, and **Running**,
    as shown in *Figure 4.1*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于部署和自动化，将配置分离成至少四个阶段非常有用：**期望的**、**批准的**、**应用的**和**运行的**，如图 *4.1* 所示：
- en: '![ Figure 4.1 – Configuration stages and control layer](img/B18165_04_001.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 配置阶段和控制层](img/B18165_04_001.jpg)'
- en: Figure 4.1 – Configuration stages and control layer
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 配置阶段和控制层
- en: We’ll discuss each of these in the following sub sections.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下子节中讨论这些内容。
- en: Desired-configuration
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 想要的配置
- en: The **desired-configuration** is used to document the configuration that should
    be applied in the near future. It is used to check for inconsistencies and to
    be applied in a test network (or a network simulation) to evaluate future deployments,
    possible syntax errors, and other functional problems.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**期望配置**用于记录即将应用在不久的将来的配置。它用于检查不一致性，并在测试网络（或网络模拟）中应用，以评估未来的部署、可能的语法错误和其他功能问题。'
- en: Modern networks use the desired-configuration to feed a configuration pipeline
    that will perform a series of tests, including simulation to validate and anticipate
    errors. It is also used to test the deployment sequence, and evaluate which devices
    can be deployed in parallel or which ones need to wait until some have finished
    being deployed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络使用期望配置来向配置管道提供数据，该管道将执行一系列测试，包括模拟以验证和预测错误。它还用于测试部署顺序，并评估哪些设备可以并行部署，哪些设备需要等待某些设备完成部署。
- en: Approved-configuration
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批准配置
- en: The **approved-configuration** is the configuration that has passed all approval
    stages in the configuration pipeline, whether they are automated approval stages,
    such as syntax checks, or manual stages, done by a human approval.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**批准配置**是已经通过配置管道中所有审批阶段的配置，无论是自动化审批阶段，如语法检查，还是人工审批阶段。'
- en: To enhance confidence, some configuration pipelines will apply the desired-configuration
    in a network simulation for further function testing, and if everything passes,
    the configuration pipeline will approve the configuration.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强信心，一些配置管道会在网络模拟中应用所需的配置进行进一步的功能测试，如果一切顺利，配置管道将批准配置。
- en: From all configuration stages, the approval-configuration is the one that takes
    more time to finish as large networks have thousands of routers, and some require
    sequential functional testing instead of parallel testing. After everything is
    completed, the configurations are ready to be deployed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有配置阶段中，审批配置是耗时最长的，因为大型网络有成千上万的路由器，其中一些需要顺序功能测试而不是并行测试。完成所有工作后，配置就绪，可以部署。
- en: Applied-configuration
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用的配置
- en: The **applied-configuration** is the configuration saved on the device’s non-volatile
    configuration or the startup configuration. At the end of this stage, we confidently
    know that the configuration has been saved in all routers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用的配置**是保存在设备非易失性配置或启动配置中的配置。在这个阶段结束时，我们自信地知道配置已经保存在所有路由器中。'
- en: This stage also can take a long time because deployment cannot necessarily be
    performed in parallel.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段也可能需要很长时间，因为部署不一定能并行进行。
- en: Running-configuration
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行配置
- en: This stage is used as a safeguard for future deployments and approval processes.
    The **running-configuration** has to be the same as the applied configuration;
    however, it might not be the same configuration, especially after a catastrophic
    event that required configuration intervention.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段用作未来部署和审批流程的安全保障。**运行配置**必须与应用配置相同；然而，它可能不是相同的配置，尤其是在需要配置干预的灾难性事件之后。
- en: The running-configuration is constantly updated by trigger points such as privileged
    access to the device, faulty hardware, or any configuration changes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 运行配置由触发点不断更新，如对设备的特权访问、故障硬件或任何配置更改。
- en: Using configuration pipelines requires that only the pipeline is able to change
    the startup configuration of the router. That means network engineers are not
    able to save configuration changes on the device to avoid this happening.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置管道要求只有管道能够更改路由器的启动配置。这意味着网络工程师无法在设备上保存配置更改，以避免这种情况发生。
- en: For catastrophic scenarios where the configuration has to be changed quickly,
    the configuration pipelines are normally bypassed and the configuration updates
    are done by manual intervention from network engineers. These changes are normally
    applied to running-configuration and are not saved to the device. If a configuration
    audit runs it will show the difference between the running-configuration and the
    applied-configuration.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要快速更改配置的灾难性场景，通常绕过配置管道，由网络工程师手动干预进行配置更新。这些更改通常应用于运行配置，并且不会保存到设备中。如果运行配置审计，它将显示运行配置和应用的配置之间的差异。
- en: Configuration history
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置历史
- en: It is most desirable to have a history of the configuration for each of the
    devices for all configuration stages. The configuration history helps us to understand
    possible failures or improvements by comparing an old setup to a new one. It is
    also used to build an entire network in simulation for troubleshooting a failure
    in deployment during configuration updates. A configuration history might also
    benefit other teams, such as security auditing and capacity planners.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个设备的所有配置阶段，都希望有一个配置历史记录。配置历史记录帮助我们通过比较旧配置与新配置来了解可能的故障或改进。它还用于在模拟中构建整个网络，以在配置更新期间解决部署中的故障。配置历史记录也可能对其他团队有益，例如安全审计和容量规划师。
- en: Deployment pipeline
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署管道
- en: '**Deployment pipelines** are used on large networks that require fast and reliable
    changes. The pipeline is constructed with modern techniques of simulation and
    testing, which include extensive use of network automation coding.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**部署管道**用于需要快速和可靠更改的大型网络。该管道使用现代的模拟和测试技术构建，包括广泛使用网络自动化编码。'
- en: 'An example of a network deployment pipeline can be seen as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 网络部署管道的一个示例如下：
- en: '![Figure 4.2 – Example of a configuration deployment pipeline ](img/B18165_04_002.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 配置部署管道示例](img/B18165_04_002.jpg)'
- en: Figure 4.2 – Example of a configuration deployment pipeline
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 配置部署管道示例
- en: 'In the preceding figure, we can see how we can use the configuration states
    in our deployment pipeline. The input to the pipeline is the generated desired
    configuration, and the approved configuration will only be updated when the final
    tests have finished. With the use of this workflow, it is possible to automate
    deployment, reduce mistakes, and allow faster parallel deployments. Let’s describe
    each step of the pipeline process:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到我们如何在部署管道中使用配置状态。管道的输入是生成的期望配置，而批准的配置只有在最终测试完成后才会更新。使用此工作流程，可以实现自动化部署，减少错误，并允许更快的并行部署。让我们描述管道过程每一步：
- en: First, the configuration syntax is checked automatically. If it passes, go to
    the next steps. If it fails, the pipeline process stops and waits until a valid
    configuration is presented.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一，自动检查配置语法。如果通过，则进入下一步。如果失败，管道过程停止，等待有效的配置出现。
- en: Second, the pipeline verifies any differences between the running and applied
    configurations, which in some cases could be due to an urgent configuration fix.
    If the configurations are different, it will require manual approval to go to
    the next steps.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二，管道验证运行配置和应用的配置之间的任何差异，在某些情况下可能是由于紧急配置修复引起的。如果配置不同，则需要手动批准才能进入下一步。
- en: Third, the pipeline launches a simulation for the routers in the configuration
    change scope and deploys the new configuration to the simulated network.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三，管道在配置更改范围内对路由器进行模拟，并将新配置部署到模拟网络中。
- en: Fourth, the pipeline runs functional tests in the simulation that will confirm
    that the new configuration does not break any functions that are already present.
    If it passes, it goes to the next step. If it fails, the pipeline stops and awaits
    rejection or acceptance.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四，管道在模拟中运行功能测试，以确认新配置不会破坏已存在的任何功能。如果通过，则进入下一步。如果失败，管道停止并等待拒绝或接受。
- en: Fifth, the pipeline applies the new configuration to the network, following
    all parallel dependencies and time restrictions.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第五，该管道将新配置应用于网络，遵循所有并行依赖关系和时间限制。
- en: Network diagrams and automation
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络图和自动化
- en: Network diagrams are graphical, human-friendly, and readable representations
    of the network, but they are not easy for machines to read. Most of the time,
    they are generated by humans from graphical tools such as Visio, Lucid Chart,
    and Draw.io. When generated by humans, the updates on the diagrams, to reflect
    the current state, are normally left behind, causing information on the diagram
    to be outdated.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 网络图是网络的可视化、人性化的可读表示，但它们对机器来说并不容易阅读。大多数情况下，它们是由人类使用Visio、Lucid Chart和Draw.io等图形工具生成的。当由人类生成时，为了反映当前状态，图表的更新通常会被遗漏，导致图表上的信息过时。
- en: To have an accurate network diagram, we need to have some sort of diagram generator
    that reads data from either the router configuration or network definition files.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要有一个准确的网络图，我们需要有一种图表生成器，它可以读取来自路由器配置或网络定义文件的数据。
- en: In our previous example of the deployment pipeline, the diagram generator could
    read the configuration from any configuration stage and have a different diagram
    for the running configuration and desired configuration stages.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的部署管道示例中，图表生成器可以读取任何配置阶段的配置，并为运行配置和期望配置阶段生成不同的图表。
- en: With automatic diagram generation, an up-to-date diagram can be generated for
    any stage of the pipeline. These diagrams can be used to help network engineers
    to troubleshoot a problem or help network designers to understand how to improve
    the current network functions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自动生成图表，可以为管道的任何阶段生成最新的图表。这些图表可以帮助网络工程师解决问题，或帮助网络设计师了解如何改进当前的网络功能。
- en: In this section, we discussed how multiple configuration stages can help deploy
    solutions and how problems can occur when the source of truth is not defined or
    updated. Next, we will examine how we can create abstract definitions from a device
    configuration to create a better source of truth.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了多个配置阶段如何帮助部署解决方案，以及当真相来源未定义或更新时可能发生的问题。接下来，我们将探讨如何从设备配置创建抽象定义，以创建更好的真相来源。
- en: Using network definitions to aid automation
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网络定义来辅助自动化
- en: The previous section explored the configuration stages and how we can rely on
    them to build a better network deployment pipeline. On the other hand, we have
    not covered another issue with the router configuration, which is related to router
    software versions and router vendors.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节探讨了配置阶段以及我们如何依赖它们来构建更好的网络部署管道。另一方面，我们没有涵盖另一个与路由器配置相关的问题，即与路由器软件版本和供应商相关。
- en: Using a router configuration as a source of truth has advantages if your network
    will not update, grow, or change vendors. If your network is not intended to change,
    you might not need a definition at all. However, as the majority of the network
    will need to upgrade or grow, it is important to think about getting away from
    vendor-specific solutions and create vendor-agnostic definitions of your network.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的网络不会更新、增长或更改供应商，使用路由器配置作为真相源具有优势。如果您的网络不打算更改，您可能根本不需要定义。然而，由于大多数网络都需要升级或增长，因此考虑摆脱特定供应商的解决方案并创建无供应商定义的网络是很重要的。
- en: A router vendor has different configuration defaults, which means some configuration
    lines might not be necessary with one vendor but be required with the other vendor.
    For network automation, we want to avoid traps like that and have a network source
    of truth that explicitly says what is necessary to configure. We then have to
    add a translation layer that will produce a router configuration specifically
    for that vendor.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器供应商有不同的配置默认值，这意味着某些配置行可能在一个供应商中不是必需的，但在另一个供应商中却是必需的。对于网络自动化，我们希望避免这样的陷阱，并有一个明确说明配置所需内容的网络真相源。然后我们必须添加一个翻译层，以生成针对该供应商的特定路由器配置。
- en: Another point is some vendors change default configuration between versions
    of the same operational system. One version might have extra lines that are not
    present in the other version. This can also cause problems with our network automation.
    Again, we want to add a translation layer that is vendor- and version-specific,
    therefore generating configurations appropriately.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点是，一些供应商在相同操作系统的不同版本之间更改默认配置。一个版本可能包含其他版本中不存在的额外行。这也可能对我们的网络自动化造成问题。同样，我们希望添加一个供应商和版本特定的翻译层，因此生成适当的配置。
- en: The router configuration render
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器配置渲染
- en: 'A router configuration render is a software layer that sits between our agnostic
    definitions and the desired configuration in our deployment pipeline described
    earlier. It works like a translator and needs to be aware of the vendor and the
    version of the router to generate an appropriate configuration. The following
    figure shows an example of two different configuration renders, one for Juniper
    and one for Cisco:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器配置渲染是一个位于我们无差别的定义和之前描述的部署管道中所需配置之间的软件层。它的工作方式就像一个翻译者，需要了解供应商和路由器的版本以生成适当的配置。以下图显示了两个不同的配置渲染示例，一个用于Juniper，一个用于Cisco：
- en: '![Figure 4.3 – Configuration render examples for Cisco and Juniper](img/B18165_04_003.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – Cisco和Juniper的配置渲染示例](img/B18165_04_003.jpg)'
- en: Figure 4.3 – Configuration render examples for Cisco and Juniper
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – Cisco和Juniper的配置渲染示例
- en: A configuration render can be flexible when generating configuration lines for
    the same vendor, but it must be aware of the configuration defaults and difference
    for each vendor and its operating system version. Normally, a render can cover
    a series of versions and platforms from the same vendor.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在为同一供应商生成配置行时，配置渲染可以是灵活的，但它必须了解每个供应商及其操作系统版本的配置默认值和差异。通常，一个渲染器可以覆盖同一供应商的一系列版本和平台。
- en: Using configuration templates
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用配置模板
- en: An easy way to generate a router configuration is to use **configuration templates**.
    With these, it is easy to construct a generic configuration and then modify by
    adding key text words to the configuration text that has to be changed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 生成路由器配置的一个简单方法是使用**配置模板**。有了这些模板，可以轻松构建一个通用配置，然后通过添加关键文本词到需要更改的配置文本中来进行修改。
- en: 'In our case, the router configuration render will read the definitions from
    a file and then read a configuration template to generate the router configuration
    as described in the following diagram. It shows an example for a Juniper router,
    but it can be used for any other router:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，路由器配置渲染器将从文件中读取定义，然后读取一个配置模板以生成如以下图所示的路由器配置。它展示了Juniper路由器的示例，但也可以用于任何其他路由器：
- en: '![Figure 4.4 – Router configuration render using templates](img/B18165_04_004.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 使用模板进行路由器配置渲染](img/B18165_04_004.jpg)'
- en: Figure 4.4 – Router configuration render using templates
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 使用模板进行路由器配置渲染
- en: Creating a template is not difficult and it requires only a sample of the router
    configuration platform that you want to generate; you simply replace the elements
    you want with a key string. An example using `{{ADDRESS}}` and `{{DESTINATION}}`
    is shown in the preceding figure.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模板并不困难，它只需要你生成所需的路由器配置平台的样本；你只需用键字符串替换你想要的元素。前一个图中的示例使用了 `{{ADDRESS}}` 和 `{{DESTINATION}}`。
- en: Using Python engine templates
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 引擎模板
- en: '**Jinja** is a template engine library for Python that is also commonly referred
    to as **Jinja2** to reflect the newest release version. Jinja is used to create
    HTML, XML, and, for us, router configurations. It was created by Armin Ronacher
    and is open source with the BSD license. Jinja is similar to the Django template
    engine, but with the advantage of using Python expressions. It uses a text template
    and, therefore, can be used to generate any text, markup, or even source code,
    and router configurations in our case.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jinja** 是一个用于 Python 的模板引擎库，也常被称为 **Jinja2** 以反映最新发布版本。Jinja 用于创建 HTML、XML，以及对我们来说，路由器配置。它由
    Armin Ronacher 创建，是开源的，采用 BSD 许可证。Jinja 与 Django 模板引擎类似，但具有使用 Python 表达式的优势。它使用文本模板，因此可以用于生成任何文本、标记，甚至源代码，在我们的情况下是路由器配置。'
- en: For router configurations, Jinja is useful because it has a consistent template
    tag syntax and the router template configuration is extracted as an independent
    source, so it can be used as a dependency by other code libraries.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于路由器配置，Jinja 很有用，因为它有一个一致的模板标签语法，并且路由器模板配置被提取为一个独立源，因此它可以作为其他代码库的依赖项使用。
- en: 'The following is an example of an input Jinja template file for a Cisco router
    (a file called `cisco_template.txt`):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个用于 Cisco 路由器的输入 Jinja 模板文件的示例（一个名为 `cisco_template.txt` 的文件）：
- en: '[PRE0]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is the input definition file used to feed the configuration render
    (a file called `router_definitions.yaml`):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用作向配置渲染提供输入的定义文件（一个名为 `router_definitions.yaml` 的文件）：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the Python code used to generate the router configurations:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用以生成路由器配置的 Python 代码：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After running the preceding Python script, it will generate three files with
    three different configurations for Sydney, Brisbane, and Adelaide.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的 Python 脚本后，它将为悉尼、布里斯班和阿德莱德生成三个具有不同配置的文件。
- en: 'Here is the content of the `Sydney_router_config.txt` output file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `Sydney_router_config.txt` 输出文件的内容：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the content of the `Brisbane_router_config.txt` output file,
    just to show the slight differences between the files:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为 `Brisbane_router_config.txt` 输出文件的内容，仅为了展示文件之间的细微差异：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Like Sydney and Brisbane, the Adelaide file will be created with the required
    fields changed. The preceding example is quite simple and has only three keys
    to be modified: `{{id}}`, `{{name}}`, and `{{to_name}}`. More complex examples
    can be found in the Jinja documentation at [https://jinja.palletsprojects.com/](https://jinja.palletsprojects.com/).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与悉尼和布里斯班一样，阿德莱德的文件将创建所需字段已更改。前面的示例相当简单，只有三个键需要修改：`{{id}}`、`{{name}}` 和 `{{to_name}}`。更复杂的示例可以在
    Jinja 文档中找到，链接为 [https://jinja.palletsprojects.com/](https://jinja.palletsprojects.com/)。
- en: Using Go engine templates
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Go 引擎模板
- en: Since Jinja is limited to just Python, **Go** has a native text template engine
    that can be used to generate router configurations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Jinja 仅限于 Python，**Go** 有一个本地的文本模板引擎，可以用来生成路由器配置。
- en: Different from Python, Go templates are executed by applying a data structure
    to the template text. The template has annotations that refer to the data structure,
    which is normally a field of `Struct` or `Map` in Go.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Python 不同，Go 模板通过将数据结构应用于模板文本来执行。模板有注释，这些注释引用数据结构，这通常是 Go 中 `Struct` 或 `Map`
    的字段。
- en: 'For our example using Go, let’s use a similar template for the Cisco configuration
    used for Jinja in the previous example, but with small changes to accommodate
    Go standards. Let’s use the file named `cisco_template_go.txt`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们使用 Go 的示例，让我们使用与前面示例中 Jinja 使用的 Cisco 配置相似的模板，但进行一些小的修改以适应 Go 标准。让我们使用名为
    `cisco_template_go.txt` 的文件：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: And for the router definition, the `router_definitions.yaml` file is the same
    as that used in the Python example.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 而对于路由器定义，`router_definitions.yaml` 文件与 Python 示例中使用的相同。
- en: 'The following is the Go code used to generate the same router configurations
    created in Python:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用Go语言编写的生成与Python中创建的相同路由器配置的代码：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code in Go is similar to Python, but note that in Go, you have to explicitly
    describe all the fields you are going to read from the `router_definitions.yaml`
    file. This is done in the code with the `Router` and `RouterList` types (lines
    11 and 17 in the preceding code).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的代码与Python类似，但请注意，在Go语言中，你必须明确描述你将要从`router_definitions.yaml`文件中读取的所有字段。这通过代码中的`Router`和`RouterList`类型（前述代码的第11行和第17行）来完成。
- en: In this section, we explored how we can improve network automation by having
    router configuration renders. We also explored some very useful libraries in Python
    and Go to be used for router configuration renders. Next, we are going to explore
    the nuances of creating network definitions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何通过路由器配置渲染来提高网络自动化。我们还探讨了Python和Go中一些非常有用的库，用于路由器配置渲染。接下来，我们将探讨创建网络定义的细微差别。
- en: Creating network definitions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建网络定义
- en: We have seen so far how template engines are extremely useful to create router
    configurations using network automation. It is also important to define a good
    router definition, so we can have templates that are less specific, allowing the
    router definition file to determine how the router should be configured. Additionally,
    if router definitions are created properly, it will not be necessary to change
    them if a vendor change or a router upgrade is necessary. The only change will
    be to the router configuration templates.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，模板引擎在通过网络自动化创建路由器配置方面极为有用。定义一个好的路由器定义也同样重要，这样我们就可以有更通用的模板，允许路由器定义文件决定路由器应该如何配置。此外，如果路由器定义创建得当，在需要更换供应商或升级路由器时，通常不需要更改它们。唯一需要更改的是路由器配置模板。
- en: So, how can we create a network definition that will last longer and can be
    used as the source of truth for the entire network automation? Let’s explore a
    few points that would help with that.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何创建一个可以持久存在并作为整个网络自动化真实来源的网络定义呢？让我们探讨一些有助于实现这一点的要点。
- en: Nested and hierarchical definitions
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套和分层定义
- en: A network definition does not need to be a flat unique file definition but can
    use a group of files in a nested setup. The reason is that some definition files
    can be specific to a particular characteristic present in all devices, such as
    vendor, device type, device rules, ACLs, or device function. Subsequent files
    that follow the hierarchy can have details that are more specific, such as location,
    name, capacity limits, or size.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 网络定义不一定要是一个扁平的唯一文件定义，而可以使用一组嵌套设置中的文件。原因是某些定义文件可能特定于所有设备中存在的特定特征，例如供应商、设备类型、设备规则、ACL或设备功能。后续的文件可以包含更具体的细节，例如位置、名称、容量限制或大小。
- en: Using nested or hierarchical network definitions will help to avoid having large
    definition files for each device, and most important of all, avoid the repetition
    of definitions across different files.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌套或分层网络定义将有助于避免为每个设备创建大型定义文件，最重要的是，避免在不同文件中重复定义。
- en: For instance, imagine that you want to control a list of IP addresses that are
    allowed to log into all routers in your network. If you don’t use nested definitions,
    you might need to add the list of IPs to all router definitions. But if you have
    nested definitions, you might be able to use only one file definition for that.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想控制一个允许登录你网络中所有路由器的IP地址列表。如果你不使用嵌套定义，你可能需要将IP列表添加到所有路由器定义中。但是，如果你有嵌套定义，你可能只需使用一个文件定义即可。
- en: To use hierarchy and groups, though, you must create a custom library that compiles
    the final definition of one specific router by looking into all hierarchical definition
    files that belong to that router. The final compiled definition can then be used
    on the router configuration render to complete the router template and output
    the correct router configuration.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用层次结构和组，你必须创建一个自定义库，通过查看属于该路由器的所有分层定义文件来编译一个特定路由器的最终定义。然后，可以在这个路由器配置渲染中使用最终编译的定义来完成路由器模板并输出正确的路由器配置。
- en: IP allocation considerations
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP分配考虑因素
- en: One important point to be observed with definitions is the IP addresses that
    are associated to every interface or protocol on the network devices. The IP addresses
    are normally unique to the network, unless **Network Address Translator** (**NAT**)
    is being used, but the majority of the IP address range is unique per region and
    per device.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义中需要注意的一个重要点是与网络设备上每个接口或协议关联的IP地址。除非使用**网络地址转换器**（**NAT**），否则IP地址通常是网络特有的，但大多数IP地址范围在每个地区和每个设备中都是唯一的。
- en: To create a more flexible and future-proof solution, the IP allocation has to
    be as unfixed as possible, and rules can be taken for the configuration render
    to allow better use of the IP allocation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建更灵活且具有未来性的解决方案，IP分配必须尽可能不固定，并且可以采用规则来配置渲染，以允许更好地使用IP分配。
- en: Using an IP allocation engine in combination with nested definitions, it is
    possible to reserve IPs that are essential for device identification, such as
    loopbacks, and leave other IP ranges to be associated to network interfaces.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 结合使用IP分配引擎和嵌套定义，可以预留用于设备标识的基本IP地址，例如回环地址，并将其他IP地址范围留给网络接口关联。
- en: One enhancement that can be made when IP addresses are not fixed is to have
    a service that translates the IP address to a name associated with the network
    definition files. That can be done using DNS, for instance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当IP地址不固定时，可以进行的改进之一是拥有一个将IP地址转换为与网络定义文件关联的名称的服务。例如，可以使用DNS来完成这项工作。
- en: The strategy of having less-fixed IPs in the definitions will allow a more flexible
    solution and avoid complications for the network definition files.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义中使用较少固定的IP地址将允许更灵活的解决方案，并避免网络定义文件中的复杂性。
- en: Using files for definitions
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用文件进行定义
- en: When creating definitions, the best practice is to use plain files, not databases
    or any other storage method. This will allow engineers to have a complete source
    of truth without dependency on any system or application, thus the files can be
    read even after a catastrophic event with multiple system failures.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建定义时，最佳实践是使用纯文本文件，而不是数据库或其他存储方法。这将允许工程师拥有一个完整的真实来源，而不依赖于任何系统或应用程序，因此即使在发生多系统故障的灾难性事件后，文件也可以被读取。
- en: File format
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件格式
- en: Network automation should use only one file format across all network definitions.
    The file should be text-based but use a well-known format that enforces, among
    other things, typing. If the structure of the file is standard and easy to read,
    it will help engineers to review it if necessary.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 网络自动化应跨所有网络定义仅使用一种文件格式。文件应该是基于文本的，但应使用一种众所周知且强制执行（包括但不限于）输入的格式。如果文件结构标准化且易于阅读，则在必要时将有助于工程师进行审查。
- en: Names
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称
- en: Whenever associating names to network definitions, avoid acronyms or any sort
    of abbreviation. Although shortening can help engineers to type faster, it can
    create confusion and raise problems when humans have to investigate. Remember
    that you can always create hotkeys or aliases locally in your environment to type
    device names faster.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在将名称与网络定义关联时，应避免使用缩写或任何形式的缩写。虽然缩短名称可以帮助工程师更快地输入，但可能会造成混淆，并在人类需要调查时引发问题。请记住，您始终可以在本地环境中创建快捷键或别名来更快地输入设备名称。
- en: Some devices have a limit on string sizes for names, so use names wisely and
    describe as much as possible the device you are naming to avoid economizing space.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一些设备对名称的字符串大小有限制，因此请明智地使用名称，并尽可能详细地描述您命名的设备，以避免节省空间。
- en: This section has shown how important it is to examine some details when creating
    network definitions. We’ll now review the most common data representation types
    in our network definitions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本节已展示了在创建网络定义时检查一些细节的重要性。现在，我们将回顾我们网络定义中最常见的几种数据表示类型。
- en: Exploring different file types
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索不同的文件类型
- en: The examples that we have seen in this chapter had network definitions with
    files ending with `.yaml`, which is an indication that they are in YAML format.
    But why? Why not XML or JSON formats? Let’s explore the pros and cons of the most
    used file formats.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中看到的示例具有以`.yaml`结尾的文件，这是它们处于YAML格式的指示。但为什么是YAML而不是XML或JSON格式呢？让我们来探讨最常用文件格式的优缺点。
- en: For our network definitions, we want to choose a format that is easy to read
    by humans and systems, fast to parse, and small to store. Then we can write a
    large content of definitions in files without worrying about performance, reading
    difficulty, or storage issues.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的网络定义，我们希望选择一种既易于人类阅读又易于系统解析，且存储空间小的格式。这样我们就可以在文件中编写大量内容，而不用担心性能、阅读难度或存储问题。
- en: XML files
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML文件
- en: '**Extensible Markup Language** or **XML** is the oldest markup language of
    those described in this section, with the first implementation dated 1996\. Its
    first standard publication was created in 1998 by the World Wide Web Consortium
    as the version 1.0 specification.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展标记语言**或**XML**是本节中描述的最古老的标记语言，其首次实现日期为1996年。其第一个标准发布是由万维网联盟在1998年创建的1.0规范。'
- en: The main goals of the initial XML design were to create a markup language that
    was simple, could cover general cases, and was easy to use across the internet.
    Even though the initial idea was for XML to create documents, the language has
    been used for arbitrary data structures on client and server interactions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 初始XML设计的主要目标是创建一种简单、能覆盖通用情况且易于在互联网上使用的标记语言。尽管最初的想法是使用XML创建文档，但该语言已被用于客户端和服务器交互中的任意数据结构。
- en: Because of its schema system, XML can use several media types. In 2001, IETF
    published the RFC3023, which described all possible media types, including `application/xml`
    and `text/xml`. In 2014, IETF published RFC7303, which refined the standards for
    media types and rendered RFC3023 obsolete.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其模式系统，XML可以使用多种媒体类型。2001年，IETF发布了RFC3023，描述了所有可能的媒体类型，包括`application/xml`和`text/xml`。2014年，IETF发布了RFC7303，细化了媒体类型的标准，使RFC3023过时。
- en: 'Here is an example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that in the example, we only have two data values (the highlighted IP addresses);
    the rest is markup overhead.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在示例中，我们只有两个数据值（突出显示的IP地址）；其余的都是标记开销。
- en: 'Here are the pros and cons:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是优缺点：
- en: 'Pros:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优点：
- en: More flexible for representing general data
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更灵活地表示通用数据
- en: 'Cons:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：
- en: Slow to process because of its complexity
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其复杂性，处理速度慢
- en: Lots of overhead from using many repetitive structure markers
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用许多重复的结构标记带来的开销很大
- en: Less human-readable
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不太易读
- en: Is prone to redundancies in structure
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构容易出现冗余
- en: JSON files
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON文件
- en: '**JavaScript Object Notation**, or **JSON**, is a newer method for data interchange
    representation compared to XML, with the original specification having been done
    by Douglas Crockford in the early 2000s. In 2004, IETF published an informational
    RFC4627, but only in 2014 did IETF create the RFC7159 standard. Now the latest
    standard is RFC8259.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法**，或**JSON**，与XML相比，是一种较新的数据交换表示方法，原始规范由道格拉斯·克罗克福德在21世纪初制定。2004年，IETF发布了信息性RFC4627，但直到2014年，IETF才创建了RFC7159标准。现在最新的标准是RFC8259。'
- en: 'JSON, like objects in JavaScript, has primitive types such as string, Boolean,
    number, and null. The structure in JSON consists of a key name and a value surrounded
    by a pair of curly brackets, as in `{"key": <value>}`. The key name is always
    a string. Here is an example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'JSON，就像JavaScript中的对象一样，具有原始类型，如字符串、布尔值、数字和null。JSON的结构由一对花括号包围的键名和值组成，如`{"key":
    <value>}`。键名始终是字符串。以下是一个例子：'
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that JSON carries much less overhead than XML.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，JSON的开销比XML小得多。
- en: 'The preceding representation can also be written in one line, but it is not
    easy to read:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表示也可以写在一行中，但不易阅读：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here are the pros and cons:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是优缺点：
- en: 'Pros:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优点：
- en: Simpler and faster than XML
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比XML简单且更快
- en: Better parsing performance
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的解析性能
- en: Loading truncated files is avoided
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免加载截断的文件
- en: 'Cons:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：
- en: Does not support comments
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持注释
- en: Does not allow aliases
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许别名
- en: Carries more overhead than other formats
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比其他格式有更多的开销
- en: Is not human-readable, depending on the format
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可读，取决于格式
- en: YAML files
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: YAML文件
- en: '**YAML** was originally an acronym for **Yet Another Markup Language** because
    it was created after the proliferation of markup languages such as XML and HTML
    in late 1990\. The creator Clark Evans wanted YAML to sound different, so the
    name was changed to **YAML Ain’t Markup Language**, a recursive acronym, to differentiate
    the purpose of YAML from other markup languages. The standard version 1.0 was
    published in 2004 and the latest version, 1.2.2, was published in 2021.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**YAML** 最初是 **Yet Another Markup Language** 的缩写，因为它是在 1990 年代末 XML 和 HTML
    等标记语言大量涌现之后创建的。创建者 Clark Evans 希望YAML听起来不同，因此将名称改为 **YAML Ain’t Markup Language**，这是一个递归缩写，用以区分
    YAML 与其他标记语言的目的。标准版本 1.0 于 2004 年发布，最新版本 1.2.2 于 2021 年发布。'
- en: YAML is intended to be human-readable and its data representation requires the
    use of indentation and new lines, which are used for delimitation and the grouping
    of data; this is different from JSON, which doesn’t actually require newlines
    or indentation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 旨在易于人类阅读，其数据表示需要使用缩进和新行，这些用于界定和分组数据；这与 JSON 不同，JSON 实际上不需要新行或缩进。
- en: YAML also supports advanced features that are not supported by other data representation
    languages, such as anchors and references, which are very useful for avoiding
    repetition and data errors. Natively, YAML encodes scalars (such as strings, integers,
    and floats), dictionaries (or maps), and lists.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 还支持其他数据表示语言不支持的高级功能，例如锚点和引用，这对于避免重复和数据错误非常有用。YAML 本地编码标量（如字符串、整数和浮点数）、字典（或映射）和列表。
- en: 'Here is an example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, YAML has an even shorter representation and is very easy to
    read. As opposed to JSON, though, it can’t be represented in just one line as
    the format alters the data representation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，YAML 有更简短的表现形式，并且非常易于阅读。然而，与 JSON 不同，它不能仅用一行表示，因为格式改变了数据表示。
- en: 'Here are the pros and cons:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是优缺点：
- en: 'Pros:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优点：
- en: Simpler and smaller
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更简单、更小
- en: Easy to read
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于阅读
- en: Allows aliases and anchors
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许别名和锚点
- en: Allows comments
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许注释
- en: 'Cons:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：
- en: Not as fast to parse as JSON
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不如 JSON 解析快
- en: There are other formats, such as **TOML**, **HOCON**, and **HCL**. Each of them
    has its advantages and disadvantages, but for our network automation and for most
    of our network definitions, YAML is the best option so far. It is also the most
    common one in network definitions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他格式，例如 **TOML**、**HOCON** 和 **HCL**。每个都有其优缺点，但就我们的网络自动化和大多数网络定义而言，YAML 仍然是迄今为止的最佳选择。它也是网络定义中最常见的格式。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored how network automation and engineers can benefit
    from having a proper configuration and network definition solution. It is not
    easy to grow a network with minimal human interaction and low dependency on network
    vendors and operating system versions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了网络自动化和工程师如何从拥有适当的配置和网络定义解决方案中受益。在没有最小化人工交互和降低对网络供应商和操作系统版本的依赖的情况下，增长网络并不容易。
- en: You are now familiar with network configuration issues and how to tackle them.
    You are able to distinguish the stages of a deployment pipeline. You are also
    able to create a robust network definition to feed an automated router configuration
    render and choose the best file type to represent the network definition.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在熟悉了网络配置问题及其解决方法。你能够区分部署管道的阶段。你也能够创建一个健壮的网络定义，以供自动路由器配置渲染，并选择最佳文件类型来表示网络定义。
- en: The next chapter will cover network programming by looking at what we should
    and should not do when writing code for networks.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将通过网络编程的视角，探讨在编写网络代码时我们应该做什么和不应该做什么。
- en: 'Part 2: Network Programming for Automation'
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：自动化网络编程
- en: The second part of the book is focused more on the programming aspects of network
    automation. This includes a description of the popular libraries, runtime performance,
    scaling aspects, error handling, logging, and more. Go and Python are used, and,
    in some cases, there are comparable examples to show how either language can be
    used for better network automation work.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 书的第二部分更侧重于网络自动化的编程方面。这包括对流行库、运行时性能、扩展性、错误处理、日志记录等的描述。使用了 Go 和 Python，在某些情况下，还提供了类似示例来展示如何使用这两种语言进行更好的网络自动化工作。
- en: 'This part has the following chapters:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B18165_05.xhtml#_idTextAnchor127), *Dos and Don’ts for Network
    Programming*'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 5 章*](B18165_05.xhtml#_idTextAnchor127)，*网络编程的做与不做*'
- en: '[*Chapter 6*](B18165_06.xhtml#_idTextAnchor166), *Using Go and Python for Network
    Programming*'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18165_06.xhtml#_idTextAnchor166), *使用Go和Python进行网络编程*'
- en: '[*Chapter 7*](B18165_07.xhtml#_idTextAnchor183), *Error Handling and Logging*'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18165_07.xhtml#_idTextAnchor183), *错误处理和日志记录*'
- en: '[*Chapter 8*](B18165_08.xhtml#_idTextAnchor195), *Scaling Your Code*'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18165_08.xhtml#_idTextAnchor195), *代码扩展*'
