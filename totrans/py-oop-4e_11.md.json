["```py\nimport contextlib\nimport socket\ndef main_1() -> None:\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind((\"localhost\", 2401))\n    server.listen(1)\n    with contextlib.closing(server):\n        while True:\n            client, addr = server.accept()\n            dice_response(client)\n            client.close() \n```", "```py\ndef dice_response(client: socket.socket) -> None:\n    request = client.recv(1024)\n    try:\n        response = dice.dice_roller(request)\n    except (ValueError, KeyError) as ex:\n        response = repr(ex).encode(\"utf-8\")\n    client.send(response) \n```", "```py\nimport random\ndef dice_roller(request: bytes) -> bytes:\n    request_text = request.decode(\"utf-8\")\n    numbers = [random.randint(1, 6) for _ in range(6)]\n    response = f\"{request_text} = {numbers}\"\n    return response.encode(\"utf-8\") \n```", "```py\nimport socket\ndef main() -> None:\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.connect((\"localhost\", 2401))\n    count = input(\"How many rolls: \") or \"1\"\n    pattern = input(\"Dice pattern nd6[dk+-]a: \") or \"d6\"\n    command = f\"Dice {count} {pattern}\"\n    server.send(command.encode(\"utf8\"))\n    response = server.recv(1024)\n    print(response.decode(\"utf-8\"))\n    server.close()\nif __name__ == \"__main__\":\n    main() \n```", "```py\n    python src/socket_server.py \n    ```", "```py\n    python src/socket_client.py \n    ```", "```py\n    How many rolls: 2\n    Dice pattern nd6[dk+-]a: d6 \n    ```", "```py\nclass LogSocket:\n    def __init__(self, socket: socket.socket) -> None:\n        self.socket = socket\n    def recv(self, count: int = 0) -> bytes:\n        data = self.socket.recv(count)\n        print(\n            f\"Receiving {data!r} from {self.socket.getpeername()[0]}\"\n        )\n        return data\n    def send(self, data: bytes) -> None:\n        print(f\"Sending {data!r} to {self.socket.getpeername()[0]}\")\n        self.socket.send(data)\n    def close(self) -> None:\n        self.socket.close() \n```", "```py\ndef main_2() -> None:\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind((\"localhost\", 2401))\n    server.listen(1)\n    with contextlib.closing(server):\n        while True:\n            client, addr = server.accept()\n            logging_socket = cast(socket.socket, LogSocket(client))\n            dice_response(logging_socket)\n            client.close() \n```", "```py\nAddress = Tuple[str, int]\nclass LogRoller:\n    def __init__(\n            self, \n            dice: Callable[[bytes], bytes], \n            remote_addr: Address\n    ) -> None:\n        self.dice_roller = dice\n        self.remote_addr = remote_addr\n    def __call__(self, request: bytes) -> bytes:\n        print(f\"Receiving {request!r} from {self.remote_addr}\")\n        dice_roller = self.dice_roller\n        response = dice_roller(request)\n        print(f\"Sending {response!r} to {self.remote_addr}\")\n        return response \n```", "```py\nimport gzip\nimport io\nclass ZipRoller:\n    def __init__(self, dice: Callable[[bytes], bytes]) -> None:\n        self.dice_roller = dice\n    def __call__(self, request: bytes) -> bytes:\n        dice_roller = self.dice_roller\n        response = dice_roller(request)\n        buffer = io.BytesIO()\n        with gzip.GzipFile(fileobj=buffer, mode=\"w\") as zipfile:\n            zipfile.write(response)\n        return buffer.getvalue() \n```", "```py\ndef dice_response(client: socket.socket) -> None:\n    request = client.recv(1024)\n    try:\n        remote_addr = client.getpeername()\n        roller_1 = ZipRoller(dice.dice_roller)\n        roller_2 = LogRoller(roller_1, remote_addr=remote_addr)\n        response = roller_2(request)\n    except (ValueError, KeyError) as ex:\n        response = repr(ex).encode(\"utf-8\")\n    client.send(response) \n```", "```py\nif config.zip_feature:\n    roller_1 = ZipRoller(dice.dice_roller)\nelse:\n    roller_1 = dice.dice_roller \n```", "```py\nfrom functools import wraps\ndef log_args(function: Callable[..., Any]) -> Callable[..., Any]:\n    @wraps(function)\n    def wrapped_function(*args: Any, **kwargs: Any) -> Any:\n        print(f\"Calling {function.__name__}(*{args}, **{kwargs})\")\n        result = function(*args, **kwargs)\n        return result\n    return wrapped_function \n```", "```py\ndef test1(a: int, b: int, c: int) -> float:\n    return sum(range(a, b + 1)) / c\ntest1 = log_args(test1) \n```", "```py\n>>> test1(1, 9, 2)\nCalling test1(*(1, 9, 2), **{})\n22.5 \n```", "```py\n@log_args\ndef test1(a: int, b: int, c: int) -> float:\n    return sum(range(a, b + 1)) / c \n```", "```py\n>>> from math import factorial\n>>> def binom(n: int, k: int) -> int:\n...     return factorial(n) // (factorial(k) * factorial(n-k))\n>>> f\"6-card deals: {binom(52, 6):,d}\"\n'6-card deals: 20,358,520' \n```", "```py\n>>> from math import factorial\n>>> from functools import lru_cache\n>>> @lru_cache(64)\n... def binom(n: int, k: int) -> int:\n...     return factorial(n) // (factorial(k) * factorial(n-k)) \n```", "```py\nclass NamedLogger:\n    def __init__(self, logger_name: str) -> None:\n        self.logger = logging.getLogger(logger_name)\n    def __call__(\n           self, \n           function: Callable[..., Any]\n    ) -> Callable[..., Any]:\n        @wraps(function)\n        def wrapped_function(*args: Any, **kwargs: Any) -> Any:\n            start = time.perf_counter()\n            try:\n                result = function(*args, **kwargs)\n                μs = (time.perf_counter() - start) * 1_000_000\n                self.logger.info(\n                    f\"{function.__name__}, { μs:.1f}μs\")\n                return result\n            except Exception as ex:\n                μs = (time.perf_counter() - start) * 1_000_000\n                self.logger.error(\n                    f\"{ex}, {function.__name__}, { μs:.1f}μs\")\n                raise\n        return wrapped_function \n```", "```py\n>>> @NamedLogger(\"log4\")\n... def test4(median: float, sample: float) -> float:\n...     return abs(sample-median) \n```", "```py\nfrom __future__ import annotations\nfrom typing import Protocol\nclass Observer(Protocol):\n    def __call__(self) -> None:\n        ...\nclass Observable:\n    def __init__(self) -> None:\n        self._observers: list[Observer] = []\n    def attach(self, observer: Observer) -> None:\n        self._observers.append(observer)\n    def detach(self, observer: Observer) -> None:\n        self._observers.remove(observer)\n    def _notify_observers(self) -> None:\n        for observer in self._observers:\n            observer() \n```", "```py\nfrom typing import List\nHand = List[int]\nclass ZonkHandHistory(Observable):\n    def __init__(self, player: str, dice_set: Dice) -> None:\n        super().__init__()\n        self.player = player\n        self.dice_set = dice_set\n        self.rolls: list[Hand]\n    def start(self) -> Hand:\n        self.dice_set.roll()\n        self.rolls = [self.dice_set.dice]\n        self._notify_observers()  # State change\n        return self.dice_set.dice\n    def roll(self) -> Hand:\n        self.dice_set.roll()\n        self.rolls.append(self.dice_set.dice)\n        self._notify_observers()  # State change\n        return self.dice_set.dice \n```", "```py\nclass SaveZonkHand(Observer):\n    def __init__(self, hand: ZonkHandHistory) -> None:\n        self.hand = hand\n        self.count = 0\n    def __call__(self) -> None:\n        self.count += 1\n        message = {\n            \"player\": self.hand.player,\n            \"sequence\": self.count,\n            \"hands\": json.dumps(self.hand.rolls),\n            \"time\": time.time(),\n        }\n        print(f\"SaveZonkHand {message}\") \n```", "```py\n>>> d = Dice.from_text(\"6d6\")\n>>> player = ZonkHandHistory(\"Bo\", d)\n>>> save_history = SaveZonkHand(player)\n>>> player.attach(save_history)\n>>> r1 = player.start()\nSaveZonkHand {'player': 'Bo', 'sequence': 1, 'hands': '[[1, 1, 2, 3, 6, 6]]', 'time': 1609619907.52109}\n>>> r1\n[1, 1, 2, 3, 6, 6]\n>>> r2 = player.roll()\nSaveZonkHand {'player': 'Bo', 'sequence': 2, 'hands': '[[1, 1, 2, 3, 6, 6], [1, 2, 2, 6, 6, 6]]', 'time': ...} \n```", "```py\nclass ThreePairZonkHand:\n    \"\"\"Observer of ZonkHandHistory\"\"\"\n    def __init__(self, hand: ZonkHandHistory) -> None:\n        self.hand = hand\n        self.zonked = False\n    def __call__(self) -> None:\n        last_roll = self.hand.rolls[-1]\n        distinct_values = set(last_roll)\n        self.zonked = len(distinct_values) == 3 and all(\n            last_roll.count(v) == 2 for v in distinct_values\n        )\n        if self.zonked:\n            print(\"3 Pair Zonk!\") \n```", "```py\nimport abc\nfrom pathlib import Path\nfrom PIL import Image  # type: ignore [import]\nfrom typing import Tuple\nSize = Tuple[int, int]\nclass FillAlgorithm(abc.ABC):\n    @abc.abstractmethod\n    def make_background(\n            self, \n            img_file: Path, \n            desktop_size: Size\n    ) -> Image:\n        pass \n```", "```py\nclass TiledStrategy(FillAlgorithm):\n    def make_background(\n            self, \n            img_file: Path, \n            desktop_size: Size\n    ) -> Image:\n        in_img = Image.open(img_file)\n        out_img = Image.new(\"RGB\", desktop_size)\n        num_tiles = [\n            o // i + 1 for o, i in zip(out_img.size, in_img.size)]\n        for x in range(num_tiles[0]):\n            for y in range(num_tiles[1]):\n                out_img.paste(\n                    in_img,\n                    (\n                        in_img.size[0] * x,\n                        in_img.size[1] * y,\n                        in_img.size[0] * (x + 1),\n                        in_img.size[1] * (y + 1),\n                    ),\n                )\n        return out_img \n```", "```py\nclass CenteredStrategy(FillAlgorithm):\n    def make_background(\n            self, \n            img_file: Path, \n            desktop_size: Size\n    ) -> Image:\n        in_img = Image.open(img_file)\n        out_img = Image.new(\"RGB\", desktop_size)\n        left = (out_img.size[0] - in_img.size[0]) // 2\n        top = (out_img.size[1] - in_img.size[1]) // 2\n        out_img.paste(\n            in_img,\n            (left, top, left + in_img.size[0], top + in_img.size[1]),\n        )\n        return out_img \n```", "```py\nclass ScaledStrategy(FillAlgorithm):\n    def make_background(\n            self, \n            img_file: Path, \n            desktop_size: Size\n    ) -> Image:\n        in_img = Image.open(img_file)\n        out_img = in_img.resize(desktop_size)\n        return out_img \n```", "```py\nclass Resizer:\n    def __init__(self, algorithm: FillAlgorithm) -> None:\n        self.algorithm = algorithm\n    def resize(self, image_file: Path, size: Size) -> Image:\n        result = self.algorithm.make_background(image_file, size)\n        return result \n```", "```py\ndef main() -> None:\n    image_file = Path.cwd() / \"boat.png\"\n    tiled_desktop = Resizer(TiledStrategy())\n    tiled_image = tiled_desktop.resize(image_file, (1920, 1080))\n    tiled_image.show() \n```", "```py\nFillAlgorithm = Callable[[Image, Size], Image] \n```", "```py\ndef dice_roller(request: bytes) -> bytes:\n    request_text = request.decode(\"utf-8\")\n    numbers = [random.randint(1, 6) for _ in range(6)]\n    response = f\"{request_text} = {numbers}\"\n    return response.encode(\"utf-8\") \n```", "```py\ndice_pattern = re.compile(r\"(?P<n>\\d*)d(?P<d>\\d+)(?P<a>[dk+-]\\d+)*\") \n```", "```py\nclass Dice:\n    def __init__(self, n: int, d: int, *adj: Adjustment) -> None:\n        self.adjustments = [cast(Adjustment, Roll(n, d))] + list(adj)\n        self.dice: list[int]\n        self.modifier: int\n    def roll(self) -> int:\n        for a in self.adjustments:\n            a.apply(self)\n        return sum(self.dice) + self.modifier \n```", "```py\nclass Adjustment(abc.ABC):\n    def __init__(self, amount: int) -> None:\n        self.amount = amount\n    @abc.abstractmethod\n    def apply(self, dice: \"Dice\") -> None:\n        ...\nclass Roll(Adjustment):\n    def __init__(self, n: int, d: int) -> None:\n        self.n = n\n        self.d = d\n    def apply(self, dice: \"Dice\") -> None:\n        dice.dice = sorted(\n            random.randint(1, self.d) for _ in range(self.n))\n        dice.modifier = 0\nclass Drop(Adjustment):\n    def apply(self, dice: \"Dice\") -> None:\n        dice.dice = dice.dice[self.amount :]\nclass Keep(Adjustment):\n    def apply(self, dice: \"Dice\") -> None:\n        dice.dice = dice.dice[: self.amount]\nclass Plus(Adjustment):\n    def apply(self, dice: \"Dice\") -> None:\n        dice.modifier += self.amount\nclass Minus(Adjustment):\n    def apply(self, dice: \"Dice\") -> None:\n        dice.modifier -= self.amount \n```", "```py\n@classmethod\ndef from_text(cls, dice_text: str) -> \"Dice\":\n    dice_pattern = re.compile(\n        r\"(?P<n>\\d*)d(?P<d>\\d+)(?P<a>[dk+-]\\d+)*\")\n    adjustment_pattern = re.compile(r\"([dk+-])(\\d+)\")\n    adj_class: dict[str, Type[Adjustment]] = {\n        \"d\": Drop,\n        \"k\": Keep,\n        \"+\": Plus,\n        \"-\": Minus,\n    }\n    if (dice_match := dice_pattern.match(dice_text)) is None:\n        raise ValueError(f\"Error in {dice_text!r}\")\n    n = int(dice_match.group(\"n\")) if dice_match.group(\"n\") else 1\n    d = int(dice_match.group(\"d\"))\n    adjustment_matches = adjustment_pattern.finditer(\n        dice_match.group(\"a\") or \"\")\n    adjustments = [\n        adj_class[a.group(1)](int(a.group(2))) \n        for a in adjustment_matches\n    ]\n    return cls(n, d, *adjustments) \n```", "```py\n dice.Dice(4, dice.D6, dice.Keep(3)) \n```", "```py\n$GPGLL,3723.2475,N,12158.3416,W,161229.487,A,A*41 \n```", "```py\nclass NMEA_State:\n    def __init__(self, message: \"Message\") -> None:\n        self.message = message\n    def feed_byte(self, input: int) -> \"NMEA_State\":\n        return self\n    def valid(self) -> bool:\n        return False\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({self.message})\" \n```", "```py\nclass Message:\n    def __init__(self) -> None:\n        self.body = bytearray(80)\n        self.checksum_source = bytearray(2)\n        self.body_len = 0\n        self.checksum_len = 0\n        self.checksum_computed = 0\n    def reset(self) -> None:\n        self.body_len = 0\n        self.checksum_len = 0\n        self.checksum_computed = 0\n    def body_append(self, input: int) -> int:\n        self.body[self.body_len] = input\n        self.body_len += 1\n        self.checksum_computed ^= input\n        return self.body_len\n    def checksum_append(self, input: int) -> int:\n        self.checksum_source[self.checksum_len] = input\n        self.checksum_len += 1\n        return self.checksum_len\n    @property\n    def valid(self) -> bool:\n        return (\n            self.checksum_len == 2\n            and int(self.checksum_source, 16) == self.checksum_computed\n        ) \n```", "```py\nclass Reader:\n    def __init__(self) -> None:\n        self.buffer = Message()\n        self.state: NMEA_State = Waiting(self.buffer)\n    def read(self, source: Iterable[bytes]) -> Iterator[Message]:\n        for byte in source:\n            self.state = self.state.feed_byte(cast(int, byte))\n            if self.buffer.valid:\n                yield self.buffer\n                self.buffer = Message()\n                self.state = Waiting(self.buffer) \n```", "```py\nclass Waiting(NMEA_State):\n    def feed_byte(self, input: int) -> NMEA_State:\n        if input == ord(b\"$\"):\n            return Header(self.message)\n        return self \n```", "```py\nclass Header(NMEA_State):\n    def __init__(self, message: \"Message\") -> None:\n        self.message = message\n        self.message.reset()\n    def feed_byte(self, input: int) -> NMEA_State:\n        if input == ord(b\"$\"):\n            return Header(self.message)\n        size = self.message.body_append(input)\n        if size == 5:\n            return Body(self.message)\n        return self \n```", "```py\nclass Body(NMEA_State):\n    def feed_byte(self, input: int) -> NMEA_State:\n        if input == ord(b\"$\"):\n            return Header(self.message)\n        if input == ord(b\"*\"):\n            return Checksum(self.message)\n        self.message.body_append(input)\n        return self \n```", "```py\nclass Checksum(NMEA_State):\n    def feed_byte(self, input: int) -> NMEA_State:\n        if input == ord(b\"$\"):\n            return Header(self.message)\n        if input in {ord(b\"\\n\"), ord(b\"\\r\")}:\n            # Incomplete checksum... Will be invalid.\n            return End(self.message)\n        size = self.message.checksum_append(input)\n        if size == 2:\n            return End(self.message)\n        return self \n```", "```py\nclass End(NMEA_State):\n    def feed_byte(self, input: int) -> NMEA_State:\n        if input == ord(b\"$\"):\n            return Header(self.message)\n        elif input not in {ord(b\"\\n\"), ord(b\"\\r\")}:\n            return Waiting(self.message)\n        return self\n    def valid(self) -> bool:\n        return self.message.valid \n```", "```py\n>>> message = b'''\n... $GPGGA,161229.487,3723.2475,N,12158.3416,W,1,07,1.0,9.0,M,,,,0000*18\n... $GPGLL,3723.2475,N,12158.3416,W,161229.487,A,A*41\n... '''\n>>> rdr = Reader()\n>>> result = list(rdr.read(message))\n[Message(bytearray(b'GPGGA,161229.487,3723.2475,N,12158.3416,W,1,07,1.0,9.0,M,,,,0000'), bytearray(b'18'), computed=18), Message(bytearray(b'GPGLL,3723.2475,N,12158.3416,W,161229.487,A,A'), bytearray(b'41'), computed=41)] \n```", "```py\n>>> class OneOnly: \n...     _singleton = None \n...     def __new__(cls, *args, **kwargs): \n...         if not cls._singleton: \n...             cls._singleton = super().__new__(cls, *args, **kwargs) \n...         return cls._singleton \n```", "```py\n>>> o1 = OneOnly()\n>>> o2 = OneOnly()\n>>> o1 == o2\nTrue\n>>> id(o1) == id(o2)\nTrue\n>>> o1\n<__main__.OneOnly object at 0x7fd9c49ef2b0>\n>>> o2\n<__main__.OneOnly object at 0x7fd9c49ef2b0> \n```", "```py\nclass NMEA_State:\n    def enter(self, message: \"Message\") -> \"NMEA_State\":\n        return self\n    def feed_byte(\n            self, \n            message: \"Message\", \n            input: int\n    ) -> \"NMEA_State\":\n        return self\n    def valid(self, message: \"Message\") -> bool:\n        return False\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}()\" \n```", "```py\nclass Waiting(NMEA_State):\n    def feed_byte(\n            self, \n            message: \"Message\", \n            input: int\n    ) -> \"NMEA_State\":\n        return self\n        if input == ord(b\"$\"):\n            return HEADER\n        return self\nclass Header(NMEA_State):\n    def enter(self, message: \"Message\") -> \"NMEA_State\":\n        message.reset()\n        return self\n    def feed_byte(\n            self, \n            message: \"Message\", \n            input: int\n    ) -> \"NMEA_State\":\n        return self\n        if input == ord(b\"$\"):\n            return HEADER\n        size = message.body_append(input)\n        if size == 5:\n            return BODY\n        return self\nclass Body(NMEA_State):\n    def feed_byte(\n            self, \n            message: \"Message\", \n            input: int\n    ) -> \"NMEA_State\":\n        return self\n        if input == ord(b\"$\"):\n            return HEADER\n        if input == ord(b\"*\"):\n            return CHECKSUM\n        size = message.body_append(input)\n        return self\nclass Checksum(NMEA_State):\n    def feed_byte(\n            self, \n            message: \"Message\", \n            input: int\n    ) -> \"NMEA_State\":\n        return self\n        if input == ord(b\"$\"):\n            return HEADER\n        if input in {ord(b\"\\n\"), ord(b\"\\r\")}:\n            # Incomplete checksum... Will be invalid.\n            return END\n        size = message.checksum_append(input)\n        if size == 2:\n            return END\n        return self\nclass End(NMEA_State):\n    def feed_byte(\n            self, \n            message: \"Message\", \n            input: int\n    ) -> \"NMEA_State\":\n        return self\n        if input == ord(b\"$\"):\n            return HEADER\n        elif input not in {ord(b\"\\n\"), ord(b\"\\r\")}:\n            return WAITING\n        return self\n    def valid(self, message: \"Message\") -> bool:\n        return message.valid \n```", "```py\nWAITING = Waiting()\nHEADER = Header()\nBODY = Body()\nCHECKSUM = Checksum()\nEND = End() \n```", "```py\nclass Reader:\n    def __init__(self) -> None:\n        self.buffer = Message()\n        self.state: NMEA_State = WAITING\n    def read(self, source: Iterable[bytes]) -> Iterator[Message]:\n        for byte in source:\n            new_state = self.state.feed_byte(\n            self.buffer, cast(int, byte)\n            )\n            if self.buffer.valid:\n                yield self.buffer\n                self.buffer = Message()\n                new_state = WAITING\n            if new_state != self.state:\n                new_state.enter(self.buffer)\n                self.state = new_state \n```", "```py\nfrom typing import Protocol\nfrom math import hypot\nclass Distance(Protocol):\n    def distance(\n            self, \n            s1: TrainingKnownSample, \n            s2: AnySample\n    ) -> float:\n        ...\nclass Euclidean(Distance):\n    def distance(self, s1: TrainingKnownSample, s2: AnySample) -> float:\n      return hypot(\n        (s1.sample.sample.sepal_length - s2.sample.sepal_length)**2,\n        (s1.sample.sample.sepal_width - s2.sample.sepal_width)**2,\n        (s1.sample.sample.petal_length - s2.sample.petal_length)**2,\n        (s1.sample.sample.petal_width - s2.sample.petal_width)**2,\n      ) \n```", "```py\nclass Manhattan(Distance):\n    def distance(self, s1: TrainingKnownSample, s2: AnySample) -> float:\n        return sum(\n            [\n                abs(s1.sample.sample.sepal_length - s2.sample.sepal_length),\n                abs(s1.sample.sample.sepal_width - s2.sample.sepal_width),\n                abs(s1.sample.sample.petal_length - s2.sample.petal_length),\n                abs(s1.sample.sample.petal_width - s2.sample.petal_width),\n            ]\n        )\nclass Chebyshev(Distance):\n    def distance(self, s1: TrainingKnownSample, s2: AnySample) -> float:\n        return max(\n            [\n                abs(s1.sample.sample.sepal_length - s2.sample.sepal_length),\n                abs(s1.sample.sample.sepal_width - s2.sample.sepal_width),\n                abs(s1.sample.sample.petal_length - s2.sample.petal_length),\n                abs(s1.sample.sample.petal_width - s2.sample.petal_width),\n            ]\n        ) \n```", "```py\nFrom collections import Counter\ndef k_nn_1(\n        k: int, \n        dist: DistanceFunc, \n        training_data: TrainingList, \n        unknown: AnySample\n) -> str:\n    distances = sorted(\n        map(lambda t: Measured(dist(t, unknown), t), training_data))\n    k_nearest = distances[:k]\n    k_frequencies: Counter[str] = Counter(\n        s.sample.sample.species for s in k_nearest\n    )\n    mode, fq = k_frequencies.most_common(1)[0]\n    return mode \n```", "```py\nclass Hyperparameter(NamedTuple):\n    k: int\n    distance: Distance\n    training_data: TrainingList\n    classifier: Classifier\n    def classify(self, unknown: AnySample) -> str:\n        classifier = self.classifier\n        distance = self.distance\n        return classifier(\n            self.k, distance.distance, self.training_data, unknown) \n```", "```py\n>>> data = [\n...     KnownSample(sample=Sample(1, 2, 3, 4), species=\"a\"),\n...     KnownSample(sample=Sample(2, 3, 4, 5), species=\"b\"),\n...     KnownSample(sample=Sample(3, 4, 5, 6), species=\"c\"),\n...     KnownSample(sample=Sample(4, 5, 6, 7), species=\"d\"),\n... ]\n>>> manhattan = Manhattan().distance\n>>> training_data = [TrainingKnownSample(s) for s in data]\n>>> h = Hyperparameter(1, manhattan, training_data, k_nn_1)\n>>> h.classify(UnknownSample(Sample(2, 3, 4, 5)))\n'b' \n```", "```py\ndef test(self, testing: TestingList) -> float:\n    classifier = self.classifier\n    distance = self.distance\n    test_results = (\n        ClassifiedKnownSample(\n            t.sample,\n            classifier(\n                self.k, distance.distance, \n                self.training_data, t.sample),\n        )\n        for t in testing\n    )\n    pass_fail = map(\n        lambda t: (1 if t.sample.species == t.classification else 0), \n        test_results\n    )\n    return sum(pass_fail) / len(testing) \n```", "```py\nclass Timing(NamedTuple):\n    k: int\n    distance_name: str\n    classifier_name: str\n    quality: float\n    time: float  # Milliseconds \n```", "```py\nimport time\nclass TestCommand:\n    def __init__(\n        self,\n        hyper_param: Hyperparameter,\n        testing: TestingList,\n    ) -> None:\n        self.hyperparameter = hyper_param\n        self.testing_samples = testing\n    def test(self) -> Timing:\n        start = time.perf_counter()\n        recall_score = self.hyperparameter.test(self.testing_samples)\n        end = time.perf_counter()\n        timing = Timing(\n            k=self.hyperparameter.k,\n            distance_name=\n                self.hyperparameter.distance.__class__.__name__,\n            classifier_name=\n                self.hyperparameter.classifier.__name__,\n            quality=recall_score,\n            time=round((end - start) * 1000.0, 3),\n        )\n        return timing \n```", "```py\ndef tuning(source: Path) -> None:\n    train, test = load(source)\n    scenarios = [\n        TestCommand(Hyperparameter(k, df, train, cl), test)\n        for k in range(3, 33, 2)\n        for df in (euclidean, manhattan, chebyshev)\n        for cl in (k_nn_1, k_nn_b, k_nn_q)\n    ]\n    timings = [s.test() for s in scenarios]\n    for t in timings:\n        if t.quality >= 1.0:\n            print(t) \n```"]