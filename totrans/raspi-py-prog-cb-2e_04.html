<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Creating Games and Graphics</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using IDLE3 to debug your programs</li><li class="listitem" style="list-style-type: disc">Drawing lines using a mouse on a Tkinter Canvas</li><li class="listitem" style="list-style-type: disc">Creating a bat and ball game</li><li class="listitem" style="list-style-type: disc">Creating an overhead scrolling game</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Introduction</h1></div></div></div><p>Games are often a great way to explore and extend your programming skills as they present an inherent motivating force to modify and improve your creation, add new features, and create new challenges. They are also great for sharing your ideas with others, even if they aren't interested in programming.</p><p>This chapter focuses on using the Tkinter Canvas widget to create and display objects on screen for the user to interact with. Using these techniques, a wide variety of games and applications can be created that are limited only by your own creativity.</p><p>We also take a quick look at using the debugger built into IDLE, a valuable tool for testing and developing your programs without the need to write extensive test code.</p><p>The first example demonstrates how we can monitor and make use of the mouse to create objects and draw directly on the <code class="literal">Canvas</code> widget. Next, we create a bat and ball game, which shows how the positions of objects can be controlled and how interactions between them can be detected and responded to. Finally, we take things a little further and use Tkinter to place our own graphics onto the <code class="literal">Canvas</code> widget to create an overhead view treasure hunt game.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Using IDLE3 to debug your programs</h1></div></div></div><p>A key<a class="indexterm" id="id327"/> aspect of programming is being able to test and debug your code, and a useful tool to achieve this is a debugger. The IDLE editor (make sure you use IDLE3 to support the Python 3 code we use in this book) includes a basic debugger. It allows you to step through your code, observe the values of local and global variables, and set breakpoints.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec78"/>How to do it…</h2></div></div></div><p>To enable the debugger, start IDLE3 and select <strong>Debugger</strong> from the <strong>Debug</strong> menu; it will open up the following window (if you are currently running some code, you will need to stop it first):</p><div><img alt="How to do it…" src="img/6623OT_04_01.jpg"/><div><p>The IDLE3 debugger window</p></div></div><p>Open up the code you want to test (via <strong>File</strong> | <strong>Open…</strong>) and try running it (<em>F5</em>). You will find that the code will not start, since the debugger has automatically stopped at the first line. The following screenshot shows the debugger has stopped on the first line of code in <code class="literal">filehandler.py</code>, which is <code class="literal">line 3: import os</code>:</p><div><img alt="How to do it…" src="img/6623OT_04_02.jpg"/><div><p>The IDLE3 debugger at the start of the code</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec79"/>How it works…</h2></div></div></div><p>The control<a class="indexterm" id="id328"/> buttons shown in the following screenshot allow you to run and/or jump through the code:</p><div><img alt="How it works…" src="img/6623OT_04_03.jpg"/><div><p>Debugger controls</p></div></div><p>The functions of the control buttons are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Go</strong>: This button will execute the code as normal.</li><li class="listitem" style="list-style-type: disc"><strong>Step</strong>: This button will execute the line of code one step at a time and then stop again. If a function is called, it will enter that function and allow you to step through that too.</li><li class="listitem" style="list-style-type: disc"><strong>Over</strong>: This button is like the <strong>Step</strong> command, but if there is a function call, it will execute the whole function and stop at the following line.</li><li class="listitem" style="list-style-type: disc"><strong>Out</strong>: This button will keep executing the code until it has completed the function it is currently in, continuing until you come out of the function.</li><li class="listitem" style="list-style-type: disc"><strong>Quit</strong>: This button ends the program immediately.</li></ul></div><p>In addition to<a class="indexterm" id="id329"/> the previously mentioned controls, you can <strong>Set Breakpoint</strong> and <strong>Clear Breakpoint</strong> directly within the code. A breakpoint is a marker that you can insert in the code (by right-clicking on the editor window), which the debugger will always break on (stop at) when it is reached, as shown in the following screenshot:</p><div><img alt="How it works…" src="img/6623OT_04_04.jpg"/><div><p>Set and clear breakpoints directly in your code</p></div></div><p>The checkboxes (on the right-hand side of the control buttons) allow you to choose what information to display when you step through the code or when the debugger stops somewhere due to a breakpoint. <strong>Stack</strong> is shown in the main window, which is similar to what you would see if the program hit an unhandled exception. The <strong>Stack</strong> option shows all the function calls made to get to the current position in the code, right up to the line it has stopped at. The <strong>Source</strong> option highlights the line of code currently being executed and, in some cases, the code inside the imported modules too (if they are non-compiled libraries).</p><p>You can also select whether to display <strong>Locals</strong> and/or <strong>Globals</strong>. By default, the <strong>Source</strong> and <strong>Globals</strong> options are usually disabled as they can make the process quite slow if there is a lot of data to display.</p><div><div><h3 class="title"><a id="note38"/>Note</h3><p>Python uses the concept of local and global variables to define the scope (where and when the variables are valid). Global variables are defined at the top level of the file and are visible from any point in the code after it has been defined. However, in order to alter its value from anywhere other than the top level, Python requires you to use the global keyword first. Without the global keyword, you will create a local copy with the same name (the value of which will be lost when you exit the function). Local variables are defined when you create a variable within a function; once outside of the function, the variable is destroyed and is not visible anymore.</p></div></div><p>Below <strong>Stack</strong> data<a class="indexterm" id="id330"/> are the <strong>Locals</strong>, in this case <code class="literal">aPhoto</code>, <code class="literal">filename</code>, and <code class="literal">self</code>. Then (if enabled), we have all the global values that are currently valid providing useful details about the status of the program (<code class="literal">DATE = 1</code>, <code class="literal">DEBUG = True</code>, <code class="literal">FOLDERSONLY = True</code>, and so on):</p><div><img alt="How it works…" src="img/6623OT_04_05.jpg"/><div><p>The Stack, Locals, and Globals options within the debugger</p></div></div><p>The debugger isn't particularly advanced, as it does not allow you to expand complex objects such as the <code class="literal">photohandler.Photo</code> object to see what data it contains. However, if required, you <a class="indexterm" id="id331"/>can adjust your code and assign the data you want to observe to some temporary variables during testing.</p><p>It is worth learning how to use the debugger as it is a much easier way to track down particular problems and check whether or not things are functioning as you expect them to.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Drawing lines using a mouse on Tkinter Canvas</h1></div></div></div><p>The Tkinter Canvas widget provides an area to create and draw objects on. The following script <a class="indexterm" id="id332"/>demonstrates how to use mouse events to<a class="indexterm" id="id333"/> interact with Tkinter. By detecting the mouse clicks, we can use Tkinter to draw a line that follows the movement of the mouse:</p><div><img alt="Drawing lines using a mouse on Tkinter Canvas" src="img/6623OT_04_06.jpg"/><div><p>A simple drawing application using Tkinter</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec80"/>Getting ready</h2></div></div></div><p>As before, we need to have Tkinter installed and either the Raspbian desktop running (<code class="literal">startx</code> from the command line) or an SSH session with X11 Forwarding and an X server running (see <a class="link" href="ch01.html" title="Chapter 1. Getting Started with a Raspberry Pi Computer">Chapter 1</a>, <em>Getting Started with a Raspberry Pi Computer</em>). We will also need a <a class="indexterm" id="id334"/>mouse connected.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec81"/>How to do it…</h2></div></div></div><p>Create the<a class="indexterm" id="id335"/> following script, <code class="literal">painting.py</code>:</p><div><pre class="programlisting">#!/usr/bin/python3
#painting.py
import tkinter as TK

#Set defaults
btn1pressed = False
newline = True

def main():
  root = TK.Tk()
  the_canvas = TK.Canvas(root)
  the_canvas.pack()
  the_canvas.bind("&lt;Motion&gt;", mousemove)
  the_canvas.bind("&lt;ButtonPress-1&gt;", mouse1press)
  the_canvas.bind("&lt;ButtonRelease-1&gt;", mouse1release)
  root.mainloop()

def mouse1press(event):
  global btn1pressed
  btn1pressed = True

def mouse1release(event):
  global btn1pressed, newline
  btn1pressed = False
  newline = True

def mousemove(event):
  if btn1pressed == True:
    global xorig, yorig, newline
    if newline == False:
      event.widget.create_line(xorig,yorig,event.x,event.y,
                               smooth=TK.TRUE)
    newline = False
    xorig = event.x
    yorig = event.y

if __name__ == "__main__":
  main()
#End</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec82"/>How it works…</h2></div></div></div><p>The Python code creates a Tkinter window that contains a <code class="literal">Canvas</code> object called <code class="literal">the_canvas</code>. We use the <code class="literal">bind</code> function here, which will bind a specific event that occurs on this widget (<code class="literal">the_canvas</code>) to a specific action or key press. In this case, we bind the <code class="literal">&lt;Motion&gt;</code> function of the mouse plus the click and release of the first mouse button (<code class="literal">&lt;ButtonPress-1&gt;</code> and <code class="literal">&lt;ButtonRelease-1&gt;</code>). Each of these events are then used to call the <code class="literal">mouse1press()</code>, <code class="literal">mouse1release()</code>, and <code class="literal">mousemove()</code> functions.</p><p>The logic<a class="indexterm" id="id336"/> here is as follows. We track the status of<a class="indexterm" id="id337"/> the mouse button using the <code class="literal">mouse1press()</code> and <code class="literal">mouse1release()</code> functions.</p><p>If the mouse has been clicked, the <code class="literal">mousemove()</code> function will check to see whether we are drawing a new line (we set new coordinates for this) or continuing an old one (we draw a line from the previous coordinates to the coordinates of the current event that has triggered <code class="literal">mousemove()</code>). We just need to ensure that we reset to the <code class="literal">newline</code> command whenever the mouse button is released to reset the start position of the line.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Creating a bat and ball game</h1></div></div></div><p>A classic bat and ball game can be created using the drawing tools of canvas and by detecting the<a class="indexterm" id="id338"/> collisions of the objects. The user will be able to control the green paddle using the left and right cursor keys to aim the ball at the bricks and hit them until they have all been destroyed.</p><div><img alt="Creating a bat and ball game" src="img/6623OT_04_07.jpg"/><div><p>Control the bat to aim the ball at the bricks</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec83"/>Getting ready</h2></div></div></div><p>This example<a class="indexterm" id="id339"/> requires graphical output, so you must have a screen and keyboard attached to the Raspberry Pi or use X11 Forwarding and X server if connected remotely from another computer.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec84"/>How to do it…</h2></div></div></div><p>Create the following script, <code class="literal">bouncingball.py</code>.</p><div><ol class="orderedlist arabic"><li class="listitem">First, import the <code class="literal">tkinter</code> and <code class="literal">time</code> modules, and define constants for the game graphics:<div><pre class="programlisting">#!/usr/bin/python3
# bouncingball.py
import tkinter as TK
import time

VERT,HOREZ=0,1
xTOP,yTOP = 0,1
xBTM,yBTM = 2,3
MAX_WIDTH,MAX_HEIGHT = 640,480
xSTART,ySTART = 100,200
BALL_SIZE=20
RUNNING=True</pre></div></li><li class="listitem">Next, create <a class="indexterm" id="id340"/>functions for closing the program, moving the paddle right and left, and for calculating the direction of the ball:<div><pre class="programlisting">def close():
  global RUNNING
  RUNNING=False
  root.destroy()

def move_right(event):
  if canv.coords(paddle)[xBTM]&lt;(MAX_WIDTH-7):
    canv.move(paddle, 7, 0)

def move_left(event):
  if canv.coords(paddle)[xTOP]&gt;7:
    canv.move(paddle, -7, 0)

def determineDir(ball,obj):
  global delta_x,delta_y
  if (ball[xTOP] == obj[xBTM]) or (ball[xBTM] == 
      obj[xTOP]):
    delta_x = -delta_x
  elif (ball[yTOP] == obj[yBTM]) or (ball[yBTM] == 
        obj[yTOP]):
    delta_y = -delta_y</pre></div></li><li class="listitem">Set up the <code class="literal">tkinter</code> window and define the canvas:<div><pre class="programlisting">root = TK.Tk()
root.title("Bouncing Ball")
root.geometry('%sx%s+%s+%s' %(MAX_WIDTH, MAX_HEIGHT, 100, 100))
root.bind('&lt;Right&gt;', move_right)
root.bind('&lt;Left&gt;', move_left)
root.protocol('WM_DELETE_WINDOW', close)

canv = TK.Canvas(root, highlightthickness=0)
canv.pack(fill='both', expand=True)</pre></div></li><li class="listitem">Add the borders, <code class="literal">ball</code>, and <code class="literal">paddle</code> objects to the canvas:<div><pre class="programlisting">top = canv.create_line(0, 0, MAX_WIDTH, 0, fill='blue',
                       tags=('top'))
left = canv.create_line(0, 0, 0, MAX_HEIGHT, fill='blue',
                        tags=('left'))
right = canv.create_line(MAX_WIDTH, 0, MAX_WIDTH, MAX_HEIGHT,
                         fill='blue', tags=('right'))
bottom = canv.create_line(0, MAX_HEIGHT, MAX_WIDTH, MAX_HEIGHT,
                          fill='blue', tags=('bottom'))

ball = canv.create_rectangle(0, 0, BALL_SIZE, BALL_SIZE,
                             outline='black', fill='black', 
                             tags=('ball'))
paddle = canv.create_rectangle(100, MAX_HEIGHT - 30, 150, 470,
                               outline='black', 
                               fill='green', tags=('rect'))</pre></div></li><li class="listitem">Draw all <a class="indexterm" id="id341"/>the bricks and set up the ball and paddle positions:<div><pre class="programlisting">brick=list()
for i in range(0,16):
  for row in range(0,4):
    brick.append(canv.create_rectangle(i*40, row*20,
                 ((i+1)*40)-2, ((row+1)*20)-2,
                 outline='black', fill='red',
                 tags=('rect')))

delta_x = delta_y = 1
xold,yold = xSTART,ySTART
canv.move(ball, xold, yold)</pre></div></li><li class="listitem">Create the main loop for the game to check for collisions and handle the movement of the paddle and ball:<div><pre class="programlisting">while RUNNING:
  objects = canv.find_overlapping(canv.coords(ball)[0],
                                  canv.coords(ball)[1],
                                  canv.coords(ball)[2],
                                  canv.coords(ball)[3])

  #Only change the direction once (so will bounce off 1st
  # block even if 2 are hit)
  dir_changed=False
  for obj in objects:
    if (obj != ball):
      if dir_changed==False:
        determineDir(canv.coords(ball),canv.coords(obj))
        dir_changed=True
      if (obj &gt;= brick[0]) and (obj &lt;= brick[len(brick)-1]):
        canv.delete(obj)
      if (obj == bottom):
        text = canv.create_text(300,100,text="YOU HAVE MISSED!")
        canv.coords(ball, (xSTART,ySTART,
                    xSTART+BALL_SIZE,ySTART+BALL_SIZE))
        delta_x = delta_y = 1
        canv.update()
        time.sleep(3)
        canv.delete(text)
  new_x, new_y = delta_x, delta_y
  canv.move(ball, new_x, new_y)

  canv.update()
  time.sleep(0.005)
#End</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec85"/>How it works…</h2></div></div></div><p>We create<a class="indexterm" id="id342"/> a Tkinter application that is 640 x 480 pixels and bind the <code class="literal">&lt;Right&gt;</code> and <code class="literal">&lt;Left&gt;</code> cursor keys to the <code class="literal">move_right()</code> and <code class="literal">move_left()</code> functions. We use <code class="literal">root.protocol('WM_DELETE_WINDOW', close)</code> to detect when the window is closed so that we can cleanly exit the program (via <code class="literal">close()</code>, which sets <code class="literal">RUNNING</code> to <code class="literal">False</code>).</p><p>We then add a <code class="literal">Canvas</code> widget to the application that will hold all our objects. We create the following objects: <code class="literal">top</code>, <code class="literal">left</code>, <code class="literal">right</code>, and <code class="literal">bottom</code>. These make up our bounding sides for our game area. The canvas coordinates are <code class="literal">0,0</code> in the top-left corner and <code class="literal">640,480</code> in the bottom-right corner, so the start and end coordinates can be determined for each side (using <code class="literal">canv.create_line(xStart, yStart, xEnd, yEnd)</code>).</p><div><img alt="How it works…" src="img/6623OT_04_08.jpg"/><div><p>The coordinates of the Canvas widget</p></div></div><p>You can also<a class="indexterm" id="id343"/> add multiple <code class="literal">tags</code> to the objects; <code class="literal">tags</code> are often useful for defining specific actions or behaviors of objects. For instance, they allow for different types of event to occur when specific objects or bricks are hit. We see more uses of <code class="literal">tags</code> in the next example.</p><p>Next, we define the ball and paddle objects, which are added using <code class="literal">canv.create_rectangle()</code>. This requires two sets of coordinates that define the opposite corners of the Incorrect image, should be the following image with the 4x16 bricks on objects (in this case, the top-left and bottom-right corners).</p><div><img alt="How it works…" src="img/6623OT_04_09.jpg"/><div><p>A tkinter rectangle is defined by the coordinates of the two corners.</p></div></div><p>Finally, we can create the bricks!</p><p>We want our bricks to be 40 x 20 pixels wide so we can fit 16 bricks across our game area of 640 pixels (in four rows). We can create a list of brick objects with their positions defined automatically, as shown in the following code:</p><div><pre class="programlisting">brick=list()
for i in range(0,16):
  for row in range(0,4):
    brick.append(canv.create_rectangle(i*40, row*20, 
                 ((i+1)*40)-2, ((row+1)*20)-2, outline='black', 
                 fill='red', tags=('rect')))</pre></div><p>A brick-like effect<a class="indexterm" id="id344"/> is provided by making the bricks slightly smaller (<code class="literal">-2</code>) to create a small gap.</p><div><img alt="How it works…" src="img/6623OT_04_10.jpg"/><div><p>Four rows of 16 bricks are generated at the top of Canvas</p></div></div><p>We now set the default settings before starting the main control loop. The movement of the ball will be governed by <code class="literal">delta_x</code> and <code class="literal">delta_y</code>, which are added to or subtracted from the ball's previous position in each cycle.</p><p>Next, we set the starting position of the ball and use the <code class="literal">canv.move()</code> function to move the ball by that amount. The <code class="literal">move()</code> function will add <code class="literal">100</code> to the <code class="literal">x</code> and <code class="literal">y</code> coordinates of the ball object, which was originally created at position <code class="literal">0,0</code>.</p><p>Now that everything is set up, the main loop can run; this will check that the ball has not hit anything (using the <code class="literal">canv.find_overlapping()</code> function), make any adjustments to the <code class="literal">delta_x</code> or <code class="literal">delta_y</code> values, and then apply them to move the ball to the next location.</p><p>The sign of <code class="literal">delta_x</code> and <code class="literal">delta_y</code> determines the direction of the ball. Positive values will make the ball travel diagonally downwards and towards the right, while <code class="literal">-delta_x</code> will make it travel towards the left, either downwards or upwards depending on whether <code class="literal">delta_y</code> is positive or negative.</p><p>After the ball has been moved, we use <code class="literal">canv.update()</code> to redraw any changes made to the display, and <code class="literal">time.sleep()</code> allows a small delay before checking and moving the ball again.</p><p>Object collisions<a class="indexterm" id="id345"/> are detected using the <code class="literal">canv.find_overlapping()</code> function. This returns a list of canvas objects that are found to be overlapping the bounds of a rectangle defined by the supplied coordinates. For example, in the case of the square ball, are any of the coordinates of the canvas objects within the space the ball is occupying?</p><div><img alt="How it works…" src="img/6623OT_04_11.jpg"/><div><p>The objects are checked to detect if they overlap each other</p></div></div><p>If the ball is found to be overlapping another object, such as the walls, the paddle, or one or more of the bricks, we need to determine which direction the ball should next travel in. Since we are using the coordinates of the ball as the area within which to check, the ball will always be listed so that we ignore them when we check the list of objects.</p><p>We use the <code class="literal">dir_changed</code> flag to ensure that if we hit two bricks at the same time, we do not change direction twice before we move the ball. Otherwise, this would cause the ball to continue moving in the same direction even though it has collided with the bricks.</p><p>So if the ball is overlapping something else, we can call <code class="literal">determineDir()</code> with the coordinates of the ball and the object to work out what the new direction should be.</p><p>When the ball collides with something, we want the ball to bounce off it; fortunately, this is easy to simulate as we just need to change the sign of either <code class="literal">delta_x</code> or <code class="literal">delta_y</code> depending on whether we have hit something on the sides or the top/bottom. If the ball hits the bottom of another object, it means we were travelling upwards and should now travel downwards. However, we will continue to travel in the same direction on the <code class="literal">x</code> axis (be it left or right or just up). This can be seen from the following code:</p><div><pre class="programlisting">if (ball[xTOP] == obj[xBTM]) or (ball[xBTM] == obj[xTOP]):
    delta_x = -delta_x</pre></div><p>The <code class="literal">determineDir()</code> function looks at the coordinates of the ball and the object, and looks for a match between either the left and right <code class="literal">x</code> coordinates or the top and bottom <code class="literal">y</code> coordinates. This is enough to say whether the collision is on the sides or top/bottom, and we can set the <code class="literal">delta_x</code> or <code class="literal">delta_y</code> signs accordingly, as can be seen in the following code:</p><div><pre class="programlisting">if (obj &gt;= brick[0]) and (obj &lt;= brick[-1]):
    canv.delete(obj)</pre></div><p>Next, we can determine if we have hit a brick by checking whether the overlapping object ID is between the first and last ID bricks. If it was a brick, we can remove it using <code class="literal">canv.delete()</code>.</p><div><div><h3 class="title"><a id="note39"/>Note</h3><p>Python allows the index values to wrap around rather than access the invalid memory, so an index value of <code class="literal">-1</code> will provide us with the last item in the list. We use this to reference the last brick as <code class="literal">brick [-1]</code>.</p></div></div><p>We also check<a class="indexterm" id="id346"/> to see whether the object being overlapped is the bottom line (in which case, the player has missed the ball with the paddle), so a short message is displayed briefly. We reset the position of the <code class="literal">ball</code> and <code class="literal">delta_x</code>/<code class="literal">delta_y</code> values. The <code class="literal">canv.update()</code> function ensures that the display is refreshed with the message before it is deleted (3 seconds later).</p><p>Finally, the ball is moved by the <code class="literal">delta_x</code>/<code class="literal">delta_y</code> distance and the display is updated. A small delay is added here to reduce the rate of updates and the CPU time used. Otherwise, you will find that your Raspberry Pi will become unresponsive if it is spending 100 percent of its effort running the program.</p><p>When the user presses the cursor keys, the <code class="literal">move_right()</code> and <code class="literal">move_left()</code> functions are called. They check the position of the paddle object, and if the paddle is not at the edge, the paddle will be moved accordingly. If the ball hits the paddle, the collision detection will ensure that the ball bounces off, just as if it has hit one of the bricks.</p><p>You can extend this game further by adding a score for each block destroyed, allowing the player a finite number of lives that are lost when they miss the ball, and even writing some code to read in new brick layouts.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Creating an overhead scrolling game</h1></div></div></div><p>By using objects<a class="indexterm" id="id347"/> and images in our programs, we can create many types of 2D graphical games.</p><p>In this recipe, we will create a treasure hunt game where the player is trying to find buried treasure (by pressing <em>Enter</em> to dig for it). Each time the treasure has not been found, the player is given a clue to how far away the treasure is; they can then use the cursor keys to move around and search until they find it.</p><div><img alt="Creating an overhead scrolling game" src="img/6623OT_04_12.jpg"/><div><p>Dig for treasure in your own overhead scrolling game!</p></div></div><p>Although this is a basic concept for a game, it could easily be extended to include multiple layouts, traps, and enemies to avoid, perhaps even additional tools or puzzles to solve. With a few adjustments to the graphics, the character could be exploring a dungeon, a spaceship, or hopping through the clouds collecting rainbows!</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec86"/>Getting ready</h2></div></div></div><p>The following<a class="indexterm" id="id348"/> example uses a number of images; these are available as part of the book's resources. You will need to place the nine images in the same directory as the Python script.</p><p>The required image files can be seen in the code bundle of this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec87"/>How to do it…</h2></div></div></div><p>Create the following script, <code class="literal">scroller.py</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">Begin by importing the required libraries and parameters:<div><pre class="programlisting">#!/usr/bin/python3
# scroller.py
import tkinter as TK
import time
import math
from random import randint

STEP=7
xVAL,yVAL=0,1
MAX_WIDTH,MAX_HEIGHT=640,480
SPACE_WIDTH=MAX_WIDTH*2
SPACE_HEIGHT=MAX_HEIGHT*2
LEFT,UP,RIGHT,DOWN=0,1,2,3
SPACE_LIMITS=[0,0,SPACE_WIDTH-MAX_WIDTH,
              SPACE_HEIGHT-MAX_HEIGHT]
DIS_LIMITS=[STEP,STEP,MAX_WIDTH-STEP,MAX_HEIGHT-STEP]
BGN_IMG="bg.gif"
PLAYER_IMG=["playerL.gif","playerU.gif",
            "playerR.gif","playerD.gif"]
WALL_IMG=["wallH.gif","wallV.gif"]
GOLD_IMG="gold.gif"
MARK_IMG="mark.gif"
newGame=False
checks=list()</pre></div></li><li class="listitem">Provide<a class="indexterm" id="id349"/> functions to handle the movement of the player:<div><pre class="programlisting">def move_right(event):
  movePlayer(RIGHT,STEP)
def move_left(event):
  movePlayer(LEFT,-STEP)
def move_up(event):
  movePlayer(UP,-STEP)
def move_down(event):
  movePlayer(DOWN,STEP)

def foundWall(facing,move):
  hitWall=False
  olCoords=[canv.coords(player)[xVAL],
            canv.coords(player)[yVAL],
            canv.coords(player)[xVAL]+PLAYER_SIZE[xVAL],
            canv.coords(player)[yVAL]+PLAYER_SIZE[yVAL]]
  olCoords[facing]+=move
  objects = canv.find_overlapping(olCoords[0],olCoords[1],
                                  olCoords[2],olCoords[3])
  for obj in objects:
    objTags = canv.gettags(obj)
    for tag in objTags:
      if tag == "wall":
        hitWall=True
  return hitWall

def moveBackgnd(movement):
  global bg_offset
  bg_offset[xVAL]+=movement[xVAL]
  bg_offset[yVAL]+=movement[yVAL]
  for obj in canv.find_withtag("bg"):
    canv.move(obj, -movement[xVAL], -movement[yVAL])

def makeMove(facing,move):
  if facing == RIGHT or facing == LEFT:
    movement=[move,0] #RIGHT/LEFT
    bgOffset=bg_offset[xVAL]
    playerPos=canv.coords(player)[xVAL]
  else:
    movement=[0,move] #UP/DOWN
    bgOffset=bg_offset[yVAL]
    playerPos=canv.coords(player)[yVAL]
  #Check Bottom/Right Corner
  if facing == RIGHT or facing == DOWN: 
    if (playerPos+PLAYER_SIZE[xVAL]) &lt; DIS_LIMITS[facing]:
      canv.move(player, movement[xVAL], movement[yVAL])
    elif bgOffset &lt; SPACE_LIMITS[facing]:
      moveBackgnd(movement)
  else:
    #Check Top/Left Corner
    if (playerPos) &gt; DIS_LIMITS[facing]:
      canv.move(player, movement[xVAL], movement[yVAL])
    elif bgOffset &gt; SPACE_LIMITS[facing]:
      moveBackgnd(movement)

def movePlayer(facing,move):
  hitWall=foundWall(facing,move)
  if hitWall==False:
    makeMove(facing,move)
  canv.itemconfig(player,image=playImg[facing])</pre></div></li><li class="listitem">Add<a class="indexterm" id="id350"/> functions to check how far the player is from the hidden gold:<div><pre class="programlisting">def check(event):
  global checks,newGame,text
  if newGame:
    for chk in checks:
      canv.delete(chk)
    del checks[:]
    canv.delete(gold,text)
    newGame=False
    hideGold()
  else:
    checks.append(
                  canv.create_image(canv.coords(player)[xVAL],
                  canv.coords(player)[yVAL],
                  anchor=TK.NW, image=checkImg,
                  tags=('check','bg')))
    distance=measureTo(checks[-1],gold)
    if(distance&lt;=0):
      canv.itemconfig(gold,state='normal')
      canv.itemconfig(check,state='hidden')
      text = canv.create_text(300,100,fill="white",
                              text=("You have found the gold in"+ 
                              " %d tries!"%len(checks)))
      newGame=True
    else:
      text = canv.create_text(300,100,fill="white",
                              text=("You are %d steps away!"%distance))
      canv.update()
      time.sleep(1)
      canv.delete(text)

def measureTo(objectA,objectB):
  deltaX=canv.coords(objectA)[xVAL]-\
                     canv.coords(objectB)[xVAL]
  deltaY=canv.coords(objectA)[yVAL]-\
                     canv.coords(objectB)[yVAL]
  w_sq=abs(deltaX)**2
  h_sq=abs(deltaY)**2
  hypot=math.sqrt(w_sq+h_sq)
  return round((hypot/5)-20,-1)</pre></div></li><li class="listitem">Add <a class="indexterm" id="id351"/>functions to help find a location to hide the gold in:<div><pre class="programlisting">def hideGold():
  global gold
  goldPos=findLocationForGold()
  gold=canv.create_image(goldPos[xVAL], goldPos[yVAL],
                         anchor=TK.NW, image=goldImg,
                         tags=('gold','bg'),
                         state='hidden')

def findLocationForGold():
  placeGold=False
  while(placeGold==False):
    goldPos=[randint(0-bg_offset[xVAL],
             SPACE_WIDTH-GOLD_SIZE[xVAL]-bg_offset[xVAL]),
             randint(0-bg_offset[yVAL],
             SPACE_HEIGHT-GOLD_SIZE[yVAL]-bg_offset[yVAL])]
    objects = canv.find_overlapping(goldPos[xVAL],
                                    goldPos[yVAL],
                                    goldPos[xVAL]+GOLD_SIZE[xVAL],
                                    goldPos[yVAL]+GOLD_SIZE[yVAL])
    findNewPlace=False
    for obj in objects:
      objTags = canv.gettags(obj)
      for tag in objTags:
        if (tag == "wall") or (tag == "player"):
          findNewPlace=True
    if findNewPlace == False:
      placeGold=True
  return goldPos</pre></div></li><li class="listitem">Create<a class="indexterm" id="id352"/> the Tkinter application window and bind the keyboard events:<div><pre class="programlisting">root = TK.Tk()
root.title("Overhead Game")
root.geometry('%sx%s+%s+%s' %(MAX_WIDTH, 
                              MAX_HEIGHT, 
                              100, 100))
root.resizable(width=TK.FALSE, height=TK.FALSE)
root.bind('&lt;Right&gt;', move_right)
root.bind('&lt;Left&gt;', move_left)
root.bind('&lt;Up&gt;', move_up)
root.bind('&lt;Down&gt;', move_down)
root.bind('&lt;Return&gt;', check)

canv = TK.Canvas(root, highlightthickness=0)
canv.place(x=0,y=0,width=SPACE_WIDTH,height=SPACE_HEIGHT)</pre></div></li><li class="listitem">Initialize all the game objects (the background tiles, the player, the walls, and the gold):<div><pre class="programlisting">#Create background tiles
bgnImg = TK.PhotoImage(file=BGN_IMG)
BGN_SIZE = bgnImg.width(),bgnImg.height()
background=list()
COLS=int(SPACE_WIDTH/BGN_SIZE[xVAL])+1
ROWS=int(SPACE_HEIGHT/BGN_SIZE[yVAL])+1
for col in range(0,COLS):
  for row in range(0,ROWS):
    background.append(canv.create_image(col*BGN_SIZE[xVAL],
                      row*BGN_SIZE[yVAL], anchor=TK.NW,
                      image=bgnImg,
                      tags=('background','bg')))
bg_offset=[0,0]

#Create player
playImg=list()
for img in PLAYER_IMG:
  playImg.append(TK.PhotoImage(file=img))
#Assume images are all same size/shape
PLAYER_SIZE=playImg[RIGHT].width(),playImg[RIGHT].height()
player = canv.create_image(100,100, anchor=TK.NW,
                           image=playImg[RIGHT],
                           tags=('player'))

#Create walls
wallImg=[TK.PhotoImage(file=WALL_IMG[0]),
         TK.PhotoImage(file=WALL_IMG[1])]
WALL_SIZE=[wallImg[0].width(),wallImg[0].height()]
wallPosH=[(0,WALL_SIZE[xVAL]*1.5),
          (WALL_SIZE[xVAL],WALL_SIZE[xVAL]*1.5),
          (SPACE_WIDTH-WALL_SIZE[xVAL],WALL_SIZE[xVAL]*1.5),
          (WALL_SIZE[xVAL],SPACE_HEIGHT-WALL_SIZE[yVAL])]
wallPosV=[(WALL_SIZE[xVAL],0),(WALL_SIZE[xVAL]*3,0)]
wallPos=[wallPosH,wallPosV]
wall=list()
for i,img in enumerate(WALL_IMG):
  for item in wallPos[i]:
    wall.append(canv.create_image(item[xVAL],item[yVAL],
                anchor=TK.NW, image=wallImg[i],
                tags=('wall','bg')))

#Place gold
goldImg = TK.PhotoImage(file=GOLD_IMG)
GOLD_SIZE=[goldImg.width(),goldImg.height()]
hideGold()
#Check mark
checkImg = TK.PhotoImage(file=MARK_IMG)</pre></div></li><li class="listitem">Finally, start <a class="indexterm" id="id353"/>the <code class="literal">mainloop()</code> command to allow Tkinter to monitor for events:<div><pre class="programlisting">#Wait for actions from user
root.mainloop()
#End</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec88"/>How it works…</h2></div></div></div><p>As before, we create a new Tkinter application that contains a <code class="literal">Canvas</code> widget so that we can add all of the game objects. We ensure that we bind the right, left, up, down and <em>Enter</em> keys, which will be our controls in the game.</p><p>First, we place our background image (<code class="literal">bg.gif</code>) onto the <code class="literal">Canvas</code> widget. We calculate the number of images we can fit along the length and width to tile the whole canvas space, and locate them using suitable coordinates.</p><p>Next, we create the player image (by creating <code class="literal">playImg</code>, a list of Tkinter image objects for each direction the player can turn in) and place it on the canvas.</p><p>We now create the walls, the positions of which are defined by the <code class="literal">wallPosH</code> and <code class="literal">wallPosV</code> lists. These could be defined using the exact coordinates, perhaps even read from a file to provide an easy method to load different layouts for levels if required. By iterating through the lists, the horizontal and vertical wall images are put in position on the canvas.</p><p>To complete the layout, we just need to hide the gold somewhere. Using the <code class="literal">hideGold()</code> function, we randomly determine a suitable place to locate the gold. Within <code class="literal">findLocationForGold()</code>, we use <code class="literal">randint(0,value)</code> to create a pseudo-random number (it is not totally random but good enough for this use) between <code class="literal">0</code> and <code class="literal">value</code>. In our case, the value <a class="indexterm" id="id354"/>we want is between <code class="literal">0</code> and the edge of our canvas space minus the size of the gold image and any <code class="literal">bg_offset</code> that has been applied to the canvas. This ensures it is not beyond the edge of the screen. We then check the potential location using the <code class="literal">find_overlapping()</code> function to see whether any objects with <code class="literal">wall</code> or <code class="literal">player</code> tags are in the way. If so, we pick a new location. Otherwise, we place the gold on the canvas but with the <code class="literal">state="hidden"</code> value, which will hide it from view.</p><p>We then create <code class="literal">checkImg</code> (a Tkinter image) and use it while checking for gold to mark the area we have checked. Finally, we just wait for the user to press one of the keys.</p><p>The character will move around the screen whenever one of the cursor keys is pressed. The player's movement is determined by the <code class="literal">movePlayer()</code> function; it will first check whether the player is trying to move into a wall, then determine (within the <code class="literal">makeMove()</code> function) if the player is at the edge of the display or canvas space.</p><div><img alt="How it works…" src="img/6623OT_04_13.jpg"/><div><p>Every time a cursor key is pressed, we use the logic shown in the diagram to determine what to do</p></div></div><p>The <code class="literal">foundWall()</code> function works out whether the player will hit a wall by checking for any objects<a class="indexterm" id="id355"/> with <code class="literal">wall</code> tags within the area being covered by the player image, plus a little extra for the area that the player will be moving to next. The following diagram shows how the <code class="literal">olCoords</code> coordinates are determined:</p><div><img alt="How it works…" src="img/6623OT_04_14.jpg"/><div><p>The coordinates to check for objects that overlap (olCoords) are calculated</p></div></div><p>The <code class="literal">makeMove()</code> function checks if the player will be moving to the edge of the display (as defined by <code class="literal">DIS_LIMITS</code>) and whether they are at the edge of the canvas space (as defined by <code class="literal">SPACE_LIMITS</code>). Within the display, the player can be moved in the direction of the cursor, or <a class="indexterm" id="id356"/>all the objects tagged with <code class="literal">bg</code> within the canvas space are moved in the opposite direction, simulating scrolling behind the player. This is done by the <code class="literal">moveBackground()</code> function.</p><p>When the player presses <em>Enter</em>, we'll want to check for gold in the current location. Using the <code class="literal">measureTo()</code> function, the position of the player and the gold are compared (the distance between the <code class="literal">x</code> and <code class="literal">y</code> coordinates of each is calculated).</p><div><img alt="How it works…" src="img/6623OT_04_15.jpg"/><div><p>The distance between the player and the gold is calculated</p></div></div><p>The result is scaled to provide a rough indication of how far away the player is from the gold. If the distance is greater than zero, we display how far away the player is from the gold and leave a cross to show where we have checked. If the player has found the gold, we display a message saying so and set <code class="literal">newGame</code> to <code class="literal">True</code>. The next time the player presses <em>Enter</em>, the places marked with a cross are removed and the gold is relocated somewhere new.</p><p>With the gold hidden again, the player is ready to start again!</p></div></div></body></html>