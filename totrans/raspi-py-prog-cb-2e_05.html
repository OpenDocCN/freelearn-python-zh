<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Creating 3D Graphics</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Starting with 3D coordinates and vertices</li><li class="listitem" style="list-style-type: disc">Creating and importing 3D models</li><li class="listitem" style="list-style-type: disc">Creating a 3D world to roam in</li><li class="listitem" style="list-style-type: disc">Building 3D maps and mazes</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Introduction</h1></div></div></div><p>The chip at the heart of the original Raspberry Pi (a <strong>Broadcom BCM2835</strong> processor) was originally designed to be a <strong>Graphical Processing Unit</strong> (<strong>GPU</strong>) for mobile and embedded applications. The ARM core that drives most of the Raspberry Pi's functionality was added because some extra space was available on the chip; this enabled this powerful GPU to be used as a <strong>System-On-Chip</strong> (<strong>SoC</strong>) solution.</p><p>As you can imagine, if that original ARM core (<strong>ARM1176JZF-S</strong>, which is the <strong>ARMv6</strong> architecture) consisted of only a small part of the chip on the Raspberry Pi, you would be right in thinking that the GPU must perform rather well.</p><div><div><h3 class="title"><a id="note40"/>Note</h3><p>The processor at the heart of the Raspberry Pi 3 has been upgraded (to a <strong>Broadcom BCM2837</strong> processor); it now contains four ARM cores (<strong>Cortex A53 ARMv8A</strong>), each of which are more powerful than the original <strong>ARMv6</strong>. Coupled with the same GPU from the previous generation, the Raspberry Pi 3 is far better equipped to perform the calculations required to build 3D environments. However, although the Raspberry Pi 3 will load the examples faster, once the 3D models are generated, both versions of the chip perform just as well.</p></div></div><p>The <strong>VideoCore IV GPU</strong> consists of 48 purpose-built processors, with some providing support for 1080p high-definition encoding and decoding of video, while others support <strong>OpenGL ES 2.0</strong>, which provides fast calculations for 3D graphics. It has been said that its graphics processing power is equivalent to that of an Apple iPhone 4s and also the original Microsoft Xbox. This is even more apparent if you run <strong>Quake 3</strong> or <strong>OpenArena</strong> on the Raspberry Pi (go to <a class="ulink" href="http://www.raspberrypi.org/openarena-for-raspberry-pi">http://www.raspberrypi.org/openarena-for-raspberry-pi</a> for details).</p><p>In this chapter, I hope to show you that while you can achieve a lot by performing operations using the ARM side of the Raspberry Pi, if you venture into the side where the GPU is hidden, you may see that there is even more to this little computer than first appears.</p><p>The Pi3D library created by the Pi3D team (Patrick Gaunt, Tom Swirly, Tim Skillman, and others) provides a way to put the GPU to work by creating 3D graphics.</p><p>The Pi3D wiki and documentation pages can be found at the following link:</p><p>
<a class="ulink" href="http://pi3d.github.io/html/index.html">http://pi3d.github.io/html/index.html</a>
</p><p>The support/development group can be found at the following link:</p><p>
<a class="ulink" href="https://groups.google.com/forum/#!forum/pi3d">https://groups.google.com/forum/#!forum/pi3d</a>
</p><p>The library contains many features, so it will not be possible to cover everything that is available in the following examples. It is recommended that you also take some time to try out the Pi3D demos. To discover more options for the creation and handling of the 3D graphics, you can have a look through some of the Python modules, which make up the library itself (described in the documentation or the code on GitHub at <a class="ulink" href="https://github.com/pi3d/pi3d.github.com">https://github.com/pi3d/pi3d.github.com</a>). It is hoped that this chapter will introduce you to enough concepts to illustrate some of the raw potential available to you.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Starting with 3D coordinates and vertices</h1></div></div></div><p>The world around us is three-dimensional, so in order to simulate parts of the world, we can create a 3D representation and display it on our 2D screen.</p><p>The Raspberry Pi enables us to simulate a 3D space, place 3D objects within it, and observe them from a selected viewpoint. We will use the GPU to produce a representation of the 3D view as a 2D image to display it on the screen.</p><p>The following example will show how we can use <strong>Pi3D</strong> (an OpenGL ES library for the Raspberry Pi) to place a single 3D object and display it within the 3D space. We will then allow the mouse to rotate the view around the object.</p><div><img alt="Starting with 3D coordinates and vertices" src="img/6623_05_001.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec89"/>Getting ready</h2></div></div></div><p>The Raspberry Pi must be directly connected to a display, either via the HDMI or an analog video output. The 3D graphics rendered by the GPU will only be displayed on a local display, even if you are connecting to the Raspberry Pi remotely over a network. You will also need to use a locally connected mouse for control (however, keyboard control does work via a SSH connection).</p><p>The first time we use Pi3D, we will need to download and install it with the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The Pi3D library uses Pillow, a version of the Python Imaging Library that is compatible with Python 3, to import graphics used in models (such as textures and backgrounds).<p>The installation of Pillow has been covered in the <em>Getting ready</em> section of <a class="link" href="ch03.html" title="Chapter 3. Using Python for Automation and Productivity">Chapter 3</a>, <em>Using Python for Automation and Productivity</em>.</p><p>The commands for the installation are shown in the following code (if you've installed them before, it will skip them and continue):</p><div><pre class="programlisting">
<strong>sudo apt-get update</strong>
<strong>sudo apt-get install python3-pip</strong>
<strong>sudo apt-get install libjpeg-dev</strong>
<strong>sudo pip-3.2 install pillow</strong>
</pre></div></li><li class="listitem">We can now use PIP to install Pi3D using the following command:<div><pre class="programlisting">
<strong>sudo pip-3.2 install pi3d</strong>
</pre></div><div><div><h3 class="title"><a id="note41"/>Note</h3><p>The Pi3D team is continuously developing and improving the library; if you are experiencing problems, it may mean that a new release is not compatible with the previous ones.</p><p>You can also check in the <a class="link" href="apa.html" title="Appendix A. Hardware and Software List">Appendix</a>, <em>Hardware and Software List</em>, to confirm which version of Pi3D you have and, if required, install the same version listed. Alternatively, contact the Pi3D team on the Google group; they will be happy to help!</p><p>Obtain Pi3D demos from the GitHub site, as shown in the following command lines. You will need around 90 MB of free space to download and extract the files:</p><div><pre class="programlisting">
<strong>cd ~</strong>
<strong>wget https://github.com/pi3d/pi3d_demos/archive/master.zip</strong>
<strong>unzip master.zip</strong>
<strong>rm master.zip</strong>
</pre></div></div></div><p>You will find that the demos have been unpacked to <code class="literal">pi3d_demos-master</code>. By default, the demos are expected to be located at <code class="literal">home/pi/pi3d</code>; therefore, we will rename this directory <code class="literal">pi3d</code>, as shown in the following command:</p><div><pre class="programlisting">
<strong>mv pi3d_demos-master pi3d</strong>
</pre></div></li><li class="listitem">Finally, check the Raspberry Pi memory split. Run <strong>raspi-config</strong> (<code class="literal">sudo raspi-config</code>) and ensure that your memory split is set to 128. (You should only need to do this if you have changed it in the past, as 128 MB is the default.) This ensures that you have plenty of RAM allocated for the GPU, so it will be able to handle lots of 3D objects if required.</li><li class="listitem">Test if everything is working properly. You should now be able to run any of the scripts in the <code class="literal">pi3d_demos-master</code> directory. See the Pi3D wiki pages for details of how they function (<a class="ulink" href="http://pi3d.github.io/html/ReadMe.html">http://pi3d.github.io/html/ReadMe.html</a>). To get the best performance, it is recommended that the scripts are run from the command prompt (without loading the desktop):<div><pre class="programlisting">
<strong>cd pi3d</strong>
<strong>python3 Raspberry_Rain.py</strong>
</pre></div><div><div><h3 class="title"><a id="note42"/>Note</h3><p>Many of the demos require mouse and keyboard control.</p><p>Although it would be perfectly reasonable to use the methods from <a class="link" href="ch04.html" title="Chapter 4. Creating Games and Graphics">Chapter 4</a>, <em>Creating Games and Graphics</em>, for mouse and keyboard input using <strong>Tkinter</strong>, many of the demos in the Pi3D library use <strong>pi3d.Keyboard</strong> and <strong>pi3d.Mouse</strong> objects to provide additional support for joysticks and gamepads. The <strong>pi3d.Keyboard</strong> object also supports keyboard control via SSH (see the <em>Connecting remotely to the Raspberry Pi over the network using SSH (and X11 Forwarding)</em> section of <a class="link" href="ch01.html" title="Chapter 1. Getting Started with a Raspberry Pi Computer">Chapter 1</a>, <em>Getting Started with a Raspberry Pi Computer</em>).</p><p>Configure the setup for your own scripts. Since we will use some of the textures and models from the demos, it is recommended that you create your scripts within the <code class="literal">pi3d</code> directory. If you have a username that's different from the default Pi account, you will need to adjust <code class="literal">/pi3d/demo.py</code>. Replace the <code class="literal">USERNAME</code> part with your own username by editing the file:</p><div><pre class="programlisting">
<strong>nano ~/pi3d/demo.py</strong>
<strong>import sys</strong>
<strong>sys.path.insert(1, '/home/USERNAME/pi3d')</strong>
</pre></div></div></div><p>If you want to relocate your files somewhere else, ensure that you add a copy of <code class="literal">demo.py</code> in the folder with the correct path to any resource files you require.</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec90"/>How to do it…</h2></div></div></div><p>Create the following <code class="literal">3dObject.py</code> script:</p><div><pre class="programlisting">#!/usr/bin/python3
""" Create a 3D space with a Tetrahedron inside and rotate the
    view around using the mouse.
"""
from math import sin, cos, radians

import demo
import pi3d

KEY = {'ESC':27,'NONE':-1}

DISPLAY = pi3d.Display.create(x=50, y=50)
#capture mouse and key presses
mykeys = pi3d.Keyboard()
mymouse = pi3d.Mouse(restrict = False)
mymouse.start()

def main():
  CAMERA = pi3d.Camera.instance()
  tex = pi3d.Texture("textures/stripwood.jpg")
  flatsh = pi3d.Shader("uv_flat")

  #Define the coordinates for our shape (x,y,z) 
  A = (-1.0,-1.0,-1.0)
  B = (1.0,-1.0,1.0)
  C = (-1.0,-1.0,1.0)
  D = (-1.0,1.0,1.0)
  ids = ["A","B","C","D"]
  coords = [A,B,C,D]
  myTetra = pi3d.Tetrahedron(x=0.0, y=0.0, z=0.0,
                             corners=(A,B,C,D))
  myTetra.set_draw_details(flatsh,[tex])
  # Load ttf font and set the font to black
  arialFont = pi3d.Font("fonts/FreeMonoBoldOblique.ttf",
                        "#000000")
  mystring = []
  #Create string objects to show the coordinates
  for i,pos in enumerate(coords):
    mystring.append(pi3d.String(font=arialFont,
                            string=ids[i]+str(pos),
                            x=pos[0], y=pos[1],z=pos[2]))
    mystring.append(pi3d.String(font=arialFont,
                            string=ids[i]+str(pos),
                            x=pos[0], y=pos[1],z=pos[2], ry=180))
  for string in mystring:
    string.set_shader(flatsh)

  camRad = 4.0 # radius of camera position
  rot = 0.0 # rotation of camera
  tilt = 0.0 # tilt of camera
  k = KEY['NONE']
  omx, omy = mymouse.position()
  
  # main display loop
  while DISPLAY.loop_running() and not k == KEY['ESC']:
    k = mykeys.read()
    mx, my = mymouse.position()
    rot -= (mx-omx)*0.8
    tilt += (my-omy)*0.8
    omx = mx
    omy = my

    CAMERA.reset()
    CAMERA.rotate(-tilt, rot, 0)
    CAMERA.position((camRad * sin(radians(rot)) *
                     cos(radians(tilt)), 
                     camRad * sin(radians(tilt)), 
                     -camRad * cos(radians(rot)) *
                     cos(radians(tilt))))
    #Draw the Tetrahedron
    myTetra.draw()
    for string in mystring:
      string.draw()

try:
  main()
finally:
  mykeys.close()
  mymouse.stop()
  DISPLAY.destroy()
  print("Closed Everything. END")
#End</pre></div><p>To run the script, use <code class="literal">python3 3dObject.py</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec91"/>How it works…</h2></div></div></div><p>We import the math modules (for angle calculations—used to control the view based on mouse movements). We also import the demo module, which just provides the path to the <strong>shaders</strong> and <strong>textures</strong> in this example.</p><p>We start by defining some key elements that will be used by Pi3D to generate and display our object. The space in which we shall place our object is the <code class="literal">pi3d.Display</code> object; this defines the size of the space and initializes the screen to generate and display OpenGL ES graphics.</p><p>Next, we define a <code class="literal">pi3d.Camera</code> object, which will allow us to define how we view the object within our space. To render our object, we define a texture to be applied to the surface and a shader that will apply the texture to the object. The shader is used to apply all the effects and lighting to the object, and it is coded to use the GPU's OpenGL ES core instead of the ARM processor.</p><p>We define the <code class="literal">keyboard </code>and<code class="literal"> mouse</code> object using <code class="literal">pi3d.keyboard()</code> and <code class="literal">pi3d.mouse()</code> so that we can respond to the keyboard and mouse input. The <code class="literal">restrict</code> flag of the <code class="literal">mouse</code> object allows the absolute mouse position to continue past the screen limits (so we can continuously rotate our 3D object). The main loop, when running, will check if the <em>Esc</em> key is pressed and then close everything down (including calling <code class="literal">DISPLAY.destroy()</code> to release the screen). We use the <code class="literal">try: finally:</code> method to ensure that the display is closed correctly even if there is an exception within <code class="literal">main()</code>.</p><p>The mouse movement is collected in the main display loop using <code class="literal">mymouse.position()</code>, which returns the <em>x</em> and <em>y</em> coordinates. The difference in the <em>x</em> and <em>y</em> movement is used to rotate around the object.</p><p>The mouse movements determine the position and angle of the camera. Any adjustment to the forward/backward position of the mouse is used to move it over or under the object and change the angle of the camera (using <code class="literal">tilt</code>) so it remains pointing at the object. Similarly, any sideways movement will move the camera around the object using the <code class="literal">CAMERA.reset()</code> function. This ensures that the display updates the camera view with the new position, <code class="literal">CAMERA.rotate()</code>, to change the angle and uses <code class="literal">CAMERA.position()</code> to move the camera to a position around the object, <code class="literal">camRad</code> units away from its center.</p><p>We will draw a three-dimensional object called a <strong>tetrahedron</strong>, a shape made up of four triangles to form a pyramid with a triangular base. The four corners of the shape (three around the base and one at the top) will be defined by the three-dimensional coordinates A, B, C, and D, as shown in the following figure:</p><div><img alt="How it works…" src="img/6623_05_002.jpg"/><div><p>The tetrahedron placed within the X, Y, and Z axes</p></div></div><p>The <code class="literal">pi3d.Tetrahedron</code> object is defined by specifying coordinates to position it in the space and then specify the corners that will be joined to form the four triangles that make up the shape.</p><p>Using <code class="literal">set_draw_details(flatsh,[text])</code>, we apply the shader(s) we wish to use and the texture(s) for the object. In our example, we are just using a single texture, but some shaders can use several textures for complex effects.</p><p>To help highlight where the coordinates are, we will add some <code class="literal">pi3d.String</code> objects by setting the string text to specify the ID and coordinates next to them and placing it at the required location. We will create two string objects for each location, one facing forward and another facing backwards (<code class="literal">ry=180</code> rotates the object by 180 degrees on the y axis). The <code class="literal">pi3d.String</code> objects are single-sided, so if we only had one side facing forward, it wouldn't be visible from behind when the view was rotated and would just disappear (plus, if it was visible, the text would be backwards anyway). Again, we use the <code class="literal">flatsh</code> shader to render it using the <code class="literal">set_shader()</code> string object.</p><p>All that is left to do now is to draw our tetrahedron and the string objects while checking for any keyboard events. Each time the <code class="literal">while</code> loop completes, <code class="literal">DISPLAY.loop_running()</code> is called, which will update the display with any adjustments to the camera as required.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec92"/>There's more…</h2></div></div></div><p>In addition to introducing how to draw a basic object within the 3D space, the preceding example makes use of the following four key elements used in 3D graphics programming.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec24"/>Camera</h3></div></div></div><p>The camera represents our view in the 3D space; one way to explore and see more of the space is by moving the camera. The <code class="literal">Camera</code> class is defined as follows:</p><div><pre class="programlisting">pi3d.Camera.Camera(at=(0, 0, 0), eye=(0, 0, -0.1),
                   lens=None, is_3d=True, scale=1.0)</pre></div><p>The camera is defined by providing two locations, one to look at (usually the object we wish to see—defined by <code class="literal">at</code>) and another to look from (the object's position—defined by <code class="literal">eye</code>). Other features of the camera, such as its field of view (<code class="literal">lens</code>) and so on, can be adjusted or used with the default settings.</p><div><div><h3 class="title"><a id="note43"/>Note</h3><p>If we didn't define a camera in our display, a default one will be created that points at the origin (the center of the display, that is, <code class="literal">0,0,0</code>), positioned slightly in front of it (<code class="literal">0,0,-0.1</code>).</p><p>See the Pi3D documentation regarding the camera module for more details.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec25"/>Shaders</h3></div></div></div><p>Shaders are very useful as they allow a lot of the complex work required to apply textures and lighting to an object by offloading the task to the more powerful GPU in the Raspberry Pi. The Shader class is defined as follows:</p><div><pre class="programlisting">class pi3d.Shader.Shader(shfile=None, vshader_source=None,
                                      fshader_source=None)</pre></div><p>This allows you to specify a shader file (<code class="literal">shfile</code>) and specific vertex and fragment shaders (if required) within the file.</p><p>There are several shaders included in the Pi3D library, some of which allow multiple textures to be used for reflections, close-up details, and transparency effects. The implementation of the shader will determine how the lights and textures are applied to the object (and in some cases, such as <code class="literal">uv_flat</code>, the shader will ignore any lighting effects).</p><p>The shader files are listed in the <code class="literal">pi3d\shaders</code> directory. Try experimenting with different shaders, such as <code class="literal">mat_reflect</code>, which will ignore the textures/fonts but still apply the lighting effects; or <code class="literal">uv_toon</code>, which will apply a cartoon effect to the texture.</p><p>Each shader consists of two files, <code class="literal">vs</code> (vertex shader) and <code class="literal">fs</code> (fragment shader), written in C-like code. They work together to apply the effects to the object as desired. The vertex shader is responsible for mapping the 3D location of the vertices to the 2D display. The fragment shader (or sometimes called the pixel shader) is responsible for applying lighting and texture effects to the pixels themselves. The construction and operation of these shaders is well beyond the scope of this chapter, but there are several example shaders that you can compare, change, and experiment with within the <code class="literal">pi3d\shaders</code> directory.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec26"/>Lights</h3></div></div></div><p>Lighting is very important in a 3D world; it could range from simple general lighting (as used in our example) to multiple lights angled from different directions providing different strengths and colors. How lights interact with objects and the effects they produce will be determined by the textures and shaders used to render them.</p><p>Lights are defined by their direction, their color and brightness, and also by an ambient light to define the background (non-directional) light. The <code class="literal">Light</code> class is defined as follows:</p><div><pre class="programlisting">class pi3d.Light (lightpos=(10, -10, 20),
                       lightcol=(1.0, 1.0, 1.0),
                       lightamb=(0.1, 0.1, 0.2))</pre></div><div><div><h3 class="title"><a id="note44"/>Note</h3><p>By default, the display will define a light that has the following properties:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">lightpos=(10, -10, 20)</code>: This is a light that shines from the front of the space (near the top-left side) down towards the back of the space (towards the right).</li><li class="listitem" style="list-style-type: disc"><code class="literal">lightcol=(1.0, 1.0, 1.0)</code>: This is a bright, white, directional light (the direction is defined in the preceding dimension, and it is the color defined by the RGB values <code class="literal">1.0, 1.0, 1.0</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">lightamb=(0.1, 0.1, 0.2)</code>: This is overall a dull, slightly bluish light.</li></ul></div></div></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec27"/>Textures</h3></div></div></div><p>Textures are able to add realism to an object by allowing fine detail to be applied to the object's surface; this could be an image of bricks for a wall or a person's face to be displayed on the character. When a texture is used by the shader, it can often be re-scaled and reflection can be added to it; some shaders even allow you to apply surface detail.</p><div><div><h3 class="title"><a id="note45"/>Note</h3><p>We can apply multiple textures to an object to combine them and produce different effects; it will be up to the shader to determine how they are applied.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Creating and importing 3D models</h1></div></div></div><p>Creating complex shapes directly from code can often be cumbersome and time consuming. Fortunately, it is possible to import prebuilt models into your 3D space.</p><p>It is even possible to use graphical 3D modeling programs to generate models and then export them as a suitable format for you to use. This example produces a Newell Teapot in the Raspberry Pi theme, as shown in the following screenshot:</p><div><img alt="Creating and importing 3D models" src="img/6623_05_003.jpg"/><div><p>Newell Raspberry Pi teapot</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec93"/>Getting ready</h2></div></div></div><p>We shall use 3D models of a teapot (both <code class="literal">teapot.obj</code> and <code class="literal">teapot.mdl</code>) located in <code class="literal">pi3d\models</code>.</p><div><div><h3 class="title"><a id="note46"/>Note</h3><p>Modeling a teapot is the traditional 3D equivalent of displaying <em>Hello World</em>. Computer graphics researcher Martin Newell first created the Newell Teapot in 1975 as a basic test model for his work. The Newell Teapot soon became the standard model to quickly check if a 3D rendering system is working correctly (it even appeared in Toy Story and a 3D episode of The Simpsons).</p><p>Other models are available in the <code class="literal">pi3d\models</code> directory (<code class="literal">monkey.obj/mdl</code>, which has been used later on, is available in the book's resource files).</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec94"/>How to do it…</h2></div></div></div><p>Create and run the following <code class="literal">3dModel.py</code> script:</p><div><pre class="programlisting">#!/usr/bin/python3
""" Wavefront obj model loading. Material properties set in
    mtl file. Uses the import pi3d method to load *everything*
"""
import demo
import pi3d
from math import sin, cos, radians

KEY = {'ESC':27,'NONE':-1}

# Setup display and initialise pi3d
DISPLAY = pi3d.Display.create()
#capture mouse and key presses
mykeys = pi3d.Keyboard()
mymouse = pi3d.Mouse(restrict = False)
mymouse.start()
  
def main():
  #Model textures and shaders
  shader = pi3d.Shader("uv_reflect")
  bumptex = pi3d.Texture("textures/floor_nm.jpg")
  shinetex = pi3d.Texture("textures/stars.jpg")
  # load model
  #mymodel = pi3d.Model(file_string='models/teapot.obj', z=10)
  mymodel = pi3d.Model(file_string='models/monkey.obj', z=10)
  mymodel.set_shader(shader)
  mymodel.set_normal_shine(bumptex, 4.0, shinetex, 0.5)

  #Create environment box
  flatsh = pi3d.Shader("uv_flat")
  ectex = pi3d.loadECfiles("textures/ecubes","sbox")
  myecube = pi3d.EnvironmentCube(size=900.0, maptype="FACES",
                                 name="cube")
  myecube.set_draw_details(flatsh, ectex)
    
  CAMERA = pi3d.Camera.instance()
  rot = 0.0 # rotation of camera
  tilt = 0.0 # tilt of camera
  k = KEY['NONE']
  omx, omy = mymouse.position()
    
  while DISPLAY.loop_running() and not k == KEY['ESC']:
    k = mykeys.read()
    #Rotate camera - camera steered by mouse
    mx, my = mymouse.position()
    rot -= (mx-omx)*0.8
    tilt += (my-omy)*0.8
    omx = mx
    omy = my
    CAMERA.reset()
    CAMERA.rotate(tilt, rot, 0)
    #Rotate object
    mymodel.rotateIncY(2.0)
    mymodel.rotateIncZ(0.1)
    mymodel.rotateIncX(0.3)
    #Draw objects
    mymodel.draw()
    myecube.draw()

try:
  main()
finally:
  mykeys.close()
  mymouse.stop()
  DISPLAY.destroy()
  print("Closed Everything. END")
#End</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec95"/>How it works...</h2></div></div></div><p>Like the <code class="literal">3dObject.py</code> example, we define the <code class="literal">DISPLAY</code> shader (this time using <code class="literal">uv_reflect</code>) and some additional textures—<code class="literal">bumptex</code> (<code class="literal">floor_nm.jpg</code>) and <code class="literal">shinetex</code> (<code class="literal">stars.jpg</code>)—to use later. We define a model that we want to import, placing it at <code class="literal">z=10</code> (if no coordinates are given, it will be placed at <code class="literal">(0,0,0)</code>. Since we do not specify a camera position, the default will place it within the view (see the section regarding the camera for more details).</p><p>We apply the shader using the <code class="literal">set_shader()</code> function. Next, we add some textures and effects using <code class="literal">bumptex</code> as a surface texture (scaled by <code class="literal">4</code>). We apply an extra shiny effect using <code class="literal">shinetex</code> and apply a reflection strength of <code class="literal">0.5</code> (the strength ranges from 0.0, the weakest, to 1.0, the strongest) using the <code class="literal">set_normal_shine()</code> function. If you look closely at the surface of the model, the <code class="literal">bumptex</code> texture provides additional surface detail and the <code class="literal">shinetex</code> texture can be seen as the reflection on the surface.</p><p>To display our model within something more interesting than a default blue space, we create an <code class="literal">EnvironmentCube</code> object. This defines a large space that has a special texture applied to the inside space (in this instance, it will load the <code class="literal">sbox_front/back/bottom/left</code> and <code class="literal">sbox_right</code> images from the <code class="literal">textures\ecubes</code> directory), so it effectively encloses the objects within. The result is that you get a pleasant backdrop for your object.</p><p>Again, we define a default <code class="literal">CAMERA</code> object with <code class="literal">rot</code> and <code class="literal">tilt</code> variables to control the view. Within the <code class="literal">DISPLAY.loop_running()</code> section, we can control the view of the <code class="literal">CAMERA</code> object using the mouse and rotate the model on its axis at different rates to let it spin and show all its sides (using the <code class="literal">RotateIncX/Y/Z()</code> function to specify the rate of rotation). Finally, we ensure that the <code class="literal">DISPLAY</code> is updated by drawing the model and the environment cube.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec96"/>There's more…</h2></div></div></div><p>We can create a wide range of objects to place within our simulated environment. Pi3D provides methods to import our own models and apply multiple textures to them.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec28"/>Creating or loading your own objects</h3></div></div></div><p>If you wish to use your own models in this example, you shall need to create one in the correct format; Pi3D supports <strong>obj</strong> (wavefront object files) and <strong>egg</strong> (Panda3D).</p><p>An excellent, free, 3D modeling program is called <strong>Blender</strong> (available at <a class="ulink" href="http://www.blender.org">http://www.blender.org</a>). There are lots of examples and tutorials on their website to get you started with basic modeling (<a class="ulink" href="http://www.blender.org/education-help/tutorials">http://www.blender.org/education-help/tutorials</a>).</p><p>Pi3D model support is limited and will not support all the features that Blender can embed in an exported model, for example, deformable meshes. Therefore, only basic multipart models are supported. There are a few steps required to simplify the model so it can be loaded by Pi3D.</p><p>To convert an <code class="literal">.obj</code> model to use with Pi3D, proceed with the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create or load a model in Blender—try starting with a simple object before attempting more complex models.</li><li class="listitem">Select each <strong>Object</strong> and switch to <strong>Edit</strong> mode (press <em>Tab</em>).</li><li class="listitem">Select all vertices (press <em>A</em>) and uv-map them (press <em>U</em> and then select <strong>Unwrap</strong>).</li><li class="listitem">Return to <strong>Object</strong> mode (press <em>Tab</em>).</li><li class="listitem">Export it as <strong>obj</strong>—from the <strong>File</strong> menu at the top, select <strong>Export</strong> and then <strong>Wavefront (.obj)</strong>. Ensure that <strong>Include Normals</strong> is also checked in the list of options in the bottom-left list.</li><li class="listitem">Click on <strong>Save</strong> and place the <code class="literal">.obj</code> and <code class="literal">.mtl</code> files in the <code class="literal">pi3d\models</code> directory, and ensure that you update the script with the model's filename, as follows:<div><pre class="programlisting">mymodel = pi3d.Model(file_string='models/monkey.obj', name='monkey', z=4)</pre></div></li></ol></div><p>When you run your updated script, you will see your model displayed in the 3D space. For example, the <code class="literal">monkey.obj</code> model is shown in the following screenshot:</p><div><img alt="Creating or loading your own objects" src="img/6623_05_004.jpg"/><div><p>A monkey head model created in Blender and displayed by Pi3D</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec29"/>Changing the object's textures and .mtl files</h3></div></div></div><p>The texture that is applied to the surface of the model is contained within the <code class="literal">.mtl</code> file of the model. This file defines the textures and how they are applied as set by the modeling software. Complex models may contain multiple textures for various parts of the object.</p><p>If no material is defined, the first texture in the shader is used (in our example, this is the <code class="literal">bumptex</code> texture). To add a new texture to the object, add (or edit) the following line in the <code class="literal">.mtl</code> file (that is, to use <code class="literal">water.jpg</code>):</p><div><pre class="programlisting">map_Kd ../textures/water.jpg</pre></div><p>More information about <code class="literal">.mtl</code> files and <code class="literal">.obj</code> files can be found at the following Wikipedia link:</p><p>
<a class="ulink" href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">https://en.wikipedia.org/wiki/Wavefront_.obj_file</a>
</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec30"/>Taking screenshots</h3></div></div></div><p>The Pi3D library includes a useful screenshot function to capture the screen in a <code class="literal">.jpg</code> or <code class="literal">.png</code> file. We can add a new key event to trigger it and call <code class="literal">pi3d.screenshot("filename.jpg")</code> to save an image (or use a counter to take multiple screenshots), as shown in the following code:</p><div><pre class="programlisting">shotnum = 0 #Set counter to 0
while DISPLAY.loop_running()
...
  if inputs.key_state("KEY_P"):
    while inputs.key_state("KEY_P"):
      inputs.do_input_events()		# wait for key to go up
      pi3d.screenshot("screenshot%04d.jpg"%( shotnum))
      shotnum += 1
...</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Creating a 3D world to roam in</h1></div></div></div><p>Now that we are able to create models and objects within our 3D space, as well as generate backgrounds, we may want to create a more interesting environment within which to place them.</p><p>3D terrain maps provide an elegant way to define very complex landscapes. The terrain is defined using a grayscale image to set the elevation of the land. The following example shows how we can define our own landscape and simulate flying over it, or even walk on its surface:</p><div><img alt="Creating a 3D world to roam in" src="img/6623_05_005.jpg"/><div><p>A 3D landscape generated from a terrain map</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec97"/>Getting ready</h2></div></div></div><p>You will need to place the <code class="literal">Map.png</code> file (available in the book resource files) in the <code class="literal">pi3d/textures</code> directory of the Pi3D library. Alternatively, you can use one of the elevation maps already present—replace the reference to <code class="literal">Map.png</code> with another one of the elevation maps, such as <code class="literal">testislands.jpg</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec98"/>How to do it…</h2></div></div></div><p>Create the following <code class="literal">3dWorld.py</code> script:</p><div><pre class="programlisting">#!/usr/bin/python3
from __future__ import absolute_import, division
from __future__ import print_function, unicode_literals
""" An example of generating a 3D environment using a elevation map
"""
from math import sin, cos, radians
import demo
import pi3d

KEY = {'R':114,'S':115,'T':116,'W':119,'ESC':27,'NONE':-1}

DISPLAY = pi3d.Display.create(x=50, y=50)
#capture mouse and key presses
mykeys = pi3d.Keyboard()
mymouse = pi3d.Mouse(restrict = False)
mymouse.start()

def limit(value,min,max):
  if (value &lt; min):
    value = min
  elif (value &gt; max):
    value = max
  return value

def main():
  CAMERA = pi3d.Camera.instance()
  tex = pi3d.Texture("textures/grass.jpg")
  flatsh = pi3d.Shader("uv_flat")
  # Create elevation map
  mapwidth,mapdepth,mapheight = 200.0,200.0,50.0
  mymap = pi3d.ElevationMap("textures/Map.png",
                width=mapwidth, depth=mapdepth, height=mapheight,
                divx=128, divy=128, ntiles=20)
  mymap.set_draw_details(flatsh, [tex], 1.0, 1.0)

  rot = 0.0 # rotation of camera
  tilt = 0.0 # tilt of camera
  height = 20
  viewhight = 4
  sky = 200
  xm,ym,zm = 0.0,height,0.0
  k = KEY['NONE']
  omx, omy = mymouse.position()
  onGround = False
  # main display loop
  while DISPLAY.loop_running() and not k == KEY['ESC']:
    CAMERA.reset()
    CAMERA.rotate(-tilt, rot, 0)
    CAMERA.position((xm,ym,zm))
    mymap.draw()
	
    mx, my = mymouse.position()
    rot -= (mx-omx)*0.8
    tilt += (my-omy)*0.8
    omx = mx
    omy = my

    #Read keyboard keys
    k = mykeys.read()
    if k == KEY['W']:
      xm -= sin(radians(rot))
      zm += cos(radians(rot))
    elif k == KEY['S']:
      xm += sin(radians(rot))
      zm -= cos(radians(rot))
    elif k == KEY['R']:
      ym += 2
      onGround = False
    elif k == KEY['T']:
      ym -= 2
    ym -= 0.1 #Float down!
    #Limit the movement
    xm = limit(xm,-(mapwidth/2),mapwidth/2)
    zm = limit(zm,-(mapdepth/2),mapdepth/2)
    if ym &gt;= sky:
      ym = sky
    #Check onGround
    ground = mymap.calcHeight(xm, zm) + viewhight
    if (onGround == True) or (ym &lt;= ground):
      ym = mymap.calcHeight(xm, zm) + viewhight
      onGround = True

try:
  main()
finally:
  mykeys.close()
  mymouse.stop()
  DISPLAY.destroy()
  print("Closed Everything. END")
#End</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec99"/>How it works…</h2></div></div></div><p>Once we have defined the display, camera, textures, and shaders that we are going to use, we can define the <code class="literal">ElevationMap</code> object.</p><p>It works by assigning a height to the terrain image based on the pixel value of selected points of the image. For example, a single line of an image will provide a slice of the <code class="literal">ElevationMap</code> object and a row of elevation points on the 3D surface:</p><div><img alt="How it works…" src="img/6623_05_006.jpg"/><div><p>Mapping the map.png pixel shade to the terrain height</p></div></div><p>We create an <code class="literal">ElevationMap</code> object by providing the filename of the image we will use for the gradient information (<code class="literal">textures/Map.png</code>), and we also create the dimensions of the map (<code class="literal">width</code>, <code class="literal">depth</code>, and <code class="literal">height</code>—which is how high the white spaces will be compared to the black spaces):</p><div><img alt="How it works…" src="img/6623_05_007.jpg"/><div><p>The light parts of the map will create high points and the dark ones will create low points</p></div></div><p>The <code class="literal">Map.png</code> texture provides an example terrain map, which is converted into a three-dimensional surface.</p><p>We also specify <code class="literal">divx</code> and <code class="literal">divy</code>, which determine how much detail of the terrain map is used (how many points from the terrain map are used to create the elevation surface). Finally, <code class="literal">ntiles</code> specifies that the texture used will be scaled to fit <code class="literal">20 times</code> across the surface.</p><p>Within the main <code class="literal">DISPLAY.loop_running()</code> section, we will control the camera, draw <code class="literal">ElevationMap</code>, respond to inputs, and limit movements in our space.</p><p>As before, we use a <code class="literal">Keyboard</code> object to capture mouse movements and translate them to control the camera. We will also use <code class="literal">mykeys.read()</code> to determine if <em>W</em>, <em>S</em>, <em>R</em>, and <em>T</em> have been pressed, which allow us to move forward and backwards, as well as rise up and down.</p><div><div><h3 class="title"><a id="note47"/>Note</h3><p>To allow easy conversion between the values returned from the <code class="literal">Keyboard</code> object and their equivalent meaning, we will use a Python dictionary:</p><p>
<code class="literal">KEY = {'R':114,'S':115,'T':116,'W':119,'ESC':27,'NONE':-1}</code>
</p><p>The dictionary provides an easy way to translate between a given value and the resulting string. To access a key's value, we use <code class="literal">KEY['W']</code>. We also used a dictionary in <a class="link" href="ch03.html" title="Chapter 3. Using Python for Automation and Productivity">Chapter 3</a>, <em>Displaying Photo Information in an Application</em>, to translate between the image Exif TAG names and IDs.</p></div></div><p>To ensure that we do not fall through the surface of the <code class="literal">ElevationMap</code> object when we move over it, we can use <code class="literal">mymap.calcHeight()</code> to provide us with the height of the terrain at a specific location (<code class="literal">x,y,z</code>). We can either follow the ground by ensuring the camera is set to equal this, or fly through the air by just ensuring that we never go below it. When we detect that we are on the ground, we ensure that we remain on the ground until we press <em>R</em> to rise again.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Building 3D maps and mazes</h1></div></div></div><p>We've seen that the Pi3D library can be used to create lots of interesting objects and environments. Using some of the more complex classes (or by constructing our own), whole custom spaces can be designed for the user to explore.</p><p>In the following example, we use a special module called <strong>Building</strong>, which has been designed to allow you to construct a whole building using a single image file to provide the layout:</p><div><img alt="Building 3D maps and mazes" src="img/6623_05_008.jpg"/><div><p>Explore the maze and find the sphere that marks the exit</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec100"/>Getting ready</h2></div></div></div><p>You will need to ensure that you have the following files in the <code class="literal">pi3d/textures</code> directory:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">squareblocksred.png</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">floor.png</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">inside_map0.png, inside_map1.png, inside_map2.png</code></li></ul></div><p>These files are available as part of the book's resources placed in <code class="literal">Chapter05\resource\source_files\textures</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec101"/>How to do it…</h2></div></div></div><p>Let's run the following <code class="literal">3dMaze.py</code> script by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we set up the keyboard, mouse, display, and settings for the model using the following code:<div><pre class="programlisting">#!/usr/bin/python3
"""Small maze game, try to find the exit
"""
from math import sin, cos, radians
import demo
import pi3d
from pi3d.shape.Building import Building, SolidObject
from pi3d.shape.Building import Size, Position

KEY = {'A':97,'D':100,'H':104,'R':114,'S':115,'T':116,
       'W':119,'ESC':27,'APOST':39,'SLASH':47,'NONE':-1}

# Setup display and initialise pi3d
DISPLAY = pi3d.Display.create()
#capture mouse and key presses
mykeys = pi3d.Keyboard()
mymouse = pi3d.Mouse(restrict = False)

#Load shader
shader = pi3d.Shader("uv_reflect")
flatsh = pi3d.Shader("uv_flat")
# Load textures
ceilingimg = pi3d.Texture("textures/squareblocks4.png")
wallimg = pi3d.Texture("textures/squareblocksred.png")
floorimg = pi3d.Texture("textures/dunes3_512.jpg")
bumpimg = pi3d.Texture("textures/mudnormal.jpg")
startimg = pi3d.Texture("textures/rock1.jpg")    
endimg = pi3d.Texture("textures/water.jpg")
# Create elevation map
mapwidth = 1000.0
mapdepth = 1000.0
#We shall assume we are using a flat floor in this example
mapheight = 0.0
mymap = pi3d.ElevationMap(mapfile="textures/floor.png",
                width=mapwidth, depth=mapdepth, height=mapheight,
                divx=64, divy=64)
mymap.set_draw_details(shader,[floorimg, bumpimg],128.0, 0.0)
levelList = ["textures/inside_map0.png","textures/inside_map1.png",
             "textures/inside_map2.png"]
avhgt = 5.0
aveyelevel = 4.0
MAP_BLOCK = 15.0
aveyeleveladjust = aveyelevel - avhgt/2
PLAYERHEIGHT = (mymap.calcHeight(5, 5) + avhgt/2)
#Start the player in the top-left corner
startpos = [(8*MAP_BLOCK),PLAYERHEIGHT,(8*MAP_BLOCK)]
endpos = [0,PLAYERHEIGHT,0] #Set the end pos in the centre
person = SolidObject("person", Size(1, avhgt, 1),
                Position(startpos[0],startpos[1],startpos[2]), 1)
#Add spheres for start and end, end must also have a solid object
#so we can detect when we hit it
startobject = pi3d.Sphere(name="start",x=startpos[0],
                          y=startpos[1]+avhgt,z=startpos[2])
startobject.set_draw_details(shader, [startimg, bumpimg],
                             32.0, 0.3)
endobject = pi3d.Sphere(name="end",x=endpos[0],
                        y=endpos[1],z=endpos[2])
endobject.set_draw_details(shader, [endimg, bumpimg], 32.0, 0.3)
endSolid = SolidObject("end", Size(1, avhgt, 1),
                Position(endpos[0],endpos[1],endpos[2]), 1)

mazeScheme = {"#models": 3,
      (1,None): [["C",2]],      #white cell : Ceiling
      (0,1,"edge"): [["W",1]],  #white cell on edge next
                                #   black cell : Wall
      (1,0,"edge"): [["W",1]],  #black cell on edge next
                                #   to white cell : Wall
      (0,1):[["W",0]]}          #white cell next
                                #   to black cell : Wall

details = [[shader, [wallimg], 1.0, 0.0, 4.0, 16.0],
            [shader, [wallimg], 1.0, 0.0, 4.0, 8.0],
            [shader, [ceilingimg], 1.0, 0.0, 4.0, 4.0]]

arialFont = pi3d.Font("fonts/FreeMonoBoldOblique.ttf",
                      "#ffffff", font_size=10)</pre></div></li><li class="listitem">We then create functions to allow us to reload the levels and display messages to the player using the following code:<div><pre class="programlisting">def loadLevel(next_level):
  print("&gt;&gt;&gt; Please wait while maze is constructed...")
  next_level=next_level%len(levelList)
  building = pi3d.Building(levelList[next_level], 0, 0, mymap,
      width=MAP_BLOCK, depth=MAP_BLOCK, height=30.0,
      name="", draw_details=details, yoff=-15, scheme=mazeScheme)
  return building

def showMessage(text,rot=0):
  message = pi3d.String(font=arialFont, string=text,
                        x=endpos[0],y=endpos[1]+(avhgt/4),
                        z=endpos[2], sx=0.05, sy=0.05,ry=-rot)
  message.set_shader(flatsh)
  message.draw()</pre></div></li><li class="listitem">Within the main function, we set up the 3D environment and draw all the objects using the following code:<div><pre class="programlisting">def main():
  #Load a level
  level=0
  building = loadLevel(level)
  lights = pi3d.Light(lightpos=(10, -10, 20),
                      lightcol =(0.7, 0.7, 0.7),
                      lightamb=(0.7, 0.7, 0.7))
  rot=0.0
  tilt=0.0
  #capture mouse movements
  mymouse.start()
  omx, omy = mymouse.position()

  CAMERA = pi3d.Camera.instance()
  while DISPLAY.loop_running() and not \
                               inputs.key_state("KEY_ESC"):
    CAMERA.reset()
    CAMERA.rotate(tilt, rot, 0)
    CAMERA.position((person.x(), person.y(),
                     person.z() - aveyeleveladjust))
    #draw objects
    person.drawall()
    building.drawAll()
    mymap.draw()
    startobject.draw()
    endobject.draw()
    #Apply the light to all the objects in the building
    for b in building.model:
      b.set_light(lights, 0)
    mymap.set_light(lights, 0)

	#Get mouse position
    mx, my = mymouse.position()
    rot -= (mx-omx)*0.8
    tilt += (my-omy)*0.8
    omx = mx
    omy = my
    xm = person.x()
    ym = person.y()
    zm = person.z()</pre></div></li><li class="listitem">Finally, we monitor for key presses, handle any collisions with objects, and move within the maze as follows:<div><pre class="programlisting">    #Read keyboard keys
    k = mykeys.read()
    if k == KEY['APOST']: #' Key
      tilt -= 2.0
    elif k == KEY['SLASH']: #/ Key
      tilt += 2.0
    elif k == KEY['A']:
      rot += 2.0
    elif k == KEY['D']:
      rot -= 2.0
    elif k == KEY['H']:
      #Use point_at as help - will turn the player to face
      #  the direction of the end point
      tilt, rot = CAMERA.point_at([endobject.x(), endobject.y(),
                                   endobject.z()])
    elif k == KEY['W']:
      xm -= sin(radians(rot))
      zm += cos(radians(rot))
    elif k == KEY['S']:
      xm += sin(radians(rot))
      zm -= cos(radians(rot))

    NewPos = Position(xm, ym, zm)
    collisions = person.CollisionList(NewPos)
    if collisions:
      #If we reach the end, reset to start position!
      for obj in collisions:
        if obj.name == "end":
          #Required to remove the building walls from the
          #  solidobject list
          building.remove_walls()
          showMessage("Loading Level",rot)
          DISPLAY.loop_running()
          level+=1
          building = loadLevel(level)
          showMessage("")
          person.move(Position(startpos[0],startpos[1],
                               startpos[2]))
    else:
      person.move(NewPos)
    
try:
  main()
finally:
  mykeys.close()
  mymouse.stop()
  DISPLAY.destroy()
  print("Closed Everything. END")
#End</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec102"/>How it works...</h2></div></div></div><p>We define many of the elements we used in the preceding examples, such as the display, textures, shaders, font, and lighting. We also define the objects, such as the building itself, the <code class="literal">ElevationMap</code> object, as well as the start and end points of the maze. We also use <strong>SolidObjects</strong> to help detect movement within the space. See the <em>Using SolidObjects to detect collisions</em> subsection in the <em>There's more…</em> section of this recipe for more information.</p><p>Finally, we create the actual <code class="literal">Building</code> object based on the selected map image (using the <code class="literal">loadLevel()</code> function) and locate the camera (which represents our first-person viewpoint) at the start. See the <em>The Building module</em> subsection in the <em>There's more…</em> section of this recipe for more information.</p><p>Within the <code class="literal">main</code> loop, we draw all the objects in our space and apply the lighting effects. We will also monitor for movement in the mouse (to control the tilt and rotation of the camera) or the keyboard to move the player (or exit/provide help).</p><p>The controls are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Mouse movement</strong>: This changes the camera tilt and rotation.</li><li class="listitem" style="list-style-type: disc"><strong>' or / key</strong>: This changes the camera to tilt either downwards or upwards.</li><li class="listitem" style="list-style-type: disc"><strong>A or D</strong>: This changes the camera to rotate from left to right or vice versa. </li><li class="listitem" style="list-style-type: disc"><strong>W or S</strong>: This moves the player forwards or backwards.</li><li class="listitem" style="list-style-type: disc"><strong>H</strong>: This helps the player by rotating them to face the end of the maze. The useful <code class="literal">CAMERA.point_at()</code> function is used to quickly rotate and tilt the camera's viewpoint towards the provided coordinates (the end position).</li></ul></div><p>Whenever the player moves, we check if the new position (<code class="literal">NewPos</code>) collides with another <code class="literal">SolidObject</code> using <code class="literal">CollisionList(NewPos)</code>. The function will return a list of any other SolidObjects that overlap the coordinates provided.</p><p>If there are no SolidObjects in the way, we make the player move; otherwise, we check to see if one of the SolidObject's names is the <code class="literal">end</code> object, in which case we have reached the end of the maze.</p><p>When the player reaches the end, we remove the walls from the old <code class="literal">Building</code> object and display a loading message. If we don't remove the walls, all the SolidObjects belonging to the previous <code class="literal">Building</code> will still remain, creating invisible obstacles in the next level.</p><p>We use the <code class="literal">showMessage()</code> function to inform the user that the next level will be loaded soon (since it can take a while for the building object to be constructed). We need to ensure that we call <code class="literal">DISPLAY.loop_running()</code> after we draw the message. This ensures it is displayed on screen before we start loading the level (after which the person will be unable to move while loading takes place). We need to ensure that the message is always facing the player regardless of which of their sides collides with the <code class="literal">end</code> object by using the camera rotation (<code class="literal">rot</code>) for its angle.</p><div><img alt="How it works..." src="img/6623_05_009.jpg"/><div><p>When the exit ball is found, the next level is loaded</p></div></div><p>When the next level in the list has been loaded (or the first level has been loaded again when all the levels have been completed), we replace the message with a blank one to remove it and reset the person's position back to the start.</p><p>You can design and add your own levels by creating additional map files (20 x 20 PNG files with walls marked out with black pixels and walkways in white) and listing them in <code class="literal">levelList</code>. The player will start at the top-left corner of the map, and the exit is placed at the center.</p><p>You will notice that loading the levels can take quite a long time; this is the relatively slow ARM processor in the Raspberry Pi performing all the calculations required to construct the maze and locate all the components. As soon as the maze has been built, the more powerful GPU takes over, which results in fast and smooth graphics as the player explores the space.</p><div><div><h3 class="title"><a id="note48"/>Note</h3><p>This recipe demonstrates the difference between the original Raspberry Pi processor and the Raspberry Pi 2. The Raspberry Pi 2 takes around 1 minute 20 seconds to load the first level, while the original Raspberry Pi can take up to 4 minutes 20 seconds. The Raspberry Pi 3 takes a stunning 4 seconds to load the same level.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec103"/>There's more...</h2></div></div></div><p>The preceding example creates a building for the player to explore and interact with. In order to achieve this, we use the <code class="literal">Building</code> module of Pi3D to create a building and use <code class="literal">SolidObject</code> to detect collisions.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec31"/>The Building module</h3></div></div></div><p>The <code class="literal">pi3d.Building</code> module allows you to define a whole level or floor of a building using map files. Like the terrain maps used in the preceding example, the color of the pixels will be converted into different parts of the level. In our case, black is for the walls and white is for the passages and halls, complete with ceilings:</p><div><img alt="The Building module" src="img/6623_05_010.jpg"/><div><p>The building layout is defined by the pixels in the image</p></div></div><p>The sections built by the <code class="literal">Building</code> object are defined by the <strong>Scheme</strong> used. The <code class="literal">Scheme</code> is defined by two sections, by the number of models, and then by the definitions for various aspects of the model, as seen in the following code:</p><div><pre class="programlisting">mazeScheme = {"#models": 3,
  (1,None): [["C",2]],     #white cell : Ceiling
  (0,1,"edge"): [["W",1]], #white cell on edge by black cell : Wall
  (1,0,"edge"): [["W",1]], #black cell on edge by white cell : Wall
  (0,1):[["W",0]]}         #white cell next to black cell : Wall </pre></div><p>The first <strong>tuple</strong> defines the type of cell/square that the selected model should be applied to. Since there are two pixel colors in the map, the squares will either be black (<code class="literal">0</code>) or white (<code class="literal">1</code>). By determining the position and type of a particular cell/square, we can define which models (wall, ceiling, or roof) we want to apply.</p><p>We define three main types of cell/square location:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A whole square <code class="literal">(1,None)</code>: This is a white cell representing open space in the building.</li><li class="listitem" style="list-style-type: disc">One cell bordering another, on the edge <code class="literal">(0,1,"edge")</code>: This is a black cell next to a white one on the map edge. This also includes <code class="literal">(1,0,"edge")</code>. This will represent the outer wall of the building.</li><li class="listitem" style="list-style-type: disc">Any black cell that is next to a white cell <code class="literal">(0,1)</code>: This will represent all the internal walls of the building.</li></ul></div><p>Next, we allocate a type of object(s) to be applied for that type (<code class="literal">W</code> or <code class="literal">C</code>):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Wall</strong> (<code class="literal">W</code>): This is a vertical wall that is placed between the specified cells (such as between black and white cells).</li><li class="listitem" style="list-style-type: disc"><strong>Ceiling</strong> (<code class="literal">C</code>): This is a horizontal section of the ceiling to cover the current cell.</li><li class="listitem" style="list-style-type: disc"><strong>Roof</strong> (<code class="literal">R</code>): This is an additional horizontal section that is placed slightly above the ceiling to provide a roofing effect. It is typically used for buildings that may need to be viewed from the outside (this is not used in our example).</li><li class="listitem" style="list-style-type: disc"><strong>Ceiling Edge</strong> (<code class="literal">CE</code>): This is used to join the ceiling sections to the roof around the edges of the building (it is not used in our example since ours is an indoor model).</li></ul></div><p>Finally, we specify the model that will be used for each object. We are using three models in this example (normal walls, walls on an edge, and the ceiling), so we can define the model used by specifying <code class="literal">0</code>, <code class="literal">1</code>, or <code class="literal">2</code>.</p><p>Each of the models are defined in the <code class="literal">details</code> array, which allows us to set the required textures and shaders for each one (this contains the same information that would normally be set by the <code class="literal">.set_draw_details()</code> function), as shown in the following code:</p><div><pre class="programlisting">details = [[shader, [wallimg], 1.0, 0.0, 4.0, 16.0],
           [shader, [wallimg], 1.0, 0.0, 4.0, 8.0],
           [shader, [ceilingimg], 1.0, 0.0, 4.0, 4.0]]</pre></div><p>In our example, the inside walls are allocated to the <code class="literal">wallimg</code> texture (<code class="literal">textures/squareblocksred.png</code>) and the ceilings are allocated to the <code class="literal">ceilingimg</code> texture (<code class="literal">textures/squareblocks4.png</code>). You may be able to note from the following screenshot that we can apply different texture models (in our case, a slightly different scaling) to the different types of blocks. The walls that border the outside of the maze (with the edge identifier) will use the <code class="literal">wallimg</code> model texture scaled by 4x8 (<code class="literal">details[1]</code>) while the same model texture will be scaled 4x16 for the internal walls (<code class="literal">details[0]</code>):</p><div><img alt="The Building module" src="img/6623_05_011.jpg"/><div><p>The outward facing wall on the left has a different scaling applied compared to the other walls</p></div></div><p>Both <code class="literal">scheme</code> and <code class="literal">draw_details</code> are set when the <code class="literal">pi3d.Building</code> object is created, as shown in the following code:</p><div><pre class="programlisting">building = pi3d.Building(levelList[next_level], 0, 0, mymap,width=MAP_BLOCK, depth=MAP_BLOCK, height=30.0, name="",draw_details=details, yoff=-15, scheme=mazeScheme)</pre></div><p>Using the map file (<code class="literal">levelList[next_level</code>]), the scheme (<code class="literal">mazeScheme</code>), and draw details (<code class="literal">details</code>), the entire building is<a class="indexterm" id="id357"/> created within the environment:</p><div><img alt="The Building module" src="img/6623_05_012.jpg"/><div><p>An overhead view of the 3D maze we created</p></div></div><div><div><h3 class="title"><a id="note49"/>Note</h3><p>Although we use just black and white in this example, other colored pixels can also be used to define additional block types (and therefore different textures, if required). If another color (such as gray) is added, the indexing of the color mapping is shifted so that black blocks are referenced as <code class="literal">0</code>, the new colored blocks as <code class="literal">1</code>, and the white blocks as <code class="literal">2</code>. See the <strong>Silo</strong> example in the Pi3D demos for details.</p><p>We also need to define an <code class="literal">ElevationMap</code> object—<code class="literal">mymap</code>. The <code class="literal">pi3d.Building</code> module makes use of the <code class="literal">ElevationMap</code> object's <code class="literal">calcHeight()</code> function to correctly place the walls on top of the <code class="literal">ElevationMap</code> object's surface. In this example, we will apply a basic <code class="literal">ElevationMap</code> object using <code class="literal">textures/floor.png</code>, which will generate a flat surface that the <code class="literal">Building</code> object will be placed on.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec32"/>Using SolidObjects to detect collisions</h3></div></div></div><p>In addition to <a class="indexterm" id="id358"/>the <code class="literal">Building</code> object, we will define an<a class="indexterm" id="id359"/> object for the player and also define two objects to mark the start and end points of the maze. Although the player's view is the first-person viewpoint (that is, we don't actually see them since the view is effectively through their eyes), we need to define a <strong>SolidObject</strong> to represent them.</p><p>A SolidObject is a special type of invisible object that can be checked to determine if the space that would be occupied by one SolidObject has overlapped another. This will allow us to use <code class="literal">person.CollisionList(NewPos)</code> to get a list of any other SolidObjects that the <code class="literal">person</code> object will be in contact with at the <code class="literal">NewPos</code> position. Since the <code class="literal">Building</code> class defines SolidObjects for all the parts of the <code class="literal">Building</code> object, we will be able to detect when the player tries to move through a wall (or, for some reason, the roof/ceiling) and stop them from moving through it.</p><p>We also use SolidObjects for the start and end locations in the maze. The place where the player starts is set as the top-left corner of the map (the white-space pixel from the top left of the map) and is marked by the <code class="literal">startpos</code> object (a small <code class="literal">pi3d.Sphere</code> with the <code class="literal">rock1.jpg</code> texture) placed above the person's head. The end of the maze is marked with another <code class="literal">pi3d.Sphere</code> object (with the <code class="literal">water.jpg</code> texture) located at the center of the map. We also define another SolidObject at the end so that we can detect when the player reaches it and collides with it (and load the next level!).</p></div></div></div></body></html>