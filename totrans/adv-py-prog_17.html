<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer179">
			<h1 id="_idParaDest-280"><em class="italic"><a id="_idTextAnchor261"/>Chapter 15</em>: The Global Interpreter Lock</h1>
			<p>One of the major players in Python concurrent programming is the <strong class="bold">Global Interpreter Lock</strong> (<strong class="bold">GIL</strong>). In this chapter, we will cover a definition and the purposes of the GIL and how it affects concurrent Python applications. The problems that the GIL poses for Python concurrent systems and the controversy around its implementation will also be discussed. Finally, we will mention some thoughts on how Python programmers and developers should think about, and interact with, the GIL.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Introducing the GIL</li>
				<li>The potential removal of the GIL from Python</li>
				<li>Working with the GIL</li>
			</ul>
			<p>While our discussions in this chapter will mostly be theoretical, we will be able to gain a deep insight into the ecosystem of concurrent programming in Python.</p>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor262"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the following GitHub repository: </p>
			<p><a href="https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter15">https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter15</a></p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor263"/>Introducing the GIL</h1>
			<p>The GIL is quite popular in the Python concurrent<a id="_idIndexMarker1092"/> programming community. Designed as a lock that will only allow one thread to access and control the Python interpreter at any given time, the GIL in Python is often known as <em class="italic">the infamous GIL</em> that prevents multithreaded<a id="_idIndexMarker1093"/> programs from reaching their fully optimized speed. </p>
			<p>In this section, we will discuss the concept behind the GIL, as well as its purpose: why it was designed and implemented<a id="_idIndexMarker1094"/> and how it affects multithreaded programming in Python.</p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor264"/>Analyzing memory management in Python</h2>
			<p>Before we jump into the specifics of the GIL and its effects, let's consider the problems that Python core developers<a id="_idIndexMarker1095"/> encountered during the early days of Python that gave rise to a need for the GIL. Specifically, there is a significant<a id="_idIndexMarker1096"/> difference between Python programming and programming in other popular languages, in terms<a id="_idIndexMarker1097"/> of managing objects in the memory space.</p>
			<p>For example, in the programming language C++, a variable is actually a location in the memory space where a value will be written. This setup leads to the fact that, when a non-pointer variable is assigned with a specific value, the programming language will effectively copy that specific<a id="_idIndexMarker1098"/> value to the memory location (that is, the <strong class="bold">variable</strong>). Additionally, when a variable is assigned with another variable (that is not a pointer), the memory location of the latter will be copied to that of the former; no further connection between these two variables will be maintained after the assignment.</p>
			<p>On the other hand, Python considers a variable as simply a name, while the actual values of its variables are isolated in another region in the memory space. When a value is assigned to a variable, the variable is effectively given a reference to the location in the memory space of the value (even though the term <em class="italic">referencing</em> is not used in the same sense as C++ referencing). Memory management in Python is, therefore, fundamentally different from the model of putting a value into a memory space that we see in C++.</p>
			<p>This means that when an assignment instruction is executed, Python simply interacts with references and switches them around—not the actual values themselves. Also, for this reason, multiple variables can be referenced by the same value, and the changes made by one variable will be reflected throughout all of the other associated variables.</p>
			<p>Let's analyze this feature in Python. If you have already downloaded the code for this book from the GitHub page, go ahead and navigate to the <strong class="source-inline">Chapter15</strong> folder. Let's take a look at the <strong class="source-inline">Chapter15/example1.py</strong> file here:</p>
			<p class="source-code">import sys</p>
			<p class="source-code">print(f'Reference count when direct-referencing:  \</p>
			<p class="source-code">  {sys.getrefcount([7])}.')</p>
			<p class="source-code">a = [7]</p>
			<p class="source-code">print(f'Reference count when referenced once:  \</p>
			<p class="source-code">  {sys.getrefcount(a)}.')</p>
			<p class="source-code">b = a</p>
			<p class="source-code">print(f'Reference count when referenced twice:  \</p>
			<p class="source-code">  {sys.getrefcount(a)}.')</p>
			<p class="source-code">###########################################################</p>
			<p class="source-code">a[0] = 8</p>
			<p class="source-code">print(f'Variable a after a is changed: {a}.')</p>
			<p class="source-code">print(f'Variable b after a is changed: {b}.')</p>
			<p class="source-code">print('Finished.')</p>
			<p>In this example, we are looking at the management of the value <strong class="source-inline">[7]</strong> (a list of one element: the integer <strong class="source-inline">7</strong>). We mentioned<a id="_idIndexMarker1099"/> that values in Python are stored<a id="_idIndexMarker1100"/> independently of variables, and value management in Python simply references variables to the appropriate values. The <strong class="source-inline">sys.getrefcount()</strong> method in Python takes in an object and returns the counter<a id="_idIndexMarker1101"/> of all references that the value associated with that object has. Here, we are calling <strong class="source-inline">sys.getrefcount()</strong> three times: on the actual value, <strong class="source-inline">[7]</strong>; the variable <strong class="source-inline">a</strong> that is assigned the value; and finally, the variable <strong class="source-inline">b</strong> that is assigned with the variable <strong class="source-inline">a</strong>.</p>
			<p>Additionally, we are exploring the process of mutating the value by using a variable referenced with it and the resulting values of all of the variables associated with that value. Specifically, we are mutating the first element of the list via variable <strong class="source-inline">a</strong>, and printing out the values of both <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>. Run the script, and your output should be similar to this:</p>
			<p class="source-code">&gt; python3 example1.py</p>
			<p class="source-code">Reference count when direct-referencing: 1.</p>
			<p class="source-code">Reference count when referenced once: 2.</p>
			<p class="source-code">Reference count when referenced twice: 3.</p>
			<p class="source-code">Variable a after a is changed: [8].</p>
			<p class="source-code">Variable b after a is changed: [8].</p>
			<p class="source-code">Finished.</p>
			<p>As you can see, this output<a id="_idIndexMarker1102"/> is consistent with what we discussed as the following ways:</p>
			<ol>
				<li>For the first <strong class="source-inline">sys.getrefcount()</strong> function call, there is only one reference count for the value <strong class="source-inline">[7]</strong>, which is created when we directly reference it.</li>
				<li>When we assign the list to variable <strong class="source-inline">a</strong>, the value has two references, since <strong class="source-inline">a</strong> is now associated with the value.</li>
				<li>Finally, when <strong class="source-inline">a</strong> is assigned to <strong class="source-inline">b</strong>, <strong class="source-inline">[7]</strong> is additionally referenced by <strong class="source-inline">b</strong>, and the reference count is now <strong class="source-inline">3</strong>.</li>
				<li>In the output<a id="_idIndexMarker1103"/> of the second part of the program, we can<a id="_idIndexMarker1104"/> see that when we changed the value of the variable that <strong class="source-inline">a</strong> references, <strong class="source-inline">[7]</strong> was mutated instead of variable <strong class="source-inline">a</strong>. As a result, variable <strong class="source-inline">b</strong>, which was referencing the same value as <strong class="source-inline">a</strong>, also had its value changed.</li>
			</ol>
			<p>The following diagram illustrates this process: </p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/Figure_15.1_B17499.jpg" alt="Figure 15.1 – Diagram of Python's referencing scheme " width="1499" height="586"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.1 – Diagram of Python's referencing scheme</p>
			<p>Overall, in Python programs, variables<a id="_idIndexMarker1105"/> simply make references to the actual<a id="_idIndexMarker1106"/> values (objects), and an assignment statement between two variables makes the two variables reference the same object, as opposed<a id="_idIndexMarker1107"/> to copying the actual value to another memory location, as in C++.</p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor265"/>The problem that the GIL addresses</h2>
			<p>Keeping Python's implementation<a id="_idIndexMarker1108"/> of memory and variable management in mind, we can see references to a given value in Python are constantly changing in a program, and keeping track of the reference count for a value is therefore highly important.</p>
			<p>Now, applying what you learned in <a href="B17499_14_Final_SS_ePub.xhtml#_idTextAnchor244"><em class="italic">Chapter 14</em></a>, <em class="italic">Race Conditions</em>, you should know that in a Python concurrent program, this reference count is a shared resource that needs protection from race conditions. In other words, this reference count is a critical section that, if handled carelessly, will result in an incorrect interpretation of how many variables are referencing a particular value. This will cause memory leaks that will make Python programs significantly inefficient and may even release a memory that is actually being referenced by some variables, losing that value forever.</p>
			<p>As you learned in the previous chapter, a solution to making sure that race conditions will not occur with regard to a particular shared resource is to place a lock on that resource, effectively allowing one thread, at the most, to access the resource at any given time within a concurrent program. We also discussed that if enough locks are placed in a concurrent program, that program will become entirely sequential, and no additional speed will be gained by implementing concurrency.</p>
			<p>The GIL is a solution to the combination of the two preceding problems, being one single lock on the entire execution of Python. The GIL must first be acquired by any Python instruction that wants to be executed (<strong class="bold">central processing unit</strong> (<strong class="bold">CPU</strong>)-bound tasks), preventing a race condition from occurring for any reference count.</p>
			<p>In the early days of the development<a id="_idIndexMarker1109"/> of the Python language, other solutions to the problem described here were also proposed, but the GIL was the most efficient and simple to implement, by far. Since the GIL is a lightweight, overarching lock for the entire execution of Python, no other lock needs to be implemented to guarantee the integrity of other critical sections, keeping the performance overhead of Python programs at a minimum.</p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor266"/>Problems raised by the GIL</h2>
			<p>Intuitively, with a lock guarding<a id="_idIndexMarker1110"/> all CPU-bound tasks in Python, a concurrent program will not be able to become fully multithreading. The GIL effectively prevents CPU-bound tasks from being executed in parallel across multiple threads. To understand the effect of this feature of the GIL, let's consider an example in Python. Navigate to <strong class="source-inline">Chapter15/example2.py</strong>, which has the following content:</p>
			<p class="source-code">import time</p>
			<p class="source-code">import threading</p>
			<p class="source-code">COUNT = 50000000</p>
			<p class="source-code">def countdown(n):</p>
			<p class="source-code">    while n &gt; 0:</p>
			<p class="source-code">        n -= 1</p>
			<p class="source-code">###########################################################</p>
			<p class="source-code">start = time.time()</p>
			<p class="source-code">countdown(COUNT)</p>
			<p class="source-code">print('Sequential program finished.')</p>
			<p class="source-code">print(f'Took {time.time() - start : .2f} seconds.')</p>
			<p class="source-code">###########################################################</p>
			<p class="source-code">thread1 = threading.Thread(target=countdown, args=(  \</p>
			<p class="source-code">  COUNT // 2,))</p>
			<p class="source-code">thread2 = threading.Thread(target=countdown, args=(  \</p>
			<p class="source-code">  COUNT // 2,))</p>
			<p class="source-code">start = time.time()</p>
			<p class="source-code">thread1.start()</p>
			<p class="source-code">thread2.start()</p>
			<p class="source-code">thread1.join()</p>
			<p class="source-code">thread2.join()</p>
			<p class="source-code">print('Concurrent program finished.')</p>
			<p class="source-code">print(f'Took {time.time() - start : .2f} seconds.')</p>
			<p>In this example, we are comparing the speed of executing a particular program in Python sequentially and concurrently, via multithreading. Specifically, we have a function named <strong class="source-inline">countdown()</strong> that simulates a heavy CPU-bound task, which takes in a number, <strong class="source-inline">n</strong>, and decrements it until it becomes zero or negative. We then call <strong class="source-inline">countdown()</strong> on <strong class="source-inline">50,000,000</strong> once, as a sequential program. Finally, we call the function twice, each in a separate thread, on <strong class="source-inline">25,000,000</strong>, which is exactly half of <strong class="source-inline">50,000,000</strong>; this is the multithreading version of the program. We are also keeping track of the time it takes for Python<a id="_idIndexMarker1111"/> to run both the sequential program and the multithreading program.</p>
			<p>Theoretically, the multithreading version of the program should take half as long as the sequential version, as the task is effectively being split in half and run in parallel, via the two threads that we created. However, the output produced by the program would suggest otherwise. The following output is what I obtained through running the script:</p>
			<p class="source-code">&gt; python3 example2.py</p>
			<p class="source-code">Sequential program finished.</p>
			<p class="source-code">Took 2.80 seconds.</p>
			<p class="source-code">Concurrent program finished.</p>
			<p class="source-code">Took 2.74 seconds.</p>
			<p>Contrary to what we predicted, the concurrent version of the countdown took almost as long as the sequential version; multithreading did not offer any considerable speedup for our program. This is a direct effect of having the GIL guarding CPU-bound tasks, as multiple threads are not allowed to run simultaneously. Sometimes, a multithreading program can take even longer to complete its execution than its sequential counterpart, since there is also the overhead of acquiring and releasing the GIL.</p>
			<p>This is undoubtedly a significant problem for multithreading, and for concurrent programming in Python in general, because as long as a program contains CPU-bound instructions, those instructions will, in fact, be sequential in the execution of the program. However, instructions that are not CPU-bound happen outside the GIL, and thus they are not affected by the GIL (for example, <strong class="bold">input/output</strong> (<strong class="bold">I/O</strong>)-bound instructions).</p>
			<p>With these problems identified, let's next see what the infamous GIL is.</p>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor267"/>The potential removal of the GIL from Python</h1>
			<p>You have learned that the GIL sets a significant constraint on our multithreading programs in Python, especially those with CPU-bound tasks. For this reason, many Python developers have come to view the GIL in a negative light, and the term <em class="italic">the infamous GIL</em> has started to become popular. It is not surprising, then, that some have even advocated the complete removal<a id="_idIndexMarker1112"/> of the GIL from the Python language.</p>
			<p>In fact, multiple attempts to remove the GIL have been made by prominent Python users. However, the GIL is so deeply implanted in the implementation of the language, and the execution of most libraries and packages that are not thread-safe is so significantly dependent on the GIL, that the removal of the GIL will actually engender bugs as well as backward-incompatibility issues for your Python programs. A number of Python developers and researchers tried to completely omit the GIL from Python execution, and most existing C extensions, which depend heavily on the functionalities of the GIL, stopped working.</p>
			<p>Now, there are other viable solutions to address the problems that we have discussed; in other words, the GIL is in every way replaceable. However, most of these solutions contain so many complex instructions that they actually decrease the performance of sequential and I/O-bound programs, which are not affected by the GIL. So, these solutions will slow down single-threaded or multithreaded I/O programs, which actually make up a large percentage of existing Python applications. Interestingly, the creator of Python, Guido van Rossum, also commented on this topic in his article <em class="italic">It isn't Easy to Remove the GIL</em>, as follows:</p>
			<p class="author-quote">"I'd welcome a set of patches into Py3k only if the performance for a single-threaded program (and for a multi-threaded but I/O-bound program) does not decrease."</p>
			<p>Unfortunately, this request has not been achieved by any of the proposed alternatives to the GIL. The GIL remains an integral part of the Python language.</p>
			<p>With this covered, let's now see how to work with the GIL.</p>
			<h1 id="_idParaDest-287"><a id="_idTextAnchor268"/>Working with the GIL</h1>
			<p>There are a few ways to deal with the GIL in your Python<a id="_idIndexMarker1113"/> applications, and these will be addressed in the following sections.</p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor269"/>Implementing multiprocessing, rather than multithreading </h2>
			<p>This is perhaps the most popular and easiest method to circumvent the GIL and achieve optimal speed in a concurrent<a id="_idIndexMarker1114"/> program. As the GIL only prevents multiple threads from executing CPU-bound tasks simultaneously, processes<a id="_idIndexMarker1115"/> executing over multiple cores of a system, each having its own memory space, are completely immune to the GIL.</p>
			<p>Specifically, considering the preceding countdown example, let's compare the performance of that CPU-bound program when it is sequential, multithreading, and multiprocessing. Navigate to the <strong class="source-inline">Chapter15/example3.py</strong> file. The first part of the program is identical to what we saw earlier, but at the end, we add in an implementation of a multiprocessing solution for the problem of counting down from 50,000,000, using two separate processes, as follows:</p>
			<p class="source-code">COUNT = 50000000</p>
			<p class="source-code">def countdown(n):</p>
			<p class="source-code">    while n &gt; 0:</p>
			<p class="source-code">        n -= 1</p>
			<p class="source-code">if __name__ == '__main__':</p>
			<p class="source-code">    #######################################################</p>
			<p class="source-code">    # Sequential</p>
			<p class="source-code">    start = time.time()</p>
			<p class="source-code">    countdown(COUNT)</p>
			<p class="source-code">    #######################################################</p>
			<p class="source-code">    # Multithreading</p>
			<p class="source-code">    thread1 = threading.Thread(target=countdown,  \</p>
			<p class="source-code">      args=(COUNT // 2,))</p>
			<p class="source-code">    thread2 = threading.Thread(target=countdown,  \</p>
			<p class="source-code">      args=(COUNT // 2,))</p>
			<p class="source-code">    start = time.time()</p>
			<p class="source-code">    thread1.start()</p>
			<p class="source-code">    thread2.start()</p>
			<p class="source-code">    thread1.join()</p>
			<p class="source-code">    thread2.join()</p>
			<p class="source-code">    #######################################################</p>
			<p class="source-code">    # Multiprocessing</p>
			<p class="source-code">    pool = Pool(processes=2)</p>
			<p class="source-code">    start = time.time()</p>
			<p class="source-code">    pool.apply_async(countdown, args=(COUNT//2,))</p>
			<p class="source-code">    pool.apply_async(countdown, args=(COUNT//2,))</p>
			<p class="source-code">    pool.close()</p>
			<p class="source-code">    pool.join()</p>
			<p>After running<a id="_idIndexMarker1116"/> the program, this was<a id="_idIndexMarker1117"/> my output:</p>
			<p class="source-code">&gt; python3 example3.py</p>
			<p class="source-code">Sequential program finished.</p>
			<p class="source-code">Took 2.95 seconds.</p>
			<p class="source-code">Multithreading program finished.</p>
			<p class="source-code">Took 2.69 seconds.</p>
			<p class="source-code">Multiprocessing program finished.</p>
			<p class="source-code">Took 1.54 seconds.</p>
			<p>There is still a minimal difference in speed between the sequential and multithreading versions of the program. However, the multiprocessing version was able to cut that speed by almost half in its execution. As discussed in earlier chapters, since processes are fairly heavyweight, multiprocessing instructions contain significant overhead, which is the reason why the speed<a id="_idIndexMarker1118"/> of the multiprocessing program was<a id="_idIndexMarker1119"/> not exactly half of the sequential program.</p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor270"/>Getting around the GIL with native extensions</h2>
			<p>There are Python-native extensions that are written in C/C++ and are therefore able to avoid the limitations that the GIL<a id="_idIndexMarker1120"/> sets out; one example is the most popular Python scientific computing package, NumPy. Within these extensions, manual releases of the GIL can be made so that the execution can simply bypass the lock. However, these releases need to be implemented carefully and accompanied by the reassertion of the GIL before the execution goes back to the main Python execution.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor271"/>Utilizing a different Python interpreter</h2>
			<p>The GIL only exists in CPython, which<a id="_idIndexMarker1121"/> is the most common interpreter for the language by far and is built in C. However, there are other interpreters for Python, such as Jython (written in Java) and IronPython (written in C++), that can be used to avoid the GIL and its effects on multithreading programs. Keep in mind that these interpreters<a id="_idIndexMarker1122"/> are not as widely used as CPython, and some packages and libraries might not be compatible with one or both of what? please clarify.</p>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor272"/>Summary</h1>
			<p>While the GIL in Python offers a simple and intuitive solution to one of the more difficult problems in the language, it also raises a number of problems of its own, concerning the ability to run multiple threads in a Python program to process CPU-bound tasks. Multiple attempts have been made to remove the GIL from the main implementation of Python, but none has been able to achieve it while maintaining the effectiveness of processing non-CPU-bound tasks, which are affected by the GIL.</p>
			<p>Overall, we have discussed practical methods that make working with the GIL easier. We have also learned that while it possesses considerable notoriety among the Python community, the GIL only affects a certain portion of the ecosystem. This should better inform our opinion about the GIL.</p>
			<p>In the last four chapters, we discussed some of the most well-known and common problems in concurrent programming in Python. For the remainder of the book, we will be looking at a different topic—advanced design patterns in Python. In the next chapter, we will start with the <em class="italic">factory</em> pattern.</p>
			<h1 id="_idParaDest-292"><a id="_idTextAnchor273"/>Questions</h1>
			<ol>
				<li value="1">What are the differences in memory management between Python and C++?</li>
				<li>Which problem does the GIL solve for Python?</li>
				<li>Which problem does the GIL create for Python?</li>
				<li>What are some of the approaches to circumventing the GIL in Python programs?</li>
			</ol>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor274"/>Further reading</h1>
			<p>For more information, you can refer to the following sources:</p>
			<ul>
				<li><em class="italic">What Is the Python Global Interpreter Lock (GIL)?</em> (<a href="http://realpython.com/python-gil/">realpython.com/python-gil/</a>), <em class="italic">Abhinav Ajitsaria</em></li>
				<li><em class="italic">The Python GIL Visualized</em> (<a href="http://dabeaz.blogspot.com/2010/01/python-gil-visualized">dabeaz.blogspot.com/2010/01/python-gil-visualized</a>), <em class="italic">Dave Beazley</em></li>
				<li><em class="italic">Copy Operations in Python</em> (<a href="http://pythontic.com/modules/copy/introduction">pythontic.com/modules/copy/introduction</a>)</li>
				<li><em class="italic">It isn't Easy to Remove the GIL</em> (<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=214235">www.artima.com/weblogs/viewpost.jsp?thread=214235</a>), <em class="italic">Guido van Rossum</em></li>
				<li><em class="italic">Parallel Programming with Python</em>, by <em class="italic">Jan Palach</em>, <em class="italic">Packt Publishing Ltd</em> (2014)</li>
				<li><em class="italic">Learning Concurrency in Python: Build highly efficient, robust, and concurrent applications</em>, <em class="italic">Elliot Forbes</em> (2017)</li>
			</ul>
		</div>
	</div>
</div>
</body></html>