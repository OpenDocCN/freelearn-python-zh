["```py\n    HashSet<string, int> mySet = new HashSet<string>(); \n    mySet.Add(\"green\");  \n    Console.WriteLine(\"{0}\", mySet.Count); \n    mySet.Add(\"yellow\");  \n    Console.WriteLine(\"{0}\", mySet.Count); \n    mySet.Add(\"red\");  \n    Console.WriteLine(\"{0}\", mySet.Count); \n    mySet.Add(\"red\");  \n    Console.WriteLine(\"{0}\", mySet.Count); \n    mySet.Add(\"blue\");  \n    Console.WriteLine(\"{0}\", mySet.Count); \n\n    /* Output:  \n    1 \n    2 \n    3 \n    3 since \"red\" already exists in the collection \n    4 \n    */ \n\n```", "```py\n    HashSet<String> mySet = new HashSet< >(); \n    mySet.add(\"green\");  \n    System.out.println(mySet.size()); \n    mySet.add(\"yellow\");  \n    System.out.println(mySet.size()); \n    mySet.add(\"red\");  \n    System.out.println(mySet.size()); \n    mySet.add(\"red\");  \n    System.out.println(mySet.size()); \n    mySet.add(\"blue\");  \n    System.out.println(mySet.size()); \n\n    /* Output:  \n    1 \n    2 \n    3 \n    3 since \"red\" already exists in the collection \n    4 \n    */ \n\n```", "```py\n    NSMutableSet *mySet = [NSMutableSet set]; \n    [mySet addObject:@\"green\"]; \n    NSLog(@\"%li\", (long)[mySet count]);  \n    [mySet addObject:@\"yellow\"]; \n    NSLog(@\"%li\", (long)[mySet count]); \n    [mySet addObject:@\"red\"]; \n    NSLog(@\"%li\", (long)[mySet count]); \n    [mySet addObject:@\"red\"]; \n    NSLog(@\"%li\", (long)[mySet count]); \n    [mySet addObject:@\"blue\"]; \n    NSLog(@\"%li\", (long)[mySet count]);  \n\n    /* Output:  \n    1 \n    2 \n    3 \n    3 since \"red\" already exists in the collection \n    4 \n    */ \n\n```", "```py\n    let mySet: Set<String> = Set<String>() \n    mySet.insert(@\"green\")  \n    print(mySet.count)  \n    mySet.insert(@\"yellow\")  \n    print(mySet.count) \n    mySet.insert(@\"red\")  \n    print(mySet.count) \n    mySet.insert(@\"red\")  \n    print(mySet.count) \n    mySet.insert(@\"blue\")  \n    print(mySet.count)  \n\n    /* Output:  \n    1 \n    2 \n    3 \n    3 since \"red\" already exists in the collection \n    4 \n    */ \n\n```", "```py\n    public class LoggedInUserSet \n    { \n        HashSet<User> _users; \n\n        public LoggedInUserSet() \n        { \n            _users = new HashSet<User>(); \n        } \n\n        public bool UserAuthenticated(User user) \n        { \n            if (_users.Count < 30) \n            { \n                return _users.Add(user); \n            } \n            return false; \n        } \n\n        public void UserLoggedOut(User user) \n        { \n            _users.Remove(user); \n        } \n    } \n\n```", "```py\n    HashSet<User> _users; \n\n    public LoggedInUserSet() \n    { \n        _users = new HashSet<User>(); \n    } \n\n    public boolean userAuthenticated(User user) \n    { \n        if (_users.size() < 30) \n        { \n            return _users.add(user); \n        } \n        return false; \n    } \n\n    public void userLoggedOut(User user) \n    { \n        _users.remove(user); \n    } \n\n```", "```py\n    @interface EDSLoggedInUserSet() \n    { \n        NSMutableSet *_users; \n    } \n    @end \n\n    @implementation EDSLoggedInUserSet \n    -(instancetype)init \n    { \n        if (self = [super init]) \n        { \n            _users = [NSMutableSet set]; \n        } \n        return self; \n    } \n\n    -(void)userAuthenticated:(EDSUser *)user \n    { \n        if ([_users count] < 30) \n        { \n            [_users addObject:user]; \n        } \n    } \n\n    -(void)userLoggedOut:(EDSUser *)user \n    { \n        [_users removeObject:user]; \n    } \n\n```", "```py\n    var _users: Set<User> = Set<User>() \n\n    public func userAuthenticated(user: User) \n    { \n        if (_users.count < 30) \n        { \n            _users.insert(user) \n        } \n    } \n\n    public func userLoggedOut(user: User) \n    { \n        if let index = _users.indexOf(user) \n        { \n            _users.removeAtIndex(index) \n        } \n    } \n\n```", "```py\n    HashSet<Song> _songs; \n    public Int16 capacity { get; private set; } \n    public bool premiumUser { get; private set; } \n    public bool isEmpty  \n    { \n        get \n        { \n            return _songs.Count == 0; \n        } \n    } \n\n    public bool isFull \n    { \n        get \n        { \n            if (this.premiumUser) \n            { \n                return false; \n            } \n            else \n            { \n                return _songs.Count == this.capacity; \n            } \n        } \n    } \n\n    public PlaylistSet(bool premiumUser, Int16 capacity) \n    { \n        _songs = new HashSet<Song>(); \n        this.premiumUser = premiumUser; \n        this.capacity = capacity;  \n    } \n\n```", "```py\n    public bool AddSong(Song song) \n    { \n        if (!this.isFull) \n        { \n            return _songs.Add(song); \n        } \n        return false; \n    } \n\n```", "```py\n    public bool RemoveSong(Song song) \n    { \n        return _songs.Remove(song); \n    } \n\n```", "```py\n    public void MergeWithPlaylist(HashSet<Song> playlist) \n    { \n        _songs.UnionWith(playlist); \n    } \n\n```", "```py\n    public HashSet<Song> FindSharedSongsInPlaylist(HashSet<Song> playlist) \n    { \n        HashSet<Song> songsCopy = new HashSet<Song>(_songs); \n        songsCopy.IntersectWith(playlist); \n        return songsCopy; \n    } \n\n```", "```py\n    public HashSet<Song> FindUniqueSongs(HashSet<Song> playlist) \n    { \n        HashSet<Song> songsCopy = new HashSet<Song>(_songs); \n        songsCopy.ExceptWith(playlist); \n        return songsCopy; \n    } \n\n```", "```py\n    public bool IsSubset(HashSet<Song> playlist) \n    { \n        return _songs.IsSubsetOf(playlist); \n    } \n\n    public bool IsSuperset(HashSet<Song> playlist) \n    { \n        return _songs.IsSupersetOf(playlist); \n    } \n\n```", "```py\n    public int TotalSongs() \n    { \n        return _songs.Count; \n    } \n\n```", "```py\n\n    private HashSet<Song> _songs; \n    public int capacity; \n    public boolean premiumUser; \n    public boolean isEmpty() \n    { \n        return _songs.size() == 0; \n    } \n\n    public boolean isFull() \n    { \n        if (this.premiumUser) \n        { \n            return false; \n        } \n        else { \n            return _songs.size() == this.capacity; \n        } \n    } \n\n    public PlaylistSet(boolean premiumUser, int capacity) \n    { \n        _songs = new HashSet<>(); \n        this.premiumUser = premiumUser; \n        this.capacity = capacity; \n    } \n\n```", "```py\n    public boolean addSong(Song song) \n    { \n        if (!this.isFull()) \n        { \n            return _songs.add(song); \n        } \n        return false; \n    } \n\n```", "```py\n    public boolean removeSong(Song song) \n    { \n        return _songs.remove(song); \n    } \n\n```", "```py\n    public void mergeWithPlaylist(HashSet<Song> playlist) \n    { \n        _songs.addAll(playlist); \n    } \n\n```", "```py\n    public HashSet<Song> findSharedSongsInPlaylist(HashSet<Song> playlist) \n    { \n        HashSet<Song> songsCopy = new HashSet<>(_songs); \n        songsCopy.retainAll(playlist); \n        return songsCopy; \n    } \n\n```", "```py\n    public HashSet<Song> findUniqueSongs(HashSet<Song> playlist) \n    { \n        HashSet<Song> songsCopy = new HashSet<>(_songs); \n        songsCopy.removeAll(playlist); \n        return songsCopy; \n    } \n\n```", "```py\n    public boolean isSubset(HashSet<Song> playlist) \n    { \n        return _songs.containsAll(playlist); \n    } \n\n    public boolean isSuperset(HashSet<Song> playlist) \n    { \n        return playlist.containsAll(_songs); \n    } \n\n```", "```py\n    public int totalSongs() \n    { \n        return _songs.size(); \n    } \n\n```", "```py\n    @interface EDSPlaylistSet() \n    { \n        NSMutableSet<EDSSong*>* _songs; \n        NSInteger _capacity; \n        BOOL _premiumUser; \n        BOOL _isEmpty; \n        BOOL _isFull; \n    } \n    @end \n\n    @implementation EDSPlaylistSet \n\n    -(instancetype)playlistSetWithPremiumUser:(BOOL)isPremiumUser andCapacity:(NSInteger)capacity \n    { \n        if (self == [super init]) \n        { \n            _songs = [NSMutableSet set]; \n            _premiumUser = isPremiumUser; \n            _capacity = capacity; \n        } \n        return self;  \n    } \n\n    -(BOOL)isEmpty \n    { \n        return [_songs count] == 0; \n    } \n\n    -(BOOL)isFull \n    { \n        if (_premiumUser) \n        { \n            return NO; \n        } \n        else \n        { \n            return [_songs count] == _capacity; \n        } \n    } \n\n```", "```py\n    -(BOOL)addSong:(EDSSong*)song \n    { \n        if (!_isFull && ![_songs containsObject:song]) \n        { \n            [_songs addObject:song]; \n            return YES; \n        } \n        return NO; \n    } \n\n```", "```py\n    -(BOOL)removeSong:(EDSSong*)song \n    { \n        if ([_songs containsObject:song]) \n        { \n            [_songs removeObject:song]; \n            return YES; \n        } \n        else \n        { \n            return NO; \n        } \n    } \n\n```", "```py\n    -(void)mergeWithPlaylist:(NSMutableSet<EDSSong*>*)playlist \n    { \n        [_songs unionSet:playlist]; \n    } \n\n```", "```py\n    -(NSMutableSet<EDSSong*>*)findSharedSongsInPlaylist: (NSMutableSet<EDSSong*>*)playlist \n    { \n        NSMutableSet *songsCopy = [NSMutableSet setWithSet:_songs]; \n        [songsCopy intersectSet:playlist]; \n        return songsCopy; \n    } \n\n```", "```py\n    -(NSMutableSet<EDSSong*>*)findUniqueSongs:(NSMutableSet<EDSSong*>*)playlist \n    { \n        NSMutableSet *songsCopy = [NSMutableSet setWithSet:_songs]; \n        [songsCopy minusSet:playlist]; \n        return songsCopy; \n    } \n\n```", "```py\n    -(BOOL)isSubset:(NSMutableSet<EDSSong*>*)playlist \n    { \n        return [_songs isSubsetOfSet:playlist];  \n    } \n\n    -(BOOL)isSuperset:(NSMutableSet<EDSSong*>*)playlist \n    { \n        return; \n    } \n\n```", "```py\n    -(NSInteger)totalSongs \n    { \n        return [_songs count]; \n    } \n\n```", "```py\n    var _songs: Set<Song> = Set<Song>() \n\n    public private(set) var _capacity: Int \n    public private(set) var _premiumUser: Bool \n    public private(set) var _isEmpty: Bool \n    public private(set) var _isFull: Bool \n\n    public init (capacity: Int, premiumUser: Bool) \n    { \n        _capacity = capacity \n        _premiumUser = premiumUser \n        _isEmpty = true \n        _isFull = false \n    } \n\n    public func premiumUser() -> Bool \n    { \n        return _premiumUser \n    } \n\n    public func isEmpty() -> Bool \n    { \n        return _songs.count == 0 \n    } \n\n    public func isFull() -> Bool \n    { \n        if (_premiumUser) \n        { \n            return false \n        } \n        else \n        { \n            return _songs.count == _capacity \n        } \n    } \n\n```", "```py\n    public func addSong(song: Song) -> Bool \n    { \n        if (!_isFull && !_songs.contains(song)) \n        { \n            _songs.insert(song) \n            return true \n        } \n        return false \n    } \n\n```", "```py\n    public func removeSong(song: Song) -> Bool \n    { \n        if (_songs.contains(song)) \n        { \n            _songs.remove(song) \n            return true \n        } \n        else \n        { \n            return false \n        } \n    } \n\n```", "```py\n    public func mergeWithPlaylist(playlist: Set<Song>) \n    { \n        _songs.unionInPlace(playlist) \n    } \n\n```", "```py\n    public func findSharedSongsInPlaylist(playlist: Set<Song>) -> Set<Song> \n    { \n        return _songs.intersect(playlist) \n    } \n\n```", "```py\n    public func findUniqueSongs(playlist: Set<Song>) -> Set<Song> \n    { \n        return _songs.subtract(playlist) \n    } \n\n```", "```py\n    public func isSubset(playlist: Set<Song>) -> Bool \n    { \n        return _songs.isSubsetOf(playlist) \n    } \n\n    public func isSuperset(playlist: Set<Song>) -> Bool \n    { \n        return _songs.isSupersetOf(playlist) \n    } \n\n```", "```py\n    public func totalSongs() -> Int \n    { \n        return _songs.count; \n    } \n\n```"]